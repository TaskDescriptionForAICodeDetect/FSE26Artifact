[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n  val Array(w, h) = readLine.trim.split(' ').map(_.toInt)\n  val arg = Array.tabulate(h){ _ ⇒ readLine.trim}\n  val start = (0 until h).flatMap(y ⇒ (0 until w).find(x ⇒ arg(y)(x) == 's').map(x ⇒ Coordinate(x, y))).head\n  val goal = (0 until h).flatMap(y ⇒ (0 until w).find(x ⇒ arg(y)(x) == 'g').map(x ⇒ Coordinate(x, y))).head\n  val state = arg.map{line ⇒ line.map{\n    case '#' ⇒ Wall\n    case '.' | 's' ⇒ Empty\n    case 'g' ⇒ Stair\n    case '*' ⇒ Spring\n    case _ ⇒ ???\n  }.toArray}\n  val minFromGoal = Array.fill(h){Array.fill(w){Double.MaxValue / 3}}\n  minFromGoal(goal.y)(goal.x) = 0\n  val queue = mutable.Queue[Coordinate](goal)\n  while (queue.nonEmpty) {\n    val current = queue.dequeue()\n    for (next ← current.neighbor if (0 until h).contains(next.y) && (0 until w).contains(next.x) && state(next.y)(next.x) == Empty) {\n      if (minFromGoal(next.y)(next.x) > minFromGoal(current.y)(current.x) + 1) {\n        minFromGoal(next.y)(next.x) = minFromGoal(current.y)(current.x) + 1\n        queue.enqueue(next)\n      }\n    }\n  }\n  val minToSpring = Array.fill(h){Array.fill(w){Double.MaxValue / 3}}\n  for (spring ← (0 until h).flatMap(y ⇒ (0 until w).collect{case x if state(y)(x) == Spring ⇒ Coordinate(x, y)})){\n    minToSpring(spring.y)(spring.x) = 0\n    queue.enqueue(spring)\n  }\n  while(queue.nonEmpty) {\n    val current = queue.dequeue()\n    for (next ← current.neighbor if (0 until h).contains(next.y) && (0 until w).contains(next.x) && state(next.y)(next.x) == Empty) {\n      if (minToSpring(next.y)(next.x) > minToSpring(current.y)(current.x) + 1) {\n        minToSpring(next.y)(next.x) = minToSpring(current.y)(current.x) + 1\n        queue.enqueue(next)\n      }\n    }\n  }\n  val empties = (0 until h).flatMap(y ⇒ (0 until w).collect{case x if state(y)(x) == Empty ⇒ Coordinate(x, y)})\n  var min = 0d\n  var max = Double.MaxValue / 2\n  while (min * 1.000000000000001d < max) {\n    val mid = (min + max) / 2\n    if (canReach(mid)) max = mid\n    else min = mid\n  }\n  println(f\"${math.min(minToSpring(start.y)(start.x) + max, minFromGoal(start.y)(start.x))}%.12f\")\n  def canReach(estimated: Double): Boolean = empties.map{case Coordinate(x, y) ⇒ math.min(minToSpring(y)(x) + estimated, minFromGoal(y)(x))}.sum <= estimated * empties.length\n  sealed trait State\n  case object Spring extends State\n  case object Wall extends State\n  case object Empty extends State\n  case object Stair extends State\n  case class Coordinate(x: Int, y: Int) {\n    def neighbor: List[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n  }\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\nchar c[523][523];\n\ntemplate<class A>\nvoid bfs(A &ds,queue<tuple<int,int,int> > que){\n  fill(*begin(ds),*end(ds),1e4);\n  while(!que.empty()){\n    auto cs=que.front();\n    que.pop();\n    int t=get<0>(cs);\n    int y=get<1>(cs);\n    int x=get<2>(cs);\n    if(ds[y][x]<=t)continue;\n    ds[y][x]=t;\n    for(int i=0;i<4;i++){\n      static const int d[]={0,1,0,-1,0};\n      int ny=y+d[i];\n      int nx=x+d[i+1];\n      if(c[ny][nx]!='#'){\n\tque.push(make_tuple(t+1,ny,nx));\n      }\n    }\n  }\n}\n\nint main(){\n  int W,H;\n  cin>>W>>H;\n  queue<tuple<int,int,int> > sque,gque;\n  int sy,sx;\n  int n=0;\n  for(int i=0;i<H;i++){\n    cin>>c[i];\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='s'){\n\tc[i][j]='.';\n\tsy=i;\n\tsx=j;\n      }else if(c[i][j]=='*'){\n\tsque.push(make_tuple(0,i,j));\n      }else if(c[i][j]=='g'){\n\tgque.push(make_tuple(0,i,j));\n      }\n      n+=c[i][j]=='.';\n    }\n  }\n  static int ds[523][523];\n  bfs(ds,sque);\n  static int dg[523][523];\n  bfs(dg,gque);\n  int gsum=0,ssum=0;\n  int xsum=0;\n  int gs[2555]={},ss[2555]={};\n  int xs[2555]={};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='.'){\n\tint cx=min(2500,max(0,dg[i][j]-ds[i][j]));\n\tgsum+=dg[i][j];\n\tgs[cx]+=dg[i][j];\n\tss[cx]+=ds[i][j];\n\txs[cx]++;\n      }\n    }\n  }\n  double ans=1e9;\n  for(int i=2500;i>=0;i--){\n    gsum-=gs[i];\n    ssum+=ss[i];\n    xsum+=xs[i];\n    if(xsum==n)continue;\n    ans=min(ans,(dg[sy][sx]-ds[sy][sx]>=i)?ds[sy][sx]+(gsum+ssum)*1./(n-xsum):dg[sy][sx]);\n  }\n  cout.precision(99);\n  cout<<fixed<<ans<<endl;\n}\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=INF;\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=100000000000,lower=0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) sum+=min((double)dist_goal[y][x],dist_spring[y][x]+E);\n\t\t\t\telse sum+=dist_spring[y][x]+E;\n\t\t\t}\n\t\t}\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e30), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 1000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing dbl = long double;\nusing Pi = pair<int, int>;\n\nconst dbl eps = 1e-9;\n#define lt(a, b) ((a)-(b) < -eps)\n#define eq(a, b) (fabs((a)-(b)) < eps)\n\nint W, H;\nchar mas[505][505];\nPi S, G;\nvector<Pi> Bs;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nvector<vector<dbl> > bfs(const vector<Pi>& s) {\n  queue<Pi> que;\n  vector<vector<dbl> > dist(H, vector<dbl>(W, -1));\n  for(Pi p : s) {\n    que.emplace(p);\n    dist[p.first][p.second] = 0;\n  }\n  while(!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front(); que.pop();\n    for(int i = 0; i < 4; ++i) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#') continue;\n      if(dist[ny][nx] == -1) {\n\tdist[ny][nx] = dist[y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n  return dist;\n}\n\nvector<vector<dbl> > db;\nvector<vector<dbl> > dg;\n\nbool check(dbl mb) {\n  dbl sum = 0;\n  int num = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.') {\n\tif(dg[i][j] == -1 && db[i][j] == -1) assert(false);\n\telse if(dg[i][j] == -1) sum += db[i][j]+mb;\n\telse if(db[i][j] == -1) sum += dg[i][j];\n\telse sum += min(dg[i][j], db[i][j]+mb);\n\t++num;\n      }\n    }\n  }\n  sum /= num;\n  return sum >= mb;\n}\n\nint main() {\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 's') S = Pi(i, j), mas[i][j] = '.';\n      else if(mas[i][j] == 'g') G = Pi(i, j);\n      else if(mas[i][j] == '*') Bs.emplace_back(i, j);\n    }\n  }\n\n  db = bfs(Bs);\n  dg = bfs({G});\n\n  dbl ans = dg[S.first][S.second];\n  if(ans == -1) ans = 1e9;\n  else if(db[S.first][S.second] == -1) {\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n  }\n\n  dbl lb = 0, ub = 1e9;\n  for(int i = 0; i < 200; ++i) {\n    dbl mb = (lb+ub)/2;\n    if(check(mb)) lb = mb;\n    else ub = mb;\n  }\n\n  ans = min(ans, db[S.first][S.second]+lb);\n\n  cout << fixed << setprecision(12) << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 10000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >4000)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 1000000000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >1000)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<int,mp> mmp;\n\nint w,h;\nint sy,sx,gy,gx;\nint dist[505][505]={};\nint mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = 500*500*500;\n\tif(dist[y][x]!=-1)res=min(res,(double)dist[y][x]);\n\tif(mine[y][x]!=-1)res=min(res,((double)mine[y][x])+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\tmemset(gone,0,sizeof(gone));\n\tmemset(dist,-1,sizeof(dist));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tint nd = pa.fir,\n\t\t\tny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\tmemset(gone,0,sizeof(gone));\n\tmemset(mine,-1,sizeof(mine));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tint nd = pa.fir,\n\t\t\tny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=500*500,r=0;\n\t\n\twhile(l-r>1e-10){\n\t\tdouble m = (l+r)/2;\n\t\tdouble ce=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tce+=cmin(y,x,m);\n\t\t}\n\t\tce/=dotnum;\n\t\tif(ce>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\nint INF = 1145141919893810;\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = INF;\n\t\t\tb[i][j] = INF;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = INF;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\tif (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=1e7,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a-1==0)break;\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e8;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\nvector<double> dist;\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, double> is_lower(const double e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, double> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] <= d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tdouble total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\tdouble ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\tdouble lb = 0, ub = 1e10;\n\tdouble ans = 0;\n\tconst int max_step = 100;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  bool canReachSpring = false;\n\n  vector<vector<int>> d(h, vector<int>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n        if(vec[nx][ny]=='*') canReachSpring=true;\n      }\n    }\n  }\n\n  vector<vector<int>> ds(h,vector<int>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  if(canReachSpring){\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500*500;\n    while((r-l)>=1e-10){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n//      dbg(mp(l,r));\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n#define double long double\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500.0*500*500*500;\n    rep(_,1000){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10Lf\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tint maxn = 0;\n\trep(i,H) rep(j,W){\n\t\tif(vv1[i][j] != INF) maxn=max(maxn,vv1[i][j]);\n\t\tif(vv2[i][j] != INF) maxn=max(maxn,vv2[i][j]);\n\t}\n\tmap<pair<int,int>,int> ma;\n\tdouble bb = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] != '.') continue;\n\t\t\tint x = vv1[i][j];\n\t\t\tint y = vv2[i][j];\n\t\t\tint t = min(x,y);\n\t\t\tbb += t;\n\t\t\tx-=t;\n\t\t\ty-=t;\n\t\t\tpii z = pii(x,y);\n\t\t\tif(ma.count(z)==0) ma[z] = 0;\n\t\t\tma[z]+=1;\n\t\t}\n\t}\n\tlong double ans = 1e100;\n\trep(o,maxn+1){\n\t\tlong double a = 0;\n\t\tlong double b = bb;\n\t\tfor(auto x:ma){\n\t\t\tif(x.F.F-x.F.S <= o){\n\t\t\t\tb += p*x.F.F*x.S;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb += p*x.F.S*x.S;\n\t\t\t\ta += p*x.S;\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[600][600];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\ndouble ijk[600][600];\ndouble ijk2[600][600];\ndouble eps=1e-10;\npair<double,pair<int,int> > v[1000000];\nint t[600][600];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\tijk[i][j]=ijk2[i][j]=1e20;\n\tint sr,sc,gr,gc;\n\tqueue<pair<int,int> > Q;\n\tint cnt=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='s'){sr=i;sc=j;}\n\t\t\tif(str[i][j]=='g'){\n\t\t\t\tgr=i;gc=j;\n\t\t\t\tijk[i][j]=0;\n\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'&&str[i][j]!='*'&&str[i][j]!='g')cnt++;\n\twhile(Q.size()){\n\t\tint row=Q.front().first;\n\t\tint col=Q.front().second;Q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk[row+dx[i]][col+dy[i]]>eps+ijk[row][col]+1){\n\t\t\t\tijk[row+dx[i]][col+dy[i]]=ijk[row][col]+1;\n\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='*'){\n\t\t\tijk2[i][j]=0;\n\t\t\tQ.push(make_pair(i,j));\n\t\t}\n\t}\n\twhile(Q.size()){\n\t\tint row=Q.front().first;\n\t\tint col=Q.front().second;Q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk2[row+dx[i]][col+dy[i]]>eps+ijk2[row][col]+1){\n\t\t\t\tijk2[row+dx[i]][col+dy[i]]=ijk2[row][col]+1;\n\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\tint sz=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='s'||str[i][j]=='.')v[sz++]=make_pair(ijk[i][j]-ijk2[i][j],make_pair(i,j));\n\t\t}\n\t}\n\tstd::sort(v,v+sz);\n\tdouble L=0;\n\tdouble R=0;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='s'||str[i][j]=='.')R+=ijk2[i][j];\n\tdouble ret=ijk[sr][sc];\n\tfor(int i=0;i<=sz;i++){\n\t\tif(t[sr][sc]){\n\t\t\tbreak;\n\t\t}\n\t\tif(i){\n\t\t\tret=min(ret,ijk2[sr][sc]+R/(sz-i)*((double)sz/i-1)+L/i);\n\t\t}\n\t\tif(i<sz){\n\t\t\tt[v[i].second.first][v[i].second.second]=1;\n\t\t\tL+=ijk[v[i].second.first][v[i].second.second];\n\t\t\tR-=ijk2[v[i].second.first][v[i].second.second];\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e10), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 100; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      //cout << springs[i].first << \" \" << springs[i].second << \"!\" << endl;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\t//cout << x << \" \" << y << endl;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j]/n;\n\t  //cout << exp[i][j] << endl;\n\t}\n      }\n    }\n    //cout << s << \" \" << mean << endl;\n    if(s < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n    //cout << mean << endl;\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  /*\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      cout << exp[i][j] << \" \";\n    }cout << endl;\n  }\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 30000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <cstdio>\n#include <cmath>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntemplate <class T> bool setmax(T & l, T const & r) { if (not (l < r)) return false; l = r; return true; }\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\nconst int inf = 1e9+7;\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nint main() {\n    // input\n    int w, h; cin >> w >> h;\n    vector<string> c(h); repeat (y,h) cin >> c[y];\n    // modify input\n    int sy, sx, gy, gx;\n    repeat (y,h) repeat (x,w) {\n        if (c[y][x] == 's') {\n            sy = y;\n            sx = x;\n            c[y][x] = '.';\n        } else if (c[y][x] == 'g') {\n            gy = y;\n            gx = x;\n        }\n    }\n    // prepare\n    auto on_field = [&](int y, int x) { return 0 <= y and y < h and 0 <= x and x < w; };\n    typedef queue<pair<int,int> > points_queue;\n    auto bfs = [&](function<void (points_queue &)> init, function<void (points_queue &, int, int, int, int)> update) {\n        points_queue que;\n        init(que);\n        while (not que.empty()) {\n            int y, x; tie(y, x) = que.front(); que.pop();\n            repeat (i,4) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if (not on_field(ny, nx)) continue;\n                if (c[ny][nx] != '.') continue;\n                update(que, y, x, ny, nx);\n            }\n        }\n    };\n    vector<vector<int> > goal(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        goal[gy][gx] = 0;\n        que.push(make_pair(gy, gx));\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (goal[ny][nx] == inf) {\n            goal[ny][nx] = goal[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    vector<vector<int> > jump(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        repeat (y,h) repeat (x,w) if (c[y][x] == '*') {\n            jump[y][x] = 0;\n            que.push(make_pair(y, x));\n        }\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (jump[ny][nx] == inf) {\n            jump[ny][nx] = jump[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    map<pair<int,int>,int> freq; // frequency\n    int total = 0;\n    int max_goal = 0;\n    repeat (y,h) repeat (x,w) if (c[y][x] == '.') {\n        freq[make_pair(goal[y][x], jump[y][x])] += 1;\n        total += 1;\n        if (goal[y][x] < inf) setmax(max_goal, goal[y][x]);\n    }\n    // calc\n    double e = INFINITY;\n    repeat (estimate, max_goal + 1) {\n        // E = f(E) = aE + b\n        double a = 0;\n        double b = 0;\n        for (auto it : freq) {\n            int g, j; tie(g, j) = it.first;\n            int cnt = it.second;\n            double p = cnt /(double) total;\n            if (g == inf) {\n                a += p;\n                b += p * j;\n            } else if (j == inf) {\n                b += p * g;\n            } else {\n                if (g <= j + estimate) {\n                    b += p * g;\n                } else {\n                    a += p;\n                    b += p * j;\n                }\n            }\n        }\n        setmin(e, b / (1 - a));\n    }\n    // output\n    double ans = min<double>(goal[sy][sx], jump[sy][sx] + e);\n    printf(\"%.12lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing dbl = long double;\nusing Pi = pair<int, int>;\n\nconst dbl eps = 1e-15;\n#define lt(a, b) ((a)-(b) < -eps)\n#define eq(a, b) (fabs((a)-(b)) < eps)\n\nint W, H;\nchar mas[505][505];\nPi S, G;\nvector<Pi> Bs;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nvector<vector<dbl> > bfs(const vector<Pi>& s) {\n  //cout<<\"!!!!!\"<<endl;\n  queue<Pi> que;\n  vector<vector<dbl> > dist(H, vector<dbl>(W, -1));\n  for(Pi p : s) {\n    que.emplace(p);\n    dist[p.first][p.second] = 0;\n  }\n  while(!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front(); que.pop();\n    //cout<<mas[y][x]<<\" \"<<y<<\" \"<<x<<endl;    \n    for(int i = 0; i < 4; ++i) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#' || mas[ny][nx] == '*') continue;\n      if(dist[ny][nx] == -1) {\n\tdist[ny][nx] = dist[y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n  return dist;\n}\n\nvector<vector<dbl> > db;\nvector<vector<dbl> > dg;\n\nbool check(dbl mb) {\n  dbl sum = 0;\n  int num = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.') {\n\tif(dg[i][j] == -1 && db[i][j] == -1) assert(false);\n\telse if(dg[i][j] == -1) sum += db[i][j]+mb;\n\telse if(db[i][j] == -1) sum += dg[i][j];\n\telse sum += min(dg[i][j], db[i][j]+mb);\n\t++num;\n      }\n    }\n  }\n  sum /= num;\n  return sum >= mb;\n}\n\nint main() {\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 's') S = Pi(i, j), mas[i][j] = '.';\n      else if(mas[i][j] == 'g') G = Pi(i, j);\n      else if(mas[i][j] == '*') Bs.emplace_back(i, j);\n    }\n  }\n\n  db = bfs(Bs);\n  dg = bfs({G});\n\n  dbl ans = dg[S.first][S.second];\n  //cout<<ans<<endl;\n  if(ans == -1) ans = DBL_MAX/2;\n  else if(db[S.first][S.second] == -1) {\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n  }\n\n  dbl lb = 0, ub = 1e20;\n  for(int i = 0; i < 200; ++i) {\n    dbl mb = (lb+ub)/2;\n    if(check(mb)) lb = mb;\n    else ub = mb;\n  }\n\n  ans = min(ans, db[S.first][S.second]+lb);\n\n  cout << fixed << setprecision(12) << ans << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\nint w,h,sx,sy,gx,gy,num;\nstring s[500];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nll dg[500][500],db[500][500],inf=1e18;\nvoid gbfs(int gx,int gy){\n\trep(i,h) rep(j,w) dg[i][j]=inf;\n\tdg[gx][gy]=0;\n\tqueue<PP> que;\n\tque.push(PP(dg[gx][gy],P(gx,gy)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&dg[nx][ny]==inf){\n\t\t\t\tdg[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(dg[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bbfs(){\n\tqueue<PP> que;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='*') db[i][j]=inf;\n\t\telse que.push(PP(0,P(i,j)));\n\t}\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&db[nx][ny]==inf){\n\t\t\t\tdb[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(db[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(long double x){\n\tlong double sum=0;\n\trep(i,h) rep(j,w) if(s[i][j]!='#'&&s[i][j]!='*') sum+=min(x+db[i][j],(long double)dg[i][j]);\n\treturn sum/num<x;\n}\nint main(){\n\tcin>>w>>h;\n\trep(i,h) cin>>s[i];\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]=='s') sx=i,sy=j,num++;\n\t\tif(s[i][j]=='g') gx=i,gy=j;\n\t\tif(s[i][j]=='.') num++;\n\t}\n\tgbfs(gx,gy);\n\tbbfs();\n\tbool flag=false;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='#'&&dg[i][j]==inf&&db[i][j]==inf) flag=true;\n\t}\n\tif(flag){\n\t\tprintf(\"%lld\\n\",dg[sx][sy]);\n\t\treturn 0;\n\t}\n\tlong double ub=500.0*500*500*500,lb=0;\n\tint cnt=0;\n\twhile(cnt<100){\n//\t\tcout<<ub<<\" \"<<lb<<endl;\n\t\tcnt++;\n\t\tlong double mid=(ub+lb)/2;\n\t\tif(check(mid)) ub=mid;\n\t\telse lb=mid;\n\t}\n\tprintf(\"%.12f\\n\",(double)min(ub+db[sx][sy],(long double)dg[sx][sy]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nint main()\n{\n    int W, H;\n    cin >> W >> H;\n    vector<vector<char>> field(H, vector<char>(W));\n    P s, g;\n    vector<P> spring;\n    int floor = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> field[i][j];\n            if (field[i][j] == 's') {\n                s = make_pair(i, j);\n                field[i][j] = '.';\n                floor++;\n            } else if (field[i][j] == 'g') {\n                g = make_pair(i, j);\n            } else if (field[i][j] == '*') {\n                spring.push_back(make_pair(i, j));\n            } else if (field[i][j] == '.') {\n                floor++;\n            }\n        }\n    }\n\n    constexpr int INF = 1 << 30;\n    vector<vector<int>> goal_dist(H, vector<int>(W, INF));\n    vector<vector<int>> spring_dist(H, vector<int>(W, INF));\n    vector<vector<bool>> used(H, vector<bool>(W, false));\n    queue<pair<P, int>> q;\n    q.push(make_pair(g, 0));\n    while (not q.empty()) {\n        const auto& s = q.front();\n        const int y = s.first.first;\n        const int x = s.first.second;\n        const int dist = s.second;\n        q.pop();\n        used[y][x] = true;\n        goal_dist[y][x] = dist;\n        for (int d = 0; d < 4; d++) {\n            const int newx = x + dir[d];\n            const int newy = y + dir[d + 1];\n            if (newx >= 0 and newx < W and newy >= 0 and newy < H and (not used[newy][newx]) and (field[newy][newx] == '.')) {\n                used[newy][newx] = true;\n                q.push(make_pair(make_pair(newy, newx), dist + 1));\n            }\n        }\n    }\n\n    fill(used.begin(), used.end(), vector<bool>(W, false));\n    for (const P& sp : spring) {\n        q.push(make_pair(sp, 0));\n    }\n\n    while (not q.empty()) {\n        const auto& s = q.front();\n        const int y = s.first.first;\n        const int x = s.first.second;\n        const int dist = s.second;\n        q.pop();\n        used[y][x] = true;\n        spring_dist[y][x] = dist;\n        for (int d = 0; d < 4; d++) {\n            const int newx = x + dir[d];\n            const int newy = y + dir[d + 1];\n            if (newx >= 0 and newx < W and newy >= 0 and newy < H and (not used[newy][newx]) and (field[newy][newx] == '.')) {\n                used[newy][newx] = true;\n                q.push(make_pair(make_pair(newy, newx), dist + 1));\n            }\n        }\n    }\n\n    ld inf = 0;\n    ld sup = 250000;\n    constexpr int REP = 1000;\n    for (int i = 0; i < REP; i++) {\n        const ld mid = (inf + sup) / 2;\n        ld sum = 0;\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                if (field[y][x] == '.') {\n                    sum += min(spring_dist[y][x] + mid, (ld)goal_dist[y][x]);\n                }\n            }\n        }\n        const ld actual = sum / floor;\n        if (actual < mid) {\n            sup = mid;\n        } else {\n            inf = mid;\n        }\n    }\n\n    const int sy = s.first;\n    const int sx = s.second;\n    cout << fixed << setprecision(15) << min(spring_dist[sy][sx] + inf, (ld)goal_dist[sy][sx]) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nP dlt[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};\n\nvector<vector<char>> c;\nll h,w,f;\nP sp,gp;\nvector<P> spr;\nvector<vector<ll>> g_cost;\nvector<vector<ll>> s_cost;\n\nbool isfloor(P p) {\n\tif(p.first>=0&&p.first<h&&p.second>=0&&p.second<w&&\n\t   (c[p.first][p.second]=='.'||c[p.first][p.second]=='s')) return true;\n\telse return false;\n}\n\nvector<vector<ll>> dijkstra(vector<P> s) {\n\tvector<vector<ll>> dst(h,vector<ll>(w,INF));\n\tpriority_queue<pair<ll,P>,vector<pair<ll,P>>,greater<pair<ll,P>>> q;\n\tREP(i,(ll)s.size()) {\n\t\tdst[s[i].first][s[i].second]=0;\n\t\tq.push(make_pair(0,s[i]));\n\t}\n\twhile(!q.empty()) {\n\t\tll d=q.top().first;\n\t\tP p=q.top().second;\n\t\tq.pop();\n\t\tif(dst[p.first][p.second]!=d) continue;\n\t\tREP(i,4) {\n\t\t\tP np=P(p.first+dlt[i].first,p.second+dlt[i].second);\n\t\t\tif(isfloor(np)&&dst[np.first][np.second]>d+1) {\n\t\t\t\tdst[np.first][np.second]=d+1;\n\t\t\t\tq.push(make_pair(dst[np.first][np.second],np));\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}\n\nvoid init() {\n\tcin>>w>>h;\n\tc.assign(h,vector<char>(w));\n\tREP(i,h) REP(j,w) cin>>c[i][j];\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') f++;\n\tREP(i,h) REP(j,w) if(c[i][j]=='s') sp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='g') gp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='*') spr.pb(P(i,j));\n\tg_cost=dijkstra(vector<P>(1,gp));\n\ts_cost=dijkstra(spr);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tinit();\n\tif(g_cost[sp.first][sp.second]<=s_cost[sp.first][sp.second]) {\n\t\tcout<<fixed<<setprecision(39)<<g_cost[sp.first][sp.second]<<endl;\n\t\treturn 0;\n\t}\n\tll cons=0;\n\tll cf=0;\n\tpriority_queue<ll,vector<ll>,greater<ll>> diff;\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') {\n\t\tif(g_cost[i][j]==INF) {\n\t\t\tcons+=s_cost[i][j];\n\t\t\tcf++;\n\t\t} else cons+=g_cost[i][j];\n\t\tif(g_cost[i][j]!=INF&&s_cost[i][j]<g_cost[i][j]) diff.push(s_cost[i][j]-g_cost[i][j]);\n\t}\n\tld min_x=cons/(ld)(f-cf);\n\twhile(!diff.empty()) {\n\t\tll c=diff.top();\n\t\tdiff.pop();\n\t\tcons+=c;\n\t\tcf++;\n\t\tmin_x=min(min_x,cons/(ld)(f-cf));\n\t}\n\tcout<<fixed<<setprecision(39)<<min(\n\t(ld)g_cost[sp.first][sp.second],s_cost[sp.first][sp.second]+min_x)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nll A[500][500],B[500][500];\nll INF=(1LL<<50);\n\nvoid bfs(char ch,ll d[500][500]){\n  fill(d[0],d[500], INF );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  \n  bfs('*',A);\n  bfs('g',B);\n\n  vector<ll> v;\n  ll sum=0,cnt=0,K=0;\n  double base=1e100;\n  double ans=1e100;\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      \n      cnt++;\n      if(t[i][j]=='s'){\n        if(A[i][j]==INF)base=1e100;\n        else base=A[i][j];\n        if(B[i][j]!=INF)ans=B[i][j];\n      }\n      if(A[i][j]==INF){\n        sum+=B[i][j];\n      }else if(B[i][j]==INF){\n        sum+=A[i][j];\n        K++;\n      }else{\n        sum+=B[i][j];\n        v.push_back(A[i][j]-B[i][j]);\n      }\n\n    }\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<=(int)v.size();i++){\n    double rate=(double)K/(double)cnt;\n    double X=(double)sum/(double)cnt;\n    X/=(1.0-rate);\n    ans=min(ans,(double)base+X);\n    K++;\n    \n    if(i==(int)v.size())break;\n    sum+=v[i];\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tint maxn = 0;\n\trep(i,H) rep(j,W){\n\t\tif(vv1[i][j] != INF) maxn=max(maxn,vv1[i][j]);\n\t\tif(vv2[i][j] != INF) maxn=max(maxn,vv2[i][j]);\n\t}\n\tmap<pair<int,int>,int> ma;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] != '.') continue;\n\t\t\tint x = vv1[i][j];\n\t\t\tint y = vv2[i][j];\n\t\t\tpii z = pii(x,y);\n\t\t\tif(ma.count(z)==0) ma[z] = 0;\n\t\t\tma[z]+=1;\n\t\t}\n\t}\n\tlong double ans = 1e100;\n\trep(o,maxn+1){\n\t\tlong double a = 0;\n\t\tlong double b = 0;\n\t\tfor(auto x:ma){\n\t\t\tif(x.F.F-x.F.S <= o){\n\t\t\t\tb += p*x.F.F*x.S;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb += p*x.F.S*x.S;\n\t\t\t\ta += p*x.S;\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 16;\n\nconst int cmax=250010;\nint w,h;\nint d[cmax];\nint e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg)const{\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[cmax];\n\nvoid dijkstra(char s,char o,int* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid show(int *dist){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tint idx=i*w+j;\n\t\t\tif(dist[idx]<10)\n\t\t\t\tcout << dist[idx];\n\t\t\telse\n\t\t\t\tcout << '-';\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tex[n].d=d[idx];\n\t\t\tex[n++].e=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\tdouble ans=d[sidx];\n\tll sum=0;\n\trep(i,n) sum+=ex[i].d;\n\tfor(int i=n;i>=1;--i){\n\n\t\tans=min(ans,1.0*sum/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tsum-=ex[cur].d;\n\t\tsum+=ex[cur].e;\n\t}\n\tcout.precision(12);\n\tcout << fixed << ans << endl;\n\tshow(d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> c(h);\n  for(int i=0;i<h;i++){\n    cin>>c[i];\n  }\n  const int INF=1e9;\n  vector<vector<int>> spr(h,vector<int>(w,INF));\n  queue<pair<int,int>> que;\n  pair<int,int> s;\n  pair<int,int> t;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(c[i][j]=='s'){\n\ts={i,j};\n\tc[i][j]='.';\n      }\n      if(c[i][j]=='g'){\n\tt={i,j};\n      }\n      if(c[i][j]=='*'){\n\tque.push({i,j});\n\tspr[i][j]=0;\n      }\n    }\n  }\n  int dx[]={1,-1,0,0};\n  int dy[]={0,0,1,-1};\n  auto isRange=[=](int i,int j){\n    return 0<=i && i<h && 0<=j && j<w;\n  };\n  \n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && spr[p.first][p.second]+1<spr[toh][tow]){\n\tspr[toh][tow]=spr[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n  vector<vector<int>> goal(h,vector<int>(w,INF));\n  goal[t.first][t.second]=0;\n  que.push(t);\n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && goal[p.first][p.second]+1<goal[toh][tow]){\n\tgoal[toh][tow]=goal[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n\n  double ub=1000000000;\n  double lb=0;\n\n  for(int i=0;i<1000;i++){\n    double mid=(lb+ub)/2;\n    double sum=0;\n    int cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='.'){\n\t  sum+=min<double>(goal[i][j],mid+spr[i][j]);\n\t  cnt++;\n\t}\n      }\n    }\n    sum/=cnt;\n    if(mid<sum){\n      lb=mid;\n    }\n    else{\n      ub=mid;\n    }\n  }\n  cout<<setprecision(15)<<fixed;\n  cout<<min<double>(goal[s.first][s.second],lb+spr[s.first][s.second])<<endl;\n  return 0;\n}\n  \n\n  \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n//#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nll d[512][512],INF=5e15,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  double a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //    cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  //cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,75){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#define DINF (1e15);\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.5)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.5)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0;\n\t\n\twhile((l-r)/(l/2+r/2)>1e-11){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = l/2+r/2;\n\t\tdouble ce=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tce+=cmin(y,x,m)/dotnum;\n\t\t}\n\t\tif(ce>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(999999);\n\t\t\tgot[i].emplace_back(999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1000000000;\n\twhile (amin + 1e-11 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(long double(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans = min(long double(got[sy][sx]), spt[sy][sx] + amin);\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <cstdio>\n#include <cmath>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntemplate <class T> bool setmax(T & l, T const & r) { if (not (l < r)) return false; l = r; return true; }\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\nconst int inf = 1e9+7;\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nint main() {\n    // input\n    int w, h; cin >> w >> h;\n    vector<string> c(h); repeat (y,h) cin >> c[y];\n    // modify input\n    int sy, sx, gy, gx;\n    repeat (y,h) repeat (x,w) {\n        if (c[y][x] == 's') {\n            sy = y;\n            sx = x;\n            c[y][x] = '.';\n        } else if (c[y][x] == 'g') {\n            gy = y;\n            gx = x;\n        }\n    }\n    // prepare\n    auto on_field = [&](int y, int x) { return 0 <= y and y < h and 0 <= x and x < w; };\n    typedef queue<pair<int,int> > points_queue;\n    auto bfs = [&](function<void (points_queue &)> init, function<void (points_queue &, int, int, int, int)> update) {\n        points_queue que;\n        init(que);\n        while (not que.empty()) {\n            int y, x; tie(y, x) = que.front(); que.pop();\n            repeat (i,4) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if (not on_field(ny, nx)) continue;\n                if (c[ny][nx] != '.') continue;\n                update(que, y, x, ny, nx);\n            }\n        }\n    };\n    vector<vector<int> > goal(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        goal[gy][gx] = 0;\n        que.push(make_pair(gy, gx));\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (goal[ny][nx] == inf) {\n            goal[ny][nx] = goal[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    vector<vector<int> > jump(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        repeat (y,h) repeat (x,w) if (c[y][x] == '*') {\n            jump[y][x] = 0;\n            que.push(make_pair(y, x));\n        }\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (jump[ny][nx] == inf) {\n            jump[ny][nx] = jump[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    map<pair<int,int>,int> freq; // frequency\n    int total = 0;\n    int max_goal = 0;\n    repeat (y,h) repeat (x,w) if (c[y][x] == '.') {\n        freq[make_pair(goal[y][x], jump[y][x])] += 1;\n        total += 1;\n        if (goal[y][x] < inf) setmax(max_goal, goal[y][x]);\n    }\n    // calc\n    double e = INFINITY;\n    repeat (estimate, max_goal + 1) {\n        // E = f(E) = aE + b\n        double a = 0;\n        double b = 0;\n        for (auto it : freq) {\n            int g, j; tie(g, j) = it.first;\n            int cnt = it.second;\n            double p = cnt /(double) total;\n            if (g == inf) {\n                a += p;\n                b += p * j;\n            } else if (j == inf) {\n                b += p * g;\n            } else {\n                if (g <= j + estimate) {\n                    b += p * g;\n                } else {\n                    a += p;\n                    b += p * j;\n                }\n            }\n        }\n        setmin(e, b / (1 - a));\n    }\n    // output\n    double ans\n        = goal[sy][sx] == inf ? jump[sy][sx] + e\n        : jump[sy][sx] == inf ? goal[sy][sx]\n        : min<double>(goal[sy][sx], jump[sy][sx] + e); // the answer can become grater than `int inf`, so conditional op. is required.\n    printf(\"%.12lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n#define double long double\n\nconst int INF=1001001001;\nconst int INFLL=1001001001001001001ll;\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint dy[4]={-1,0,1,0};\nint dx[4]={0,-1,0,1};\n\nint H,W;\nchar fld[555][555];\ndouble E[555][555];\nbool check(double e){\n    queue<pint>que;\n    fill_n(*E,555*555,1e14);\n    rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n        E[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(true){\n        if(que.size()==0){\n            if(flag)break;\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n            continue;\n        }\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n\n        if(E[y][x]+1>=e&&!flag){\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n        }\n\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||fld[ny][nx]=='*')continue;\n\n            if(E[ny][nx]!=1e14)continue;\n            E[ny][nx]=E[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    double sum=0;\n    int cnt=0;\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='#'||fld[i][j]=='*'||fld[i][j]=='g')continue;\n        cnt++;sum+=E[i][j];\n    }\n\n    return sum<=e*cnt;\n}\n\n\nsigned main(){\n    cin>>W>>H;\n    rep(i,H)cin>>fld[i];\n\n    vector<vint>dist(H,vint(W,INT_MAX));\n    queue<pint>que;\n    rep(i,H)rep(j,W)if(fld[i][j]=='s'){\n        dist[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||dist[ny][nx]!=INT_MAX)continue;\n            if(fld[ny][nx]=='*')flag=true;\n            dist[ny][nx]=dist[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    if(!flag){\n        rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n            printf(\"%.20Lf\\n\",(double)dist[i][j]);\n            return 0;\n        }\n    }\n\n    double lb=0,ub=1e12;\n    rep(i,70){\n        double mid=(ub+lb)/2;\n        if(check(mid))ub=mid;\n        else lb=mid;\n    }\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='s'){\n            printf(\"%.20Lf\\n\",E[i][j]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst ll INF=1e10; // 期待値の最大値はおよそ(500*250/2)*500*250<1e10\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h && w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tvvl stair(h,vl(w,INF)),spring(h,vl(w,INF));\n\t\tqueue<tuple<int,int,ll>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='g') q.emplace(i,j,0);\n\t\twhile(q.size()){\n\t\t\tint i,j; ll d; tie(i,j,d)=q.front(); q.pop();\n\t\t\tif(0<=i && i<h && 0<=j && j<w && strchr(\".sg\",grid[i][j]) && stair[i][j]==INF){\n\t\t\t\tstair[i][j]=d;\n\t\t\t\trep(k,4) q.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t\t\t}\n\t\t}\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='*') q.emplace(i,j,0);\n\t\twhile(q.size()){\n\t\t\tint i,j; ll d; tie(i,j,d)=q.front(); q.pop();\n\t\t\tif(0<=i && i<h && 0<=j && j<w && strchr(\".sg*\",grid[i][j]) && spring[i][j]==INF){\n\t\t\t\tspring[i][j]=d;\n\t\t\t\trep(k,4) q.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvl st,sp;\n\t\trep(i,h) rep(j,w) if(strchr(\".s\",grid[i][j])){\n\t\t\tst.push_back(stair[i][j]);\n\t\t\tsp.push_back(spring[i][j]);\n\t\t}\n\t\t\n\t\tint n=st.size();\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return st[i]-sp[i]<st[j]-sp[j];});\n\t\t\n\t\tint si=-1,sj=-1;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='s') si=i,sj=j;\n\t\t\n\t\tdouble res=stair[si][sj];\n\t\tll sum1=0,sum2=accumulate(all(sp),0ll),cnt=0;\n\t\tfor(int i:is){\n\t\t\tsum1+=st[i],sum2-=sp[i],cnt++;\n\t\t\tres=min(res,spring[si][sj]+double(sum1+sum2)/cnt);\n\t\t}\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint w,h,sx,sy,gx,gy,num,inf=1e8;\nstring s[500];\nint dg[500][500],db[500][500],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvoid gbfs(int gx,int gy){\n\trep(i,h) rep(j,w) dg[i][j]=inf;\n\tdg[gx][gy]=0;\n\tqueue<PP> que;\n\tque.push(PP(dg[gx][gy],P(gx,gy)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&dg[nx][ny]==inf){\n\t\t\t\tdg[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(dg[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bbfs(){\n\tqueue<PP> que;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='*') db[i][j]=inf;\n\t\telse que.push(PP(0,P(i,j)));\n\t}\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&db[nx][ny]==inf){\n\t\t\t\tdb[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(db[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(long double x){\n\tlong double sum=0;\n\trep(i,h) rep(j,w) if(s[i][j]!='#'&&s[i][j]!='*') sum+=min(x+db[i][j],(long double)dg[i][j]);\n\treturn sum/num<x;\n}\nint main(){\n\tcin>>w>>h;\n\trep(i,h) cin>>s[i];\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]=='s') sx=i,sy=j,num++;\n\t\tif(s[i][j]=='g') gx=i,gy=j;\n\t\tif(s[i][j]=='.') num++;\n\t}\n\tgbfs(gx,gy);\n\tbbfs();\n\t/*bool flag=false;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='#'&&dg[i][j]==inf&&db[i][j]==inf) flag=true;\n\t}\n\tif(flag){\n\t\tprintf(\"%d\\n\",dg[sx][sy]);\n\t\treturn 0;\n\t}*/\n\tlong double ub=3000000,lb=0;\n\twhile(ub-lb>1e-12){\n//\t\tcout<<ub<<\" \"<<lb<<endl;\n\t\tlong double mid=(ub+lb)/2;\n\t\tif(check(mid)) ub=mid;\n\t\telse lb=mid;\n\t}\n\tprintf(\"%.12f\\n\",(double)min(ub+db[sx][sy],(long double)dg[sx][sy]));\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <cassert>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 1000000000000ll;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// ?????¢??°????\\???§??????????????¨??????\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 1000){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// ?????¢??°????\\??°???????????±???????\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\n/*long double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k,\n                   const int s=0){\n    const int N = v.size();\n    int l = as[k];\n    int r = bs[N] - bs[k];\n    if(s > 1000) return 1.0F * (l+r) / N;\n    return (l + r + (1.0F * (N-k) * calc_e(v,as,bs,k,s+1)))/N;\n    }*/\n\ndouble target(const vector<Info>& dots, double e) {\n    double t = 0.0;\n    for (const auto & i : dots) {\n        t += min((double)i.to_spring, i.to_goal - e);\n    }\n    return t;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n    /* {info[i][j] |-> ??´???????????§????????¢?????´?????????????????§????????¢} */\n    \n    \n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                if (info[i][j].to_goal > INF / 2 &&\n                    info[i][j].to_spring > INF / 2) {continue;}\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    /* dots???????????§?£?????????´?????¨??????info?????\\?????? */ \n    double minimum = 0, maximum = 1e15;\n    //    assert (target(dots, minimum) > 0);\n    //    dump(dots);\n    //    dump(target(dots, maximum));\n    //    assert (target(dots, maximum) < 0);\n\n    for (int i = 0; i < 500; i++) {\n        double half = (minimum + maximum) / 2.;\n        double val = target(dots, half);\n        //        dump(half);\n        //        dump(val);\n        if (val > 0) {\n            minimum = half;\n        } else {\n            maximum = half;\n        }\n    }\n    dump(minimum);\n    auto si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;});\n    cout << fixed << setprecision(12);\n    cout << min(si->to_spring + minimum, (double)si->to_goal) << endl;\n    return 0;\n    /*    \n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n    // dump(bs[N]);\n    // dump(as[N]);\n    // dump((long double)(as[si+1] - as[si]));\n    // dump((long double)(bs[si+1] - bs[si]));\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c + 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    int ls = as[1] - bs[1];\n    int rs = as[N] - as[N-1] - (bs[N] - bs[N-1]);\n    auto r = ternary_search_concave(f,ls,rs);\n    // for(int i=0;i<N;i++){\n    //     double d = as[i+1] - as[i] - (bs[i+1] - bs[i]);\n    //     cerr << d << \" -> \" << f(d) << endl;\n    // }\n\n    cout << fixed << setprecision(12);\n    cout << f(r) << endl;\n    return 0;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n      //  assert(g[y][x] != '#');\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n      //  assert(g[y][x] != '#');\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < h; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*\n    printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sy][sx] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e15;\n    for (int i = 0; i < 100; i++) {\n        //printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                \n                \n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n        //printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  LL w,h;\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> left=0;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> right=10000000000000000000;\n   cout << left << endl;\n   cout << right << endl;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> mid;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor);\n            }else{\n              count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   cout << left << endl;\n   cout << right << endl;\n   cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << \" \";\n  //         }else{\n  //           cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << endl;\n    }else{\n      cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  //long double nE = 0.0;\n  int cnt = 0;\n  priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    long double l = que.top();\n    que.pop();\n    long double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 100) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint w,h,sx,sy,gx,gy,num,inf=1e8;\nstring s[500];\nint dg[500][500],db[500][500],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvoid gbfs(int gx,int gy){\n\trep(i,h) rep(j,w) dg[i][j]=inf;\n\tdg[gx][gy]=0;\n\tqueue<PP> que;\n\tque.push(PP(dg[gx][gy],P(gx,gy)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&dg[nx][ny]==inf){\n\t\t\t\tdg[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(dg[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bbfs(){\n\tqueue<PP> que;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='*') db[i][j]=inf;\n\t\telse que.push(PP(0,P(i,j)));\n\t}\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&db[nx][ny]==inf){\n\t\t\t\tdb[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(db[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(long double x){\n\tlong double sum=0;\n\trep(i,h) rep(j,w) if(s[i][j]!='#'&&s[i][j]!='*') sum+=min(x+db[i][j],(long double)dg[i][j]);\n//\tshow((double)x);\n//\tshow((double)sum/(double)num);\n//\tcout<<endl;\n\treturn sum/num<x;\n}\nint main(){\n\tcin>>w>>h;\n\trep(i,h) cin>>s[i];\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]=='s') sx=i,sy=j,num++;\n\t\tif(s[i][j]=='g') gx=i,gy=j;\n\t\tif(s[i][j]=='.') num++;\n\t}\n\tgbfs(gx,gy);\n\tbbfs();\n\t/*bool flag=false;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='#'&&dg[i][j]==inf&&db[i][j]==inf) flag=true;\n\t}\n\tif(flag){\n\t\tprintf(\"%d\\n\",dg[sx][sy]);\n\t\treturn 0;\n\t}*/\n\tlong double ub=300000,lb=0;\n\twhile(ub-lb>1e-12){\n//\t\tcout<<ub<<\" \"<<lb<<endl;\n\t\tlong double mid=(ub+lb)/2;\n\t\tif(check(mid)) ub=mid;\n\t\telse lb=mid;\n\t}\n\tprintf(\"%.12f\\n\",(double)min(ub+db[sx][sy],(long double)dg[sx][sy]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <cstdio>\n#include <cmath>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntemplate <class T> bool setmax(T & l, T const & r) { if (not (l < r)) return false; l = r; return true; }\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\nconst int inf = 1e9+7;\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nint main() {\n    // input\n    int w, h; cin >> w >> h;\n    vector<string> c(h); repeat (y,h) cin >> c[y];\n    // modify input\n    int sy, sx, gy, gx;\n    repeat (y,h) repeat (x,w) {\n        if (c[y][x] == 's') {\n            sy = y;\n            sx = x;\n            c[y][x] = '.';\n        } else if (c[y][x] == 'g') {\n            gy = y;\n            gx = x;\n        }\n    }\n    // prepare\n    auto on_field = [&](int y, int x) { return 0 <= y and y < h and 0 <= x and x < w; };\n    typedef queue<pair<int,int> > points_queue;\n    auto bfs = [&](function<void (points_queue &)> init, function<void (points_queue &, int, int, int, int)> update) {\n        points_queue que;\n        init(que);\n        while (not que.empty()) {\n            int y, x; tie(y, x) = que.front(); que.pop();\n            repeat (i,4) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if (not on_field(ny, nx)) continue;\n                if (c[ny][nx] != '.') continue;\n                update(que, y, x, ny, nx);\n            }\n        }\n    };\n    vector<vector<int> > goal(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        goal[gy][gx] = 0;\n        que.push(make_pair(gy, gx));\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (goal[ny][nx] == inf) {\n            goal[ny][nx] = goal[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    vector<vector<int> > jump(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        repeat (y,h) repeat (x,w) if (c[y][x] == '*') {\n            jump[y][x] = 0;\n            que.push(make_pair(y, x));\n        }\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (jump[ny][nx] == inf) {\n            jump[ny][nx] = jump[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    map<pair<int,int>,int> freq; // frequency\n    int total = 0;\n    int max_goal = 0;\n    repeat (y,h) repeat (x,w) if (c[y][x] == '.') {\n        freq[make_pair(goal[y][x], jump[y][x])] += 1;\n        total += 1;\n        if (goal[y][x] < inf) setmax(max_goal, goal[y][x]);\n    }\n    // calc\n    long double e = INFINITY;\n    repeat (estimate, max_goal + 1) {\n        // E = f(E) = aE + b\n        long double a = 0;\n        long double b = 0;\n        for (auto it : freq) {\n            int g, j; tie(g, j) = it.first;\n            int cnt = it.second;\n            long double p = cnt /(long double) total;\n            if (g == inf) {\n                a += p;\n                b += p * j;\n            } else if (j == inf) {\n                b += p * g;\n            } else {\n                if (g <= j + estimate) {\n                    b += p * g;\n                } else {\n                    a += p;\n                    b += p * j;\n                }\n            }\n        }\n        setmin(e, b / (1 - a));\n    }\n    // output\n    long double ans\n        = goal[sy][sx] == inf ? jump[sy][sx] + e\n        : jump[sy][sx] == inf ? goal[sy][sx]\n        : min<long double>(goal[sy][sx], jump[sy][sx] + e); // the answer can become grater than `int inf`, so conditional op. is required.\n    printf(\"%.12Lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=INF;\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=100000000000LL,lower=0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) sum+=min((double)dist_goal[y][x],dist_spring[y][x]+E);\n\t\t\t\telse sum+=dist_spring[y][x]+E;\n\t\t\t}\n\t\t}\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tvector<double> vec;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e11;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t//\tsum+=tmp;\n\t\tvec.push_back(tmp);\n\t\tcnt++;\n\t}\n\tsort(vec.begin(),vec.end());\n\tfor(int i=0;i<cnt;i++) sum+=vec[i];\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e10;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=1e10;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nll A[500][500],B[500][500];\n\nvoid bfs(char ch,ll d[500][500]){\n  fill(d[0],d[500], (1LL<<60) );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  bfs('*',A);\n  bfs('g',B);\n\n  vector<ll> v;\n  ll sum=0,cnt=0,base;\n  \n  double ans=1e9;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      cnt++;\n      sum+=B[i][j];\n      v.push_back(A[i][j]-B[i][j]);\n      if(t[i][j]=='s'){\n        base=A[i][j];\n        ans=min(ans,(double)B[i][j]);\n      }\n    }\n  }\n\n  ans=min(ans, (double)base + (double)sum / (double)cnt);\n  sort(v.begin(),v.end());\n  for(int i=0;i+1<(int)v.size();i++){\n    sum+=v[i];\n    double rate=(double) (i+1)/ (double) cnt;\n    double X= (double)sum / (double)cnt;\n    X/= (1.0-rate);\n    ans=min( ans, (double)base + X);\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tlong long x,y;\n\tC(long long x,long long y):x(x),y(y){}\n};\nconst long long dx[]={1,0,-1,0};\nconst long long dy[]={0,1,0,-1};\n\nlong long w,h;\n\nbool in(long long x,long long y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nunsigned long long int dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(long long i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(long long j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=8000000000;\n\t\t\tdist_goal[i][j]=(long long)8000000000;\n\t\t\tdist_spring[i][j]=(long long)8000000000;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst long long NUM=4000;\n\tfor(long long t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,60){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=500;\n\tdouble upper=10000000000.0,lower=1.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nchar field[600][600];\nint a[600][600];\nint b[600][600];\n\nvoid bfs(char start, int dist[][600]){\n  queue<int> que;\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, INF);\n  rep(i, H)rep(j, W){\n    if(field[i][j] == start){\n      dist[i][j] = 0;\n      que.push(i * W + j);\n    }\n  }\n  while(!que.empty()){\n    int p = que.front(); que.pop();\n    int x = p % W;\n    int y = p / W;\n    rep(i, 4){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      if((field[y2][x2] == '.' || field[y2][x2] == 's') && dist[y2][x2] == INF){\n\tdist[y2][x2] = dist[y][x] + 1;\n\tque.push(y2 * W + x2);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H){\n    int sy = 0, sx = 0;\n    rep(i, H)rep(j, W){\n      cin >> field[i][j];\n      if(field[i][j] == 's'){\n\tsy = i, sx = j;\n      }\n    }\n    bfs('*', a);\n    bfs('g', b);\n    double ub = 1e10;\n    double lb = 0;\n    rep(i, 100){\n      double mb = (ub + lb) / 2;\n      double sum = 0;\n      int cnt = 0;\n      rep(j, H)rep(k, W){\n\tif(field[j][k] == 's' || field[j][k] == '.'){\n\t  cnt++;\n\t  sum += min((double)b[j][k], a[j][k] + mb);\n\t}\n      }\n      if(mb > sum / cnt) ub = mb;\n      else lb = mb;\n    }\n    cout << fixed << setprecision(12) << min(lb+a[sy][sx],(double)b[sy][sx])<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < w; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sx][sy] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e18;\n    while (r - l > 1e-12) {\n//        printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                assert(dist2b[y][x] != INT_INF);\n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n//        printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int w, h; cin >> w >> h;\n  vector<vector<char>> v(h, vector<char>(w));\n  vector<P> bane;\n  P st, gl;\n  for(int i=0;i<(h);++i) {\n    for(int j=0;j<(w);++j) {\n      cin >> v[i][j];\n      if(v[i][j] == 's') {\n        v[i][j] = '.';\n        st = {i, j};\n      } else if(v[i][j] == 'g') {\n        v[i][j] = '.';\n        gl = {i, j};\n      } else if(v[i][j] == '*') {\n        bane.push_back({i, j});\n      }\n    }\n  }\n  vvi dg(h, vi(w, -1));\n  dg[gl.first][gl.second] = 0;\n  queue<P> que;\n  que.push(gl);\n  vi dr = {-1, 1, 0, 0};\n  vi dc = {0, 0, -1, 1};\n  while(!que.empty()) {\n    P now = que.front(); que.pop();\n    int d = dg[now.first][now.second];\n    for(int i=0;i<(4);++i) {\n      int nr = now.first + dr[i], nc = now.second + dc[i];\n      if(!(0 <= nr && nr < h && 0 <= nc && nc < w)) continue;\n      if(v[nr][nc] != '.') continue;\n      if(dg[nr][nc] == -1) {\n        dg[nr][nc] = d + 1;\n        que.push({nr, nc});\n      }\n    }\n  }\n  vvi dbane(h, vi(w, -1));\n  for(auto &e: bane) dbane[e.first][e.second] = 0, que.push(e);\n  while(!que.empty()) {\n    P now = que.front(); que.pop();\n    int d = dbane[now.first][now.second];\n    for(int i=0;i<(4);++i) {\n      int nr = now.first + dr[i], nc = now.second + dc[i];\n      if(!(0 <= nr && nr < h && 0 <= nc && nc < w)) continue;\n      if(v[nr][nc] != '.') continue;\n      if(dbane[nr][nc] == -1) {\n        dbane[nr][nc] = d + 1;\n        que.push({nr, nc});\n      }\n    }\n  }\n  double l = 0.0, r = LINF;\n  for(int _=0;_<(500);++_) {\n    double mid = (l + r) / 2;\n    double su = 0;\n    int cnt = 0;\n    for(int i=0;i<(h);++i) {\n      for(int j=0;j<(w);++j) {\n        if(v[i][j] != '.' || gl == make_pair(i, j)) continue;\n        cnt++;\n        double tmp = 2e18;\n        if(dg[i][j] != -1 && tmp > dg[i][j]) tmp = dg[i][j];\n        if(dbane[i][j] != -1 && tmp > dbane[i][j] + mid) tmp = dbane[i][j] + mid;\n        su += tmp;\n      }\n    }\n    if(cnt * mid < su) {\n      l = mid;\n    } else {\n      r = mid;\n    }\n  }\n  double ans = 2e18;\n  if(dg[st.first][st.second] != -1 && ans > dg[st.first][st.second]) ans = dg[st.first][st.second];\n  if(dbane[st.first][st.second] != -1 && ans > dbane[st.first][st.second] + l) ans = dbane[st.first][st.second] + l;\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  //long double nE = 0.0;\n  int cnt = 0;\n  priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    long double l = que.top();\n    que.pop();\n    long double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 90) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 10000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e8, M = 0;\n  rep(i,50){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#include<cfloat>\nconst double DINF = 1e14;\nconst double eps = 1e-10;\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.01)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.01)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0.0;\n\t\n\t//while((l-r)*2.0>(l+r)*esp){}\n\trep(k,200){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = l*0.5+r*0.5;\n\t\t//printf(\"%.10f %.10f %.10f\\n\",l,r,m);\n\t\tdouble zan=0,cs=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tdouble na = cmin(y,x,m),ce;\n\t\t\tce=cs+na+zan;\n\t\t\tzan=cs+na+zan-ce;\n\t\t\tcs=ce;\n\t\t}\n\t\tcs=cs+zan;\n\t\tif(cs/dotnum>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\t//printf(\"%.10f %.10f\\n\",dist[sy][sx],mine[sy][sx]);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 40000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\n#define INF 1e18\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP; \nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fie[510][510];\nint dist[2][510][510];\nint w,h;\nvector<PP> vec;\nint sx,sy,gx,gy;\ntypedef long long ll;\n\nvoid bfs(int y=-1,int x=-1){\n\tqueue<P> que;\n\tint type=0;\n\tif(y==-1)type=1;\n\tmemset(dist[type],-1,sizeof(dist[type]));\n\tif(type==0){\n\t\tdist[type][y][x]=0;\n\t\tque.push(P(y,x));\n\t}else{\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==1){\n\t\t\t\t\tdist[type][i][j]=0;\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(abs(fie[ny][nx])!=1 && dist[type][ny][nx]==-1){\n\t\t\t\tdist[type][ny][nx]=dist[type][p.first][p.second]+1;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll cnt=0;\nll all=0;\nll okave=0;\nll ngave=0;\n\nlong double calc(int v){\n\tif((dist[0][sy][sx]!=-1 && dist[0][sy][sx]<=dist[1][sy][sx]+v) || dist[1][sy][sx]==-1)return dist[0][sy][sx];\n\telse{\n\t\tif(cnt==0)return INF;\n\t\tlong double va=(long double)okave/all;\n\t\tva*=(double)1.0*all/cnt;\n\t\tlong double vb=(long double)ngave/((long double)(all-cnt));\n\t\tvb*=(long double)1.0*all/cnt;\n\t\tvb-=(long double)ngave/((long double)(all-cnt));\n\t\treturn (long double)va+vb+dist[1][sy][sx];\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%*c\",&w,&h);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='#')fie[i][j]=-1;\n\t\t\tif(c=='s')sy=i,sx=j;\n\t\t\tif(c=='g')gy=i,gx=j;\n\t\t\tif(c=='*')fie[i][j]=1;\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tbfs(gy,gx);\n\tbfs();\n\tif(dist[1][sy][sx]==-1 || (dist[0][sy][sx]<=dist[1][sy][sx] && dist[0][sy][sx]!=-1)){\n\t\tprintf(\"%.10f\\n\",(double)dist[0][sy][sx]);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\tall++;\n\t\t\t\tif(dist[0][i][j]!=-1 && dist[1][i][j]!=-1)vec.push_back(PP(dist[0][i][j]-dist[1][i][j],P(i,j)));\n\t\t\t\telse if(dist[0][i][j]==-1)ngave+=dist[1][i][j];\n\t\t\t\telse{\n\t\t\t\t\tokave+=dist[0][i][j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tlong double res=INF;\n\tfor(int i=0;i<vec.size();i++){\n\t\tngave+=dist[1][vec[i].second.first][vec[i].second.second];\n\t}\n\tfor(int i=0;i<=vec.size();i++){\n\t\tif(i==vec.size())res=min(res,calc(514514));\n\t\telse if(all!=cnt || cnt!=0)res=min(res,calc(vec[i].first));\n\t\tif(i!=vec.size()){\n\t\t\tngave-=dist[1][vec[i].second.first][vec[i].second.second];\n\t\t\tcnt++;\n\t\t\tokave+=dist[0][vec[i].second.first][vec[i].second.second];\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",(double)res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e30\n\nusing namespace std;\n\ntypedef pair<int, int> pos;\ntypedef pair<long double, pos> P;\n\nint W, H;\nchar map[505][505];\nint sx, sy, gx, gy;\nlong double dist[505][505];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dijkstra(long double m)\n{\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tdist[x][y] = inf;\n\t\t}\n\t}\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tdist[gx][gy] = 0, Q.push( make_pair(0, make_pair(gx, gy)) );\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '*') dist[x][y] = m, Q.push(make_pair(m, make_pair(x, y)));\n\t\t}\n\t}\n\t\n\tint x, y;\n\tlong double d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tx = Q.top().second.first;\n\t\ty = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(dist[x][y] < d) continue;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx <= 0 || nx > W || ny <= 0 || ny > H) continue;\n\t\t\tif(map[nx][ny] != '.') continue;\n\t\t\tif(dist[nx][ny] > d + 1){\n\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\tQ.push( make_pair(dist[nx][ny], make_pair(nx, ny)) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong double calc(long double m)\n{\n\tdijkstra(m);\n\tlong double ret = 0; int cnt = 0;\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '.' && (x != gx || y != gy)){\n\t\t\t\tret += dist[x][y];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tret /= cnt;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> W >> H;\n\tfor(int y = 1; y <= H; y++){\n\t\tfor(int x = 1; x <= W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 's'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tsx = x, sy = y;\n\t\t\t}\n\t\t\tif(map[x][y] == 'g'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tgx = x, gy = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong double ub = 1e18, lb = 0.0, mid;\n\tfor(int i = 0; i < 100; i++){\n\t\tmid = (ub + lb) * 0.5;\n\t\tlong double val = calc(mid);\n\t\tif(val < mid) ub = mid;\n\t\telse if(val > mid) lb = mid;\n\t}\n\tmid = (ub + lb) * 0.5;\n\tcalc(mid);\n\t\n\tlong double ret = 0; int cnt = 0;\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '.' && (x != gx || y != gy)){\n\t\t\t\tret += dist[x][y];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tret /= cnt;\n\t\n\tprintf(\"%.11Lf\\n\", dist[sx][sy]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        assert(g[y][x] != '#');\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n        assert(g[y][x] != '#');\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < h; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*\n    printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sy][sx] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e18;\n    while (r - l > 1e-12) {\n        //printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                assert(dist2b[y][x] != INT_INF);\n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n        //printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst double inf = 1e40;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\nvector<double> dist;\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, double> is_lower(const double e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, double> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] <= d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tdouble total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\tdouble ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\tdouble lb = 0, ub = inf / 2;\n\tdouble ans = 0;\n\tconst int max_step = 400;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint w,h;\nvector<string> mp;\n\nvector<vector<int> > bfs(char start){\n  int dx[] = {1,-1,0,0};\n  int dy[] = {0,0,1,-1};\n  \n  queue<P> Q;\n  vector<vector<int> > D(h,vector<int> (w,INF));\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == start) Q.push(P(i,j)), D[i][j] = 0;\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y, x; tie(y, x) = t;\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if(mp[ny][nx] == '#' || mp[ny][nx] == '*') continue;\n      if(D[ny][nx] != INF) continue;\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(ny, nx));\n    }  \n  }\n  return D;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>w>>h;\n  mp.resize(h);\n  cin>>mp;\n\n  P S, T;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 's') S = P(i,j), mp[i][j] = '.';\n      if(mp[i][j] == 'g') T = P(i,j);\n    }\n\n  auto DB = bfs('*');\n  auto DT = bfs('g');\n  \n  vector<P> A;\n  double dot = 0;\n  int sum = 0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] != '.') continue;\n      if(DB[i][j] == INF && DT[i][j] == INF) continue;\n      if(DT[i][j] == INF) {sum += DB[i][j]; continue;}\n      dot++;\n      if(DB[i][j] == INF) {sum += DT[i][j]; continue;}\n      A.push_back(P(DB[i][j], DT[i][j]));\n    }\n  \n  for(auto p:A) sum += p.second;\n\n  sort(A.begin(),A.end(),[&](auto a,auto b){return a.first - a.second < b.first - b.second;});\n  \n  \n  int sy = S.first, sx = S.second;\n  auto calc=[&](double x){return DB[sy][sx] + x;};\n  \n  double ans = calc(sum/dot);\n  Min(ans, (double)DT[sy][sx]);\n  for(int i=0;i<(int)A.size() - 1;i++){\n    sum += A[i].first - A[i].second;\n    double x = sum / (dot - i - 1);\n    Min(ans, calc(x));\n  }\n  \n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e12), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 100; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] != 'g' && c[i][j] != '#' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  rep(i,H){\n    rep(j,W){\n      if( mincost[i][j][0] == IINF )  cout << \"X \";\n      else cout << mincost[i][j][0] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  rep(i,H){\n    rep(j,W){\n      if( mincost[i][j][1] == IINF )  cout << \"X \";\n      else cout << mincost[i][j][1] << \" \";\n    }\n    cout << endl;\n  }\n\n  ld L = 0, R = 1e100, M = 0;\n  rep(i,320){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint H, W;\nvector<string> fi;\nusing pint = pair<int,int>;\n\nvoid bfs(queue<pint> &que, vector<vector<int> > &dist) {\n    while (!que.empty()) {\n        auto p = que.front(); que.pop();\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = p.first + dx[dir], ny = p.second + dy[dir];\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n            if (fi[nx][ny] != '.' && fi[nx][ny] != 's') continue;\n            if (dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[p.first][p.second] + 1;\n                que.push(pint(nx, ny));\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> W >> H;\n    fi.resize(H);\n    for (int i = 0; i < H; ++i) cin >> fi[i];\n\n    pint s, g;\n    vector<pint> ss;\n    for (int i = 0; i < H; ++i) for (int j = 0; j < W; ++j) {\n            if (fi[i][j] == 'g') g = pint(i, j);\n            else if (fi[i][j] == 's') s = pint(i, j);\n            else if (fi[i][j] == '*') ss.push_back(pint(i, j));\n        }\n\n    vector<vector<int> > dpg(H, vector<int>(W, -1)), dps(H, vector<int>(W, -1));\n    queue<pint> queg;\n    queg.push(g), dpg[g.first][g.second] = 0;\n    bfs(queg, dpg);\n    queue<pint> ques;\n    for (auto p : ss) ques.push(p), dps[p.first][p.second] = 0;\n    bfs(ques, dps);\n\n    double low = 0, high = 1LL<<60;\n    for (int _ = 0; _ < 100; ++_) {\n        double t = (low + high) / 2; //cout << \"----------------\" << endl; cout << t << endl;\n        double sum = 0;\n        int N = 0;\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (fi[i][j] != '.' && fi[i][j] != 's') continue;\n                ++N;\n                double tmp = 1LL<<60;\n                if (dps[i][j] != -1 && tmp > dps[i][j] + t) tmp = dps[i][j] + t;\n                if (dpg[i][j] != -1 && tmp > dpg[i][j]) tmp = dpg[i][j];\n                sum += tmp;\n            }\n        }\n        if (t * N >= sum) high = t;\n        else low = t;\n    }\n\n    double res = 1LL<<60;\n    if (dps[s.first][s.second] != -1 && res > dps[s.first][s.second] + high)\n        res = dps[s.first][s.second] + high;\n    if (dpg[s.first][s.second] != -1 && res > dpg[s.first][s.second])\n        res = dpg[s.first][s.second];\n\n    cout << fixed << setprecision(12) << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint H,W;\nchar c[555][555];\nint sy,sx,gy,gx;\nint dist1[555][555],dist2[555][555];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H;\n\trep(i,H)rep(j,W){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sy=i,sx=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gy=i,gx=j;\n\t}\n\trep(i,H)rep(j,W){\n\t\tdist1[i][j]=dist2[i][j]=INF;\n\t}\n\tdist1[gy][gx]=0;\n\tqueue<pi> Q;\n\tQ.push(mp(gy,gx));\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist1[ny][nx]==INF){\n\t\t\t\tdist1[ny][nx]=dist1[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H)rep(j,W)if(c[i][j]=='*'){\n\t\tdist2[i][j]=0;\n\t\tQ.push(mp(i,j));\n\t}\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist2[ny][nx]==INF){\n\t\t\t\tdist2[ny][nx]=dist2[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi d1,d2;\n\tint start;\n\trep(i,H)rep(j,W)if(c[i][j]=='.'){\n\t\tif(i==sy && j==sx)start=sz(d1);\n\t\td1.pb(dist1[i][j]);\n\t\td2.pb(dist2[i][j]);\n\t}\n\t\n\tdouble lo=0,hi=250000;\n\trep(t,100){\n\t\tdouble mi=(lo+hi)/2;\n\t\tdouble sum=0;\n\t\trep(i,sz(d1)){\n\t\t\tsum+=min(1.*d1[i],d2[i]+mi);\n\t\t}\n\t\tif(sum>mi*sz(d1))lo=mi;\n\t\telse hi=mi;\n\t}\n\tprintf(\"%.16f\\n\",min(1.*d1[start],d2[start]+hi));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,59){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst double INF = 1e8;\n\nusing vd = vector<double>;\nusing V = vector<vd>;\n\nusing pi = pair<int,int>;\nusing P = pair<double,pi>;\n\nconst int dy[4]={1,-1,0,0}, dx[4]={0,0,1,-1};\n\nint main(){\n    int w,h;\n    cin >>w >>h;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    auto IN = [&](int y, int x){\n        return 0<=y && y<h && 0<=x && x<w;\n    };\n\n    auto calc = [&](double m){\n        V dp(h,vd(w,INF));\n\n        queue<pi> que;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='g'){\n                dp[i][j]=0;\n                que.push({i,j});\n            }\n            if(s[i][j]=='*'){\n                dp[i][j]=m;\n                que.push({i,j});\n            }\n        }\n\n        while(!que.empty()){\n            pi pos = que.front();\n            que.pop();\n            rep(d,4){\n                int ny = pos.fi+dy[d], nx = pos.se+dx[d];\n                if(IN(ny,nx) && s[ny][nx]!='#' && s[ny][nx]!='*'){\n                    if(dp[ny][nx] > dp[pos.fi][pos.se]+1){\n                        dp[ny][nx] = dp[pos.fi][pos.se]+1;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n        }\n\n        return dp;\n    };\n\n    double l=0, r=INF;\n    rep(loop,70){\n        double m = (l+r)/2;\n        V E = calc(m);\n\n        int n = 0;\n        double sumE = 0;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='.' || s[i][j]=='s'){\n                ++n;\n                sumE += E[i][j];\n            }\n        }\n        sumE /= n;\n\n        if(sumE<m) r=m;\n        else l=m;\n    }\n\n    V E = calc(l);\n    double ans=-1;\n    rep(i,h)rep(j,w)if(s[i][j]=='s') ans = E[i][j];\n    printf(\"%.15f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tlong long x,y;\n\tC(long long x,long long y):x(x),y(y){}\n};\nconst long long dx[]={1,0,-1,0};\nconst long long dy[]={0,1,0,-1};\n\nlong long w,h;\n\nbool in(long long x,long long y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nunsigned long long int dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(long long i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(long long j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=8000000000;\n\t\t\tdist_goal[i][j]=8000000000;\n\t\t\tdist_spring[i][j]=8000000000;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst long long NUM=4000;\n\tfor(long long t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] != 'g' && c[i][j] != '#' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e100, M = 0;\n  rep(i,520){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint W, H;\nint sx, sy, gx, gy;\nvector<string> vs;\nvector<vector<long double> > gdist;\nvector<vector<long double> > sdist;\n\nvoid make() {\n    gdist[gx][gy] = 0;\n    queue<P> que;\n    que.push(P(gx,gy));\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (0 <= nx && nx < H && 0 <= ny && ny < W && (vs[nx][ny] == '.' || vs[nx][ny] == 's') && gdist[nx][ny] > gdist[x][y] + 1) {\n                gdist[nx][ny] = gdist[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (vs[i][j] == '*') {\n                que.push(P(i,j));\n                sdist[i][j] = 0;\n            }\n        }\n    }\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (0 <= nx && nx < H && 0 <= ny && ny < W && (vs[nx][ny] == '.' || vs[nx][ny] == 's') && sdist[nx][ny] > sdist[x][y] + 1) {\n                sdist[nx][ny] = sdist[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n}\n\nlong double check(long double e) {\n    long double ret = 0.0;\n    int cnt = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (vs[i][j] == '.' || vs[i][j] == 's') {\n               long double dist = 1e+50;\n               dist = min(dist, gdist[i][j]);\n               dist = min(dist, sdist[i][j] + e);\n               ret += dist;\n               cnt ++;\n            }\n        }\n    }\n\n    return ret / (long double)cnt;\n}\n\nint main() {\n    cin >> W >> H;\n    vs.resize(H);\n    gdist.resize(H);\n    sdist.resize(H);\n    for (auto &i : gdist) i.resize(W, 1e50);\n    for (auto &i : sdist) i.resize(W, 1e50);\n    for (auto &i : vs) cin >> i;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (vs[i][j] == 'g') gx = i, gy = j;\n            if (vs[i][j] == 's') sx = i, sy = j;\n        }\n    }\n\n    make();\n\n    long double l = 0.0, r = 1e+18;\n    for (int c = 0; c < 100; c++) {\n        long double m = (l + r)/2.0;\n        // printf(\"%.10Lf\\n\", m);\n        if (check(m) > m) {\n            l = m;\n        } else {\n            r = m;\n        }\n    }\n    printf(\"%.10Lf\\n\", min(l + sdist[sx][sy], gdist[sx][sy]));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    cout<<fixed<<setprecision(10);\n}}init;\n\ninline bool isWall(char c){return c=='#';}\ninline bool isSpring(char c){return c=='*';}\ninline bool isFloor(char c){return c=='.'||c=='s';}\ninline bool isStart(char c){return c=='s';}\ninline bool isGoal(char c){return c=='g';}\ntemplate<typename T>\nistream& operator>>(istream& is,vector<T>& v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef long long LL;\nusing P=pair<int,int>;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF=1e12;\nconst int dir4[]={0,1,0,-1,0};\nint main(){\n    int R,C;\n    cin>>C>>R;\n    vector<string> maze(R);\n    int sr,sc,gr,gc,M=0;\n    cin>>maze;\n    \n    queue<P> que;\n    VV dG(R,V(C,INF));\n    VV dB(R,V(C,INF));\n    for(int r=0;r<R;r++)\n        for(int c=0;c<C;c++){\n            if(isSpring(maze[r][c])){\n                dB[r][c]=0;\n                que.push(P(r,c));\n            }\n            if(isFloor(maze[r][c])){\n                M++;\n            }\n            if(isStart(maze[r][c])){\n                sr=r,sc=c;\n            }\n            if(isGoal(maze[r][c])){\n                gr=r,gc=c;\n            }\n        }\n    while(que.size()){\n        int r,c;\n        tie(r,c)=que.front();\n        for(int i=0;i<4;i++){\n            int nr=r+dir4[i];\n            int nc=c+dir4[i+1];\n            if(isWall(maze[nr][nc]))continue;\n            if(dB[nr][nc]>dB[r][c]+1){\n                dB[nr][nc]=dB[r][c]+1;\n                que.push(P(nr,nc));\n            }\n        }\n        que.pop();\n    }\n    que.push(P(gr,gc));\n    dG[gr][gc]=0;\n    while(que.size()){\n        int r,c;\n        tie(r,c)=que.front();\n        for(int i=0;i<4;i++){\n            int nr=r+dir4[i];\n            int nc=c+dir4[i+1];\n            if(isWall(maze[nr][nc])||isSpring(maze[nr][nc]))continue;\n            if(dG[nr][nc]>dG[r][c]+1){\n                dG[nr][nc]=dG[r][c]+1;\n                que.push(P(nr,nc));\n            }\n        }\n        que.pop();\n    }\n    vector<P> fs;\n    auto b=[&](P p){return max(0ll,min(INF,dG[p.first][p.second]-dB[p.first][p.second]));};\n    for(int r=0;r<R;r++)\n        for(int c=0;c<C;c++)\n            if(isFloor(maze[r][c])){\n                fs.push_back(P(r,c));\n            }\n    sort(fs.begin(),fs.end(),[&](P p,P q){return b(p)<b(q);});\n    LL K=0;\n    int B=M;\n    for(int i=0,sz=fs.size();i<sz;i++){\n        K+=dB[fs[i].first][fs[i].second];\n    }\n    double res=INF;\n    K-=dB[fs[0].first][fs[0].second];\n    K+=dG[fs[0].first][fs[0].second];\n    B--;\n    LL prev=b(fs[0]);\n    for(int i=1,sz=fs.size();i<sz;i++){\n        LL now=b(fs[i]);\n        if(now!=prev){\n            double b=1.0-B/(double)M;\n            b=(K/(double)M)/b;\n            if(prev<=b&&b<=now){\n                res=min(res,b);\n            }\n        }\n        K-=dB[fs[i].first][fs[i].second];\n        K+=dG[fs[i].first][fs[i].second];\n        B--;\n        prev=now;\n    }\n    if(prev<INF){\n        double b=1.0-B/(double)M;\n        b=(K/(double)M)/b;\n        if(prev<=b&&b<=INF){\n            res=min(res,b);\n        }\n    }\n    cout<<min((double)dG[sr][sc],dB[sr][sc]+res)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nll A[500][500],B[500][500];\n\nvoid bfs(char ch,ll d[500][500]){\n  fill(d[0],d[500], (1LL<<50) );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  \n  bfs('*',A);\n  bfs('g',B);\n\n  vector<ll> v;\n  ll sum=0,cnt=0,base;\n  double ans=1e30;\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      cnt++;\n      sum+=B[i][j];\n      v.push_back(A[i][j]-B[i][j]);\n      if(t[i][j]=='s'){\n        base=A[i][j];\n        ans=min(ans, (double) B[i][j]);\n      }\n    }\n  }\n  ans=min(ans, (double)base + (double)sum / (double)cnt);\n  \n  sort(v.begin(),v.end());\n  for(int i=0;i+1<(int)v.size();i++){\n    sum+=v[i];\n    double rate=(double)(i+1)/(double)cnt;\n    double X=(double)sum/(double)cnt;\n    X/=(1.0-rate);\n    ans=min(ans,(double)base+X);\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e20, M = 0;\n  rep(i,70){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  //long double nE = 0.0;\n  int cnt = 0;\n  priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    long double l = que.top();\n    que.pop();\n    long double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+15;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 100) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W;\nint si,sj,ti,tj;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nint A[500][500],B[500][500];\n\nvoid bfs(char ch,int d[500][500]){\n  fill(d[0],d[500],1e9);\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  bfs('*',A);\n  bfs('g',B);\n\n  vector<int> v;\n  double sum=0,cnt=0,base;\n  double ans=1e9;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      cnt+=1.0;\n      sum+=B[i][j];\n      v.push_back(A[i][j]-B[i][j]);\n      \n      if(t[i][j]=='s'){\n        base=A[i][j];\n        ans=min(ans,(double)B[i][j]);\n      }\n    }\n  }\n\n  ans=min(ans, (double)base + (double)sum / (double)cnt);\n\n\n  sort(v.begin(),v.end());\n  \n  for(int i=0;i+1<(int)v.size();i++){\n    sum+=v[i];\n    double rate=(double) (i+1)/ (double) cnt;\n    double X= (double)sum / (double)cnt;\n    X/= (1.0-rate);\n    ans=min( ans, (double)base + X);\n  }\n\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e15), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 100; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e30;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e30;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=W*H;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nint dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tint num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\te[i][j]=500*500*500;\n\t\t\tdist_goal[i][j]=500*500*500;\n\t\t\tdist_spring[i][j]=500*500*500;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=4000;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nP dlt[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};\n\nvector<vector<char>> c;\nll h,w,f;\nP sp,gp;\nvector<P> spr;\nvector<vector<ll>> g_cost;\nvector<vector<ll>> s_cost;\n\nbool isfloor(P p) {\n\tif(p.first>=0&&p.first<h&&p.second>=0&&p.second<w&&\n\t   (c[p.first][p.second]=='.'||c[p.first][p.second]=='s')) return true;\n\telse return false;\n}\n\nvector<vector<ll>> dijkstra(vector<P> s) {\n\tvector<vector<ll>> dst(h,vector<ll>(w,INF));\n\tpriority_queue<pair<ll,P>,vector<pair<ll,P>>,greater<pair<ll,P>>> q;\n\tREP(i,(ll)s.size()) {\n\t\tdst[s[i].first][s[i].second]=0;\n\t\tq.push(make_pair(0,s[i]));\n\t}\n\twhile(!q.empty()) {\n\t\tll d=q.top().first;\n\t\tP p=q.top().second;\n\t\tq.pop();\n\t\tif(dst[p.first][p.second]!=d) continue;\n\t\tREP(i,4) {\n\t\t\tP np=P(p.first+dlt[i].first,p.second+dlt[i].second);\n\t\t\tif(isfloor(np)&&dst[np.first][np.second]>d+1) {\n\t\t\t\tdst[np.first][np.second]=d+1;\n\t\t\t\tq.push(make_pair(dst[np.first][np.second],np));\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}\n\nvoid init() {\n\tcin>>w>>h;\n\tc.assign(h,vector<char>(w));\n\tREP(i,h) REP(j,w) cin>>c[i][j];\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') f++;\n\tREP(i,h) REP(j,w) if(c[i][j]=='s') sp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='g') gp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='*') spr.pb(P(i,j));\n\tg_cost=dijkstra(vector<P>(1,gp));\n\ts_cost=dijkstra(spr);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tinit();\n\tif(g_cost[sp.first][sp.second]<=s_cost[sp.first][sp.second]) {\n\t\tcout<<fixed<<setprecision(39)<<g_cost[sp.first][sp.second]<<endl;\n\t\treturn 0;\n\t}\n\tll cons=0;\n\tll cf=0;\n\tpriority_queue<ll,vector<ll>,greater<ll>> diff;\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') {\n\t\tcons+=g_cost[i][j];\n\t\tif(s_cost[i][j]<g_cost[i][j]) diff.push(s_cost[i][j]-g_cost[i][j]);\n\t}\n\tld min_x=cons/(ld)f;\n\twhile(!diff.empty()) {\n\t\tll c=diff.top();\n\t\tdiff.pop();\n\t\tcons+=c;\n\t\tcf++;\n\t\tmin_x=min(min_x,cons/(ld)(f-cf));\n\t}\n\tcout<<fixed<<setprecision(39)<<min(\n\t(ld)g_cost[sp.first][sp.second],s_cost[sp.first][sp.second]+min_x)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(int i=0;i<h;i++) cin>>s[i];\n  vector<vector<int> > dg(h,vector<int>(w,-1)),ds=dg;\n  using T = pair<int,int>;\n  queue<T> qg,qs;\n  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  int dy[]={0,0,1,-1};\n  int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      int y=t.first,x=t.second;\n      for(int k=0;k<4;k++){\n\tint ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](int i,int j,double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (double)dg[i][j];\n    return double(0);\n  };\n  \n  auto calc=[&](double p){\n    double q=0;\n    int c=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc++;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12f %.12f\\n\",p, abs(p-q));\n    return abs(p-q);\n  };\n\n  double l=0,r=1e9;\n  \n  for(int k=0;k<200;k++){\n    double m1=l+(r-l)/3;\n    double m2=l+(r-l)/3*2;\n    if(calc(m1)<calc(m2)) r=m2;\n    else l=m1;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12f\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H*2, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<one, vector<one>, greater<one>>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16500; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <cassert>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n#define double long double\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 1000000000000ll;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// ?????¢??°????\\???§??????????????¨??????\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 1000){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// ?????¢??°????\\??°???????????±???????\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\n/*long double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k,\n                   const int s=0){\n    const int N = v.size();\n    int l = as[k];\n    int r = bs[N] - bs[k];\n    if(s > 1000) return 1.0F * (l+r) / N;\n    return (l + r + (1.0F * (N-k) * calc_e(v,as,bs,k,s+1)))/N;\n    }*/\n\ndouble target(const vector<Info>& dots, double e) {\n    double t = 0.0;\n    for (const auto & i : dots) {\n        t += min((double)i.to_spring, i.to_goal - e);\n    }\n    return t;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n    /* {info[i][j] |-> ??´???????????§????????¢?????´?????????????????§????????¢} */\n    \n    \n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                if (info[i][j].to_goal > INF / 2 &&\n                    info[i][j].to_spring > INF / 2) {continue;}\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    /* dots???????????§?£?????????´?????¨??????info?????\\?????? */ \n    double minimum = 0, maximum = 1e15;\n    //    assert (target(dots, minimum) > 0);\n    //    dump(dots);\n    //    dump(target(dots, maximum));\n    //    assert (target(dots, maximum) < 0);\n\n    for (int i = 0; i < 500; i++) {\n        double half = (minimum + maximum) / 2.;\n        double val = target(dots, half);\n        //        dump(half);\n        //        dump(val);\n        if (val > 0) {\n            minimum = half;\n        } else {\n            maximum = half;\n        }\n    }\n    dump(minimum);\n    auto si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;});\n    cout << fixed << setprecision(12);\n    cout << min(si->to_spring + minimum, (double)si->to_goal) << endl;\n    return 0;\n    /*    \n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n    // dump(bs[N]);\n    // dump(as[N]);\n    // dump((long double)(as[si+1] - as[si]));\n    // dump((long double)(bs[si+1] - bs[si]));\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c + 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    int ls = as[1] - bs[1];\n    int rs = as[N] - as[N-1] - (bs[N] - bs[N-1]);\n    auto r = ternary_search_concave(f,ls,rs);\n    // for(int i=0;i<N;i++){\n    //     double d = as[i+1] - as[i] - (bs[i+1] - bs[i]);\n    //     cerr << d << \" -> \" << f(d) << endl;\n    // }\n\n    cout << fixed << setprecision(12);\n    cout << f(r) << endl;\n    return 0;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nint h, w;\nP st, go;\nchar b[500][500];\nint gist[500][500], wist[500][500];\nqueue<P> que;\nint dh[4] = {1,0,-1,0};\nint dw[4] = {0,1,0,-1};\nint flo = 0;\n\nint main(){\n    cin >> w >> h;\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    rep(i,h) rep(j,w){\n        if(b[i][j] == 's'){\n            st.first = i;\n            st.second = j;\n            b[i][j] = '.';\n        }\n        if(b[i][j] == '.'){\n            flo++;\n        }\n        if(b[i][j] == 'g'){\n            go.first = i;\n            go.second  = j;\n            b[i][j] = '.';\n        }\n    }\n    rep(i,h) rep(j,w){\n        gist[i][j] = INF;\n        wist[i][j] = INF;\n    }\n    gist[go.first][go.second] = 0;\n    que.push(go);\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(gist[nh][nw] <= gist[p.first][p.second]+1) continue;\n            gist[nh][nw] = gist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '*'){\n            que.push(P(i,j));\n            wist[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(wist[nh][nw] <= wist[p.first][p.second]+1) continue;\n            wist[nh][nw] = wist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    double s = 0.0, e = 1000000000000.0, mid;\n    rep(u,1000){\n        mid = (s+e)/2.0;\n        double sum = 0.0;\n        rep(i,h) rep(j,w){\n            if(b[i][j] == '.' && go != P(i,j)){\n                sum += min((double)gist[i][j],wist[i][j]+mid);\n            }\n        }\n        sum /= (double)flo;\n        if(mid > sum){\n            e = mid;\n        } else{\n            s = mid;\n        }\n    }\n    double ans = min((double)gist[st.first][st.second],wist[st.first][st.second]+mid);\n    printf(\"%.15f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// ???????°???°???????????¢?´¢\nld BinarySearchReal(ld rl, ld rr, function<bool(ld)> f) { \n    rep(i, 200) { ld m = (rl + rr) / 2; f(m)?rr=m:rl=m; }\n    return rl;\n}\nvoid BinarySearchRealInteractive(ld rl, ld rr, function<bool(ld)> f) { \n    while (1) {\n        cout << \"####\" << endl;\n        ld tmp; cin >> tmp;\n        if (rl > tmp) {cout << \"Out of range: too small\" << endl; continue; }\n        if (rr < tmp) {cout << \"Out of range: too large\" << endl; continue; }\n        ld ret = f(tmp); cout << tmp << \" : \" << ret << endl;\n    }\n}\n\nchar m[500][500] = {};\nll b[500][500] = {};\nll g[500][500] = {};\nvoid print_map(ll w, ll h) {\n    rep(hi, h) {\n        rep(wi, w) {\n            cout << m[hi][wi];\n        }\n        cout << endl;\n    }\n}\n\nvoid print_bane(ll w, ll h) {\n    rep(hi, h) {\n        rep(wi, w) {\n            if (b[hi][wi] == INF) \n                cout << -1 << \"\\t\";\n            else\n                cout << b[hi][wi] << \"\\t\";\n        }\n        cout << endl;\n    }\n}\n\nvoid print_goal(ll w, ll h) {\n    rep(hi, h) {\n        rep(wi, w) {\n            if (g[hi][wi] == INF) \n                cout << -1 << \"\\t\";\n            else\n                cout << g[hi][wi] << \"\\t\";\n        }\n        cout << endl;\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll w, h; cin >> w >> h;\n    rep(hi, h) {\n        rep(wi, w) {\n            cin >> m[hi][wi];\n        }\n    }\n//    print_map(w, h);\n\n    rep(hi, h) {\n        rep(wi, w) {\n            b[hi][wi] = INF;\n        }\n    }\n    rep(hi, h) {\n        rep(wi, w) {\n            g[hi][wi] = INF;\n        }\n    }\n\n    vector<ll> dh = {1, 0, -1, 0};\n    vector<ll> dw = {0, 1, 0, -1};\n    queue<P> q;\n\n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == '*') {\n                q.push(P(hi, wi));\n                b[hi][wi] = 0;\n            }\n        }\n    }\n    while (!q.empty()) {\n        P pos = q.front(); q.pop();\n        ll hi = pos.fi, wi = pos.se;\n        ll pos_dist = b[hi][wi];\n        rep(d, 4) {\n            ll next_hi = hi + dh[d];\n            ll next_wi = wi + dw[d];\n            if (next_hi < h && next_hi >= 0 && \n                next_wi < w && next_wi >= 0 &&\n                (m[next_hi][next_wi] == '.' || m[next_hi][next_wi] == 's') && \n                b[next_hi][next_wi] == INF) {\n\n                b[next_hi][next_wi] = pos_dist + 1;\n                q.push(P(next_hi, next_wi));\n            }\n        }\n    }\n//    cout << endl;\n//    print_bane(w, h);\n    \n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == 'g') {\n                q.push(P(hi, wi));\n                g[hi][wi] = 0;\n            }\n        }\n    }\n    while (!q.empty()) {\n        P pos = q.front(); q.pop();\n        ll hi = pos.fi, wi = pos.se;\n        ll pos_dist = g[hi][wi];\n        rep(d, 4) {\n            ll next_hi = hi + dh[d];\n            ll next_wi = wi + dw[d];\n            if (next_hi < h && next_hi >= 0 && \n                next_wi < w && next_wi >= 0 &&\n                (m[next_hi][next_wi] == '.' || m[next_hi][next_wi] == 's') && \n                g[next_hi][next_wi] == INF) {\n\n                g[next_hi][next_wi] = pos_dist + 1;\n                q.push(P(next_hi, next_wi));\n            }\n        }\n    }\n//    cout << endl;\n//    print_goal(w, h);\n \n    vector<P> bg;\n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == '.') {\n                bg.pb(P(b[hi][wi], g[hi][wi]));\n            }\n        }\n    }\n    ll n = bg.size();\n\n    // !!!!!!!!!!!!!!!!!!!! 1e8 !!!!!!!!!!!!!!!!!!!!\n    function<bool(ld)> f = [&](ld e){\n        ll k = 0;\n        ll bsum = 0; \n        ll gsum = 0; \n        for (auto x : bg) {\n            if (x.fi + e < x.se) {\n                k++;\n                bsum += x.fi;\n            } else {\n                gsum += x.se;\n            }\n        }\n        return e * (n - k) > bsum + gsum;\n    };\n    ld e = BinarySearchReal(0, 1e40,  f);\n//    cout << e << endl;\n\n    ll hs = -1, ws = -1;\n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == 's') {\n                hs = hi;\n                ws = wi;\n            }\n        }\n    }\n    cout << ldout << min((ld)b[hs][ws] + e, (ld)g[hs][ws]) << endl;\n    \n    // 5 1\n    // .g...s*\n    //\n    //\n    // 7 1\n    // .g...s*\n    //\n    // 8 1\n    // .g...s.*\n    // # e = 2\n    // # e = (1+1+2+3)/5 + (1+e)/5\n    //\n    // e??£?????????????????§?????????????????¨????????????\n    // sample 2??§e=2.8e15???????????????\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <cassert>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 1000000000000ll;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// ?????¢??°????\\???§??????????????¨??????\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 1000){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// ?????¢??°????\\??°???????????±???????\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\nlong double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k,\n                   const int s=0){\n    const int N = v.size();\n    int l = as[k];\n    int r = bs[N] - bs[k];\n    if(s > 1000) return 1.0F * (l+r) / N;\n    return (l + r + (1.0F * (N-k) * calc_e(v,as,bs,k,s+1)))/N;\n}\n\ndouble target(const vector<Info>& dots, double e) {\n    double t = 0.0;\n    for (const auto & i : dots) {\n        t += min((double)i.to_spring, i.to_goal - e);\n    }\n    return t;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n    /* {info[i][j] |-> ??´???????????§????????¢?????´?????????????????§????????¢} */\n    \n    \n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                if (info[i][j].to_goal > INF / 2 &&\n                    info[i][j].to_spring > INF / 2) {continue;}\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    /* dots???????????§?£?????????´?????¨??????info?????\\?????? */ \n    double minimum = 0, maximum = 1000000;\n    //    assert (target(dots, minimum) > 0);\n    //    dump(dots);\n    //    dump(target(dots, maximum));\n    //    assert (target(dots, maximum) < 0);\n\n    for (int i = 0; i < 100; i++) {\n        double half = (minimum + maximum) / 2.;\n        double val = target(dots, half);\n        //        dump(half);\n        //        dump(val);\n        if (val > 0) {\n            minimum = half;\n        } else {\n            maximum = half;\n        }\n    }\n    dump(minimum);\n    auto si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;});\n    cout << fixed << setprecision(12);\n    cout << min(si->to_spring + minimum, (double)si->to_goal) << endl;\n    return 0;\n    /*    \n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n    // dump(bs[N]);\n    // dump(as[N]);\n    // dump((long double)(as[si+1] - as[si]));\n    // dump((long double)(bs[si+1] - bs[si]));\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c + 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    int ls = as[1] - bs[1];\n    int rs = as[N] - as[N-1] - (bs[N] - bs[N-1]);\n    auto r = ternary_search_concave(f,ls,rs);\n    // for(int i=0;i<N;i++){\n    //     double d = as[i+1] - as[i] - (bs[i+1] - bs[i]);\n    //     cerr << d << \" -> \" << f(d) << endl;\n    // }\n\n    cout << fixed << setprecision(12);\n    cout << f(r) << endl;\n    return 0;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<long long int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(9999999999);\n\t\t\tgot[i].emplace_back(9999999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1e18;\n\tbool ok = true;\n\twhile (amin + 1e-10 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tif (got[y][x] == 9999999999 && spt[y][x] == 9999999999) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<long double>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans;\n\tif (ok) {\n\t\tans = min(static_cast<long double>(got[sy][sx]), spt[sy][sx] + amin);\n\n\t}\n\telse {\n\t\tans = static_cast<long double>(got[sy][sx]);\n\t}\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\n\nint main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = 11451419;\n\t\t\tb[i][j] = 11451419;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = 1145141919;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\tif (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing dbl = long double;\nusing Pi = pair<int, int>;\n\nconst dbl eps = 1e-15;\n#define lt(a, b) ((a)-(b) < -eps)\n#define eq(a, b) (fabs((a)-(b)) < eps)\n\nint W, H;\nchar mas[505][505];\nPi S, G;\nvector<Pi> Bs;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nvector<vector<dbl> > bfs(const vector<Pi>& s) {\n  //cout<<\"!!!!!\"<<endl;\n  queue<Pi> que;\n  vector<vector<dbl> > dist(H, vector<dbl>(W, -1));\n  for(Pi p : s) {\n    que.emplace(p);\n    dist[p.first][p.second] = 0;\n  }\n  while(!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front(); que.pop();\n    //cout<<mas[y][x]<<\" \"<<y<<\" \"<<x<<endl;    \n    for(int i = 0; i < 4; ++i) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#' || mas[ny][nx] == '*') continue;\n      if(dist[ny][nx] == -1) {\n\tdist[ny][nx] = dist[y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n  return dist;\n}\n\nvector<vector<dbl> > db;\nvector<vector<dbl> > dg;\n\nbool check(dbl mb) {\n  dbl sum = 0;\n  int num = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.') {\n\tif(dg[i][j] == -1 && db[i][j] == -1) continue;//assert(false);\n\telse if(dg[i][j] == -1) sum += db[i][j]+mb;\n\telse if(db[i][j] == -1) sum += dg[i][j];\n\telse sum += min(dg[i][j], db[i][j]+mb);\n\t++num;\n      }\n    }\n  }\n  assert(num > 0);\n  sum /= num;\n  return sum >= mb;\n}\n\nint main() {\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 's') S = Pi(i, j), mas[i][j] = '.';\n      else if(mas[i][j] == 'g') G = Pi(i, j);\n      else if(mas[i][j] == '*') Bs.emplace_back(i, j);\n    }\n  }\n\n  db = bfs(Bs);\n  dg = bfs({G});\n\n  dbl ans = dg[S.first][S.second];\n  //cout<<ans<<endl;\n  /*\n  bool flag = false;  \n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.' && dg[i][j] == -1 && db[i][j] == -1) flag = true;\n    }\n  }\n  */\n  if(ans == -1) ans = DBL_MAX/2;\n  else if(db[S.first][S.second] == -1) {\n  //else if(flag) {\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n  }\n\n  dbl lb = 0, ub = 1e20;\n  for(int i = 0; i < 200; ++i) {\n    dbl mb = (lb+ub)/2;\n    if(check(mb)) lb = mb;\n    else ub = mb;\n  }\n\n  ans = min(ans, db[S.first][S.second]+lb);\n\n  cout << fixed << setprecision(12) << ans << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 17000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ld MAX = 10000000000000;\nconst ld EPS = 0.0000000001;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int w,h;\n\tstatic char c[502][502];\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h){\n\t\tscanf(\"\\n\");\n\t\trep(j,w){\n\t\t\tscanf(\"%c\",&c[i][j]);\n\t\t}\n\t}\n\t\n\tstatic ld a[502][502];\n\tstatic bool used[502][502];\n\tstatic queue<pair<ld,P>> que;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 'g'){\n\t\t\ta[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse a[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(a[nx][ny] > a[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\ta[nx][ny] = a[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(a[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tstatic ld b[502][502];\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == '*'){\n\t\t\tb[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse b[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(b[nx][ny] > b[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\tb[nx][ny] = b[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(b[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tbool t;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's' && b[i][j] == MAX)t = true;\n\t}\n\trep(i,h)rep(j,w){\n\t\tif(a[i][j] == MAX && b[i][j] == MAX)c[i][j] = '#';\n\t\tif(t && a[i][j] == MAX)c[i][j] = '#';\n\t}\n\t\n\tld l = 0.0 , r = MAX;\n\twhile(l+EPS < r){\n\t\tld m = (l+r)/2;\n\t\tld sum = 0.0 , cnt = 0.0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(c[i][j] == '#' || c[i][j] == '*' || c[i][j] == 'g')continue;\n\t\t\tsum += min ( a[i][j] , m+b[i][j] );\n\t\t\tcnt += 1.0;\n\t\t}\n\t\t//cout << l << \" \" << r << \":\" << endl;\n\t\t//cout << \"m = \" << m << endl;\n\t\t//cout << \"sum = \" << sum << \",cnt = \" << cnt << endl;\n\t\tif(m*cnt > sum)r = m;\n\t\telse l = m;\n\t}\n\t\n\t/*rep(i,h){\n\t\trep(j,w){\n\t\t\tif(a[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)a[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(b[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)b[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tcout.precision(20);\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's'){\n\t\t\tcout << min ( a[i][j] , l+b[i][j] ) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,55){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=5e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a-1==0)break;\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e30), l = 0.0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 100; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0.0;\n    long double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i = 0; i < (n); i++)\n#define fi first\n#define se second\n\nconst int INF = 1e9;\n\nint W, H;\nvector<string> brd;\nvector<vector<int> > dist_spring;\nvector<vector<int> > dist_goal;\n\nbool check(int y, int x) {\n\treturn 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid bfs(queue<pii> q, vector<vector<int> > & res) {\n\tint d = 0;\n\tqueue<pii> nex;\n\twhile(q.size()) {\n\t\twhile(q.size()) {\n\t\t\tpii crd;\n\t\t\tcrd = q.front(); q.pop();\n\t\t\tres[crd.fi][crd.se] = min(res[crd.fi][crd.se], d);\n\t\t\trep(i,4) {\n\t\t\t\tconst int dxy[] = {0,1,0,-1,0};\n\t\t\t\tint ny, nx;\n\t\t\t\tny = crd.fi + dxy[i];\n\t\t\t\tnx = crd.se + dxy[i+1];\n\t\t\t\tif(check(ny,nx) && (brd[ny][nx] == '.' || brd[ny][nx] == 's')\n\t\t\t\t\t\t&& res[ny][nx] == INF) {\n\t\t\t\t\tnex.push(pii(ny,nx));\n\t\t\t\t\tres[ny][nx] = d+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = nex;\n\t\twhile(nex.size()) nex.pop();\n\t\td++;\n\t}\n}\n\nvoid make_dist_spring() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_spring.push_back(vector<int>(W, INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == '*')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_spring);\n}\n\nvoid make_dist_goal() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_goal.push_back(vector<int>(W,INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == 'g')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_goal);\n}\n\nint main() {\n\tpii st;\n\tcin >> W >> H;\n\trep(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tbrd.push_back(s);\n\t\trep(j, W) {\n\t\t\tif(s[j] == 's')\n\t\t\t\tst = pii(i,j);\n\t\t}\n\t}\n\tmake_dist_spring();\n\tmake_dist_goal();\n\n\tdouble l, r, m;\n\tl = 0; r = 1e15;\n\trep(i,100) {\n\t\tm = (l+r) / 2;\n\t\tdouble a, b;\n\t\ta = b = 0;\n\t\trep(j, H) {\n\t\t\trep(k, W) {\n\t\t\t\tif(brd[j][k] == '.' || brd[j][k] == 's') {\n\t\t\t\t\ta += min((double)dist_goal[j][k], dist_spring[j][k] + m);\n\t\t\t\t\tb += m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a > b)\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tcout << setprecision(15) << fixed <<\n\t\tmin((double)dist_goal[st.fi][st.se], dist_spring[st.fi][st.se] + m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF (1<<25)\nint W,H;\nchar fie[502][502];\nint bfs[502][502];\nint sps[502][502];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct P{\n  int x,y,c;\n  P(int x,int y,int c) : x(x),y(y),c(c) {}\n};\nvector<P> p;\nvector<P> s;\nvoid BFS(int x,int y){\n  queue<P> q;\n  q.push(P(x,y,0));\n  bfs[x][y]=0;\n  while(!q.empty()){\n    P p = q.front(); q.pop();\n    x = p.x;\n    y = p.y;\n    int c = p.c;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='#' || fie[nx][ny]=='*') continue;\n      if(bfs[nx][ny]!=-1) continue;\n      bfs[nx][ny]=c+1;\n      q.push(P(nx,ny,c+1));\n    }\n  }\n  for(int i=0;i<(int)p.size();i++)\n    if(bfs[p[i].x][p[i].y]!=-1) p[i].c = bfs[p[i].x][p[i].y];\n}\n\nvoid BFS2(int x,int y){\n  queue<P> q;\n  q.push(P(x,y,0));\n  sps[x][y]=0;\n  while(!q.empty()){\n    P p = q.front(); q.pop();\n    x = p.x;\n    y = p.y;\n    int c = p.c;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='#' || fie[nx][ny]=='*') continue;\n      if(sps[nx][ny]<=c+1 && sps[nx][ny]!=-1) continue;\n      sps[nx][ny]=c+1;\n      q.push(P(nx,ny,c+1));\n    }\n  }\n}\ndouble dp[501][501][50];\nint used[501][501][50];\ndouble solve(int x,int y,int jc){\n  if(jc>=45){\n    used[x][y][jc]=1;\n    if(bfs[x][y]==-1) return dp[x][y][jc]=(double)INF;\n    return dp[x][y][jc]=(double)bfs[x][y];\n  }\n  if(used[x][y][jc]) return dp[x][y][jc];\n  double ret = 0.0f;\n  if(sps[x][y]==-1) return dp[x][y][jc]=(double)bfs[x][y];\n  for(int i=0;i<(int)p.size();i++){\n    ret += (solve(p[i].x,p[i].y,jc+1)+(double)sps[x][y])/(double)p.size();\n  }\n  ret = min((double)(bfs[x][y]>0?bfs[x][y]:INF),ret);\n  //  printf(\"st :: %d %d %d ,  %lf %lf\\n\",x,y,jc,ret,(double)bfs[x][y]); \n  used[x][y][jc]=1;\n  return dp[x][y][jc]=ret;\n}\n\nint main(){\n  int gx,gy;\n  int sx,sy;\n  cin >> W >> H;\n  memset(bfs,-1,sizeof(bfs));\n  memset(sps,-1,sizeof(sps));\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i];\n      if(fie[j][i]=='.' || fie[j][i]=='s') p.push_back(P(j,i,INF));\n      if(fie[j][i]=='s'){ sx = j; sy = i; }\n      if(fie[j][i]=='g'){ gx = j; gy = i; }\n      if(fie[j][i]=='*') s.push_back(P(j,i,0));\n    }\n  }\n  BFS(gx,gy);\n  for(int i=0;i<(int)s.size();i++) BFS2(s[i].x,s[i].y);\n  printf(\"%.12lf\\n\",solve(sx,sy,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e8;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\nvector<double> dist;\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, double> is_lower(const double e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, double> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tdouble total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\tdouble ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\tdouble lb = 0, ub = 1e10;\n\tdouble ans = 0;\n\tconst int max_step = 100;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst double INF = 1e18;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(double dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1.0 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    double dist_goal[500][500], dist_spring[500][500];\n    REP(y, H) REP(x, W) dist_goal[y][x] = dist_spring[y][x] = -1.0;\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e6;\n    REP(_, 50){\n      const double sum = (ub + lb) * 0.5;\n      double S = 0;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        double exp = min(dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S += exp;\n      }\n      if(sum - S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = lb / N;\n    printf(\"%.12f\\n\", min(dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\nlong double vs[510 * 510];\nlong double calc(long double E) {\n  long double nE = 0.0;\n  int cnt = 0;\n  //priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      vs[cnt++] = ToGoal(x, y, E);\n      //que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      //cnt++;\n    }\n  }\n  sort(vs, vs + cnt);\n  REP(i, cnt) {\n    nE += vs[i];\n    //long double l = que.top();\n    //que.pop();\n    //long double r = que.top();\n    //que.pop();\n    //que.push(l + r);\n  }\n  return nE / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+20;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 300) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=5e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint w,h;\nvector<string> mp;\n\nvector<vector<int> > bfs(char start){\n  int dx[] = {1,-1,0,0};\n  int dy[] = {0,0,1,-1};\n  \n  queue<P> Q;\n  vector<vector<int> > D(h,vector<int> (w,INF));\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == start) Q.push(P(i,j)), D[i][j] = 0;\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y, x; tie(y, x) = t;\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if(mp[ny][nx] == '#' || mp[ny][nx] == '*') continue;\n      if(D[ny][nx] != INF) continue;\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(ny, nx));\n    }  \n  }\n  return D;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>w>>h;\n  mp.resize(h);\n  cin>>mp;\n\n  P S, T;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 's') S = P(i,j), mp[i][j] = '.';\n      if(mp[i][j] == 'g') T = P(i,j);\n    }\n\n  auto DB = bfs('*');\n  auto DT = bfs('g');\n  \n  vector<P> A;\n  double dot = 0;\n  int sum = 0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] != '.') continue;\n      if(DB[i][j] == INF && DT[i][j] == INF) continue;\n      if(DB[i][j] == INF) {sum += DT[i][j]; continue;}\n      if(DT[i][j] == INF) {sum += DB[i][j]; continue;}\n      A.push_back(P(DB[i][j], DT[i][j]));\n      dot++;\n    }\n  \n  for(auto p:A) sum += p.second;\n\n  sort(A.begin(),A.end(),[&](auto a,auto b){return a.first - a.second < b.first - b.second;});\n  \n  \n  int sy = S.first, sx = S.second;\n  auto calc=[&](double x){return DB[sy][sx] + x;};\n  \n  double ans = calc(sum/dot);\n  Min(ans, (double)DT[sy][sx]);\n  for(int i=0;i<(int)A.size() - 1;i++){\n    sum += A[i].first - A[i].second;\n    double x = sum / (dot - i - 1);\n    Min(ans, calc(x));\n  }\n  \n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\nconst int INFLL=1001001001001001001ll;\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint dy[4]={-1,0,1,0};\nint dx[4]={0,-1,0,1};\n\nint H,W;\nchar fld[555][555];\ndouble E[555][555];\nbool check(double e){\n    queue<pint>que;\n    fill_n(*E,555*555,1e14);\n    rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n        E[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(true){\n        if(que.size()==0){\n            if(flag)break;\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n            continue;\n        }\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n\n        if(E[y][x]+1>=e&&!flag){\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n        }\n\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||fld[ny][nx]=='*')continue;\n\n            if(E[ny][nx]!=1e14)continue;\n            E[ny][nx]=E[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    double sum=0;\n    int cnt=0;\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='#'||fld[i][j]=='*'||fld[i][j]=='g')continue;\n        cnt++;sum+=E[i][j];\n    }\n\n    return sum<=e*cnt;\n}\n\n\nsigned main(){\n    cin>>W>>H;\n    rep(i,H)cin>>fld[i];\n\n    vector<vint>dist(H,vint(W,INT_MAX));\n    queue<pint>que;\n    rep(i,H)rep(j,W)if(fld[i][j]=='s'){\n        dist[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||dist[ny][nx]!=INT_MAX)continue;\n            if(fld[ny][nx]=='*')flag=true;\n            dist[ny][nx]=dist[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    if(!flag){\n        rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n            printf(\"%.20f\\n\",(double)dist[i][j]);\n            return 0;\n        }\n    }\n\n    double lb=0,ub=1e12;\n    rep(i,100){\n        double mid=(ub+lb)/2;\n        if(check(mid))ub=mid;\n        else lb=mid;\n    }\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='s'){\n            printf(\"%.20f\\n\",E[i][j]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500.0*500*500*500;\n    rep(_,300){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e50\n\nusing namespace std;\n\ntypedef pair<int, int> pos;\ntypedef pair<double, pos> P;\n\nint W, H;\nchar map[505][505];\nint sx, sy, gx, gy;\ndouble dist[505][505];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dijkstra(double m)\n{\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tdist[x][y] = inf;\n\t\t}\n\t}\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tdist[gx][gy] = 0, Q.push( make_pair(0, make_pair(gx, gy)) );\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '*') dist[x][y] = m, Q.push(make_pair(m, make_pair(x, y)));\n\t\t}\n\t}\n\t\n\tint x, y;\n\tdouble d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tx = Q.top().second.first;\n\t\ty = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(dist[x][y] < d) continue;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx <= 0 || nx > W || ny <= 0 || ny > H) continue;\n\t\t\tif(map[nx][ny] != '.') continue;\n\t\t\tif(dist[nx][ny] > d + 1){\n\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\tQ.push( make_pair(dist[nx][ny], make_pair(nx, ny)) );\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(double m)\n{\n\tdijkstra(m);\n\tdouble ret = 0; int cnt = 0;\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '.' && (x != gx || y != gy)){\n\t\t\t\tret += dist[x][y];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tret /= cnt;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> W >> H;\n\tfor(int y = 1; y <= H; y++){\n\t\tfor(int x = 1; x <= W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 's'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tsx = x, sy = y;\n\t\t\t}\n\t\t\tif(map[x][y] == 'g'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tgx = x, gy = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ub = 1e36, lb = 0.0, mid;\n\tfor(int i = 0; i < 200; i++){\n\t\tmid = (ub + lb) * 0.5;\n\t\tif(calc(mid) < mid) ub = mid;\n\t\telse lb = mid;\n\t}\n\tmid = (ub + lb) * 0.5;\n\tcalc(mid);\n\t\n\tprintf(\"%.11f\\n\", dist[sx][sy]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e15), l = 0.0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 100; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0.0;\n    long double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long double real;\nconst real inf = 1e20;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\nvector<real> dist;\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, real> is_lower(const real e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, real> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] <= d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\treal total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\treal ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\treal lb = 0, ub = inf / 2;\n\treal ans = 0;\n\tconst int max_step = 200;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\treal mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20Lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <iomanip>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct state {\n\tint x, y; long double dist;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.dist < s2.dist;\n}\nint dir[4] = { 0, 1, 0, -1 };\nint H, W, sx, sy; long double dist[555][555]; string s[555];\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tif (s[i].find('s') != string::npos) {\n\t\t\tsx = i; sy = s[i].find('s');\n\t\t}\n\t}\n\tlong double l = 0.0, r = 1.0e+10;\n\tfor (int i = 0; i < 80; i++) {\n\t\tlong double m = (l + r) * 0.5;\n\t\tpriority_queue<state> que;\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tfor (int k = 0; k < W; k++) {\n\t\t\t\tdist[j][k] = 1.0e+15;\n\t\t\t\tif (s[j][k] == 'g') {\n\t\t\t\t\tdist[j][k] = 0.0;\n\t\t\t\t\tque.push(state{ j, k, 0.0 });\n\t\t\t\t}\n\t\t\t\tif (s[j][k] == '*') {\n\t\t\t\t\tdist[j][k] = m;\n\t\t\t\t\tque.push(state{ j, k, -m });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = u.x + dir[i], ty = u.y + dir[i ^ 1];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && s[tx][ty] != '*' && dist[tx][ty] > dist[u.x][u.y] + 1.0L) {\n\t\t\t\t\tdist[tx][ty] = dist[u.x][u.y] + 1.0L;\n\t\t\t\t\tque.push(state{ tx, ty, -dist[tx][ty] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double sum = 0.0; int cnt = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 's' || s[i][j] == '.') {\n\t\t\t\t\tsum += dist[i][j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sum < m * cnt) r = m;\n\t\telse l = m;\n\t}\n\tcout << fixed << setprecision(10) << dist[sx][sy] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e10), l = 0.0, r = INF, exp_[H][W], exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  queue< pair<int,int> > que;\n  que.push(make_pair(gx,gy));\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      exp_[i][j] = INF;\n      exp[i][j] = INF;\n    }\n  }\n\n  exp_[gx][gy] = 0.0;\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k){\n      int x_ = x + d[k], y_ = y + d[(k+1)%4];\n      if(x_ >= H || x_ < 0 || y_ >= W || y_ < 0) continue;\n      char c = M[x_][y_];\n      if(c == '.' && exp_[x_][y_] > exp_[x][y]+1){\n\texp_[x_][y_] = exp_[x][y]+1;\n\tque.push(make_pair(x_,y_));\n      }\n    }\n  }\n  vector< vector<double> > dist_from_spring(H, vector<double>(W, INF));\n  for(int i = 0; i < springs.size(); ++i){\n    queue< pair<int,int> > que2;\n    que2.push(make_pair(springs[i].first, springs[i].second));\n    dist_from_spring[springs[i].first][springs[i].second] = 0;\n    while(!que2.empty()){\n      int x = que2.front().first, y = que2.front().second;\n      que2.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ >= H || x_ < 0 || y_ >= W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && (dist_from_spring[x_][y_] > dist_from_spring[x][y]+1)){\n\t  que2.push(make_pair(x_,y_));\n\t  dist_from_spring[x_][y_] = dist_from_spring[x][y]+1;\n\t}\n      }\n    }\n  }\n \n  for(int t = 0; t < 100; ++t){\n    double mean = (l+r)/2.0;\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  exp[i][j] = min(exp_[i][j], dist_from_spring[i][j]+mean);\n\t  s += exp[i][j];\n\t}\n      }\n    }\n\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    cout<<fixed<<setprecision(10);\n}}init;\n\ninline bool isWall(char c){return c=='#';}\ninline bool isSpring(char c){return c=='*';}\ninline bool isFloor(char c){return c=='.'||c=='s';}\ninline bool isStart(char c){return c=='s';}\ninline bool isGoal(char c){return c=='g';}\ntemplate<typename T>\nistream& operator>>(istream& is,vector<T>& v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef long long LL;\nusing P=pair<int,int>;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF=1e8;\nconst int dir4[]={0,1,0,-1,0};\nint main(){\n    int R,C;\n    cin>>C>>R;\n    vector<string> maze(R);\n    int sr,sc,gr,gc,M=0;\n    cin>>maze;\n    \n    queue<P> que;\n    VV dG(R,V(C,INF));\n    VV dB(R,V(C,INF));\n    for(int r=0;r<R;r++)\n        for(int c=0;c<C;c++){\n            if(isSpring(maze[r][c])){\n                dB[r][c]=0;\n                que.push(P(r,c));\n            }\n            if(isFloor(maze[r][c])){\n                M++;\n            }\n            if(isStart(maze[r][c])){\n                sr=r,sc=c;\n            }\n            if(isGoal(maze[r][c])){\n                gr=r,gc=c;\n            }\n        }\n    while(que.size()){\n        int r,c;\n        tie(r,c)=que.front();\n        for(int i=0;i<4;i++){\n            int nr=r+dir4[i];\n            int nc=c+dir4[i+1];\n            if(isWall(maze[nr][nc]))continue;\n            if(dB[nr][nc]>dB[r][c]+1){\n                dB[nr][nc]=dB[r][c]+1;\n                que.push(P(nr,nc));\n            }\n        }\n        que.pop();\n    }\n    que.push(P(gr,gc));\n    dG[gr][gc]=0;\n    while(que.size()){\n        int r,c;\n        tie(r,c)=que.front();\n        for(int i=0;i<4;i++){\n            int nr=r+dir4[i];\n            int nc=c+dir4[i+1];\n            if(isWall(maze[nr][nc])||isSpring(maze[nr][nc]))continue;\n            if(dG[nr][nc]>dG[r][c]+1){\n                dG[nr][nc]=dG[r][c]+1;\n                que.push(P(nr,nc));\n            }\n        }\n        que.pop();\n    }\n    vector<P> fs;\n    auto b=[&](P p){return max(0ll,min(INF,dG[p.first][p.second]-dB[p.first][p.second]));};\n    for(int r=0;r<R;r++)\n        for(int c=0;c<C;c++)\n            if(isFloor(maze[r][c])){\n                fs.push_back(P(r,c));\n            }\n    sort(fs.begin(),fs.end(),[&](P p,P q){return b(p)<b(q);});\n    LL K=0;\n    int B=M;\n    for(int i=0,sz=fs.size();i<sz;i++){\n        K+=dB[fs[i].first][fs[i].second];\n    }\n    double res=INF;\n    K-=dB[fs[0].first][fs[0].second];\n    K+=dG[fs[0].first][fs[0].second];\n    B--;\n    LL prev=b(fs[0]);\n    for(int i=1,sz=fs.size();i<sz;i++){\n        LL now=b(fs[i]);\n        if(now!=prev){\n            double b=1.0-B/(double)M;\n            b=(K/(double)M)/b;\n            if(prev<=b&&b<=now){\n                res=min(res,b);\n            }\n        }\n        K-=dB[fs[i].first][fs[i].second];\n        K+=dG[fs[i].first][fs[i].second];\n        B--;\n        prev=now;\n    }\n    if(prev<INF){\n        double b=1.0-B/(double)M;\n        b=(K/(double)M)/b;\n        if(prev<=b&&b<=INF){\n            res=min(res,b);\n        }\n    }\n    cout<<min((double)dG[sr][sc],dB[sr][sc]+res)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define int ll\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nvs field;\nint w, h;\n\n//((cost, (y, x)) \ntypedef pair<int, pii> State;\n\n#define F first\n#define S second\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nvoid bfs(char tar, vvi & minDist){\n    minDist = vvi(h, vi(w, inf));\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] != tar) continue;\n            q.push(mp(0, mp(y, x)));\n        }\n    }\n\n    while(!q.empty()){\n        int cur_cost = q.top().F;\n        pii cur_pos = q.top().S;\n        q.pop();\n\n        if(minDist[cur_pos.F][cur_pos.S] != inf) continue;\n\n        if(field[cur_pos.F][cur_pos.S] == '.'){\n            minDist[cur_pos.F][cur_pos.S] = cur_cost;\n        }\n\n        int next_cost = cur_cost + 1;\n        rep(i, 4){\n            pii next_pos = mp(cur_pos.F + dy[i], cur_pos.S + dx[i]);\n\n            if(field[next_pos.F][next_pos.S] == '#' ||\n               field[next_pos.F][next_pos.S] == 'g' ||\n               field[next_pos.F][next_pos.S] == '*' ||\n               minDist[next_pos.F][next_pos.S] != inf)\n                continue;\n            \n            q.push(mp(next_cost, next_pos));\n        }\n    }\n}\n\nsigned main(void){\n    for(; cin >> w >> h;){\n        field = vs(h);\n        pii s;\n        int num_f = 0;\n        rep(y, h){\n            cin >> field[y];\n            \n            rep(x, w){\n                if(field[y][x] == 's'){\n                    s = mp(y, x);\n                    field[y][x] = '.';\n                }\n                if(field[y][x] == '.'){\n                    num_f++;\n                }\n            }\n        }\n\n        vvi minDist_s, minDist_g;\n        bfs('*', minDist_s);\n        bfs('g', minDist_g);\n\n//        rep(y, h){\n//            rep(x, w){\n//                printf(\"%4d\", (minDist_s[y][x] == inf ? -1:minDist_s[y][x]));\n//            }\n//            cout << endl;\n//        }\n//        cout << endl;\n//        rep(y, h){\n//            rep(x, w){\n//                printf(\"%4d\", (minDist_g[y][x] == inf ? -1:minDist_g[y][x]));\n//            }\n//            cout << endl;\n//        }\n//        cout << \"----------\" <<endl;\n        \n        vector<pair<int, pii>> deltaSG;\n        int sum_dist = 0, num_tos = 0;\n        rep(y, h){\n            rep(x, w){\n                if(field[y][x] != '.') continue;\n\n                if(minDist_g[y][x] != inf){\n                    sum_dist += minDist_g[y][x];\n\n                    if(minDist_s[y][x] != inf){\n                        deltaSG.pb(mp(minDist_g[y][x] - minDist_s[y][x], mp(y, x)));\n                    }\n                }\n                else{\n                    sum_dist += minDist_s[y][x];\n                    num_tos++;\n                }\n            }\n        }\n        sort(all(deltaSG), greater<pair<int, pii>>());\n        \n#define F first\n#define S second\n\n        long double e = 1.0 / (num_f - num_tos) * sum_dist;\n        for(auto state : deltaSG){\n            pii pos = state.S;\n\n            num_tos++;\n            sum_dist = sum_dist - minDist_g[pos.F][pos.S] + minDist_s[pos.F][pos.S];\n\n            if(num_f == num_tos) break;\n            long double cur = 1.0 / (num_f - num_tos) * sum_dist;\n\n            if(cur < e) e = cur;\n            else break;\n        }\n        long double res = minDist_s[s.F][s.S] + e;\n        if(minDist_g[s.F][s.S] != inf) res = min(res, (long double)minDist_g[s.F][s.S]);\n        printf(\"%.12Lf\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nint w, h;\nchar g[512][512];\n\nint sx, sy;\nint gx, gy;\nint all;\n\nint dg[512][512];\nint ds[512][512];\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\n\nint main(){\n  scanf(\"%d%d\", &w, &h);\n  REP(i,h) scanf(\"%s\", g[i]);\n\n  queue<pair<int, int> > gq;\n  queue<pair<int, int> > sq;\n\n  REP(i,h) REP(j,w){\n    dg[i][j] = ds[i][j] = -1;\n\n    if(g[i][j] == '.' || g[i][j] == 's')\n      all++;\n\n    if(g[i][j] == 's'){\n      sx = j; sy = i;\n      g[i][j] = '.';\n    }else if(g[i][j] == 'g'){\n      gx = j; gy = i;\n      gq.push(make_pair(i, j));\n      dg[i][j] = 0;\n    }else if(g[i][j] == '*'){\n      sq.push(make_pair(i, j));\n      ds[i][j] = 0;\n    }\n  }\n\n  // bfs1\n  while(gq.size()){\n    int x = gq.front().second;\n    int y = gq.front().first;\n    gq.pop();\n\n    REP(i,4){\n      int xx = x + _dx[i];\n      int yy = y + _dy[i];\n      if(ISIN(xx, yy, w, h) &&\n         dg[yy][xx] == -1   &&\n         g[yy][xx] == '.'){\n        dg[yy][xx] = dg[y][x] + 1;\n        gq.push(make_pair(yy, xx));\n      }\n    }\n  }\n\n  // REP(i,h){ REP(j,w) printf(\"%2d \", dg[i][j]); puts(\"\"); }\n\n  // bfs2\n  while(sq.size()){\n    int x = sq.front().second;\n    int y = sq.front().first;\n    sq.pop();\n\n    REP(i,4){\n      int xx = x + _dx[i];\n      int yy = y + _dy[i];\n      if(ISIN(xx, yy, w, h) &&\n         ds[yy][xx] == -1   &&\n         g[yy][xx] == '.'){\n        ds[yy][xx] = ds[y][x] + 1;\n        sq.push(make_pair(yy, xx));\n      }\n    }\n  }\n\n  // REP(i,h) { REP(j,w) printf(\"%2d \", ds[i][j]); puts(\"\"); }\n\n  double ans = 1e10;\n  int cnt = 0;\n  long long chokusetsu = 0;\n  long long tospring   = 0;\n\n  if(dg[sy][sx] != -1) ans = dg[sy][sx];\n\n  // spring = p * chokusetsu + (1 - p) * (tospring + spring)\n  // p * spring = p * chokusetsu + (1 - p) * tospring\n  // spring = chokusetsu + (1 - p) / p * tospring\n\n  vector<pair<int, pair<int, int> > > pos;\n  REP(i,h) REP(j,w) if(g[i][j] == '.'){\n    int d = dg[i][j];\n    if(d == -1){\n      tospring += ds[i][j];\n    }else{\n      chokusetsu += d;\n      cnt++;\n      int dd = ds[i][j];\n      if(dd != -1 && dd < d){\n        pos.push_back(make_pair(-(d - dd), make_pair(i, j)));\n      }\n    }\n  }\n\n  sort(pos.begin(), pos.end());\n\n  size_t idx = 0;\n\n  while(idx != pos.size() && cnt != 0){\n    double p = (double)cnt / all;\n\n    // printf(\"cnt: %d, all: %d, ans: %.3f\\n\", cnt, all, ans);\n    if(cnt != all && ds[sy][sx] != -1)\n      ans = min(ans, ds[sy][sx] + (double)chokusetsu / cnt\n                + (1 - p) / p * ((double)tospring / (all - cnt)));\n\n    int d = pos[idx].first;\n\n    while(idx != pos.size() && pos[idx].first == d){\n      int x = pos[idx].second.second;\n      int y = pos[idx].second.first;\n\n      if(ds[y][x] != -1){\n        cnt--;\n        chokusetsu -= dg[y][x];\n        tospring   += ds[y][x];\n      }\n      idx++;\n    }\n\n  }\n\n  double p = (double)cnt / all;\n  if(cnt != 0 && cnt != all && ds[sy][sx] != -1)\n    ans = min(ans, ds[sy][sx] + (double)chokusetsu / cnt\n              + (1 - p) / p * ((double)tospring / (all - cnt)));\n  printf(\"%.10f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#define INF 1e12\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fie[510][510];\nint dist[2][510][510];\nint w,h;\nint cnt;\nint sx,sy,gx,gy;\n\nvoid bfs(int y=-1,int x=-1){\n\tqueue<P> que;\n\tint type=0;\n\tif(y==-1)type=1;\n\tmemset(dist[type],-1,sizeof(dist[type]));\n\tif(type==0){\n\t\tdist[type][y][x]=0;\n\t\tque.push(P(y,x));\n\t}else{\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==1){\n\t\t\t\t\tdist[type][i][j]=0;\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(abs(fie[ny][nx])!=1 && dist[type][ny][nx]==-1){\n\t\t\t\tdist[type][ny][nx]=dist[type][p.first][p.second]+1;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(int v){\n\tif((dist[0][sy][sx]!=-1 && dist[0][sy][sx]<=dist[1][sy][sx]+v) || dist[1][sy][sx]==-1)return dist[0][sy][sx];\n\telse{\n\t\tint cnt=0;\n\t\tint all=0;\n\t\tint okave=0;\n\t\tint ngave=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\t\tall++;\n\t\t\t\t\tif(dist[0][i][j]==-1){\n\t\t\t\t\t\tngave+=dist[1][i][j];\n\t\t\t\t\t}else if(dist[0][i][j]<=dist[1][i][j]+v || dist[1][sy][sx]==-1){\n\t\t\t\t\t\tokave+=dist[0][i][j];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tngave+=dist[1][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt==0)return INF;\n\t\tdouble va=(double)okave/all;\n\t\tva*=1.0/((double)cnt/all);\n\t\tdouble vb=(double)ngave/((double)(all-cnt));\n\t\tvb*=1.0/((double)cnt/all);\n\t\tvb-=(double)ngave/((double)(all-cnt));\n\t\treturn (double)va+vb+dist[1][sy][sx];\n\t}\n}\n\nint calc_ok(int v){\n\tint cnt=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\tif(dist[0][i][j]==-1){\n\t\t\t\t}else if(dist[0][i][j]<=dist[1][i][j]+v || dist[1][sy][sx]==-1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tscanf(\"%d%d%*c\",&w,&h);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='#')fie[i][j]=-1;\n\t\t\tif(c=='s')sy=i,sx=j;\n\t\t\tif(c=='g')gy=i,gx=j;\n\t\t\tif(c=='*')fie[i][j]=1;\n\t\t\tif(c=='.')cnt++;\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tbfs(gy,gx);\n\tbfs();\n\tif(dist[1][sy][sx]==-1 || (dist[0][sy][sx]<=dist[1][sy][sx] && dist[0][sy][sx]!=-1)){\n\t\tprintf(\"%.10f\\n\",(double)dist[0][sy][sx]);\n\t\treturn 0;\n\t}\n\tint l=1,r=w*h;\n\tfor(int i=0;i<30;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(calc_ok(mid)==0){\n\t\t\tl=mid;\n\t\t}else{\n\t\t\tr=mid;\n\t\t}\n\t}\n\tr=w*h;\n\tif(dist[0][sy][sx]==-1){\n\t\tr=w*h;\n\t}else{\n\t\tr=dist[0][sy][sx]-dist[1][sy][sx]+1;\n\t}\n\tfor(int i=0;i<50;i++){\n\t\tint lm=(l*2+r)/3;\n\t\tint rm=(l+r*2)/3;\n\t\tdouble vl=calc(lm);\n\t\tdouble rl=calc(rm);\n\t\tif(vl<rl){\n\t\t\tr=rm;\n\t\t}else{\n\t\t\tl=lm;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",min(calc((l*2+r)/3),calc((l+r*2)/3)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\ntypedef long double lld;\ntypedef pair<lld,mp> lmp;\nint w,h;\n\nchar dat[505][505];\nlld ds[505][505];\n\nint sy,sx,gy,gx;\n\nint dd[5]={1,0,-1,0,1};\n\nvoid calcd(lld m){\n\tpque(lmp) que;\n\tque.push(lmp(0,mp(gy,gx)));\n\trep(y,h)rep(x,w){\n\t\tif(dat[y][x]=='*'){\n\t\t\tds[y][x]=m;\n\t\t\trep(i,4){\n\t\t\t\tint ty = y + dd[i],\n\t\t\t\t\ttx = x + dd[i+1];\n\t\t\t\tif(dat[ty][tx]!='.')continue;\n\t\t\t\tque.push(lmp(m+1,mp(ty,tx)));\n\t\t\t}\n\t\t}\n\t\telse ds[y][x]=-1;\n\t}\n\t\n\twhile(!que.empty()){\n\t\tlmp pa = que.top();\n\t\tque.pop();\n\t\tlld d = pa.fir;\n\t\tint y = pa.sec.fir,\n\t\t\tx = pa.sec.sec;\n\t\tif(ds[y][x]>=0)continue;\n\t\tds[y][x]=d;\n\t\trep(i,4){\n\t\t\tint ty = y + dd[i],\n\t\t\t\ttx = x + dd[i+1];\n\t\t\tif(dat[ty][tx]!='.')continue;\n\t\t\tif(ds[ty][tx]>=0)continue;\n\t\t\tque.push(lmp(d+1,mp(ty,tx)));\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",dat[y]);\n\trep(y,h)rep(x,w){\n\t\tif(dat[y][x]=='s'){\n\t\t\tsy=y; sx=x; dat[y][x]='.';\n\t\t}\n\t\tif(dat[y][x]=='g'){\n\t\t\tgy=y; gx=x; \n\t\t}\n\t}\n\t\n\tlld l=0,r=1000*1000;\n\twhile(r-l>1e-10){\n\t\tlld m = (l+r)/2.0;\n\t\t//printf(\"%Lf %Lf\\n\",l,r);\n\t\tcalcd(m);\n\t\tint p = 0;\n\t\tlld s = 0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(dat[y][x]=='.'){\n\t\t\t\tp++; s+=ds[y][x];\n\t\t\t}\n\t\t}\n\t\ts /= p;\n\t\tif(s>=m)l = m;\n\t\telse r = m;\n\t}\n\t\n\tcalcd(l);\n\tprintf(\"%.15Lf\\n\",ds[sy][sx]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 16;\n\nconst int cmax=25010;\nint w,h;\nint d[cmax];\nint e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg)const{\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[25010];\n\nvoid dijkstra(char s,char o,int* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid show(int *dist){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tint idx=i*w+j;\n\t\t\tif(dist[idx]<10)\n\t\t\t\tcout << dist[idx];\n\t\t\telse\n\t\t\t\tcout << '-';\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tex[n].d=d[idx];\n\t\t\tex[n++].e=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\tdouble ans=d[sidx];\n\tll sum=0;\n\trep(i,n) sum+=ex[i].d;\n\tfor(int i=n;i>=1;--i){\n\n\t\tans=min(ans,1.0*sum/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tsum-=ex[cur].d;\n\t\tsum+=ex[cur].e;\n\t}\n\tcout.precision(12);\n\tcout << fixed << ans << endl;\n\tshow(d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 100000000;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// 凸関数の極大な点をもとめる\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 1000){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// 凹関数の極小な・を求める\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\nlong double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k,\n                   const int s=0){\n    const int N = v.size();\n    int l = as[k];\n    int r = bs[N] - bs[k];\n    if(s > 1000) return 1.0F * (l+r) / N;\n    return (l + r + (1.0F * (N-k) * calc_e(v,as,bs,k,s+1)))/N;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n    \n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n\n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    // 階段が近い → 遠い\n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c + 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    int ls = as[1] - bs[1];\n    int rs = as[N] - as[N-1] - (bs[N] - bs[N-1]);\n    auto r = ternary_search_concave(f,ls,rs);\n    // cout << f(r) << endl;\n    // for(int i=0;i<N;i++){\n    //     double d = as[i+1] - as[i] - (bs[i+1] - bs[i]);\n    //     dump(d);\n    // }\n\n    cout << fixed << setprecision(10);\n    cout << f(r) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#include<cfloat>\nconst double DINF = 1e14;\nconst double eps = 1e-10;\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.01)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.01)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0.0;\n\t\n\t//while((l-r)*2.0>(l+r)*esp){}\n\trep(k,200){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = l*0.5+r*0.5;\n\t\t//printf(\"%.10f %.10f %.10f\\n\",l,r,m);\n\t\tdouble zan=0,cs=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tdouble na = cmin(y,x,m),ce;\n\t\t\tce=cs+na+zan;\n\t\t\tzan=cs+na+zan-ce;\n\t\t\tcs=ce;\n\t\t}\n\t\tcs=cs+zan;\n\t\tif(cs/dotnum>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\t//printf(\"%.10f %.10f\\n\",dist[sy][sx],mine[sy][sx]);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nint sy,sx, gy, gx;\nstring field[600];\ndouble dist[600][600];\n\nvoid dijkstra(int sx, int sy, double mb){\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, 1e20);\n  priority_queue<P,vector<P>, greater<P> > que;\n  que.push(P(0, sy * W + sx));\n  dist[sy][sx] = 0;\n  rep(i, H)rep(j, W){\n    if(field[i][j] == '*') {\n      dist[i][j] = mb;\n      que.push(P(mb, i * W + j));\n    }\n  }\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    double cost = p.first;\n\n    int x = p.second % W;\n    int y = p.second / W;\n    if(cost > dist[y][x] + EPS) continue;\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      if(field[y2][x2] == '.' && dist[y2][x2] > cost + 1){\n\tdist[y2][x2] = cost + 1;\n\tque.push(P(cost + 1, y2 * W + x2));\n      }\n    }\n  }\n}\n\nbool C(double mb){\n  dijkstra(gx, gy, mb);\n  int cnt = 0;\n  double sum = 0.0;\n  rep(i, H)rep(j, W){\n    //    cout << setw(6) << dist[i][j] << (j == W - 1 ? '\\n':' ');\n    if(field[i][j] == '.') sum += dist[i][j], cnt++;\n  }\n  return mb < sum / cnt;\n}\n\nint main(){\n  while(cin >> W >>H){\n\n    rep(i, H){\n      cin >> field[i];\n      rep(j, W){\n\tif(field[i][j] == 's') {\n\t  sx = j;\n\t  sy = i;\n\t  field[i][j] = '.';\n\t}\n\tif(field[i][j] == 'g'){\n\t  gx = j;\n\t  gy = i;\n\t}\n      }\n    }\n    double ub = 1e15;    \n    double lb = 0;\n    rep(i, 300){\n      double mb = (ub + lb) / 2;\n      if(C(mb)) lb = mb;\n      else ub = mb; \n    }\n    dijkstra(gx, gy, lb);\n    //    cout << lb << endl;\n    cout << fixed << setprecision(12) << dist[sy][sx] << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16500; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i = 0; i < (n); i++)\n#define fi first\n#define se second\n\nconst int INF = 1e9;\n\nint W, H;\nvector<string> brd;\nvector<vector<int> > dist_spring;\nvector<vector<int> > dist_goal;\n\nbool check(int y, int x) {\n\treturn 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid bfs(queue<pii> q, vector<vector<int> > & res) {\n\tint d = 0;\n\tqueue<pii> nex;\n\twhile(q.size()) {\n\t\twhile(q.size()) {\n\t\t\tpii crd;\n\t\t\tcrd = q.front(); q.pop();\n\t\t\tres[crd.fi][crd.se] = min(res[crd.fi][crd.se], d);\n\t\t\trep(i,4) {\n\t\t\t\tconst int dxy[] = {0,1,0,-1,0};\n\t\t\t\tint ny, nx;\n\t\t\t\tny = crd.fi + dxy[i];\n\t\t\t\tnx = crd.se + dxy[i+1];\n\t\t\t\tif(check(ny,nx) && (brd[ny][nx] == '.' || brd[ny][nx] == 's')\n\t\t\t\t\t\t&& res[ny][nx] == INF) {\n\t\t\t\t\tnex.push(pii(ny,nx));\n\t\t\t\t\tres[ny][nx] = d+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = nex;\n\t\twhile(nex.size()) nex.pop();\n\t\td++;\n\t}\n}\n\nvoid make_dist_spring() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_spring.push_back(vector<int>(W, INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == '*')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_spring);\n}\n\nvoid make_dist_goal() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_goal.push_back(vector<int>(W,INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == 'g')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_goal);\n}\n\nint main() {\n\tpii st;\n\tcin >> W >> H;\n\trep(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tbrd.push_back(s);\n\t\trep(j, W) {\n\t\t\tif(s[j] == 's')\n\t\t\t\tst = pii(i,j);\n\t\t}\n\t}\n\tmake_dist_spring();\n\tmake_dist_goal();\n\n\tdouble l, r, m;\n\tl = 0; r = 1e15;\n\trep(i,100) {\n\t\tm = (l+r) / 2;\n\t\tdouble a, b;\n\t\tll c, d, e;\n\t\ta = b = 0;\n\t\tc = d = e = 0;\n\t\trep(j, H) {\n\t\t\trep(k, W) {\n\t\t\t\tif(brd[j][k] == '.' || brd[j][k] == 's') {\n\t\t\t\t\ta += min((double)dist_goal[j][k], dist_spring[j][k] + m);\n\t\t\t\t\tif(dist_goal[j][k] > dist_spring[j][k] + m) {\n\t\t\t\t\t\td += dist_spring[j][k];\n\t\t\t\t\t\te++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\td += dist_goal[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = d + e * m;\n\t\tb = c * m;\n\t\tif(a > b)\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tcout << setprecision(15) << fixed <<\n\t\tmin((double)dist_goal[st.fi][st.se], dist_spring[st.fi][st.se] + m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nll INF = LLONG_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<ll> > dg(H, vector<ll>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<ll> > ds(H, vector<ll>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e16;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nP dlt[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};\n\nvector<vector<char>> c;\nll h,w,f;\nP sp,gp;\nvector<P> spr;\nvector<vector<ll>> g_cost;\nvector<vector<ll>> s_cost;\n\nbool isfloor(P p) {\n\tif(p.first>=0&&p.first<h&&p.second>=0&&p.second<w&&\n\t   (c[p.first][p.second]=='.'||c[p.first][p.second]=='s')) return true;\n\telse return false;\n}\n\nvector<vector<ll>> dijkstra(vector<P> s) {\n\tvector<vector<ll>> dst(h,vector<ll>(w,INF));\n\tpriority_queue<pair<ll,P>,vector<pair<ll,P>>,greater<pair<ll,P>>> q;\n\tREP(i,(ll)s.size()) {\n\t\tdst[s[i].first][s[i].second]=0;\n\t\tq.push(make_pair(0,s[i]));\n\t}\n\twhile(!q.empty()) {\n\t\tll d=q.top().first;\n\t\tP p=q.top().second;\n\t\tq.pop();\n\t\tif(dst[p.first][p.second]!=d) continue;\n\t\tREP(i,4) {\n\t\t\tP np=P(p.first+dlt[i].first,p.second+dlt[i].second);\n\t\t\tif(isfloor(np)&&dst[np.first][np.second]>d+1) {\n\t\t\t\tdst[np.first][np.second]=d+1;\n\t\t\t\tq.push(make_pair(dst[np.first][np.second],np));\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}\n\nvoid init() {\n\tcin>>w>>h;\n\tc.assign(h,vector<char>(w));\n\tREP(i,h) REP(j,w) cin>>c[i][j];\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') f++;\n\tREP(i,h) REP(j,w) if(c[i][j]=='s') sp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='g') gp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='*') spr.pb(P(i,j));\n\tg_cost=dijkstra(vector<P>(1,gp));\n\ts_cost=dijkstra(spr);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tinit();\n\tif(g_cost[sp.first][sp.second]<=s_cost[sp.first][sp.second]) {\n\t\tcout<<fixed<<setprecision(39)<<g_cost[sp.first][sp.second]<<endl;\n\t\treturn 0;\n\t}\n\tll cons=0;\n\tll cf=0;\n\tpriority_queue<ll,vector<ll>,greater<ll>> diff;\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') {\n\t\tif(g_cost[i][j]==INF) {\n\t\t\tcons+=s_cost[i][j];\n\t\t\tcf++;\n\t\t\tcontinue;\n\t\t}\n\t\tcons+=g_cost[i][j];\n\t\tif(s_cost[i][j]<g_cost[i][j]) diff.push(s_cost[i][j]-g_cost[i][j]);\n\t}\n\tld min_x=cons/(ld)(f-cf);\n\twhile(!diff.empty()) {\n\t\tll c=diff.top();\n\t\tdiff.pop();\n\t\tcons+=c;\n\t\tcf++;\n\t\tmin_x=min(min_x,cons/(ld)(f-cf));\n\t}\n\tcout<<fixed<<setprecision(39)<<min(\n\t(ld)g_cost[sp.first][sp.second],s_cost[sp.first][sp.second]+min_x)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int inf = (1<<20);\nchar m[N][N+1];\nint dcost[N][N];//¼ÚS[ÜÅs­RXg\nint scost[N][N];//olðgÁ½ÌRXg\nvoid bfs(int r,int c,char s,int cost[N][N]){\n  queue<int> Q;\n  rep(i,r)rep(j,c)\n    if (m[i][j] == s)cost[i][j] = 0,Q.push(i*c+j);\n    else cost[i][j] = inf;\n  while(!Q.empty()){\n    int y = Q.front()/c,x=Q.front()%c;Q.pop();\n    //    cout << y <<\" \" << x << endl;\n    rep(i,4){\n      int ney = y+dy[i],nex = x+dx[i];\n      if (m[ney][nex] == '*' || m[ney][nex] == 'g' || m[ney][nex] == '#' || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n}\n\n//brute force,Æè ¦¸û©·éÜÅñµÄÝé\n//üÍªgs*Ý½¢ÈÌªéÆ¿éÂ\\«ª é\ndouble exp[N][N];\ndouble bf(int r,int c){\n  double e=0;//úÒlÌaðÁÄ¨­ÆðÉ§Â\n  double pos = 0;//olÅs­Â\\«Ì éêÌ\n  int sy,sx;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '*' || m[i][j] == 'g' || m[i][j] == '#')continue;\n      exp[i][j] = dcost[i][j];\n      e += dcost[i][j];\n      pos++;\n      if (m[i][j] == 's')sy = i,sx = j;\n    }\n  }\n\n\n  double L = 0,R=1e20;\n  double ans = -1;\n  rep(i,300){\n    double mid = (L+R)/2.;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#' || m[i][j] == '*')continue;\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + mid/pos;\n\tnewe += min(tmp,tmp2);\n      }\n    }\n\n    //cout <<\"owari \" << newe <<\" \" << L << \" \" << mid <<\" \" << R << endl;\n    if (newe < mid){//\\zæè¬³©Á½\n      ans = mid;\n      R = mid - 1e-10;\n    }else {//\\zæèå«©Á½\n      L = mid + 1e-10;\n    }\n  }\n  //cout << ans<< \" \" << ans/pos << endl;\n  return  min((double)dcost[sy][sx],scost[sy][sx]+ans/pos);\n\n  /*\n  while(true){\n    bool isupdate = false;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#')continue;//±±Íl¦È¢B\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + (e)/(pos);\n\tif (exp[i][j] > min(tmp,tmp2)){\n\t  isupdate = true;\n\t  e -= exp[i][j];\n\t  exp[i][j] = min(tmp,tmp2);\n\t  e += exp[i][j];\n\t}\n\tnewe += exp[i][j];\n      }\n    }\n    e = newe;\n    cout <<\"debug \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tprintf(\"%.3lf \",exp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    cout <<\"--------------==\" << endl;\n\n    if (!isupdate)break;\n  }\n\n  double hoge = 0;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#' || m[i][j] == 'g' || m[i][j] == '*')continue;\n      hoge += min((double)dcost[i][j],scost[i][j] + e/pos);\n      cout << min((double)dcost[i][j],scost[i][j] + e/pos) <<\" \" ;\n    }\n    cout << endl;\n  }\n  cout <<\"hoge \" << e <<\" \" << hoge/pos << endl;\n  */\n  rep(i,r)rep(j,c)if (m[i][j] == 's')return exp[i][j];\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)cin>>m[i];\n    bfs(r,c,'*',scost);\n    bfs(r,c,'g',dcost);\n    printf(\"%.12lf\\n\",bf(r,c));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint w,h;\nvector<string> mp;\n\nvector<vector<int> > bfs(char start){\n  int dx[] = {1,-1,0,0};\n  int dy[] = {0,0,1,-1};\n  \n  queue<P> Q;\n  vector<vector<int> > D(h,vector<int> (w,INF));\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == start) Q.push(P(i,j)), D[i][j] = 0;\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y, x; tie(y, x) = t;\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if(mp[ny][nx] == '#' || mp[ny][nx] == '*') continue;\n      if(D[ny][nx] != INF) continue;\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(ny, nx));\n    }  \n  }\n  return D;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>w>>h;\n  mp.resize(h);\n  cin>>mp;\n\n  P S, T;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 's') S = P(i,j), mp[i][j] = '.';\n      if(mp[i][j] == 'g') T = P(i,j);\n    }\n\n  auto DB = bfs('*');\n  auto DT = bfs('g');\n  \n  vector<P> A;\n  double dot = 0;\n  int sum = 0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] != '.') continue;\n      if(DB[i][j] == INF && DT[i][j] == INF) continue;\n      if(DT[i][j] == INF) {sum += DB[i][j]; continue;}\n      dot++;\n      if(DB[i][j] == INF) {sum += DT[i][j]; continue;}\n      A.push_back(P(DB[i][j], DT[i][j]));\n    }\n  \n  for(auto p:A) sum += p.second;\n\n  sort(A.begin(),A.end(),[&](auto a,auto b){return a.first - a.second < b.first - b.second;});\n  \n  \n  int sy = S.first, sx = S.second;\n  auto calc=[&](double x){return DB[sy][sx] + x;};\n  \n  double ans = calc(sum/dot);\n  Min(ans, (double)DT[sy][sx]);\n  for(int i=0;i<(int)A.size() - 1;i++){\n    sum += A[i].first - A[i].second;\n    double x = sum / (dot - i - 1);\n    Min(ans, calc(x));\n  }\n  \n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> c(h);\n  for(int i=0;i<h;i++){\n    cin>>c[i];\n  }\n  const int INF=1e9;\n  vector<vector<int>> spr(h,vector<int>(w,INF));\n  queue<pair<int,int>> que;\n  pair<int,int> s;\n  pair<int,int> t;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(c[i][j]=='s'){\n\ts={i,j};\n\tc[i][j]='.';\n      }\n      if(c[i][j]=='g'){\n\tt={i,j};\n      }\n      if(c[i][j]=='*'){\n\tque.push({i,j});\n\tspr[i][j]=0;\n      }\n    }\n  }\n  int dx[]={1,-1,0,0};\n  int dy[]={0,0,1,-1};\n  auto isRange=[=](int i,int j){\n    return 0<=i && i<h && 0<=j && j<w;\n  };\n  \n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && spr[p.first][p.second]+1<spr[toh][tow]){\n\tspr[toh][tow]=spr[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n  vector<vector<int>> goal(h,vector<int>(w,INF));\n  goal[t.first][t.second]=0;\n  que.push(t);\n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && goal[p.first][p.second]+1<goal[toh][tow]){\n\tgoal[toh][tow]=goal[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n\n  double ub=1000000;\n  double lb=0;\n\n  for(int i=0;i<100;i++){\n    double mid=(lb+ub)/2;\n    double sum=0;\n    int cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='.'){\n\t  sum+=min<double>(goal[i][j],mid+spr[i][j]);\n\t  cnt++;\n\t}\n      }\n    }\n    sum/=cnt;\n    if(mid<sum){\n      lb=mid;\n    }\n    else{\n      ub=mid;\n    }\n  }\n  cout<<setprecision(10)<<fixed;\n  cout<<min<double>(goal[s.first][s.second],lb+spr[s.first][s.second])<<endl;\n  return 0;\n}\n  \n\n  \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e50, M = 0;\n  rep(i,220){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define H 510\nll dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nll h,w;\nchar c[H][H];\nll bane[H][H],goal[H][H];\nlong double f(ll x,ll y,long double k){\n\treturn min((long double)goal[x][y],(long double)bane[x][y]+k);\n}\nbool solve(long double k){\n\tlong double sum=0;\n\tll cnt=0;\n\trep(i,h)rep(j,w)if(c[i][j]=='.'){\n\t\tsum+=f(i,j,k);\n\t\tcnt++;\n\t}\n\tsum/=(long double)cnt;\n\t//cout<<\"solve:\"<<sum<<\" \"<<k<<endl;\n\treturn sum<=k;\n}\n\nint main(){\n\tcin>>w>>h;\n\tll sx,sy,gx,gy;\n\trep(i,h)rep(j,w){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sx=i,sy=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gx=i,gy=j;\n\t\tbane[i][j]=goal[i][j]=1e17;\n\t}\n\tqueue<ll> Qx,Qy,Qcost;\n\tQx.push(gx); Qy.push(gy); Qcost.push(0);\n\twhile(!Qx.empty()){\n\t\tll x=Qx.front(),y=Qy.front(),cost=Qcost.front();\n\t\tQx.pop(); Qy.pop(); Qcost.pop();\n\t\tif(goal[x][y]<=cost)continue;\n\t\tgoal[x][y]=cost;\n\t\trep(r,4){\n\t\t\tll xx=x+dx[r],yy=y+dy[r];\n\t\t\tif(0<=xx&&xx<h&&0<=yy&&yy<w&&c[xx][yy]=='.'){\n\t\t\t\tQx.push(xx);\n\t\t\t\tQy.push(yy);\n\t\t\t\tQcost.push(cost+1);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h)rep(j,w)if(c[i][j]=='*'){\n\t\tQx.push(i);\n\t\tQy.push(j);\n\t\tQcost.push(0);\n\t}\n\twhile(!Qx.empty()){\n\t\tll x=Qx.front(),y=Qy.front(),cost=Qcost.front();\n\t\tQx.pop(); Qy.pop(); Qcost.pop();\n\t\tif(bane[x][y]<=cost)continue;\n\t\tbane[x][y]=cost;\n\t\trep(r,4){\n\t\t\tll xx=x+dx[r],yy=y+dy[r];\n\t\t\tif(0<=xx&&xx<h&&0<=yy&&yy<w&&c[xx][yy]!='#'&&c[xx][yy]!='*'){\n\t\t\t\tQx.push(xx);\n\t\t\t\tQy.push(yy);\n\t\t\t\tQcost.push(cost+1);\n\t\t\t}\n\t\t}\n\t}\n\t/*cout<<\"goal\"<<endl;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(goal[i][j]==1e17)cout<<\"# \";\n\t\t\telse cout<<goal[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<\"bane\"<<endl;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(bane[i][j]==1e17)cout<<\"# \";\n\t\t\telse cout<<bane[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tlong double l=0,r=1e15,mid;\n\trep(d,100){\n\t\tmid=(l+r)/2.0;\n\t\tif(solve(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tcout<<fixed<<setprecision(9)<<f(sx,sy,r)<<endl;\n\t/*for(double x=0.01;x<=10.0;x+=0.01){\n\t\tbool res=solve(x);\n\t\tif(res!=(r<x))cout<<\"WrongAnswer\"<<endl;\n\t}*/\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e30;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e30;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=1e30;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing dbl = long double;\nusing Pi = pair<int, int>;\n\nconst dbl eps = 1e-9;\n#define lt(a, b) ((a)-(b) < -eps)\n#define eq(a, b) (fabs((a)-(b)) < eps)\n\nint W, H;\nchar mas[505][505];\nPi S, G;\nvector<Pi> Bs;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nvector<vector<dbl> > bfs(const vector<Pi>& s) {\n  //cout<<\"!!!!!\"<<endl;\n  queue<Pi> que;\n  vector<vector<dbl> > dist(H, vector<dbl>(W, -1));\n  for(Pi p : s) {\n    que.emplace(p);\n    dist[p.first][p.second] = 0;\n  }\n  while(!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front(); que.pop();\n    //cout<<mas[y][x]<<\" \"<<y<<\" \"<<x<<endl;    \n    for(int i = 0; i < 4; ++i) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#' || mas[ny][nx] == '*') continue;\n      if(dist[ny][nx] == -1) {\n\tdist[ny][nx] = dist[y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n  return dist;\n}\n\nvector<vector<dbl> > db;\nvector<vector<dbl> > dg;\n\nbool check(dbl mb) {\n  dbl sum = 0;\n  int num = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.') {\n\tif(dg[i][j] == -1 && db[i][j] == -1) assert(false);\n\telse if(dg[i][j] == -1) sum += db[i][j]+mb;\n\telse if(db[i][j] == -1) sum += dg[i][j];\n\telse sum += min(dg[i][j], db[i][j]+mb);\n\t++num;\n      }\n    }\n  }\n  sum /= num;\n  return sum >= mb;\n}\n\nint main() {\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 's') S = Pi(i, j), mas[i][j] = '.';\n      else if(mas[i][j] == 'g') G = Pi(i, j);\n      else if(mas[i][j] == '*') Bs.emplace_back(i, j);\n    }\n  }\n\n  db = bfs(Bs);\n  dg = bfs({G});\n\n  dbl ans = dg[S.first][S.second];\n  //cout<<ans<<endl;\n  if(ans == -1) ans = 1e9;\n  else if(db[S.first][S.second] == -1) {\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n  }\n\n  dbl lb = 0, ub = 1e9;\n  for(int i = 0; i < 200; ++i) {\n    dbl mb = (lb+ub)/2;\n    if(check(mb)) lb = mb;\n    else ub = mb;\n  }\n\n  ans = min(ans, db[S.first][S.second]+lb);\n\n  cout << fixed << setprecision(12) << ans << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(int dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    int dist_goal[500][500], dist_spring[500][500];\n    memset(dist_goal, -1, sizeof dist_goal);\n    memset(dist_spring, -1, sizeof dist_spring);\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e18;\n    REP(_, 100){\n      const double sum = (ub + lb) * 0.5;\n      double S = sum;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        double exp = min((double)dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S -= exp;\n      }\n      if(S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = lb / N;\n    printf(\"%.12f\\n\", min((double)dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// ???????°???°???????????¢?´¢\nld BinarySearchReal(ld rl, ld rr, function<bool(ld)> f) { \n    rep(i, 200) { ld m = (rl + rr) / 2; f(m)?rr=m:rl=m; }\n    return rl;\n}\nvoid BinarySearchRealInteractive(ld rl, ld rr, function<bool(ld)> f) { \n    while (1) {\n        cout << \"####\" << endl;\n        ld tmp; cin >> tmp;\n        if (rl > tmp) {cout << \"Out of range: too small\" << endl; continue; }\n        if (rr < tmp) {cout << \"Out of range: too large\" << endl; continue; }\n        ld ret = f(tmp); cout << tmp << \" : \" << ret << endl;\n    }\n}\n\nchar m[500][500] = {};\nll b[500][500] = {};\nll g[500][500] = {};\nvoid print_map(ll w, ll h) {\n    rep(hi, h) {\n        rep(wi, w) {\n            cout << m[hi][wi];\n        }\n        cout << endl;\n    }\n}\n\nvoid print_bane(ll w, ll h) {\n    rep(hi, h) {\n        rep(wi, w) {\n            if (b[hi][wi] == INF) \n                cout << -1 << \"\\t\";\n            else\n                cout << b[hi][wi] << \"\\t\";\n        }\n        cout << endl;\n    }\n}\n\nvoid print_goal(ll w, ll h) {\n    rep(hi, h) {\n        rep(wi, w) {\n            if (g[hi][wi] == INF) \n                cout << -1 << \"\\t\";\n            else\n                cout << g[hi][wi] << \"\\t\";\n        }\n        cout << endl;\n    }\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll w, h; cin >> w >> h;\n    rep(hi, h) {\n        rep(wi, w) {\n            cin >> m[hi][wi];\n        }\n    }\n//    print_map(w, h);\n\n    rep(hi, h) {\n        rep(wi, w) {\n            b[hi][wi] = INF;\n        }\n    }\n    rep(hi, h) {\n        rep(wi, w) {\n            g[hi][wi] = INF;\n        }\n    }\n\n    vector<ll> dh = {1, 0, -1, 0};\n    vector<ll> dw = {0, 1, 0, -1};\n    queue<P> q;\n\n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == '*') {\n                q.push(P(hi, wi));\n                b[hi][wi] = 0;\n            }\n        }\n    }\n    while (!q.empty()) {\n        P pos = q.front(); q.pop();\n        ll hi = pos.fi, wi = pos.se;\n        ll pos_dist = b[hi][wi];\n        rep(d, 4) {\n            ll next_hi = hi + dh[d];\n            ll next_wi = wi + dw[d];\n            if (next_hi < h && next_hi >= 0 && \n                next_wi < w && next_wi >= 0 &&\n                (m[next_hi][next_wi] == '.' || m[next_hi][next_wi] == 's') && \n                b[next_hi][next_wi] == INF) {\n\n                b[next_hi][next_wi] = pos_dist + 1;\n                q.push(P(next_hi, next_wi));\n            }\n        }\n    }\n//    cout << endl;\n//    print_bane(w, h);\n    \n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == 'g') {\n                q.push(P(hi, wi));\n                g[hi][wi] = 0;\n            }\n        }\n    }\n    while (!q.empty()) {\n        P pos = q.front(); q.pop();\n        ll hi = pos.fi, wi = pos.se;\n        ll pos_dist = g[hi][wi];\n        rep(d, 4) {\n            ll next_hi = hi + dh[d];\n            ll next_wi = wi + dw[d];\n            if (next_hi < h && next_hi >= 0 && \n                next_wi < w && next_wi >= 0 &&\n                (m[next_hi][next_wi] == '.' || m[next_hi][next_wi] == 's') && \n                g[next_hi][next_wi] == INF) {\n\n                g[next_hi][next_wi] = pos_dist + 1;\n                q.push(P(next_hi, next_wi));\n            }\n        }\n    }\n//    cout << endl;\n//    print_goal(w, h);\n \n    vector<P> bg;\n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == '.' || m[hi][wi] == 's') {\n                bg.pb(P(b[hi][wi], g[hi][wi]));\n            }\n        }\n    }\n    ll n = bg.size();\n\n    // !!!!!!!!!!!!!!!!!!!! 1e8 !!!!!!!!!!!!!!!!!!!!\n    function<bool(ld)> f = [&](ld e){\n        ll k = 0;\n        ll bsum = 0; \n        ll gsum = 0; \n        for (auto x : bg) {\n            if (x.fi + e < x.se) {\n                k++;\n                bsum += x.fi;\n            } else {\n                gsum += x.se;\n            }\n        }\n        return e * (n - k) > bsum + gsum;\n    };\n    ld e = BinarySearchReal(0, 1e40,  f);\n//    cout << e << endl;\n\n    ll hs = -1, ws = -1;\n    rep(hi, h) {\n        rep(wi, w) {\n            if (m[hi][wi] == 's') {\n                hs = hi;\n                ws = wi;\n            }\n        }\n    }\n    cout << ldout << min((ld)b[hs][ws] + e, (ld)g[hs][ws]) << endl;\n    \n    // 5 1\n    // .g...s*\n    //\n    //\n    // 7 1\n    // .g...s*\n    //\n    // 8 1\n    // .g...s.*\n    // # e = 2\n    // # e = (1+1+2+3)/5 + (1+e)/5\n    //\n    // e??£?????????????????§?????????????????¨????????????\n    // sample 2??§e=2.8e15???????????????\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  LL w,h;\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  double left=0;\n  double right=h*w*h*w;\n  double mid;\n  double count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n  // cout << left << endl;\n  // cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  cout << setprecision(12);\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 100000000;\n\nint h, w;\nP st, go;\nchar b[500][500];\nint gist[500][500], wist[500][500];\nqueue<P> que;\nint dh[4] = {1,0,-1,0};\nint dw[4] = {0,1,0,-1};\nint flo = 0;\n\nint main(){\n    cin >> w >> h;\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    rep(i,h) rep(j,w){\n        if(b[i][j] == 's'){\n            st.first = i;\n            st.second = j;\n            b[i][j] = '.';\n        }\n        if(b[i][j] == '.'){\n            flo++;\n        }\n        if(b[i][j] == 'g'){\n            go.first = i;\n            go.second  = j;\n            b[i][j] = '.';\n        }\n    }\n    rep(i,h) rep(j,w){\n        gist[i][j] = INF;\n        wist[i][j] = INF;\n    }\n    gist[go.first][go.second] = 0;\n    que.push(go);\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(gist[nh][nw] <= gist[p.first][p.second]+1) continue;\n            gist[nh][nw] = gist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '*'){\n            que.push(P(i,j));\n            wist[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(wist[nh][nw] <= wist[p.first][p.second]+1) continue;\n            wist[nh][nw] = wist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    double s = 0.0, e = 1000000000000.0, mid;\n    rep(u,10000){\n        mid = (s+e)/2.0;\n        double sum = 0.0;\n        rep(i,h) rep(j,w){\n            if(b[i][j] == '.' && go != P(i,j)){\n                sum += min((double)gist[i][j],wist[i][j]+mid);\n            }\n        }\n        sum /= (double)flo;\n        if(mid > sum){\n            e = mid;\n        } else{\n            s = mid;\n        }\n    }\n    double ans = min((double)gist[st.first][st.second],wist[st.first][st.second]+mid);\n    printf(\"%.15f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e30), l = 0.0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 2000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0.0;\n    long double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  //long double nE = 0.0;\n  int cnt = 0;\n  priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    long double l = que.top();\n    que.pop();\n    long double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 80) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] == '*' || field[y][x] == '#') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\ndouble ToGoal(int x, int y, double E) {\n  double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\ndouble calc(double E) {\n  double nE = 0.0;\n  double cnt = 0.0;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  return nE / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    double left = 0.0;\n    double right = 1e+30;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 300) {\n        double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10f\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<int> > dg(H, vector<int>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ds(H, vector<int>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e6;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=1e20,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define DEC(i, k) for (int i = (k); i >= 0; --i)\n#define FORIT(i, c) for (__tyoeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n#define ALL(c) (c).begin(), (c).end()\n\nint W,H;\nchar s[503][503];\ndouble F;\ndouble d[503][503],bane[503][503];\n\nint dy[]={-1,1,0,0};\nint dx[]={0,0,-1,1};\n\nstruct P {\n    int y,x; double dist;\n    P(int y,int x,double dist):y(y),x(x),dist(dist){}\n};\n\nbool visited[503][503];\nqueue<P> q;\nvoid bfs(double v[503][503]) {\n    MEMSET(visited,false);\n\n    while (!q.empty()) {\n        P p=q.front(); q.pop();\n        if (visited[p.y][p.x]) continue;\n        visited[p.y][p.x]=true;\n\n        v[p.y][p.x]=p.dist;\n\n        REP(r,4) {\n            int ay=p.y+dy[r], ax=p.x+dx[r];\n            if (ay<0||ax<0||ay>=H||ax>=W) continue;\n            if (visited[ay][ax]) continue;\n            if (s[ay][ax]=='#' || s[ay][ax]=='*') continue;\n            q.push(P(ay,ax,p.dist+1));\n        }\n    }\n}\n\ndouble f(double z) {\n    double sum=0;\n    REP(y,H) REP(x,W) if (s[y][x]=='.' || s[y][x]=='s') sum+=min(bane[y][x]+z, d[y][x]);\n    return sum;\n}\n\nint main() {\n    scanf(\"%d%d\",&W,&H);\n    REP(y,H) scanf(\"%s\",s[y]);\n    int sy=-1,sx=-1,gy=-1,gx=-1;\n    F=0;\n    REP(y,H) REP(x,W) {\n        if (s[y][x]=='.'||s[y][x]=='s') F++;\n        if (s[y][x]=='s') sy=y,sx=x;\n        if (s[y][x]=='g') gy=y,gx=x;\n    }\n\n    REP(y,H) REP(x,W) d[y][x]=1e18,bane[y][x]=1e18;\n        // d\n    q=queue<P>();\n    q.push(P(gy,gx,0));\n    bfs(d);\n\n        // bane\n    q=queue<P>();\n    REP(y,H) REP(x,W) if (s[y][x]=='*') q.push(P(y,x,0));\n    bfs(bane);\n\n    double inf=1,sup=1e18;\n    REP(itr,164) {\n        double z=(inf+sup)/2;\n        if (f(z)/F-z < 0) sup=z;\n        else inf=z;\n    }\n    //cout<<\"#\"<<d[sy][sx]<<endl;\n    printf(\"%.14f\\n\", min(bane[sy][sx]+inf, d[sy][sx]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<int> > dg(H, vector<int>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (_y >= 0 && _y < H && _x >= 0 && _x < W && a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ds(H, vector<int>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (_y >= 0 && _y < H && _x >= 0 && _x < W && a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e18;\n\tfor (int t = 0; t < 200; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#include<cfloat>\nconst double DINF = 1e12;\nconst double eps = 1e-10;\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.01)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.01)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0.0;\n\t\n\t//while((l-r)*2.0>(l+r)*esp){}\n\trep(k,200){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = (l+r)*0.5;\n\t\t//printf(\"%.10f %.10f %.10f\\n\",l,r,m);\n\t\tdouble zan=0,cs=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tdouble na = cmin(y,x,m),ce;\n\t\t\tce=cs + na + zan;\n\t\t\tzan=cs+na+zan-ce;\n\t\t\tcs=ce;\n\t\t}\n\t\tcs+=zan;\n\t\tif(cs/dotnum>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\t//printf(\"%.10f %.10f\\n\",dist[sy][sx],mine[sy][sx]);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] != 'g' && c[i][j] != '#' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e160, M = 0;\n  rep(i,1020){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef long long Weight;\n\nconst Weight INF = 1000000000000ll;\n\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n// The costs of edges must be 0 or 1 (Verified: TCO 2014 Round 2C Medium)\nvoid bfs01(Graph &g, vector<Weight> &d, int s) {\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  queue<P> que, zero;\n  que.push(P(0, s));\n  while (!zero.empty() || !que.empty()) {\n    P top = zero.empty() ? que.front() : zero.front();\n    if (zero.empty()) que.pop(); else zero.pop();\n    Weight dist = top.first; int v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push(P(d[e.dest], e.dest));\n        else zero.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nbool is_mbl(char c){\n  return c=='.'||c=='s'||c=='g'||c=='*';\n}\n\nbool is_bembl(char c){\n  return c=='.'||c=='s';\n}\n\nint main() {\n  int w,h;\n  cin>>w>>h;\n  vector<string> t(h);\n  REP(i,h)cin>>t[i];\n  int s,gix;\n  REP(i,h)REP(j,w){\n    if(t[i][j]=='s'){\n      s=i*w+j;\n    }else if(t[i][j]=='g'){\n      gix=i*w+j;\n    }\n  }\n  Graph g(h*w+1);\n  REP(i,h)REP(j,w){\n    if(!is_mbl(t[i][j]))continue;\n    int di[]={1,0,-1,0};\n    int dj[]={0,1,0,-1};\n    int six = i*w+j;\n    REP(k,4){\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if(ni<0||nj<0||ni>=h||nj>=w)continue;\n      if(!is_bembl(t[ni][nj]))continue;\n      int tix = ni*w+nj;\n      g[six].push_back({six,tix,1});\n    }\n    if(t[i][j]=='*'){\n      g[h*w].push_back({h*w,six,0});\n    }\n  }\n  Array dg(h*w+1);\n  Array ds(h*w+1);\n  bfs01(g, dg, gix);\n  bfs01(g, ds, h*w);\n  long double v=1e+10;\n  long double ex_spr = 0;\n  while(v > 1e-14){\n    long double dist_sum = 0;\n    int cnt=0;\n    REP(i,h*w){\n      if(!is_bembl(t[i/w][i%w]))continue;\n      dist_sum += min((long double)(dg[i]), ds[i] + ex_spr + v);\n      ++cnt;\n    }\n    if (ex_spr + v < (dist_sum/cnt)) {\n      ex_spr += v;\n    }\n    v /= 2.0;\n  }\n  cout << setprecision(14) << fixed << min((long double)(dg[s]), ds[s] + ex_spr) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e30), l = 0.0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 1000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0.0;\n    long double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H*W*H, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\tcout << ans << endl;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 10000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >500)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\ndouble ToGoal(int x, int y, double E) {\n  double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//double vs[510 * 510];\ndouble calc(double E) {\n  double nE = 0.0;\n  int cnt = 0;\n  //priority_queue<double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      //que.push(-ToGoal(x, y, E));\n      nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  //REP(i, cnt - 1) {\n    //nE += vs[i];\n    //double l = que.top();\n    //que.pop();\n    //double r = que.top();\n    //que.pop();\n    //que.push(l + r);\n  //}\n  return nE / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    double left = 0.0;\n    double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 90) {\n        double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10f\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconstexpr int INF = 1e9;\n\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<string> v(H);\n    int s, g;\n    int fcnt = 0;\n    queue<int> que;\n    vector<int> sd(H * W, INF);\n    for(int i = 0; i < H; ++i) {\n        cin >> v[i];\n        for(int j = 0; j < W; ++j) {\n            if(v[i][j] == 's') {\n                s = i * W + j;\n            } else if(v[i][j] == 'g') {\n                g = i * W + j;\n            } else if(v[i][j] == '*') {\n                que.push(i * W + j);\n                sd[i * W + j] = 0;\n            }\n            fcnt += v[i][j] == '.' || v[i][j] == 's';\n        }\n    }\n\n    while(!que.empty()) {\n        int y = que.front() / W;\n        int x = que.front() % W;\n        que.pop();\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx || v[ny][nx] == '#' || v[ny][nx] == 'g' || sd[ny * W + nx] != INF) {\n                continue;\n            }\n            sd[ny * W + nx] = sd[y * W + x] + 1;\n            que.push(ny * W + nx);\n        }\n    }\n\n    vector<int> gd(H * W, INF);\n    que.push(g);\n    gd[g] = 0;\n    double total_gd = 0;\n    while(!que.empty()) {\n        int y = que.front() / W;\n        int x = que.front() % W;\n        que.pop();\n        for(int i = 0; i < 4; ++i) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx || v[ny][nx] == '#' || v[ny][nx] == '*' || gd[ny * W + nx] != INF) {\n                continue;\n            }\n            gd[ny * W + nx] = gd[y * W + x] + 1;\n            total_gd += gd[ny * W + nx];\n            que.push(ny * W + nx);\n        }\n    }\n\n    vector<pll> d;\n    int scnt = 0;\n    double total_sd = 0;\n    for(int i = 0; i < H * W; ++i) {\n        if(i == g || v[i / W][i % W] == '*' || v[i / W][i % W] == '#') {\n            continue;\n        }\n        if(gd[i] == INF && sd[i] != INF) {\n            scnt++;\n            total_sd += sd[i];\n        } else if(sd[i] != INF) {\n            d.emplace_back(-gd[i] + sd[i], i);\n        }\n    }\n    sort(d.begin(), d.end());\n\n    double res = 1e18;\n    auto it = d.begin();\n    for(int i = -H * W; i <= H * W; ++i) {\n        while(it != end(d) && it->first <= i) {\n            scnt++;\n            total_sd += sd[it->second];\n            total_gd -= gd[it->second];\n            it++;\n        }\n        if(scnt == fcnt) {\n            continue;\n        }\n        double E = (total_gd + total_sd) / (1 - (double)scnt / fcnt) / fcnt;\n        if(gd[s] == INF || -gd[s] + sd[s] <= i) {\n            res = min(res, E + sd[s]);\n        } else {\n            res = min(res, (double)gd[s]);\n        }\n    }\n\n    cout << fixed << setprecision(10) << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<int> > dg(H, vector<int>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ds(H, vector<int>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1000000000000LL;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf (int)(1e18)\n#define int long long\n#define double long double\n\nsigned main(){\n\tint H, W, i, j, v;\n\tscanf(\"%lld%lld\", &W, &H);\n\tvector<string> c(H);\n\tint sx, sy, floor = 0;\n\tqueue<pair<pair<int, int>, int>> q1, q2;\n\tfor(i = 0; i < H; i++){\n\t\tcin >> c[i];\n\t\tfor(j = 0; j < W; j++){\n\t\t\tif(c[i][j] == 's'){\n\t\t\t\tsx = i;\n\t\t\t\tsy = j;\n\t\t\t\tc[i][j] = '.';\n\t\t\t}\n\t\t\tif(c[i][j] == 'g'){\n\t\t\t\tq1.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\t}\n\t\t\tif(c[i][j] == '*'){\n\t\t\t\tq2.push(pair<pair<int, int>, int>(pair<int, int>(i, j), 0));\n\t\t\t}\n\t\t\tif(c[i][j] == '.'){\n\t\t\t\tfloor++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[4] = {0, 1, 0, -1};\n\tint dy[4] = {1, 0, -1, 0};\n\tint d;\n\tvector<vector<int>> A1(H, vector<int>(W, inf));\n\twhile(q1.size() > 0){\n\t\ti = q1.front().first.first;\n\t\tj = q1.front().first.second;\n\t\tv = q1.front().second;\n\t\tq1.pop();\n\t\tif(c[i][j] == '#' || c[i][j] == '*' || A1[i][j] <= v){\n\t\t\tcontinue;\n\t\t}\n\t\tA1[i][j] = v;\n\t\tfor(d = 0; d < 4; d++){\n\t\t\tq1.push(pair<pair<int, int>, int>(pair<int, int>(i + dx[d], j + dy[d]), v + 1));\n\t\t}\n\t}\n\tvector<vector<int>> A2(H, vector<int>(W, inf));\n\twhile(q2.size() > 0){\n\t\ti = q2.front().first.first;\n\t\tj = q2.front().first.second;\n\t\tv = q2.front().second;\n\t\tq2.pop();\n\t\tif(c[i][j] == '#' || c[i][j] == 'g' || A2[i][j] <= v){\n\t\t\tcontinue;\n\t\t}\n\t\tA2[i][j] = v;\n\t\tfor(d = 0; d < 4; d++){\n\t\t\tq2.push(pair<pair<int, int>, int>(pair<int, int>(i + dx[d], j + dy[d]), v + 1));\n\t\t}\n\t}\n/*\tprintf(\"floor = %d\\n\", floor);\n\tprintf(\"A1\\n\");\n\tfor(i = 0; i < H; i++){\n\t\tfor(j = 0; j < W; j++){\n\t\t\tprintf(\"%2d \", A1[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"A2\\n\");\n\tfor(i = 0; i < H; i++){\n\t\tfor(j = 0; j < W; j++){\n\t\t\tprintf(\"%2d \", A2[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n*/\tdouble l = 0, h, r = 1e12;\n\tfor(int k = 0; k < 200; k++){\n//\t\tprintf(\"(l, r) = (%lf, %lf)\\n\", l, r);\n\t\th = (l + r) / 2;\n\t\tdouble hf = 0;\n\t\tfor(i = 0; i < H; i++){\n\t\t\tfor(j = 0; j < W; j++){\n\t\t\t\tif(c[i][j] == '.'){\n\t\t\t\t\thf += min((double)A1[i][j], A2[i][j] + h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tprintf(\"(h, hf) = (%lf, %lf)\\n\", h, hf);\n\t\tif(h * floor < hf){\n\t\t\tl = h;\n\t\t}\n\t\telse{\n\t\t\tr = h;\n\t\t}\n\t}\n\tprintf(\"%.20Lf\\n\", min((double)A1[sx][sy], A2[sx][sy] + r));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int N = 500;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst ll inf = 1LL<<60;\nchar m[N][N+1];\nll dcost[N][N];//ç´æ¥ã´ã¼ã«ã¾ã§è¡ãã³ã¹ã\nll scost[N][N];//ãããä½¿ã£ãæã®ã³ã¹ã\nvoid bfs(int r,int c,char s,ll cost[N][N]){\n  queue<int> Q;\n  rep(i,r)rep(j,c)\n    if (m[i][j] == s)cost[i][j] = 0,Q.push(i*c+j);\n    else cost[i][j] = inf;\n  while(!Q.empty()){\n    int y = Q.front()/c,x=Q.front()%c;Q.pop();\n    //    cout << y <<\" \" << x << endl;\n    rep(i,4){\n      int ney = y+dy[i],nex = x+dx[i];\n      if (m[ney][nex] == '*' || m[ney][nex] == 'g' || m[ney][nex] == '#' || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n}\n\n//brute force,ã¨ããããåæããã¾ã§åãã¦ã¿ã\n//å¥åãgs*ã¿ãããªã®ãæ¥ãã¨è½ã¡ãå¯è½æ§ããã\ndouble exp[N][N];\ndouble bf(int r,int c){\n  double e=0;//æå¾å¤ã®ç·åãæã£ã¦ããã¨å½¹ã«ç«ã¤\n  double pos = 0;//ããã§è¡ãå¯è½æ§ã®ããå ´æã®æ°\n  int sy,sx;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '*' || m[i][j] == 'g' || m[i][j] == '#')continue;\n      exp[i][j] = dcost[i][j];\n      e += dcost[i][j];\n      pos++;\n      if (m[i][j] == 's')sy = i,sx = j;\n    }\n  }\n\n\n  double L = 0,R=1e20;\n  double ans = -1;\n  rep(i,300){\n    double mid = (L+R)/2.;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#' || m[i][j] == '*')continue;\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + mid/pos;\n\tnewe += min(tmp,tmp2);\n      }\n    }\n\n    //cout <<\"owari \" << newe <<\" \" << L << \" \" << mid <<\" \" << R << endl;\n    if (newe < mid){//äºæ³ããå°ããã£ã\n      ans = mid;\n      R = mid - 1e-10;\n    }else {//äºæ³ããå¤§ããã£ã\n      L = mid + 1e-10;\n    }\n  }\n  //cout << ans<< \" \" << ans/pos << endl;\n  return  min((double)dcost[sy][sx],scost[sy][sx]+ans/pos);\n\n  /*\n  while(true){\n    bool isupdate = false;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#')continue;//ããã¯èããªãã\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + (e)/(pos);\n\tif (exp[i][j] > min(tmp,tmp2)){\n\t  isupdate = true;\n\t  e -= exp[i][j];\n\t  exp[i][j] = min(tmp,tmp2);\n\t  e += exp[i][j];\n\t}\n\tnewe += exp[i][j];\n      }\n    }\n    e = newe;\n    cout <<\"debug \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tprintf(\"%.3lf \",exp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    cout <<\"--------------==\" << endl;\n\n    if (!isupdate)break;\n  }\n\n  double hoge = 0;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#' || m[i][j] == 'g' || m[i][j] == '*')continue;\n      hoge += min((double)dcost[i][j],scost[i][j] + e/pos);\n      cout << min((double)dcost[i][j],scost[i][j] + e/pos) <<\" \" ;\n    }\n    cout << endl;\n  }\n  cout <<\"hoge \" << e <<\" \" << hoge/pos << endl;\n  */\n  rep(i,r)rep(j,c)if (m[i][j] == 's')return exp[i][j];\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)cin>>m[i];\n    bfs(r,c,'*',scost);\n    bfs(r,c,'g',dcost);\n    printf(\"%.12lf\\n\",bf(r,c));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n      //  assert(g[y][x] != '#');\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n      //  assert(g[y][x] != '#');\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < h; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*\n    printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sy][sx] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e18;\n    while (r - l > 1e-12) {\n        //printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                \n                \n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n        //printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int W, H;\n    vector<string> F;\n    void input() {\n        cin >> W >> H;\n        F.clear(); F.resize(H);\n        cin >> F;\n    }\n\n    const real INF = 1e200;\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {-1, 0, 1, 0};\n\n    vector< vector<real> > C; // from the stairs\n    vector< vector<real> > S; // from the nearest spring;\n\n    void bfs(int sy, int sx, vector< vector<real> >& M) {\n        assert(M.size() == H && M[0].size() == W);\n        queue< pair<int, int> > Q;\n        Q.push(make_pair(sy, sx));\n        M[sy][sx] = 0;\n        while (not Q.empty()) {\n            auto cur = Q.front(); Q.pop();\n            int cy = cur.first, cx = cur.second;\n            for (int i = 0; i < 4; i++) {\n                int ny = cy + dy[i],\n                    nx = cx + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (F[ny][nx] == '*') continue;\n                real ncost = M[cy][cx] + 1;\n                if (M[ny][nx] > ncost) {\n                    M[ny][nx] = ncost;\n                    Q.push(make_pair(ny, nx));\n                }\n            }\n        }\n    }\n\n    int N;\n    int X, Y;\n    void init() {\n        N = 0;\n        C = vector< vector<real> >(H, vector<real>(W, INF));\n        S = vector< vector<real> >(H, vector<real>(W, INF));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'g') {\n                    bfs(i, j, C);\n                } else if (F[i][j] == '*') {\n                    bfs(i, j, S);\n                } else if (F[i][j] == 's' || F[i][j] == '.') {\n                    if (F[i][j] == 's') {\n                        Y = i;\n                        X = j;\n                    }\n                    N++;\n                } else {\n                    assert(F[i][j] == '#');\n                }\n            }\n        }\n    }\n\n    real f(real x) {\n        real ret = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '.' || F[i][j] == 's') {\n                    ret += min(S[i][j] + x, C[i][j]);\n                }\n            }\n        }\n        return ret / N;\n    }\n\n    real g(real x) {\n        return x - f(x);\n    }\n\n    void solve() {\n        init();\n        real lb = 0, ub = INF;\n        for (int i = 0; i < 1000; i++) {\n            //if (i % 100 == 0) cerr << i << endl;\n            real mid = (lb + ub) / 2;\n            (g(mid) < 0 ? lb : ub) = mid;\n        }\n        real x = lb;\n        //cerr << \"x: \" << x << endl;\n        //cerr << S[Y][X] << endl;\n        cout << fixed << setprecision(12) << min(C[Y][X], S[Y][X] + x) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst ll INF = 1LL << 50;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nchar field[600][600];\nll a[600][600];\nll b[600][600];\n\nvoid bfs(char start, ll dist[][600]){\n  queue<int> que;\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, INF);\n  rep(i, H)rep(j, W){\n    if(field[i][j] == start){\n      dist[i][j] = 0;\n      que.push(i * W + j);\n    }\n  }\n  while(!que.empty()){\n    int p = que.front(); que.pop();\n    int x = p % W;\n    int y = p / W;\n    rep(i, 4){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      if((field[y2][x2] == '.' || field[y2][x2] == 's') && dist[y2][x2] == INF){\n\tdist[y2][x2] = dist[y][x] + 1;\n\tque.push(y2 * W + x2);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H){\n    int sy = 0, sx = 0;\n    rep(i, H)rep(j, W){\n      cin >> field[i][j];\n      if(field[i][j] == 's'){\n\tsy = i, sx = j;\n      }\n    }\n    bfs('*', a);\n    bfs('g', b);\n    long double ub = 1e15;\n    long double lb = 0;\n    rep(i, 1000){\n      long double mb = (ub + lb) / 2;\n      long double sum = 0;\n      int cnt = 0;\n      rep(j, H)rep(k, W){\n\tif(field[j][k] == 's' || field[j][k] == '.'){\n\t  cnt++;\n\t  sum += min((long double)b[j][k], a[j][k] + mb);\n\t}\n      }\n      if(mb > sum / cnt) ub = mb;\n      else lb = mb;\n    }\n    cout << fixed << setprecision(15) << min(lb+a[sy][sx],(long double)b[sy][sx])<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint W,H;\nstring s[500];\nll a[500][500];\nll b[500][500];\nint dd[]={-1,0,1,0,-1};\nint si,sj;\nvector<P> ts;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>W>>H;\n  rep(i,H)cin>>s[i];\n\n  rep(i,H)rep(j,W){\n    if(s[i][j]=='s'){\n      si=i; sj=j;\n    }\n  }\n  rep(i,H)rep(j,W)a[i][j]=b[i][j]=INF;\n  {\n    queue<P> que;\n    rep(i,H)rep(j,W){\n      if(s[i][j]=='g'){\n        que.push(P(i,j));\n        a[i][j]=0;\n      }\n    }\n    while(que.size()){\n      P p=que.front(); que.pop();\n      rep(d,4){\n        int ni=p.fi+dd[d],nj=p.se+dd[d+1];\n        if(ni<0||ni>=H||nj<0||nj>=W||s[ni][nj]=='#'||s[ni][nj]=='*'||a[ni][nj]!=INF)continue;\n        a[ni][nj]=a[p.fi][p.se]+1;\n        que.push(P(ni,nj));\n      }\n    }\n  }\n  {\n    queue<P> que;\n    rep(i,H)rep(j,W){\n      if(s[i][j]=='*'){\n        que.push(P(i,j));\n        b[i][j]=0;\n      }\n    }\n    while(que.size()){\n      P p=que.front(); que.pop();\n      rep(d,4){\n        int ni=p.fi+dd[d],nj=p.se+dd[d+1];\n        if(ni<0||ni>=H||nj<0||nj>=W||s[ni][nj]=='#'||s[ni][nj]=='g'||b[ni][nj]!=INF)continue;\n        b[ni][nj]=b[p.fi][p.se]+1;\n        que.push(P(ni,nj));\n      }\n    }\n  }\n\n  rep(i,H)rep(j,W){\n    if(s[i][j]=='s'||s[i][j]=='.')ts.push_back(P(i,j));\n  }\n  sort(all(ts),[=](const P& t1,const P& t2){ return a[t1.fi][t1.se]-b[t1.fi][t1.se] < a[t2.fi][t2.se]-b[t2.fi][t2.se]; });\n\n  bool oc=true;\n  long double res=a[si][sj];\n  long double suma=0,sumb=0;\n  ll T=ts.size();\n  rep(i,T)sumb+=b[ts[i].fi][ts[i].se];\n  repl(M,1,T+1){\n    ll i=ts[M-1].fi,j=ts[M-1].se;\n    suma+=a[i][j];\n    sumb-=b[i][j];\n    long double sumE=((long double)(T-M)*suma+(long double)T*sumb)/(long double)M;\n    if(s[i][j]=='s')oc=false;\n    if(oc)minch(res,suma/(long double)T+sumE/(long double)T+b[si][sj]);\n  }\n  printf(\"%.10Lf\\n\", res);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one, vector<one>>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16500; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < w; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e9;\n    while (r - l > 1e-12) {\n//        printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                assert(dist2b[y][x] != INT_INF);\n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n//        printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e10), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 10000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      //cout << springs[i].first << \" \" << springs[i].second << \"!\" << endl;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\t//cout << x << \" \" << y << endl;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j]/n;\n\t  //cout << exp[i][j] << endl;\n\t}\n      }\n    }\n    //cout << s << \" \" << mean << endl;\n    if(s < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n    //cout << mean << endl;\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  /*\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      cout << exp[i][j] << \" \";\n    }cout << endl;\n  }\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF (1070000000LL*1070000000LL)\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint H,W;\nchar c[555][555];\nint sy,sx,gy,gx;\nll dist1[555][555],dist2[555][555];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H;\n\trep(i,H)rep(j,W){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sy=i,sx=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gy=i,gx=j;\n\t}\n\trep(i,H)rep(j,W){\n\t\tdist1[i][j]=dist2[i][j]=INF;\n\t}\n\tdist1[gy][gx]=0;\n\tqueue<pi> Q;\n\tQ.push(mp(gy,gx));\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist1[ny][nx]==INF){\n\t\t\t\tdist1[ny][nx]=dist1[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H)rep(j,W)if(c[i][j]=='*'){\n\t\tdist2[i][j]=0;\n\t\tQ.push(mp(i,j));\n\t}\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist2[ny][nx]==INF){\n\t\t\t\tdist2[ny][nx]=dist2[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<ll> d1,d2;\n\tint start;\n\trep(i,H)rep(j,W)if(c[i][j]=='.'){\n\t\tif(i==sy && j==sx)start=sz(d1);\n\t\td1.pb(dist1[i][j]);\n\t\td2.pb(dist2[i][j]);\n\t}\n\t\n\tdouble lo=0,hi=1e10;\n\trep(t,100){\n\t\tdouble mi=(lo+hi)/2;\n\t\tdouble sum=0;\n\t\trep(i,sz(d1)){\n\t\t\tsum+=min(1.*d1[i],d2[i]+mi);\n\t\t}\n\t\tif(sum>mi*sz(d1))lo=mi;\n\t\telse hi=mi;\n\t}\n\tprintf(\"%.16f\\n\",min(1.*d1[start],d2[start]+hi));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n#define double long double\n\nconst int INF=1001001001;\nconst int INFLL=1001001001001001001ll;\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint dy[4]={-1,0,1,0};\nint dx[4]={0,-1,0,1};\n\nint H,W;\nchar fld[555][555];\ndouble E[555][555];\nbool check(double e){\n    queue<pint>que;\n    fill_n(*E,555*555,1e14);\n    rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n        E[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(true){\n        if(que.size()==0){\n            if(flag)break;\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n            continue;\n        }\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n\n        if(E[y][x]+1>=e&&!flag){\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n        }\n\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||fld[ny][nx]=='*')continue;\n\n            if(E[ny][nx]!=1e14)continue;\n            E[ny][nx]=E[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    double sum=0;\n    int cnt=0;\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='#'||fld[i][j]=='*'||fld[i][j]=='g')continue;\n        cnt++;sum+=E[i][j];\n    }\n\n    return sum<=e*cnt;\n}\n\n\nsigned main(){\n    cin>>W>>H;\n    rep(i,H)cin>>fld[i];\n\n    vector<vint>dist(H,vint(W,INT_MAX));\n    queue<pint>que;\n    rep(i,H)rep(j,W)if(fld[i][j]=='s'){\n        dist[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||dist[ny][nx]!=INT_MAX)continue;\n            if(fld[ny][nx]=='*')flag=true;\n            dist[ny][nx]=dist[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    if(!flag){\n        rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n            printf(\"%.20Lf\\n\",(double)dist[i][j]);\n            return 0;\n        }\n    }\n\n    double lb=0,ub=1e12;\n    rep(i,200){\n        double mid=(ub+lb)/2;\n        if(check(mid))ub=mid;\n        else lb=mid;\n    }\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='s'){\n            printf(\"%.20Lf\\n\",E[i][j]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF (1070000000LL*1070000000LL)\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint H,W;\nchar c[555][555];\nint sy,sx,gy,gx;\nll dist1[555][555],dist2[555][555];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H;\n\trep(i,H)rep(j,W){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sy=i,sx=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gy=i,gx=j;\n\t}\n\trep(i,H)rep(j,W){\n\t\tdist1[i][j]=dist2[i][j]=INF;\n\t}\n\tdist1[gy][gx]=0;\n\tqueue<pi> Q;\n\tQ.push(mp(gy,gx));\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist1[ny][nx]==INF){\n\t\t\t\tdist1[ny][nx]=dist1[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H)rep(j,W)if(c[i][j]=='*'){\n\t\tdist2[i][j]=0;\n\t\tQ.push(mp(i,j));\n\t}\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist2[ny][nx]==INF){\n\t\t\t\tdist2[ny][nx]=dist2[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<ll> d1,d2;\n\tint start;\n\trep(i,H)rep(j,W)if(c[i][j]=='.'){\n\t\tif(i==sy && j==sx)start=sz(d1);\n\t\td1.pb(dist1[i][j]);\n\t\td2.pb(dist2[i][j]);\n\t}\n\t\n\tlong double lo=0,hi=1e15;\n\trep(t,100){\n\t\tlong double mi=(lo+hi)/2;\n\t\tlong double sum=0;\n\t\trep(i,sz(d1)){\n\t\t\tsum+=min((long double)d1[i],d2[i]+mi);\n\t\t}\n\t\tif(sum>mi*sz(d1))lo=mi;\n\t\telse hi=mi;\n\t}\n\tprintf(\"%.16f\\n\",min((double)d1[start],(double)(d2[start]+hi)));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 500\n\nstruct LOC{\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nstruct Info{\n\tLOC loc;\n\tint to_goal,to_spring;\n\tbool is_floor;\n};\n\nstruct State{\n\tState(int arg_row,int arg_col,int arg_sum_dist){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct State &arg) const{\n\t\treturn sum_dist > arg.sum_dist;\n\t}\n\tint row,col,sum_dist;\n};\n\nchar base_map[NUM][NUM+1];\nint W,H;\nint floor_num;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint goal_table[NUM][NUM],spring_table[NUM][NUM];\nLOC start,goal;\nInfo info[NUM][NUM];\n\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tinfo[row][col].loc.set(row,col);\n\t\t\tinfo[row][col].is_floor = false;\n\t\t}\n\t}\n\n\tfloor_num = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tswitch(base_map[row][col]){\n\t\t\tcase '.':\n\t\t\t\tinfo[row][col].is_floor = true;\n\t\t\t\tfloor_num++;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tinfo[row][col].is_floor = true;\n\t\t\t\tstart.set(row,col);\n\t\t\t\tfloor_num++;\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\tgoal.set(row,col);\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\t//Do nothing\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\t//Do nothing\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)goal_table[row][col] = BIG_NUM;\n\t}\n\n\tpriority_queue<State> Q;\n\tgoal_table[goal.row][goal.col] = 0;\n\n\tQ.push(State(goal.row,goal.col,0));\n\n\tint adj_row,adj_col,next_dist;\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\tnext_dist = Q.top().sum_dist+1;\n\t\t\tif(goal_table[adj_row][adj_col] > next_dist){\n\t\t\t\tgoal_table[adj_row][adj_col] = next_dist;\n\t\t\t\tQ.push(State(adj_row,adj_col,next_dist));\n\t\t\t}\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++)spring_table[row][col] = BIG_NUM;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] != '*')continue;\n\n\t\t\tspring_table[row][col] = 0;\n\t\t\tQ.push(State(row,col,0));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || base_map[adj_row][adj_col] != '.')continue;\n\n\t\t\t\t\tnext_dist = Q.top().sum_dist+1;\n\t\t\t\t\tif(spring_table[adj_row][adj_col] > next_dist){\n\t\t\t\t\t\tspring_table[adj_row][adj_col] = next_dist;\n\t\t\t\t\t\tQ.push(State(adj_row,adj_col,next_dist));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tint maximum = 0;\n\tmap<pair<int,int>,int> MAP;\n\n\tfor(int row = 0;row < H;row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(info[row][col].is_floor){\n\t\t\t\tinfo[row][col].to_goal = goal_table[row][col];\n\t\t\t\tif(info[row][col].to_goal != BIG_NUM){\n\t\t\t\t\tmaximum = max(maximum,info[row][col].to_goal);\n\t\t\t\t}\n\t\t\t\tinfo[row][col].to_spring = spring_table[row][col];\n\t\t\t\tMAP[make_pair(goal_table[row][col],spring_table[row][col])]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double E = INFINITY;\n    for(int value = 0; value <= maximum; value++){\n\n    \tlong double a = 0;\n    \tlong double b = 0;\n\n    \tfor(auto it: MAP){\n\n    \t\tint to_goal,to_spring;\n    \t\tto_goal = it.first.first;\n    \t\tto_spring = it.first.second;\n\n    \t\tint count = it.second;\n\n    \t\tlong double possib = count/(long double)floor_num;\n\n    \t\tif(to_goal == BIG_NUM){\n    \t\t\ta += possib;\n    \t\t\tb += possib*to_spring;\n    \t\t}else if(to_spring == BIG_NUM){\n    \t\t\tb += possib*to_goal;\n    \t\t}else{\n    \t\t\tif(to_goal <= to_spring+value){\n    \t\t\t\tb += possib*to_goal;\n    \t\t\t}else{\n    \t\t\t\ta += possib;\n    \t\t\t\tb += possib*to_spring;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tE = min(E,b/(1-a));\n    }\n\n    long double ans;\n    if(info[start.row][start.col].to_goal == BIG_NUM){\n    \tans = info[start.row][start.col].to_spring+E;\n    }else if(info[start.row][start.col].to_spring == BIG_NUM){\n    \tans = info[start.row][start.col].to_goal;\n    }else{\n    \tans = min<long double>(info[start.row][start.col].to_goal,info[start.row][start.col].to_spring+E);\n    }\n\n    printf(\"%.10Lf\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=5e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint w,h,sx,sy,gx,gy,num,inf=1e8;\nstring s[500];\nint dg[500][500],db[500][500],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvoid gbfs(int gx,int gy){\n\trep(i,h) rep(j,w) dg[i][j]=inf;\n\tdg[gx][gy]=0;\n\tqueue<PP> que;\n\tque.push(PP(dg[gx][gy],P(gx,gy)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&dg[nx][ny]==inf){\n\t\t\t\tdg[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(dg[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bbfs(){\n\tqueue<PP> que;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='*') db[i][j]=inf;\n\t\telse que.push(PP(0,P(i,j)));\n\t}\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&db[nx][ny]==inf){\n\t\t\t\tdb[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(db[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(long double x){\n\tlong double sum=0;\n\trep(i,h) rep(j,w) if(s[i][j]!='#'&&s[i][j]!='*') sum+=min(x+db[i][j],(long double)dg[i][j]);\n\treturn sum/num<x;\n}\nint main(){\n\tcin>>w>>h;\n\trep(i,h) cin>>s[i];\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]=='s') sx=i,sy=j,num++;\n\t\tif(s[i][j]=='g') gx=i,gy=j;\n\t\tif(s[i][j]=='.') num++;\n\t}\n\tgbfs(gx,gy);\n\tbbfs();\n\t/*bool flag=false;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='#'&&dg[i][j]==inf&&db[i][j]==inf) flag=true;\n\t}\n\tif(flag){\n\t\tprintf(\"%d\\n\",dg[sx][sy]);\n\t\treturn 0;\n\t}*/\n\tlong double ub=1e100,lb=0;\n\twhile(ub-lb>1e-12){\n//\t\tcout<<ub<<\" \"<<lb<<endl;\n\t\tlong double mid=(ub+lb)/2;\n\t\tif(check(mid)) ub=mid;\n\t\telse lb=mid;\n\t}\n\tprintf(\"%.12f\\n\",(double)min(ub+db[sx][sy],(long double)dg[sx][sy]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<ll> > dg(H, vector<ll>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<ll> > ds(H, vector<ll>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e18;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e25\n\nusing namespace std;\n\ntypedef pair<int, int> pos;\ntypedef pair<double, pos> P;\n\nint W, H;\nchar map[505][505];\nint sx, sy, gx, gy;\ndouble dist[505][505];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dijkstra(double m)\n{\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tdist[x][y] = inf;\n\t\t}\n\t}\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tdist[gx][gy] = 0, Q.push( make_pair(0, make_pair(gx, gy)) );\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '*') dist[x][y] = m, Q.push(make_pair(m, make_pair(x, y)));\n\t\t}\n\t}\n\t\n\tint x, y;\n\tdouble d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tx = Q.top().second.first;\n\t\ty = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(dist[x][y] < d) continue;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx <= 0 || nx > W || ny <= 0 || ny > H) continue;\n\t\t\tif(map[nx][ny] != '.') continue;\n\t\t\tif(dist[nx][ny] > d + 1){\n\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\tQ.push( make_pair(dist[nx][ny], make_pair(nx, ny)) );\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(double m)\n{\n\tdijkstra(m);\n\tdouble ret = 0; int cnt = 0;\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '.' && (x != gx || y != gy)){\n\t\t\t\tret += dist[x][y];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tret /= cnt;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> W >> H;\n\tfor(int y = 1; y <= H; y++){\n\t\tfor(int x = 1; x <= W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 's'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tsx = x, sy = y;\n\t\t\t}\n\t\t\tif(map[x][y] == 'g'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tgx = x, gy = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ub = 1e18, lb = 0.0, mid;\n\tfor(int i = 0; i < 100; i++){\n\t\tmid = (ub + lb) * 0.5;\n\t\tif(calc(mid) < mid) ub = mid;\n\t\telse lb = mid;\n\t}\n\tmid = (ub + lb) * 0.5;\n\tcalc(mid);\n\t\n\tprintf(\"%.11f\\n\", dist[sx][sy]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\n#define double long double\n\nint main() {\n  constexpr double inf = 1e100;\n\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int w, h; cin >> w >> h;\n  V<string> s(h); for (auto&& e : s) cin >> e;\n  int si = -1, sj = -1, gi = -1, gj = -1;\n  for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (s[i][j] == 'g') {\n    gi = i, gj = j;\n  } else if (s[i][j] == 's') {\n    si = i, sj = j;\n  }\n  VV<> d(h, V<>(w, -1));\n  d[gi][gj] = 0;\n  queue< pair<int, int> > que;\n  que.emplace(gi, gj);\n  while (not que.empty()) {\n    int i, j;\n    tie(i, j) = que.front(); que.pop();\n    for (int di = -1; di <= 1; ++di) for (int dj = -1; dj <= 1; ++dj) if (abs(di) + abs(dj) == 1) {\n      int ni = i + di, nj = j + dj;\n      if (s[ni][nj] != 's' and s[ni][nj] != '.') continue;\n      if (d[ni][nj] != -1) continue;\n      d[ni][nj] = d[i][j] + 1;\n      que.emplace(ni, nj);\n    }\n  }\n  VV<> e(h, V<>(w, -1));\n  for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (s[i][j] == '*') {\n    e[i][j] = 0;\n    que.emplace(i, j);\n  }\n  while (not que.empty()) {\n    int i, j;\n    tie(i, j) = que.front(); que.pop();\n    for (int di = -1; di <= 1; ++di) for (int dj = -1; dj <= 1; ++dj) if (abs(di) + abs(dj) == 1) {\n      int ni = i + di, nj = j + dj;\n      if (s[ni][nj] != 's' and s[ni][nj] != '.') continue;\n      if (e[ni][nj] != -1) continue;\n      e[ni][nj] = e[i][j] + 1;\n      que.emplace(ni, nj);\n    }\n  }\n  double ng = 0, ok = inf;\n  while (true) {\n    double mid = (ng + ok) / 2;\n    double num = 0, den = 0;\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (s[i][j] == 's' or s[i][j] == '.') {\n      num += min<double>(d[i][j] == -1 ? inf : d[i][j], (e[i][j] == -1 ? inf : e[i][j]) + mid);\n      den += 1;\n    }\n    (num / den < mid ? ok : ng) = mid;\n    if ((ok - ng) / ok < 1e-10) break;\n  }\n  double res = min<double>(d[si][sj] == -1 ? inf : d[si][sj], (e[si][sj] == -1 ? inf : e[si][sj]) + ok);\n  cout << fixed << setprecision(15) << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < w; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e18;\n    while (r - l > 1e-12) {\n//        printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                assert(dist2b[y][x] != INT_INF);\n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n//        printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e10), l = 0.0, r = INF, exp_[H][W], exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  queue< pair<int,int> > que;\n  que.push(make_pair(gx,gy));\n  for(int i = 0; i < H; ++i)\n    for(int j = 0; j < W; ++j)\n      exp_[i][j] = INF;\n  \n  exp_[gx][gy] = 0.0;\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k){\n      int x_ = x + d[k], y_ = y + d[(k+1)%4];\n      if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n      char c = M[x_][y_];\n      if(c == '.' && exp_[x_][y_] > exp_[x][y]+1){\n\texp_[x_][y_] = exp_[x][y]+1;\n\tque.push(make_pair(x_,y_));\n      }\n    }\n  }\n\n  for(int t = 0; t < 100; ++t){\n    long double mean = (l+r)/2.0;\n\n    for(int i = 0; i < H; ++i)\n      for(int j = 0; j < W; ++j)\n\texp[i][j] = exp_[i][j];\n\n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst double INF = 1e10;\n\nusing vd = vector<double>;\nusing V = vector<vd>;\n\nusing pi = pair<int,int>;\nusing P = pair<double,pi>;\n\nconst int dy[4]={1,-1,0,0}, dx[4]={0,0,1,-1};\n\nint main(){\n    int w,h;\n    cin >>w >>h;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    auto IN = [&](int y, int x){\n        return 0<=y && y<h && 0<=x && x<w;\n    };\n\n    auto calc = [&](double m){\n        V dp(h,vd(w,INF));\n\n        queue<pi> que;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='g'){\n                dp[i][j]=0;\n                que.push({i,j});\n            }\n            if(s[i][j]=='*'){\n                dp[i][j]=m;\n                que.push({i,j});\n            }\n        }\n\n        while(!que.empty()){\n            pi pos = que.front();\n            que.pop();\n            rep(d,4){\n                int ny = pos.fi+dy[d], nx = pos.se+dx[d];\n                if(IN(ny,nx) && s[ny][nx]!='#' && s[ny][nx]!='*'){\n                    if(dp[ny][nx] > dp[pos.fi][pos.se]+1){\n                        dp[ny][nx] = dp[pos.fi][pos.se]+1;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n        }\n\n        return dp;\n    };\n\n    double l=0, r=INF;\n    rep(loop,80){\n        double m = (l+r)/2;\n        V E = calc(m);\n\n        int n = 0;\n        double sumE = 0;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='.' || s[i][j]=='s'){\n                ++n;\n                sumE += E[i][j];\n            }\n        }\n        sumE /= n;\n\n        if(sumE<m) r=m;\n        else l=m;\n    }\n\n    V E = calc(l);\n    double ans=-1;\n    rep(i,h)rep(j,w)if(s[i][j]=='s') ans = E[i][j];\n    printf(\"%.15f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,58){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 50000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H*1000, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 100000000;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// 凸関数の極大な点をもとめる\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 1000){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// 凹関数の極小な・を求める\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\nlong double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k,\n                   const int s=0){\n    const int N = v.size();\n    int l = as[k];\n    int r = bs[N] - bs[k];\n    if(s > 100) return 1.0F * (l+r) / N;\n    return (l + r + (1.0F * (N-k) * calc_e(v,as,bs,k,s+1)))/N;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n    \n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n\n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    // 階段が近い → 遠い\n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c + 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    int ls = as[1] - bs[1];\n    int rs = as[N] - as[N-1] - (bs[N] - bs[N-1]);\n    auto r = ternary_search_concave(f,ls,rs);\n    // cout << f(r) << endl;\n    // for(int i=0;i<N;i++){\n    //     double d = as[i+1] - as[i] - (bs[i+1] - bs[i]);\n    //     dump(d);\n    // }\n\n    cout << fixed << setprecision(10);\n    cout << f(r) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/rational.hpp>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  LL w,h;\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> left=0;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> right=10000000000000000000;\n   cout << left << endl;\n   cout << right << endl;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> mid;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor);\n            }else{\n              count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   cout << left << endl;\n   cout << right << endl;\n   cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << \" \";\n  //         }else{\n  //           cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << endl;\n    }else{\n      cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n \nll INF = LLONG_MAX / 2;\n \nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n \nint main() {\n    int H, W; cin >> W >> H;\n    vector<string> a(H);\n    for (int y = 0; y < H; y++)\n        cin >> a[y];\n    int ys, xs, yg, xg;\n    for (int y = 0; y < H; y++)\n        for (int x = 0; x < W; x++) {\n            if (a[y][x] == 's') {\n                a[y][x] = '.';\n                ys = y;\n                xs = x;\n            }\n            if (a[y][x] == 'g') {\n                yg = y;\n                xg = x;\n            }\n        }\n    vector<vector<ll> > dg(H, vector<ll>(W, INF));\n    queue<i_i> q;\n    dg[yg][xg] = 0;\n    q.push(i_i(yg, xg));\n    while (q.size()) {\n        i_i p = q.front(); q.pop();\n        int y = p.first, x = p.second;\n        for (int k = 0; k < 4; k++) {\n            int _y = y + dy[k], _x = x + dx[k];\n            if (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n                dg[_y][_x] = dg[y][x] + 1;\n                q.push(i_i(_y, _x));\n            }\n        }\n    }\n    vector<vector<ll> > ds(H, vector<ll>(W, INF));\n    for (int y = 0; y < H; y++)\n        for (int x = 0; x < W; x++)\n            if (a[y][x] == '*') {\n                ds[y][x] = 0;\n                q.push(i_i(y, x));\n            }\n    while (q.size()) {\n        i_i p = q.front(); q.pop();\n        int y = p.first, x = p.second;\n        for (int k = 0; k < 4; k++) {\n            int _y = y + dy[k], _x = x + dx[k];\n            if (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n                ds[_y][_x] = ds[y][x] + 1;\n                q.push(i_i(_y, _x));\n            }\n        }\n    }\n    double lb = 0, ub = 1e15;\n    for (int t = 0; t < 100; t++) {\n        double mid = (lb + ub) / 2;\n        int k = 0;\n        double sum = 0;\n        for (int y = 0; y < H; y++)\n            for (int x = 0; x < W; x++)\n                if (a[y][x] == '.') {\n                    k++;\n                    sum += min((double)dg[y][x], ds[y][x] + mid);\n                }\n        if (sum / k > mid) lb = mid;\n        else ub = mid;\n    }\n    printf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing dbl = long double;\nusing Pi = pair<int, int>;\n\nconst dbl eps = 1e-15;\n#define lt(a, b) ((a)-(b) < -eps)\n#define eq(a, b) (fabs((a)-(b)) < eps)\n\nint W, H;\nchar mas[505][505];\nPi S, G;\nvector<Pi> Bs;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nvector<vector<dbl> > bfs(const vector<Pi>& s) {\n  //cout<<\"!!!!!\"<<endl;\n  queue<Pi> que;\n  vector<vector<dbl> > dist(H, vector<dbl>(W, -1));\n  for(Pi p : s) {\n    que.emplace(p);\n    dist[p.first][p.second] = 0;\n  }\n  while(!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front(); que.pop();\n    //cout<<mas[y][x]<<\" \"<<y<<\" \"<<x<<endl;    \n    for(int i = 0; i < 4; ++i) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#' || mas[ny][nx] == '*') continue;\n      if(dist[ny][nx] == -1) {\n\tdist[ny][nx] = dist[y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n  return dist;\n}\n\nvector<vector<dbl> > db;\nvector<vector<dbl> > dg;\n\nbool check(dbl mb) {\n  dbl sum = 0;\n  int num = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.') {\n\t//if(dg[i][j] == -1 && db[i][j] == -1) assert(false);\n\tif(0) ;\n\telse if(dg[i][j] == -1) sum += db[i][j]+mb;\n\telse if(db[i][j] == -1) sum += dg[i][j];\n\telse sum += min(dg[i][j], db[i][j]+mb);\n\t++num;\n      }\n    }\n  }\n  assert(num > 0);\n  sum /= num;\n  return sum >= mb;\n}\n\nint main() {\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 's') S = Pi(i, j), mas[i][j] = '.';\n      else if(mas[i][j] == 'g') G = Pi(i, j);\n      else if(mas[i][j] == '*') Bs.emplace_back(i, j);\n    }\n  }\n\n  db = bfs(Bs);\n  dg = bfs({G});\n\n  dbl ans = dg[S.first][S.second];\n  //cout<<ans<<endl;\n  bool flag = false;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.' && dg[i][j] == -1 && db[i][j] == -1) flag = true;\n    }\n  }\n  \n  if(ans == -1) ans = DBL_MAX/2;\n  //else if(db[S.first][S.second] == -1) {\n  else if(flag) {\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n  }\n\n  dbl lb = 0, ub = 1e20;\n  for(int i = 0; i < 200; ++i) {\n    dbl mb = (lb+ub)/2;\n    if(check(mb)) lb = mb;\n    else ub = mb;\n  }\n\n  ans = min(ans, db[S.first][S.second]+lb);\n\n  cout << fixed << setprecision(12) << ans << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tdouble upper=20000000000.0,lower=1.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nll A[500][500],B[500][500];\nll INF=(1LL<<50);\n\nvoid bfs(char ch,ll d[500][500]){\n  fill(d[0],d[500], INF );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  \n  bfs('*',A);\n  bfs('g',B);\n\n  vector<ll> v;\n  ll sum=0,cnt=0,K=0;\n  double base=1e100;\n  double ans=1e100;\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      \n      cnt++;\n      if(t[i][j]=='s'){\n        if(A[i][j]==INF)base=1e100;\n        else base=A[i][j];\n        if(B[i][j]!=INF)ans=B[i][j];\n      }\n      if(A[i][j]==INF){\n        sum+=B[i][j];\n      }else if(B[i][j]==INF){\n        sum+=A[i][j];\n        K++;\n      }else{\n        sum+=B[i][j];\n        v.push_back(A[i][j]-B[i][j]);\n      }\n\n    }\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<(int)v.size();i++){\n    double rate=(double)K/(double)cnt;\n    double X=(double)sum/(double)cnt;\n    X/=(1.0-rate);\n    ans=min(ans,(double)base+X);\n    K++;\n    sum+=v[i];\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n#define INF 1e12\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fie[510][510];\nint dist[2][510][510];\nint w,h;\nint cnt;\nint sx,sy,gx,gy;\n\nvoid bfs(int y=-1,int x=-1){\n\tqueue<P> que;\n\tint type=0;\n\tif(y==-1)type=1;\n\tmemset(dist[type],-1,sizeof(dist[type]));\n\tif(type==0){\n\t\tdist[type][y][x]=0;\n\t\tque.push(P(y,x));\n\t}else{\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==1){\n\t\t\t\t\tdist[type][i][j]=0;\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(fie[ny][nx]!=-1 && dist[type][ny][nx]==-1){\n\t\t\t\tdist[type][ny][nx]=dist[type][p.first][p.second]+1;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(int v){\n\tif((dist[0][sy][sx]!=-1 && dist[0][sy][sx]<=dist[1][sy][sx]+v) || dist[1][sy][sx]==-1)return dist[0][sy][sx];\n\telse{\n\t\tint cnt=0;\n\t\tint all=0;\n\t\tint okave=0;\n\t\tint ngave=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\t\tall++;\n\t\t\t\t\tif(dist[0][i][j]==-1){\n\t\t\t\t\t\tngave+=dist[1][i][j];\n\t\t\t\t\t}else if(dist[0][i][j]<=dist[1][i][j]+v || dist[1][sy][sx]==-1){\n\t\t\t\t\t\tokave+=dist[0][i][j];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tngave+=dist[1][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt==0)return INF;\n\t\tdouble va=(double)okave/all;\n\t\tva*=1.0/((double)cnt/all);\n\t\tdouble vb=(double)ngave/((double)(all-cnt));\n\t\tvb*=1.0/((double)cnt/all);\n\t\tvb-=(double)ngave/((double)(all-cnt));\n\t\treturn (double)va+vb+dist[1][sy][sx];\n\t}\n}\n\nint calc_ok(int v){\n\tint cnt=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\tif(dist[0][i][j]==-1){\n\t\t\t\t}else if(dist[0][i][j]<=dist[1][i][j]+v || dist[1][sy][sx]==-1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tscanf(\"%d%d%*c\",&w,&h);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='#')fie[i][j]=-1;\n\t\t\tif(c=='s')sy=i,sx=j;\n\t\t\tif(c=='g')gy=i,gx=j;\n\t\t\tif(c=='*')fie[i][j]=1;\n\t\t\tif(c=='.')cnt++;\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tbfs(gy,gx);\n\tbfs();\n\tif(dist[1][sy][sx]==-1 || (dist[0][sy][sx]<=dist[1][sy][sx] && dist[0][sy][sx]!=-1)){\n\t\tprintf(\"%.10f\\n\",(double)dist[0][sy][sx]);\n\t\treturn 0;\n\t}\n\tint l=1,r=w*h;\n\tfor(int i=0;i<30;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(calc_ok(mid)==0){\n\t\t\tl=mid;\n\t\t}else{\n\t\t\tr=mid;\n\t\t}\n\t}\n\tr=w*h;\n\tif(dist[0][sy][sx]==-1){\n\t\tr=w*h;\n\t}else{\n\t\tr=dist[0][sy][sx]-dist[1][sy][sx]+1;\n\t}\n\tfor(int i=0;i<50;i++){\n\t\tint lm=(l*2+r)/3;\n\t\tint rm=(l+r*2)/3;\n\t\tdouble vl=calc(lm);\n\t\tdouble rl=calc(rm);\n\t\tif(vl<rl){\n\t\t\tr=rm;\n\t\t}else{\n\t\t\tl=lm;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",min(calc((l*2+r)/3),calc((l+r*2)/3)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing dbl = long double;\nusing Pi = pair<int, int>;\n\nconst dbl eps = 1e-15;\n#define lt(a, b) ((a)-(b) < -eps)\n#define eq(a, b) (fabs((a)-(b)) < eps)\n\nint W, H;\nchar mas[505][505];\nPi S, G;\nvector<Pi> Bs;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nvector<vector<dbl> > bfs(const vector<Pi>& s) {\n  //cout<<\"!!!!!\"<<endl;\n  queue<Pi> que;\n  vector<vector<dbl> > dist(H, vector<dbl>(W, -1));\n  for(Pi p : s) {\n    que.emplace(p);\n    dist[p.first][p.second] = 0;\n  }\n  while(!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front(); que.pop();\n    //cout<<mas[y][x]<<\" \"<<y<<\" \"<<x<<endl;    \n    for(int i = 0; i < 4; ++i) {\n      int ny = y+dy[i], nx = x+dx[i];\n      if(!in(ny, nx) || mas[ny][nx] == '#' || mas[ny][nx] == '*') continue;\n      if(dist[ny][nx] == -1) {\n\tdist[ny][nx] = dist[y][x]+1;\n\tque.emplace(ny, nx);\n      }\n    }\n  }\n  return dist;\n}\n\nvector<vector<dbl> > db;\nvector<vector<dbl> > dg;\n\nbool check(dbl mb) {\n  dbl sum = 0;\n  int num = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.') {\n\tif(dg[i][j] == -1 && db[i][j] == -1) continue;//assert(false);\n\telse if(dg[i][j] == -1) sum += db[i][j]+mb;\n\telse if(db[i][j] == -1) sum += dg[i][j];\n\telse sum += min(dg[i][j], db[i][j]+mb);\n\t++num;\n      }\n    }\n  }\n  assert(num > 0);\n  sum /= num;\n  return sum >= mb;\n}\n\nint main() {\n  cin >> W >> H;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 's') S = Pi(i, j), mas[i][j] = '.';\n      else if(mas[i][j] == 'g') G = Pi(i, j);\n      else if(mas[i][j] == '*') Bs.emplace_back(i, j);\n    }\n  }\n\n  db = bfs(Bs);\n  dg = bfs({G});\n\n  dbl ans = dg[S.first][S.second];\n  //cout<<ans<<endl;\n  /*\n  bool flag = false;  \n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(mas[i][j] == '.' && dg[i][j] == -1 && db[i][j] == -1) flag = true;\n    }\n  }\n  */\n  if(ans == -1) ans = DBL_MAX/2;\n  else if(db[S.first][S.second] == -1) {\n  //else if(flag) {\n    cout << fixed << setprecision(12) << ans << endl;\n    return 0;\n  }\n\n  dbl lb = 0, ub = 1e20;\n  for(int i = 0; i < 200; ++i) {\n    dbl mb = (lb+ub)/2;\n    if(check(mb)) lb = mb;\n    else ub = mb;\n  }\n\n  ans = min(ans, db[S.first][S.second]+lb);\n\n  cout << fixed << setprecision(12) << ans << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < w; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e9;\n    while (r - l > 1e-12) {\n//        printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                assert(dist2b[y][x] != INT_INF);\n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n//        printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\nconst int INFLL=1001001001001001001ll;\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint dy[4]={-1,0,1,0};\nint dx[4]={0,-1,0,1};\n\nint H,W;\nchar fld[555][555];\ndouble E[555][555];\nbool check(double e){\n    queue<pint>que;\n    fill_n(*E,555*555,1e12);\n    rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n        E[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(true){\n        if(que.size()==0){\n            if(flag)break;\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n            continue;\n        }\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n\n        if(E[y][x]+1>=e&&!flag){\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n        }\n\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||fld[ny][nx]=='*')continue;\n\n            if(E[ny][nx]!=1e12)continue;\n            E[ny][nx]=E[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    double sum=0;\n    int cnt=0;\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='#'||fld[i][j]=='*'||fld[i][j]=='g')continue;\n        cnt++;sum+=E[i][j];\n    }\n\n    return sum<=e*cnt;\n}\n\n\nsigned main(){\n    cin>>W>>H;\n    rep(i,H)cin>>fld[i];\n\n    vector<vint>dist(H,vint(W,INT_MAX));\n    queue<pint>que;\n    rep(i,H)rep(j,W)if(fld[i][j]=='s'){\n        dist[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||dist[ny][nx]!=INT_MAX)continue;\n            if(fld[ny][nx]=='*')flag=true;\n            dist[ny][nx]=dist[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    if(!flag){\n        rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n            printf(\"%.20f\\n\",(double)dist[i][j]);\n            return 0;\n        }\n    }\n\n    double lb=0,ub=1e9;\n    rep(i,100){\n        double mid=(ub+lb)/2;\n        if(check(mid))ub=mid;\n        else lb=mid;\n    }\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='s'){\n            printf(\"%.20f\\n\",E[i][j]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ld MAX = 10000000000000;\nconst ld EPS = 0.0000000001;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int w,h;\n\tstatic char c[502][502];\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h){\n\t\tscanf(\"\\n\");\n\t\trep(j,w){\n\t\t\tscanf(\"%c\",&c[i][j]);\n\t\t}\n\t}\n\t\n\tstatic ld a[502][502];\n\tstatic bool used[502][502];\n\tstatic queue<pair<ld,P>> que;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 'g'){\n\t\t\ta[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse a[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(a[nx][ny] > a[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\ta[nx][ny] = a[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(a[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tstatic ld b[502][502];\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == '*'){\n\t\t\tb[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse b[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(b[nx][ny] > b[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\tb[nx][ny] = b[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(b[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tbool t = false;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's' && b[i][j] == MAX)t = true;\n\t}\n\trep(i,h)rep(j,w){\n\t\tif(a[i][j] == MAX && b[i][j] == MAX)c[i][j] = '#';\n\t\tif(t && a[i][j] == MAX)c[i][j] = '#';\n\t}\n\t\n\tld l = 0.0 , r = MAX;\n\twhile(l+EPS < r){\n\t\tld m = (l+r)/2;\n\t\tld sum = 0.0 , cnt = 0.0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(c[i][j] == '#' || c[i][j] == '*' || c[i][j] == 'g')continue;\n\t\t\tsum += min ( a[i][j] , m+b[i][j] );\n\t\t\tcnt += 1.0;\n\t\t}\n\t\t//cout << l << \" \" << r << \":\" << endl;\n\t\t//cout << \"m = \" << m << endl;\n\t\t//cout << \"sum = \" << sum << \",cnt = \" << cnt << endl;\n\t\tif(m*cnt > sum)r = m;\n\t\telse l = m;\n\t}\n\t\n\t/*rep(i,h){\n\t\trep(j,w){\n\t\t\tif(a[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)a[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(b[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)b[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tcout.precision(20);\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's'){\n\t\t\tcout << min ( a[i][j] , l+b[i][j] ) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double INF = 1e+12;\nconst int H = 500;\nconst int W = 500;\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,-1,0,1};\n\nstruct P{\n  int x, y;\n  P(int x=0, int y=0):x(x),y(y){}\n};\n\nstruct state{\n  P p;\n  int cnt;\n  state(P p=P(), int cnt=0):p(p),cnt(cnt){}\n};\n\n\nint w, h, dis_go[H][W], dis_sp[H][W];\ndouble cnt_wall;\nP st, go;\nvector<P> v;\nbool wall[H][W];\n\nvoid init_dis(){\n  queue<state> q;\n  state u, u2;\n\n  cnt_wall = 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      dis_go[i][j] = dis_sp[i][j] = -1;\n      cnt_wall += !wall[i][j];\n    }\n  }\n\n  for(q.push(state(go, 0));!q.empty();){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      u2 = state(P(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n      if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n        dis_go[u2.p.y][u2.p.x] = u2.cnt;\n        q.push(u2);\n      }\n    }\n  }\n\n  for(int i=0;i<v.size();i++){\n    for(q.push(state(v[i], 0));!q.empty();){\n      u = q.front();\n      q.pop();\n      for(int j=0;j<4;j++){\n        u2 = state(P(u.p.x+dx[j], u.p.y+dy[j]), u.cnt+1);\n        if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n          dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n}\n\ndouble calc_exp(int base){\n  double a = 1.0, b = 0.0, exp_go = 0.0;\n  \n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      if(!wall[i][j]){\n        if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n          a -= 1.0 / cnt_wall;\n          b += (double)dis_sp[i][j] / cnt_wall;\n        } else {\n          exp_go += (double)dis_go[i][j] / cnt_wall;\n        }\n      }\n    }\n  }\n\n  return (b + exp_go) / a;\n}\n\ndouble solve(){\n  double ans = INF;\n\n  init_dis();\n\n  if(dis_go[st.y][st.x] != -1) ans = dis_go[st.y][st.x];\n  //cout << ans << ' ';\n\n  // TLE??????????????¢?´¢\n  for(int i=2;i<(h-2)*(w-2);i++){\n    if(dis_sp[st.y][st.x] == -1 || dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i){\n      break;\n    }    \n    ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n  }\n\n  return ans;\n}\n\nint main(){\n  char c;\n  while(cin >> w >> h){\n    v.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> c;\n        wall[i][j] = true;\n        if(c == 's') st = P(j, i), wall[i][j] = false;\n        else if(c == 'g') go = P(j, i);\n        else if(c == '*') v.push_back(P(j, i));\n        else if(c == '.') wall[i][j] = false;\n      }\n    }    \n    printf(\"%.12f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ld MAX = 10000000000000;\nconst ld EPS = 0.0000000001;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int w,h;\n\tstatic char c[502][502];\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h){\n\t\tscanf(\"\\n\");\n\t\trep(j,w){\n\t\t\tscanf(\"%c\",&c[i][j]);\n\t\t}\n\t}\n\t\n\tstatic ld a[502][502];\n\tstatic bool used[502][502];\n\tstatic queue<pair<ld,P>> que;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 'g'){\n\t\t\ta[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse a[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(a[nx][ny] > a[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\ta[nx][ny] = a[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(a[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tstatic ld b[502][502];\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == '*'){\n\t\t\tb[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse b[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(b[nx][ny] > b[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\tb[nx][ny] = b[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(b[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tbool t = false;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's' && b[i][j] == MAX)t = true;\n\t}\n\trep(i,h)rep(j,w){\n\t\tif(a[i][j] == MAX && b[i][j] == MAX)c[i][j] = '#';\n\t\tif(t && a[i][j] == MAX)c[i][j] = '#';\n\t}\n\t\n\tcout.precision(20);\n\tld l = 0.0 , r = MAX;\n\trep(ppp,200){\n\t\tld m = (l+r)/2;\n\t\tld sum = 0.0 , cnt = 0.0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(c[i][j] == '#' || c[i][j] == '*' || c[i][j] == 'g')continue;\n\t\t\tsum += min ( a[i][j] , m+b[i][j] );\n\t\t\tcnt += 1.0;\n\t\t}\n\t\t//cout << l << \" \" << r << \":\" << endl;\n\t\t//cout << \"m = \" << m << endl;\n\t\t//cout << \"sum = \" << sum << \",cnt = \" << cnt << endl;\n\t\tif(m*cnt > sum)r = m;\n\t\telse l = m;\n\t}\n\t\n\t/*rep(i,h){\n\t\trep(j,w){\n\t\t\tif(a[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)a[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(b[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)b[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tcout.precision(20);\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's'){\n\t\t\tcout << min ( a[i][j] , l+b[i][j] ) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nlong long H, W, sx, sy, gx, gy, dist1[509][509], dist2[509][509]; char c[509][509];\n\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> c[i][j]; dist1[i][j] = (1LL << 60); dist2[i][j] = (1LL << 60);\n\t\t\tif (c[i][j] == 's') { sx = i; sy = j; }\n\t\t\tif (c[i][j] == 'g') { gx = i; gy = j; }\n\t\t}\n\t}\n\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }; queue<pair<int, int>>Q;\n\tdist1[gx][gy] = 0; Q.push(make_pair(gx, gy));\n\n\twhile (!Q.empty()) {\n\t\tpair<int, int>a1 = Q.front(); Q.pop();\n\t\tint cx = a1.first, cy = a1.second;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint px = cx + dx[i], py = cy + dy[i];\n\t\t\tif (c[px][py] == '#' || c[px][py] == '*') continue;\n\t\t\tif (dist1[px][py] > dist1[cx][cy] + 1) {\n\t\t\t\tdist1[px][py] = dist1[cx][cy] + 1;\n\t\t\t\tQ.push(make_pair(px, py));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (c[i][j] == '*') { dist2[i][j] = 0; Q.push(make_pair(i, j)); }\n\t\t}\n\t}\n\tif (Q.empty()) {\n\t\tcout << dist1[sx][sy] << endl;\n\t\treturn 0;\n\t}\n\n\twhile (!Q.empty()) {\n\t\tpair<int, int>a1 = Q.front(); Q.pop();\n\t\tint cx = a1.first, cy = a1.second;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint px = cx + dx[i], py = cy + dy[i];\n\t\t\tif (c[px][py] == '#') continue;\n\t\t\tif (dist2[px][py] > dist2[cx][cy] + 1) {\n\t\t\t\tdist2[px][py] = dist2[cx][cy] + 1;\n\t\t\t\tQ.push(make_pair(px, py));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong double L = 0.0L, R = 1e12, M;\n\tfor (int i = 0; i < 100; i++) {\n\t\tM = (L + R) / 2;\n\t\tint cnt = 0; long double sum = 0;\n\t\tfor (int j = 1; j <= H; j++) {\n\t\t\tfor (int k = 1; k <= W; k++) {\n\t\t\t\tif (c[j][k] == '#' || c[j][k] == '*' || c[j][k] == 'g') continue;\n\t\t\t\tcnt++;\n\t\t\t\tsum += min(M + 1.0L*dist2[j][k], 1.0L*dist1[j][k]);\n\t\t\t}\n\t\t}\n\t\tif ((1.0L*sum / cnt) < M) { R = M; }\n\t\telse { L = M; }\n\t}\n\tprintf(\"%.12Lf\\n\", min(M + 1.0L*dist2[sx][sy], 1.0L * dist1[sx][sy]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=20000000000.0,lower=1.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E+0.01;\n\t\telse lower=E-0.01;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\n#define INF 1e18\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP; \nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fie[510][510];\nint dist[2][510][510];\nint w,h;\nvector<PP> vec;\nint sx,sy,gx,gy;\ntypedef long long ll;\n\nvoid bfs(int y=-1,int x=-1){\n\tqueue<P> que;\n\tint type=0;\n\tif(y==-1)type=1;\n\tmemset(dist[type],-1,sizeof(dist[type]));\n\tif(type==0){\n\t\tdist[type][y][x]=0;\n\t\tque.push(P(y,x));\n\t}else{\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==1){\n\t\t\t\t\tdist[type][i][j]=0;\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(abs(fie[ny][nx])!=1 && dist[type][ny][nx]==-1){\n\t\t\t\tdist[type][ny][nx]=dist[type][p.first][p.second]+1;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll cnt=0;\nll all=0;\nll okave=0;\nll ngave=0;\n\nlong double calc(int v){\n\tif((dist[0][sy][sx]!=-1 && dist[0][sy][sx]<=dist[1][sy][sx]+v) || dist[1][sy][sx]==-1)return dist[0][sy][sx];\n\telse{\n\t\tif(cnt==0)return INF;\n\t\tlong double va=(long double)okave/all;\n\t\tva*=(double)1.0*all/cnt;\n\t\tlong double vb=(long double)ngave/((long double)(all-cnt));\n\t\tvb*=(long double)1.0*all/cnt;\n\t\tvb-=(long double)ngave/((long double)(all-cnt));\n\t\treturn (long double)va+vb+dist[1][sy][sx];\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%*c\",&w,&h);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='#')fie[i][j]=-1;\n\t\t\tif(c=='s')sy=i,sx=j;\n\t\t\tif(c=='g')gy=i,gx=j;\n\t\t\tif(c=='*')fie[i][j]=1;\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tbfs(gy,gx);\n\tbfs();\n\tif(dist[1][sy][sx]==-1 || (dist[0][sy][sx]<=dist[1][sy][sx] && dist[0][sy][sx]!=-1)){\n\t\tprintf(\"%.10f\\n\",(double)dist[0][sy][sx]);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\tall++;\n\t\t\t\tif(dist[0][i][j]!=-1 && dist[1][i][j]!=-1)vec.push_back(PP(dist[0][i][j]-dist[1][i][j],P(i,j)));\n\t\t\t\telse if(dist[0][i][j]==-1)ngave+=dist[1][i][j];\n\t\t\t\telse{\n\t\t\t\t\tokave+=dist[0][i][j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tlong double res=INF;\n\tfor(int i=0;i<vec.size();i++){\n\t\tngave+=dist[1][vec[i].second.first][vec[i].second.second];\n\t}\n\tfor(int i=0;i<=vec.size();i++){\n\t\tres=min(res,calc(vec[i].first));\n\t\tif(i!=vec.size()){\n\t\t\tngave-=dist[1][vec[i].second.first][vec[i].second.second];\n\t\t\tcnt++;\n\t\t\tokave+=dist[0][vec[i].second.first][vec[i].second.second];\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",(double)res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tdouble upper=10000000000.0,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define double long double\n#define INF 1.0e12\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<double, P> Pd;\nint main()\n{\n  int dx[4]={1, -1, 0, 0}, dy[4]={0, 0, 1, -1};\n\tint w, h;\n  cin>>w>>h;\n  double x1=0, x2=1.0e10;\n  string s[500];\n  int sx, sy, gx, gy;\n  for(int i=0; i<h; i++){\n    cin>>s[i];\n    for(int j=0; j<w; j++){\n      if(s[i][j]=='s'){\n        sx=i, sy=j;\n      }else if(s[i][j]=='g'){\n        gx=i, gy=j;\n      }\n    }\n  }\n  for(int l=0; l<100; l++){\n    double xmid=(x1+x2)/2;\n    double d[500][500];\n    priority_queue<Pd, vector<Pd>, greater<Pd> > que;\n    que.push(Pd(0, P(gx, gy)));\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(s[i][j]=='g'){\n          d[i][j]=0;\n        }else if(s[i][j]=='*'){\n          d[i][j]=xmid;\n          que.push(Pd(xmid, P(i, j)));\n        }else{\n          d[i][j]=INF;\n        }\n      }\n    }\n    while(!que.empty()){\n      Pd p=que.top();\n      que.pop();\n      int x=p.second.first, y=p.second.second;\n      if(p.first>d[x][y]) continue;\n      for(int i=0; i<4; i++){\n        if(!(0<=x+dx[i] && x+dx[i]<h && 0<=y+dy[i] && y+dy[i]<w)) continue;\n        if(s[x+dx[i]][y+dy[i]]=='#' || s[x+dx[i]][y+dy[i]]=='*') continue;\n        if(d[x+dx[i]][y+dy[i]]>d[x][y]+1.0){\n          d[x+dx[i]][y+dy[i]]=d[x][y]+1.0;\n          que.push(Pd(d[x+dx[i]][y+dy[i]], P(x+dx[i], y+dy[i])));\n        }\n          \n      }\n    }\n    if(l==99){\n      printf(\"%.10Lf\\n\", d[sx][sy]);\n      return 0;\n    }\n    double sum=0;\n    int ct=0;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(s[i][j]=='.' || s[i][j]=='s'){\n          ct++;\n          sum+=d[i][j];\n        }\n      }\n    }\n    if(sum/(double)ct<xmid){\n      x2=xmid;\n    }else{\n      x1=xmid;\n    }\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <cstdio>\n#include <cmath>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntemplate <class T> bool setmax(T & l, T const & r) { if (not (l < r)) return false; l = r; return true; }\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\nconst int inf = 1e9+7;\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nint main() {\n    // input\n    int w, h; cin >> w >> h;\n    vector<string> c(h); repeat (y,h) cin >> c[y];\n    // modify input\n    int sy, sx, gy, gx;\n    repeat (y,h) repeat (x,w) {\n        if (c[y][x] == 's') {\n            sy = y;\n            sx = x;\n            c[y][x] = '.';\n        } else if (c[y][x] == 'g') {\n            gy = y;\n            gx = x;\n        }\n    }\n    // prepare\n    auto on_field = [&](int y, int x) { return 0 <= y and y < h and 0 <= x and x < w; };\n    typedef queue<pair<int,int> > points_queue;\n    auto bfs = [&](function<void (points_queue &)> init, function<void (points_queue &, int, int, int, int)> update) {\n        points_queue que;\n        init(que);\n        while (not que.empty()) {\n            int y, x; tie(y, x) = que.front(); que.pop();\n            repeat (i,4) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if (not on_field(ny, nx)) continue;\n                if (c[ny][nx] != '.') continue;\n                update(que, y, x, ny, nx);\n            }\n        }\n    };\n    vector<vector<int> > goal(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        goal[gy][gx] = 0;\n        que.push(make_pair(gy, gx));\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (goal[ny][nx] == inf) {\n            goal[ny][nx] = goal[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    vector<vector<int> > jump(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        repeat (y,h) repeat (x,w) if (c[y][x] == '*') {\n            jump[y][x] = 0;\n            que.push(make_pair(y, x));\n        }\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (jump[ny][nx] == inf) {\n            jump[ny][nx] = jump[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    map<pair<int,int>,int> freq; // frequency\n    int total = 0;\n    int max_goal = 0;\n    repeat (y,h) repeat (x,w) if (c[y][x] == '.') {\n        freq[make_pair(goal[y][x], jump[y][x])] += 1;\n        total += 1;\n        if (goal[y][x] < inf) setmax(max_goal, goal[y][x]);\n    }\n    // calc\n    long double e = INFINITY;\n    repeat (estimate, max_goal + 1) {\n        // E = f(E) = aE + b\n        long double a = 0;\n        long double b = 0;\n        for (auto it : freq) {\n            int g, s; tie(g, s) = it.first;\n            int cnt = it.second;\n            long double p = cnt /(long double) total;\n            if (g == inf) {\n                a += p;\n                b += p * s;\n            } else if (s == inf) {\n                b += p * g;\n            } else {\n                if (g <= s + estimate) {\n                    b += p * g;\n                } else {\n                    a += p;\n                    b += p * s;\n                }\n            }\n        }\n        setmin(e, b / (1 - a));\n    }\n    // output\n    long double ans\n        = goal[sy][sx] == inf ? jump[sy][sx] + e\n        : jump[sy][sx] == inf ? goal[sy][sx]\n        : min<long double>(goal[sy][sx], jump[sy][sx] + e); // the answer can become grater than `int inf`, so conditional op. is required.\n    printf(\"%.12Lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\nconst long long LM = (long long)1e17;\nint d[5] = { 0, 1, 0, -1, 0 };\n\nint main() {\n    int w, h, si, sj, gi, gj;\n    cin >> w >> h;\n    vector<string> s(h);\n    queue<pair<int, int>> q;\n    vector<vector<int>> dsp(h, vector<int>(w, M));\n    vector<vector<long long>> dg(h, vector<long long>(w, LM * 2));\n    for (int i = 0; i < h; ++i) {\n        cin >> s[i];\n        for (int j = 0; j < w; ++j) {\n            if (s[i][j] == 's') {\n                si = i;\n                sj = j;\n            }\n            else if (s[i][j] == 'g') {\n                gi = i;\n                gj = j;\n                dg[i][j] = 0;\n            }\n            else if (s[i][j] == '*') {\n                dsp[i][j] = 0;\n                q.push(make_pair(i, j));\n            }\n        }\n    }\n    while (!q.empty()) {\n        pair<int, int> p = q.front();\n        q.pop();\n        int pi = p.first, pj = p.second;\n        for (int i = 0; i < 4; ++i) {\n            int ti = pi + d[i], tj = pj + d[i + 1];\n            if (s[ti][tj] != '#' && dsp[ti][tj] > dsp[pi][pj] + 1) {\n                dsp[ti][tj] = dsp[pi][pj] + 1;\n                q.push(make_pair(ti, tj));\n            }\n        }\n    }\n    q.push(make_pair(gi, gj));\n    while (!q.empty()) {\n        pair<int, int> p = q.front();\n        q.pop();\n        int pi = p.first, pj = p.second;\n        for (int i = 0; i < 4; ++i) {\n            int ti = pi + d[i], tj = pj + d[i + 1];\n            if (s[ti][tj] != '#' && s[ti][tj] != '*' && dg[ti][tj] > dg[pi][pj] + 1) {\n                dg[ti][tj] = dg[pi][pj] + 1;\n                q.push(make_pair(ti, tj));\n            }\n        }\n    }\n    long long l = 0, r = LM;\n    double k = -1;\n    while (l <= r) {\n        long long m = (l + r) / 2;\n        int c = 0;\n        long long dist = 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                if (s[i][j] == 's' || s[i][j] == '.') {\n                    ++c;\n                    if (dg[i][j] > dsp[i][j] + m) {\n                        --c;\n                        dist += dsp[i][j];\n                    }\n                    else {\n                        dist += dg[i][j];\n                    }\n                }\n            }\n        }\n        k = dist / (double)c;\n        if (m - 1e-9 < k && k < m + 1) {\n            break;\n        }\n        else if (m < k) {\n            l = m + 1;\n        }\n        else {\n            r = m - 1;\n        }\n    }\n    printf(\"%.12lf\\n\", min((double)dg[si][sj], dsp[si][sj] + k));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 15000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16500; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<long long int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(9999999999);\n\t\t\tgot[i].emplace_back(9999999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1e11;\n\tbool ok = true;\n\twhile (amin + 1e-10 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tif (got[y][x] == 9999999999 && spt[y][x] == 9999999999) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<long double>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans;\n\tif (ok) {\n\t\tans = min(static_cast<long double>(got[sy][sx]), spt[sy][sx] + amin);\n\n\t}\n\telse {\n\t\tans = static_cast<long double>(got[sy][sx]);\n\t}\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n \nll INF = LLONG_MAX / 2;\n \nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n \nint main() {\n    int H, W; cin >> W >> H;\n    vector<string> a(H);\n    for (int y = 0; y < H; y++)\n        cin >> a[y];\n    int ys, xs, yg, xg;\n    for (int y = 0; y < H; y++)\n        for (int x = 0; x < W; x++) {\n            if (a[y][x] == 's') {\n                a[y][x] = '.';\n                ys = y;\n                xs = x;\n            }\n            if (a[y][x] == 'g') {\n                yg = y;\n                xg = x;\n            }\n        }\n    vector<vector<ll> > dg(H, vector<ll>(W, INF));\n    queue<i_i> q;\n    dg[yg][xg] = 0;\n    q.push(i_i(yg, xg));\n    while (q.size()) {\n        i_i p = q.front(); q.pop();\n        int y = p.first, x = p.second;\n        for (int k = 0; k < 4; k++) {\n            int _y = y + dy[k], _x = x + dx[k];\n            if (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n                dg[_y][_x] = dg[y][x] + 1;\n                q.push(i_i(_y, _x));\n            }\n        }\n    }\n    vector<vector<ll> > ds(H, vector<ll>(W, INF));\n    for (int y = 0; y < H; y++)\n        for (int x = 0; x < W; x++)\n            if (a[y][x] == '*') {\n                ds[y][x] = 0;\n                q.push(i_i(y, x));\n            }\n    while (q.size()) {\n        i_i p = q.front(); q.pop();\n        int y = p.first, x = p.second;\n        for (int k = 0; k < 4; k++) {\n            int _y = y + dy[k], _x = x + dx[k];\n            if (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n                ds[_y][_x] = ds[y][x] + 1;\n                q.push(i_i(_y, _x));\n            }\n        }\n    }\n    long double lb = 0, ub = 1e15;\n    for (int t = 0; t < 100; t++) {\n        long double mid = (lb + ub) / 2;\n        int k = 0;\n        long double sum = 0;\n        for (int y = 0; y < H; y++)\n            for (int x = 0; x < W; x++)\n                if (a[y][x] == '.') {\n                    k++;\n                    sum += min((long double)dg[y][x], ds[y][x] + mid);\n                }\n        if (sum / k > mid) lb = mid;\n        else ub = mid;\n    }\n\tdouble ans = min((long double)dg[ys][xs], ds[ys][xs] + lb);\n    printf(\"%.15f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e15), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 100; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j]/n;\n\t}\n      }\n    }\n    if(s < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\n#define int long long\n\nchar c[523][523];\n\ntemplate<class A>\nvoid bfs(A &ds,queue<tuple<int,int,int> > que){\n  fill(*begin(ds),*end(ds),1e9);\n  while(!que.empty()){\n    auto cs=que.front();\n    que.pop();\n    int t=get<0>(cs);\n    int y=get<1>(cs);\n    int x=get<2>(cs);\n    if(ds[y][x]<=t)continue;\n    ds[y][x]=t;\n    for(int i=0;i<4;i++){\n      static const int d[]={0,1,0,-1,0};\n      int ny=y+d[i];\n      int nx=x+d[i+1];\n      if(c[ny][nx]=='.'){\n\tque.push(make_tuple(t+1,ny,nx));\n      }\n    }\n  }\n}\n\nsigned main(){\n  int W,H;\n  cin>>W>>H;\n  queue<tuple<int,int,int> > sque,gque;\n  int sy,sx;\n  int n=0;\n  for(int i=0;i<H;i++){\n    cin>>c[i];\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='s'){\n\tc[i][j]='.';\n\tsy=i;\n\tsx=j;\n      }else if(c[i][j]=='*'){\n\tsque.push(make_tuple(0,i,j));\n      }else if(c[i][j]=='g'){\n\tgque.push(make_tuple(0,i,j));\n      }\n      n+=c[i][j]=='.';\n    }\n  }\n  static int ds[523][523];\n  bfs(ds,sque);\n  static int dg[523][523];\n  bfs(dg,gque);\n  int gsum=0,ssum=0;\n  int xsum=0;\n  int gs[2555]={},ss[2555]={};\n  int xs[2555]={};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='.'){\n\tint cx=min<int> (2500,max<int>(0,dg[i][j]-ds[i][j]));\n\tgsum+=dg[i][j];\n\tgs[cx]+=dg[i][j];\n\tss[cx]+=ds[i][j];\n\txs[cx]++;\n      }\n    }\n  }\n  double ans=1e18;\n  for(int i=2500;i>=0;i--){\n    gsum-=gs[i];\n    ssum+=ss[i];\n    xsum+=xs[i];\n    if(xsum==n)continue;\n    ans=min(ans,(dg[sy][sx]-ds[sy][sx]>=i)?ds[sy][sx]+(gsum+ssum)*1./(n-xsum):dg[sy][sx]);\n  }\n  cout.precision(99);\n  cout<<fixed<<ans<<endl;\n}\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=5e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a-1==0)break;\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nvs field;\nint w, h;\n\n//((cost, (y, x)) \ntypedef pair<int, pii> State;\n\n#define F first\n#define S second\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nvoid bfs(char tar, vvi & minDist){\n    minDist = vvi(h, vi(w, inf));\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    rep(y, h){\n        rep(x, w){\n            if(field[y][x] != tar) continue;\n            q.push(mp(0, mp(y, x)));\n        }\n    }\n\n    while(!q.empty()){\n        int cur_cost = q.top().F;\n        pii cur_pos = q.top().S;\n        q.pop();\n\n        if(minDist[cur_pos.F][cur_pos.S] != inf) continue;\n\n        if(field[cur_pos.F][cur_pos.S] == '.'){\n            minDist[cur_pos.F][cur_pos.S] = cur_cost;\n        }\n\n        int next_cost = cur_cost + 1;\n        rep(i, 4){\n            pii next_pos = mp(cur_pos.F + dy[i], cur_pos.S + dx[i]);\n\n            if(field[next_pos.F][next_pos.S] == '#' ||\n               field[next_pos.F][next_pos.S] == 'g' ||\n               field[next_pos.F][next_pos.S] == '*' ||\n               minDist[next_pos.F][next_pos.S] != inf)\n                continue;\n            \n            q.push(mp(next_cost, next_pos));\n        }\n    }\n}\n\nint main(void){\n    for(; cin >> w >> h;){\n        field = vs(h);\n        pii s;\n        int num_f = 0;\n        rep(y, h){\n            cin >> field[y];\n            \n            rep(x, w){\n                if(field[y][x] == 's'){\n                    s = mp(y, x);\n                    field[y][x] = '.';\n                }\n                if(field[y][x] == '.'){\n                    num_f++;\n                }\n            }\n        }\n\n        vvi minDist_s, minDist_g;\n        bfs('*', minDist_s);\n        bfs('g', minDist_g);\n\n//        rep(y, h){\n//            rep(x, w){\n//                printf(\"%4d\", (minDist_s[y][x] == inf ? -1:minDist_s[y][x]));\n//            }\n//            cout << endl;\n//        }\n//        cout << endl;\n//        rep(y, h){\n//            rep(x, w){\n//                printf(\"%4d\", (minDist_g[y][x] == inf ? -1:minDist_g[y][x]));\n//            }\n//            cout << endl;\n//        }\n//        cout << \"----------\" <<endl;\n        \n        vector<pair<int, pii>> deltaSG;\n        int sum_dist = 0, num_tos = 0;\n        rep(y, h){\n            rep(x, w){\n                if(field[y][x] != '.') continue;\n\n                if(minDist_g[y][x] != inf){\n                    sum_dist += minDist_g[y][x];\n\n                    if(minDist_s[y][x] != inf){\n                        deltaSG.pb(mp(minDist_g[y][x] - minDist_s[y][x], mp(y, x)));\n                    }\n                }\n                else{\n                    sum_dist += minDist_s[y][x];\n                    num_tos++;\n                }\n            }\n        }\n        sort(all(deltaSG), greater<pair<int, pii>>());\n        \n#define F first\n#define S second\n\n        double e = 1.0 / (num_f - num_tos) * sum_dist;\n        for(auto state : deltaSG){\n            pii pos = state.S;\n\n            num_tos++;\n            sum_dist = sum_dist - minDist_g[pos.F][pos.S] + minDist_s[pos.F][pos.S];\n            double cur = 1.0 / (num_f - num_tos) * sum_dist;\n\n            if(cur < e) e = cur;\n            else break;\n        }\n\n        double res = min((double)minDist_g[s.F][s.S], minDist_s[s.F][s.S] + e);\n        printf(\"%.12f\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,57){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=1e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(n-a-1==0)break;\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint W, H;\nchar board[510][510];\nlong double dp[510][510];\n\nvoid calc(long double bin_v) {\n    fill(dp[0], dp[H+1], INF);\n    queue< tuple<int, int, long double> > que;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            if(board[i][j] == 'g') {\n                dp[i][j] = 0.0;\n                que.emplace(i, j, dp[i][j]);\n            }\n            if(board[i][j] == '*') {\n                dp[i][j] = bin_v;\n                que.emplace(i, j, dp[i][j]);\n            }\n        }\n    }\n\n    while(que.size()) {\n        int x, y; long double val;\n        tie(x, y, val) = que.front(); que.pop();\n\n        for(int k=0; k<4; k++) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if(board[nx][ny] == '#') continue;\n            if(board[nx][ny] == '*') continue;\n            if(dp[nx][ny] > val + 1) {\n                dp[nx][ny] = val + 1;\n                que.emplace(nx, ny, val + 1);\n            }\n        }\n    }\n}\n\n\nsigned main() {\n    cin >> W >> H;\n    int sx, sy, gx, gy, cnt = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            cin >> board[i][j];\n            if(board[i][j] == 's') sx = i, sy = j;\n            if(board[i][j] == 'g') gx = i, gy = j;\n\n            if(board[i][j] == 's' or board[i][j] == '.') {\n                cnt++;\n            }\n        }\n    }\n\n    // fprintf(stderr, \"cnt = %lld\\n\", cnt);\n    long double ub = INF, lb = 0;\n    for(int r=0; r<200; r++) {\n        long double x = (ub + lb) / 2.0;\n        calc(x);\n        \n        long double E = 0.0;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                if(board[i][j] == '.' or board[i][j] == 's') {\n                    E += dp[i][j];\n                }\n            }\n        }\n        E /= cnt;\n        if(E < x) ub = x;\n        else lb = x;\n    }\n\n    long double x = ub;\n    calc(x);\n    // fprintf(stderr, \"x = %.12f\\n\", x);\n    printf(\"%.12Lf\\n\", dp[sx][sy]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=W*H;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=W*H;\n\tfor(int stage=0;stage<100;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=W*H;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int W, H;\n    vector<string> F;\n    void input() {\n        cin >> W >> H;\n        F.clear(); F.resize(H);\n        cin >> F;\n    }\n\n    const real INF = 1e200;\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {-1, 0, 1, 0};\n\n    vector< vector<real> > C; // from the stairs\n    vector< vector<real> > S; // from the nearest spring;\n\n    void bfs(int sy, int sx, vector< vector<real> >& M) {\n        assert(M.size() == H && M[0].size() == W);\n        queue< pair<int, int> > Q;\n        Q.push(make_pair(sy, sx));\n        M[sy][sx] = 0;\n        while (not Q.empty()) {\n            auto cur = Q.front(); Q.pop();\n            int cy = cur.first, cx = cur.second;\n            for (int i = 0; i < 4; i++) {\n                int ny = cy + dy[i],\n                    nx = cx + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (F[ny][nx] == '*') continue;\n                int ncost = M[cy][cx] + 1;\n                if (M[ny][nx] > ncost) {\n                    M[ny][nx] = ncost;\n                    Q.push(make_pair(ny, nx));\n                }\n            }\n        }\n    }\n\n    int N;\n    int X, Y;\n    void init() {\n        N = 0;\n        C = vector< vector<real> >(H, vector<real>(W, INF));\n        S = vector< vector<real> >(H, vector<real>(W, INF));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'g') {\n                    bfs(i, j, C);\n                } else if (F[i][j] == '*') {\n                    bfs(i, j, S);\n                } else if (F[i][j] == 's' || F[i][j] == '.') {\n                    if (F[i][j] == 's') {\n                        Y = i;\n                        X = j;\n                    }\n                    N++;\n                } else {\n                    assert(F[i][j] == '#');\n                }\n            }\n        }\n    }\n\n    real f(real x) {\n        real ret = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '.' || F[i][j] == 's') {\n                    ret += min(S[i][j] + x, C[i][j]);\n                }\n            }\n        }\n        return ret / N;\n    }\n\n    real g(real x) {\n        return x - f(x);\n    }\n\n    void solve() {\n        init();\n        real lb = 0, ub = INF;\n        for (int i = 0; i < 1000; i++) {\n            //if (i % 100 == 0) cerr << i << endl;\n            real mid = (lb + ub) / 2;\n            (g(mid) < 0 ? lb : ub) = mid;\n        }\n        real x = lb;\n        //cerr << \"x: \" << x << endl;\n        //cerr << S[Y][X] << endl;\n        cout << fixed << setprecision(12) << min(C[Y][X], S[Y][X] + x) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<one, vector<one>, greater<one>>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16500; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<int> > dg(H, vector<int>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (_y >= 0 && _y < H && _x >= 0 && _x < W && a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ds(H, vector<int>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (_y >= 0 && _y < H && _x >= 0 && _x < W && a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e18;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tlong long x,y;\n\tC(long long x,long long y):x(x),y(y){}\n};\nconst long long dx[]={1,0,-1,0};\nconst long long dy[]={0,1,0,-1};\n\nlong long w,h;\n\nbool in(long long x,long long y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(long long i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(long long j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=8000000000;\n\t\t\tdist_goal[i][j]=8000000000;\n\t\t\tdist_spring[i][j]=8000000000;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst long long NUM=4000;\n\tfor(long long t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e10), l = 0.0, r = INF, exp_[H][W], exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  queue< pair<int,int> > que;\n  que.push(make_pair(gx,gy));\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      exp_[i][j] = INF;\n      exp[i][j] = INF;\n    }\n  }\n\n  exp_[gx][gy] = 0.0;\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k){\n      int x_ = x + d[k], y_ = y + d[(k+1)%4];\n      if(x_ >= H || x_ < 0 || y_ >= W || y_ < 0) continue;\n      char c = M[x_][y_];\n      if(c == '.' && exp_[x_][y_] > exp_[x][y]+1){\n\texp_[x_][y_] = exp_[x][y]+1;\n\tque.push(make_pair(x_,y_));\n      }\n    }\n  }\n  /*\n  long double dist_from_spring[H][W];\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      dist_from_spring[i][j] = INF;\n    }\n  }\n  */\n  vector< vector<long double> > dist_from_spring(H, vector<long double>(W, INF));\n  for(int i = 0; i < springs.size(); ++i){\n    queue< pair<int,int> > que2;\n    que2.push(make_pair(springs[i].first, springs[i].second));\n    dist_from_spring[springs[i].first][springs[i].second] = 0;\n    while(!que2.empty()){\n      int x = que2.front().first, y = que2.front().second;\n      que2.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ >= H || x_ < 0 || y_ >= W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && (dist_from_spring[x_][y_] > dist_from_spring[x][y]+1)){\n\t  que2.push(make_pair(x_,y_));\n\t  dist_from_spring[x_][y_] = dist_from_spring[x][y]+1;\n\t}\n      }\n    }\n  }\n \n  for(int t = 0; t < 100; ++t){\n    long double mean = (l+r)/2.0;\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  exp[i][j] = min(exp_[i][j], dist_from_spring[i][j]+mean);\n\t  s += exp[i][j];\n\t}\n      }\n    }\n\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#define DINF (1e14);\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.5)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.5)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0;\n\t\n\twhile((l-r)/((l+r)/2)>1e-12){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = (l+r)/2;\n\t\tdouble ce=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tce+=cmin(y,x,m);\n\t\t}\n\t\tce/=dotnum;\n\t\tif(ce>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<int> > dg(H, vector<int>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ds(H, vector<int>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 10000000LL;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#define DINF (1e12);\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.5)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.5)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0;\n\t\n\twhile((l-r)/(l/2+r/2)>1e-11){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = l/2+r/2;\n\t\tdouble ce=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tce+=cmin(y,x,m)/dotnum;\n\t\t}\n\t\tif(ce>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst double INF = 1e18;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(double dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1.0 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    double dist_goal[500][500], dist_spring[500][500];\n    REP(y, H) REP(x, W) dist_goal[y][x] = dist_spring[y][x] = -1.0;\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e18;\n    REP(_, 100){\n      const long double sum = (ub + lb) * 0.5;\n      long double S = 0;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        long double exp = min((long double)dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S += exp;\n      }\n      if(sum - S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = lb / N;\n    printf(\"%.12f\\n\", min((double)dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF (1<<25)\nint W,H;\nchar fie[502][502];\nint bfs[502][502];\nint sps[502][502];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct P{\n  int x,y,c;\n  P(int x,int y,int c) : x(x),y(y),c(c) {}\n};\nvector<P> p;\nvector<P> s;\nvoid BFS(int x,int y){\n  queue<P> q;\n  q.push(P(x,y,0));\n  bfs[x][y]=0;\n  while(!q.empty()){\n    P p = q.front(); q.pop();\n    x = p.x;\n    y = p.y;\n    int c = p.c;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='#' || fie[nx][ny]=='*') continue;\n      if(bfs[nx][ny]<=c+1) continue;\n      bfs[nx][ny]=c+1;\n      q.push(P(nx,ny,c+1));\n    }\n  }\n  for(int i=0;i<(int)p.size();i++)\n    if(bfs[p[i].x][p[i].y]!=INF) p[i].c = bfs[p[i].x][p[i].y];\n}\n\nvoid BFS2(int x,int y){\n  queue<P> q;\n  q.push(P(x,y,0));\n  sps[x][y]=0;\n  while(!q.empty()){\n    P p = q.front(); q.pop();\n    x = p.x;\n    y = p.y;\n    int c = p.c;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if(nx < 0 || ny < 0 || nx>=W || ny>=H) continue;\n      if(fie[nx][ny]=='#' || fie[nx][ny]=='*') continue;\n      if(sps[nx][ny]<=c+1) continue;\n      sps[nx][ny]=c+1;\n      q.push(P(nx,ny,c+1));\n    }\n  }\n}\ndouble gosaume(){\n  double ret = 0.0f;\n  for(int i=0;i<(int)p.size();i++)\n    ret += (double)p[i].c;\n  ret/=(double)p.size();\n  \n  return ret;\n}\n/*\ndouble dp[501][501];\ndouble dpg[50];\nint used[501][501];\nint useg[50];\ndouble max_d=0.0f;\ndouble solve(int x,int y,int jc){\n  if(jc>=48){\n    //    used[x][y]=1;\n    if(bfs[x][y]==-1) return dp[x][y]=(double)INF;\n    return dp[x][y]=(double)bfs[x][y];\n  }\n  if(jc<10 && used[x][y]) return dp[x][y];\n  double ret = 0.0f;\n  if(sps[x][y]==-1 || sps[x][y]>=bfs[x][y] || max_d >= bfs[x][y]) return dp[x][y]=(double)bfs[x][y];\n  for(int i=0;i<(int)p.size();i++){\n    ret += (solve(p[i].x,p[i].y,jc+1)+(double)sps[x][y]);\n  }\n  ret = min((double)(bfs[x][y]>0?bfs[x][y]:INF),ret/(double)p.size());\n  //  printf(\"st :: %d %d %d ,  %lf %lf\\n\",x,y,jc,ret,(double)bfs[x][y]); \n  used[x][y]=1;\n  return dp[x][y]=ret;\n  }*/\ndouble dp[2][250000];\ndouble solve(){\n  double max_d=0.0f;\n  int co=0;\n  for(int i=0;i<(int)p.size();i++){\n    if(p[i].c!=INF){\n      max_d += (double)p[i].c; co++;\n    }\n  }\n  max_d/=(double)co;\n\n  //  printf(\"%lf\\n\",max_d);\n\n  for(int id = 0; id < (int)p.size(); id++)\n    dp[0][id] = min((double)bfs[p[id].x][p[id].y],max_d);\n  \n  for(int i=50;i>1;i--){\n    int now = i&1;\n    int next = (now+1)&1;\n\n    max_d = 0.0f;\n    for(int id = 0; id < (int)p.size(); id++){\n      // printf(\"before::dp[%d][%d] = %lf\\n\",i,id,dp[now][id]);\n      max_d += dp[now][id];\n      dp[next][id]=0.0f;\n    }\n    \n    //    printf(\"%lf\\n\",max_d);\n\n    for(int id = 0; id < (int)p.size(); id++){\n      int x = p[id].x, y = p[id].y;\n      double tmp_max = max_d+(double)p.size()*(double)sps[x][y];\n      tmp_max/=(double)p.size();\n      //      printf(\"dp[%d][%d] => %lf  VS  %d\\n\",i,id,tmp_max,bfs[x][y]);\n      if(sps[x][y]==INF){\n\tdp[next][id] += (double)bfs[x][y];\n      } else if(bfs[x][y]==INF){\n\tdp[next][id] += tmp_max;\n      } else{\n\tdp[next][id] += min((double)bfs[x][y],tmp_max);\n      }\n      //      printf(\"after::dp[%d][%d] => %lf\\n\",i-1,id,dp[next][id]);\n    }\n  }\n}\nint main(){\n  int gx,gy;\n  int sx,sy;\n  int ID;\n  cin >> W >> H;\n  for(int i=0;i<501;i++){\n    for(int j=0;j<501;j++){\n      bfs[j][i]=INF;\n      sps[j][i]=INF;\n    }\n  }\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i];\n      if(fie[j][i]=='.' || fie[j][i]=='s') p.push_back(P(j,i,INF));\n      if(fie[j][i]=='s'){ sx = j; sy = i; ID = p.size()-1; }\n      if(fie[j][i]=='g'){ gx = j; gy = i; }\n      if(fie[j][i]=='*') s.push_back(P(j,i,0));\n    }\n  }\n  BFS(gx,gy);\n  for(int i=0;i<(int)s.size();i++) BFS2(s[i].x,s[i].y);\n  solve();\n  printf(\"%.12lf\\n\",dp[0][ID]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[600][600];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\ndouble ijk[600][600];\nint v[600][600];\ndouble eps=1e-12;\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\tijk[i][j]=999999999;\n\tint sr,sc,gr,gc;\n\tqueue<pair<int,int> > Q;\n\tint cnt=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='s'){sr=i;sc=j;}\n\t\t\tif(str[i][j]=='g'){\n\t\t\t\tgr=i;gc=j;\n\t\t\t\tijk[i][j]=0;\n\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'&&str[i][j]!='*'&&str[i][j]!='g')cnt++;\n\twhile(Q.size()){\n\t\tint row=Q.front().first;\n\t\tint col=Q.front().second;Q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk[row+dx[i]][col+dy[i]]>eps+ijk[row][col]+1){\n\t\t\t\tijk[row+dx[i]][col+dy[i]]=ijk[row][col]+1;\n\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\tbool upd=false;\n\tdo{\n\t\tupd=false;\n\t\tdouble val=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'&&str[i][j]!='*'&&str[i][j]!='g')val+=ijk[i][j];\n\t\tval/=cnt;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='*'){\n\t\t\t\tijk[i][j]=val;\n\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk[row+dx[i]][col+dy[i]]>eps+ijk[row][col]+1){\n\t\t\t\t\tupd=true;\n\t\t\t\t\tijk[row+dx[i]][col+dy[i]]=ijk[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t/*\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++)printf(\"%f \",ijk[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}while(upd);\n\tprintf(\"%.12f\\n\",ijk[sr][sc]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tint maxn = 0;\n\trep(i,H) rep(j,W){\n\t\tif(vv1[i][j] != INF) maxn=max(maxn,vv1[i][j]);\n\t\tif(vv2[i][j] != INF) maxn=max(maxn,vv2[i][j]);\n\t}\n\tlong double ans = 1e100;\n\trep(o,maxn+1){\n\t\tlong double a = 0;\n\t\tlong double b = 0;\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(v[i][j] != '.') continue;\n\t\t\t\tif(vv1[i][j]-vv2[i][j] <= o){\n\t\t\t\t\tb += p*vv1[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tb += p*vv2[i][j];\n\t\t\t\t\ta += p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 100000000000000;\n\nint h, w;\nP st, go;\nchar b[500][500];\nll gist[500][500], wist[500][500];\nqueue<P> que;\nint dh[4] = {1,0,-1,0};\nint dw[4] = {0,1,0,-1};\nint flo = 0;\n\nint main(){\n    cin >> w >> h;\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    rep(i,h) rep(j,w){\n        if(b[i][j] == 's'){\n            st.first = i;\n            st.second = j;\n            b[i][j] = '.';\n        }\n        if(b[i][j] == '.'){\n            flo++;\n        }\n        if(b[i][j] == 'g'){\n            go.first = i;\n            go.second  = j;\n            b[i][j] = '.';\n        }\n    }\n    rep(i,h) rep(j,w){\n        gist[i][j] = INF;\n        wist[i][j] = INF;\n    }\n    gist[go.first][go.second] = 0;\n    que.push(go);\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(gist[nh][nw] <= gist[p.first][p.second]+1) continue;\n            gist[nh][nw] = gist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '*'){\n            que.push(P(i,j));\n            wist[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(wist[nh][nw] <= wist[p.first][p.second]+1) continue;\n            wist[nh][nw] = wist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    long double s = 0.0, e = 1000000000000.0, mid;\n    rep(u,1000){\n        mid = (s+e)/2.0;\n        long double sum = 0.0;\n        rep(i,h) rep(j,w){\n            if(b[i][j] == '.' && go != P(i,j)){\n                sum += min((long double)gist[i][j],wist[i][j]+mid);\n            }\n        }\n        sum /= (long double)flo;\n        if(mid > sum){\n            e = mid;\n        } else{\n            s = mid;\n        }\n    }\n    long double ans = min((long double)gist[st.first][st.second],wist[st.first][st.second]+mid);\n    printf(\"%.15Lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#'||s[ny][nx]=='*') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0,c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc+=1.0;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12Lf %.12Lf\\n\",p, p-q);\n    return p-q;\n  };\n\n  Double l=0,r=1e15;\n\n  for(int k=0;k<1000;k++){\n  //while(abs(calc(l))>1e-10){\n    Double m=(l+r)/2;\n    if(calc(m)<=Double(0)) l=m;\n    else r=m;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=5e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double Double;\nconst Double INF = 1e20;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nchar ba[500][500];\nDouble disg[500][500];\nDouble disb[500][500];\nbool visited[500][500];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\nint h,w;\nvoid bfs(Double hoge[500][500], queue<pii> &Q, bool vis[500][500]) {\n  \n  while(!Q.empty()) {\n    pii p = Q.front(); Q.pop();\n    int y = p.first;\n    int x = p.second;\n    REP(k, 4) {\n      int yy = y+dy[k];\n      int xx = x+dx[k];\n      if (yy<0||yy>=h||xx<0||xx>=w) continue;\n      if (ba[yy][xx] != '.') continue;\n      if (vis[yy][xx]) continue;\n      vis[yy][xx] = 1;\n      hoge[yy][xx] = hoge[y][x] + 1;\n      Q.push(pii(yy,xx));\n    }\n  }  \n}\n\n// Cð½·àÌªub¤É èACð½·Å¬lðßéÆ«B\ntemplate<class T> T lower_search(T lb, T ub, bool (*C)(T)) {\n  REP(i, 200) {\n    T mid = (lb+ub)/2;\n    if (C(mid)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint num = 0;\n\nbool C(Double E) {\n  Double hoge = 0;\n  REP(i, h) {\n    REP(j, w) {\n      if (ba[i][j] == '.') {\n        if (disg[i][j] < disb[i][j] + E) {\n          hoge += disg[i][j];\n        } else {\n          hoge += disb[i][j] + E;\n        }\n      }\n    }\n  }\n  hoge /= num;\n  //cout << hoge << \" \"<< E << endl;\n  return  E >= hoge;\n}\n\nint main() {\n  cin >> w >> h;\n  int sx,sy,gx,gy;\n  queue<pii> Q;\n  memset(visited, 0, sizeof(visited));\n  REP(i,h)REP(j,w) disb[i][j] = disg[i][j] = INF;\n  num = 0;\n  REP(i, h) {\n    REP(j, w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == 's') {\n        sx = j; sy = i;\n        ba[i][j] = '.';\n        num++;\n      } else if (ba[i][j] == 'g') {\n        gx = j; gy = i;\n      } else if (ba[i][j] == '*') {\n        Q.push(pii(i,j));\n        visited[i][j] = 1;\n        disb[i][j] = 0;\n      } else if (ba[i][j] == '.') {\n        num++;\n      }\n    }\n  }\n  bfs(disb, Q, visited);\n  \n  memset(visited,0,sizeof(visited));\n  disg[gy][gx] = 0;\n  visited[gy][gx] = 1;\n  Q.push(pii(gy,gx));\n  bfs(disg, Q, visited);\n\n  // REP(i, h) {\n  //   REP(j, w) {\n  //     if (disb[i][j] == INF) cout << \"* \";\n  //     else cout << disb[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  \n  // REP(i, h) {\n  //   REP(j, w) {\n  //     if (disg[i][j] >= INF)cout << \"* \";\n  //     else cout << disg[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  Double E = lower_search<Double>(0, 1e20, C);\n  //cout << E << endl;\n  Double ans = min((Double)disg[sy][sx],disb[sy][sx]+E);\n  printf(\"%.12Lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nint c[500][500];\nld ans=1e9;\nint w,h;\nstring s[500];\nint bn,bs,gn,gs;\n\n\nvoid bfs(){\n  queue<P> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='*')c[i][j]=0,q.push(P(j,i));\n      else c[i][j]=1e9;\n    }\n  while(!q.empty()){\n    int x=q.front().first,y=q.front().second;\n    q.pop();\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0||w<=nx||ny<0||h<=ny||s[ny][nx]=='#'||s[ny][nx]=='g'||s[ny][nx]=='*'||c[ny][nx]!=1e9)continue;\n      c[ny][nx]=c[y][x]+1;\n      q.push(P(nx,ny));\n    }\n  }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(c[i][j]!=1e9&&c[i][j])bn++,bs+=c[i][j];\n}\n\nvoid bfs2(){\n  queue<P> q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='g')c[i][j]=0,q.push(P(j,i));\n      else c[i][j]=1e9;\n    }\n  while(!q.empty()){\n    int x=q.front().first,y=q.front().second;\n    q.pop();\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0||w<=nx||ny<0||h<=ny||c[ny][nx]<1e9||s[ny][nx]=='#'||s[ny][nx]=='*')continue;\n      c[ny][nx]=c[y][x]+1;\n      q.push(P(nx,ny));\n    }\n  }\n\n  for(int i=0;i<h;i++){\n\n    for(int j=0;j<w;j++)\n      if(c[i][j]==1e9)cout<<'#'<<\" \";\n      else cout<<c[i][j]<<\" \";\n    cout<<endl;\n  }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(c[i][j]!=1e9){\n\tgn++,gs+=c[i][j];\n\tif(s[i][j]=='s')ans=c[i][j];\n      }\n}\n\nint main(){\n \n  cin>>w>>h;\n\n  for(int i=0;i<h;i++)cin>>s[i];\n  bfs();\n  bfs2();\n\n  cout<<bn<<\" \"<<bs<< \" \"<<gn<< \" \"<< gs<<\" \"<<endl;\n\n  ld res=0,p=1,a;\n  a=(gn-1)/bn;\n\n  for(int i=0;i<1000;i++)res+=p*a;\n  \n  ans=min(ans,res);  \n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int W, H;\n    vector<string> F;\n    void input() {\n        cin >> W >> H;\n        F.clear(); F.resize(H);\n        cin >> F;\n    }\n\n    const int INF = INT_MAX / 8;\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {-1, 0, 1, 0};\n\n    vector< vector<int> > C; // from the stairs\n    vector< vector<int> > S; // from the nearest spring;\n\n    void bfs(int sy, int sx, vector< vector<int> >& M) {\n        assert(M.size() == H && M[0].size() == W);\n        queue< pair<int, int> > Q;\n        Q.push(make_pair(sy, sx));\n        M[sy][sx] = 0;\n        while (not Q.empty()) {\n            auto cur = Q.front(); Q.pop();\n            int cy = cur.first, cx = cur.second;\n            for (int i = 0; i < 4; i++) {\n                int ny = cy + dy[i],\n                    nx = cx + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (F[ny][nx] == '*') continue;\n                int ncost = M[cy][cx] + 1;\n                if (M[ny][nx] > ncost) {\n                    M[ny][nx] = ncost;\n                    Q.push(make_pair(ny, nx));\n                }\n            }\n        }\n    }\n\n    int N;\n    int X, Y;\n    void init() {\n        N = 0;\n        C = vector< vector<int> >(H, vector<int>(W, INF));\n        S = vector< vector<int> >(H, vector<int>(W, INF));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'g') {\n                    bfs(i, j, C);\n                } else if (F[i][j] == '*') {\n                    bfs(i, j, S);\n                } else if (F[i][j] == 's' || F[i][j] == '.') {\n                    if (F[i][j] == 's') {\n                        Y = i;\n                        X = j;\n                    }\n                    N++;\n                } else {\n                    assert(F[i][j] == '#');\n                }\n            }\n        }\n    }\n\n    real f(real x) {\n        real ret = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '.' || F[i][j] == 's') {\n                    ret += min(real(S[i][j]) + x, real(C[i][j]));\n                }\n            }\n        }\n        return ret / N;\n    }\n\n    real g(real x) {\n        return x - f(x);\n    }\n\n    void solve() {\n        init();\n        real lb = 0, ub = 1e5;\n        for (int i = 0; i < 1000; i++) {\n            real mid = (lb + ub) / 2;\n            (g(mid) < 0 ? lb : ub) = mid;\n        }\n        real x = lb;\n        cout << fixed << setprecision(12) << min(real(C[Y][X]), S[Y][X] + x) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e20, M = 0;\n  rep(i,100){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\n\nint main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = 11451419;\n\t\t\tb[i][j] = 11451419;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = 1e+18;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\tif (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\ndouble ToGoal(int x, int y, double E) {\n  double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//double vs[510 * 510];\ndouble calc(double E) {\n  //double nE = 0.0;\n  int cnt = 0;\n  priority_queue<double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    double l = que.top();\n    que.pop();\n    double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    double left = 0.0;\n    double right = 1e+18;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 164) {\n        double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10f\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n \nint INF = INT_MAX / 2;\n \nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n \nint main() {\n    int H, W; cin >> W >> H;\n    vector<string> a(H);\n    for (int y = 0; y < H; y++)\n        cin >> a[y];\n    int ys, xs, yg, xg;\n    for (int y = 0; y < H; y++)\n        for (int x = 0; x < W; x++) {\n            if (a[y][x] == 's') {\n                a[y][x] = '.';\n                ys = y;\n                xs = x;\n            }\n            if (a[y][x] == 'g') {\n                yg = y;\n                xg = x;\n            }\n        }\n    vector<vector<int> > dg(H, vector<int>(W, INF));\n    queue<i_i> q;\n    dg[yg][xg] = 0;\n    q.push(i_i(yg, xg));\n    while (q.size()) {\n        i_i p = q.front(); q.pop();\n        int y = p.first, x = p.second;\n        for (int k = 0; k < 4; k++) {\n            int _y = y + dy[k], _x = x + dx[k];\n            if (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n                dg[_y][_x] = dg[y][x] + 1;\n                q.push(i_i(_y, _x));\n            }\n        }\n    }\n    vector<vector<int> > ds(H, vector<int>(W, INF));\n    for (int y = 0; y < H; y++)\n        for (int x = 0; x < W; x++)\n            if (a[y][x] == '*') {\n                ds[y][x] = 0;\n                q.push(i_i(y, x));\n            }\n    while (q.size()) {\n        i_i p = q.front(); q.pop();\n        int y = p.first, x = p.second;\n        for (int k = 0; k < 4; k++) {\n            int _y = y + dy[k], _x = x + dx[k];\n            if (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n                ds[_y][_x] = ds[y][x] + 1;\n                q.push(i_i(_y, _x));\n            }\n        }\n    }\n    long double lb = 0, ub = 1e18;\n    for (int t = 0; t < 100; t++) {\n        long double mid = (lb + ub) / 2;\n        int k = 0;\n        long double sum = 0;\n        for (int y = 0; y < H; y++)\n            for (int x = 0; x < W; x++)\n                if (a[y][x] == '.') {\n                    k++;\n                    sum += min((long double)dg[y][x], ds[y][x] + mid);\n                }\n        if (sum / k > mid) lb = mid;\n        else ub = mid;\n    }\n\tdouble ans = min((long double)dg[ys][xs], ds[ys][xs] + lb);\n    printf(\"%.15f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tlong double ans = 1e100;\n\trep(o,H*W){\n\t\tlong double a = 0;\n\t\tlong double b = 0;\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(v[i][j] != '.') continue;\n\t\t\t\tif(vv1[i][j]-vv2[i][j] <= o){\n\t\t\t\t\tb += p*vv1[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tb += p*vv2[i][j];\n\t\t\t\t\ta += p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint w,h,sx,sy,gx,gy,num,inf=1e8;\nstring s[500];\nint dg[500][500],db[500][500],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvoid gbfs(int gx,int gy){\n\trep(i,h) rep(j,w) dg[i][j]=inf;\n\tdg[gx][gy]=0;\n\tqueue<PP> que;\n\tque.push(PP(dg[gx][gy],P(gx,gy)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&dg[nx][ny]==inf){\n\t\t\t\tdg[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(dg[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bbfs(){\n\tqueue<PP> que;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='*') db[i][j]=inf;\n\t\telse que.push(PP(0,P(i,j)));\n\t}\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&db[nx][ny]==inf){\n\t\t\t\tdb[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(db[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(long double x){\n\tlong double sum=0;\n\trep(i,h) rep(j,w) if(s[i][j]!='#'&&s[i][j]!='*') sum+=min(x+db[i][j],(long double)dg[i][j]);\n\treturn sum/num<x;\n}\nint main(){\n\tcin>>w>>h;\n\trep(i,h) cin>>s[i];\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]=='s') sx=i,sy=j,num++;\n\t\tif(s[i][j]=='g') gx=i,gy=j;\n\t\tif(s[i][j]=='.') num++;\n\t}\n\tgbfs(gx,gy);\n\tbbfs();\n\tbool flag=false;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='#'&&dg[i][j]==inf&&db[i][j]==inf) flag=true;\n\t}\n\tif(flag){\n\t\tprintf(\"%d\\n\",dg[sx][sy]);\n\t\treturn 0;\n\t}\n\tlong double ub=300000,lb=0;\n\twhile(ub-lb>1e-12){\n//\t\tcout<<ub<<\" \"<<lb<<endl;\n\t\tlong double mid=(ub+lb)/2;\n\t\tif(check(mid)) ub=mid;\n\t\telse lb=mid;\n\t}\n\tprintf(\"%.12f\\n\",(double)min(ub+db[sx][sy],(long double)dg[sx][sy]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <utility>\n#include <queue>\n#define inf 1e30\n\nusing namespace std;\n\ntypedef pair<int, int> pos;\ntypedef pair<double, pos> P;\n\nint W, H;\nchar map[505][505];\nint sx, sy, gx, gy;\ndouble dist[505][505];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid dijkstra(double m)\n{\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tdist[x][y] = inf;\n\t\t}\n\t}\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tdist[gx][gy] = 0, Q.push( make_pair(0, make_pair(gx, gy)) );\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '*') dist[x][y] = m, Q.push(make_pair(m, make_pair(x, y)));\n\t\t}\n\t}\n\t\n\tint x, y;\n\tdouble d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tx = Q.top().second.first;\n\t\ty = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(dist[x][y] < d) continue;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(nx <= 0 || nx > W || ny <= 0 || ny > H) continue;\n\t\t\tif(map[nx][ny] != '.') continue;\n\t\t\tif(dist[nx][ny] > d + 1){\n\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\tQ.push( make_pair(dist[nx][ny], make_pair(nx, ny)) );\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(double m)\n{\n\tdijkstra(m);\n\tdouble ret = 0; int cnt = 0;\n\tfor(int x = 1; x <= W; x++){\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tif(map[x][y] == '.' && (x != gx || y != gy)){\n\t\t\t\tret += dist[x][y];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tret /= cnt;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> W >> H;\n\tfor(int y = 1; y <= H; y++){\n\t\tfor(int x = 1; x <= W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 's'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tsx = x, sy = y;\n\t\t\t}\n\t\t\tif(map[x][y] == 'g'){\n\t\t\t\tmap[x][y] = '.';\n\t\t\t\tgx = x, gy = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ub = 1e18, lb = 0.0, mid;\n\tfor(int i = 0; i < 300; i++){\n\t\tmid = (ub + lb) * 0.5;\n\t\tif(calc(mid) < mid) ub = mid;\n\t\telse lb = mid;\n\t}\n\tmid = (ub + lb) * 0.5;\n\tcalc(mid);\n\t\n\tprintf(\"%.11f\\n\", dist[sx][sy]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double INF = 1e+12;\nconst int H = 500;\nconst int W = 500;\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,-1,0,1};\n\nstruct P{\n  int x, y;\n  P(int x=0, int y=0):x(x),y(y){}\n};\n\nstruct state{\n  P p;\n  int cnt;\n  state(P p=P(), int cnt=0):p(p),cnt(cnt){}\n};\n\n\nint w, h, dis_go[H][W], dis_sp[H][W];\ndouble cnt_wall;\nP st, go;\nvector<P> v;\nbool wall[H][W];\n\nvoid init_dis(){\n  queue<state> q;\n  state u, u2;\n\n  cnt_wall = 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      dis_go[i][j] = dis_sp[i][j] = -1;\n      cnt_wall += !wall[i][j];\n    }\n  }\n\n  for(q.push(state(go, 0));!q.empty();){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      u2 = state(P(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n      if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n        dis_go[u2.p.y][u2.p.x] = u2.cnt;\n        q.push(u2);\n      }\n    }\n  }\n\n  for(int i=0;i<v.size();i++){\n    for(q.push(state(v[i], 0));!q.empty();){\n      u = q.front();\n      q.pop();\n      for(int j=0;j<4;j++){\n        u2 = state(P(u.p.x+dx[j], u.p.y+dy[j]), u.cnt+1);\n        if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n          dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n}\n\ndouble calc_exp(int base){\n  double a = 1.0, b = 0.0, exp_go = 0.0;\n  \n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      if(!wall[i][j]){\n        if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n          a -= 1.0 / cnt_wall;\n          b += (double)dis_sp[i][j] / cnt_wall;\n        } else {\n          exp_go += (double)dis_go[i][j] / cnt_wall;\n        }\n      }\n    }\n  }\n\n  return (b + exp_go) / a;\n}\n\ndouble solve(){\n  double ans = INF;\n\n  init_dis();\n\n  if(dis_go[st.y][st.x] != -1) ans = dis_go[st.y][st.x];\n\n  /*\n  for(int i=2;i<(h-2)*(w-2);i++){\n    if(dis_sp[st.y][st.x] == -1 || dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i){\n      break;\n    }    \n    ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n    }\n  */\n  if(dis_sp[st.y][st.x] != -1){\n    int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n    double res0, res1, res2;\n    if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n    while(ri - le >= 4){\n      mid1 = (le * 2 + ri) / 3;\n      mid2 = (le + ri * 2) / 3;\n      res0 = calc_exp(le) + dis_sp[st.y][st.x];\n      res1 = calc_exp(mid1) + dis_sp[st.y][st.x];\n      res2 = calc_exp(mid2) + dis_sp[st.y][st.x];\n      if(mid2 - mid1 <= 1) break;\n      if(res0 >= res1 && res1 >= res2) le = mid1;\n      else ri = mid2;\n    }\n    for(int i=le;i<le+4;i++) {\n      if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n      ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  char c;\n  while(cin >> w >> h){\n    v.clear();\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> c;\n        wall[i][j] = true;\n        if(c == 's') st = P(j, i), wall[i][j] = false;\n        else if(c == 'g') go = P(j, i);\n        else if(c == '*') v.push_back(P(j, i));\n        else if(c == '.') wall[i][j] = false;\n      }\n    }    \n    printf(\"%.12f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e8;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\nvector<double> dist;\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, double> is_lower(const double e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, double> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] <= d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tdouble total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\tdouble ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\tdouble lb = 0, ub = 1e20;\n\tdouble ans = 0;\n\tconst int max_step = 200;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=10100;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%02d\\n\",dis[sti][stj]);\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=W*H;\n\tfor(int stage=0;stage<100;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=W*H;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e160, M = 0;\n  rep(i,220){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\ndouble ToGoal(int x, int y, double E) {\n  double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//double vs[510 * 510];\ndouble calc(double E) {\n  //double nE = 0.0;\n  int cnt = 0;\n  priority_queue<double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    double l = que.top();\n    que.pop();\n    double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    double left = 0.0;\n    double right = 1e+18;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 164) {\n        double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10f\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint H,W;\nchar c[555][555];\nint sy,sx,gy,gx;\nint dist1[555][555],dist2[555][555];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H;\n\trep(i,H)rep(j,W){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sy=i,sx=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gy=i,gx=j;\n\t}\n\trep(i,H)rep(j,W){\n\t\tdist1[i][j]=dist2[i][j]=INF;\n\t}\n\tdist1[gy][gx]=0;\n\tqueue<pi> Q;\n\tQ.push(mp(gy,gx));\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist1[ny][nx]==INF){\n\t\t\t\tdist1[ny][nx]=dist1[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H)rep(j,W)if(c[i][j]=='*'){\n\t\tdist2[i][j]=0;\n\t\tQ.push(mp(i,j));\n\t}\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist2[ny][nx]==INF){\n\t\t\t\tdist2[ny][nx]=dist2[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi d1,d2;\n\tint start;\n\trep(i,H)rep(j,W)if(c[i][j]=='.'){\n\t\tif(i==sy && j==sx)start=sz(d1);\n\t\td1.pb(dist1[i][j]);\n\t\td2.pb(dist2[i][j]);\n\t}\n\t\n\tdouble lo=0,hi=250000;\n\trep(t,100){\n\t\tdouble mi=(lo+hi)/2;\n\t\tdouble sum=0;\n\t\trep(i,sz(d1)){\n\t\t\tsum+=min(1.*d1[i],d2[i]+mi);\n\t\t}\n\t\tif(sum>mi*sz(d1))lo=mi;\n\t\telse hi=mi;\n\t}\n\tcout<<setprecision(16)<<min(1.*d1[start],d2[start]+hi)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0;\n    Int c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc++;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12f %.12f\\n\",p, abs(p-q));\n    return abs(p-q);\n  };\n\n  Double l=0,r=1e12;\n  \n  for(Int k=0;k<300;k++){\n    Double m1=l+(r-l)/3;\n    Double m2=l+(r-l)/3*2;\n    if(calc(m1)<calc(m2)) r=m2;\n    else l=m1;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ld MAX = 10000000000000;\nconst ld EPS = 0.0000000001;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\tstatic int w,h;\n\tstatic char c[502][502];\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h){\n\t\tscanf(\"\\n\");\n\t\trep(j,w){\n\t\t\tscanf(\"%c\",&c[i][j]);\n\t\t}\n\t}\n\t\n\tstatic ld a[502][502];\n\tstatic bool used[502][502];\n\tstatic queue<pair<ld,P>> que;\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 'g'){\n\t\t\ta[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse a[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(a[nx][ny] > a[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\ta[nx][ny] = a[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(a[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\tstatic ld b[502][502];\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == '*'){\n\t\t\tb[i][j] = 0;\n\t\t\tque.push(pair<ld,P>(0,P(i,j)));\n\t\t}\n\t\telse b[i][j] = MAX;\n\t\tused[i][j] = false;\n\t}\n\twhile(!que.empty()){\n\t\tpair<ld,P> p = que.front(); que.pop();\n\t\tif(!used[p.sc.fr][p.sc.sc]){\n\t\t\trep(i,4){\n\t\t\t\tint nx = p.sc.fr + dir_4[i][0];\n\t\t\t\tint ny = p.sc.sc + dir_4[i][1];\n\t\t\t\tif(c[nx][ny] == '#' || c[nx][ny] == '*')continue;\n\t\t\t\tif(b[nx][ny] > b[p.sc.fr][p.sc.sc] + 1.0){\n\t\t\t\t\tb[nx][ny] = b[p.sc.fr][p.sc.sc] + 1.0;\n\t\t\t\t\tque.push(pair<ld,P>(b[nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t}\n\t}\n\t\n\trep(i,h)rep(j,w){\n\t\tif(a[i][j] == MAX && b[i][j] == MAX)c[i][j] = '#';\n\t}\n\t\n\tld l = 0.0 , r = MAX;\n\twhile(l+EPS < r){\n\t\tld m = (l+r)/2;\n\t\tld sum = 0.0 , cnt = 0.0;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(c[i][j] == '#' || c[i][j] == '*' || c[i][j] == 'g')continue;\n\t\t\tsum += min ( a[i][j] , m+b[i][j] );\n\t\t\tcnt += 1.0;\n\t\t}\n\t\t//cout << l << \" \" << r << \":\" << endl;\n\t\t//cout << \"m = \" << m << endl;\n\t\t//cout << \"sum = \" << sum << \",cnt = \" << cnt << endl;\n\t\tif(m*cnt > sum)r = m;\n\t\telse l = m;\n\t}\n\t\n\t/*rep(i,h){\n\t\trep(j,w){\n\t\t\tif(a[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)a[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(b[i][j] >= MAX-1.0){\n\t\t\t\tprintf(\"-\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\",(int)b[i][j]);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tcout.precision(20);\n\trep(i,h)rep(j,w){\n\t\tif(c[i][j] == 's'){\n\t\t\tcout << min ( a[i][j] , l+b[i][j] ) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  //long double nE = 0.0;\n  int cnt = 0;\n  priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    long double l = que.top();\n    que.pop();\n    long double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+15;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 120) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 18;\n\nconst int cmax=250010;\nint w,h;\nll d[cmax];\nll e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg)const{\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[cmax];\n\nvoid dijkstra(char s,char o,ll* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\tll dsum=0;\n\tll esum=0;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tif(d[idx]!=inf){\n\t\t\t\tex[n].d=d[idx];\n\t\t\t\tex[n++].e=e[idx];\n\t\t\t}else\n\t\t\t\tesum+=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\trep(i,n) dsum+=ex[i].d;\n\tdouble ans=(1.0*(dsum+esum)/n+e[sidx]);\n\tfor(int i=n;i>=1;--i){\n\t\tans=min(ans,1.0*(dsum+esum)/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tdsum-=ex[cur].d;\n\t\tdsum+=ex[cur].e;\n\t}\n\tif(d[sidx]!=inf)\n\t\tans=min(ans,1.0*d[sidx]);\n\tcout.precision(16);\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <functional>\n#include <cstdio>\n#include <cmath>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\ntemplate <class T> bool setmax(T & l, T const & r) { if (not (l < r)) return false; l = r; return true; }\ntemplate <class T> bool setmin(T & l, T const & r) { if (not (r < l)) return false; l = r; return true; }\nusing namespace std;\nconst int inf = 1e9+7;\nconst int dy[] = { -1, 1, 0, 0 };\nconst int dx[] = { 0, 0, 1, -1 };\nint main() {\n    // input\n    int w, h; cin >> w >> h;\n    vector<string> c(h); repeat (y,h) cin >> c[y];\n    // modify input\n    int sy, sx, gy, gx;\n    repeat (y,h) repeat (x,w) {\n        if (c[y][x] == 's') {\n            sy = y;\n            sx = x;\n            c[y][x] = '.';\n        } else if (c[y][x] == 'g') {\n            gy = y;\n            gx = x;\n        }\n    }\n    // prepare\n    auto on_field = [&](int y, int x) { return 0 <= y and y < h and 0 <= x and x < w; };\n    typedef queue<pair<int,int> > points_queue;\n    auto bfs = [&](function<void (points_queue &)> init, function<void (points_queue &, int, int, int, int)> update) {\n        points_queue que;\n        init(que);\n        while (not que.empty()) {\n            int y, x; tie(y, x) = que.front(); que.pop();\n            repeat (i,4) {\n                int ny = y + dy[i];\n                int nx = x + dx[i];\n                if (not on_field(ny, nx)) continue;\n                if (c[ny][nx] != '.') continue;\n                update(que, y, x, ny, nx);\n            }\n        }\n    };\n    vector<vector<int> > goal(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        goal[gy][gx] = 0;\n        que.push(make_pair(gy, gx));\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (goal[ny][nx] == inf) {\n            goal[ny][nx] = goal[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    vector<vector<int> > jump(h, vector<int>(w, inf));\n    bfs([&](points_queue & que) {\n        repeat (y,h) repeat (x,w) if (c[y][x] == '*') {\n            jump[y][x] = 0;\n            que.push(make_pair(y, x));\n        }\n    }, [&](points_queue & que, int y, int x, int ny, int nx) {\n        if (jump[ny][nx] == inf) {\n            jump[ny][nx] = jump[y][x] + 1;\n            que.push(make_pair(ny, nx));\n        }\n    });\n    map<pair<int,int>,int> freq; // frequency\n    int total = 0;\n    int max_goal = 0;\n    repeat (y,h) repeat (x,w) if (c[y][x] == '.') {\n        freq[make_pair(goal[y][x], jump[y][x])] += 1;\n        total += 1;\n        if (goal[y][x] < inf) setmax(max_goal, goal[y][x]);\n    }\n    // calc\n    double e = INFINITY;\n    repeat (estimate, max_goal + 1) {\n        // E = f(E) = aE + b\n        double a = 0;\n        double b = 0;\n        for (auto it : freq) {\n            int g, j; tie(g, j) = it.first;\n            int cnt = it.second;\n            double p = cnt /(double) total;\n            if (g == inf) {\n                a += p;\n                b += p * j;\n            } else if (j == inf) {\n                b += p * g;\n            } else {\n                if (g <= j + estimate) {\n                    b += p * g;\n                } else {\n                    a += p;\n                    b += p * j;\n                }\n            }\n        }\ncerr << estimate << \": \" << a << \" \" << b << \" -> \" << b / (1-a) << endl;\n        setmin(e, b / (1 - a));\n    }\ncerr << \"e : \" << e << endl;\n    // output\n    double ans\n        = goal[sy][sx] == inf ? jump[sy][sx] + e\n        : jump[sy][sx] == inf ? goal[sy][sx]\n        : min<double>(goal[sy][sx], jump[sy][sx] + e); // the answer can become grater than `int inf`, so conditional op. is required.\n    printf(\"%.12lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tint maxn = 0;\n\trep(i,H) rep(j,W){\n\t\tif(vv1[i][j] != INF) maxn=max(maxn,vv1[i][j]);\n\t}\n\tmap<pair<int,int>,int> ma;\n\tdouble bb = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] != '.') continue;\n\t\t\tint x = vv1[i][j];\n\t\t\tint y = vv2[i][j];\n\t\t\tint t = min(x,y);\n\t\t\tbb += t*p;\n\t\t\tx-=t;\n\t\t\ty-=t;\n\t\t\tpii z = pii(x,y);\n\t\t\tif(ma.count(z)==0) ma[z] = 0;\n\t\t\tma[z]+=1;\n\t\t}\n\t}\n\tlong double ans = 1e100;\n\trep(o,maxn+1){\n\t\tlong double a = 0;\n\t\tlong double b = bb;\n\t\tfor(auto x:ma){\n\t\t\tif(x.F.F-x.F.S <= o){\n\t\t\t\tb += p*x.F.F*x.S;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb += p*x.F.S*x.S;\n\t\t\t\ta += p*x.S;\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\nconst int INFLL=1001001001001001001ll;\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint dy[4]={-1,0,1,0};\nint dx[4]={0,-1,0,1};\n\nint H,W;\nchar fld[555][555];\ndouble E[555][555];\nbool check(double e){\n    queue<pint>que;\n    fill_n(*E,555*555,1e14);\n    rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n        E[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(true){\n        if(que.size()==0){\n            if(flag)break;\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n            continue;\n        }\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n\n        if(E[y][x]+1>=e&&!flag){\n            rep(i,H)rep(j,W)if(fld[i][j]=='*'){\n                E[i][j]=e;\n                que.push({i,j});\n            }\n            flag=true;\n        }\n\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||fld[ny][nx]=='*')continue;\n\n            if(E[ny][nx]!=1e12)continue;\n            E[ny][nx]=E[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    double sum=0;\n    int cnt=0;\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='#'||fld[i][j]=='*'||fld[i][j]=='g')continue;\n        cnt++;sum+=E[i][j];\n    }\n\n    return sum<=e*cnt;\n}\n\n\nsigned main(){\n    cin>>W>>H;\n    rep(i,H)cin>>fld[i];\n\n    vector<vint>dist(H,vint(W,INT_MAX));\n    queue<pint>que;\n    rep(i,H)rep(j,W)if(fld[i][j]=='s'){\n        dist[i][j]=0;\n        que.push({i,j});\n    }\n    bool flag=false;\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n        rep(d,4){\n            int ny=y+dy[d],nx=x+dx[d];\n            if(fld[ny][nx]=='#'||dist[ny][nx]!=INT_MAX)continue;\n            if(fld[ny][nx]=='*')flag=true;\n            dist[ny][nx]=dist[y][x]+1;\n            que.push({ny,nx});\n        }\n    }\n\n    if(!flag){\n        rep(i,H)rep(j,W)if(fld[i][j]=='g'){\n            printf(\"%.20f\\n\",(double)dist[i][j]);\n            return 0;\n        }\n    }\n\n    double lb=0,ub=1e12;\n    rep(i,100){\n        double mid=(ub+lb)/2;\n        if(check(mid))ub=mid;\n        else lb=mid;\n    }\n\n    rep(i,H)rep(j,W){\n        if(fld[i][j]=='s'){\n            printf(\"%.20f\\n\",E[i][j]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 100000000000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >1000)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr int INF = (1 << 30);\n\ninline bool out(int x, int y, int w, int h) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nvoid bfs(int sx, int sy, const vector<string> &field, vector<vector<int>> &dist) {\n\ttypedef pair<int, int> point;\n\n\tconstexpr int dx[] = {1, 0, -1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tconst int h = field.size();\n\tconst int w = field[0].size();\n\n\tqueue<point> que;\n\n\tque.push({sx, sy});\n\tdist[sy][sx] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().first;\n\t\tconst int y = que.front().second;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny, w, h) || field[ny][nx] != '.') continue;\n\t\t\tif(dist[ny][nx] > dist[y][x] + 1) {\n\t\t\t\tdist[ny][nx] = dist[y][x] + 1;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(double E, const vector<pair<int, int>> &values) {\n\tdouble sum = 0.0;\n\tfor(const auto &e : values) {\n\t\tsum += min<double>(e.first, e.second + E);\n\t}\n\treturn sum / values.size();\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(12);\n\n\tint w, h;\n\tcin >> w >> h;\n\n\tvector<string> field(h);\n\tfor(auto &e : field) cin >> e;\n\n\tint sx, sy;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 's') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j] = '.';\n\t\t\t\tgoto bfs_phase;\n\t\t\t}\n\t\t}\n\t}\n\nbfs_phase:;\n\n\tvector<vector<int>> from_goal(h, vector<int>(w, INF));\n\tvector<vector<int>> from_spring(h, vector<int>(w, INF));\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'g') {\n\t\t\t\tbfs(j, i, field, from_goal);\n\t\t\t}\n\t\t\telse if(field[i][j] == '*') {\n\t\t\t\tbfs(j, i, field, from_spring);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<int, int>> values;\n\tvalues.reserve(h * w);\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == '.') {\n\t\t\t\tvalues.emplace_back(from_goal[i][j], from_spring[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble L = 0.0, R = INF;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tconst double M = (L + R) / 2.0;\n\t\tif(calc(M, values) < M) {\n\t\t\tR = M;\n\t\t}\n\t\telse {\n\t\t\tL = M;\n\t\t}\n\t}\n\n\tcout << min<double>(from_goal[sy][sx], from_spring[sy][sx] + L) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(int dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    int dist_goal[500][500], dist_spring[500][500];\n    memset(dist_goal, -1, sizeof dist_goal);\n    memset(dist_spring, -1, sizeof dist_spring);\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e9;\n    REP(_, 200){\n      const double sum = (ub + lb) * 0.5;\n      double S = sum;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        double exp = min((double)dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S -= exp;\n      }\n      if(S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = lb / N;\n    printf(\"%.12f\\n\", min((double)dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16500; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0,c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc+=1.0;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12Lf %.12Lf\\n\",p, p-q);\n    return p-q;\n  };\n\n  Double l=0,r=1e30;\n\n  for(int k=0;k<200;k++){\n    Double m=(l+r)/2;\n    if(calc(m)<=0) l=m;\n    else r=m;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nll A[500][500],B[500][500];\nll INF=(1LL<<50);\n\nvoid bfs(char ch,ll d[500][500]){\n  fill(d[0],d[500], INF );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(0);\n  \n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  \n  bfs('*',A);\n  bfs('g',B);\n\n  vector<ll> v;\n  ll sum=0,cnt=0,K=0;\n  double base=1e100;\n  double ans=1e100;\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      \n      cnt++;\n      if(t[i][j]=='s'){\n        if(A[i][j]==INF)base=1e100;\n        else base=A[i][j];\n        if(B[i][j]!=INF)ans=B[i][j];\n      }\n      if(A[i][j]==INF){\n        sum+=B[i][j];\n      }else if(B[i][j]==INF){\n        sum+=A[i][j];\n        K++;\n      }else{\n        sum+=B[i][j];\n        v.push_back(A[i][j]-B[i][j]);\n      }\n\n    }\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<=(int)v.size();i++){\n    double rate=(double)K/(double)cnt;\n    double X=(double)sum/(double)cnt;\n    X/=(1.0-rate);\n    ans=min(ans,(double)base+X);\n    K++;\n    \n    if(i==(int)v.size())break;\n    sum+=v[i];\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nchar field[600][600];\nint a[600][600];\nint b[600][600];\n\nvoid bfs(char start, int dist[][600]){\n  queue<int> que;\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, INF);\n  rep(i, H)rep(j, W){\n    if(field[i][j] == start){\n      dist[i][j] = 0;\n      que.push(i * W + j);\n    }\n  }\n  while(!que.empty()){\n    int p = que.front(); que.pop();\n    int x = p % W;\n    int y = p / W;\n    rep(i, 4){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      if((field[y2][x2] == '.' || field[y2][x2] == 's') && dist[y2][x2] == INF){\n\tdist[y2][x2] = dist[y][x] + 1;\n\tque.push(y2 * W + x2);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H){\n    int sy = 0, sx = 0;\n    rep(i, H)rep(j, W){\n      cin >> field[i][j];\n      if(field[i][j] == 's'){\n\tsy = i, sx = j;\n      }\n    }\n    bfs('*', a);\n    bfs('g', b);\n    long double ub = 1e10;\n    long double lb = 0;\n    rep(i, 300){\n      double mb = (ub + lb) / 2;\n      double sum = 0;\n      int cnt = 0;\n      rep(j, H)rep(k, W){\n\tif(field[j][k] == 's' || field[j][k] == '.'){\n\t  cnt++;\n\t  sum += min((double)b[j][k], a[j][k] + mb);\n\t}\n      }\n      if(mb > sum / cnt) ub = mb;\n      else lb = mb;\n    }\n    cout << fixed << setprecision(12) << min(lb+a[sy][sx],(long double)b[sy][sx])<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tlong long x,y;\n\tC(long long x,long long y):x(x),y(y){}\n};\nconst long long dx[]={1,0,-1,0};\nconst long long dy[]={0,1,0,-1};\n\nlong long w,h;\n\nbool in(long long x,long long y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(long long i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(long long j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=8000000000;\n\t\t\tdist_goal[i][j]=8000000000;\n\t\t\tdist_spring[i][j]=8000000000;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst long long NUM=4000;\n\tfor(long long t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(long long y=0;y<h;y++){\n\t\t\tfor(long long x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n//#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\ndouble d[512][512],INF=5e15,d2[512][512];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  //  cout<<sizeof(ll)<<endl;\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[0]+512*512,INF);\n  fill(d2[0],d2[0]+512*512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  double a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //    cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  //cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(999999);\n\t\t\tgot[i].emplace_back(999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1000000000;\n\twhile (amin + 1e-11 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<long double>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans = min(long double(got[sy][sx]), spt[sy][sx] + amin);\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int w,h;\n    cin >> w >> h;\n    vector<string> c(h);\n    int sy,sx,gy,gx;\n    rep(i,0,h){\n        cin >> c[i];\n        rep(j,0,w){\n            if(c[i][j]=='s'){\n                sy=i;\n                sx=j;\n            }\n            if(c[i][j]=='g'){\n                gy=i;\n                gx=j;\n            }\n        }\n    }\n\n\n    int dy[]={0,1,0,-1},dx[]={1,0,-1,0};\n    vector<vector<int>> a(h,vector<int>(w,inf)),b(h,vector<int>(w,inf));\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto bfs=[&](int y0,int x0,int c){\n        queue<tuple<int,int,int>> que;\n        que.push(make_tuple(y0,x0,0));\n        while(!que.empty()){\n            tuple<int,int,int> t=que.front();\n            que.pop();\n            int y=get<0>(t),x=get<1>(t),d=get<2>(t);\n            if(c==0){\n                if(a[y][x]<=d) continue;\n                a[y][x]=d;\n            }\n            if(c==1){\n                if(b[y][x]<=d) continue;\n                b[y][x]=d;\n            }\n            rep(i,0,4){\n                int ny=y+dy[i],nx=x+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_tuple(ny,nx,d+1));\n            }\n        }\n    };\n    rep(i,0,h){\n        rep(j,0,w){\n            if(c[i][j]=='*') bfs(i,j,0);\n            if(c[i][j]=='g') bfs(i,j,1);\n        }\n    }\n    \n    auto g=[&](long double e){\n        long double sum=0;\n        int count=0;\n        rep(y,0,h){\n            rep(x,0,w){\n                if(c[y][x]=='#' or c[y][x]=='*' or c[y][x]=='g') continue;\n                sum+=min(a[y][x]+e,(long double)b[y][x]);\n                ++count;\n            }\n        }\n        return sum/count;\n    };\n\n    long double lb=0,ub=inf64;\n    rep(i,0,128){\n        long double mid=(lb+ub)/2;\n        if(mid<g(mid)) lb=mid;\n        else ub=mid;\n    }\n\n    cout << min(a[sy][sx]+lb,(long double)b[sy][sx]) << endl;\n }\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\nchar c[523][523];\n\ntemplate<class A>\nvoid bfs(A &ds,queue<tuple<int,int,int> > que){\n  fill(*begin(ds),*end(ds),3333);\n  while(!que.empty()){\n    auto cs=que.front();\n    que.pop();\n    int t=get<0>(cs);\n    int y=get<1>(cs);\n    int x=get<2>(cs);\n    if(ds[y][x]<=t)continue;\n    ds[y][x]=t;\n    for(int i=0;i<4;i++){\n      static const int d[]={0,1,0,-1,0};\n      int ny=y+d[i];\n      int nx=x+d[i+1];\n      if(c[ny][nx]!='#'){\n\tque.push(make_tuple(t+1,ny,nx));\n      }\n    }\n  }\n}\n\nint main(){\n  int W,H;\n  cin>>W>>H;\n  queue<tuple<int,int,int> > sque,gque;\n  int sy,sx;\n  int n=0;\n  for(int i=0;i<H;i++){\n    cin>>c[i];\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='s'){\n\tc[i][j]='.';\n\tsy=i;\n\tsx=j;\n      }else if(c[i][j]=='*'){\n\tsque.push(make_tuple(0,i,j));\n      }else if(c[i][j]=='g'){\n\tgque.push(make_tuple(0,i,j));\n      }\n      n+=c[i][j]=='.';\n    }\n  }\n  static int ds[523][523];\n  bfs(ds,sque);\n  static int dg[523][523];\n  bfs(dg,gque);\n  int gsum=0,ssum=0;\n  int xsum=0;\n  int gs[2555]={},ss[2555]={};\n  int xs[2555]={};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='.'){\n\tint cx=min(2500,max(0,dg[i][j]-ds[i][j]));\n\tgsum+=dg[i][j];\n\tgs[cx]+=dg[i][j];\n\tss[cx]+=ds[i][j];\n\txs[cx]++;\n      }\n    }\n  }\n  double ans=1e9;\n  for(int i=2500;i>=0;i--){\n    gsum-=gs[i];\n    ssum+=ss[i];\n    xsum+=xs[i];\n    if(xsum==n)continue;\n    ans=min(ans,(dg[sy][sx]-ds[sy][sx]>=i)?ds[sy][sx]+(gsum+ssum)*1./(n-xsum):dg[sy][sx]);\n  }\n  cout.precision(99);\n  cout<<fixed<<ans<<endl;\n}\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int N = 500;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst ll inf = 1LL<<60;\nchar m[N][N+1];\nll dcost[N][N];//¼ÚS[ÜÅs­RXg\nll scost[N][N];//olðgÁ½ÌRXg\nvoid bfs(int r,int c,char s,ll cost[N][N]){\n  queue<int> Q;\n  rep(i,r)rep(j,c)\n    if (m[i][j] == s)cost[i][j] = 0,Q.push(i*c+j);\n    else cost[i][j] = inf;\n  while(!Q.empty()){\n    int y = Q.front()/c,x=Q.front()%c;Q.pop();\n    rep(i,4){\n      int ney = y+dy[i],nex = x+dx[i];\n      if (m[ney][nex] == '*' || m[ney][nex] == 'g' || m[ney][nex] == '#' || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n}\n\n/*\n  e}X©çÌúÒlÍA\n  min(¼ÚS[ÜÅs­AÅZÌolÜÅJ¢Ä¢ÁÄòÔ{úÒl)\n  ±±ÅÌúÒlÍ (òñ¾ Æs­Â\\«ª é}XÌúÒlÌa)/(»Ìæ¤È}XÌ)B\n  \n  KÉúÒlðßÅ¿µÄAÇ¤µ·é©ðl¦ÄÝéB\n  úÒlð³çÉ¬³­Å«éÈç¬³­µÄAå«­È¢Æ¢¯È¢Èçå«­·éB\n */\ndouble exp[N][N];\ndouble bf(int r,int c){\n  double e=0;//úÒlÌaðÁÄ¨­ÆðÉ§Â\n  double pos = 0;//olÅs­Â\\«Ì éêÌ\n  int sy,sx;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '*' || m[i][j] == 'g' || m[i][j] == '#')continue;\n      exp[i][j] = dcost[i][j];\n      e += dcost[i][j];\n      pos++;\n      if (m[i][j] == 's')sy = i,sx = j;\n    }\n  }\n\n  /*\n    olÅòñÅ©çS[ÜÅ½Çè­ÜÅÌúÒlðßÅ¿·éB\n    »ÌúÒlð³ÉÀÛÌúÒlðvZµÄÝÄA¬³¯êÎßÅ¿µ½úÒlæèàÁÆ¬³­Å«éB\n    å«¯êÎàÁÆå«­È¢Æ¢¯È­ÈéB\n   */\n  double L = 0,R=1e20;\n  double ans = -1;\n  rep(i,300){\n    double mid = (L+R)/2.;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#' || m[i][j] == '*')continue;\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + mid/pos;\n\tnewe += min(tmp,tmp2);\n      }\n    }\n    if (newe < mid){//\\zæè¬³©Á½\n      ans = mid;\n      R = mid - 1e-10;\n    }else {//\\zæèå«©Á½\n      L = mid + 1e-10;\n    }\n  }\n  return  min((double)dcost[sy][sx],scost[sy][sx]+ans/pos);\n\n  /*\n    û©·éÜÅñµÄÝ½\n   */\n  /*\n  while(true){\n    bool isupdate = false;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#')continue;//±±Íl¦È¢B\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + (e)/(pos);\n\tif (exp[i][j] > min(tmp,tmp2)){\n\t  isupdate = true;\n\t  e -= exp[i][j];\n\t  exp[i][j] = min(tmp,tmp2);\n\t  e += exp[i][j];\n\t}\n\tnewe += exp[i][j];\n      }\n    }\n    e = newe;\n    if (!isupdate)break;\n  }\n\n  /*\n  ðúÌè@ª³µ­®­©`FbN·é½ßÉ¢½\n  *\n  double hoge = 0;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#' || m[i][j] == 'g' || m[i][j] == '*')continue;\n      hoge += min((double)dcost[i][j],scost[i][j] + e/pos);\n      cout << min((double)dcost[i][j],scost[i][j] + e/pos) <<\" \" ;\n    }\n    cout << endl;\n  }\n  cout <<\"hoge \" << e <<\" \" << hoge/pos << endl;\n  */\n  //rep(i,r)rep(j,c)if (m[i][j] == 's')return exp[i][j];\n}\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)cin>>m[i];\n    bfs(r,c,'*',scost);\n    bfs(r,c,'g',dcost);\n    printf(\"%.12lf\\n\",bf(r,c));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long double EPS = 1e-10;\nconst int H = 500;\nconst int W = 500;\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,-1,0,1};\n\nstruct P{\n  int x, y;\n  P(int x=0, int y=0):x(x),y(y){}\n};\n\nstruct state{  \n  int x, y, cnt;\n  state(int x=0, int y=0, int cnt=0):x(x),y(y),cnt(cnt){}\n  bool operator < (const state &s) const {\n    return cnt < s.cnt;\n  }\n};\n\nint w, h, dis_go[H][W], dis_sp[H][W];\nlong double cnt_nowall;\nP st, go;\nvector<P> v;\nbool wall[H][W];\n\nvoid init_dis(){\n  queue<state> q;\n  state u, u2;\n\n  cnt_nowall = 0;\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      dis_go[i][j] = dis_sp[i][j] = -1;\n      cnt_nowall += !wall[i][j];\n    }\n  }\n\n  for(q.push(state(go.x, go.y, 0));!q.empty();){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      u2 = state(u.x+dx[i], u.y+dy[i], u.cnt+1);\n      if(!wall[u2.y][u2.x] && (dis_go[u2.y][u2.x] == -1 || dis_go[u2.y][u2.x] > u2.cnt)){\n        dis_go[u2.y][u2.x] = u2.cnt;\n        q.push(u2);\n      }\n    }\n  }\n\n  for(int i=0;i<v.size();i++){\n    for(q.push(state(v[i].x, v[i].y, 0));!q.empty();){\n      u = q.front();\n      q.pop();\n      for(int j=0;j<4;j++){\n        u2 = state(u.x+dx[j], u.y+dy[j], u.cnt+1);\n        if(!wall[u2.y][u2.x] && (dis_sp[u2.y][u2.x] == -1 || dis_sp[u2.y][u2.x] > u2.cnt)){\n          dis_sp[u2.y][u2.x] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n}\n\nlong double a_ruiseki[H*W], b_ruiseki[H*W], g_ruiseki[H*W];\n\nvoid calc_exp_init(){\n  vector<state> pv;\n\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      if(!wall[i][j]){\n        pv.push_back(state(j, i, dis_go[i][j] - dis_sp[i][j]));\n        if(dis_sp[i][j] == -1) pv[pv.size()-1].cnt = -2;\n        else if(dis_go[i][j] == -1) pv[pv.size()-1].cnt = -1;\n        else if(dis_go[i][j] < dis_sp[i][j]) pv[pv.size()-1].cnt = 0;\n      }\n    }\n  }      \n  fill(a_ruiseki, a_ruiseki+H*W, 0);\n  fill(b_ruiseki, b_ruiseki+H*W, 0);\n  fill(g_ruiseki, g_ruiseki+H*W, 0);\n\n  sort(pv.begin(), pv.end());\n\n  a_ruiseki[h*w-1] = 1.0;\n  for(int i=0;i<pv.size();i++){\n    if(pv[i].cnt == -2){  // dis_sp[i][j] == -1\n      g_ruiseki[0] += (long double)dis_go[pv[i].y][pv[i].x] / cnt_nowall;\n\n    } else if(pv[i].cnt == -1){ // dis_go[i][j] == -1\n      b_ruiseki[h*w-1] += (long double)dis_sp[pv[i].y][pv[i].x] / cnt_nowall;\n      a_ruiseki[h*w-1] -= (long double)1.0 / cnt_nowall;\n\n    } else if(pv[i].cnt == 0){\n      //b_ruiseki[h*w-1] += (long double)dis_sp[pv[i].y][pv[i].x] / cnt_nowall;\n      g_ruiseki[1] += (long double)dis_go[pv[i].y][pv[i].x] / cnt_nowall;\n\n    } else {\n      b_ruiseki[pv[i].cnt] += (long double)dis_sp[pv[i].y][pv[i].x] / cnt_nowall;\n      g_ruiseki[pv[i].cnt+1] += (long double)dis_go[pv[i].y][pv[i].x] / cnt_nowall;\n      a_ruiseki[pv[i].cnt] -= (long double)1.0 / cnt_nowall;\n    }\n  }\n\n  for(int i=0;i<h*w-1;i++){\n    g_ruiseki[i+1] += g_ruiseki[i];\n  }\n  for(int i=h*w-1;i>0;i--){\n    b_ruiseki[i-1] += b_ruiseki[i];\n    a_ruiseki[i-1] += a_ruiseki[i];\n  }\n}\n\nlong double calc_exp(int base){\n  long double a = 1.0, b = 0.0, exp_go = 0.0;\n    \n  /*\n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      if(!wall[i][j]){\n        if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n          a -= 1.0 / cnt_nowall;\n          b += (long double)dis_sp[i][j] / cnt_nowall;\n        } else {\n          exp_go += (long double)dis_go[i][j] / cnt_nowall;\n        }\n      }\n    }\n  }\n  */\n\n  //printf(\"g %d: %.10Lf %.10Lf\\n\", base, g_ruiseki[base], exp_go);\n  //printf(\"b %d: %.10Lf %.10Lf\\n\", base, b_ruiseki[base], b);\n  //printf(\"a %d: %.10Lf %.10Lf\\n\", base, a_ruiseki[base], a);\n  \n  //return (b + exp_go) / a;\n  return (b_ruiseki[base] + g_ruiseki[base]) / a_ruiseki[base];\n}\n\nlong double solve(){\n  long double ans = -1;\n\n  init_dis();\n  calc_exp_init();\n\n  if(dis_go[st.y][st.x] != -1) ans = dis_go[st.y][st.x];\n\n  int cnt = 0;\n\n \n  for(int i=2;i<(h-2)*(w-2);i++){\n    if(dis_sp[st.y][st.x] == -1 || dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i){\n      break;\n    }  \n    if(ans < -0.9) ans = calc_exp(i) + dis_sp[st.y][st.x];\n    else ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n  }\n  \n  \n  /*\n  if(dis_sp[st.y][st.x] != -1){\n    int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n    long double res0, res1, res2;\n    if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n    while(ri - le >= 4){\n      mid1 = (le * 2 + ri) / 3;\n      mid2 = (le + ri * 2) / 3;\n      res0 = calc_exp(le) + dis_sp[st.y][st.x];\n      res1 = calc_exp(mid1) + dis_sp[st.y][st.x];\n      res2 = calc_exp(mid2) + dis_sp[st.y][st.x];\n      if(mid2 - mid1 <= 1) break;\n      if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n      else ri = mid2;\n    }\n    for(int i=le;i<le+5;i++) {\n      if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n      if(ans < -0.9) ans = calc_exp(i) + dis_sp[st.y][st.x];\n      else ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n    }\n  }\n  */\n\n  return ans;\n}\n\nint main(){\n  char c;\n  while(cin >> w >> h){\n    v.clear();\n    int cnt = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> c;\n        wall[i][j] = true;\n        if(c == 's') st = P(j, i), wall[i][j] = false;\n        else if(c == 'g') go = P(j, i);\n        else if(c == '*') v.push_back(P(j, i)), cnt++;\n        else if(c == '.') wall[i][j] = false;\n      }\n    }    \n\n    printf(\"%.12Lf\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<long long int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(9999999999);\n\t\t\tgot[i].emplace_back(9999999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\t__float128 amin = 0;\n\t__float128 amax = 1e11;\n\tbool ok = true;\n\twhile (amin + 1e-10 < amax) {\n\t\t__float128 amid = (amin + amax) / 2;\n\n\t\t__float128 timesum = 0;\n\t\t__float128 placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tif (got[y][x] == 9999999999 && spt[y][x] == 9999999999) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<__float128>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans;\n\tif (ok) {\n\t\tans = min(static_cast<__float128>(got[sy][sx]), spt[sy][sx] + amin);\n\n\t}\n\telse {\n\t\tans = static_cast<long double>(got[sy][sx]);\n\t}\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst long double INF = 5e9;\n\nusing vd = vector<long double>;\nusing V = vector<vd>;\n\nusing pi = pair<int,int>;\nusing P = pair<double,pi>;\n\nconst int dy[4]={1,-1,0,0}, dx[4]={0,0,1,-1};\n\nint main(){\n    int w,h;\n    cin >>w >>h;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    auto IN = [&](int y, int x){\n        return 0<=y && y<h && 0<=x && x<w;\n    };\n\n    auto calc = [&](double m){\n        V dp(h,vd(w,INF));\n\n        queue<pi> que;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='g'){\n                dp[i][j]=0;\n                que.push({i,j});\n            }\n            if(s[i][j]=='*'){\n                dp[i][j]=m;\n                que.push({i,j});\n            }\n        }\n\n        while(!que.empty()){\n            pi pos = que.front();\n            que.pop();\n            rep(d,4){\n                int ny = pos.fi+dy[d], nx = pos.se+dx[d];\n                if(IN(ny,nx) && s[ny][nx]!='#' && s[ny][nx]!='*'){\n                    if(dp[ny][nx] > dp[pos.fi][pos.se]+1){\n                        dp[ny][nx] = dp[pos.fi][pos.se]+1;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n        }\n\n        return dp;\n    };\n\n    long double l=0, r=INF;\n    rep(loop,100){\n        long double m = (l+r)/2;\n        V E = calc(m);\n\n        int n = 0;\n        long double sumE = 0;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='.' || s[i][j]=='s'){\n                ++n;\n                sumE += E[i][j];\n            }\n        }\n        sumE /= n;\n\n        if(sumE<m) r=m;\n        else l=m;\n    }\n\n    V E = calc(l);\n    double ans=-1;\n    rep(i,h)rep(j,w)if(s[i][j]=='s') ans = E[i][j];\n    printf(\"%.15f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ld INF = 1e+30;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nint w, h;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nint sx, sy;\nqueue<P> q;\nchar mp[500][500];\nbool used[500][500];\nld d[500][500];\nvector<ld> a, b;\nld sa, sb;\nbool comp(LDP x, LDP y) {\n\treturn x.first - x.second < y.first - y.second;\n}\nvoid solve() {\n\tcin >> w >> h;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\td[i][j] = (ld)h*w*1000000;\n\t\t}\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> mp[i][j];\n\t\t\tif (mp[i][j] == 's') {\n\t\t\t\tsx = i, sy = j; mp[i][j] = '.';\n\t\t\t}\n\t\t\telse if (mp[i][j] == 'g') {\n\t\t\t\tq.push({ i,j }); used[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint tmp = 0;\n\twhile (!q.empty()) {\n\t\tint len = q.size();\n\t\trep(aa, len) {\n\t\t\tP p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\td[x][y] = tmp;\n\t\t\trep(j, 4) {\n\t\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\t\tif (mp[nx][ny] == '.' && !used[nx][ny]) {\n\t\t\t\t\tused[nx][ny] = true; q.push({ nx,ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp++;\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tif (mp[i][j] == '.')a.push_back(d[i][j]);\n\t\t\tif (sx == i && sy == j)sa = d[i][j];\n\t\t}\n\t}\n\trep(i, h)rep(j, w) {\n\t\tused[i][j] = false; d[i][j] = (ld)h*w*1000000;\n\t\tif (mp[i][j] == '*') {\n\t\t\tused[i][j] = true; q.push({ i,j });\n\t\t}\n\t}\n\ttmp = 0;\n\twhile (!q.empty()) {\n\t\tint len = q.size();\n\t\trep(aa, len) {\n\t\t\tP p = q.front(); q.pop();\n\t\t\tint x = p.first, y = p.second;\n\t\t\td[x][y] = tmp;\n\t\t\trep(j, 4) {\n\t\t\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\t\t\tif (mp[nx][ny] == '.' && !used[nx][ny]) {\n\t\t\t\t\tused[nx][ny] = true; q.push({ nx,ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttmp++;\n\t}\n\trep(i, h)rep(j, w) {\n\t\tif (mp[i][j] == '.') {\n\t\t\t//cout << i << \" \" << j << \" \" << d[i][j] << endl;\n\t\t\tb.push_back(d[i][j]);\n\t\t}\n\t\tif (sx == i && sy == j) {\n\t\t\tsb = d[i][j];\n\t\t}\n\t}\n\tcout << fixed << setprecision(10);\n\tint sz = a.size();\n\tld ans = INF;\n\tvector<LDP> v;\n\trep(i, sz) {\n\t\tv.push_back({ a[i],b[i] });\n\t}\n\tsort(v.begin(), v.end(), comp);\n\tld sum = 0;\n\trep(i, sz) {\n\t\tsum += b[i];\n\t}\n\trep(i, sz) {\n\t\t//cout << v[i].first << \" \" << v[i].second << endl;\n\t\t//cout << v[i].first - v[i].second << endl;\n\t\tsum -= v[i].second; sum += v[i].first;\n\t\tld csum = sum * sz / (ld)(1 + i);\n\t\tld le = v[i].first - v[i].second;\n\t\tld ri = INF;\n\t\tif (i + 1 < sz - 1) {\n\t\t\tri = v[i + 1].first - v[i + 1].second;\n\t\t}\n\t\t//cout << sum << endl;\n\t\tif (le < csum / (ld)sz&&csum/(ld)sz<ri) {\n\t\t\tans = min(ans, csum);\n\t\t}\n\t}\n\tcout << min(sa, sb + ans / (ld)sz) << endl;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H*100000, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<long long int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(9999999999);\n\t\t\tgot[i].emplace_back(9999999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1e18;\n\twhile (amin + 1e-12 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<long double>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans = min(static_cast<long double>(got[sy][sx]), spt[sy][sx] + amin);\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 20000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nP dlt[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};\n\nvector<vector<char>> c;\nll h,w,f;\nP sp,gp;\nvector<P> spr;\nvector<vector<ll>> g_cost;\nvector<vector<ll>> s_cost;\n\nbool isfloor(P p) {\n\tif(p.first>=0&&p.first<h&&p.second>=0&&p.second<w&&\n\t   (c[p.first][p.second]=='.'||c[p.first][p.second]=='s')) return true;\n\telse return false;\n}\n\nvector<vector<ll>> dijkstra(vector<P> s) {\n\tvector<vector<ll>> dst(h,vector<ll>(w,INF));\n\tpriority_queue<pair<ll,P>,vector<pair<ll,P>>,greater<pair<ll,P>>> q;\n\tREP(i,(ll)s.size()) {\n\t\tdst[s[i].first][s[i].second]=0;\n\t\tq.push(make_pair(0,s[i]));\n\t}\n\twhile(!q.empty()) {\n\t\tll d=q.top().first;\n\t\tP p=q.top().second;\n\t\tq.pop();\n\t\tif(dst[p.first][p.second]!=d) continue;\n\t\tREP(i,4) {\n\t\t\tP np=P(p.first+dlt[i].first,p.second+dlt[i].second);\n\t\t\tif(isfloor(np)&&dst[np.first][np.second]>d+1) {\n\t\t\t\tdst[np.first][np.second]=d+1;\n\t\t\t\tq.push(make_pair(dst[np.first][np.second],np));\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}\n\nvoid init() {\n\tcin>>w>>h;\n\tc.assign(h,vector<char>(w));\n\tREP(i,h) REP(j,w) cin>>c[i][j];\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') f++;\n\tREP(i,h) REP(j,w) if(c[i][j]=='s') sp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='g') gp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='*') spr.pb(P(i,j));\n\tg_cost=dijkstra(vector<P>(1,gp));\n\ts_cost=dijkstra(spr);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tinit();\n\tif(g_cost[sp.first][sp.second]<=s_cost[sp.first][sp.second]) {\n\t\tcout<<fixed<<setprecision(39)<<g_cost[sp.first][sp.second]<<endl;\n\t\treturn 0;\n\t}\n\tll cons=0;\n\tll cf=0;\n\tpriority_queue<ll,vector<ll>,greater<ll>> diff;\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') {\n\t\tif(g_cost[i][j]==INF) {\n\t\t\tcons+=s_cost[i][j];\n\t\t\tcf++;\n\t\t} else cons+=g_cost[i][j];\n\t\tif(g_cost[i][j]!=INF&&s_cost[i][j]>g_cost[i][j]) diff.push(s_cost[i][j]-g_cost[i][j]);\n\t}\n\tld min_x=cons/(ld)(f-cf);\n\twhile(!diff.empty()) {\n\t\tll c=diff.top();\n\t\tdiff.pop();\n\t\tcons+=c;\n\t\tcf++;\n\t\tmin_x=min(min_x,cons/(ld)(f-cf));\n\t}\n\tcout<<fixed<<setprecision(39)<<min(\n\t(ld)g_cost[sp.first][sp.second],s_cost[sp.first][sp.second]+min_x)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nint dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tint num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\te[i][j]=500*500*500;\n\t\t\tdist_goal[i][j]=500*500*500;\n\t\t\tdist_spring[i][j]=500*500*500;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=2000;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint W, H;\nint sx, sy, gx, gy;\nvector<string> vs;\nvector<vector<int> > gdist;\nvector<vector<int> > sdist;\n\nvoid make() {\n    gdist[gx][gy] = 0;\n    queue<P> que;\n    que.push(P(gx,gy));\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (0 <= nx && nx < H && 0 <= ny && ny < W && (vs[nx][ny] == '.' || vs[nx][ny] == 's') && gdist[nx][ny] > gdist[x][y] + 1) {\n                gdist[nx][ny] = gdist[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (vs[i][j] == '*') {\n                que.push(P(i,j));\n                sdist[i][j] = 0;\n            }\n        }\n    }\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (0 <= nx && nx < H && 0 <= ny && ny < W && (vs[nx][ny] == '.' || vs[nx][ny] == 's') && sdist[nx][ny] > sdist[x][y] + 1) {\n                sdist[nx][ny] = sdist[x][y] + 1;\n                que.push(P(nx,ny));\n            }\n        }\n    }\n}\n\nlong double check(long double e) {\n    long double ret = 0.0;\n    int cnt = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (vs[i][j] == '.' || vs[i][j] == 's') {\n               long double dist = 500 * 500;\n               dist = min(dist, (long double)gdist[i][j]);\n               dist = min(dist, (long double)sdist[i][j] + e);\n               ret += dist;\n               cnt ++;\n            }\n        }\n    }\n\n    return ret / cnt;\n}\n\nint main() {\n    cin >> W >> H;\n    vs.resize(H);\n    gdist.resize(H);\n    sdist.resize(H);\n    for (auto &i : gdist) i.resize(W, 500 * 500);\n    for (auto &i : sdist) i.resize(W, 500 * 500);\n    for (auto &i : vs) cin >> i;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (vs[i][j] == 'g') gx = i, gy = j;\n            if (vs[i][j] == 's') sx = i, sy = j;\n        }\n    }\n\n    make();\n\n    long double l = 0.0, r = 1e+10;\n    for (int c = 0; c < 100; c++) {\n        long double m = (l + r)/2.0;\n        if (check(m) < m) {\n            r = m;\n        } else {\n            l = m;\n        }\n    }\n    printf(\"%.10Lf\\n\", min(r + sdist[sx][sy], (long double)gdist[sx][sy]));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e15), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 1000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\nconst int inf = 1e9;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid bfs_grid(queue<pair<int,int>> &wait, vector<string> &g, vector<vector<int>> &res){\n    while(!wait.empty()){\n        int y = wait.front().first;\n        int x = wait.front().second;\n        wait.pop();\n        for(int d=0; d<4; d++){\n            int ny = y +dy[d];\n            int nx = x +dx[d];\n            if(g[ny][nx] == '#' or g[ny][nx] == '*') continue;\n            if(res[ny][nx] != inf) continue;\n            res[ny][nx] = res[y][x] +1;\n            wait.push({ny, nx});\n        }\n    }\n}\n\nint main(){\n    int w,h;\n    cin >> w >> h;\n    vector<string> g(h);\n    for(int i=0; i<h; i++){\n        cin >> g[i];\n    }\n\n    int sy,sx,gy,gx;\n    queue<pair<int, int>> wait;\n    int n = 0;\n    vector<vector<int>> mincost_spring(h, vector<int>(w, inf));\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            if(g[i][j] == 's'){\n                sy = i;\n                sx = j;\n                g[i][j] = '.';\n            }\n            if(g[i][j] == 'g'){\n                gy = i;\n                gx = j;\n            }\n            if(g[i][j] == '*'){\n                wait.push({i, j});\n                mincost_spring[i][j] = 0;\n            }\n            if(g[i][j] == '.'){\n                n++;\n            }\n        }\n    }\n    bfs_grid(wait, g, mincost_spring);\n    vector<vector<int>> mincost_goal(h, vector<int>(w, inf));\n    mincost_goal[gy][gx] = 0;\n    wait.push({gy, gx});\n    bfs_grid(wait, g, mincost_goal);\n\n    long double lb=0, ub=1LL<<60;\n    for(int rep=0; rep<100; rep++){\n        long double mid = (lb +ub) /2;\n        long double sum = 0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(g[i][j] != '.') continue;\n                long double tmp = 1e18;\n                if(mincost_goal[i][j] != inf){\n                    tmp = min(tmp, (long double)mincost_goal[i][j]);\n                }\n                if(mincost_spring[i][j] != inf){\n                    tmp = min(tmp, mincost_spring[i][j] +mid);\n                }\n                sum += tmp;\n            }\n        }\n        if(n*mid > sum){\n            ub = mid;\n        }else{\n            lb = mid;\n        }\n    }\n    \n    long double ans = 1e18;\n    if(mincost_goal[sy][sx] != inf){\n        ans = min(ans, (long double)mincost_goal[sy][sx]);\n    }\n    if(mincost_spring[sy][sx] != inf){\n        ans = min(ans, mincost_spring[sy][sx] +lb);\n    }\n    cout << fixed << setprecision(12);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\n#define INF 1e18\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP; \nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fie[510][510];\nint dist[2][510][510];\nint w,h;\nvector<PP> vec;\nint sx,sy,gx,gy;\ntypedef long long ll;\n\nvoid bfs(int y=-1,int x=-1){\n\tqueue<P> que;\n\tint type=0;\n\tif(y==-1)type=1;\n\tmemset(dist[type],-1,sizeof(dist[type]));\n\tif(type==0){\n\t\tdist[type][y][x]=0;\n\t\tque.push(P(y,x));\n\t}else{\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==1){\n\t\t\t\t\tdist[type][i][j]=0;\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(abs(fie[ny][nx])!=1 && dist[type][ny][nx]==-1){\n\t\t\t\tdist[type][ny][nx]=dist[type][p.first][p.second]+1;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll cnt=0;\nll all=0;\nll okave=0;\nll ngave=0;\n\nlong double calc(int v){\n\tif((dist[0][sy][sx]!=-1 && dist[0][sy][sx]<=dist[1][sy][sx]+v) || dist[1][sy][sx]==-1)return dist[0][sy][sx];\n\telse{\n\t\tif(cnt==0)return INF;\n\t\tlong double va=(long double)okave/all;\n\t\tva*=(double)1.0*all/cnt;\n\t\tlong double vb=(long double)ngave/((long double)(all-cnt));\n\t\tvb*=(long double)1.0*all/cnt;\n\t\tvb-=(long double)ngave/((long double)(all-cnt));\n\t\treturn (long double)va+vb+dist[1][sy][sx];\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%*c\",&w,&h);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='#')fie[i][j]=-1;\n\t\t\tif(c=='s')sy=i,sx=j;\n\t\t\tif(c=='g')gy=i,gx=j;\n\t\t\tif(c=='*')fie[i][j]=1;\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tbfs(gy,gx);\n\tbfs();\n\tif(dist[1][sy][sx]==-1 || (dist[0][sy][sx]<=dist[1][sy][sx] && dist[0][sy][sx]!=-1)){\n\t\tprintf(\"%.10f\\n\",(double)dist[0][sy][sx]);\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\tall++;\n\t\t\t\tif(dist[0][i][j]!=-1 && dist[1][i][j]!=-1)vec.push_back(PP(dist[0][i][j]-dist[1][i][j],P(i,j)));\n\t\t\t\telse if(dist[0][i][j]==-1)ngave+=dist[1][i][j];\n\t\t\t\telse{\n\t\t\t\t\tokave+=dist[0][i][j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(vec.size()>0)sort(vec.begin(),vec.end());\n\tlong double res=INF;\n\tfor(int i=0;i<vec.size();i++){\n\t\tngave+=dist[1][vec[i].second.first][vec[i].second.second];\n\t}\n\tfor(int i=0;i<=vec.size();i++){\n\t\tres=min(res,calc(vec[i].first));\n\t\tif(i!=vec.size()){\n\t\t\tngave-=dist[1][vec[i].second.first][vec[i].second.second];\n\t\t\tcnt++;\n\t\t\tokave+=dist[0][vec[i].second.first][vec[i].second.second];\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",(double)res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n//#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nll d[512][512],INF=5e15,d2[512][512], dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  //  cout<<sizeof(ll)<<endl;\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[0]+512*512,INF);\n  fill(d2[0],d2[0]+512*512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  ll a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //    cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  //cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=1e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a-1==0)break;\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e160, M = 0;\n  rep(i,1020){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct point{\n  int x;\n  int y;\n  int count;\n};\n\nint main(){\n  int houkou[5]={0,1,0,-1,0};\n  int w,h;\n  cin >> w >> h;\n  vector<vector<int>> field(h,vector<int>(w));\n  list<struct point> spring;\n  char c;\n  int sx,sy,gx,gy;\n  int numofFloor=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<int>> toGoal(h,vector<int>(w,0));\n  vector<vector<int>> toSpring(h,vector<int>(w,0));\n  queue<struct point> bfs;\n  struct point now;\n  int nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(int i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(int i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  double left=0;\n  double right=(h-2)*(w-2)*(h-2)*(w-2);\n  double mid;\n  double count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(int i=1;i<h-1;i++){\n      for(int j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n  // cout << left << endl;\n  // cout << count << endl;\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  cout << fixed << setprecision(11);\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 16;\n\nconst int cmax=25010;\nint w,h;\nint d[cmax];\nint e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg){\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[25010];\n\nvoid dijkstra(char s,char o,int* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid show(int *dist){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tint idx=i*w+j;\n\t\t\tif(dist[idx]<10)\n\t\t\t\tcout << dist[idx];\n\t\t\telse\n\t\t\t\tcout << '-';\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tex[n].d=d[idx];\n\t\t\tex[n++].e=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\tdouble ans=d[sidx];\n\tll sum=0;\n\trep(i,n) sum+=ex[i].d;\n\tfor(int i=n;i>=1;--i){\n\n\t\tans=min(ans,1.0*sum/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tsum-=ex[cur].d;\n\t\tsum+=ex[cur].e;\n\t}\n\tcout.precision(12);\n\tcout << fixed << ans << endl;\n\tshow(d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0,c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc+=1.0;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12Lf %.12Lf\\n\",p, p-q);\n    return p-q;\n  };\n\n  Double l=0,r=1e10;\n\n  for(int k=0;k<200;k++){\n    Double m=(l+r)/2;\n    if(calc(m)<=0) l=m;\n    else r=m;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n\nconst int INF = 1e+15;\nconst double EPS = 1e-8;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,gx,gy;\nstring field[510];\n\ntemplate<class T = int>\nvector<vector<T>> bfs(int ind){\n\tusing P = pair<int,int>;\n\tvector<vector<T>> dist(h,vector<T>(w,INF));\n\tqueue<P> que;\n\tif(!ind){\n\t\tdist[gx][gy] = 0;\n\t\tque.emplace(gx,gy);\n\t}else{\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] == '*'){\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t\tque.emplace(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(T d = 0;;d++){\n\t\tint siz = que.size();\n\t\tif(siz == 0) break;\n\t\tfor(int i = 0;i < siz;i++){\n\t\t\tint x,y;\n\t\t\ttie(x,y) = que.front();que.pop();\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tint nx = x + dx[j],ny = y + dy[j];\n\t\t\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w\n\t\t\t\t&& field[nx][ny] != '#' && (ind || field[nx][ny] != '*')\n\t\t\t\t&& dist[nx][ny] == INF){ \n\t\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\t\tque.emplace(nx,ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin >> w >> h;\n\tfor(int i = 0;i < h;i++) cin >> field[i];\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] == 's') sx = i,sy = j;\n\t\t\tif(field[i][j] == 'g') gx = i,gy = j;\n\t\t}\n\t}\n\tauto dist1 = bfs(0),dist2 = bfs(1);\n\tint d = 0,xcnt = 0,cnt = 0;\n\tvector<int> vec;\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(field[i][j] != '#' && field[i][j] != '*'){\n\t\t\t\tcnt++;\n\t\t\t\tif(dist1[i][j] <= dist2[i][j]){\n\t\t\t\t\tif(dist1[i][j] != INF) d += dist1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\td += dist2[i][j];\n\t\t\t\t\txcnt++;\n\t\t\t\t\tif(dist1[i][j] != INF) vec.push_back(dist1[i][j] - dist2[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = dist1[sx][sy];\n\tsort(vec.begin(),vec.end());\n\tfor(int v : vec){\n\t\tdouble x = (double)d / (cnt - xcnt - 1);\n\t\t//cout << v << \" \" << x << \" \" << d << \" \" << cnt - xcnt << \" \" << endl;\n\t\tif(x < v + EPS) chmin(ans,dist2[sx][sy] + x);\n\t\td += v;\n\t\txcnt--;\n\t}\n\tdouble x = (double)d / (cnt - xcnt - 1);\n\tchmin(ans,dist2[sx][sy] + x);\n\tprintf(\"%.15lf\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\nchar c[523][523];\n\ntemplate<class A>\nvoid bfs(A &ds,queue<tuple<int,int,int> > que){\n  fill(*begin(ds),*end(ds),1e9);\n  while(!que.empty()){\n    auto cs=que.front();\n    que.pop();\n    int t=get<0>(cs);\n    int y=get<1>(cs);\n    int x=get<2>(cs);\n    if(ds[y][x]<=t)continue;\n    ds[y][x]=t;\n    for(int i=0;i<4;i++){\n      static const int d[]={0,1,0,-1,0};\n      int ny=y+d[i];\n      int nx=x+d[i+1];\n      if(c[ny][nx]!='#'){\n\tque.push(make_tuple(t+1,ny,nx));\n      }\n    }\n  }\n}\n\nint main(){\n  int W,H;\n  cin>>W>>H;\n  queue<tuple<int,int,int> > sque,gque;\n  int sy,sx;\n  int n=0;\n  for(int i=0;i<H;i++){\n    cin>>c[i];\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='s'){\n\tc[i][j]='.';\n\tsy=i;\n\tsx=j;\n      }else if(c[i][j]=='*'){\n\tsque.push(make_tuple(0,i,j));\n      }else if(c[i][j]=='g'){\n\tgque.push(make_tuple(0,i,j));\n      }\n      n+=c[i][j]=='.';\n    }\n  }\n  static int ds[523][523];\n  bfs(ds,sque);\n  static int dg[523][523];\n  bfs(dg,gque);\n  int gsum=0,ssum=0;\n  int xsum=0;\n  int gs[2555]={},ss[2555]={};\n  int xs[2555]={};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='.'){\n\tint cx=min(2500,max(0,dg[i][j]-ds[i][j]));\n\tgsum+=dg[i][j];\n\tgs[cx]+=dg[i][j];\n\tss[cx]+=ds[i][j];\n\txs[cx]++;\n      }\n    }\n  }\n  double ans=1e9;\n  for(int i=2500;i>=0;i--){\n    gsum-=gs[i];\n    ssum+=ss[i];\n    xsum+=xs[i];\n    if(xsum==n)continue;\n    ans=min(ans,(dg[sy][sx]-ds[sy][sx]>=i)?ds[sy][sx]+(gsum+ssum)*1./(n-xsum):dg[sy][sx]);\n  }\n  cout.precision(99);\n  cout<<fixed<<ans<<endl;\n}\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF (1070000000LL*1070000000LL)\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint H,W;\nchar c[555][555];\nint sy,sx,gy,gx;\nll dist1[555][555],dist2[555][555];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H;\n\trep(i,H)rep(j,W){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sy=i,sx=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gy=i,gx=j;\n\t}\n\trep(i,H)rep(j,W){\n\t\tdist1[i][j]=dist2[i][j]=INF;\n\t}\n\tdist1[gy][gx]=0;\n\tqueue<pi> Q;\n\tQ.push(mp(gy,gx));\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist1[ny][nx]==INF){\n\t\t\t\tdist1[ny][nx]=dist1[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H)rep(j,W)if(c[i][j]=='*'){\n\t\tdist2[i][j]=0;\n\t\tQ.push(mp(i,j));\n\t}\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist2[ny][nx]==INF){\n\t\t\t\tdist2[ny][nx]=dist2[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<ll> d1,d2;\n\tint start;\n\trep(i,H)rep(j,W)if(c[i][j]=='.'){\n\t\tif(i==sy && j==sx)start=sz(d1);\n\t\td1.pb(dist1[i][j]);\n\t\td2.pb(dist2[i][j]);\n\t}\n\t\n\tdouble lo=0,hi=1e15;\n\trep(t,100){\n\t\tdouble mi=(lo+hi)/2;\n\t\tdouble sum=0;\n\t\trep(i,sz(d1)){\n\t\t\tsum+=min(1.*d1[i],d2[i]+mi);\n\t\t}\n\t\tif(sum>mi*sz(d1))lo=mi;\n\t\telse hi=mi;\n\t}\n\tprintf(\"%.16f\\n\",min(1.*d1[start],d2[start]+hi));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<int>> d(h, vector<int>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<int>> ds(h,vector<int>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500*500;\n    while((r-l)>=1e-10){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\twhile( abs( maxExpectedValue - minExpectedValue ) > 1e-5L ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i = 0; i < (n); i++)\n#define fi first\n#define se second\n\nconst ll INF = 1e15;\n\nint W, H;\nvector<string> brd;\nvector<vector<ll> > dist_spring;\nvector<vector<ll> > dist_goal;\n\nbool check(int y, int x) {\n\treturn 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid bfs(queue<pii> q, vector<vector<ll> > & res) {\n\tll d = 0;\n\tqueue<pii> nex;\n\twhile(q.size()) {\n\t\twhile(q.size()) {\n\t\t\tpii crd;\n\t\t\tcrd = q.front(); q.pop();\n\t\t\tres[crd.fi][crd.se] = min(res[crd.fi][crd.se], d);\n\t\t\trep(i,4) {\n\t\t\t\tconst int dxy[] = {0,1,0,-1,0};\n\t\t\t\tint ny, nx;\n\t\t\t\tny = crd.fi + dxy[i];\n\t\t\t\tnx = crd.se + dxy[i+1];\n\t\t\t\tif(check(ny,nx) && (brd[ny][nx] == '.' || brd[ny][nx] == 's')\n\t\t\t\t\t\t&& res[ny][nx] == INF) {\n\t\t\t\t\tnex.push(pii(ny,nx));\n\t\t\t\t\tres[ny][nx] = d+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = nex;\n\t\twhile(nex.size()) nex.pop();\n\t\td++;\n\t}\n}\n\nvoid make_dist_spring() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_spring.push_back(vector<ll>(W, INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == '*')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_spring);\n}\n\nvoid make_dist_goal() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_goal.push_back(vector<ll>(W,INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == 'g')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_goal);\n}\n\nint main() {\n\tpii st;\n\tcin >> W >> H;\n\trep(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tbrd.push_back(s);\n\t\trep(j, W) {\n\t\t\tif(s[j] == 's')\n\t\t\t\tst = pii(i,j);\n\t\t}\n\t}\n\tmake_dist_spring();\n\tmake_dist_goal();\n\n\tdouble l, r, m;\n\tl = 0; r = INF;\n\trep(i,100) {\n\t\tm = (l+r) / 2;\n\t\tdouble a, b;\n\t\tll c, d, e;\n\t\ta = b = 0;\n\t\tc = d = e = 0;\n\t\trep(j, H) {\n\t\t\trep(k, W) {\n\t\t\t\tif(brd[j][k] == '.' || brd[j][k] == 's') {\n\t\t\t\t\ta += min((double)dist_goal[j][k], dist_spring[j][k] + m);\n\t\t\t\t\tif(dist_goal[j][k] > dist_spring[j][k] + m) {\n\t\t\t\t\t\td += dist_spring[j][k];\n\t\t\t\t\t\te++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\td += dist_goal[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = d + e * m;\n\t\tb = c * m;\n\t\tif(a > b)\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tcout << setprecision(15) << fixed <<\n\t\tmin((double)dist_goal[st.fi][st.se], dist_spring[st.fi][st.se] + m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\nlong double calc(long double E) {\n  long double nE = 0.0;\n  long double cnt = 0.0;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  return nE / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+20;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 200) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\nconst double inf = 1e30;\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = inf;\n\tif(dist[y][x]>=-0.5)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.5)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=inf,r=0;\n\t\n\twhile(l-r>l*1e-10){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = (l+r)/2;\n\t\tdouble ce=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tce+=cmin(y,x,m);\n\t\t}\n\t\tce/=dotnum;\n\t\tif(ce>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e10), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 1000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      //cout << springs[i].first << \" \" << springs[i].second << \"!\" << endl;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\t//cout << x << \" \" << y << endl;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j]/n;\n\t  //cout << exp[i][j] << endl;\n\t}\n      }\n    }\n    //cout << s << \" \" << mean << endl;\n    if(s < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n    //cout << mean << endl;\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  /*\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      cout << exp[i][j] << \" \";\n    }cout << endl;\n  }\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e160, M = 0;\n  rep(i,1020){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[600][600];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nlong double ijk[600][600];\nlong double ijk2[600][600];\nlong double eps=1e-10L;\npair<long double,pair<int,int> > v[1000000];\nint t[600][600];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\tijk[i][j]=ijk2[i][j]=1e20L;\n\tint sr,sc,gr,gc;\n\tqueue<pair<int,int> > Q;\n\tint cnt=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='s'){sr=i;sc=j;}\n\t\t\tif(str[i][j]=='g'){\n\t\t\t\tgr=i;gc=j;\n\t\t\t\tijk[i][j]=0;\n\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'&&str[i][j]!='*'&&str[i][j]!='g')cnt++;\n\twhile(Q.size()){\n\t\tint row=Q.front().first;\n\t\tint col=Q.front().second;Q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk[row+dx[i]][col+dy[i]]>eps+ijk[row][col]+1){\n\t\t\t\tijk[row+dx[i]][col+dy[i]]=ijk[row][col]+1;\n\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(str[i][j]=='*'){\n\t\t\tijk2[i][j]=0;\n\t\t\tQ.push(make_pair(i,j));\n\t\t}\n\t}\n\twhile(Q.size()){\n\t\tint row=Q.front().first;\n\t\tint col=Q.front().second;Q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk2[row+dx[i]][col+dy[i]]>eps+ijk2[row][col]+1){\n\t\t\t\tijk2[row+dx[i]][col+dy[i]]=ijk2[row][col]+1;\n\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\tint sz=0;\n\t\n\tlong double L=0;\n\tlong double R=0;\n\tint n=0;\n\tint m=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='s'||str[i][j]=='.'){\n\t\t\t\tif(ijk[i][j]<1e10L&&ijk2[i][j]<1e10L)\n\t\t\t\t\tv[sz++]=make_pair(ijk[i][j]-ijk2[i][j],make_pair(i,j));\n\t\t\t\telse if(ijk[i][j]<1e10L){\n\t\t\t\t\tn++;\n\t\t\t\t\tL+=ijk[i][j];\n\t\t\t\t}\n\t\t\t\telse if(ijk2[i][j]<1e10L){\n\t\t\t\t\tm++;\n\t\t\t\t\tR+=ijk2[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(v,v+sz);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tif(ijk[i][j]<1e10L&&ijk2[i][j]<1e10L)\n\t\tif(str[i][j]=='s'||str[i][j]=='.')R+=ijk2[i][j];\n\t}\n\tlong double ret=ijk[sr][sc];\n//\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t//\tprintf(\"%d %d: %Lf %Lf\\n\",i,j,ijk[i][j],ijk2[i][j]);\n\tfor(int i=0;i<=sz;i++){\n\t\tif(t[sr][sc]){\n\t\t\tbreak;\n\t\t}\n\t\tif(n+i){\n\t\t//\tprintf(\"%d: %Lf\\n\",i,ijk2[sr][sc]+R/(sz-i)*((long double)sz/i-1)+L/(n+i));\n\t\t\tret=min(ret,ijk2[sr][sc]+R/(m+sz-i)*((long double)(sz+m+n)/(n+i)-1)+L/(n+i));\n\t\t}\n\t\tif(i<sz){\n\t\t\tt[v[i].second.first][v[i].second.second]=1;\n\t\t\tL+=ijk[v[i].second.first][v[i].second.second];\n\t\t\tR-=ijk2[v[i].second.first][v[i].second.second];\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst long double INF = 1e10;\n\nusing vd = vector<long double>;\nusing V = vector<vd>;\n\nusing pi = pair<int,int>;\n\nconst int dy[4]={1,-1,0,0}, dx[4]={0,0,1,-1};\n\nint main(){\n    int w,h;\n    cin >>w >>h;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    auto IN = [&](int y, int x){\n        return 0<=y && y<h && 0<=x && x<w;\n    };\n\n    auto calc = [&](double m){\n        V dp(h,vd(w,INF));\n\n        queue<pi> que;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='g'){\n                dp[i][j]=0;\n                que.push({i,j});\n            }\n            if(s[i][j]=='*'){\n                dp[i][j]=m;\n                que.push({i,j});\n            }\n        }\n\n        while(!que.empty()){\n            pi pos = que.front();\n            que.pop();\n            rep(d,4){\n                int ny = pos.fi+dy[d], nx = pos.se+dx[d];\n                if(IN(ny,nx) && s[ny][nx]!='#' && s[ny][nx]!='*'){\n                    if(dp[ny][nx] > dp[pos.fi][pos.se]+1){\n                        dp[ny][nx] = dp[pos.fi][pos.se]+1;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n        }\n\n        return dp;\n    };\n\n    long double l=0, r=INF;\n    rep(loop,80){\n        long double m = (l+r)/2;\n        V E = calc(m);\n\n        int n = 0;\n        rep(i,h)rep(j,w)if(s[i][j]=='.' || s[i][j]=='s') ++n;\n\n        long double sumE = 0;\n        rep(i,h)rep(j,w){\n            if(s[i][j]=='.' || s[i][j]=='s') sumE += E[i][j]/n;\n        }\n\n        if(sumE<m) r=m;\n        else l=m;\n    }\n    // dbg(l);\n    // dbg(r-l);\n\n    V E = calc(l);\n    long double ans=-1;\n    rep(i,h)rep(j,w)if(s[i][j]=='s') ans = E[i][j];\n    printf(\"%.15Lf\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid minDist(const vector<string>& plane, char start, vector<vector<int> >& dist)\n{\n    int dy[] = {0, 0, -1, 1};\n    int dx[] = {-1, 1, 0, 0};\n\n    int h = plane.size();\n    int w = plane[0].size();\n    dist.assign(h, vector<int>(w, INT_MAX));\n\n    queue<pair<int, int> > q;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(plane[i][j] == start)\n                q.push(make_pair(i, j));\n        }\n    }\n    int n = 1;\n    while(!q.empty()){\n        queue<pair<int, int> > q1;\n        while(!q.empty()){\n            int y = q.front().first;\n            int x = q.front().second;\n            q.pop();\n            for(int i=0; i<4; ++i){\n                int y1 = y + dy[i];\n                int x1 = x + dx[i];\n                if(0 <= y1 && y1 < h && 0 <= x1 && x1 < w && plane[y1][x1] == '.' && dist[y1][x1] == INT_MAX){\n                    q1.push(make_pair(y1, x1));\n                    dist[y1][x1] = n;\n                }\n            }\n        }\n        ++ n;\n        q = q1;\n    }\n}\n\nint main()\n{\n    int w, h;\n    cin >> w >> h;\n\n    vector<string> c(h);\n    vector<vector<bool> > floor(h, vector<bool>(w, false));\n    int n = 0;  // 床の数\n    int sy, sx; // スタート位置\n    for(int i=0; i<h; ++i){\n        cin >> c[i];\n        for(int j=0; j<w; ++j){\n            if(c[i][j] == 's'){\n                sy = i;\n                sx = j;\n                c[i][j] = '.';\n            }\n            if(c[i][j] == '.'){\n                floor[i][j] = true;\n                ++ n;\n            }\n        }\n    }\n\n    vector<vector<int> > a, b; // ゴールまでの距離、バネまでの距離\n    minDist(c, 'g', a);\n    minDist(c, '*', b);\n\n    multiset<int> diff;\n    long long sum = 0;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(!floor[i][j])\n                continue;\n\n            sum += b[i][j];\n            diff.insert(a[i][j] - b[i][j]);\n        }\n    }\n\n    double ret = a[sy][sx];\n    for(int i=0; i<n; ++i){\n        sum += *diff.begin();\n        diff.erase(diff.begin());\n        ret = min(ret, b[sy][sx] + sum / (i + 1.0));\n    }\n    printf(\"%.10f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i = 0; i < (n); i++)\n#define fi first\n#define se second\n\nconst int INF = 1e9;\n\nint W, H;\nvector<string> brd;\nvector<vector<int> > dist_spring;\nvector<vector<int> > dist_goal;\n\nbool check(int y, int x) {\n\treturn 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid bfs(queue<pii> q, vector<vector<int> > & res) {\n\tint d = 0;\n\tqueue<pii> nex;\n\twhile(q.size()) {\n\t\twhile(q.size()) {\n\t\t\tpii crd;\n\t\t\tcrd = q.front(); q.pop();\n\t\t\tres[crd.fi][crd.se] = min(res[crd.fi][crd.se], d);\n\t\t\trep(i,4) {\n\t\t\t\tconst int dxy[] = {0,1,0,-1,0};\n\t\t\t\tint ny, nx;\n\t\t\t\tny = crd.fi + dxy[i];\n\t\t\t\tnx = crd.se + dxy[i+1];\n\t\t\t\tif(check(ny,nx) && (brd[ny][nx] == '.' || brd[ny][nx] == 's')\n\t\t\t\t\t\t&& res[ny][nx] == INF) {\n\t\t\t\t\tnex.push(pii(ny,nx));\n\t\t\t\t\tres[ny][nx] = d+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq = nex;\n\t\twhile(nex.size()) nex.pop();\n\t\td++;\n\t}\n}\n\nvoid make_dist_spring() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_spring.push_back(vector<int>(W, INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == '*')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_spring);\n}\n\nvoid make_dist_goal() {\n\tqueue<pii> q;\n\trep(i,H) {\n\t\tdist_goal.push_back(vector<int>(W,INF));\n\t\trep(j,W) {\n\t\t\tif(brd[i][j] == 'g')\n\t\t\t\tq.push(pii(i,j));\n\t\t}\n\t}\n\tbfs(q, dist_goal);\n}\n\nint main() {\n\tpii st;\n\tcin >> W >> H;\n\trep(i,H) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tbrd.push_back(s);\n\t\trep(j, W) {\n\t\t\tif(s[j] == 's')\n\t\t\t\tst = pii(i,j);\n\t\t}\n\t}\n\tmake_dist_spring();\n\tmake_dist_goal();\n\n\tdouble l, r, m;\n\tl = 0; r = 1e9;\n\trep(i,100) {\n\t\tm = (l+r) / 2;\n\t\tdouble a, b;\n\t\ta = b = 0;\n\t\trep(j, H) {\n\t\t\trep(k, W) {\n\t\t\t\tif(brd[j][k] == '.' || brd[j][k] == 's') {\n\t\t\t\t\ta += min((double)dist_goal[j][k], dist_spring[j][k] + m);\n\t\t\t\t\tb += m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a > b)\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tcout << setprecision(15) << fixed <<\n\t\tmin((double)dist_goal[st.fi][st.se], dist_spring[st.fi][st.se] + m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e15), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 1000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tlong double upper=1e20,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tlong double sum=0.0;\n\t\tlong double E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],(double)dist_spring[y][x]+(double)E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E-1e-10;\n\t\telse lower=E+1e-10;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(double)(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n#define double long double\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500.0*500*500*500;\n    rep(_,1000){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10llf\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nusing namespace std;\n\n#define int long long\n\nchar c[523][523];\n\ntemplate<class A>\nvoid bfs(A &ds,queue<tuple<int,int,int> > que){\n  fill(*begin(ds),*end(ds),1e9);\n  while(!que.empty()){\n    auto cs=que.front();\n    que.pop();\n    int t=get<0>(cs);\n    int y=get<1>(cs);\n    int x=get<2>(cs);\n    if(ds[y][x]<=t)continue;\n    ds[y][x]=t;\n    for(int i=0;i<4;i++){\n      static const int d[]={0,1,0,-1,0};\n      int ny=y+d[i];\n      int nx=x+d[i+1];\n      if(c[ny][nx]!='#'){\n\tque.push(make_tuple(t+1,ny,nx));\n      }\n    }\n  }\n}\n\nsigned main(){\n  int W,H;\n  cin>>W>>H;\n  queue<tuple<int,int,int> > sque,gque;\n  int sy,sx;\n  int n=0;\n  for(int i=0;i<H;i++){\n    cin>>c[i];\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='s'){\n\tc[i][j]='.';\n\tsy=i;\n\tsx=j;\n      }else if(c[i][j]=='*'){\n\tsque.push(make_tuple(0,i,j));\n      }else if(c[i][j]=='g'){\n\tgque.push(make_tuple(0,i,j));\n      }\n      n+=c[i][j]=='.';\n    }\n  }\n  static int ds[523][523];\n  bfs(ds,sque);\n  static int dg[523][523];\n  bfs(dg,gque);\n  int gsum=0,ssum=0;\n  int xsum=0;\n  int gs[2555]={},ss[2555]={};\n  int xs[2555]={};\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(c[i][j]=='.'){\n\tint cx=min<int> (2500,max<int>(0,dg[i][j]-ds[i][j]));\n\tgsum+=dg[i][j];\n\tgs[cx]+=dg[i][j];\n\tss[cx]+=ds[i][j];\n\txs[cx]++;\n      }\n    }\n  }\n  double ans=1e18;\n  for(int i=2500;i>=0;i--){\n    gsum-=gs[i];\n    ssum+=ss[i];\n    xsum+=xs[i];\n    if(xsum==n)continue;\n    ans=min(ans,(dg[sy][sx]-ds[sy][sx]>=i)?ds[sy][sx]+(gsum+ssum)*1./(n-xsum):dg[sy][sx]);\n  }\n  cout.precision(99);\n  cout<<fixed<<ans<<endl;\n}\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int inf = (1<<20);\nchar m[N][N+1];\nint dcost[N][N];//¼ÚS[ÜÅs­RXg\nint scost[N][N];//olðgÁ½ÌRXg\nvoid bfs(int r,int c,char s,int cost[N][N]){\n  queue<int> Q;\n  rep(i,r)rep(j,c)\n    if (m[i][j] == s)cost[i][j] = 0,Q.push(i*c+j);\n    else cost[i][j] = inf;\n  while(!Q.empty()){\n    int y = Q.front()/c,x=Q.front()%c;Q.pop();\n    //    cout << y <<\" \" << x << endl;\n    rep(i,4){\n      int ney = y+dy[i],nex = x+dx[i];\n      if (m[ney][nex] == '*' || m[ney][nex] == 'g' || m[ney][nex] == '#' || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n}\n\n//brute force,Æè ¦¸û©·éÜÅñµÄÝé\n//üÍªgs*Ý½¢ÈÌªéÆ¿éÂ\\«ª é\ndouble exp[N][N];\ndouble bf(int r,int c){\n  double e=0;//úÒlÌaðÁÄ¨­ÆðÉ§Â\n  double pos = 0;//olÅs­Â\\«Ì éêÌ\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '*' || m[i][j] == 'g' || m[i][j] == '#')continue;\n      exp[i][j] = dcost[i][j];\n      e += dcost[i][j];\n      if (m[i][j] == 's' || m[i][j] == '.')pos+=1;\n    }\n  }\n  while(true){\n    bool isupdate = false;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#')continue;//±±Íl¦È¢B\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + (e)/(pos);\n\t//printf(\"%d %d test %.10lf %.10lf\\n\",i,j,tmp,tmp2);\n\tif (exp[i][j] > min(tmp,tmp2)){\n\t  isupdate = true;\n\t  //cout <<\"olde \"<<  e << \" \" << exp[i][j] << endl;\n\t  e -= exp[i][j];\n\t  exp[i][j] = min(tmp,tmp2);\n\t  e += exp[i][j];\n\t  //cout <<\"newe \" <<e << \" \" << exp[i][j] <<  endl;\n\t}\n\tnewe += exp[i][j];\n      }\n    }\n    e = newe;\n    /*\n    cout <<\"debug \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tprintf(\"%.3lf \",exp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    cout <<\"--------------==\" << endl;\n    */\n    if (!isupdate)break;\n  }\n\n  rep(i,r)rep(j,c)if (m[i][j] == 's')return exp[i][j];\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)cin>>m[i];\n    bfs(r,c,'*',scost);\n    bfs(r,c,'g',dcost);\n    /*\n    cout <<\"scost \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tif (scost[i][j] == inf)cout << m[i][j] <<\"-  \";\n\telse printf(\"%2d  \",scost[i][j]);\n      }\n      cout << endl;\n    }\n    cout << endl;\n    cout << \"------------------------------\"<<endl;\n\n    cout <<\"dcost \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tif (dcost[i][j] == inf)cout << m[i][j] <<\"-  \";\n\telse printf(\"%2d  \",dcost[i][j]);\n      }\n      cout << endl;\n    }\n    cout << endl;\n    cout << \"------------------------------\"<<endl;\n    */\n    printf(\"%.10lf\\n\",bf(r,c));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint H, W;\ndouble ex[500][500];\nstring vs[500];\n\nusing D = pair<double,PII>;\nvoid bfs(PII p, VVI& dist){\n  queue<PII> q;\n  q.push(p);\n  dist[p.FF][p.SS] = 0.;\n  \n  while(!q.empty()){\n\tp = q.front();\n\tq.pop();\n\n\tREP(d,4){\n\t  PII np(p.FF + dy[d], p.SS + dx[d]);\n\t  if(vs[np.FF][np.SS] != '.')\n\t\tcontinue;\n\t  int nc = dist[p.FF][p.SS] + 1;\n\t  if(dist[np.FF][np.SS] > nc){\n\t\tdist[np.FF][np.SS] = nc;\n\t\tq.push(np);\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> W >> H;\n  REP(y,H) cin >> vs[y];\n  fill((double*)ex, (double*)ex+500*500, INF);\n\n  PII S, G;\n  vector<PII> star;\n  int sum = 0;\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] == 's'){\n\t  vs[y][x] = '.';\n\t  S = MP(y,x);\n\t  ++sum;\n\t}\n\telse if(vs[y][x] == 'g'){\n\t  G = MP(y,x);\n\t  ++sum;\n\t}\n\telse if(vs[y][x] == '*'){\n\t  star.PB(MP(y,x));\n\t}\n  }\n  shuffle(ALL(star), mt19937());\n\n  VVI dist(H, VI(W, INF));\n  bfs(G, dist);\n\n  VVI sp_dist(H, VI(W, INF));\n  for(auto&& p: star)\n\tbfs(p, sp_dist);\n\n  using LD = long double;\n  LD lb = 0., ub = 1e15;\n  REP(i,100){\n\tLD X = (lb + ub) / 2.;\n\tLD acc = 0.;\n\tint n = 0;\n\tREP(y,H) REP(x,W){\n\t  if(vs[y][x] == '.'){\n\t\t++n;\n\t\tif(dist[y][x] != INF){\n\t\t  if(sp_dist[y][x] != INF)\n\t\t\tacc += min((LD)dist[y][x], sp_dist[y][x] + X);\n\t\t  else\n\t\t\tacc += dist[y][x];\n\t\t}\n\t\telse\n\t\t  acc += sp_dist[y][x] + X;\n\t  }\n\t}\n\n\tif(acc / n < X)\n\t  ub = X;\n\telse\n\t  lb = X;\n  }\n\n  LD ans = 0.;\n  if(dist[S.FF][S.SS] != INF){\n\tif(sp_dist[S.FF][S.SS] != INF)\n\t  ans += min((LD)dist[S.FF][S.SS], sp_dist[S.FF][S.SS] + lb);\n\telse\n\t  ans += dist[S.FF][S.SS];\n  }\n  else\n\tans += sp_dist[S.FF][S.SS] + lb;\n  cout << fixed << setprecision(11) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n//#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nll d[512][512],INF=5e15,d2[512][512], dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  //  cout<<sizeof(ll)<<endl;\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[511]+512,INF);\n  fill(d2[0],d2[511]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  ll a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //    cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  //cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n//#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nll d[512][512],INF=5e15,d2[512][512];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  double a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //    cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  //cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\twhile( abs( maxExpectedValue - minExpectedValue ) > 1e-9L ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,60){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr long long INF = (1ll << 50);\n\nvoid bfs(int sx, int sy, const vector<string> &field, vector<vector<long long>> &dist) {\n\ttypedef pair<int, int> point;\n\n\tconstexpr int dx[] = {1, 0, -1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tqueue<point> que;\n\n\tque.push({sx, sy});\n\tdist[sy][sx] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().first;\n\t\tconst int y = que.front().second;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(field[ny][nx] == '.' && dist[ny][nx] > dist[y][x] + 1) {\n\t\t\t\tdist[ny][nx] = dist[y][x] + 1;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(double E, const vector<pair<long long, long long>> &values) {\n\tdouble sum = 0.0;\n\tfor(const auto &e : values) {\n\t\tsum += min<double>(e.first, e.second + E);\n\t}\n\treturn sum / values.size();\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(12);\n\n\tint w, h;\n\tcin >> w >> h;\n\n\tvector<string> field(h);\n\tfor(auto &e : field) cin >> e;\n\n\tint sx, sy;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 's') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j] = '.';\n\t\t\t\tgoto bfs_phase;\n\t\t\t}\n\t\t}\n\t}\n\nbfs_phase:;\n\n\tvector<vector<long long>> from_goal(h, vector<long long>(w, INF));\n\tvector<vector<long long>> from_spring(h, vector<long long>(w, INF));\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'g') {\n\t\t\t\tbfs(j, i, field, from_goal);\n\t\t\t}\n\t\t\telse if(field[i][j] == '*') {\n\t\t\t\tbfs(j, i, field, from_spring);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<long long, long long>> values;\n\tvalues.reserve(h * w);\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == '.') {\n\t\t\t\tvalues.emplace_back(from_goal[i][j], from_spring[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble L = 0.0, R = INF;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tconst double M = (L + R) / 2.0;\n\t\tif(calc(M, values) < M) {\n\t\t\tR = M;\n\t\t}\n\t\telse {\n\t\t\tL = M;\n\t\t}\n\t}\n\n\tcout << min<double>(from_goal[sy][sx], from_spring[sy][sx] + L) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 10000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >500)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#'||s[ny][nx]=='*') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0,c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc+=1.0;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12Lf %.12Lf\\n\",p, p-q);\n    return p-q;\n  };\n\n  Double l=0,r=1e15;\n\n  for(int k=0;k<300;k++){\n  //while(abs(calc(l))>1e-10){\n    Double m=(l+r)/2;\n    if(calc(m)<=Double(0)) l=m;\n    else r=m;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int W, H;\n    vector<string> F;\n    void input() {\n        cin >> W >> H;\n        F.clear(); F.resize(H);\n        cin >> F;\n    }\n\n    const int INF = INT_MAX / 8;\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {-1, 0, 1, 0};\n\n    vector< vector<int> > C; // from the stairs\n    vector< vector<int> > S; // from the nearest spring;\n\n    void bfs(int sy, int sx, vector< vector<int> >& M) {\n        assert(M.size() == H && M[0].size() == W);\n        queue< pair<int, int> > Q;\n        Q.push(make_pair(sy, sx));\n        M[sy][sx] = 0;\n        while (not Q.empty()) {\n            auto cur = Q.front(); Q.pop();\n            int cy = cur.first, cx = cur.second;\n            for (int i = 0; i < 4; i++) {\n                int ny = cy + dy[i],\n                    nx = cx + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (F[ny][nx] == '*') continue;\n                int ncost = M[cy][cx] + 1;\n                if (M[ny][nx] > ncost) {\n                    M[ny][nx] = ncost;\n                    Q.push(make_pair(ny, nx));\n                }\n            }\n        }\n    }\n\n    int N;\n    int X, Y;\n    void init() {\n        N = 0;\n        C = vector< vector<int> >(H, vector<int>(W, INF));\n        S = vector< vector<int> >(H, vector<int>(W, INF));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'g') {\n                    bfs(i, j, C);\n                } else if (F[i][j] == '*') {\n                    bfs(i, j, S);\n                } else if (F[i][j] == 's' || F[i][j] == '.') {\n                    if (F[i][j] == 's') {\n                        Y = i;\n                        X = j;\n                    }\n                    N++;\n                } else {\n                    assert(F[i][j] == '#');\n                }\n            }\n        }\n    }\n\n    real f(real x) {\n        real ret = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '.' || F[i][j] == 's') {\n                    ret += min(real(S[i][j]) + x, real(C[i][j]));\n                }\n            }\n        }\n        return ret / N;\n    }\n\n    real g(real x) {\n        return x - f(x);\n    }\n\n    void solve() {\n        init();\n        real lb = 0, ub = 1e8;\n        for (int i = 0; i < 10000; i++) {\n            real mid = (lb + ub) / 2;\n            (g(mid) < 0 ? lb : ub) = mid;\n        }\n        real x = lb;\n        //cerr << x << endl;\n        //cerr << S[Y][X] << endl;\n        //cerr << C[Y][X] << endl;\n        cout << fixed << setprecision(12) << min(real(C[Y][X]), S[Y][X] + x) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst double inf = 1e20;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\nvector<double> dist;\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, double> is_lower(const double e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, double> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] <= d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tdouble total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\tdouble ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\tdouble lb = 0, ub = inf / 2;\n\tdouble ans = 0;\n\tconst int max_step = 200;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=2000;\n\tlong double upper=100000000000.0,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tlong double sum=0.0;\n\t\tlong double E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((long double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((long double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tint maxn = 0;\n\trep(i,H) rep(j,W){\n\t\tif(vv1[i][j] != INF) maxn=max(maxn,vv1[i][j]);\n\t\tif(vv2[i][j] != INF) maxn=max(maxn,vv2[i][j]);\n\t}\n\tmap<pair<int,int>,int> ma;\n\tdouble bb = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] != '.') continue;\n\t\t\tint x = vv1[i][j];\n\t\t\tint y = vv2[i][j];\n\t\t\tint t = min(x,y);\n\t\t\tbb += t*p;\n\t\t\tx-=t;\n\t\t\ty-=t;\n\t\t\tpii z = pii(x,y);\n\t\t\tif(ma.count(z)==0) ma[z] = 0;\n\t\t\tma[z]+=1;\n\t\t}\n\t}\n\tlong double ans = 1e100;\n\trep(o,maxn+1){\n\t\tlong double a = 0;\n\t\tlong double b = bb;\n\t\tfor(auto x:ma){\n\t\t\tif(x.F.F-x.F.S <= o){\n\t\t\t\tb += p*x.F.F*x.S;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb += p*x.F.S*x.S;\n\t\t\t\ta += p*x.S;\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n//#define int long long\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\ndouble d[512][512],INF=5e15,d2[512][512];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  double a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //    cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  //cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e31;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e30;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=1e30;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 1000000000000000ll;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// 凸関数の極大な点をもとめる\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 100){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// 凹関数の極小な・を求める\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\nlong double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k){\n    const int N = v.size();\n    long double l = as[k];\n    long double r = bs[N] - bs[k];\n    return (l+r) / k;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n\n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    // 階段が近い → 遠い\n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n    map<tuple<int,int>,long double> memo;\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c + 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    long double ls = 1e-15;\n    long double rs = 1e15;\n    auto r = ternary_search_concave(f,ls,rs);\n\n    cout << fixed << setprecision(12);\n    cout << f(r) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#'||s[ny][nx]=='*') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0,c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc+=1.0;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12Lf %.12Lf\\n\",p, p-q);\n    return p-q;\n  };\n\n  Double l=0,r=1e15;\n\n  for(int k=0;k<300;k++){\n  //while(abs(calc(l))>1e-10){\n    Double m=(l+r)/2;\n    if(calc(m)<=Double(0)) l=m;\n    else r=m;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#define INF 1e12\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fie[510][510];\nint dist[2][510][510];\nint w,h;\nint cnt;\nint sx,sy,gx,gy;\ntypedef long long ll;\n\nvoid bfs(int y=-1,int x=-1){\n\tqueue<P> que;\n\tint type=0;\n\tif(y==-1)type=1;\n\tmemset(dist[type],-1,sizeof(dist[type]));\n\tif(type==0){\n\t\tdist[type][y][x]=0;\n\t\tque.push(P(y,x));\n\t}else{\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==1){\n\t\t\t\t\tdist[type][i][j]=0;\n\t\t\t\t\tque.push(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i],ny=p.first+dy[i];\n\t\t\tif(abs(fie[ny][nx])!=1 && dist[type][ny][nx]==-1){\n\t\t\t\tdist[type][ny][nx]=dist[type][p.first][p.second]+1;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(int v){\n\tif((dist[0][sy][sx]!=-1 && dist[0][sy][sx]<=dist[1][sy][sx]+v) || dist[1][sy][sx]==-1)return dist[0][sy][sx];\n\telse{\n\t\tint cnt=0;\n\t\tint all=0;\n\t\tll okave=0;\n\t\tll ngave=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\t\tall++;\n\t\t\t\t\tif(dist[0][i][j]==-1){\n\t\t\t\t\t\tngave+=dist[1][i][j];\n\t\t\t\t\t}else if(dist[0][i][j]<=dist[1][i][j]+v || dist[1][sy][sx]==-1){\n\t\t\t\t\t\tokave+=dist[0][i][j];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tngave+=dist[1][i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cnt==0)return INF;\n\t\tdouble va=(double)okave/all;\n\t\tva*=(double)1.0*all/cnt;\n\t\tdouble vb=(double)ngave/((double)(all-cnt));\n\t\tvb*=(double)1.0*all/cnt;\n\t\tvb-=(double)ngave/((double)(all-cnt));\n\t\treturn (double)va+vb+dist[1][sy][sx];\n\t}\n}\n\nint calc_ok(int v){\n\tint cnt=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fie[i][j]==0 && (i!=gy || j!=gx)){\n\t\t\t\tif(dist[0][i][j]==-1){\n\t\t\t\t}else if(dist[0][i][j]<=dist[1][i][j]+v || dist[1][sy][sx]==-1){\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tscanf(\"%d%d%*c\",&w,&h);\n\tmemset(fie,0,sizeof(fie));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='#')fie[i][j]=-1;\n\t\t\tif(c=='s')sy=i,sx=j;\n\t\t\tif(c=='g')gy=i,gx=j;\n\t\t\tif(c=='*')fie[i][j]=1;\n\t\t\tif(c=='.')cnt++;\n\t\t}\n\t\tscanf(\"%*c\");\n\t}\n\tbfs(gy,gx);\n\tbfs();\n\tif(dist[1][sy][sx]==-1 || (dist[0][sy][sx]<=dist[1][sy][sx] && dist[0][sy][sx]!=-1)){\n\t\tprintf(\"%.10f\\n\",(double)dist[0][sy][sx]);\n\t\treturn 0;\n\t}\n\tint l=1,r=w*h;\n\tfor(int i=0;i<30;i++){\n\t\tint mid=(l+r)/2;\n\t\tif(calc_ok(mid)==0){\n\t\t\tl=mid;\n\t\t}else{\n\t\t\tr=mid;\n\t\t}\n\t}\n\tr=w*h;\n\tif(dist[0][sy][sx]==-1){\n\t\tr=w*h;\n\t}else{\n\t\tr=dist[0][sy][sx]-dist[1][sy][sx]+1;\n\t}\n\tfor(int i=0;i<50;i++){\n\t\tint lm=(l*2+r)/3;\n\t\tint rm=(l+r*2)/3;\n\t\tdouble vl=calc(lm);\n\t\tdouble rl=calc(rm);\n\t\tif(vl<rl){\n\t\t\tr=rm;\n\t\t}else{\n\t\t\tl=lm;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",min(calc((l*2+r)/3),calc((l+r*2)/3)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e8;\n\nstruct point {\n\tint x, y;\n};\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\n\n// ret1: true if arg e < calculated e\n// ret2: expected s-g value if e is correct\npair<bool, double> is_lower(const double e, const vector<vector<char> >& f,\n\tconst point& s, const point& g, const vector<point>& spring)\n{\n\tstatic vector<double> dist;\n\tconst int w = f[0].size(), h = f.size();\n\n\tdist.resize(w * h);\n\tfill(dist.begin(), dist.end(), inf);\n\n\tqueue<pair<point, double> > q;\n\n\tq.push(make_pair(g, 0));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < inf)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tfor(auto sp : spring)\n\t\tq.push(make_pair(sp, e));\n\n\twhile(!q.empty()) {\n\n\t\tconst auto vd = q.front();\n\t\tconst auto v = vd.first;\n\t\tconst auto d = vd.second;\n\t\tq.pop();\n\t\tconst int idx = v.x * w + v.y;\n\n\t\tif(dist[idx] < d)\n\t\t\tcontinue;\n\t\tdist[idx] = d;\n\n\t\tfor(int dir = 0; dir < 4; ++dir) {\n\t\t\tconst int nx = v.x + dx[dir], ny = v.y + dy[dir];\n\t\t\tconst point vvv = {nx, ny};\n\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w)\n\t\t\t\tcontinue;\n\t\t\tchar c = f[nx][ny];\n\t\t\tif(c == '#' || c == '*')\n\t\t\t\tcontinue;\n\t\t\tq.push(make_pair(vvv, d + 1));\n\t\t}\n\t}\n\n\tdouble total = 0;\n\tint count = 0;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tconst int idx = i * w + j;\n\n\t\t\tif(c == '#' || c == 'g' || c == '*')\n\t\t\t\tcontinue;\n\n\t\t\ttotal += dist[idx];\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tbool ok = e < total / count;\n\tdouble ans = dist[s.x * w + s.y];\n\n\treturn make_pair(ok, ans);\n}\n\n\nint main()\n{\n\tint w, h;\n\tvector<vector<char> > f;\n\n\tscanf(\"%d%d\", &w, &h);\n\tf.resize(h);\n\tfor(int i = 0; i < h; ++i) {\n\t\tchar buf[1024];\n\t\tscanf(\"%s\", buf);\n\t\tfor(int j = 0; buf[j] != '\\0'; ++j)\n\t\t\tf[i].push_back(buf[j]);\n\t}\n\n\tvector<point> spring;\n\tpoint s, g;\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\n\t\t\tchar c = f[i][j];\n\t\t\tif(c == 's')\n\t\t\t\ts = {i, j};\n\t\t\telse if(c == 'g')\n\t\t\t\tg = {i, j};\n\t\t\telse if(c == '*')\n\t\t\t\tspring.push_back({i, j});\n\t\t}\n\t}\n\n\tdouble lb = 0, ub = 1e10;\n\tdouble ans = 0;\n\tconst int max_step = 200;\n\n\tfor(int step = 0; step < max_step; ++step) {\n\n\t\tdouble mid = (lb + ub) / 2;\n\n\t\tauto ret = is_lower(mid, f, s, g, spring);\n\t\tif(ret.first)\n\t\t\tlb = mid;\n\t\telse\n\t\t\tub = mid;\n\t\tans = ret.second;\n\t}\n\n\tprintf(\"%.20lf\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\nint INF = 1145141919893810;\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = INF;\n\t\t\tb[i][j] = INF;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = INF;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\t//if (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t//}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n#define double long double\n\nconstexpr int INF = (1 << 30);\n\nvoid bfs(int sx, int sy, const vector<string> &field, vector<vector<int>> &dist) {\n\ttypedef pair<int, int> point;\n\n\tconstexpr int dx[] = {1, 0, -1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tqueue<point> que;\n\n\tque.push({sx, sy});\n\tdist[sy][sx] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().first;\n\t\tconst int y = que.front().second;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(field[ny][nx] == '.' && dist[ny][nx] > dist[y][x] + 1) {\n\t\t\t\tdist[ny][nx] = dist[y][x] + 1;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\n\ndouble calc(double E, const vector<pair<int, int>> &values) {\n\tdouble sum = 0.0;\n\tfor(const auto &e : values) {\n\t\tsum += min<double>(e.first, e.second + E);\n\t}\n\treturn sum / values.size();\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(12);\n\n\tint w, h;\n\tcin >> w >> h;\n\n\tvector<string> field(h);\n\tfor(auto &e : field) cin >> e;\n\n\tint sx, sy;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 's') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j] = '.';\n\t\t\t\tgoto bfs_phase;\n\t\t\t}\n\t\t}\n\t}\n\nbfs_phase:;\n\n\tvector<vector<int>> from_goal(h, vector<int>(w, INF));\n\tvector<vector<int>> from_spring(h, vector<int>(w, INF));\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'g') {\n\t\t\t\tbfs(j, i, field, from_goal);\n\t\t\t}\n\t\t\telse if(field[i][j] == '*') {\n\t\t\t\tbfs(j, i, field, from_spring);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<int, int>> values;\n\tvalues.reserve(h * w);\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == '.') {\n\t\t\t\tvalues.emplace_back(from_goal[i][j], from_spring[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble L = 0.0, R = INF;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tconst double M = (L + R) / 2.0;\n\t\tif(calc(M, values) < M) {\n\t\t\tR = M;\n\t\t}\n\t\telse {\n\t\t\tL = M;\n\t\t}\n\t}\n\n\tcout << min<double>(from_goal[sy][sx], from_spring[sy][sx] + L) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,70){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e30;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e30;\n\tfor(int stage=0;stage<100;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=W*H;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nint w, h;\nchar g[512][512];\n\nint sx, sy;\nint gx, gy;\nint all;\n\nint dg[512][512];\nint ds[512][512];\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\n\nint main(){\n  scanf(\"%d%d\", &w, &h);\n  REP(i,h) scanf(\"%s\", g[i]);\n\n  queue<pair<int, int> > gq;\n  queue<pair<int, int> > sq;\n\n  REP(i,h) REP(j,w){\n    dg[i][j] = ds[i][j] = -1;\n\n    if(g[i][j] == '.' || g[i][j] == 's')\n      all++;\n\n    if(g[i][j] == 's'){\n      sx = j; sy = i;\n      g[i][j] = '.';\n    }else if(g[i][j] == 'g'){\n      gx = j; gy = i;\n      gq.push(make_pair(i, j));\n      dg[i][j] = 0;\n    }else if(g[i][j] == '*'){\n      sq.push(make_pair(i, j));\n      ds[i][j] = 0;\n    }\n  }\n\n  // bfs1\n  while(gq.size()){\n    int x = gq.front().second;\n    int y = gq.front().first;\n    gq.pop();\n\n    REP(i,4){\n      int xx = x + _dx[i];\n      int yy = y + _dy[i];\n      if(ISIN(xx, yy, w, h) &&\n         dg[yy][xx] == -1   &&\n         g[yy][xx] == '.'){\n        dg[yy][xx] = dg[y][x] + 1;\n        gq.push(make_pair(yy, xx));\n      }\n    }\n  }\n\n  // REP(i,h){ REP(j,w) printf(\"%2d \", dg[i][j]); puts(\"\"); }\n\n  // bfs2\n  while(sq.size()){\n    int x = sq.front().second;\n    int y = sq.front().first;\n    sq.pop();\n\n    REP(i,4){\n      int xx = x + _dx[i];\n      int yy = y + _dy[i];\n      if(ISIN(xx, yy, w, h) &&\n         ds[yy][xx] == -1   &&\n         g[yy][xx] == '.'){\n        ds[yy][xx] = ds[y][x] + 1;\n        sq.push(make_pair(yy, xx));\n      }\n    }\n  }\n\n  // REP(i,h) { REP(j,w) printf(\"%2d \", ds[i][j]); puts(\"\"); }\n\n  double ans = 1e10;\n  int cnt = 0;\n  int chokusetsu = 0;\n  int tospring   = 0;\n\n  if(dg[sy][sx] != -1) ans = dg[sy][sx];\n\n  // spring = p * chokusetsu + (1 - p) * (tospring + spring)\n  // p * spring = p * chokusetsu + (1 - p) * tospring\n  // spring = chokusetsu + (1 - p) / p * tospring\n\n  vector<pair<int, pair<int, int> > > pos;\n  REP(i,h) REP(j,w) if(g[i][j] == '.'){\n    int d = dg[i][j];\n    if(d == -1){\n      tospring += ds[i][j];\n    }else{\n      chokusetsu += d;\n      cnt++;\n      int dd = ds[i][j];\n      if(dd != -1 && dd < d){\n        pos.push_back(make_pair(-(d - dd), make_pair(i, j)));\n      }\n    }\n  }\n\n  sort(pos.begin(), pos.end());\n\n  size_t idx = 0;\n\n  while(idx != pos.size() && cnt != 0){\n    double p = (double)cnt / all;\n\n    // printf(\"cnt: %d, all: %d, ans: %.3f\\n\", cnt, all, ans);\n    if(cnt != all && ds[sy][sx] != -1)\n      ans = min(ans, ds[sy][sx] + (double)chokusetsu / cnt\n                + (1 - p) / p * ((double)tospring / (all - cnt)));\n\n    int d = pos[idx].first;\n\n    while(idx != pos.size() && pos[idx].first == d){\n      int x = pos[idx].second.second;\n      int y = pos[idx].second.first;\n\n      if(ds[y][x] != -1){\n        cnt--;\n        chokusetsu -= dg[y][x];\n        tospring   += ds[y][x];\n      }\n      idx++;\n    }\n\n  }\n\n  printf(\"%.10f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\ntypedef pair<double,mp> mmp;\n\n#include<cfloat>\nconst double DINF = 1e14;\nconst double eps = 1e-10;\n\nint w,h;\nint sy,sx,gy,gx;\ndouble dist[505][505]={};\ndouble mine[505][505]={};\nint gone[505][505];\nchar map[505][505];\n\nvector<mp> es;\n\nint dd[5]={1,0,-1,0,1};\ndouble dotnum = 0;\n\n\ndouble cmin(int y,int x,double e){\n\tdouble res = DINF;\n\tif(dist[y][x]>=-0.01)res=min(res,dist[y][x]);\n\tif(mine[y][x]>=-0.01)res=min(res,mine[y][x]+e);\n\treturn res;\n}\n\t\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",map[y]);\n\trep(y,h)rep(x,w){\n\t\tif(map[y][x]=='s'){\n\t\t\tsy=y; sx=x;\n\t\t\tmap[y][x]='.';\n\t\t\tdotnum+=1;\n\t\t}\n\t\telse if(map[y][x]=='g'){\n\t\t\tgy=y; gx=x;\n\t\t}\n\t\telse if(map[y][x]=='*')es.push_back(mp(y,x));\n\t\telse if(map[y][x]=='.')dotnum+=1;\n\t}\n\t\n\t\n\tqueue<mmp> bfs;\n\t\n\trep(y,h)rep(x,w)dist[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\t\n\tbfs.push(mmp(0,mp(gy,gx)));\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tdist[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\trep(y,h)rep(x,w)mine[y][x]=-1;\n\tmemset(gone,0,sizeof(gone));\n\trep(i,es.size()){\n\t\tbfs.push(mmp(0,es[i]));\n\t}\n\n\twhile(!bfs.empty()){\n\t\tmmp pa = bfs.front();\n\t\tbfs.pop();\n\t\tdouble nd = pa.fir;\n\t\tint ny = pa.sec.fir,\n\t\t\tnx = pa.sec.sec;\n\t\tif(gone[ny][nx])continue;\n\t\tgone[ny][nx]=1;\n\t\tmine[ny][nx]=nd;\n\t\trep(i,4){\n\t\t\tint ty = ny+dd[i],\n\t\t\t\ttx = nx+dd[i+1];\n\t\t\t\tif(map[ty][tx]!='.' || gone[ty][tx])continue;\n\t\t\tbfs.push(mmp(nd+1,mp(ty,tx)));\n\t\t}\n\t}\n\t\n\t/*\n\trep(y,h){\n\t\trep(x,w)printf(\"(%2d %2d) \",dist[y][x],mine[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\t\n\tdouble l=DINF;\n\tdouble r=0.0;\n\t\n\t//while((l-r)*2.0>(l+r)*esp){}\n\trep(k,100){\n\t\t//printf(\"%f %f\\n\",l,r);\n\t\tdouble m = (l+r)*0.5;\n\t\t//printf(\"%.10f %.10f %.10f\\n\",l,r,m);\n\t\tdouble zan=0,cs=0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(map[y][x]!='.')continue;\n\t\t\tdouble na = cmin(y,x,m),ce;\n\t\t\tce=cs + na + zan;\n\t\t\tzan=cs+na+zan-ce;\n\t\t\tcs=ce;\n\t\t}\n\t\tcs+=zan;\n\t\tif(cs/dotnum>m)r=m;\n\t\telse l=m;\n\t}\n\t//printf(\"%.10f %.10f\\n\",l,r);\n\t//printf(\"%.10f %.10f\\n\",dist[sy][sx],mine[sy][sx]);\n\tdouble ans = cmin(sy,sx,l);\n\tprintf(\"%.10f\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct position{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL w,h;\n  LL houkou[5]={0,1,0,-1,0};\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct position> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct position> bfs;\n  struct position now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n   // cout << numofFloor << endl;\n  cout << fixed << setprecision(12);\n  double left=0;\n  double right=10000000000000000;\n  double mid;\n  double count;\n  int spcount=0;\n  while(right-left>0.0000000002*right){\n    mid=(left+right)/2;\n    spcount=0;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              if((double)toGoal[i][j]<(double)toSpring[i][j]+(double)mid/(double)numofFloor){\n                count+=(double)toGoal[i][j];\n              }else{\n                count+=(double)toSpring[i][j];\n                spcount++;\n              }\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0){\n              count+=(double)toSpring[i][j];\n              spcount++;\n            }\n          }\n        }\n      }\n    }\n    count+=(double)mid*(double)spcount/(double)numofFloor;\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n    // cout << left << endl;\n    // cout << right << endl;\n    // cout << count << endl;\n    // cout << toSpring[sy][sx] << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nll INF = LLONG_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<ll> > dg(H, vector<ll>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<ll> > ds(H, vector<ll>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e18;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k > mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nchar field[600][600];\nint a[600][600];\nint b[600][600];\n\nvoid bfs(char start, int dist[][600]){\n  queue<int> que;\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, INF);\n  rep(i, H)rep(j, W){\n    if(field[i][j] == start){\n      dist[i][j] = 0;\n      que.push(i * W + j);\n    }\n  }\n  while(!que.empty()){\n    int p = que.front(); que.pop();\n    int x = p % W;\n    int y = p / W;\n    rep(i, 4){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      if((field[y2][x2] == '.' || field[y2][x2] == 's') && dist[y2][x2] == INF){\n\tdist[y2][x2] = dist[y][x] + 1;\n\tque.push(y2 * W + x2);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H){\n    int sy = 0, sx = 0;\n    rep(i, H)rep(j, W){\n      cin >> field[i][j];\n      if(field[i][j] == 's'){\n\tsy = i, sx = j;\n      }\n    }\n    bfs('*', a);\n    bfs('g', b);\n    double ub = 1e10;\n    double lb = 0;\n    rep(i, 300){\n      double mb = (ub + lb) / 2;\n      double sum = 0;\n      int cnt = 0;\n      rep(j, H)rep(k, W){\n\tif(field[j][k] == 's' || field[j][k] == '.'){\n\t  cnt++;\n\t  sum += min((double)b[j][k], a[j][k] + mb);\n\t}\n      }\n      if(mb > sum / cnt) ub = mb;\n      else lb = mb;\n    }\n    cout << fixed << setprecision(12) << min(lb+a[sy][sx],(double)b[sy][sx])<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint w,h,sx,sy,gx,gy,num,inf=1e8;\nstring s[500];\nint dg[500][500],db[500][500],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nvoid gbfs(int gx,int gy){\n\trep(i,h) rep(j,w) dg[i][j]=inf;\n\tdg[gx][gy]=0;\n\tqueue<PP> que;\n\tque.push(PP(dg[gx][gy],P(gx,gy)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&dg[nx][ny]==inf){\n\t\t\t\tdg[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(dg[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bbfs(){\n\tqueue<PP> que;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='*') db[i][j]=inf;\n\t\telse que.push(PP(0,P(i,j)));\n\t}\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tP p=pp.second;\n\t\trep(i,4){\n\t\t\tint nx=p.fs+dx[i],ny=p.sc+dy[i];\n\t\t\tif(s[nx][ny]!='#'&&s[nx][ny]!='*'&&db[nx][ny]==inf){\n\t\t\t\tdb[nx][ny]=pp.fs+1;\n\t\t\t\tque.push(PP(db[nx][ny],P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nbool check(long double x){\n\tlong double sum=0;\n\trep(i,h) rep(j,w) if(s[i][j]!='#'&&s[i][j]!='*') sum+=min(x+db[i][j],(long double)dg[i][j]);\n\treturn sum/num<x;\n}\nint main(){\n\tcin>>w>>h;\n\trep(i,h) cin>>s[i];\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]=='s') sx=i,sy=j,num++;\n\t\tif(s[i][j]=='g') gx=i,gy=j;\n\t\tif(s[i][j]=='.') num++;\n\t}\n\tgbfs(gx,gy);\n\tbbfs();\n\t/*bool flag=false;\n\trep(i,h) rep(j,w){\n\t\tif(s[i][j]!='#'&&dg[i][j]==inf&&db[i][j]==inf) flag=true;\n\t}\n\tif(flag){\n\t\tprintf(\"%d\\n\",dg[sx][sy]);\n\t\treturn 0;\n\t}*/\n\tlong double ub=1e20,lb=0;\n\twhile(ub-lb>1e-10){\n//\t\tcout<<ub<<\" \"<<lb<<endl;\n\t\tlong double mid=(ub+lb)/2;\n\t\tif(check(mid)) ub=mid;\n\t\telse lb=mid;\n\t}\n\tprintf(\"%.12f\\n\",(double)min(ub+db[sx][sy],(long double)dg[sx][sy]));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nint dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tint num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\te[i][j]=500*500*500;\n\t\t\tdist_goal[i][j]=500*500*500;\n\t\t\tdist_spring[i][j]=500*500*500;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n//\t\t\t\tif(e[y][x]>100) cout<<\"#    \" ;\n//\t\t\t\telse\n//\t\t\t\tprintf(\"%1.3lf \",e[y][x]);\n\t\t\t}\n//\t\t\tcout<<endl;\n\t\t}\n//\t\tcout<<endl;\n\t}\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=W*H;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%02d\\n\",dis[sti][stj]);\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=W*H;\n\tfor(int stage=0;stage<100;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=W*H;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long double EPS = 1e-10;\nconst int H = 500;\nconst int W = 500;\nconst int dy[4] = {-1,0,1,0};\nconst int dx[4] = {0,-1,0,1};\n\nstruct P{\n  int x, y;\n  P(int x=0, int y=0):x(x),y(y){}\n};\n\nstruct state{\n  P p;\n  int cnt;\n  state(P p=P(), int cnt=0):p(p),cnt(cnt){}\n};\n\n\nint w, h, dis_go[H][W], dis_sp[H][W];\nlong double cnt_nowall;\nP st, go;\nvector<P> v;\nbool wall[H][W];\n\nvoid init_dis(){\n  queue<state> q;\n  state u, u2;\n\n  cnt_nowall = 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      dis_go[i][j] = dis_sp[i][j] = -1;\n      cnt_nowall += !wall[i][j];\n    }\n  }\n\n  for(q.push(state(go, 0));!q.empty();){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      u2 = state(P(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n      if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n        dis_go[u2.p.y][u2.p.x] = u2.cnt;\n        q.push(u2);\n      }\n    }\n  }\n\n  for(int i=0;i<v.size();i++){\n    for(q.push(state(v[i], 0));!q.empty();){\n      u = q.front();\n      q.pop();\n      for(int j=0;j<4;j++){\n        u2 = state(P(u.p.x+dx[j], u.p.y+dy[j]), u.cnt+1);\n        if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n          dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n}\n\nlong double calc_exp(int base){\n  long double a = 1.0, b = 0.0, exp_go = 0.0;\n  \n  for(int i=1;i<h-1;i++){\n    for(int j=1;j<w-1;j++){\n      if(!wall[i][j]){\n        if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n          a -= 1.0 / cnt_nowall;\n          b += (long double)dis_sp[i][j] / cnt_nowall;\n        } else {\n          exp_go += (long double)dis_go[i][j] / cnt_nowall;\n        }\n      }\n    }\n  }\n  return (b + exp_go) / a;\n}\n\nlong double solve(){\n  long double ans = -1;\n\n  init_dis();\n\n  if(dis_go[st.y][st.x] != -1) ans = dis_go[st.y][st.x];\n\n  /*\n  for(int i=2;i<(h-2)*(w-2);i++){\n    if(i % ((h-2)*(w-2)/100) == 0) {\n      printf(\"%d: %.12f %.12f\\n\", i, calc_exp(i) + dis_sp[st.y][st.x], ans);\n      fflush(stdout);\n    }\n    if(dis_sp[st.y][st.x] == -1 || dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i){\n      break;\n    }  \n    if(ans < -0.9) ans = calc_exp(i) + dis_sp[st.y][st.x];\n    else ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n  }\n  */\n  \n  if(dis_sp[st.y][st.x] != -1){\n    int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n    long double res0, res1, res2;\n    if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n    while(ri - le >= 4){\n      mid1 = (le * 2 + ri) / 3;\n      mid2 = (le + ri * 2) / 3;\n      res0 = calc_exp(le) + dis_sp[st.y][st.x];\n      res1 = calc_exp(mid1) + dis_sp[st.y][st.x];\n      res2 = calc_exp(mid2) + dis_sp[st.y][st.x];\n      if(mid2 - mid1 <= 1) break;\n      if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n      else ri = mid2;\n    }\n    for(int i=le;i<le+5;i++) {\n      if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n      if(ans < -0.9) ans = calc_exp(i) + dis_sp[st.y][st.x];\n      else ans = min(ans, calc_exp(i) + dis_sp[st.y][st.x]);\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  char c;\n  while(cin >> w >> h){\n    v.clear();\n    int cnt = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> c;\n        wall[i][j] = true;\n        if(c == 's') st = P(j, i), wall[i][j] = false;\n        else if(c == 'g') go = P(j, i);\n        else if(c == '*') v.push_back(P(j, i)), cnt++;\n        else if(c == '.') wall[i][j] = false;\n      }\n    }    \n\n    printf(\"%.12Lf\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] != 'g' && c[i][j] != '#' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e160, M = 0;\n  rep(i,1020){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nint main()\n{\n    int W, H;\n    cin >> W >> H;\n    vector<vector<char>> field(H, vector<char>(W));\n    P s, g;\n    vector<P> spring;\n    int floor = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> field[i][j];\n            if (field[i][j] == 's') {\n                s = make_pair(i, j);\n                field[i][j] = '.';\n                floor++;\n            } else if (field[i][j] == 'g') {\n                g = make_pair(i, j);\n            } else if (field[i][j] == '*') {\n                spring.push_back(make_pair(i, j));\n            } else if (field[i][j] == '.') {\n                floor++;\n            }\n        }\n    }\n\n    constexpr int INF = 1 << 30;\n    vector<vector<int>> goal_dist(H, vector<int>(W, INF));\n    vector<vector<int>> spring_dist(H, vector<int>(W, INF));\n    vector<vector<bool>> used(H, vector<bool>(W, false));\n    queue<pair<P, int>> q;\n    q.push(make_pair(g, 0));\n    while (not q.empty()) {\n        const auto& s = q.front();\n        const int y = s.first.first;\n        const int x = s.first.second;\n        const int dist = s.second;\n        q.pop();\n        used[y][x] = true;\n        goal_dist[y][x] = dist;\n        for (int d = 0; d < 4; d++) {\n            const int newx = x + dir[d];\n            const int newy = y + dir[d + 1];\n            if (newx >= 0 and newx < W and newy >= 0 and newy < H and (not used[newy][newx]) and (field[newy][newx] == '.')) {\n                used[newy][newx] = true;\n                q.push(make_pair(make_pair(newy, newx), dist + 1));\n            }\n        }\n    }\n\n    fill(used.begin(), used.end(), vector<bool>(W, false));\n    for (const P& sp : spring) {\n        q.push(make_pair(sp, 0));\n    }\n\n    while (not q.empty()) {\n        const auto& s = q.front();\n        const int y = s.first.first;\n        const int x = s.first.second;\n        const int dist = s.second;\n        q.pop();\n        used[y][x] = true;\n        spring_dist[y][x] = dist;\n        for (int d = 0; d < 4; d++) {\n            const int newx = x + dir[d];\n            const int newy = y + dir[d + 1];\n            if (newx >= 0 and newx < W and newy >= 0 and newy < H and (not used[newy][newx]) and (field[newy][newx] == '.')) {\n                used[newy][newx] = true;\n                q.push(make_pair(make_pair(newy, newx), dist + 1));\n            }\n        }\n    }\n\n    ld inf = 0;\n    ld sup = 25000000;\n    constexpr int REP = 1000;\n    for (int i = 0; i < REP; i++) {\n        const ld mid = (inf + sup) / 2;\n        ld sum = 0;\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                if (field[y][x] == '.') {\n                    sum += min(spring_dist[y][x] + mid, (ld)goal_dist[y][x]);\n                }\n            }\n        }\n        const ld actual = sum / floor;\n        if (actual < mid) {\n            sup = mid;\n        } else {\n            inf = mid;\n        }\n    }\n\n    const int sy = s.first;\n    const int sx = s.second;\n    cout << fixed << setprecision(15) << min(spring_dist[sy][sx] + inf, (ld)goal_dist[sy][sx]) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n#define INF 0x3f3f3f3f\n#define EPS 1e-8\n\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n\nint main(){\n\tint H,W;\n\tcin>>W>>H;\n\tvector<string> v(H);\n\trep(i,H) cin>>v[i];\n\tvector<vint> vv1(H,vint(W,INF));\n\tvector<vint> vv2(H,vint(W,INF));\n\tpii s;\n\tqueue<pii> q1,q2;\n\tlong double p = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tif(v[i][j] == 'g'){\n\t\t\t\tq1.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == 's'){\n\t\t\t\ts=pii(i,j);\t\t\t\t\n\t\t\t\tv[i][j] = '.';\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t\telse if(v[i][j] == '*'){\n\t\t\t\tq2.push(pii(i,j));\n\t\t\t}\n\t\t\telse if(v[i][j] == '.'){\n\t\t\t\tp+=1.0;\n\t\t\t}\n\t\t}\n\t}\n\tp=1/p;\n\tint cnt = 0;\n\tint dd[]={0,1,0,-1,0};\n\twhile(q1.size()){\n\t\tint qs = q1.size();\n\t\trep(i,qs){\n\t\t\tpii top = q1.front();\n\t\t\tq1.pop();\n\t\t\tif(vv1[top.F][top.S]!=INF) continue;\n\t\t\tvv1[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq1.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tcnt = 0;\n\twhile(q2.size()){\n\t\tint qs = q2.size();\n\t\trep(i,qs){\n\t\t\tpii top = q2.front();\n\t\t\tq2.pop();\n\t\t\tif(vv2[top.F][top.S]!=INF) continue;\n\t\t\tvv2[top.F][top.S] = cnt;\n\t\t\trep(j,4){\n\t\t\t\tpii nex = top;\n\t\t\t\tnex.F += dd[j];\n\t\t\t\tnex.S += dd[j+1];\n\t\t\t\tif(v[nex.F][nex.S] == '#') continue;\n\t\t\t\tif(v[nex.F][nex.S] == '*') continue;\n\t\t\t\tq2.push(nex);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\tint maxn = 0;\n\trep(i,H) rep(j,W){\n\t\tmaxn=max(maxn,vv1[i][j]);\n\t\tmaxn=max(maxn,vv2[i][j]);\n\t}\n\tlong double ans = 1e100;\n\trep(o,maxn){\n\t\tlong double a = 0;\n\t\tlong double b = 0;\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(v[i][j] != '.') continue;\n\t\t\t\tif(vv1[i][j]-vv2[i][j] <= o){\n\t\t\t\t\tb += p*vv1[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tb += p*vv2[i][j];\n\t\t\t\t\ta += p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong double e = b/(1-a);\n\t\tlong double tmp;\n\t\tif(vv1[s.F][s.S]-vv2[s.F][s.S] <= o) tmp = vv1[s.F][s.S];\n\t\telse tmp = vv2[s.F][s.S] + e;\n\t\tans = min(ans,tmp);\n\t}\n\tcout<<fixed<<setprecision(20);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nint sy,sx, gy, gx;\nstring field[600];\ndouble dist[600][600];\n\nvoid dijkstra(int sx, int sy, double mb){\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, 1e20);\n  priority_queue<P,vector<P>, greater<P> > que;\n  que.push(P(0, sy * W + sx));\n  dist[sy][sx] = 0;\n  rep(i, H)rep(j, W){\n    if(field[i][j] == '*') {\n      dist[i][j] = mb;\n      que.push(P(mb, i * W + j));\n    }\n  }\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    double cost = p.first;\n\n    int x = p.second % W;\n    int y = p.second / W;\n    if(cost > dist[y][x] + EPS) continue;\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      if(field[y2][x2] == '.' && dist[y2][x2] > cost + 1){\n\tdist[y2][x2] = cost + 1;\n\tque.push(P(cost + 1, y2 * W + x2));\n      }\n    }\n  }\n}\n\nbool C(double mb){\n  dijkstra(gx, gy, mb);\n  int cnt = 0;\n  double sum = 0.0;\n  rep(i, H)rep(j, W){\n    //    cout << setw(6) << dist[i][j] << (j == W - 1 ? '\\n':' ');\n    if(field[i][j] == '.') sum += dist[i][j], cnt++;\n  }\n  return mb < sum / cnt;\n}\n\nint main(){\n  while(cin >> W >>H){\n\n    rep(i, H){\n      cin >> field[i];\n      rep(j, W){\n\tif(field[i][j] == 's') {\n\t  sx = j;\n\t  sy = i;\n\t  field[i][j] = '.';\n\t}\n\tif(field[i][j] == 'g'){\n\t  gx = j;\n\t  gy = i;\n\t}\n      }\n    }\n    double ub = 1e10;    \n    double lb = 0;\n    rep(i, 300){\n      double mb = (ub + lb) / 2;\n      if(C(mb)) lb = mb;\n      else ub = mb; \n    }\n    dijkstra(gx, gy, lb);\n    //    cout << lb << endl;\n    cout << fixed << setprecision(12) << dist[sy][sx] << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int inf = INT_MAX;\nchar m[N][N+1];\nint dcost[N][N];//¼ÚS[ÜÅs­RXg\nint scost[N][N];//olðgÁ½ÌRXg\nvoid bfs(int r,int c,char s,int cost[N][N]){\n  queue<int> Q;\n  rep(i,r)rep(j,c)\n    if (m[i][j] == s)cost[i][j] = 0,Q.push(i*c+j);\n    else cost[i][j] = inf;\n  while(!Q.empty()){\n    int y = Q.front()/c,x=Q.front()%c;Q.pop();\n    //    cout << y <<\" \" << x << endl;\n    rep(i,4){\n      int ney = y+dy[i],nex = x+dx[i];\n      if (m[ney][nex] == '*' || m[ney][nex] == 'g' || m[ney][nex] == '#' || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n}\n\n//brute force,Æè ¦¸û©·éÜÅñµÄÝé\n//üÍªgs*Ý½¢ÈÌªéÆ¿éÂ\\«ª é\ndouble exp[N][N];\ndouble bf(int r,int c){\n  double e=0;//úÒlÌaðÁÄ¨­ÆðÉ§Â\n  double pos = 0;//olÅs­Â\\«Ì éêÌ\n  int sy,sx;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '*' || m[i][j] == 'g' || m[i][j] == '#')continue;\n      exp[i][j] = dcost[i][j];\n      e += dcost[i][j];\n      pos++;\n      if (m[i][j] == 's')sy = i,sx = j;\n    }\n  }\n\n\n  double L = 0,R=1e20;\n  double ans = -1;\n  rep(i,300){\n    double mid = (L+R)/2.;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#' || m[i][j] == '*')continue;\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + mid/pos;\n\tnewe += min(tmp,tmp2);\n      }\n    }\n\n    //cout <<\"owari \" << newe <<\" \" << L << \" \" << mid <<\" \" << R << endl;\n    if (newe < mid){//\\zæè¬³©Á½\n      ans = mid;\n      R = mid - 1e-10;\n    }else {//\\zæèå«©Á½\n      L = mid + 1e-10;\n    }\n  }\n  //cout << ans<< \" \" << ans/pos << endl;\n  return  min((double)dcost[sy][sx],scost[sy][sx]+ans/pos);\n\n  /*\n  while(true){\n    bool isupdate = false;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#')continue;//±±Íl¦È¢B\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + (e)/(pos);\n\tif (exp[i][j] > min(tmp,tmp2)){\n\t  isupdate = true;\n\t  e -= exp[i][j];\n\t  exp[i][j] = min(tmp,tmp2);\n\t  e += exp[i][j];\n\t}\n\tnewe += exp[i][j];\n      }\n    }\n    e = newe;\n    cout <<\"debug \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tprintf(\"%.3lf \",exp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    cout <<\"--------------==\" << endl;\n\n    if (!isupdate)break;\n  }\n\n  double hoge = 0;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '#' || m[i][j] == 'g' || m[i][j] == '*')continue;\n      hoge += min((double)dcost[i][j],scost[i][j] + e/pos);\n      cout << min((double)dcost[i][j],scost[i][j] + e/pos) <<\" \" ;\n    }\n    cout << endl;\n  }\n  cout <<\"hoge \" << e <<\" \" << hoge/pos << endl;\n  */\n  rep(i,r)rep(j,c)if (m[i][j] == 's')return exp[i][j];\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)cin>>m[i];\n    bfs(r,c,'*',scost);\n    bfs(r,c,'g',dcost);\n    printf(\"%.12lf\\n\",bf(r,c));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\ntypedef long double lld;\ntypedef pair<lld,mp> lmp;\nint w,h;\n\nchar dat[505][505];\nlld ds[505][505];\n\nint sy,sx,gy,gx;\n\nint dd[5]={1,0,-1,0,1};\n\nvoid calcd(lld m){\n\tpque(lmp) que;\n\tque.push(lmp(0,mp(gy,gx)));\n\trep(y,h)rep(x,w){\n\t\tif(dat[y][x]=='*'){\n\t\t\tds[y][x]=m;\n\t\t\trep(i,4){\n\t\t\t\tint ty = y + dd[i],\n\t\t\t\t\ttx = x + dd[i+1];\n\t\t\t\tif(dat[ty][tx]!='.')continue;\n\t\t\t\tque.push(lmp(m+1,mp(ty,tx)));\n\t\t\t}\n\t\t}\n\t\telse ds[y][x]=-1;\n\t}\n\t\n\twhile(!que.empty()){\n\t\tlmp pa = que.top();\n\t\tque.pop();\n\t\tlld d = pa.fir;\n\t\tint y = pa.sec.fir,\n\t\t\tx = pa.sec.sec;\n\t\tif(ds[y][x]>=0)continue;\n\t\tds[y][x]=d;\n\t\trep(i,4){\n\t\t\tint ty = y + dd[i],\n\t\t\t\ttx = x + dd[i+1];\n\t\t\tif(dat[ty][tx]!='.')continue;\n\t\t\tif(ds[ty][tx]>=0)continue;\n\t\t\tque.push(lmp(d+1,mp(ty,tx)));\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&w,&h);\n\trep(y,h)scanf(\"%s\",dat[y]);\n\trep(y,h)rep(x,w){\n\t\tif(dat[y][x]=='s'){\n\t\t\tsy=y; sx=x; dat[y][x]='.';\n\t\t}\n\t\tif(dat[y][x]=='g'){\n\t\t\tgy=y; gx=x; \n\t\t}\n\t}\n\t\n\tlld l=1e-20,r=1e20;\n\twhile((r-l)/l>1e-15){\n\t\tlld m = (l+r)/2.0;\n\t\t//printf(\"%Lf %Lf\\n\",l,r);\n\t\tcalcd(m);\n\t\tint p = 0;\n\t\tlld s = 0;\n\t\trep(y,h)rep(x,w){\n\t\t\tif(dat[y][x]=='.'){\n\t\t\t\tp++; s+=ds[y][x];\n\t\t\t}\n\t\t}\n\t\ts /= p;\n\t\tif(s>=m)l = m;\n\t\telse r = m;\n\t}\n\t\n\tcalcd(l);\n\tprintf(\"%.15Lf\\n\",ds[sy][sx]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0;\n    Int c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc++;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12f %.12f\\n\",p, abs(p-q));\n    return abs(p-q);\n  };\n\n  Double l=0,r=1e12;\n  \n  while(calc(l)>1e-12){\n    Double m1=l+(r-l)/3;\n    Double m2=l+(r-l)/3*2;\n    if(calc(m1)<calc(m2)) r=m2;\n    else l=m1;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] != 'g' && c[i][j] != '#' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e60, M = 0;\n  rep(i,420){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(999999);\n\t\t\tgot[i].emplace_back(999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1e18;\n\twhile (amin + 1e-12 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<long double>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans = min(static_cast<long double>(got[sy][sx]), spt[sy][sx] + amin);\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  LL w,h;\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  double left=0;\n  double right=(h-2)*(w-2)*(h-2)*(w-2);\n  double mid;\n  double count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n  // cout << left << endl;\n  // cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  cout << fixed << setprecision(12);\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr int INF = (1 << 30);\n\ninline bool out(int x, int y, int w, int h) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nvoid bfs(int sx, int sy, const vector<string> &field, vector<vector<int>> &dist) {\n\ttypedef pair<int, int> point;\n\n\tconstexpr int dx[] = {1, 0, -1, 0};\n\tconstexpr int dy[] = {0, 1, 0, -1};\n\n\tconst int h = field.size();\n\tconst int w = field[0].size();\n\n\tqueue<point> que;\n\n\tque.push({sx, sy});\n\tdist[sy][sx] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().first;\n\t\tconst int y = que.front().second;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny, w, h) || field[ny][nx] != '.') continue;\n\t\t\tif(dist[ny][nx] > dist[y][x] + 1) {\n\t\t\t\tdist[ny][nx] = dist[y][x] + 1;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong double calc(long double E, const vector<pair<int, int>> &values) {\n\tlong double sum = 0.0;\n\tfor(const auto &e : values) {\n\t\tsum += min<long double>(e.first, e.second + E);\n\t}\n\treturn sum / values.size();\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(12);\n\n\tint w, h;\n\tcin >> w >> h;\n\n\tvector<string> field(h);\n\tfor(auto &e : field) cin >> e;\n\n\tint sx, sy;\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 's') {\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t\tfield[i][j] = '.';\n\t\t\t\tgoto bfs_phase;\n\t\t\t}\n\t\t}\n\t}\n\nbfs_phase:;\n\n\tvector<vector<int>> from_goal(h, vector<int>(w, INF));\n\tvector<vector<int>> from_spring(h, vector<int>(w, INF));\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'g') {\n\t\t\t\tbfs(j, i, field, from_goal);\n\t\t\t}\n\t\t\telse if(field[i][j] == '*') {\n\t\t\t\tbfs(j, i, field, from_spring);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<int, int>> values;\n\tvalues.reserve(h * w);\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == '.') {\n\t\t\t\tvalues.emplace_back(from_goal[i][j], from_spring[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double L = 0.0, R = INF;\n\tfor(int i = 0; i < 200; ++i) {\n\t\tconst long double M = (L + R) / 2.0;\n\t\tif(calc(M, values) < M) {\n\t\t\tR = M;\n\t\t}\n\t\telse {\n\t\t\tL = M;\n\t\t}\n\t}\n\n\tcout << min<long double>(from_goal[sy][sx], from_spring[sy][sx] + L) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500*500;\n    while((r-l)>=1e-10){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\ndouble ToGoal(int x, int y, double E) {\n  double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//double vs[510 * 510];\ndouble calc(double E) {\n  //double nE = 0.0;\n  int cnt = 0;\n  priority_queue<double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    double l = que.top();\n    que.pop();\n    double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    double left = 0.0;\n    double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 90) {\n        double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10f\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500.0*500*500*500;\n    while((r-l)>=1e-10){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_V 1000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 100000000000000;\n\nint h, w;\nP st, go;\nchar b[500][500];\nll gist[500][500], wist[500][500];\nqueue<P> que;\nint dh[4] = {1,0,-1,0};\nint dw[4] = {0,1,0,-1};\nint flo = 0;\n\nint main(){\n    cin >> w >> h;\n    rep(i,h) rep(j,w) cin >> b[i][j];\n    rep(i,h) rep(j,w){\n        if(b[i][j] == 's'){\n            st.first = i;\n            st.second = j;\n            b[i][j] = '.';\n        }\n        if(b[i][j] == '.'){\n            flo++;\n        }\n        if(b[i][j] == 'g'){\n            go.first = i;\n            go.second  = j;\n            b[i][j] = '.';\n        }\n    }\n    rep(i,h) rep(j,w){\n        gist[i][j] = INF;\n        wist[i][j] = INF;\n    }\n    gist[go.first][go.second] = 0;\n    que.push(go);\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(gist[nh][nw] <= gist[p.first][p.second]+1) continue;\n            gist[nh][nw] = gist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    rep(i,h) rep(j,w){\n        if(b[i][j] == '*'){\n            que.push(P(i,j));\n            wist[i][j] = 0;\n        }\n    }\n    while(!que.empty()){\n        P p = que.front();\n        que.pop();\n        rep(i,4){\n            int nh = p.first+dh[i];\n            int nw = p.second+dw[i];\n            if(0>nh||nh>=h||0>nw||nw>=w) continue;\n            if(b[nh][nw] != '.') continue;\n            if(wist[nh][nw] <= wist[p.first][p.second]+1) continue;\n            wist[nh][nw] = wist[p.first][p.second]+1;\n            que.push(P(nh,nw));\n        }\n    }\n    long double s = 0.0, e = 1000000000000.0, mid;\n    rep(u,1000){\n        mid = (s+e)/2.0;\n        long double sum = 0.0;\n        rep(i,h) rep(j,w){\n            if(b[i][j] == '.' && go != P(i,j)){\n                sum += min((long double)gist[i][j],wist[i][j]+mid);\n            }\n        }\n        sum /= (long double)flo;\n        if(mid > sum){\n            e = mid;\n        } else{\n            s = mid;\n        }\n    }\n    long double ans = min((long double)gist[st.first][st.second],wist[st.first][st.second]+mid);\n    printf(\"%Lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=1e8,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a-1==0)break;\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef long double Double;\n\nchar ba[500][500];\nint disg[500][500];\nint disb[500][500];\nbool visited[500][500];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\nint h,w;\nvoid bfs(int hoge[500][500], queue<pii> &Q, bool vis[500][500]) {\n  \n  while(!Q.empty()) {\n    pii p = Q.front(); Q.pop();\n    int y = p.first;\n    int x = p.second;\n    REP(k, 4) {\n      int yy = y+dy[k];\n      int xx = x+dx[k];\n      if (yy<0||yy>=h||xx<0||xx>=w) continue;\n      if (ba[yy][xx] != '.') continue;\n      if (vis[yy][xx]) continue;\n      vis[yy][xx] = 1;\n      hoge[yy][xx] = hoge[y][x] + 1;\n      Q.push(pii(yy,xx));\n    }\n  }  \n}\n\n// Cð½·àÌªub¤É èACð½·Å¬lðßéÆ«B\ntemplate<class T> T lower_search(T lb, T ub, bool (*C)(T)) {\n  REP(i, 100) {\n    T mid = (lb+ub)/2;\n    if (C(mid)) ub = mid;\n    else lb = mid;\n  }\n  return ub;\n}\n\nint num = 0;\n\nbool C(Double E) {\n  Double hoge = 0;\n  REP(i, h) {\n    REP(j, w) {\n      if (ba[i][j] == '.') {\n        if (disg[i][j] < disb[i][j] + E) {\n          hoge += disg[i][j];\n        } else {\n          hoge += disb[i][j] + E;\n        }\n      }\n    }\n  }\n  hoge /= num;\n  //cout << hoge << \" \"<< E << endl;\n  return  E >= hoge;\n}\n\nint main() {\n  cin >> w >> h;\n  int sx,sy,gx,gy;\n  queue<pii> Q;\n  memset(visited, 0, sizeof(visited));\n  REP(i,h)REP(j,w) disb[i][j] = disg[i][j] = INF;\n  num = 0;\n  REP(i, h) {\n    REP(j, w) {\n      cin >> ba[i][j];\n      if (ba[i][j] == 's') {\n        sx = j; sy = i;\n        ba[i][j] = '.';\n        num++;\n      } else if (ba[i][j] == 'g') {\n        gx = j; gy = i;\n      } else if (ba[i][j] == '*') {\n        Q.push(pii(i,j));\n        visited[i][j] = 1;\n        disb[i][j] = 0;\n      } else if (ba[i][j] == '.') {\n        num++;\n      }\n    }\n  }\n  bfs(disb, Q, visited);\n  \n  memset(visited,0,sizeof(visited));\n  disg[gy][gx] = 0;\n  visited[gy][gx] = 1;\n  Q.push(pii(gy,gx));\n  bfs(disg, Q, visited);\n\n  // REP(i, h) {\n  //   REP(j, w) {\n  //     if (disb[i][j] == INF) cout << \"* \";\n  //     else cout << disb[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  \n  // REP(i, h) {\n  //   REP(j, w) {\n  //     if (disg[i][j] >= INF)cout << \"* \";\n  //     else cout << disg[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  Double E = lower_search<Double>(0, INF, C);\n  Double ans = min((Double)disg[sy][sx],disb[sy][sx]+E);\n  printf(\"%.12Lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int w,h;\n    cin>>w>>h;\n    vector<string> c(h);\n    const long long int INF=1e15;\n    vector<vector<long long int>> spr(h,vector<long long int>(w,INF));\n    queue<pair<int,int>> que;\n    pair<int,int> s;\n    pair<int,int> g;\n    for(int i=0;i<h;i++){\n        cin>>c[i];\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='s'){\n                s={i,j};\n                c[i][j]='.';\n            }\n            if(c[i][j]=='g'){\n                g={i,j};\n            }\n            if(c[i][j]=='*'){\n                spr[i][j]=0;\n                que.push({i,j});\n            }\n        }\n    }\n\n    int dh[]={1,-1,0,0};\n    int dw[]={0,0,1,-1};\n    while(!que.empty()){\n       auto p=que.front();\n       que.pop();\n       for(int i=0;i<4;i++){\n        int th=p.first+dh[i];\n        int tw=p.second+dw[i];\n        if(c[th][tw]=='.' && spr[p.first][p.second]+1<spr[th][tw]){\n            spr[th][tw]=spr[p.first][p.second]+1;\n            que.push({th,tw});\n        }\n       }\n    }\n    vector<vector<long long int>> goal(h,vector<long long int>(w,INF));\n    goal[g.first][g.second]=0;\n    que.push({g.first,g.second});\n    while(!que.empty()){\n        auto p=que.front();\n        que.pop();\n        for(int i=0;i<4;i++){\n            int th=p.first+dh[i];\n            int tw=p.second+dw[i];\n            if(c[th][tw]=='.' && goal[p.first][p.second]+1<goal[th][tw]){\n            goal[th][tw]=goal[p.first][p.second]+1;\n            que.push({th,tw});\n            }\n        }\n       \n    }\n    int fcnt=0;\n    long long int sum1=0;\n    long long int sum2=0;\n    vector<pair<long long int,pair<int,int>>> ex;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='.'){\n                fcnt++;\n                if((goal[i][j]!=INF || spr[i][j]!=INF)){\n                    cout<<goal[s.first][s.second]<<endl;\n                    return 0;\n                }\n                long long int dis=goal[i][j]-spr[i][j];\n                if(dis<=0){\n                    sum1+=goal[i][j];\n                }\n                else{\n                    sum2+=spr[i][j];\n                    ex.push_back({dis,{i,j}});\n                }\n            \n            }\n        }\n    }\n    sort(ex.begin(),ex.end());\n    double resex=-1;\n    int inde=0;\n    \n    for(int x=1;x<=1000000;x++){//ex=[x,x+1)\n        for(;inde<ex.size();inde++){\n            if(ex[inde].first<=x){\n                int i=ex[inde].second.first;\n                int j=ex[inde].second.second;\n                sum1+=goal[i][j];\n                sum2-=spr[i][j];\n            }\n            else{\n                break;\n            }\n        }\n        const double EPS=1e-12;\n        if(ex.size()==inde){\n            double xa=double(sum1)/fcnt;\n            if(x-EPS<xa){\n                resex=xa;\n            }\n            break;\n        }\n        double xa=double(sum1+sum2)/fcnt/(1-(double(ex.size()-inde)/fcnt));\n        if(x-EPS<xa && xa<=x+1-EPS || (x==1000000 &&  x-EPS<xa)){\n            assert(resex==-1);\n            resex=xa;\n        }\n    }\n    assert(resex!=-1);\n    \n    cout<<fixed<<setprecision(10);\n    cout<<min<double>(goal[s.first][s.second],spr[s.first][s.second]+resex)<<endl;\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct position{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL w,h;\n  LL houkou[5]={0,1,0,-1,0};\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct position> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct position> bfs;\n  struct position now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  double left=0;\n  double right=10000000000000000;\n  double mid;\n  double count;\n  while(right-left>0.00000000000001*right){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   // cout << left << endl;\n   // cout << right << endl;\n   // cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint H, W, sx, sy, gx, gy, dist1[509][509], dist2[509][509]; char c[509][509];\n\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> c[i][j]; dist1[i][j] = (1 << 30); dist2[i][j] = (1 << 30);\n\t\t\tif (c[i][j] == 's') { sx = i; sy = j; }\n\t\t\tif (c[i][j] == 'g') { gx = i; gy = j; }\n\t\t}\n\t}\n\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }; queue<pair<int, int>>Q;\n\tdist1[gx][gy] = 0; Q.push(make_pair(gx, gy));\n\n\twhile (!Q.empty()) {\n\t\tpair<int, int>a1 = Q.front(); Q.pop();\n\t\tint cx = a1.first, cy = a1.second;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint px = cx + dx[i], py = cy + dy[i];\n\t\t\tif (c[px][py] == '#') continue;\n\t\t\tif (dist1[px][py] > dist1[cx][cy] + 1) {\n\t\t\t\tdist1[px][py] = dist1[cx][cy] + 1;\n\t\t\t\tQ.push(make_pair(px, py));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (c[i][j] == '*') { dist2[i][j] = 0; Q.push(make_pair(i, j)); }\n\t\t}\n\t}\n\tif (Q.empty()) {\n\t\tcout << dist1[sx][sy] << endl;\n\t\treturn 0;\n\t}\n\n\twhile (!Q.empty()) {\n\t\tpair<int, int>a1 = Q.front(); Q.pop();\n\t\tint cx = a1.first, cy = a1.second;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint px = cx + dx[i], py = cy + dy[i];\n\t\t\tif (c[px][py] == '#') continue;\n\t\t\tif (dist2[px][py] > dist2[cx][cy] + 1) {\n\t\t\t\tdist2[px][py] = dist2[cx][cy] + 1;\n\t\t\t\tQ.push(make_pair(px, py));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong double L = 0.0L, R = 1e12, M;\n\tfor (int i = 0; i < 100; i++) {\n\t\tM = (L + R) / 2;\n\t\tint cnt = 0; long double sum = 0;\n\t\tfor (int j = 1; j <= H; j++) {\n\t\t\tfor (int k = 1; k <= W; k++) {\n\t\t\t\tif (c[j][k] == '#' || c[j][k] == '*' || c[j][k] == 'g') continue;\n\t\t\t\tcnt++;\n\t\t\t\tsum += min(M + dist2[j][k], 1.0L*dist1[j][k]);\n\t\t\t}\n\t\t}\n\t\tif (1.0L*sum / cnt < M) { R = M; }\n\t\telse { L = M; }\n\t}\n\tprintf(\"%.12Lf\\n\", min(M + dist2[sx][sy], 1.0L * dist1[sx][sy]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<int>>fi;\n\nvector<vector<int>>spt, got;\n\nstruct aa {\n\tint y;\n\tint x;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\n\nclass Compare {\npublic:\n\t//keiroが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time>r.time;\n\t}\n};\n\nint main() {\n\tint W, H; cin >> W >> H;\n\tint sx, sy;\n\tpair<int, int>gp;\n\tvector<pair<int, int>>sps;\n\tfi.resize(H);\n\tspt.resize(H);\n\tgot.resize(H);\n\tfor (int i = 0; i < H; ++i) {\n\t\t\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tspt[i].emplace_back(999999);\n\t\t\tgot[i].emplace_back(999999);\n\t\t\tint wh;\n\t\t\tif (st[j] == '.') {\n\t\t\t\twh = 0;\n\t\t\t}\n\t\t\telse if (st[j] == '#') {\n\t\t\t\twh = 1;\n\t\t\t}\n\t\t\telse if (st[j] == '*') {\n\t\t\t\twh = 2;\n\t\t\t\tsps.push_back(make_pair(i, j));\n\t\t\t}\n\t\t\telse if (st[j] == 's') {\n\t\t\t\twh = 0;\n\t\t\t\tsx = j; sy = i;\n\t\t\t}\n\t\t\telse if (st[j] == 'g') {\n\t\t\t\twh = 4;\n\t\t\t\tgp.first = i;\n\t\t\t\tgp.second = j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tfi[i].push_back(wh);\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tfor (int i = 0; i < sps.size(); ++i) {\n\t\t\tque.push(aa{ sps[i].first, sps[i].second, 0 });\n\t\t\tspt[sps[i].first][ sps[i].second] = 0;\n\t\t}\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (spt[ny][nx] > nt) {\n\t\t\t\t\t\tspt[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\t{\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ gp.first, gp.second, 0 });\n\t\tgot[gp.first][gp.second] = 0;\n\t\t\n\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int nx = atop.x + dx[i];\n\t\t\t\tconst int ny = atop.y + dy[i];\n\t\t\t\tconst int nt = atop.time + 1;\n\t\t\t\tif (!fi[ny][nx]) {\n\t\t\t\t\tif (got[ny][nx] > nt) {\n\t\t\t\t\t\tgot[ny][nx] = nt;\n\t\t\t\t\t\tque.push(aa{ ny,nx,nt });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong double amin = 0;\n\tlong double amax = 1000000000;\n\twhile (amin + 1e-11 < amax) {\n\t\tlong double amid = (amin + amax) / 2;\n\n\t\tlong double timesum = 0;\n\t\tlong double placesum = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (!fi[y][x]) {\n\t\t\t\t\tplacesum++;\n\t\t\t\t\ttimesum += min(static_cast<long double>(got[y][x]), spt[y][x] + amid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (amid < timesum / placesum) {\n\t\t\tamin = amid;\n\t\t}\n\t\telse {\n\t\t\tamax = amid;\n\t\t}\n\t}\n\tlong double ans = min(static_cast<long double>(got[sy][sx]), spt[sy][sx] + amin);\n\tcout <<fixed<<setprecision(22)<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\nint INF = 1145141919893810;\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = INF;\n\t\t\tb[i][j] = INF;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = INF;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\tif (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 10000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >1000)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 2147483600\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  bool canReachSpring = false;\n\n  vector<vector<int>> d(h, vector<int>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n        if(vec[nx][ny]=='*') canReachSpring=true;\n      }\n    }\n  }\n\n  vector<vector<int>> ds(h,vector<int>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  if(canReachSpring){\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500*500;\n    while((r-l)>=1e-10){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int W, H;\n    vector<string> F;\n    void input() {\n        cin >> W >> H;\n        F.clear(); F.resize(H);\n        cin >> F;\n    }\n\n    const real INF = 1e200;\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {-1, 0, 1, 0};\n\n    vector< vector<real> > C; // from the stairs\n    vector< vector<real> > S; // from the nearest spring;\n\n    void bfs(int sy, int sx, vector< vector<real> >& M) {\n        assert(M.size() == H && M[0].size() == W);\n        queue< pair<int, int> > Q;\n        Q.push(make_pair(sy, sx));\n        M[sy][sx] = 0;\n        while (not Q.empty()) {\n            auto cur = Q.front(); Q.pop();\n            int cy = cur.first, cx = cur.second;\n            for (int i = 0; i < 4; i++) {\n                int ny = cy + dy[i],\n                    nx = cx + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (F[ny][nx] == '*') continue;\n                real ncost = M[cy][cx] + 1;\n                if (M[ny][nx] > ncost) {\n                    M[ny][nx] = ncost;\n                    Q.push(make_pair(ny, nx));\n                }\n            }\n        }\n    }\n\n    int N;\n    int X, Y;\n    void init() {\n        N = 0;\n        C = vector< vector<real> >(H, vector<real>(W, INF));\n        S = vector< vector<real> >(H, vector<real>(W, INF));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'g') {\n                    bfs(i, j, C);\n                } else if (F[i][j] == '*') {\n                    bfs(i, j, S);\n                } else if (F[i][j] == 's' || F[i][j] == '.') {\n                    if (F[i][j] == 's') {\n                        Y = i;\n                        X = j;\n                    }\n                    N++;\n                } else {\n                    assert(F[i][j] == '#');\n                }\n            }\n        }\n    }\n\n    real f(real x) {\n        real ret = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '.' || F[i][j] == 's') {\n                    ret += min(S[i][j] + x, C[i][j]);\n                }\n            }\n        }\n        return ret / N;\n    }\n\n    real g(real x) {\n        return x - f(x);\n    }\n\n    void solve() {\n        init();\n        real lb = 0, ub = INF;\n        for (int i = 0; i < 1000; i++) {\n            //if (i % 100 == 0) cerr << i << endl;\n            real mid = (lb + ub) / 2;\n            (g(mid) < 0 ? lb : ub) = mid;\n        }\n        real x = lb;\n        //cerr << \"x: \" << x << endl;\n        //cerr << S[Y][X] << endl;\n        cout << fixed << setprecision(12) << min(C[Y][X], S[Y][X] + x) << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr int dir[5] = {0, 1, 0, -1, 0};\n\nint main()\n{\n    ll W, H;\n    cin >> W >> H;\n    vector<vector<char>> field(H, vector<char>(W));\n    P s, g;\n    vector<P> spring;\n    ll floor = 0;\n    for (ll i = 0; i < H; i++) {\n        for (ll j = 0; j < W; j++) {\n            cin >> field[i][j];\n            if (field[i][j] == 's') {\n                s = make_pair(i, j);\n                field[i][j] = '.';\n                floor++;\n            } else if (field[i][j] == 'g') {\n                g = make_pair(i, j);\n            } else if (field[i][j] == '*') {\n                spring.push_back(make_pair(i, j));\n            } else if (field[i][j] == '.') {\n                floor++;\n            }\n        }\n    }\n\n    constexpr ll INF = 1LL << 60;\n    vector<vector<ll>> goal_dist(H, vector<ll>(W, INF));\n    vector<vector<ll>> spring_dist(H, vector<ll>(W, INF));\n    vector<vector<bool>> used(H, vector<bool>(W, false));\n    queue<pair<P, ll>> q;\n    q.push(make_pair(g, 0));\n    while (not q.empty()) {\n        const auto& s = q.front();\n        const ll y = s.first.first;\n        const ll x = s.first.second;\n        const ll dist = s.second;\n        q.pop();\n        used[y][x] = true;\n        goal_dist[y][x] = dist;\n        for (ll d = 0; d < 4; d++) {\n            const ll newx = x + dir[d];\n            const ll newy = y + dir[d + 1];\n            if (newx >= 0 and newx < W and newy >= 0 and newy < H and (not used[newy][newx]) and (field[newy][newx] == '.')) {\n                used[newy][newx] = true;\n                q.push(make_pair(make_pair(newy, newx), dist + 1));\n            }\n        }\n    }\n\n    fill(used.begin(), used.end(), vector<bool>(W, false));\n    for (const P& sp : spring) {\n        q.push(make_pair(sp, 0));\n    }\n\n    while (not q.empty()) {\n        const auto& s = q.front();\n        const ll y = s.first.first;\n        const ll x = s.first.second;\n        const ll dist = s.second;\n        q.pop();\n        used[y][x] = true;\n        spring_dist[y][x] = dist;\n        for (ll d = 0; d < 4; d++) {\n            const ll newx = x + dir[d];\n            const ll newy = y + dir[d + 1];\n            if (newx >= 0 and newx < W and newy >= 0 and newy < H and (not used[newy][newx]) and (field[newy][newx] == '.')) {\n                used[newy][newx] = true;\n                q.push(make_pair(make_pair(newy, newx), dist + 1));\n            }\n        }\n    }\n\n    ld inf = 0;\n    ld sup = 10000000000;\n    constexpr ll REP = 1000;\n    for (ll i = 0; i < REP; i++) {\n        const ld mid = (inf + sup) / 2;\n        ld sum = 0;\n        for (ll y = 0; y < H; y++) {\n            for (ll x = 0; x < W; x++) {\n                if (field[y][x] == '.') {\n                    sum += min(spring_dist[y][x] + mid, (ld)goal_dist[y][x]);\n                }\n            }\n        }\n        const ld actual = sum / floor;\n        if (actual < mid) {\n            sup = mid;\n        } else {\n            inf = mid;\n        }\n    }\n\n    const ll sy = s.first;\n    const ll sx = s.second;\n    cout << fixed << setprecision(15) << min(spring_dist[sy][sx] + inf, (ld)goal_dist[sy][sx]) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  long double nE = 0.0;\n  int cnt = 0;\n  //priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      //que.push(-ToGoal(x, y, E));\n      nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  //REP(i, cnt - 1) {\n    //nE += vs[i];\n    //long double l = que.top();\n    //que.pop();\n    //long double r = que.top();\n    //que.pop();\n    //que.push(l + r);\n  //}\n  return nE / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 1.0;\n    long double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 80) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst double INF = 1e18;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(double dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1.0 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    double dist_goal[500][500], dist_spring[500][500];\n    REP(y, H) REP(x, W) dist_goal[y][x] = dist_spring[y][x] = -1.0;\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e18;\n    REP(_, 200){\n      const long double sum = (ub + lb) * 0.5;\n      long double S = 0;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        long double exp = min((long double)dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S += exp;\n      }\n      if(sum - S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = lb / N;\n    printf(\"%.12f\\n\", min((double)dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\n\nint main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = 11451419;\n\t\t\tb[i][j] = 11451419;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = 1145141919;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\tif (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/rational.hpp>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  LL w,h;\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> left=0;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> right=10000000000000000000;\n   cout << left << endl;\n   cout << right << endl;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> mid;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor);\n            }else{\n              count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   cout << left << endl;\n   cout << right << endl;\n   cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << \" \";\n  //         }else{\n  //           cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << endl;\n    }else{\n      cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e10), l = 0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 10000; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0;\n    double mean = (l+r)/2;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      //cout << springs[i].first << \" \" << springs[i].second << \"!\" << endl;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\t//cout << x << \" \" << y << endl;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0 || M[x_][y_] == '#') continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    double s = 0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j]/n;\n\t  //cout << exp[i][j] << endl;\n\t}\n      }\n    }\n    //cout << s << \" \" << mean << endl;\n    if(s < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n    //cout << mean << endl;\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  /*\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      cout << exp[i][j] << \" \";\n    }cout << endl;\n  }\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,80){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nint dist_goal[500][500],dist_spring[500][500];\n\nint main()\n{\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tint num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\te[i][j]=500*500*500;\n\t\t\tdist_goal[i][j]=500*500*500;\n\t\t\tdist_spring[i][j]=500*500*500;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='.' || M[y][x]=='s') sum+=e[y][x];\n\t\t\t}\n\t\t}\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\te[y][x]=min((double)dist_goal[y][x],dist_spring[y][x]+sum/(double)num_normal);\n\t\t\t}\n\t\t}\n\t}\n\tif(e[sy][sx]>500*500+1) cout<<0/0<<endl;\n\tprintf(\"%.13lf\\n\",e[sy][sx]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> c(h);\n  for(int i=0;i<h;i++){\n    cin>>c[i];\n  }\n  const int INF=1e9;\n  vector<vector<int>> spr(h,vector<int>(w,INF));\n  queue<pair<int,int>> que;\n  pair<int,int> s;\n  pair<int,int> t;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(c[i][j]=='s'){\n\ts={i,j};\n\tc[i][j]='.';\n      }\n      if(c[i][j]=='g'){\n\tt={i,j};\n      }\n      if(c[i][j]=='*'){\n\tque.push({i,j});\n\tspr[i][j]=0;\n      }\n    }\n  }\n  int dx[]={1,-1,0,0};\n  int dy[]={0,0,1,-1};\n  auto isRange=[=](int i,int j){\n    return 0<=i && i<h && 0<=j && j<w;\n  };\n  \n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && spr[p.first][p.second]+1<spr[toh][tow]){\n\tspr[toh][tow]=spr[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n  vector<vector<int>> goal(h,vector<int>(w,INF));\n  goal[t.first][t.second]=0;\n  que.push(t);\n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && goal[p.first][p.second]+1<goal[toh][tow]){\n\tgoal[toh][tow]=goal[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n\n  double ub=10000000000000;\n  double lb=0;\n\n  for(int i=0;i<1000;i++){\n    double mid=(lb+ub)/2;\n    double sum=0;\n    int cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='.'){\n\t  sum+=min<double>(goal[i][j],mid+spr[i][j]);\n\t  cnt++;\n\t}\n      }\n    }\n    sum/=cnt;\n    if(mid<sum){\n      lb=mid;\n    }\n    else{\n      ub=mid;\n    }\n  }\n  cout<<setprecision(15)<<fixed;\n  cout<<min<double>(goal[s.first][s.second],lb+spr[s.first][s.second])<<endl;\n  return 0;\n}\n  \n\n  \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct point{\n  int x;\n  int y;\n  int count;\n};\n\nint main(){\n  int houkou[5]={0,1,0,-1,0};\n  int w,h;\n  cin >> w >> h;\n  vector<vector<int>> field(h,vector<int>(w));\n  list<struct point> spring;\n  char c;\n  int sx,sy,gx,gy;\n  int numofFloor=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<int>> toGoal(h,vector<int>(w,0));\n  vector<vector<int>> toSpring(h,vector<int>(w,0));\n  queue<struct point> bfs;\n  struct point now;\n  int nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(int i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(int i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  double left=0;\n  double right=(h-2)*(w-2)*(h-2)*(w-2);\n  double mid;\n  double count;\n  while(right-left>0.00000001){\n    mid=(left+right)/2;\n    count=0;\n    for(int i=1;i<h-1;i++){\n      for(int j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n  // cout << mid << endl;\n  // cout << count << endl;\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)mid/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  cout << fixed << setprecision(11);\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)mid/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)mid/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nvoid print(const vvi& a)\n{\n\trep(i,a.size()){\n\t\trep(j,a[i].size())\n\t\t\tif(a[i][j]==INF)\n\t\t\t\tcout<<\"# \";\n\t\t\telse\n\t\t\t\tcout<<a[i][j]<<' ';\n\t\tcout<<endl;\n\t}\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h && w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tvvi stair(h,vi(w,INF)),spring(h,vi(w,INF));\n\t\tqueue<tuple<int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='g') q.emplace(i,j,0);\n\t\twhile(q.size()){\n\t\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\t\tif(0<=i && i<h && 0<=j && j<w && strchr(\".sg\",grid[i][j]) && stair[i][j]==INF){\n\t\t\t\tstair[i][j]=d;\n\t\t\t\trep(k,4) q.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t\t\t}\n\t\t}\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='*') q.emplace(i,j,0);\n\t\twhile(q.size()){\n\t\t\tint i,j,d; tie(i,j,d)=q.front(); q.pop();\n\t\t\tif(0<=i && i<h && 0<=j && j<w && strchr(\".sg*\",grid[i][j]) && spring[i][j]==INF){\n\t\t\t\tspring[i][j]=d;\n\t\t\t\trep(k,4) q.emplace(i+\"\\xff\\x1\\0\\0\"[k],j+\"\\0\\0\\xff\\x1\"[k],d+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout<<\"> stair:\"<<endl; print(stair);\n\t\t//cout<<\"> spring:\"<<endl; print(spring);\n\t\t\n\t\tvi st,sp;\n\t\trep(i,h) rep(j,w) if(strchr(\".s\",grid[i][j])){\n\t\t\tst.push_back(stair[i][j]);\n\t\t\tsp.push_back(spring[i][j]);\n\t\t}\n\t\tint n=st.size();\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return st[i]-sp[i]<st[j]-sp[j];});\n\t\t\n\t\tint si=-1,sj=-1;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='s') si=i,sj=j;\n\t\t\n\t\tdouble res=stair[si][sj];\n\t\tll sum1=0,sum2=accumulate(all(sp),0ll),cnt=0;\n\t\tfor(int i:is){\n\t\t\tsum1+=st[i],sum2-=sp[i],cnt++;\n\t\t\tres=min(res,spring[si][sj]+double(sum1+sum2)/cnt);\n\t\t}\n\t\tprintf(\"%.10f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct position{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL w,h;\n  LL houkou[5]={0,1,0,-1,0};\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct position> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct position> bfs;\n  struct position now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n   // cout << numofFloor << endl;\n  cout << fixed << setprecision(12);\n  double left=0;\n  double right=10000000000000000;\n  double mid;\n  double count;\n  int spcount=0;\n  while(right-left>0.0000000000000002*right){\n    mid=(left+right)/2;\n    spcount=0;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              if((double)toGoal[i][j]<(double)toSpring[i][j]+(double)mid/(double)numofFloor){\n                count+=(double)toGoal[i][j];\n              }else{\n                count+=(double)toSpring[i][j];\n                spcount++;\n              }\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0){\n              count+=(double)toSpring[i][j];\n              spcount++;\n            }\n          }\n        }\n      }\n    }\n    count+=(double)mid*(double)spcount/(double)numofFloor;\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n    // cout << left << endl;\n    // cout << right << endl;\n    // cout << count << endl;\n    // cout << toSpring[sy][sx] << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = (long)(H) * H * W * W;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tSystem.gc();\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n      //  assert(g[y][x] != '#');\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n      //  assert(g[y][x] != '#');\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < h; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*\n    printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sy][sx] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e15;\n    while (r - l > 1e-10) {\n        //printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                \n                \n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n        //printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H*10000, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//?????°???????????????????????£???????????£???(orz)\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstdio>\n#include <string>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1};\n\nint h, w;\nint sy, sx;\nint gy, gx;\nstring s[500];\nint a[500][500];\t//??????????????°????????§????????¢\nint b[500][500];\t//??´???????????§?????????\nint INF = 1145141919893810;\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> w >> h;\n\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == 's') { sy = i; sx = j; }\n\t\t\tif (s[i][j] == 'g') { gy = i; gx = j; }\n\t\t\ta[i][j] = INF;\n\t\t\tb[i][j] = INF;\n\t\t}\n\t}\n\t\n\tqueue<T> que;\n\t\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tque.push(T(0, i, j));\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || a[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\ta[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\tque.push(T(0, gy, gx));\n\t\n\twhile (!que.empty()) {\n\t\tT now = que.front(); que.pop();\n\t\tint cst = get<0>(now);\n\t\tint y = get<1>(now);\n\t\tint x = get<2>(now);\n\t\t\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\tif (s[ny][nx] == '#' || s[ny][nx] == '*' || b[ny][nx] <= cst + 1) continue;\n\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\tb[ny][nx] = cst + 1;\n\t\t}\n\t}\n\t\n\t//?????????\n\tvector<T> cells;\n\tfor (i = 0; i < h; i++) {\n\t\tfor (j = 0; j < w; j++) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tcells.push_back(T(b[i][j] - a[i][j], a[i][j], b[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(cells.begin(), cells.end());\n\t\n\t//(x?????°??????????????????????????????????????????(A)????????°. x + y????????????(B)????????°, E?????°??????????????§????????´???????????§??????????????°)\n\t//(Sx???A???g?????§????????????????????????, Hy???B-A?????°????????§???????????????????????????\n\t//??? E = (Sx + Hy) / x\n\t//???????????????. ?????£???, (x, y)?????¨??¨?????????, E = (Sx + Hy) / x??¨??????????????¨?????????x, y????????????????????¨??£?????????????????????????±???????\n\t//??£??????????????????????????????, E???????°????????±?????????°?????£??????E????±??????????\n\t//???????????£??????E???????????????x = 0??????????????¨????????????????????????????????§???x > 0??¨?????????\n\t\n\tint Sx = 0;\n\tint Hy = 0;\n\tfor (i = 0; i < cells.size(); i++) Hy += get<1>(cells[i]);\n\t\n\tdouble minE = INF;\n\t\n\tfor (int x = 0; x <= cells.size(); x++) {\n\t\tif (x > 0) {\n\t\t\tdouble E = (Sx + Hy) / (double)x;\n\t\t\tdouble eps = 1e-10;\n\t\t\tif (get<0>(cells[x - 1]) - eps <= E && E <= get<0>(cells[x]) + eps) {\n\t\t\t\tminE = min(minE, E);\n\t\t\t}\n\t\t}\n\t\tSx += get<2>(cells[x]);\n\t\tHy -= get<1>(cells[x]);\n\t}\n\t\n\t//2???????????????\n\tdouble ans = min((double)b[sy][sx], minE + a[sy][sx]);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tdouble upper=10000000000.0,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #ifdef DEBUG\n// #define _GLIBCXX_DEBUG\n// #endif\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n#include <thread>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\n#define int long long\n\n#define all(c) c.begin(), c.end()\n#define repeat(i, n) for (int i = 0; i < static_cast<int>(n); i++)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x) \n#endif\n\ntemplate<typename A,typename B>\nostream &operator<<(ostream&os,const pair<A,B>& p){\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntypedef complex<double> point;\n\n// template<typename T,std::size_t N>\n// struct _v_traits {using type = std::vector<typename _v_traits<T,N-1>::type>;};\n// template<typename T>\n// struct _v_traits<T,1> {using type = std::vector<T>;};\n// template<typename T,std::size_t N=1>\n// using vec = typename _v_traits<T,N>::type;\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nconst int INF = 100000000;\n\nstruct Info {\n    int to_goal;\n    int to_spring;\n    bool is_start;\n};\n\nostream &operator<<(ostream &os, const Info &i) {\n    return os << \"(\" << i.to_goal << \",\" << i.to_spring << \")\";\n}\n\nconst char wall = '#';\nconst char spring = '*';\nconst char dot = '.';\nconst char start = 's';\nconst char goal = 'g';\n\nconst vector<int> dx = {-1,0,1,0};\nconst vector<int> dy = {0, 1,0,-1};\n// 凸関数の極大な点をもとめる\ntemplate<typename F,typename T>\nT ternary_search(F f,T left,T right,int try_cnt = 1000){\n    for(int i=0;i<try_cnt;i++){\n        T l = (2*left + right) / 3;\n        T r = (left + 2*right) / 3;\n        if(f(l) < f(r)){\n            left = l;\n        }else{\n            right = r;\n        }\n    }\n    return (left+right)/2;\n}\n\n// 凹関数の極小な・を求める\ntemplate<typename F,typename T>\nT ternary_search_concave(F f,T left,T right,int try_cnt=1000){\n    return ternary_search([f](T x){return -f(x);},left,right);\n}\n\n// [0 ~ k)\nlong double calc_e(const vector<Info>& v,\n                   const vector<int>& as,\n                   const vector<int>& bs,\n                   const int k,\n                   const int s=0){\n    const int N = v.size();\n    int l = as[k];\n    int r = bs[N] - bs[k];\n    if(s > 100) return 1.0F * (l+r) / N;\n    return (l + r + (1.0F * (N-k) * calc_e(v,as,bs,k,s+1)))/N;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int W,H; cin >> W >> H;\n    vector<string> field(H);\n    for(string& s : field){\n        cin >> s;\n    }\n\n    vector<vector<Info> > info(H,vector<Info>(W,Info{INF,INF,false}));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == start) info[i][j].is_start = true;\n        }\n    }\n    \n\n    for(int to_finding_spring=0;to_finding_spring<2;to_finding_spring++){\n        // value,y,x\n        queue<tuple<int,int,int> > queue;\n        set<tuple<int,int> > already;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if((to_finding_spring and field[i][j] == spring) or\n                   (!to_finding_spring and field[i][j] == goal)){\n                    queue.emplace(0,i,j);\n                }\n            }\n        }\n        while(not queue.empty()){\n            auto t = queue.front();\n            queue.pop();\n            int v = get<0>(t);\n            int y = get<1>(t);\n            int x = get<2>(t);\n            if(already.find(make_tuple(y,x)) != already.end()){\n                continue;\n            }\n            if(to_finding_spring && (field[y][x] == wall or field[y][x] == goal)){\n                continue;\n            }\n            if(not to_finding_spring && (field[y][x] == wall or field[y][x] == spring)){\n                continue;\n            }\n\n            already.insert(make_tuple(y,x));\n            if(to_finding_spring){\n                info[y][x].to_spring = v;\n            }else{\n                info[y][x].to_goal = v;\n            }\n            for(int i=0;i<4;i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(0 <= nx and nx < W and 0 <= ny and ny < H\n                   and already.find(make_tuple(ny,nx)) == already.end()){\n                    queue.emplace(v+1,ny,nx);\n                }\n            }\n        }\n    }\n\n    vector<Info> dots;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == dot || field[i][j] == start){\n                dots.push_back(info[i][j]);\n            }\n        }\n    }\n    // 階段が近い → 遠い\n    sort(dots.begin(),dots.end(),[](const Info& left,const Info& right){\n            int l = left.to_goal - left.to_spring;\n            int r = right.to_goal - right.to_spring;\n            return l < r;\n        });\n\n    int si = find_if(dots.begin(),dots.end(),[](const Info& i){return i.is_start;}) - dots.begin();\n\n    int N = dots.size();\n    vector<int> as(N+1);\n    vector<int> bs(N+1);\n    for(int i=1;i<N+1;i++){\n        as[i] = as[i-1] + dots[i-1].to_goal;\n        bs[i] = bs[i-1] + dots[i-1].to_spring;\n    }\n\n    auto f = [&](long double c){\n        int k = 0;\n        for(k=0;k<N;k++){\n            if(dots[k].to_goal - dots[k].to_spring > c - 1e-9){\n                break;\n            }\n        }\n        if(si < k){\n            return (long double)(as[si+1]-as[si]);\n        }else{\n            return (bs[si+1] - bs[si]) + calc_e(dots,as,bs,k);\n        }\n    };\n    int ls = as[1] - bs[1];\n    int rs = as[N] - as[N-1] - (bs[N] - bs[N-1]);\n    auto r = ternary_search_concave(f,ls,rs);\n    // cout << f(r) << endl;\n    // for(int i=0;i<N;i++){\n    //     double d = as[i+1] - as[i] - (bs[i+1] - bs[i]);\n    // }\n\n    cout << fixed << setprecision(10);\n    cout << f(r) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst ll INF = pow(500,4);\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\n\nll dg[555][555], ds[555][555];\nint main()\n{\n\tREP(i, 555)REP(j, 555) dg[i][j] = ds[i][j] = INF;\n\tint w, h;\n\tcin >> w >> h;\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tpii s, g;\n\tvector<pii> sp, fl;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == 's')\n\t\t{\n\t\t\ts = pii(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\tif (fld[i][j] == 'g')\n\t\t{\n\t\t\tg = pii(i, j);\n\t\t}\n\t\tif (fld[i][j] == '.') fl.push_back(pii(i, j));\n\t\tif (fld[i][j] == '*')\n\t\t{\n\t\t\tsp.push_back(pii(i, j));\n\t\t\tds[i][j] = 0;\n\t\t}\n\t}\n\tqueue<pii> que;\n\tque.push(g);\n\tdg[g.first][g.second] = 0;\n\twhile (que.size())\n\t{\n\t\tint tx = que.front().first;\n\t\tint ty = que.front().second;\n\t\tque.pop();\n\t\tREP(i, 4)\n\t\t{\n\t\t\tint nx = tx + dx[i]; int ny = ty + dy[i];\n\t\t\tif (fld[nx][ny] == '.'&&dg[nx][ny] == INF)\n\t\t\t{\n\t\t\t\tdg[nx][ny] = dg[tx][ty] + 1;\n\t\t\t\tque.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\twhile (que.size()) que.pop();\n\tREP(i, sp.size()) que.push(sp[i]);\n\twhile (que.size())\n\t{\n\t\tint tx = que.front().first;\n\t\tint ty = que.front().second;\n\t\tque.pop();\n\t\tREP(i, 4)\n\t\t{\n\t\t\tint nx = tx + dx[i]; int ny = ty + dy[i];\n\t\t\tif (fld[nx][ny] == '.'&&ds[nx][ny] == INF)\n\t\t\t{\n\t\t\t\tds[nx][ny] = ds[tx][ty] + 1;\n\t\t\t\tque.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\tld lb = 0, ub = INF;\n\tREP(cnt,200)\n\t{\n\t\tld mid = (lb + ub) / 2;\n\t\tld sum = 0;\n\t\tREP(i, fl.size())\n\t\t{\n\t\t\tint x = fl[i].first, y = fl[i].second;\n\t\t\tsum += min((ld)dg[x][y], ds[x][y] + mid);\n\t\t}\n\t\tsum /= fl.size();\n\t\tif (mid > sum) ub = mid;\n\t\telse lb = mid;\n\t}\n\tld sum = 0;\n\tREP(i, fl.size()) sum += min((ld)dg[fl[i].first][fl[i].second], ds[fl[i].first][fl[i].second] + lb);\n\tcout << D10 << min((ld)dg[s.first][s.second], ds[s.first][s.second] + lb) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tlong double upper=1000000000000.0,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tlong double sum=0.0;\n\t\tlong double E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((long double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((long double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n      //  assert(g[y][x] != '#');\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n      //  assert(g[y][x] != '#');\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < h; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*\n    printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    printf(\"end\\n\");*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sy][sx] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e20;\n    for (int i = 0; i < 200; i++) {\n        //printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                \n                \n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n        //printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    if (dist2g[sy][sx] == INT_INF) {\n        printf(\"%.20Lf\\n\", dist2b[sy][sx]+l);\n        return 0;\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=10000;\n\tlong double upper=10000000000.0,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tlong double sum=0.0;\n\t\tlong double E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((long double)dist_goal[y][x],dist_spring[y][x]+E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((long double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e9, M = 0;\n  rep(i,80){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e29;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e30;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=1e30;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint H, W, sx, sy, gx, gy, dist1[509][509], dist2[509][509]; char c[509][509];\n\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tcin >> c[i][j]; dist1[i][j] = (1 << 30); dist2[i][j] = (1 << 30);\n\t\t\tif (c[i][j] == 's') { sx = i; sy = j; }\n\t\t\tif (c[i][j] == 'g') { gx = i; gy = j; }\n\t\t}\n\t}\n\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 }; queue<pair<int, int>>Q;\n\tdist1[gx][gy] = 0; Q.push(make_pair(gx, gy));\n\n\twhile (!Q.empty()) {\n\t\tpair<int, int>a1 = Q.front(); Q.pop();\n\t\tint cx = a1.first, cy = a1.second;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint px = cx + dx[i], py = cy + dy[i];\n\t\t\tif (c[px][py] == '#' || c[px][py] == '*') continue;\n\t\t\tif (dist1[px][py] > dist1[cx][cy] + 1) {\n\t\t\t\tdist1[px][py] = dist1[cx][cy] + 1;\n\t\t\t\tQ.push(make_pair(px, py));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (c[i][j] == '*') { dist2[i][j] = 0; Q.push(make_pair(i, j)); }\n\t\t}\n\t}\n\tif (Q.empty()) {\n\t\tcout << dist1[sx][sy] << endl;\n\t\treturn 0;\n\t}\n\n\twhile (!Q.empty()) {\n\t\tpair<int, int>a1 = Q.front(); Q.pop();\n\t\tint cx = a1.first, cy = a1.second;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint px = cx + dx[i], py = cy + dy[i];\n\t\t\tif (c[px][py] == '#') continue;\n\t\t\tif (dist2[px][py] > dist2[cx][cy] + 1) {\n\t\t\t\tdist2[px][py] = dist2[cx][cy] + 1;\n\t\t\t\tQ.push(make_pair(px, py));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong double L = 0.0L, R = 1e12, M;\n\tfor (int i = 0; i < 100; i++) {\n\t\tM = (L + R) / 2;\n\t\tint cnt = 0; long double sum = 0;\n\t\tfor (int j = 1; j <= H; j++) {\n\t\t\tfor (int k = 1; k <= W; k++) {\n\t\t\t\tif (c[j][k] == '#' || c[j][k] == '*' || c[j][k] == 'g') continue;\n\t\t\t\tcnt++;\n\t\t\t\tsum += min(M + dist2[j][k], 1.0L*dist1[j][k]);\n\t\t\t}\n\t\t}\n\t\tif (1.0L*sum / cnt < M) { R = M; }\n\t\telse { L = M; }\n\t}\n\tprintf(\"%.12Lf\\n\", min(M + dist2[sx][sy], 1.0L * dist1[sx][sy]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=W*H;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=W*H;\n\tfor(int stage=0;stage<100;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=W*H;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500*500*500*500;\n    while((r-l)>=1e-10){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nchar field[600][600];\nint a[600][600];\nint b[600][600];\n\nvoid bfs(char start, int dist[][600]){\n  queue<int> que;\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, INF);\n  rep(i, H)rep(j, W){\n    if(field[i][j] == start){\n      dist[i][j] = 0;\n      que.push(i * W + j);\n    }\n  }\n  while(!que.empty()){\n    int p = que.front(); que.pop();\n    int x = p % W;\n    int y = p / W;\n    rep(i, 4){\n      int y2 = y + dy[i];\n      int x2 = x + dx[i];\n      if((field[y2][x2] == '.' || field[y2][x2] == 's') && dist[y2][x2] == INF){\n\tdist[y2][x2] = dist[y][x] + 1;\n\tque.push(y2 * W + x2);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H){\n    int sy = 0, sx = 0;\n    rep(i, H)rep(j, W){\n      cin >> field[i][j];\n      if(field[i][j] == 's'){\n\tsy = i, sx = j;\n      }\n    }\n    bfs('*', a);\n    bfs('g', b);\n    long double ub = 1e15;\n    long double lb = 0;\n    rep(i, 1000){\n      double mb = (ub + lb) / 2;\n      double sum = 0;\n      int cnt = 0;\n      rep(j, H)rep(k, W){\n\tif(field[j][k] == 's' || field[j][k] == '.'){\n\t  cnt++;\n\t  sum += min((double)b[j][k], a[j][k] + mb);\n\t}\n      }\n      if(mb > sum / cnt) ub = mb;\n      else lb = mb;\n    }\n    cout << fixed << setprecision(15) << min(lb+a[sy][sx],(long double)b[sy][sx])<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nint H,W,sx,sy,gx,gy,mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = IINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == IINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n\n  }\n\n}\n\nbool check(ld E){\n  ld T = 0;\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min((ld)mincost[y][x][0],(ld)mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] != 'g' && c[i][j] != '#' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,120){\n    M = ( L + R ) * 0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=1e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(9);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  int a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(tmp.X<1.*(b-tmp.X)/(nn-a-1))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint d[512][512],INF=5e6,d2[512][512],dx[]={1,0,-1,0},dy[]={0,1,0,-1},dd[512][512];\n\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(10);\n  int i,j,k,n,m,sx,sy,gx,gy;\n  cin>>m>>n;\n  vector<string> mp(n);\n  rep(i,n)\n    cin>>mp[i];\n  fill(d[0],d[512]+512,INF);\n  fill(d2[0],d2[512]+512,INF);\n  queue<pii> que,que2;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]=='s'){\n      sx=j;\n      sy=i;\n    }else if(mp[i][j]=='g'){\n      gx=j;\n      gy=i;\n      que.push(pii(j,i));\n      d[i][j]=0;\n    }else if(mp[i][j]=='*'){\n      que2.push(pii(j,i));\n      d2[i][j]=0;\n    }\n  }\n  while(!que.empty()){\n    pii p=que.front();que.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && mp[y][x]!='*' && d[y][x]>d[p.Y][p.X]+1){\n\td[y][x]=d[p.Y][p.X]+1;\n\tque.push(pii(x,y));\n      }\n    }\n  }\n  while(!que2.empty()){\n    pii p=que2.front();que2.pop();\n    rep(i,4){\n      int x=p.X+dx[i],y=p.Y+dy[i];\n      if(mp[y][x]!='#' && d2[y][x]>d2[p.Y][p.X]+1){\n\td2[y][x]=d2[p.Y][p.X]+1;\n\tque2.push(pii(x,y));\n      }\n    }\n  }\n  //  rep(i,n){rep(j,m)cout<<d[i][j]<<\",\";cout<<endl;}cout<<endl;\n  //  rep(i,n){rep(j,m)cout<<d2[i][j]<<\",\";cout<<endl;}\n  priority_queue<piii> q;\n  ll a=0,b=0,nn=0;\n  rep(i,n)rep(j,m){\n    if(mp[i][j]!='#' && mp[i][j]!='*' && mp[i][j]!='g'){\n      q.push(piii(d[i][j]-d2[i][j],pii(j,i)));\n      b+=d[i][j];\n      nn++;\n    }\n  }\n  //  cout<<b<<\",\"<<nn<<\":\"<<1.*b/(nn-a)<<endl;\n  while(!q.empty()){\n    piii tmp=q.top();q.pop();\n    if(nn-a==1)break;\n    if(tmp.X<1.*(b)/(nn-a))\n      break;\n    //cout<<tmp.Y<<tmp.X+d2[tmp.Y.Y][tmp.Y.X]<<\"->\";\n    pii p=tmp.Y;\n    b-=tmp.X;\n    ++a;\n    dd[p.Y][p.X]=1;\n    //    cout<<1.*b/(nn-1)+d2[tmp.Y.Y][tmp.Y.X]<<endl;\n    //cout<<a<<\",\"<<b<<endl;\n  }\n  cout<<d[sy][sx]*(1-dd[sy][sx])+(d2[sy][sx]+1.*b/(nn-a))*dd[sy][sx]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e10, M = 0;\n  rep(i,65){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e11;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e10;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=1e10;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int w,h;\n    cin>>w>>h;\n    vector<string> c(h);\n    const long long int INF=1e15;\n    vector<vector<long long int>> spr(h,vector<long long int>(w,INF));\n    queue<pair<int,int>> que;\n    pair<int,int> s;\n    pair<int,int> g;\n    for(int i=0;i<h;i++){\n        cin>>c[i];\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='s'){\n                s={i,j};\n                c[i][j]='.';\n            }\n            if(c[i][j]=='g'){\n                g={i,j};\n            }\n            if(c[i][j]=='*'){\n                spr[i][j]=0;\n                que.push({i,j});\n            }\n        }\n    }\n\n    int dh[]={1,-1,0,0};\n    int dw[]={0,0,1,-1};\n    while(!que.empty()){\n       auto p=que.front();\n       que.pop();\n       for(int i=0;i<4;i++){\n        int th=p.first+dh[i];\n        int tw=p.second+dw[i];\n        if(c[th][tw]=='.' && spr[p.first][p.second]+1<spr[th][tw]){\n            spr[th][tw]=spr[p.first][p.second]+1;\n            que.push({th,tw});\n        }\n       }\n    }\n    vector<vector<long long int>> goal(h,vector<long long int>(w,INF));\n    goal[g.first][g.second]=0;\n    que.push({g.first,g.second});\n    while(!que.empty()){\n        auto p=que.front();\n        que.pop();\n        for(int i=0;i<4;i++){\n            int th=p.first+dh[i];\n            int tw=p.second+dw[i];\n            if(c[th][tw]=='.' && goal[p.first][p.second]+1<goal[th][tw]){\n            goal[th][tw]=goal[p.first][p.second]+1;\n            que.push({th,tw});\n            }\n        }\n       \n    }\n    int fcnt=0;\n    long long int sum1=0;\n    long long int sum2=0;\n    vector<pair<long long int,pair<int,int>>> ex;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j]=='.'){\n                fcnt++;\n                if(!(goal[i][j]!=INF || spr[i][j]!=INF)){\n                    cout<<goal[s.first][s.second]<<endl;\n                    return 0;\n                }\n                long long int dis=goal[i][j]-spr[i][j];\n                if(dis<=0){\n                    sum1+=goal[i][j];\n                }\n                else{\n                    sum2+=spr[i][j];\n                    ex.push_back({dis,{i,j}});\n                }\n            \n            }\n        }\n    }\n    sort(ex.begin(),ex.end());\n    double resex=-1;\n    int inde=0;\n    \n    for(int x=1;x<=1000000;x++){//ex=[x,x+1)\n        for(;inde<ex.size();inde++){\n            if(ex[inde].first<=x){\n                int i=ex[inde].second.first;\n                int j=ex[inde].second.second;\n                sum1+=goal[i][j];\n                sum2-=spr[i][j];\n            }\n            else{\n                break;\n            }\n        }\n        const double EPS=1e-12;\n        if(ex.size()==inde){\n            double xa=double(sum1)/fcnt;\n            if(x-EPS<xa){\n                resex=xa;\n            }\n            break;\n        }\n        double xa=double(sum1+sum2)/fcnt/(1-(double(ex.size()-inde)/fcnt));\n        if(x-EPS<xa && xa<=x+1-EPS || (x==1000000 &&  x-EPS<xa)){\n            assert(resex==-1);\n            resex=xa;\n        }\n    }\n    assert(resex!=-1);\n    \n    cout<<fixed<<setprecision(10);\n    cout<<min<double>(goal[s.first][s.second],spr[s.first][s.second]+resex)<<endl;\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\nstruct edge { int v, w; };\n\nint INF = INT_MAX / 2;\n\nint dy[] = {0, -1, 0, 1};\nint dx[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W; cin >> W >> H;\n\tvector<string> a(H);\n\tfor (int y = 0; y < H; y++)\n\t\tcin >> a[y];\n\tint ys, xs, yg, xg;\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (a[y][x] == 's') {\n\t\t\t\ta[y][x] = '.';\n\t\t\t\tys = y;\n\t\t\t\txs = x;\n\t\t\t}\n\t\t\tif (a[y][x] == 'g') {\n\t\t\t\tyg = y;\n\t\t\t\txg = x;\n\t\t\t}\n\t\t}\n\tvector<vector<int> > dg(H, vector<int>(W, INF));\n\tqueue<i_i> q;\n\tdg[yg][xg] = 0;\n\tq.push(i_i(yg, xg));\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && dg[_y][_x] > dg[y][x] + 1) {\n\t\t\t\tdg[_y][_x] = dg[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ds(H, vector<int>(W, INF));\n\tfor (int y = 0; y < H; y++)\n\t\tfor (int x = 0; x < W; x++)\n\t\t\tif (a[y][x] == '*') {\n\t\t\t\tds[y][x] = 0;\n\t\t\t\tq.push(i_i(y, x));\n\t\t\t}\n\twhile (q.size()) {\n\t\ti_i p = q.front(); q.pop();\n\t\tint y = p.first, x = p.second;\n\t\tfor (int k = 0; k < 4; k++) {\n\t\t\tint _y = y + dy[k], _x = x + dx[k];\n\t\t\tif (a[_y][_x] == '.' && ds[_y][_x] > ds[y][x] + 1) {\n\t\t\t\tds[_y][_x] = ds[y][x] + 1;\n\t\t\t\tq.push(i_i(_y, _x));\n\t\t\t}\n\t\t}\n\t}\n\tdouble lb = 0, ub = 1e9;\n\tfor (int t = 0; t < 100; t++) {\n\t\tdouble mid = (lb + ub) / 2;\n\t\tint k = 0;\n\t\tdouble sum = 0;\n\t\tfor (int y = 0; y < H; y++)\n\t\t\tfor (int x = 0; x < W; x++)\n\t\t\t\tif (a[y][x] == '.') {\n\t\t\t\t\tk++;\n\t\t\t\t\tsum += min((double)dg[y][x], ds[y][x] + mid);\n\t\t\t\t}\n\t\tif (sum / k >= mid) lb = mid;\n\t\telse ub = mid;\n\t}\n\tprintf(\"%.15f\\n\", min((double)dg[ys][xs], ds[ys][xs] + lb));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N = 500;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\nconst int inf = (1<<20);\nchar m[N][N+1];\nint dcost[N][N];//ç´æ¥ã´ã¼ã«ã¾ã§è¡ãã³ã¹ã\nint scost[N][N];//ãããä½¿ã£ãæã®ã³ã¹ã\nvoid bfs(int r,int c,char s,int cost[N][N]){\n  queue<int> Q;\n  rep(i,r)rep(j,c)\n    if (m[i][j] == s)cost[i][j] = 0,Q.push(i*c+j);\n    else cost[i][j] = inf;\n  while(!Q.empty()){\n    int y = Q.front()/c,x=Q.front()%c;Q.pop();\n    //    cout << y <<\" \" << x << endl;\n    rep(i,4){\n      int ney = y+dy[i],nex = x+dx[i];\n      if (m[ney][nex] == '*' || m[ney][nex] == 'g' || m[ney][nex] == '#' || cost[ney][nex] != inf)continue;\n      cost[ney][nex] = cost[y][x] + 1;\n      Q.push(ney*c+nex);\n    }\n  }\n}\n\n//brute force,ã¨ããããåæããã¾ã§åãã¦ã¿ã\n//å¥åãgs*ã¿ãããªã®ãæ¥ãã¨è½ã¡ãå¯è½æ§ããã\ndouble exp[N][N];\ndouble bf(int r,int c){\n  double e=0;//æå¾å¤ã®ç·åãæã£ã¦ããã¨å½¹ã«ç«ã¤\n  double pos = 0;//ããã§è¡ãå¯è½æ§ã®ããå ´æã®æ°\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == '*' || m[i][j] == 'g' || m[i][j] == '#')continue;\n      exp[i][j] = dcost[i][j];\n      e += dcost[i][j];\n      if (m[i][j] == 's' || m[i][j] == '.')pos+=1;\n    }\n  }\n  while(true){\n    bool isupdate = false;\n    double newe = 0;\n    rep(i,r){\n      rep(j,c){\n\tif (m[i][j] == 'g' || m[i][j] == '#')continue;//ããã¯èããªãã\n\tdouble tmp = dcost[i][j];\n\tdouble tmp2 = scost[i][j] + (e)/(pos);\n\tif (exp[i][j] > min(tmp,tmp2)){\n\t  isupdate = true;\n\t  //e -= exp[i][j];\n\t  exp[i][j] = min(tmp,tmp2);\n\t  //e += exp[i][j];\n\t}\n\tnewe += exp[i][j];\n      }\n    }\n    e = newe;\n    /*\n    cout <<\"debug \" << endl;\n    rep(i,r){\n      rep(j,c){\n\tprintf(\"%.3lf \",exp[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    cout <<\"--------------==\" << endl;\n    */\n    if (!isupdate)break;\n  }\n\n  rep(i,r)rep(j,c)if (m[i][j] == 's')return exp[i][j];\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)cin>>m[i];\n    bfs(r,c,'*',scost);\n    bfs(r,c,'g',dcost);\n    printf(\"%.10lf\\n\",bf(r,c));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e9, M = 0;\n  rep(i,70){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\ndouble A[500][500],B[500][500];\n\nvoid bfs(char ch,double d[500][500]){\n  fill(d[0],d[500], 1e20 );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  bfs('*',A);\n  bfs('g',B);\n\n  vector<double> v;\n  double sum=0,cnt=0,base,ans=1e20;\n\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      cnt+=1.0;\n      sum+=B[i][j];\n      v.push_back(A[i][j]-B[i][j]);\n      if(t[i][j]=='s'){\n        base=A[i][j];\n        ans=min(ans,B[i][j]);\n      }\n    }\n  }\n\n  ans=min(ans, base + sum / cnt);\n  sort(v.begin(),v.end());\n  for(int i=0;i+1<(int)v.size();i++){\n    sum+=v[i];\n    double rate=(double)(i+1)/cnt;\n    double X=sum/cnt;\n    X/=(1.0-rate);\n    ans=min(ans,base+X);\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> c(h);\n  for(int i=0;i<h;i++){\n    cin>>c[i];\n  }\n  const int INF=1e9;\n  vector<vector<int>> spr(h,vector<int>(w,INF));\n  queue<pair<int,int>> que;\n  pair<int,int> s;\n  pair<int,int> t;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(c[i][j]=='s'){\n\ts={i,j};\n\tc[i][j]='.';\n      }\n      if(c[i][j]=='g'){\n\tt={i,j};\n      }\n      if(c[i][j]=='*'){\n\tque.push({i,j});\n\tspr[i][j]=0;\n      }\n    }\n  }\n  int dx[]={1,-1,0,0};\n  int dy[]={0,0,1,-1};\n  auto isRange=[=](int i,int j){\n    return 0<=i && i<h && 0<=j && j<w;\n  };\n  \n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && spr[p.first][p.second]+1<spr[toh][tow]){\n\tspr[toh][tow]=spr[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n  vector<vector<int>> goal(h,vector<int>(w,INF));\n  goal[t.first][t.second]=0;\n  que.push(t);\n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && goal[p.first][p.second]+1<goal[toh][tow]){\n\tgoal[toh][tow]=goal[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n\n  double ub=100000000;\n  double lb=0;\n\n  for(int i=0;i<1000;i++){\n    double mid=(lb+ub)/2;\n    double sum=0;\n    int cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='.'){\n\t  sum+=min<double>(goal[i][j],mid+spr[i][j]);\n\t  cnt++;\n\t}\n      }\n    }\n    sum/=cnt;\n    if(mid<sum){\n      lb=mid;\n    }\n    else{\n      ub=mid;\n    }\n  }\n  cout<<setprecision(10)<<fixed;\n  cout<<min<double>(goal[s.first][s.second],lb+spr[s.first][s.second])<<endl;\n  return 0;\n}\n  \n\n  \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct position{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL w,h;\n  LL houkou[5]={0,1,0,-1,0};\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct position> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct position> bfs;\n  struct position now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  double left=0;\n  double right=10000000000000;\n  double mid;\n  double count;\n  while(right-left>0.000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   // cout << left << endl;\n   // cout << right << endl;\n   // cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)left/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)left/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)left/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)left/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x, y, cost;\n  Point() {;}\n  Point(int x, int y, int cost) : x(x), y(y), cost(cost) {;}\n};\n\nint w, h;\nchar field[600][600];\nint springDist[600][600];\nint goalDist[600][600];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint sx, sy;\n\ninline bool Movable(int x, int y) {\n  if (x < 0 || x >= w || y < 0 || y >= h) { return false; }\n  if (field[y][x] != '.') { return false; }\n  return true;\n}\n\nvoid CalcDist() {\n  MEMSET(springDist, -1);\n  MEMSET(goalDist, -1);\n  queue<Point> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == '*') {\n        REP(dir, 4) {\n          int nx = x + dx[dir];\n          int ny = y + dy[dir];\n          if (!Movable(nx, ny)) { continue; }\n          que.push(Point(nx, ny, 1));\n        }\n      }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (springDist[p.y][p.x] != -1) { continue; }\n    springDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] == 'g') { que.push(Point(x, y, 0)); }\n    }\n  }\n  while (!que.empty()) {\n    Point p = que.front();\n    que.pop();\n    if (goalDist[p.y][p.x] != -1) { continue; }\n    goalDist[p.y][p.x] = p.cost;\n    REP(dir, 4) {\n      int nx = p.x + dx[dir];\n      int ny = p.y + dy[dir];\n      if (!Movable(nx, ny)) { continue; }\n      que.push(Point(nx, ny, p.cost + 1));\n    }\n  }\n}\n\nlong double ToGoal(int x, int y, long double E) {\n  long double ret = 1e+100;\n  if (goalDist[y][x] != -1) { ret = min(ret, (long double)goalDist[y][x]); }\n  if (springDist[y][x] != -1) { ret = min(ret, springDist[y][x] + E); }\n  //cout << x << \" \" << y << endl;\n  assert(goalDist[y][x] != -1 || springDist[y][x] != -1);\n  return ret;\n}\n\n//long double vs[510 * 510];\nlong double calc(long double E) {\n  //long double nE = 0.0;\n  int cnt = 0;\n  priority_queue<long double> que;\n  REP(y, h) {\n    REP(x, w) {\n      if (field[y][x] != '.') { continue; }\n      //vs[cnt++] = ToGoal(x, y, E);\n      que.push(-ToGoal(x, y, E));\n      //nE += ToGoal(x, y, E);\n      cnt++;\n    }\n  }\n  //sort(vs, vs + cnt);\n  REP(i, cnt - 1) {\n    //nE += vs[i];\n    long double l = que.top();\n    que.pop();\n    long double r = que.top();\n    que.pop();\n    que.push(l + r);\n  }\n  return -que.top() / cnt;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h) > 0) {\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 's') {\n          sx = x;\n          sy = y;\n          field[y][x] = '.';\n        }\n      }\n    }\n    CalcDist();\n    long double left = 0.0;\n    long double right = 1e+10;\n    if (springDist[sy][sx] != -1) {\n      REP(iter, 50) {\n        long double mid = (left + right) / 2.0;\n        if (calc(mid) > mid) {\n          left = mid;\n        } else {\n          right = mid;\n        }\n      }\n    }\n    printf(\"%.10Lf\\n\", ToGoal(sx, sy, left));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\nlong double calc(vvl&gts, vvl&spr, long double val, int y, int x){\n\treturn min((long double)gts[y][x], spr[y][x]+val);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll w,h;\n\tcin>>w>>h;\n\n\tvs f(h);\n\tcin>>f;\n\n\tll sy,sx,gy,gx,br=0;\n\tvvl spr(h,vl(w,LINF));\n\tvvl gts(h,vl(w,LINF));\n\tqueue<tlll> q;\n\trep(i,h)rep(j,w){\n\t\tif(f[i][j]=='*'){\n\t\t\tq.emplace(i,j,0);\n\t\t}else if(f[i][j]=='s'){\n\t\t\tsy=i, sx=j, br++;\n\t\t}else if(f[i][j]=='g'){\n\t\t\tgy=i, gx=j;\n\t\t}else if(f[i][j]=='.'){\n\t\t\tbr++;\n\t\t}\n\t}\n\n\twhile(!q.empty()){\n\t\tint y,x,d;\n\t\ttie(y,x,d) = q.front();\n\t\tq.pop();\n\t\tif(spr[y][x]!=LINF)continue;\n\t\tspr[y][x]=d;\n\t\trep(i,4)if(spr[y+dy[i]][x+dx[i]]==LINF and \".s\"s.find(f[y+dy[i]][x+dx[i]])!=-1){\n\t\t\tq.emplace(y+dy[i], x+dx[i], d+1);\n\t\t}\n\t}\n\n\tq.emplace(gy,gx,0);\n\twhile(!q.empty()){\n\t\tint y,x,d;\n\t\ttie(y,x,d) = q.front();\n\t\tq.pop();\n\t\tif(gts[y][x]!=LINF)continue;\n\t\tgts[y][x]=d;\n\t\trep(i,4)if(gts[y+dy[i]][x+dx[i]]==LINF and \".s\"s.find(f[y+dy[i]][x+dx[i]])!=-1){\n\t\t\tq.emplace(y+dy[i], x+dx[i], d+1);\n\t\t}\n\t}\n\n\n\tlong double ok=1e10, ng=0;\n\twhile(abs(ok-ng)>=1e-9){\n\t\tlong double mid=(ok+ng)/2, val = 0;\n\n\t\trep(i,h)rep(j,w)if(\".s\"s.find(f[i][j])!=-1){\n\t\t\tval += calc(gts, spr, mid, i, j);\n\t\t}\n\n\t\tif(br*mid >= val){\n\t\t\tok=mid;\n\t\t}else{\n\t\t\tng=mid;\n\t\t}\n\t}\n\tlong double ans = calc(gts, spr, ok, sy, sx);\n\tfcout(15)<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,gx,gy;\nvs a;\nvvl b,c;\n\ndouble f(double x){\n\tdouble res=0;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) if(a[i][j]=='.'||a[i][j]=='s'){\n\t\tres+=min(b[i][j]-x,(double)c[i][j]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>w>>h;\n\ta=vs(h,string(w,'A'));\n\tb=c=vvl(h,vl(w,INF));\n\tqueue<P> q;\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++){\n\t\tcin>>a[i][j];\n\t\tif(a[i][j]=='g'){\n\t\t\tgx=i,gy=j;\n\t\t\tb[i][j]=0;\n\t\t}\n\t\tif(a[i][j]=='*'){\n\t\t\tq.push({i,j});\n\t\t\tc[i][j]=0;\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tP p=q.front();\n\t\tq.pop();\n\t\tint x=p.first,y=p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint X=x+dx[i],Y=y+dy[i];\n\t\t\tif(a[X][Y]!='#'&&c[X][Y]==INF){\n\t\t\t\tc[X][Y]=c[x][y]+1;\n\t\t\t\tq.push({X,Y});\n\t\t\t}\n\t\t}\n\t}\n\tq.push({gx,gy});\n\twhile(!q.empty()){\n\t\tP p=q.front();\n\t\tq.pop();\n\t\tint x=p.first,y=p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint X=x+dx[i],Y=y+dy[i];\n\t\t\tif((a[X][Y]=='.'||a[X][Y]=='s')&&b[X][Y]==INF){\n\t\t\t\tb[X][Y]=b[x][y]+1;\n\t\t\t\tq.push({X,Y});\n\t\t\t}\n\t\t}\n\t}\n\tdouble l=0,r=INF;\n\tfor(int i=0;i<200;i++){\n\t\tdouble m=(l+r)/2;\n\t\tif(f(m)>=0) l=m;\n\t\telse r=m;\n\t}\n\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) if(a[i][j]=='s'){\n\t\tcout<<syosu(11)<<min((double)b[i][j],c[i][j]+r)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint H,W;\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nchar t[500][500];\nll A[500][500],B[500][500];\n\nvoid bfs(char ch,ll d[500][500]){\n  fill(d[0],d[500], (1LL<<40) );\n  queue<int> qy,qx;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(ch==t[i][j]){\n        d[i][j]=0;\n        qy.push(i);\n        qx.push(j);\n      }\n    }\n  }\n  while(!qy.empty()){\n    int y=qy.front();qy.pop();\n    int x=qx.front();qx.pop();\n    for(int dir=0;dir<4;dir++){\n      int ny=y+dy[dir];\n      int nx=x+dx[dir];\n      if(t[ny][nx]=='#')continue;\n      if(t[ny][nx]=='*')continue;\n      if(d[ny][nx]>d[y][x]+1){\n        d[ny][nx]=d[y][x]+1;\n        qy.push(ny);\n        qx.push(nx);\n      }\n    }\n  }\n}\n\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      cin>>t[i][j];\n  bfs('*',A);\n  bfs('g',B);\n\n  vector<ll> v;\n  ll sum=0,cnt=0,base;\n  \n  double ans=1e9;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(t[i][j]=='#')continue;\n      if(t[i][j]=='*')continue;\n      if(t[i][j]=='g')continue;\n      cnt++;\n      sum+=B[i][j];\n      v.push_back(A[i][j]-B[i][j]);\n      if(t[i][j]=='s'){\n        base=A[i][j];\n        ans=min(ans,(double)B[i][j]);\n      }\n    }\n  }\n\n  ans=min(ans, (double)base + (double)sum / (double)cnt);\n  sort(v.begin(),v.end());\n  for(int i=0;i+1<(int)v.size();i++){\n    sum+=v[i];\n    double rate=(double) (i+1)/ (double) cnt;\n    double X= (double)sum / (double)cnt;\n    X/= (1.0-rate);\n    ans=min( ans, (double)base + X);\n  }\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst double INF = 1e18;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(double dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1.0 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    double dist_goal[500][500], dist_spring[500][500];\n    REP(y, H) REP(x, W) dist_goal[y][x] = dist_spring[y][x] = -1.0;\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e18;\n    REP(_, 200){\n      const double sum = (ub + lb) * 0.5;\n      double S = sum;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        double exp = min((double)dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S -= exp;\n      }\n      if(S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = lb / N;\n    printf(\"%.12f\\n\", min((double)dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 21474836001234567\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> vec(h);\n  rep(i,h) cin>>vec[i];\n\n  int sx,sy,tx,ty;\n  vector<int> spx,spy;\n  rep(i,h)rep(j,w){\n    if(vec[i][j]=='s') sx=i,sy=j;\n    if(vec[i][j]=='g') tx=i,ty=j;\n    if(vec[i][j]=='*') spx.pb(i), spy.pb(j);\n  }\n\n  vector<vector<long>> d(h, vector<long>(w, INF));\n  // g?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    d[tx][ty] = 0;\n    xs.push(tx); ys.push(ty);\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && d[nx][ny]>d[x][y]+1){\n          d[nx][ny] = d[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  vector<vector<long>> ds(h,vector<long>(w,INF));\n  // ????????????spring?????§??????????????¢\n  {\n    queue<int> xs,ys;\n    rep(i,spx.size()){\n      xs.push(spx[i]);\n      ys.push(spy[i]);\n      ds[spx[i]][spy[i]] = 0;\n    }\n    while(!xs.empty()){\n      int x = xs.front(); xs.pop();\n      int y = ys.front(); ys.pop();\n      const int dx[] = {0,0,-1,1}, dy[] = {-1,1,0,0};\n      rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(vec[nx][ny]!='#' && vec[nx][ny]!='*' && ds[nx][ny]>ds[x][y]+1){\n          ds[nx][ny] = ds[x][y]+1;\n          xs.push(nx);\n          ys.push(ny);\n        }\n      }\n    }\n  }\n\n  double p = INF; // ????????§?£???°??????????????¨?????????????§????????????????\n  {\n    int cnt=1;\n    rep(i,h)rep(j,w)if(vec[i][j]=='.') cnt++;\n\n    double l = 0, r = 500.0*500*500*500*500;\n    rep(_,300){\n      double m = (l+r)/2.0;\n      double accm = min<double>(d[sx][sy], ds[sx][sy]+m);\n      rep(i,h) rep(j,w)if(vec[i][j]=='.'){\n        accm += min<double>(d[i][j], ds[i][j]+m);\n      }\n      p = accm/cnt;\n      if(p<m) r = m;\n      else l = m;\n    }\n    p = (r+l)/2.0;\n  }\n\n  printf(\"%.10f\\n\", min<double>(d[sx][sy], ds[sx][sy]+p));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint H, W;\ndouble ex[500][500];\nstring vs[500];\n\nusing D = pair<double,PII>;\nvoid bfs(PII p, VVI& dist){\n  queue<PII> q;\n  q.push(p);\n  dist[p.FF][p.SS] = 0.;\n  \n  while(!q.empty()){\n\tp = q.front();\n\tq.pop();\n\n\tREP(d,4){\n\t  PII np(p.FF + dy[d], p.SS + dx[d]);\n\t  if(vs[np.FF][np.SS] != '.')\n\t\tcontinue;\n\t  int nc = dist[p.FF][p.SS] + 1;\n\t  if(dist[np.FF][np.SS] > nc){\n\t\tdist[np.FF][np.SS] = nc;\n\t\tq.push(np);\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> W >> H;\n  REP(y,H) cin >> vs[y];\n  fill((double*)ex, (double*)ex+500*500, INF);\n\n  PII S, G;\n  vector<PII> star;\n  int sum = 0;\n  REP(y,H) REP(x,W){\n\tif(vs[y][x] == 's'){\n\t  vs[y][x] = '.';\n\t  S = MP(y,x);\n\t  ++sum;\n\t}\n\telse if(vs[y][x] == 'g'){\n\t  G = MP(y,x);\n\t  ++sum;\n\t}\n\telse if(vs[y][x] == '*'){\n\t  star.PB(MP(y,x));\n\t}\n  }\n  shuffle(ALL(star), mt19937());\n\n  VVI dist(H, VI(W, INF));\n  bfs(G, dist);\n\n  VVI sp_dist(H, VI(W, INF));\n  for(auto&& p: star)\n\tbfs(p, sp_dist);\n\n  double lb = 0., ub = 1e9;\n  REP(i,100){\n\tdouble X = (lb + ub) / 2.;\n\tdouble acc = 0.;\n\tint n = 0;\n\tREP(y,H) REP(x,W){\n\t  if(vs[y][x] == '.'){\n\t\t++n;\n\t\tacc += min((double)dist[y][x], sp_dist[y][x] + X);\n\t  }\n\t}\n\n\tif(acc / n < X)\n\t  ub = X;\n\telse\n\t  lb = X;\n  }\n\n  cout << fixed << setprecision(11) << min(dist[S.FF][S.SS]*1., sp_dist[S.FF][S.SS] + lb) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/rational.hpp>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  LL w,h;\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>> left=0;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>> right=10000000000000000000;\n   cout << left << endl;\n   cout << right << endl;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>> mid;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>> count;\n  while(right-left>0.000000000001){\n    cout << right-left << endl;\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)numofFloor);\n            }else{\n              count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   cout << left << endl;\n   cout << right << endl;\n   cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)numofFloor) << \" \";\n  //         }else{\n  //           cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toGoal[sy][sx],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)numofFloor) << endl;\n    }else{\n      cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<32>>)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(long double x){\n\tint cnt=0;\n\tlong double sum=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tlong double tmp=1e11;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t\tsum+=tmp;\n\t\tcnt++;\n\t}\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tlong double lb=0,ub=1e10;\n\tfor(int stage=0;stage<500;stage++){\n\t\tlong double mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tlong double ans=1e10;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9llf\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<double, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-12;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nint W, H;\nint sy,sx, gy, gx;\nstring field[600];\ndouble dist[600][600];\n\nvoid dijkstra(int sx, int sy, double mb){\n  fill(&dist[0][0], &dist[0][0] + 600 * 600, 1e20);\n  priority_queue<P,vector<P>, greater<P> > que;\n  que.push(P(0, sy * W + sx));\n  dist[sy][sx] = 0;\n  rep(i, H)rep(j, W){\n    if(field[i][j] == '*') {\n      dist[i][j] = mb;\n      que.push(P(mb, i * W + j));\n    }\n  }\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    double cost = p.first;\n\n    int x = p.second % W;\n    int y = p.second / W;\n    if(cost > dist[y][x] + EPS) continue;\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      if(field[y2][x2] == '.' && dist[y2][x2] > cost + 1 + EPS){\n\tdist[y2][x2] = cost + 1;\n\tque.push(P(cost + 1, y2 * W + x2));\n      }\n    }\n  }\n}\n\nbool C(double mb){\n  dijkstra(gx, gy, mb);\n  int cnt = 0;\n  double sum = 0.0;\n  rep(i, H)rep(j, W){\n    //    cout << setw(6) << dist[i][j] << (j == W - 1 ? '\\n':' ');\n    if(field[i][j] == '.') sum += dist[i][j], cnt++;\n  }\n  return mb < sum / cnt;\n}\n\nint main(){\n  while(cin >> W >>H){\n\n    rep(i, H){\n      cin >> field[i];\n      rep(j, W){\n\tif(field[i][j] == 's') {\n\t  sx = j;\n\t  sy = i;\n\t  field[i][j] = '.';\n\t}\n\tif(field[i][j] == 'g'){\n\t  gx = j;\n\t  gy = i;\n\t}\n      }\n    }\n    double ub = 1e10;    \n    double lb = 0;\n    rep(i, 100){\n      double mb = (ub + lb) / 2;\n      if(C(mb)) lb = mb;\n      else ub = mb; \n    }\n    dijkstra(gx, gy, lb);\n    //    cout << lb << endl;\n    cout << fixed << setprecision(12) << dist[sy][sx] << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int w,h;\n  cin>>w>>h;\n  vector<string> c(h);\n  for(int i=0;i<h;i++){\n    cin>>c[i];\n  }\n  const int INF=1e9;\n  vector<vector<int>> spr(h,vector<int>(w,INF));\n  queue<pair<int,int>> que;\n  pair<int,int> s;\n  pair<int,int> t;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(c[i][j]=='s'){\n\ts={i,j};\n\tc[i][j]='.';\n      }\n      if(c[i][j]=='g'){\n\tt={i,j};\n      }\n      if(c[i][j]=='*'){\n\tque.push({i,j});\n\tspr[i][j]=0;\n      }\n    }\n  }\n  int dx[]={1,-1,0,0};\n  int dy[]={0,0,1,-1};\n  auto isRange=[=](int i,int j){\n    return 0<=i && i<h && 0<=j && j<w;\n  };\n  \n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && spr[p.first][p.second]+1<spr[toh][tow]){\n\tspr[toh][tow]=spr[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n  vector<vector<int>> goal(h,vector<int>(w,INF));\n  goal[t.first][t.second]=0;\n  que.push(t);\n  while(!que.empty()){\n    auto p=que.front();\n    que.pop();\n    for(int dir=0;dir<4;dir++){\n      int toh=p.first+dx[dir];\n      int tow=p.second+dy[dir];\n      if(isRange(toh,tow) && c[toh][tow]=='.' && goal[p.first][p.second]+1<goal[toh][tow]){\n\tgoal[toh][tow]=goal[p.first][p.second]+1;\n\tque.push({toh,tow});\n      }\n    }\n  }\n\n  double ub=10000000000000;\n  double lb=0;\n\n  for(int i=0;i<1000;i++){\n    double mid=(lb+ub)/2;\n    double sum=0;\n    int cnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(c[i][j]=='.'){\n\t  sum+=min<double>(goal[i][j],mid+spr[i][j]);\n\t  cnt++;\n\t}\n      }\n    }\n    sum/=cnt;\n    if(mid<sum){\n      lb=mid;\n    }\n    else{\n      ub=mid;\n    }\n  }\n  cout<<setprecision(15)<<fixed;\n  cout<<min<double>(goal[s.first][s.second],lb+spr[s.first][s.second])<<endl;\n  return 0;\n}\n  \n\n  \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\nconst long double INF = 1e17;\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint W, H;\nstring field[505];\nint sh, sw, gh, gw;\nlong double dist[505][505];\nstruct query {\n    int h, w;\n    long double cost;\n    query(int _h, int _w, long double _cost) {\n        h = _h;\n        w = _w;\n        cost = _cost;\n    }\n};\n\nbool operator <(query a, query b) {\n    return a.cost < b.cost;\n}\n\nbool operator >(query a, query b) {\n    return a.cost > b.cost;\n}\n\nbool chmin(long double &a, long double b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> W >> H;\n    for(int h = 1; h <= H; h++) {\n        cin >> field[h];\n        field[h] = \"#\" + field[h];\n        for(int w = 1; w <= W; w++) {\n            if(field[h][w] == 's') {\n                sh = h;\n                sw = w;\n            }\n            if(field[h][w] == 'g') {\n                gh = h;\n                gw = w;\n            }\n            if(field[h][w] == '.') {\n            }\n        }\n    }\n    long double ok = 1e16;\n    long double ng = 0;\n    priority_queue<query, vector<query>, greater<query>> que;\n    for(int _ = 1; _ <= 100; _++) {\n        long double mid = (ok + ng) / 2.0;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                dist[h][w] = INF;\n                if(field[h][w] == '*') {\n                    que.emplace(h, w, mid);\n                    dist[h][w] = mid;\n                }\n            }\n        }\n        dist[gh][gw] = 0;\n        que.emplace(gh, gw, 0);\n        while(!que.empty()) {\n            query now = que.top();\n            que.pop();\n            long double newcost = now.cost + 1.0;\n            for(int k = 0; k < 4; k++) {\n                int newh = now.h + dh[k];\n                int neww = now.w + dw[k];\n                if(field[newh][neww] == '#') {\n                    continue;\n                }\n                if(field[newh][neww] == '*') {\n                    continue;\n                }\n                if(chmin(dist[newh][neww], newcost)) que.emplace(newh, neww, newcost);\n            }\n        }\n        long double distsum = 0.0;\n        long double grids = 0.0;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                if(field[h][w] == '#') continue;\n                if(field[h][w] == '*') continue;\n                if(field[h][w] == 'g') continue;\n                if(abs(dist[h][w] - INF) < EPS) continue;\n                grids += 1.0;\n                distsum += dist[h][w];\n            }\n        }\n        /*\n        cerr << \"----\" << mid << \"----\" << endl;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) cerr << dist[h][w] << \" \";\n            cerr << endl;\n        }\n        */\n        if(distsum / grids < mid) ok = mid;\n        else ng = mid;\n        if(_ == 100) {\n            cout << fixed << setprecision(20) << dist[sh][sw] << endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tvector<pair<long long int, long long int>>tile;\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t\ttile.push_back( make_pair( i, j ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<one>que;\n\tfor( auto x : warp ) {\n\t\tque.push( make_pair( 0, x ) );\n\t}\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tif( len[now.second.first][now.second.second].second < now.first ) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first++;\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double maxExpectedValue = W*H*100, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 16300; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( auto point : tile ) {\n\t\t\tlong long int i = point.first, j = point.second;\n\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  100000000000000007\n\ntypedef long double ld;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint w,h;\n\n\nld sp_calc(vector<string> &v,vector<vector<ld> > &dp){\n\tld ans = 0;\n\tld d = 0.0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='.'){\n\t\t\t\td += 1.0;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans /= d;\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> v(h);\n\tfor(int i=0;i<h;i++){\n\t\tcin >> v[i];\n\t}\n\tvector<vector<ld> > d1(h,vector<ld>(w,inf)),d2(h,vector<ld>(w,inf)),dp(h,vector<ld>(w));\n\tqueue<pair<int,int> > q1,q2;\n\tint x_s,y_s;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(v[i][j]=='g'){\n\t\t\t\td1[i][j] = 0.0;\n\t\t\t\tq1.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='*'){\n\t\t\t\td2[i][j] = 0.0;\n\t\t\t\tq2.push(MP(i,j));\n\t\t\t}\n\t\t\tif(v[i][j]=='s'){\n\t\t\t\tx_s = i;\n\t\t\t\ty_s = j;\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q1.empty()){\n\t\tpair<int,int> p;\n\t\tp = q1.front();\n\t\tq1.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d1[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td1[x+dx[i]][y+dy[i]] = d1[x][y]+1.0;\n\t\t\t\t\tq1.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!q2.empty()){\n\t\tpair<int,int> p;\n\t\tp = q2.front();\n\t\tq2.pop();\n\t\tint x,y;\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[x+dx[i]][y+dy[i]]=='.'){\n\t\t\t\tif(d2[x+dx[i]][y+dy[i]]==inf){\n\t\t\t\t\td2[x+dx[i]][y+dy[i]] = d2[x][y]+1.0;\n\t\t\t\t\tq2.push(MP(x+dx[i],y+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(d2[x_s][y_s]==inf){\n\t\tcout << fixed << setprecision(15) << d1[x_s][y_s] << endl;\n\t\treturn 0;\n\t}\n\tld up = 100000000000.0;\n\tld low = 0.0;\n\tld mid;\n\tint counter = 0;\n\twhile(1){\n\t\tcounter++;\n\t\tif(counter >1000)break;\n\t\tmid = (up+low)/2.0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tdp[i][j] = 0.0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(d1[i][j]<d2[i][j]+mid){\n\t\t\t\t\tdp[i][j] = d1[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = d2[i][j]+mid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(sp_calc(v,dp)>mid){\n\t\t\tlow = mid;\n\t\t}else{\n\t\t\tup = mid;\n\t\t}\n\t}\n\tcout << fixed << setprecision(15) << dp[x_s][y_s] << endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[600][600];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\ndouble ijk[600][600];\nint v[600][600];\ndouble eps=1e-12;\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\tijk[i][j]=1e20;\n\tint sr,sc,gr,gc;\n\tqueue<pair<int,int> > Q;\n\tint cnt=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='s'){sr=i;sc=j;}\n\t\t\tif(str[i][j]=='g'){\n\t\t\t\tgr=i;gc=j;\n\t\t\t\tijk[i][j]=0;\n\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'&&str[i][j]!='*'&&str[i][j]!='g')cnt++;\n\twhile(Q.size()){\n\t\tint row=Q.front().first;\n\t\tint col=Q.front().second;Q.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk[row+dx[i]][col+dy[i]]>eps+ijk[row][col]+1){\n\t\t\t\tijk[row+dx[i]][col+dy[i]]=ijk[row][col]+1;\n\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t}\n\t\t}\n\t}\n\tbool upd=false;\n\tdo{\n\t\tupd=false;\n\t\tdouble val=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]!='#'&&str[i][j]!='*'&&str[i][j]!='g')val+=ijk[i][j];\n\t\tval/=cnt;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='*'){\n\t\t\t\tijk[i][j]=val;\n\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&str[row+dx[i]][col+dy[i]]!='#'&&str[row+dx[i]][col+dy[i]]!='*'&&ijk[row+dx[i]][col+dy[i]]>eps+ijk[row][col]+1){\n\t\t\t\t\tupd=true;\n\t\t\t\t\tijk[row+dx[i]][col+dy[i]]=ijk[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t/*\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++)printf(\"%f \",ijk[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}while(upd);\n\tprintf(\"%.12f\\n\",ijk[sr][sc]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=INF;\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=100000000000LL,lower=0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) sum+=min((double)dist_goal[y][x],dist_spring[y][x]+E);\n\t\t\t\telse sum+=dist_spring[y][x]+E;\n\t\t\t}\n\t\t}\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/rational.hpp>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct poLL{\n  LL x;\n  LL y;\n  LL count;\n};\n\nint main(){\n  LL houkou[5]={0,1,0,-1,0};\n  cin >> w >> h;\n  vector<vector<LL>> field(h,vector<LL>(w));\n  list<struct poLL> spring;\n  char c;\n  LL sx,sy,gx,gy;\n  LL numofFloor=0;\n  for(LL i=0;i<h;i++){\n    for(LL j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<LL>> toGoal(h,vector<LL>(w,0));\n  vector<vector<LL>> toSpring(h,vector<LL>(w,0));\n  queue<struct poLL> bfs;\n  struct poLL now;\n  LL nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(LL i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  cout << fixed <<  setprecision(12);\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> left=0;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> right=10000000000000000000;\n   cout << left << endl;\n   cout << right << endl;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> mid;\n  boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>> count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(LL i=1;i<h-1;i++){\n      for(LL j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor);\n            }else{\n              count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)mid/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n   cout << left << endl;\n   cout << right << endl;\n   cout << count << endl;\n  // for(LL i=0;i<h;i++){\n  //   for(LL j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << \" \";\n  //         }else{\n  //           cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[i][j]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx],(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor) << endl;\n    }else{\n      cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)toSpring[sy][sx]+(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)left/(boost::multiprecision::number<boost::multiprecision::cpp_dec_float<100>>)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst int MAX = 501,IINF = INT_MAX;\nconst ld LDINF = 1e100;\nint H,W,sx,sy,gx,gy;\nld mincost[MAX][MAX][2]; // mincost[][][0] => from start, [1] = > from star\nchar c[MAX][MAX];\nbool ban[MAX][MAX];\nvector<int> star,plane;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void bfs(vector<int> sp,vector<int> Forbidden,int type){\n  rep(i,H)rep(j,W) mincost[i][j][type] = LDINF, ban[i][j] = false;\n  queue<int> que;\n  rep(i,(int)sp.size()) que.push(sp[i]), mincost[sp[i]/W][sp[i]%W][type] = 0;\n  rep(i,(int)Forbidden.size()) ban[Forbidden[i]/W][Forbidden[i]%W] = true;\n\n  while(!que.empty()){\n    int cur = que.front(); que.pop();\n    rep(i,4){\n      int nx = cur % W + dx[i], ny = cur / W + dy[i];\n      if( c[ny][nx] == '#' ) continue;\n      if( ban[ny][nx] ) continue;\n      if( mincost[ny][nx][type] == LDINF ) {\n        mincost[ny][nx][type] = mincost[cur/W][cur%W][type] + 1;\n        que.push(nx+ny*W);\n      }\n    }\n  }\n}\n\nbool check(ld E){\n  ld T = 0;\n\n  rep(i,(int)plane.size()){\n    int x = plane[i] % W, y = plane[i] / W;\n    T += min(mincost[y][x][0],mincost[y][x][1]+E);\n  }\n\n  ld len = plane.size();\n  return len * E > T;\n}\n\nint main(){\n  cin >> W >> H;\n  rep(i,H)rep(j,W){\n    cin >> c[i][j];\n    if( c[i][j] == 's' ) sx = j, sy = i, c[i][j] = '.';\n    if( c[i][j] == 'g' ) gx = j, gy = i;\n    if( c[i][j] == '*' ) star.push_back(j+i*W);\n    if( c[i][j] == '.' ) plane.push_back(j+i*W);\n  }\n\n  vector<int> sp,forbidden;\n  sp.push_back(gx+gy*W);\n  forbidden = star;\n  forbidden.push_back(gx+gy*W);\n  bfs(sp,forbidden,0);\n\n  sp = star;\n  forbidden.push_back(gx+gy*W);\n  //forbidden.clear();\n  bfs(sp,forbidden,1);\n\n  ld L = 0, R = 1e20, M = 0;\n  rep(i,90){\n    M = ( L + R ) * (ld)0.5;\n    if( check(M) ) R = M;\n    else           L = M;\n  }\n\n  cout << setiosflags(ios::fixed) << setprecision(20) << min((ld)mincost[sy][sx][0],(ld)mincost[sy][sx][1]+L) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Double = long double;\nsigned main(){\n  Int h,w;\n  cin>>w>>h;\n  vector<string> s(h);\n  for(Int i=0;i<h;i++) cin>>s[i];\n  vector<vector<Int> > dg(h,vector<Int>(w,-1)),ds=dg;\n  using T = pair<Int,int>;\n  queue<T> qg,qs;\n  \n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(s[i][j]=='g'){\n\tqg.push(T(i,j));\n\tdg[i][j]=0;\n      }\n      if(s[i][j]=='*'){\n\tqs.push(T(i,j));\n\tds[i][j]=0;\n      }\n    }\n  }\n\n  Int dy[]={0,0,1,-1};\n  Int dx[]={1,-1,0,0};\n  auto bfs=[&](queue<T> &q,vector<vector<Int> > &d){\n    while(!q.empty()){\n      T t=q.front();q.pop();\n      Int y=t.first,x=t.second;\n      for(Int k=0;k<4;k++){\n\tInt ny=y+dy[k],nx=x+dx[k];\n\tif(s[ny][nx]=='#') continue;\n\tif(~d[ny][nx]&&d[ny][nx]<=d[y][x]+1) continue;\n\td[ny][nx]=d[y][x]+1;\n\tq.push(T(ny,nx));\n      }\n    }\n    if(0){\n      cout<<endl;\n      for(Int i=0;i<h;i++){\n\tfor(Int j=0;j<w;j++){\n\t  if(d[i][j]<0) cout<<\"x\";\n\t  else cout<<hex<<d[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n  };\n\n  bfs(qg,dg);\n  bfs(qs,ds);\n\n  auto get=[&](Int i,Int j,Double p){\n    if(~dg[i][j]&&~ds[i][j])\n      return min((Double)dg[i][j],ds[i][j]+p);\n    if(~ds[i][j]) return ds[i][j]+p;\n    if(~dg[i][j]) return (Double)dg[i][j];\n    return Double(0);\n  };\n  \n  auto calc=[&](Double p){\n    Double q=0,c=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tif(s[i][j]=='#'||s[i][j]=='g'||s[i][j]=='*') continue;\n\tc+=1.0;\n\tq+=get(i,j,p);\n      }\n    }\n    q/=c;\n    //printf(\"%.12Lf %.12Lf\\n\",p, p-q);\n    return p-q;\n  };\n\n  Double l=0,r=1e100;\n\n  for(int k=0;k<1000;k++){\n    Double m=(l+r)/2;\n    if(calc(m)<=Double(0)) l=m;\n    else r=m;\n  }\n  \n  //printf(\"%.12f\\n\",calc(l));\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      if(s[i][j]=='s')\n\tprintf(\"%.12Lf\\n\",get(i,j,l));\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1e9;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nint w,h;\nvector<string> mp;\n\nvector<vector<int> > bfs(char start){\n  int dx[] = {1,-1,0,0};\n  int dy[] = {0,0,1,-1};\n  \n  queue<P> Q;\n  vector<vector<int> > D(h,vector<int> (w,INF));\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == start) Q.push(P(i,j)), D[i][j] = 0;\n\n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y, x; tie(y, x) = t;\n    for(int i=0;i<4;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n      if(mp[ny][nx] == '#' || mp[ny][nx] == '*') continue;\n      if(D[ny][nx] != INF) continue;\n      D[ny][nx] = D[y][x] + 1;\n      Q.push(P(ny, nx));\n    }  \n  }\n  return D;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  cin>>w>>h;\n  mp.resize(h);\n  cin>>mp;\n\n  P S, T;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == 's') S = P(i,j), mp[i][j] = '.';\n      if(mp[i][j] == 'g') T = P(i,j);\n    }\n\n  auto DB = bfs('*');\n  auto DT = bfs('g');\n  \n  vector<P> A;\n  double dot = 0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] != '.') continue;\n      A.push_back(P(DB[i][j], DT[i][j]));\n      dot++;\n    }\n\n  \n  int sum = 0;\n  for(auto p:A) sum += p.second;\n\n  sort(A.begin(),A.end(),[&](auto a,auto b){return a.first - a.second < b.first - b.second;});\n  \n  \n  int sy = S.first, sx = S.second;\n  auto calc=[&](double x){return DB[sy][sx] + x;};\n  \n  double ans = calc(sum/dot);\n  Min(ans, (double)DT[sy][sx]);\n  for(int i=0;i<(int)A.size() - 1;i++){\n    sum += A[i].first - A[i].second;\n    double x = sum / (dot - i - 1);\n    Min(ans, calc(x));\n  }\n  \n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=1000000000000;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=INF;\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=10000000000000,lower=0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) sum+=min((double)dist_goal[y][x],dist_spring[y][x]+E);\n\t\t\t\telse sum+=dist_spring[y][x]+E;\n\t\t\t}\n\t\t}\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 18;\n\nconst int cmax=250010;\nint w,h;\nll d[cmax];\nll e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg)const{\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[cmax];\n\nvoid dijkstra(char s,char o,ll* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\tll dsum=0;\n\tll esum=0;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tif(d[idx]!=inf){\n\t\t\t\tex[n].d=d[idx];\n\t\t\t\tex[n++].e=e[idx];\n\t\t\t}else\n\t\t\t\tesum+=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\trep(i,n) dsum+=ex[i].d;\n\tdouble ans=(1.0*(dsum+esum)/n+e[sidx]);\n\tfor(int i=n;i>=1;--i){\n\t\tans=min(ans,1.0*(dsum+esum)/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tdsum-=ex[cur].d;\n\t\tdsum+=ex[cur].e;\n\t}\n\tif(d[sidx]!=inf)\n\t\tans=min(ans,1.0*d[sidx]);\n\tcout.precision(16);\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint H,W;\nchar c[555][555];\nint sy,sx,gy,gx;\nint dist1[555][555],dist2[555][555];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tcin>>W>>H;\n\trep(i,H)rep(j,W){\n\t\tcin>>c[i][j];\n\t\tif(c[i][j]=='s')sy=i,sx=j,c[i][j]='.';\n\t\tif(c[i][j]=='g')gy=i,gx=j;\n\t}\n\trep(i,H)rep(j,W){\n\t\tdist1[i][j]=dist2[i][j]=INF;\n\t}\n\tdist1[gy][gx]=0;\n\tqueue<pi> Q;\n\tQ.push(mp(gy,gx));\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist1[ny][nx]==INF){\n\t\t\t\tdist1[ny][nx]=dist1[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,H)rep(j,W)if(c[i][j]=='*'){\n\t\tdist2[i][j]=0;\n\t\tQ.push(mp(i,j));\n\t}\n\twhile(sz(Q)){\n\t\tpi p=Q.front();Q.pop();\n\t\tint y=p.fir,x=p.sec;\n\t\trep(d,4){\n\t\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\t\tif(c[ny][nx]=='.' && dist2[ny][nx]==INF){\n\t\t\t\tdist2[ny][nx]=dist2[y][x]+1;\n\t\t\t\tQ.push(mp(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvi d1,d2;\n\tint start;\n\trep(i,H)rep(j,W)if(c[i][j]=='.'){\n\t\tif(i==sy && j==sx)start=sz(d1);\n\t\td1.pb(dist1[i][j]);\n\t\td2.pb(dist2[i][j]);\n\t}\n\t\n\tdouble lo=0,hi=1e10;\n\trep(t,100){\n\t\tdouble mi=(lo+hi)/2;\n\t\tdouble sum=0;\n\t\trep(i,sz(d1)){\n\t\t\tsum+=min(1.*d1[i],d2[i]+mi);\n\t\t}\n\t\tif(sum>mi*sz(d1))lo=mi;\n\t\telse hi=mi;\n\t}\n\tprintf(\"%.16f\\n\",min(1.*d1[start],d2[start]+hi));\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <queue>\n#include <cassert>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> PD;\ntypedef long double ld;\n\nconst int MN = 550;\nconst int INT_INF = 1<<28;\nconst int d4[4][2] = {\n    {0, 1},\n    {1, 0},\n    {0, -1},\n    {-1, 0}\n};\n\n\nint w, h;\nstring g[MN];\nint dist2g[MN][MN];\nint dist2b[MN][MN];\n\nbool bc(int x, int y) {\n    return (0 <= x && x < w && 0 <= y && y < h);\n}\n\n\nvoid init2g() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2g[y][x] = INT_INF;\n            if (g[y][x] == 'g') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2g[y][x] < INT_INF) continue;\n        dist2g[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#' || g[ny][nx] == '*') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nvoid init2b() {\n    queue<PD> q;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            dist2b[y][x] = INT_INF;\n            if (g[y][x] == '*') {\n                q.push(PD(x, y, 0));\n            }\n        }\n    }\n    while (!q.empty()) {\n        int x, y, d;\n        tie(x, y, d) = q.front(); q.pop();\n        if (dist2b[y][x] < INT_INF) continue;\n        dist2b[y][x] = d;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + d4[i][0], ny = y + d4[i][1];\n            if (!bc(nx, ny)) continue;\n            if (g[ny][nx] == '#') continue;\n            q.push(PD(nx, ny, d+1));\n        }\n    }\n}\n\nint main() {\n    cin >> w >> h;\n    for (int i = 0; i < w; i++) {\n        cin >> g[i];\n    }\n    int pc = 0;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == '#') continue;\n            if (g[y][x] == '*') continue;\n            if (g[y][x] == 'g') continue;\n            pc++;\n        }\n    }\n    init2g(); init2b();\n    /*printf(\"pc %d\\n\", pc);\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2g[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2g[y][x]);\n            }\n        } printf(\"\\n\");\n    }\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (dist2b[y][x] == INT_INF) {\n                printf(\"-1 \");\n            } else {\n                printf(\"%2d \", dist2b[y][x]);\n            }\n        } printf(\"\\n\");\n    }*/\n    int sx, sy;\n    for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n            if (g[y][x] == 's') {\n                sx = x; sy = y;\n            }\n        }\n    }\n    if (dist2b[sy][sx] == INT_INF) {\n        assert(dist2g[sy][sx] < INT_INF);\n        printf(\"%d\\n\", dist2g[sy][sx]);\n        return 0;\n    }\n    ld l = 0, r = 1e18;\n    while (r - l > 1e-12) {\n//        printf(\"%Lf %Lf\\n\", l, r);\n        ld md = (l+r)/2;\n        ld e = 0;\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n                if (g[y][x] == '#') continue;\n                if (g[y][x] == '*') continue;\n                if (g[y][x] == 'g') continue;\n                if (dist2g[y][x] == INT_INF) {\n                    e += dist2b[y][x] + md;\n                    continue;\n                }\n                assert(dist2b[y][x] != INT_INF);\n                e += min<ld>(dist2g[y][x], dist2b[y][x]+md);\n            }\n        }\n        e /= pc;\n//        printf(\"emd %Lf %Lf\\n\", e, md);\n        if (e > md) {\n            l = md;\n        } else {\n            r = md;\n        }\n    }\n    printf(\"%.20Lf\\n\", min<ld>(dist2g[sy][sx], dist2b[sy][sx]+l));\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long long int, pair<long long int, long long int>>one;\n\n#define mod 1000000007LL\nint main() {\n\tlong long int W, H;\n\tcin >> W >> H;\n\tvector<string>D( H );\n\tlong long int counttile = 0;\n\tpair<long long int, long long int>start, goal;\n\tvector<pair<long long int, long long int>>warp;\n\tvector<vector<pair<long long int, long long int>>>len( H, vector<pair<long long int, long long int>>( W, make_pair( LLONG_MAX / 500 / 500 / 500, LLONG_MAX / 500 / 500 / 500 ) ) );\n\tfor( size_t i = 0; i < H; i++ ) {\n\t\tcin >> D[i];\n\t\tfor( size_t j = 0; j < D[i].length(); j++ ) {\n\t\t\tif( D[i][j] == 's' ) {\n\t\t\t\tD[i][j] = '.';\n\t\t\t\tstart.first = i;\n\t\t\t\tstart.second = j;\n\t\t\t\tcounttile++;\n\t\t\t} else if( D[i][j] == 'g' ) {\n\t\t\t\tgoal.first = i;\n\t\t\t\tgoal.second = j;\n\t\t\t} else if( D[i][j] == '*' ) {\n\t\t\t\twarp.push_back( make_pair( i, j ) );\n\t\t\t} else if( D[i][j] == '.' ) {\n\t\t\t\tcounttile++;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {1,0,-1,0};\n\t{\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, goal ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].first > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].first = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor( auto x : warp ) {\n\t\tpriority_queue<one, vector<one>, greater<one>>que;\n\t\tque.push( make_pair( 0, x ) );\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\tnext.first++;\n\t\t\t\tnext.second.first += dx[i];\n\t\t\t\tnext.second.second += dy[i];\n\t\t\t\tif( 0 <= next.second.first&&next.second.first < H && 0 <= next.second.second &&next.second.second < W ) {\n\t\t\t\t\tif( D[next.second.first][next.second.second] == '.' ) {\n\t\t\t\t\t\tif( len[next.second.first][next.second.second].second > next.first ) {\n\t\t\t\t\t\t\tlen[next.second.first][next.second.second].second = next.first;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double maxExpectedValue = LDBL_MAX / 6, minExpectedValue = 0;\n\tfor( size_t indexindex = 0; indexindex < 100000; indexindex++ ) {\n\t\tlong double midExpectedValue = ( maxExpectedValue + minExpectedValue ) / 2.L;\n\t\t//cout << fixed << setprecision( 20 ) << maxExpectedValue << \" \" << minExpectedValue << endl;\n\t\tlong double countExpectedValue = 0;\n\t\tfor( size_t i = 0; i < H; i++ ) {\n\t\t\tfor( size_t j = 0; j < W; j++ ) {\n\t\t\t\tif( D[i][j] == '.' ) {\n\t\t\t\t\tcountExpectedValue += min( 1.L* len[i][j].first, len[i][j].second + midExpectedValue );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcountExpectedValue /= counttile;\n\t\tif( midExpectedValue < countExpectedValue ) {\n\t\t\tminExpectedValue = midExpectedValue;\n\t\t} else {\n\t\t\tmaxExpectedValue = midExpectedValue;\n\t\t}\n\t}\n\t//cout << fixed << setprecision( 20 ) << 1.L* len[start.first][start.second].first << \" \" << len[start.first][start.second].second + maxExpectedValue << endl;\n\tcout << fixed << setprecision( 20 ) << min( 1.L* len[start.first][start.second].first, len[start.first][start.second].second + maxExpectedValue ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 18;\n\nconst int cmax=250010;\nint w,h;\nint d[cmax];\nint e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg)const{\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[cmax];\n\nvoid dijkstra(char s,char o,int* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tex[n].d=d[idx];\n\t\t\tex[n++].e=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\tdouble ans=d[sidx];\n\tll sum=0;\n\trep(i,n) sum+=ex[i].d;\n\tfor(int i=n;i>=1;--i){\n\t\tans=min(ans,1.0*sum/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tsum-=ex[cur].d;\n\t\tsum+=ex[cur].e;\n\t}\n\tcout.precision(16);\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define vi vector<int>\n\n#define ll long long\n#define vl vector<ll>\n#define vll vector<vl>\n#define double long double\n\nconst int INF = 1e9;\n\nconst int di[] = {0, 1, 0, -1};\nconst int dj[] = {1, 0, -1, 0};\nint w, h;\nstring s[500];\nint f[500][500];\nint g[500][500];\nint si, sj, gi, gj;\n\nconst double inf = 1e18; \n\nvoid sub(double prob) {\n\tusing State = pair<int, pair<int, int>>;\n\tqueue<State> Q;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (s[i][j] == '*') {\n\t\t\t\tf[i][j] = 0;\n\t\t\t\tg[i][j] = 0;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint ni = i + di[k];\n\t\t\t\t\tint nj = j + dj[k];\n\t\t\t\t\tQ.push(make_pair(1, make_pair(ni, nj)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (!Q.empty()) {\n\t\tauto q = Q.front(); Q.pop();\n\t\tint c = q.first;\n\t\tint i = q.second.first;\n\t\tint j = q.second.second;\n\t\tif (s[i][j] == '#') continue;\n\t\tif (g[i][j] < INF) continue;\n\t\tg[i][j] = c;\n\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tint ni = i + di[k];\n\t\t\tint nj = j + dj[k];\n\t\t\tQ.push(make_pair(c + 1, make_pair(ni, nj)));\n\t\t}\n\t}\n\n\n\tQ.push(make_pair(0, make_pair(gi, gj)));\n\twhile (!Q.empty()) {\n\t\tauto q = Q.front(); Q.pop();\n\t\tint c = q.first;\n\t\tint i = q.second.first;\n\t\tint j = q.second.second;\n\t\tif (s[i][j] == '#') continue;\n\t\tif (f[i][j] < INF) continue;\n\t\tf[i][j] = c;\n\n\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\tint ni = i + di[k];\n\t\t\tint nj = j + dj[k];\n\t\t\tQ.push(make_pair(c + 1, make_pair(ni, nj)));\n\t\t}\n\t}\n}\n\ndouble get(int i, int j, double prob) {\n\tdouble val = inf;\n\tif (f[i][j] < INF) val = min<double>(val, f[i][j]);\n\tif (g[i][j] < INF) val = min<double>(val, g[i][j] + prob);\n\treturn val;\n}\n\ndouble avg(double prob) {\n\tdouble sum = 0;\n\tint cnt = 0;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (s[i][j] == '.' || s[i][j] == 's') {\n\t\t\t\tsum += get(i, j, prob);\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum / cnt;\n}\n\nint main() {\n\tcin >> w >> h;\n\tfor (int i = 0; i < h; ++i) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (s[i][j] == 's') {\n\t\t\t\tsi = i;\n\t\t\t\tsj = j;\n\t\t\t} else if(s[i][j] == 'g') {\n\t\t\t\tgi = i;\n\t\t\t\tgj = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble lo = 0;\n\tdouble hi = 1e17;\n\trep(z, 200) {\n\t\tdouble mid = (lo + hi) / 2;\n\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tf[i][j] = INF;\n\t\t\t\tg[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tsub(mid);\n\n\t\tif (avg(mid) < mid) {\n\t\t\thi = mid;\n\t\t} else {\n\t\t\tlo = mid;\n\t\t}\n\t}\n\n\tcout << setprecision(16) << fixed << get(si, sj, lo) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-10;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint w, h;\nconst int WMAX = 600;\nchar field[WMAX][WMAX];\nint springd[WMAX][WMAX];\nint goald[WMAX][WMAX];\nint sy, sx, gy, gx;\nvector<pair<int,int>> floors;\n\nld expected(int y, int x, ld e) {\n  return min((ld)goald[y][x], springd[y][x] + e);\n}\n\nld solve() {\n  ld lb = 0, ub = INF;\n  int len = (int)floors.size();\n  while (ub > lb + EPS) {\n    cout << lb << \" \" << ub << endl;\n    ld mid = (lb + ub) / 2;\n    ld sum = 0;\n    for (pair<int,int> floor:floors) {\n      int y = floor.first, x = floor.second;\n      sum += expected(y, x, mid);\n    }\n    sum /= len;\n    if (sum >= mid) lb = mid;\n    else ub = mid;\n  }\n  return expected(sy, sx, lb);\n}\n\nvoid dfs() {\n  queue<tuple<int,int,int>> que;\n  que.push(make_tuple(0, gy, gx));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if ((field[y][x] != '.' && field[y][x] != 'g') ||\n        goald[y][x] <= dist) continue;\n    goald[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n\n  REP(y, h) REP(x, w)\n    if (field[y][x] == '*') que.push(make_tuple(0, y, x));\n  while (!que.empty()) {\n    tuple<int,int,int> p = que.front(); que.pop();\n    int y = get<1>(p), x = get<2>(p), dist = get<0>(p);\n    if (field[y][x] == '#' || springd[y][x] <= dist) continue;\n    springd[y][x] = dist;\n    REP(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      que.push(make_tuple(dist + 1, ny, nx));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(12);\n  cin >> w >> h;\n  REP(y, h) {\n    string row; cin >> row;\n    REP(x, w) field[y][x] = row[x];\n  }\n  REP(y, h) REP(x, w) {\n    goald[y][x] = springd[y][x] = INF;\n    if (field[y][x] == 's') field[y][x] = '.', sy = y, sx = x;\n    if (field[y][x] == 'g') gy = y, gx = x;\n    if (field[y][x] == '.') floors.emplace_back(y, x);\n  }\n  dfs();\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nP dlt[4]={P(1,0),P(0,1),P(-1,0),P(0,-1)};\n\nvector<vector<char>> c;\nll h,w,f;\nP sp,gp;\nvector<P> spr;\nvector<vector<ll>> g_cost;\nvector<vector<ll>> s_cost;\n\nbool isfloor(P p) {\n\tif(p.first>=0&&p.first<h&&p.second>=0&&p.second<w&&\n\t   (c[p.first][p.second]=='.'||c[p.first][p.second]=='s')) return true;\n\telse return false;\n}\n\nvector<vector<ll>> dijkstra(vector<P> s) {\n\tvector<vector<ll>> dst(h,vector<ll>(w,INF*INF));\n\tpriority_queue<pair<ll,P>,vector<pair<ll,P>>,greater<pair<ll,P>>> q;\n\tREP(i,(ll)s.size()) {\n\t\tdst[s[i].first][s[i].second]=0;\n\t\tq.push(make_pair(0,s[i]));\n\t}\n\twhile(!q.empty()) {\n\t\tll d=q.top().first;\n\t\tP p=q.top().second;\n\t\tq.pop();\n\t\tif(dst[p.first][p.second]!=d) continue;\n\t\tREP(i,4) {\n\t\t\tP np=P(p.first+dlt[i].first,p.second+dlt[i].second);\n\t\t\tif(isfloor(np)&&dst[np.first][np.second]>d+1) {\n\t\t\t\tdst[np.first][np.second]=d+1;\n\t\t\t\tq.push(make_pair(dst[np.first][np.second],np));\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}\n\nvoid init() {\n\tcin>>w>>h;\n\tc.assign(h,vector<char>(w));\n\tREP(i,h) REP(j,w) cin>>c[i][j];\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') f++;\n\tREP(i,h) REP(j,w) if(c[i][j]=='s') sp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='g') gp=P(i,j);\n\tREP(i,h) REP(j,w) if(c[i][j]=='*') spr.pb(P(i,j));\n\tg_cost=dijkstra(vector<P>(1,gp));\n\ts_cost=dijkstra(spr);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tinit();\n\tif(g_cost[sp.first][sp.second]<=s_cost[sp.first][sp.second]) {\n\t\tcout<<fixed<<setprecision(39)<<g_cost[sp.first][sp.second]<<endl;\n\t\treturn 0;\n\t}\n\tll cons=0;\n\tll cf=0;\n\tpriority_queue<ll,vector<ll>,greater<ll>> diff;\n\tREP(i,h) REP(j,w) if(c[i][j]=='.'||c[i][j]=='s') {\n\t\tif(g_cost[i][j]==INF*INF) {\n\t\t\tcons+=s_cost[i][j];\n\t\t\tcf++;\n\t\t\tcontinue;\n\t\t}\n\t\tcons+=g_cost[i][j];\n\t\tif(s_cost[i][j]<g_cost[i][j]) diff.push(s_cost[i][j]-g_cost[i][j]);\n\t}\n\tld min_x=cons/(ld)(f-cf);\n\twhile(!diff.empty()) {\n\t\tll c=diff.top();\n\t\tdiff.pop();\n\t\tcons+=c;\n\t\tcf++;\n\t\tmin_x=min(min_x,cons/(ld)(f-cf));\n\t}\n\tcout<<fixed<<setprecision(39)<<min(\n\t(ld)g_cost[sp.first][sp.second],s_cost[sp.first][sp.second]+min_x)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst long long INF = 1LL<<40;\n\nvoid minDist(const vector<string>& plane, char start, vector<vector<long long> >& dist)\n{\n    int dy[] = {0, 0, -1, 1};\n    int dx[] = {-1, 1, 0, 0};\n\n    int h = plane.size();\n    int w = plane[0].size();\n    dist.assign(h, vector<long long>(w, INF));\n\n    queue<pair<int, int> > q;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(plane[i][j] == start)\n                q.push(make_pair(i, j));\n        }\n    }\n    int n = 1;\n    while(!q.empty()){\n        queue<pair<int, int> > q1;\n        while(!q.empty()){\n            int y = q.front().first;\n            int x = q.front().second;\n            q.pop();\n            for(int i=0; i<4; ++i){\n                int y1 = y + dy[i];\n                int x1 = x + dx[i];\n                if(0 <= y1 && y1 < h && 0 <= x1 && x1 < w && plane[y1][x1] == '.' && dist[y1][x1] == INF){\n                    q1.push(make_pair(y1, x1));\n                    dist[y1][x1] = n;\n                }\n            }\n        }\n        ++ n;\n        q = q1;\n    }\n}\n\nint main()\n{\n    int w, h;\n    cin >> w >> h;\n\n    vector<string> c(h);\n    vector<vector<bool> > floor(h, vector<bool>(w, false));\n    int n = 0;  // 床の数\n    int sy, sx; // スタート位置\n    for(int i=0; i<h; ++i){\n        cin >> c[i];\n        for(int j=0; j<w; ++j){\n            if(c[i][j] == 's'){\n                sy = i;\n                sx = j;\n                c[i][j] = '.';\n            }\n            if(c[i][j] == '.'){\n                floor[i][j] = true;\n                ++ n;\n            }\n        }\n    }\n\n    vector<vector<long long> > a, b; // ゴールまでの距離、バネまでの距離\n    minDist(c, 'g', a);\n    minDist(c, '*', b);\n\n    multiset<long long> diff;\n    long long sum = 0;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(!floor[i][j])\n                continue;\n\n            sum += b[i][j];\n            diff.insert(a[i][j] - b[i][j]);\n        }\n    }\n\n    double ret = a[sy][sx];\n    for(int i=0; i<n; ++i){\n        sum += *diff.begin();\n        diff.erase(diff.begin());\n        ret = min(ret, b[sy][sx] + sum / (i + 1.0));\n    }\n    printf(\"%.10f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  long double INF = (1e20), l = 0.0, r = INF, exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  for(int t = 0; t < 500; ++t){\n    for(int i = 0; i < H; ++i) fill(exp[i],exp[i]+W,INF);\n    exp[gx][gy] = 0.0;\n    long double mean = (l+r)/2.0;\n    queue< pair<int,int> > que;\n    que.push(make_pair(gx,gy));\n    while(!que.empty()){\n      int x = que.front().first, y = que.front().second;\n      que.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && exp[x_][y_] > exp[x][y]+1){\n\t  exp[x_][y_] = exp[x][y]+1;\n\t  que.push(make_pair(x_,y_));\n\t}\n      }\n    }\n    \n    for(int i = 0; i < springs.size(); ++i){\n      queue< pair<int,int> > que2;\n      que2.push(make_pair(springs[i].first, springs[i].second));\n      exp[springs[i].first][springs[i].second] = mean;\n      while(!que2.empty()){\n\tint x = que2.front().first, y = que2.front().second;\n\tque2.pop();\n\tfor(int k = 0; k < 4; ++k){\n\t  int x_ = x + d[k], y_ = y + d[(k+1)%4];\n\t  if(x_ > H || x_ < 0 || y_ > W || y_ < 0) continue;\n\t  char c = M[x_][y_];\n\t  if(c == '.' && (exp[x_][y_] > exp[x][y]+1)){\n\t    que2.push(make_pair(x_,y_));\n\t    exp[x_][y_] = exp[x][y]+1;\n\t  }\n\t}\n      }\n    }\n\n    long double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  s += exp[i][j];\n\t}\n      }\n    }\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12Lf\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <iostream>\nusing namespace std;\nint main(){\n  int W, H, gx, gy, sx, sy, n = 0;\n  cin >> W >> H;\n  string M[H];\n  vector< pair<int,int> > springs;\n  for(int i = 0; i < H; ++i){\n    cin >> M[i];\n    for(int j = 0; j < W; ++j){\n      if(M[i][j] == 'g'){\n\tgx = i;\n\tgy = j;\n\tM[i][j] = '.';\n      }else if(M[i][j] == 's'){\n\tsx = i;\n\tsy = j;\n\tM[i][j] = '.';\n\t++n;\n      }else if(M[i][j] == '.') ++n;\n      else if(M[i][j] == '*'){\n\tsprings.push_back(make_pair(i,j));\n      }\n    }\n  }\n  double INF = (1e10), l = 0.0, r = INF, exp_[H][W], exp[H][W];\n\n  int d[] = {1,0,-1,0};\n  queue< pair<int,int> > que;\n  que.push(make_pair(gx,gy));\n  for(int i = 0; i < H; ++i){\n    for(int j = 0; j < W; ++j){\n      exp_[i][j] = INF;\n      exp[i][j] = INF;\n    }\n  }\n\n  exp_[gx][gy] = 0.0;\n  while(!que.empty()){\n    int x = que.front().first, y = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k){\n      int x_ = x + d[k], y_ = y + d[(k+1)%4];\n      if(x_ >= H || x_ < 0 || y_ >= W || y_ < 0) continue;\n      char c = M[x_][y_];\n      if(c == '.' && exp_[x_][y_] > exp_[x][y]+1){\n\texp_[x_][y_] = exp_[x][y]+1;\n\tque.push(make_pair(x_,y_));\n      }\n    }\n  }\n  vector< vector<double> > dist_from_spring(H, vector<double>(W, INF));\n  for(int i = 0; i < springs.size(); ++i){\n    queue< pair<int,int> > que2;\n    que2.push(make_pair(springs[i].first, springs[i].second));\n    dist_from_spring[springs[i].first][springs[i].second] = 0;\n    while(!que2.empty()){\n      int x = que2.front().first, y = que2.front().second;\n      que2.pop();\n      for(int k = 0; k < 4; ++k){\n\tint x_ = x + d[k], y_ = y + d[(k+1)%4];\n\tif(x_ >= H || x_ < 0 || y_ >= W || y_ < 0) continue;\n\tchar c = M[x_][y_];\n\tif(c == '.' && (dist_from_spring[x_][y_] > dist_from_spring[x][y]+1)){\n\t  que2.push(make_pair(x_,y_));\n\t  dist_from_spring[x_][y_] = dist_from_spring[x][y]+1;\n\t}\n      }\n    }\n  }\n \n  for(int t = 0; t < 100; ++t){\n    double mean = (l+r)/2.0;\n    double s = 0.0;\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tif(M[i][j] == '.'){\n\t  exp[i][j] = min(exp_[i][j], dist_from_spring[i][j]+mean);\n\t  s += exp[i][j];\n\t}\n      }\n    }\n\n    if(s/n < mean){\n      r = mean;\n    }else{\n      l = mean;\n    }\n  }\n  printf(\"%.12f\\n\",exp[sx][sy]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\n\nconst int inf =1 << 18;\n\nconst int cmax=250010;\nint w,h;\nint d[cmax];\nint e[cmax];\n\nstruct state{\n\tint d,e;\n\tbool operator<(const state &arg)const{\n\t\treturn (d-e) >  (arg.d-arg.e);\n\t}\n};\n\nstring table[510];\n\nint n=0;\nstate ex[cmax];\n\nvoid dijkstra(char s,char o,int* dist){\n\trep(i,cmax) dist[i]=inf;\n\tqueue<pii> q;\n\trep(i,h)rep(j,w){\n\t\tif(table[i][j]==s){\n\t\t\tint idx=w*i+j;\n\t\t\tdist[idx]=0;\n\t\t\tpii in=mp(idx,0);\n\t\t\tq.push(in);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tpii cur=q.front();q.pop();\n\t\tif(dist[cur.first]<cur.second)\n\t\t\tcontinue;\n\t\tint dir[4]={-w,-1,1,w};\n\t\trep(i,4){\n\t\t\tpii next=cur;\n\t\t\tnext.first+=dir[i];\n\t\t\tnext.second++;\n\t\t\tint cw=next.first%w;\n\t\t\tint ch=next.first/w;\n\t\t\tif(table[ch][cw]=='#'||table[ch][cw]==o)\n\t\t\t\tcontinue;\n\t\t\tif(dist[next.first]>next.second){\n\t\t\t\tdist[next.first]=next.second;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid show(int *dist){\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tint idx=i*w+j;\n\t\t\tif(dist[idx]<10)\n\t\t\t\tcout << dist[idx];\n\t\t\telse\n\t\t\t\tcout << '-';\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(void){\n\tcin >> w >> h;\n\trep(i,h) cin >> table[i];\n\tdijkstra('g','*',d);\n\tdijkstra('*','#',e);\n\n\tint sidx;\n\trep(i,h)rep(j,w) {\n\t\tint idx=i*w+j;\n\t\tif(table[i][j]=='.'||table[i][j]=='s'){\n\t\t\tex[n].d=d[idx];\n\t\t\tex[n++].e=e[idx];\n\t\t}\n\t\tif(table[i][j]=='s')\n\t\t\tsidx=idx;\n\t}\n\tsort(ex,ex+n);\n\tdouble ans=d[sidx];\n\tll sum=0;\n\trep(i,n) sum+=ex[i].d;\n\tfor(int i=n;i>=1;--i){\n\n\t\tans=min(ans,1.0*sum/i+e[sidx]);\n\t\tint cur=n-i;\n\t\tsum-=ex[cur].d;\n\t\tsum+=ex[cur].e;\n\t}\n\tcout.precision(12);\n\tcout << fixed << ans << endl;\n\tshow(d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nchar field[550][550];\nint H,W;\n\nint dis[550][550],dis2[550][550];\nvector<int> si,sj;\n\nvoid bfs(int res[550][550]){\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++) res[i][j]=-1;\n\tqueue<int> qi,qj;\n\tfor(int i=0;i<si.size();i++){\n\t\tqi.push(si[i]);\n\t\tqj.push(sj[i]);\n\t\tres[si[i]][sj[i]]=0;\n\t}\n\twhile(!qi.empty()){\n\t\tint i=qi.front();\n\t\tqi.pop();\n\t\tint j=qj.front();\n\t\tqj.pop();\n\t\tint c=res[i][j];\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nc=c+1;\n\t\t\tint ni=i+dx[k];\n\t\t\tint nj=j+dy[k];\n\t\t\tif(field[ni][nj]!='.') continue;\n\t\t\tif(res[ni][nj]!=-1&&res[ni][nj]<=nc) continue;\n\t\t\tres[ni][nj]=nc;\n\t\t\tqi.push(ni);\n\t\t\tqj.push(nj);\n\t\t}\n\t}\n}\n\nbool check(double x){\n\tint cnt=0;\n\tdouble sum=0;\n\tvector<double> vec;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]!='.') continue;\n\t\tdouble tmp=1e11;\n\t\tif(dis[i][j]!=-1){\n\t\t\ttmp=dis[i][j];\n\t\t}\n\t\tif(dis2[i][j]!=-1){\n\t\t\ttmp=min(tmp,x+dis2[i][j]);\n\t\t}\n\t//\tsum+=tmp;\n\t\tvec.push_back(tmp);\n\t\tcnt++;\n\t}\n\tsort(tmp.begin(),tmp.end());\n\tfor(int i=0;i<cnt;i++) sum+=tmp[i];\n\tif(x<sum/cnt) return true;\n\treturn false;\n}\n\nint main(){\n\tscanf(\"%d%d\",&W,&H);\n\tfor(int i=0;i<H;i++){\n\t\tscanf(\"%s\",field[i]);\n\t}\n\tint sti=-1,stj=-1;\n\tint gi=-1,gj=-1;\n\tint cnt=0;\n\tfor(int i=0;i<H;i++) for(int j=0;j<W;j++){\n\t\tif(field[i][j]=='s'){\n\t\t\tfield[i][j]='.';\n\t\t\tsti=i,stj=j;\n\t\t}\n\t\telse if(field[i][j]=='g'){\n\t\t\tfield[i][j]='#';\n\t\t\tgi=i,gj=j;\n\t\t}\n\t\telse if(field[i][j]=='*'){\n\t\t\tsi.push_back(i);\n\t\t\tsj.push_back(j);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tbfs(dis2);\n\tsi.clear();\n\tsj.clear();\n\tsi.push_back(gi);\n\tsj.push_back(gj);\n\tbfs(dis);\n\tif(cnt==0){\n\t\tprintf(\"%d\\n\",dis[sti][stj]);\n\t\treturn 0;\n\t}\n//\tfor(int i=0;i<H;i++){\n//\t\tfor(int j=0;j<W;j++) printf(\"%d \",dis[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tdouble lb=0,ub=1e10;\n\tfor(int stage=0;stage<500;stage++){\n\t\tdouble mid=(ub+lb)/2;\n\t\tbool flg=check(mid);\n\t\tif(flg) lb=mid;\n\t\telse ub=mid;\n\t}\n\tdouble ans=1e10;\n\tif(dis[sti][stj]!=-1) ans=dis[sti][stj];\n\tif(dis2[sti][stj]!=-1) ans=min(ans,dis2[sti][stj]+lb);\n\tprintf(\"%.9f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n    public Point(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State{\n    public int x, y, cnt;\n    State(int x, int y, int cnt){\n        this.x = x;\n        this.y = y;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n    public static final int scale = 18;\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main(){\n        Scanner sc = new Scanner(System.in);\n\n        while(sc.hasNext()){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for(int i=0;i<h;i++){\n                String str = sc.next();\n                for(int j=0;j<w;j++){\n                    wall[i][j] = true;\n                    if(str.charAt(j) == 's'){\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if(str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if(str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if(str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis(){\n        Queue<State> q = new LinkedList<State>();\n        int cnt_nowall_i = 0;\n\n        //cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if(!wall[i][j]){\n                    cnt_nowall_i++;\n                    //cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n        cnt_nowall = new BigDecimal(cnt_nowall_i);\n\n        for(q.offer(new State(go.x, go.y, 0)); !q.isEmpty();){\n            State u = q.poll();\n            for(int i=0;i<4;i++){\n                State u2 = new State(u.x+dx[i], u.y+dy[i], u.cnt+1);\n                if(!wall[u2.y][u2.x] && (dis_go[u2.y][u2.x] == -1 || dis_go[u2.y][u2.x] > u2.cnt)){\n                    dis_go[u2.y][u2.x] = u2.cnt;\n                    q.offer(u2);\n                } else u2 = null;\n            }\n            u = null;\n        }\n\n        for(Point vi : v){\n            for(q.offer(new State(vi.x, vi.y, 0)); !q.isEmpty();){\n                State u = q.poll();\n                for(int i=0;i<4;i++){\n                    State u2 = new State(u.x+dx[i], u.y+dy[i], u.cnt+1);\n                    if(!wall[u2.y][u2.x] && (dis_sp[u2.y][u2.x] == -1 || dis_sp[u2.y][u2.x] > u2.cnt)){\n                        dis_sp[u2.y][u2.x] = u2.cnt;\n                        q.offer(u2);\n                    } else u2 = null;\n                }\n                u = null;\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base){\n        BigDecimal a = BigDecimal.ONE, b = BigDecimal.ZERO, exp_go = BigDecimal.ZERO;\n\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(!wall[i][j]){\n                    if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, scale, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n\n        init_dis();\n        BigDecimal dis_sp_st = BigDecimal.valueOf(dis_sp[st.y][st.x]);\n\n        if(dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if(dis_sp[st.y][st.x] != -1){\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n            while(ri - le >= 4){\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(dis_sp_st);\n                res1 = calc_exp(mid1).add(dis_sp_st);\n                res2 = calc_exp(mid2).add(dis_sp_st);\n                if(mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if(res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for(int i=le;i<le+5;i++) {\n                if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if(res == null) res = calc_exp(i).add(dis_sp_st);\n                else res = res.min(calc_exp(i).add(dis_sp_st));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int w,h;\n    cin >> w >> h;\n    vector<string> c(h);\n    int sy,sx,gy,gx;\n    rep(i,0,h){\n        cin >> c[i];\n        rep(j,0,w){\n            if(c[i][j]=='s'){\n                sy=i;\n                sx=j;\n            }\n            if(c[i][j]=='g'){\n                gy=i;\n                gx=j;\n            }\n        }\n    }\n\n\n    int dy[]={0,1,0,-1},dx[]={1,0,-1,0};\n    vector<vector<int64_t>> a(h,vector<int64_t>(w,inf64)),b(h,vector<int64_t>(w,inf64));\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and (c[y][x]=='.' or c[y][x]=='s');\n    };\n    auto bfs=[&](int y0,int x0,int c){\n        queue<tuple<int,int,int64_t>> que;\n        que.push(make_tuple(y0,x0,0));\n        while(!que.empty()){\n            tuple<int,int,int> t=que.front();\n            que.pop();\n            int y=get<0>(t),x=get<1>(t);\n            int64_t d=get<2>(t);\n            if(c==0){\n                if(a[y][x]<=d) continue;\n                a[y][x]=d;\n            }\n            if(c==1){\n                if(b[y][x]<=d) continue;\n                b[y][x]=d;\n            }\n            rep(i,0,4){\n                int ny=y+dy[i],nx=x+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_tuple(ny,nx,d+1));\n            }\n        }\n    };\n    rep(i,0,h){\n        rep(j,0,w){\n            if(c[i][j]=='*') bfs(i,j,0);\n            if(c[i][j]=='g') bfs(i,j,1);\n        }\n    }\n\n    auto g=[&](long double e){\n        long double sum=0;\n        int count=0;\n        rep(y,0,h){\n            rep(x,0,w){\n                if(c[y][x]=='#' or c[y][x]=='*' or c[y][x]=='g') continue;\n                sum+=min(a[y][x]+e,(long double)b[y][x]);\n                ++count;\n            }\n        }\n        return sum/count;\n    };\n\n    long double lb=0,ub=inf64;\n    rep(i,0,128){\n        long double mid=(lb+ub)/2;\n        if(mid<g(mid)) lb=mid;\n        else ub=mid;\n    }\n\n    cout << min(a[sy][sx]+lb,(long double)b[sy][sx]) << endl;\n }\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n//#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\nusing ld = long double;\nusing pdii = pair<ld, pii>;\nchar A[505][505];\nconstexpr ld INF = 1e13;\nconstexpr int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};\nconstexpr ld EPS = 1e-11;\nld ans;\nint W, H;\nint sx, sy, gx, gy;\nld dp[505][505];\nbool done[505][505];\nusing pdi = pair<ld, int>;\npriority_queue<pdi, vector<pdi>, greater<pdi>> que;\nld calcerr(ld mid) {\n    REP(i, H) REP(j, W) {\n        dp[i][j] = INF;\n        done[i][j] = false;\n    }\n\n    REP(i, H) REP(j, W) {\n        if (A[i][j] == '*') {\n            dp[i][j] = mid;\n            que.push({mid, i * W + j});\n        }\n    }\n\n    dp[gx][gy] = 0;\n    done[gx][gy] = true;\n    que.push({0, gx * W + gy});\n    while (!que.empty()) {\n        pdi p = que.top();\n        que.pop();\n        int x = p.second / W, y = p.second % W;\n        done[x][y] = true;\n        // if (res > dp[x][y]) continue;\n        // dp[x][y] = min(dp[x][y], res);\n        REP(k, 4) {\n            int ni = x + dx[k], nj = y + dy[k];\n            if (ni >= 0 && ni < H && nj >= 0 && nj < W && A[ni][nj] != '#' && A[ni][nj] != '*' && !done[ni][nj]) {\n                if (dp[x][y] + 1 < dp[ni][nj]) {\n                    dp[ni][nj] = dp[x][y] + 1;\n                    que.push({dp[ni][nj], ni * W + nj});\n                }\n            }\n        }\n    }\n    ld sum = 0;\n    int cnt = 0;\n    REP(i, H) {\n        REP(j, W) {\n            if (A[i][j] != '#' && A[i][j] != '*' && A[i][j] != 'g' && done[i][j]) {\n                cnt++;\n                sum += dp[i][j];\n            }\n        }\n    }\n    ld res = (sum / cnt);\n\n    ans = dp[sx][sy];\n    return abs(res - mid);\n}\nconst ld phi = (3 - sqrtl(5)) / 2.0;\n\nbool solve() {\n    cin >> W >> H;\n    REP(i, H) REP(j, W) {\n        cin >> A[i][j];\n        if (A[i][j] == 's') {\n            sx = i, sy = j;\n        }\n        if (A[i][j] == 'g') {\n            gx = i, gy = j;\n        }\n    }\n\n    ld l = 1, r = 1e10;\n    ld m1, m2, e1, e2;\n    int las = 0;\n    REP(_, 86) {\n        m1 = l + phi * (r - l), m2 = r - phi * (r - l);\n        swap(e1, e2);\n        if (las == 0) {\n            e1 = calcerr(m1);\n            e2 = calcerr(m2);\n        } else if (las == 1) {\n            e2 = calcerr(m2);\n        } else {\n            e1 = calcerr(m1);\n        }\n        if (e1 > e2) {\n            l = m1;\n            las = 1;\n        } else {\n            r = m2;\n            las = 2;\n        }\n    }\n    cout << fixed << setprecision(15) << ans << endl;\n}\n\nsigned main() {\n    // while (solve())\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    cout<<fixed<<setprecision(10);\n}}init;\n\ninline bool isWall(char c){return c=='#';}\ninline bool isSpring(char c){return c=='*';}\ninline bool isFloor(char c){return c=='.'||c=='s';}\ninline bool isStart(char c){return c=='s';}\ninline bool isGoal(char c){return c=='g';}\ntemplate<typename T>\nistream& operator>>(istream& is,vector<T>& v){\n    for(auto &it:v)is>>it;\n    return is;\n}\ntypedef long long LL;\nusing P=pair<int,int>;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF=1e12;\nconst int dir4[]={0,1,0,-1,0};\nint main(){\n    int R,C;\n    cin>>C>>R;\n    vector<string> maze(R);\n    int sr,sc,gr,gc,M=0;\n    cin>>maze;\n    \n    queue<P> que;\n    VV dG(R,V(C,INF));\n    VV dB(R,V(C,INF));\n    for(int r=0;r<R;r++)\n        for(int c=0;c<C;c++){\n            if(isSpring(maze[r][c])){\n                dB[r][c]=0;\n                que.push(P(r,c));\n            }\n            if(isFloor(maze[r][c])){\n                M++;\n            }\n            if(isStart(maze[r][c])){\n                sr=r,sc=c;\n            }\n            if(isGoal(maze[r][c])){\n                gr=r,gc=c;\n            }\n        }\n    while(que.size()){\n        int r,c;\n        tie(r,c)=que.front();\n        for(int i=0;i<4;i++){\n            int nr=r+dir4[i];\n            int nc=c+dir4[i+1];\n            if(isWall(maze[nr][nc]))continue;\n            if(dB[nr][nc]>dB[r][c]+1){\n                dB[nr][nc]=dB[r][c]+1;\n                que.push(P(nr,nc));\n            }\n        }\n        que.pop();\n    }\n    que.push(P(gr,gc));\n    dG[gr][gc]=0;\n    while(que.size()){\n        int r,c;\n        tie(r,c)=que.front();\n        for(int i=0;i<4;i++){\n            int nr=r+dir4[i];\n            int nc=c+dir4[i+1];\n            if(isWall(maze[nr][nc])||isSpring(maze[nr][nc]))continue;\n            if(dG[nr][nc]>dG[r][c]+1){\n                dG[nr][nc]=dG[r][c]+1;\n                que.push(P(nr,nc));\n            }\n        }\n        que.pop();\n    }\n    vector<P> fs;\n    auto b=[&](P p){return max(0ll,min(INF,dG[p.first][p.second]-dB[p.first][p.second]));};\n    for(int r=0;r<R;r++)\n        for(int c=0;c<C;c++)\n            if(isFloor(maze[r][c])){\n                fs.push_back(P(r,c));\n            }\n    sort(fs.begin(),fs.end(),[&](P p,P q){return b(p)<b(q);});\n    LL K=0;\n    int B=M;\n    for(int i=0,sz=fs.size();i<sz;i++){\n        K+=dB[fs[i].first][fs[i].second];\n    }\n    double res=INF;\n    K-=dB[fs[0].first][fs[0].second];\n    K+=dG[fs[0].first][fs[0].second];\n    B--;\n    LL prev=b(fs[0]);\n    for(int i=1,sz=fs.size();i<sz;i++){\n        LL now=b(fs[i]);\n        if(now!=prev){\n            double b=1.0-B/(double)M;\n            b=(K/(double)M)/b;\n            if(prev<=b&&b<=now){\n                res=min(res,b);\n            }\n        }\n        K-=dB[fs[i].first][fs[i].second];\n        K+=dG[fs[i].first][fs[i].second];\n        B--;\n        prev=now;\n    }\n    if(prev<INF){\n        double b=1.0-B/(double)M;\n        b=(K/(double)M)/b;\n        if(prev<=b&&b<=INF){\n            res=min(res,b);\n        }\n    }\n    cout<<min((double)dG[sr][sc],dB[sr][sc]+res)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint W, H;\nvoid bfs(int dist[500][500], int sx, int sy, string grid[500]){\n  queue<int> qx, qy;\n  qx.push(sx); qy.push(sy);\n  dist[sy][sx] = 0;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(); qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r], ny = y + dy[r];\n      if(valid(nx, ny, W, H) && grid[ny][nx] == '.'){\n        if(dist[ny][nx] == -1 || dist[ny][nx] > dist[y][x] + 1){\n          dist[ny][nx] = dist[y][x] + 1;\n          qx.push(nx);\n          qy.push(ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W){\n    string grid[500];\n    REP(i, H) cin >> grid[i];\n\n    int sx, sy;\n    REP(y, H) REP(x, W) if(grid[y][x] == 's') {\n      sx = x, sy = y;\n      grid[y][x] = '.';\n    }\n\n    int N = 0;\n    REP(y, H) REP(x, W) if(grid[y][x] == '.') N++;\n\n    int dist_goal[500][500], dist_spring[500][500];\n    memset(dist_goal, -1, sizeof dist_goal);\n    memset(dist_spring, -1, sizeof dist_spring);\n    REP(y, H) REP(x, W) if(grid[y][x] == 'g') bfs(dist_goal, x, y, grid);\n    REP(y, H) REP(x, W) if(grid[y][x] == '*') bfs(dist_spring, x, y, grid);\n    REP(y, H) REP(x, W) if(dist_goal[y][x] == -1) dist_goal[y][x] = INF;\n    REP(y, H) REP(x, W) if(dist_spring[y][x] == -1) dist_spring[y][x] = INF;\n\n    double lb = 0, ub = 1e9;\n    REP(_, 100){\n      const double sum = (ub + lb) * 0.5;\n      double S = sum;\n      REP(y, H) REP(x, W)if(grid[y][x] == '.'){\n        double exp = min((double)dist_goal[y][x], dist_spring[y][x] + sum / N);\n        S -= exp;\n      }\n      if(S > 0){\n        ub = sum;\n      }else{\n        lb = sum;\n      }\n    }\n    double all_exp = (ub + lb) * 0.5 / N;\n    printf(\"%.12f\\n\", min((double)dist_goal[sy][sx], dist_spring[sy][sx] + all_exp));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct point{\n  int x;\n  int y;\n  int count;\n};\n\nint main(){\n  int houkou[5]={0,1,0,-1,0};\n  int w,h;\n  cin >> w >> h;\n  vector<vector<int>> field(h,vector<int>(w));\n  list<struct point> spring;\n  char c;\n  int sx,sy,gx,gy;\n  int numofFloor=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> c;\n      if(c=='.'){\n        field[i][j]=1;\n        numofFloor++;\n      }else if(c=='#'){\n        field[i][j]=0;\n      }else if(c=='*'){\n        field[i][j]=2;\n        spring.push_back({j,i,0});\n      }else if(c=='s'){\n        field[i][j]=1;\n        sx=j;\n        sy=i;\n        numofFloor++;\n      }else{\n        field[i][j]=3;\n        gx=j;\n        gy=i;\n      }\n    }\n  }\n  vector<vector<int>> toGoal(h,vector<int>(w,0));\n  vector<vector<int>> toSpring(h,vector<int>(w,0));\n  queue<struct point> bfs;\n  struct point now;\n  int nx,ny;\n  bfs.push({gx,gy,0});\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(int i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toGoal[ny][nx]==0&&field[ny][nx]==1){\n          toGoal[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  for(auto itr=spring.begin();itr!=spring.end();itr++){\n    bfs.push({(*itr).x,(*itr).y,0});\n  }\n  while(!bfs.empty()){\n    now=bfs.front();\n    bfs.pop();\n    for(int i=0;i<4;i++){\n      nx=now.x+houkou[i];\n      ny=now.y+houkou[i+1];\n      if(0<=nx&&nx<=w&&0<=ny&&ny<=h){\n        if(toSpring[ny][nx]==0&&field[ny][nx]==1){\n          toSpring[ny][nx]=now.count+1;\n          bfs.push({nx,ny,now.count+1});\n        }\n      }\n    }\n  }\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     cout << toGoal[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << endl;\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     cout << toSpring[i][j] << \" \";\n  //   }\n  //   cout << endl;\n  // }\n  // cout << numofFloor << endl;\n  double left=0;\n  double right=(h-2)*(w-2)*(h-2)*(w-2);\n  double mid;\n  double count;\n  while(right-left>0.0000000001){\n    mid=(left+right)/2;\n    count=0;\n    for(int i=1;i<h-1;i++){\n      for(int j=1;j<w-1;j++){\n        if(field[i][j]==1){\n          if(toGoal[i][j]!=0){\n            if(toSpring[i][j]!=0){\n              count+=min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor);\n            }else{\n              count+=(double)toGoal[i][j];\n            }\n          }else{\n            if(toSpring[i][j]!=0) count+=(double)toSpring[i][j]+(double)mid/(double)numofFloor;\n          }\n        }\n      }\n    }\n    if(count<mid){\n      right=mid;\n    }else{\n      left=mid;\n    }\n  }\n  // cout << mid << endl;\n  // cout << count << endl;\n  // for(int i=0;i<h;i++){\n  //   for(int j=0;j<w;j++){\n  //     if(field[i][j]==1){\n  //       if(toGoal[i][j]!=0){\n  //         if(toSpring[i][j]!=0){\n  //           cout << min((double)toGoal[i][j],(double)toSpring[i][j]+(double)mid/(double)numofFloor) << \" \";\n  //         }else{\n  //           cout << (double)toGoal[i][j] << \" \";\n  //         }\n  //       }else{\n  //         if(toSpring[sy][sx]!=0) cout << (double)toSpring[i][j]+(double)mid/(double)numofFloor << \" \";\n  //       }\n  //     }else{\n  //       cout << 0 << \" \";\n  //     }\n  //   }\n  //   cout << endl;\n  // }\n  cout << fixed << setprecision(11);\n  if(toGoal[sy][sx]!=0){\n    if(toSpring[sy][sx]!=0){\n      cout << min((double)toGoal[sy][sx],(double)toSpring[sy][sx]+(double)mid/(double)numofFloor) << endl;\n    }else{\n      cout << (double)toGoal[sy][sx] << endl;\n    }\n  }else{\n    if(toSpring[sy][sx]!=0) cout << (double)toSpring[sy][sx]+(double)mid/(double)numofFloor << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\n\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\ndouble e[500][500];\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(long long i=0;i<500;i++)\n\t\tfor(long long j=0;j<500;j++){\n\t\t\te[i][j]=INF;\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,long long> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\te[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=100;\n\tdouble upper=100000000000,lower=0;\n\tfor(int t=0;t<NUM;t++){\n\t\tdouble sum=0.0;\n\t\tdouble E=(upper+lower)/2.0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) sum+=min((double)dist_goal[y][x],dist_spring[y][x]+E);\n\t\t\t\telse sum+=dist_spring[y][x]+E;\n\t\t\t}\n\t\t}\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E;\n\t\telse lower=E;\n\t}\n\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2336\nspring tiles\n*/\n#include <stdio.h>\n#include <float.h>\n#define GETA 0\n#define OFF 9999\nint W,H;\nchar tiles[500][501];\nint dist_goal[500][501];\nint dist_spring[500][501];\n\n\nprint()\n{\n  int i,j,c;\n  for(i=0;i<H;i++)\n    printf(\"%s\\n\",&(tiles[i][0]));\n  printf(\"\\n\"); \n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W;j++)\n\t{\n\t  c=dist_goal[i][j];\n\t  if(c >0 && c<10)\n\t    printf(\"%d\",c);\n\t  else\n\t    printf(\".\");\n\t}\n      printf(\"\\n\");\n    }\n  printf(\"\\n\"); \n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W;j++)\n\t{\n\t  c=dist_spring[i][j];\n\t  if(c >0 && c<10)\n\t    printf(\"%d\",c);\n\t  else\n\t    printf(\".\");\n\t}\n      printf(\"\\n\");\n    }\n}\n\ninit()\n{\n  int i,j;\n\n  scanf(\"%d %d\",&W,&H);\n  for(i=0;i<H;i++)\n    scanf(\"%s\",&(tiles[i][0]));\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      {\n\tdist_goal[i][j]=OFF;\n\tdist_spring[i][j]=OFF;\n      }\n}\nvoid find_dist_1(int y,int x)\n{ \n  extern void find_dist_1a(int,int,int);\n  find_dist_1a(y,x,0);\n}\nvoid find_dist_1a(int y,int x,int d)\n{ \n  //printf(\"finddist %d %d %d %c\\n\",y,x,d,tiles[y][x]);\n\n  if(tiles[y][x]=='.' ||tiles[y][x]=='s'||tiles[y][x]=='g')\n    if(dist_goal[y][x]==OFF || dist_goal[y][x] > GETA+d)\n      {\n\tdist_goal[y][x]=GETA+d;\n    \n      if(y>0)\n\tfind_dist_1a(y-1,x,d+1);\n      if(y<H-1)\n\tfind_dist_1a(y+1,x,d+1);\n      if(x>0)\n\tfind_dist_1a(y,x-1,d+1);\n      if(x<W-1)\n\tfind_dist_1a(y,x+1,d+1);\n    }\n}\nvoid find_goal(int * y,int * x)\n{\n  int i,j;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(tiles[i][j]=='g')\n\t{*y = i;*x =j;\n\t  return;\n\t}\n}\nvoid calc_dist_goal()\n{\n  int gx,gy;  \n  find_goal(&gy,&gx);\n  //printf(\"find %d %d\\n\",gy,gx);\n  find_dist_1(gy,gx);\n}\nint find_spring(int * y,int * x)\n{\n  int i,j,js;\n\n  js = *x+1;\n  if(js >= W){*y++;js=0;}\n  for(i=*y;i<H;i++)\n    {\n      if(i>*y)\n\tjs=0;\n      for(j=js;j<W;j++)\n\tif(tiles[i][j]=='*')\n\t  {\n\t    *y = i;*x =j;\n\t    return(1);\n\t}\n    }\n  return(0);\n}\n\nvoid calc_dist_spring_1(int y,int x)\n{ \n  extern void find_dist_spring_1a(int,int,int);\n  find_dist_spring_1a(y,x,0);\n}\nvoid find_dist_spring_1a(int y,int x,int d)\n{ \n  //printf(\"finddist %d %d %d %c \",y,x,d,tiles[y][x]);\n  //printf(\"finddist %d \\n\",dist_spring[y][x]);\n\n  if(tiles[y][x]=='.' ||tiles[y][x]=='s'||tiles[y][x]=='g'||tiles[y][x]=='*')\n    if(dist_spring[y][x]==OFF || dist_spring[y][x] > GETA+d)\n      {\n\tdist_spring[y][x]=GETA+d;\n    \n      if(y>0)\n\tfind_dist_spring_1a(y-1,x,d+1);\n      if(y<H-1)\n\tfind_dist_spring_1a(y+1,x,d+1);\n      if(x>0)\n\tfind_dist_spring_1a(y,x-1,d+1);\n      if(x<W-1)\n\tfind_dist_spring_1a(y,x+1,d+1);\n    }\n}\n\n\nvoid calc_dist_spring()\n{\n  int y=0,x=0;\n\n  while(find_spring(&y,&x))\n    {\n      // printf(\"SP %d %d\\n\",y,x);\n      calc_dist_spring_1(y,x);\n   }\n}\ndouble calc_kitaichi()\n{\n  int i,j,k;\n  int tobisaki,bunsi,spring_tikai;\n  double result;\n  int a,b;\n\n  tobisaki=0;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(tiles[i][j]=='.'||tiles[i][j]=='s')\n\ttobisaki++;\n  for(k=0;k<1000;k++)\n    {\n      bunsi = 0;\n      spring_tikai=0;\n      for(i=0;i<H;i++)\n\tfor(j=0;j<W;j++)\n\t  {\n\t    a = dist_spring[i][j] ;\n\t    b = dist_goal[i][j]   ;\n\t    // printf(\"%d %d %d %d %d\\n\",a,b,k,bunsi,spring_tikai);\n\t    if(a == OFF)\n\t      {\n\t\tif(b == OFF)\n\t\t;\n\t\telse\n\t\t  {\n\t\t    bunsi +=(b - GETA );\n\t\t  }\n\t      }\n\t    else\n\t      if(b == OFF)\n\t      {\n\t\tbunsi +=(a - GETA);\n\t\tif(a != GETA)\n\t\t  spring_tikai++;\n\t\t\n\t      }\n\t      else\n\t\t{\n\t\t  //printf(\"%c %c %d %d\\n\",a,b,k,a+k<b);\n\t\t  spring_tikai += (a+k < b)?1:0;\n\t\t  if(a+k < b)\n\t\t    {\n\t\t      bunsi +=(a - GETA);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      //printf(\"*\");\n\t\t      //spring_tikai++;\n\t\t      bunsi +=(b - GETA);\t\t      \n\t\t    }\n\t\t}\n\t  }\n      //printf(\"::%d:%d:%d\\n\",bunsi,tobisaki,spring_tikai);\n      result = ((float)bunsi)/(tobisaki-spring_tikai);\n      if(result >= (float)k && result < (float)(k+1))\n      \tbreak;\n    }\n  return(result);\n}\nvoid search_start(int * y,int * x)\n{\n  int i,j;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(tiles[i][j]=='s')\n\t{*y = i;*x =j;\n\t  return;\n\t}\n}\n#define min(x,y) ((x)>(y))?(y):(x)\n\nmain()\n{\n  int x,y;\n  double ret;\n\n  init();\n  //print();\n  calc_dist_goal();\n  calc_dist_spring();\n  //print();\n  ret=calc_kitaichi();\n  search_start(&y,&x);\n  printf(\"%.10lf\\n\",min(dist_spring[y][x],dist_goal[y][x])+ret);\n  //printf(\"%d %d %d %d\\n\",y,x,dist_spring[y][x],dist_goal[y][x]);\n  //print();\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nclass C{\npublic:\n\tint x,y;\n\tC(int x,int y):x(x),y(y){}\n};\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint w,h;\n\nbool in(int x,int y){\n\tif(x<0 || y<0 || x>=w || y>=h) return false;\n\treturn true;\n}\n\nlong long int dist_goal[500][500],dist_spring[500][500];\n\nconst long long INF=10000000000LL;\n\nint main()\n{\n/*\tdouble m=1000000000000.0;\n\tfor(int i=0;i<1000;i++){\n\t\tcout<<m<<endl;\n\t\tm/=2.0;\n\t}*/\n\n\tcin>>w>>h;\n\tint gx,gy,sx,sy;\n\tvector<string> M(h);\n\tvector<C> spring;\n\tlong long num_normal=0;\n\tfor(int i=0;i<h;i++){\n\t\tcin>>M[i];\n\t\tfor(int j=0;j<M[i].size();j++){\n\t\t\tif(M[i][j]=='s'){sx=j;sy=i;num_normal++;}\n\t\t\tif(M[i][j]=='g'){gx=j;gy=i;}\n\t\t\tif(M[i][j]=='*'){spring.push_back(C(j,i));}\n\t\t\tif(M[i][j]=='.'){num_normal++;}\n\t\t}\n\t}\n\n\tfor(int i=0;i<500;i++)\n\t\tfor(int j=0;j<500;j++){\n\t\t\tdist_goal[i][j]=INF;\n\t\t\tdist_spring[i][j]=INF;\n\t\t}\n\n\tbool visit[500][500];\n\tmemset(visit,false,sizeof(visit));\n\n\tqueue<pair<C,int> > que;\n\tque.push(make_pair(C(gx,gy),0));\n\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tint cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#' || M[now.y][now.x]=='*') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_goal[now.y][now.x]=cost;\n\t\tfor(long long r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\t\n\tfor(long long i=0;i<spring.size();i++)\n\t\tque.push(make_pair(C(spring[i].x,spring[i].y),0));\n\tmemset(visit,false,sizeof(visit));\n\twhile(!que.empty()){\n\t\tC now=que.front().first;\n\t\tlong long cost=que.front().second;\n\t\tque.pop();\n\t\tif(!in(now.x,now.y)) continue;\n\t\tif(M[now.y][now.x]=='#') continue;\n\t\tif(visit[now.y][now.x]) continue;\n\t\tvisit[now.y][now.x]=true;\n\t\tdist_spring[now.y][now.x]=cost;\n\t\tfor(int r=0;r<4;r++){\n\t\t\tque.push(make_pair(C(now.x+dx[r],now.y+dy[r]),cost+1));\n\t\t}\n\t}\n\n\tconst int NUM=1000;\n\tlong double upper=1e20,lower=0.0;\n\tfor(int t=0;t<NUM;t++){\n\t\tlong double sum=0.0;\n\t\tlong double E=(upper+lower)/2.0;\n\t\tvector<long double> work;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]!='.' && M[y][x]!='s') continue;\n\t\t\t\tif(dist_goal[y][x]<INF) work.push_back(min((double)dist_goal[y][x],(double)dist_spring[y][x]+(double)E));\n\t\t\t\telse work.push_back(dist_spring[y][x]+E);\n\t\t\t}\n\t\t}\n//\t\tsort(work.begin(),work.end());\n\t\tfor(int i=0;i<work.size();i++)\n\t\t\tsum+=work[i];\n//\t\tcout<<sum/num_normal<<endl;\n\t\tif(sum/num_normal<E) upper=E-1e-10;\n\t\telse lower=E+1e-10;\n\t}\n//\tcout<<min((double)dist_goal[sy][sx],(upper+lower)/2.0+dist_spring[sy][sx])<<endl;\n\tprintf(\"%.13lf\\n\",min((double)dist_goal[sy][sx],(double)(upper+lower)/2.0+dist_spring[sy][sx]));\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            int counter = 0;\n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \tcounter++;\n            \n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tif(counter % 5 == 0){\n            \t\tSystem.gc();\n            \t}\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint[] dx = { 1, -1, 0, 0 };\n\tint[] dy = { 0, 0, 1, -1 };\n\tchar[][] table;\n\n\tint h, w;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tint sx = -1, sy = -1, gx = -1, gy = -1;\n\t\tdouble n = 0;\n\t\ttable = new char[h][w];\n\t\tlong[][] distance_from_goal = new long[h][w];\n\t\tlong[][] distance_from_spring = new long[h][w];\n\n\t\tArrayDeque<Pair> que1 = new ArrayDeque<>();\n\t\tArrayDeque<Pair> que2 = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\tArrays.fill(distance_from_goal[i], (1 << 30));\n\t\t\tArrays.fill(distance_from_spring[i], (1 << 30));\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == 's') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tn++;\n\t\t\t\t} else if (table[i][j] == 'g') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tdistance_from_goal[gy][gx] = 0;\n\t\t\t\t} else if (table[i][j] == '.')\n\t\t\t\t\tn++;\n\t\t\t\telse if (table[i][j] == '*') {\n\t\t\t\t\tdistance_from_spring[i][j] = 0;\n\t\t\t\t\tque2.add(new Pair(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tque1.add(new Pair(gx, gy));\n\t\twhile (!que1.isEmpty()) {\n\t\t\tPair p = que1.poll();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\tif (on_filed(nx, ny) && distance_from_goal[ny][nx] > distance_from_goal[p.y][p.x] + 1) {\n\t\t\t\t\tdistance_from_goal[ny][nx] = distance_from_goal[p.y][p.x] + 1;\n\t\t\t\t\tif (table[ny][nx] == '.' || table[ny][nx] == 's')\n\t\t\t\t\t\tque1.add(new Pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!que2.isEmpty()) {\n\t\t\tPair p = que2.poll();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\tif (on_filed(nx, ny) && distance_from_spring[ny][nx] > distance_from_spring[p.y][p.x] + 1) {\n\t\t\t\t\tdistance_from_spring[ny][nx] = distance_from_spring[p.y][p.x] + 1;\n\t\t\t\t\tif (table[ny][nx] == '.' || table[ny][nx] == 's')\n\t\t\t\t\t\tque2.add(new Pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble a = 0, b = 0;\n\t\tArrayList<P> list = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '.' || table[i][j] == 's') {\n\t\t\t\t\tif (distance_from_goal[i][j] >= (1 << 30)) {\n\t\t\t\t\t\ta += distance_from_spring[i][j];\n\t\t\t\t\t\tb++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta += distance_from_goal[i][j];\n\t\t\t\t\t\tif (distance_from_spring[i][j] >= (1 << 30)\n\t\t\t\t\t\t\t\t|| distance_from_goal[i][j] <= distance_from_spring[i][j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tlist.add(new P(distance_from_goal[i][j], distance_from_spring[i][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort(null);\n\n\t\t// E=a+bE\n\t\tdouble e = a / (n - b);\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\ta -= list.get(i).d_goal;\n\t\t\ta += list.get(i).d_spring;\n\t\t\tb++;\n\t\t\tif (i + 1 < list.size() && list.get(i).diff == list.get(i + 1).diff)\n\t\t\t\tcontinue;\n\n\t\t\te = Math.min(e, (a / (n - b)));\n\t\t}\n\n\t\tSystem.out.println(Math.min(distance_from_goal[sy][sx], e + distance_from_spring[sy][sx]));\n\t}\n\n\tboolean on_filed(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h && table[y][x] != '#')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tclass Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tlong d_goal;\n\t\tlong d_spring;\n\t\tlong diff;\n\n\t\tpublic P(long d_goal, long d_spring) {\n\t\t\tthis.d_goal = d_goal;\n\t\t\tthis.d_spring = d_spring;\n\t\t\tdiff = d_goal - d_spring;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn -Long.compare(this.diff, o.diff);\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n  \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n  \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n      \n    public static final int[] vs = {1, 0, -1, 0};\n  \n    public static final double EPS = 1e-10;\n      \n    public static boolean bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected){\n        boolean updated = false;\n          \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n        boolean[][] visited = new boolean[H][W];\n          \n        expected_queue.add(expected[sy][sx]);\n        visited[sy][sx] = true;\n        x_queue.add(sx);\n        y_queue.add(sy);\n          \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n              \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                  \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }else if(visited[ny][nx]){\n                    continue;\n                }else if(is_floor[ny][nx] && expected[ny][nx] >= expected[y][x] + 1){\n                    if(expected[ny][nx] - EPS >= expected[y][x] + 1){\n                        updated = true;\n                    }\n                      \n                    expected[ny][nx] = expected[y][x] + 1;\n                    visited[ny][nx] = true;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }else if(!is_floor[ny][nx]){\n                    visited[ny][nx] = true;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n          \n        return updated;\n    }\n      \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n              \n            final double INF = H * W * H * W;\n              \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n              \n            LinkedList<Integer> spling_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spling_ys = new LinkedList<Integer>();\n              \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spling_ys.add(i);\n                        spling_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                      \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n              \n            double[][] expected = new double[H][W];\n            for(int i = 0; i < H; i++){\n                for(int j = 0; j < W; j++){\n                    expected[i][j] = INF;\n                }\n            }\n            expected[gy][gx] = 0;\n              \n            double prev_expected = expected[sy][sx];\n            //while(expected[sy][sx] >= (INF - 1e-9) || Math.abs(expected[sy][sx] - prev_expected) > 1e-9){\n            while(true){\n            //for(int t = 0; t < 20; t++){\n                prev_expected = expected[sy][sx];\n                  \n                boolean updated = false;\n                  \n                updated |= bfs(H, W, gx, gy, is_wall, is_floor, expected);\n                for(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n                    final int x = x_itr.next();\n                    final int y = y_itr.next();\n                      \n                    updated |= bfs(H, W, x, y, is_wall, is_floor, expected);\n                }\n                  \n                  \n                if(!updated){\n                    break;\n                }\n                  \n                  \n                double sum = 0;\n                int count = 0;\n                for(int i = 0; i < H; i++){\n                    for(int j = 0; j < W; j++){\n                        if(!is_floor[i][j]){\n                            continue;\n                        }else if(i == gy && j == gx){\n                            continue;\n                        }\n                          \n                        sum += expected[i][j];\n                        count++;\n                    }\n                }\n                  \n                final double average = sum / count;\n                  \n                for(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n                    final int x = x_itr.next();\n                    final int y = y_itr.next();\n                      \n                    expected[y][x] = average;\n                }\n                /*\n                for(int i = 0; i < H; i++){\n                    for(int j = 0; j < W; j++){\n                        System.out.printf(\"%2.0f \", expected[i][j]);\n                    }\n                    System.out.println();\n                }\n                */\n                //System.out.printf(\"%.10f <- %.10f\\n\", expected[sy][sx], prev_expected);\n            }\n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint[] dx = { 1, -1, 0, 0 };\n\tint[] dy = { 0, 0, 1, -1 };\n\tchar[][] table;\n\tlong INF = 1L << 50;\n\n\tint h, w;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tint sx = -1, sy = -1, gx = -1, gy = -1;\n\t\tdouble n = 0;\n\t\ttable = new char[h][w];\n\t\tlong[][] distance_from_goal = new long[h][w];\n\t\tlong[][] distance_from_spring = new long[h][w];\n\n\t\tArrayDeque<Pair> que1 = new ArrayDeque<>();\n\t\tArrayDeque<Pair> que2 = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\tArrays.fill(distance_from_goal[i], INF);\n\t\t\tArrays.fill(distance_from_spring[i], INF);\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == 's') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tn++;\n\t\t\t\t} else if (table[i][j] == 'g') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tdistance_from_goal[gy][gx] = 0;\n\t\t\t\t} else if (table[i][j] == '.')\n\t\t\t\t\tn++;\n\t\t\t\telse if (table[i][j] == '*') {\n\t\t\t\t\tdistance_from_spring[i][j] = 0;\n\t\t\t\t\tque2.add(new Pair(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tque1.add(new Pair(gx, gy));\n\t\twhile (!que1.isEmpty()) {\n\t\t\tPair p = que1.poll();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\tif (on_filed(nx, ny) && distance_from_goal[ny][nx] > distance_from_goal[p.y][p.x] + 1) {\n\t\t\t\t\tdistance_from_goal[ny][nx] = distance_from_goal[p.y][p.x] + 1;\n\t\t\t\t\tif (table[ny][nx] == '.' || table[ny][nx] == 's')\n\t\t\t\t\t\tque1.add(new Pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!que2.isEmpty()) {\n\t\t\tPair p = que2.poll();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\tif (on_filed(nx, ny) && distance_from_spring[ny][nx] > distance_from_spring[p.y][p.x] + 1) {\n\t\t\t\t\tdistance_from_spring[ny][nx] = distance_from_spring[p.y][p.x] + 1;\n\t\t\t\t\tif (table[ny][nx] == '.' || table[ny][nx] == 's')\n\t\t\t\t\t\tque2.add(new Pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble a = 0, b = 0;\n\t\tArrayList<P> list = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '.' || table[i][j] == 's') {\n\t\t\t\t\tif (distance_from_goal[i][j] >= INF) {\n\t\t\t\t\t\ta += distance_from_spring[i][j];\n\t\t\t\t\t\tb++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta += distance_from_goal[i][j];\n\t\t\t\t\t\tif (distance_from_spring[i][j] >= (1 << 30)\n\t\t\t\t\t\t\t\t|| distance_from_goal[i][j] <= distance_from_spring[i][j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tlist.add(new P(distance_from_goal[i][j], distance_from_spring[i][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort(null);\n\n\t\t// E=a+bE\n\t\tdouble e = a / (n - b);\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\ta -= list.get(i).d_goal;\n\t\t\ta += list.get(i).d_spring;\n\t\t\tb++;\n\t\t\tif (i + 1 < list.size() && list.get(i).diff == list.get(i + 1).diff)\n\t\t\t\tcontinue;\n\n\t\t\te = Math.min(e, (a / (n - b)));\n\t\t}\n\n\t\tSystem.out.println(Math.min(distance_from_goal[sy][sx], e + distance_from_spring[sy][sx]));\n\t}\n\n\tboolean on_filed(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h && table[y][x] != '#')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tclass Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tlong d_goal;\n\t\tlong d_spring;\n\t\tlong diff;\n\n\t\tpublic P(long d_goal, long d_spring) {\n\t\t\tthis.d_goal = d_goal;\n\t\t\tthis.d_spring = d_spring;\n\t\t\tdiff = d_goal - d_spring;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn -Long.compare(this.diff, o.diff);\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n    public Point(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State{\n    public Point p;\n    public int cnt;\n    State(Point p, int cnt){\n        this.p = p;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n    public static final int scale = 18;\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main(){\n        Scanner sc = new Scanner(System.in);\n\n        while(sc.hasNext()){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for(int i=0;i<h;i++){\n                String str = sc.next();\n                for(int j=0;j<w;j++){\n                    wall[i][j] = true;\n                    if(str.charAt(j) == 's'){\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if(str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if(str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if(str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis(){\n        Queue<State> q = new LinkedList<State>();\n        int cnt_nowall_i = 0;\n\n        //cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if(!wall[i][j]){\n                    cnt_nowall_i++;\n                    //cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n        cnt_nowall = new BigDecimal(cnt_nowall_i);\n\n        for(q.offer(new State(go, 0)); !q.isEmpty();){\n            State u = q.poll();\n            for(int i=0;i<4;i++){\n                State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n                    dis_go[u2.p.y][u2.p.x] = u2.cnt;\n                    q.offer(u2);\n                }\n            }\n        }\n\n        for(Point vi : v){\n            for(q.offer(new State(vi, 0)); !q.isEmpty();){\n                State u = q.poll();\n                for(int i=0;i<4;i++){\n                    State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                    if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n                        dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n                        q.offer(u2);\n                    }\n                }\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base){\n        BigDecimal a = BigDecimal.ONE, b = BigDecimal.ZERO, exp_go = BigDecimal.ZERO;\n\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(!wall[i][j]){\n                    if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, scale, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n\n        init_dis();\n        BigDecimal dis_sp_st = BigDecimal.valueOf(dis_sp[st.y][st.x]);\n\n        if(dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if(dis_sp[st.y][st.x] != -1){\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n            while(ri - le >= 4){\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(dis_sp_st);\n                res1 = calc_exp(mid1).add(dis_sp_st);\n                res2 = calc_exp(mid2).add(dis_sp_st);\n                if(mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if(res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for(int i=le;i<le+5;i++) {\n                if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if(res == null) res = calc_exp(i).add(dis_sp_st);\n                else res = res.min(calc_exp(i).add(dis_sp_st));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n    public Point(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State{\n    public Point p;\n    public int cnt;\n    State(Point p, int cnt){\n        this.p = p;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n    public static final int scale = 20;\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main(){\n        Scanner sc = new Scanner(System.in);\n\n        while(sc.hasNext()){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for(int i=0;i<h;i++){\n                String str = sc.next();\n                for(int j=0;j<w;j++){\n                    wall[i][j] = true;\n                    if(str.charAt(j) == 's'){\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if(str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if(str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if(str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis(){\n        Queue<State> q = new LinkedList<State>();\n\n        cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if(!wall[i][j]){\n                    cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n\n        for(q.offer(new State(go, 0)); !q.isEmpty();){\n            State u = q.poll();\n            for(int i=0;i<4;i++){\n                State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n                    dis_go[u2.p.y][u2.p.x] = u2.cnt;\n                    q.offer(u2);\n                }\n            }\n        }\n\n        for(Point vi : v){\n            for(q.offer(new State(vi, 0)); !q.isEmpty();){\n                State u = q.poll();\n                for(int i=0;i<4;i++){\n                    State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                    if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n                        dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n                        q.offer(u2);\n                    }\n                }\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base){\n        BigDecimal a = new BigDecimal(1), b = new BigDecimal(0), exp_go = new BigDecimal(0);\n\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(!wall[i][j]){\n                    if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, scale, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n\n        init_dis();\n\n        if(dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if(dis_sp[st.y][st.x] != -1){\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n            while(ri - le >= 4){\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                res1 = calc_exp(mid1).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                res2 = calc_exp(mid2).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                if(mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if(res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for(int i=le;i<le+5;i++) {\n                if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if(res == null) res = calc_exp(i).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                else res = res.min(calc_exp(i).add(BigDecimal.valueOf(dis_sp[st.y][st.x])));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n    public Point(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State{\n    public Point p;\n    public int cnt;\n    State(Point p, int cnt){\n        this.p = p;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n    public static final int scale = 16;\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main(){\n        Scanner sc = new Scanner(System.in);\n\n        while(sc.hasNext()){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for(int i=0;i<h;i++){\n                String str = sc.next();\n                for(int j=0;j<w;j++){\n                    wall[i][j] = true;\n                    if(str.charAt(j) == 's'){\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if(str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if(str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if(str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis(){\n        Queue<State> q = new LinkedList<State>();\n\n        cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if(!wall[i][j]){\n                    cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n\n        for(q.offer(new State(go, 0)); !q.isEmpty();){\n            State u = q.poll();\n            for(int i=0;i<4;i++){\n                State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n                    dis_go[u2.p.y][u2.p.x] = u2.cnt;\n                    q.offer(u2);\n                }\n            }\n        }\n\n        for(Point vi : v){\n            for(q.offer(new State(vi, 0)); !q.isEmpty();){\n                State u = q.poll();\n                for(int i=0;i<4;i++){\n                    State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                    if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n                        dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n                        q.offer(u2);\n                    }\n                }\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base){\n        BigDecimal a = new BigDecimal(1), b = new BigDecimal(0), exp_go = new BigDecimal(0);\n\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(!wall[i][j]){\n                    if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, scale, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n\n        init_dis();\n\n        if(dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if(dis_sp[st.y][st.x] != -1){\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n            while(ri - le >= 4){\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                res1 = calc_exp(mid1).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                res2 = calc_exp(mid2).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                if(mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if(res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for(int i=le;i<le+5;i++) {\n                if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if(res == null) res = calc_exp(i).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                else res = res.min(calc_exp(i).add(BigDecimal.valueOf(dis_sp[st.y][st.x])));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE >> 8;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n        \t\n            \n            \n            int counter = 0;\n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \tcounter++;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tif(counter % 2 == 0){\n            \t\tSystem.gc();\n            \t}\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, int[][] expected){           \n        LinkedList<Integer> expected_queue = new LinkedList<Integer>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final int INF = H * W;\n            \n            int[][] from_goal = new int[H][W];\n            int[][] from_spring = new int[H][W];\n            for(int i = 0; i < H; i++){\n            \tfor(int j = 0; j < W; j++){\n            \t\tfrom_goal[i][j] = from_spring[i][j] = INF;\n            \t}\n            }\n            from_goal[gy][gx] = 0;\n            for(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n        \t\tfinal int x = x_itr.next();\n        \t\tfinal int y = y_itr.next();\n        \t\t\n        \t\tfrom_spring[y][x] = 0;\n        \t}\n            \n            bfs(H, W, gx, gy, is_wall, is_floor, from_goal);\n            for(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n        \t\tfinal int x = x_itr.next();\n        \t\tfinal int y = y_itr.next();\n        \t\t\n        \t\tbfs(H, W, x, y, is_wall, is_floor, from_spring);\n        \t}\n            /*\n            for(int i = 0; i < H; i++){\n            \tfor(int j = 0; j < W; j++){\n            \t\tSystem.out.print(from_goal[i][j] >= INF ? \"x \" : from_goal[i][j] + \" \");\n            \t}\n            \tSystem.out.println();\n            }\n            */\n                       \n            double upper = Long.MAX_VALUE;\n            double lower = 0;\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += Math.min(from_goal[i][j], from_spring[i][j] + middle);\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            }\n            \n            System.out.printf(\"%.10f\\n\", Math.min(from_goal[sy][sx], from_spring[sy][sx] + lower));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State {\n    public Point p;\n    public int cnt;\n\n    State(Point p, int cnt) {\n        this.p = p;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main() {\n        Scanner sc = new Scanner(System.in);\n\n        while (sc.hasNext()) {\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for (int i = 0; i < h; i++) {\n                String str = sc.next();\n                for (int j = 0; j < w; j++) {\n                    wall[i][j] = true;\n                    if (str.charAt(j) == 's') {\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if (str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if (str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if (str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis() {\n        Queue<State> q = new LinkedList<State>();\n\n        cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if (!wall[i][j]) {\n                    cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n\n        for (q.offer(new State(go, 0)); !q.isEmpty(); ) {\n            State u = q.poll();\n            for (int i = 0; i < 4; i++) {\n                State u2 = new State(new Point(u.p.x + dx[i], u.p.y + dy[i]), u.cnt + 1);\n                if (!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)) {\n                    dis_go[u2.p.y][u2.p.x] = u2.cnt;\n                    q.offer(u2);\n                }\n            }\n        }\n\n        for (Point vi : v) {\n            for (q.offer(new State(vi, 0)); !q.isEmpty(); ) {\n                State u = q.poll();\n                for (int i = 0; i < 4; i++) {\n                    State u2 = new State(new Point(u.p.x + dx[i], u.p.y + dy[i]), u.cnt + 1);\n                    if (!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)) {\n                        dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n                        q.offer(u2);\n                    }\n                }\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base) {\n        BigDecimal a = new BigDecimal(1), b = new BigDecimal(0), exp_go = new BigDecimal(0);\n\n        for (int i = 1; i < h - 1; i++) {\n            for (int j = 1; j < w - 1; j++) {\n                if (!wall[i][j]) {\n                    if (dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base) {\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, 12, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, 12, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, 12, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, 12, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n\n        init_dis();\n\n        if (dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if (dis_sp[st.y][st.x] != -1) {\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if (dis_go[st.y][st.x] == -1) ri = (h - 2) * (w - 2);\n            while (ri - le >= 4) {\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                res1 = calc_exp(mid1).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                res2 = calc_exp(mid2).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                if (mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if (res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for (int i = le; i < le + 5; i++) {\n                if (dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if (res == null) res = calc_exp(i).add(BigDecimal.valueOf(dis_sp[st.y][st.x]));\n                else res = res.min(calc_exp(i).add(BigDecimal.valueOf(dis_sp[st.y][st.x])));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Ideone\n{\n\t\n\tpublic static final int[] vs = {1, 0, -1, 0};\n\n\tpublic static final double EPS = 1e-10;\n\t\n\tpublic static boolean bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected){\n\t\tboolean updated = false;\n\t\t\n\t\tLinkedList<Double> expected_queue = new LinkedList<Double>();\n\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\tboolean[][] visited = new boolean[H][W];\n\t\t\n\t\texpected_queue.add(expected[sy][sx]);\n\t\tvisited[sy][sx] = true;\n\t\tx_queue.add(sx);\n\t\ty_queue.add(sy);\n\t\t\n\t\twhile(!x_queue.isEmpty()){\n\t\t\tfinal int x = x_queue.poll();\n\t\t\tfinal int y = y_queue.poll();\n\t\t\t\n\t\t\tfor(int v = 0; v < vs.length; v++){\n\t\t\t\tfinal int nx = x + vs[v];\n\t\t\t\tfinal int ny = y + vs[(v + 1) % vs.length];\n\t\t\t\t\n\t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}else if(is_wall[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(is_floor[ny][nx] && expected[ny][nx] >= expected[y][x] + 1){\n\t\t\t\t\tif(expected[ny][nx] - EPS >= expected[y][x] + 1){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\texpected[ny][nx] = expected[y][x] + 1;\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t}else if(!is_floor[ny][nx]){\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn updated;\n\t}\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tfinal double INF = H * W;\n\t\t\t\n\t\t\tint sx = -1, sy = -1, gx = -1, gy = -1;\n\t\t\tboolean[][] is_floor = new boolean[H][W];\n\t\t\tboolean[][] is_wall = new boolean[H][W];\n\t\t\t\n\t\t\tLinkedList<Integer> spling_xs = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> spling_ys = new LinkedList<Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfinal char[] line = sc.next().toCharArray();\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(line[j] != '#' && line[j] != '*'){\n\t\t\t\t\t\tis_floor[i][j] = true;\n\t\t\t\t\t}else if(line[j] == '*'){\n\t\t\t\t\t\tspling_ys.add(i);\n\t\t\t\t\t\tspling_xs.add(j);\n\t\t\t\t\t}else if(line[j] == '#'){\n\t\t\t\t\t\tis_wall[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(line[j] == 's'){\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t}else if(line[j] == 'g'){\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] expected = new double[H][W];\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\texpected[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\texpected[gy][gx] = 0;\n\t\t\t\n\t\t\tdouble prev_expected = expected[sy][sx];\n\t\t\t//while(expected[sy][sx] >= (INF - 1e-9) || Math.abs(expected[sy][sx] - prev_expected) > 1e-9){\n\t\t\twhile(true){\n\t\t\t//for(int t = 0; t < 20; t++){\n\t\t\t\tprev_expected = expected[sy][sx];\n\t\t\t\t\n\t\t\t\tboolean updated = false;\n\t\t\t\t\n\t\t\t\tupdated |= bfs(H, W, gx, gy, is_wall, is_floor, expected);\n\t\t\t\tfor(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n\t\t\t\t\tfinal int x = x_itr.next();\n\t\t\t\t\tfinal int y = y_itr.next();\n\t\t\t\t\t\n\t\t\t\t\tupdated |= bfs(H, W, x, y, is_wall, is_floor, expected);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(!updated){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdouble sum = 0;\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\t\tif(!is_floor[i][j]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(i == gy && j == gx){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum += expected[i][j];\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal double average = sum / count;\n\t\t\t\t\n\t\t\t\tfor(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n\t\t\t\t\tfinal int x = x_itr.next();\n\t\t\t\t\tfinal int y = y_itr.next();\n\t\t\t\t\t\n\t\t\t\t\texpected[y][x] = average;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\t\tSystem.out.printf(\"%2.0f \", expected[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t//System.out.printf(\"%.10f <- %.10f\\n\", expected[sy][sx], prev_expected);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.10f\\n\", expected[sy][sx]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, long[][] expected){           \n        LinkedList<Long> expected_queue = new LinkedList<Long>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final long INF = Long.MAX_VALUE / 2 - 1;\n            \n            long[][] from_goal = new long[H][W];\n            long[][] from_spring = new long[H][W];\n            for(int i = 0; i < H; i++){\n            \tfor(int j = 0; j < W; j++){\n            \t\tfrom_goal[i][j] = from_spring[i][j] = INF;\n            \t}\n            }\n            from_goal[gy][gx] = 0;\n            for(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n        \t\tfinal int x = x_itr.next();\n        \t\tfinal int y = y_itr.next();\n        \t\t\n        \t\tfrom_spring[y][x] = 0;\n        \t}\n            \n            bfs(H, W, gx, gy, is_wall, is_floor, from_goal);\n            for(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n        \t\tfinal int x = x_itr.next();\n        \t\tfinal int y = y_itr.next();\n        \t\t\n        \t\tbfs(H, W, x, y, is_wall, is_floor, from_spring);\n        \t}\n            /*\n            for(int i = 0; i < H; i++){\n            \tfor(int j = 0; j < W; j++){\n            \t\tSystem.out.print(from_goal[i][j] >= INF ? \"x \" : from_goal[i][j] + \" \");\n            \t}\n            \tSystem.out.println();\n            }\n            */\n                       \n            double upper = INF;\n            double lower = 0;\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += Math.min(from_goal[i][j], from_spring[i][j] + middle);\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            }\n            \n            System.out.printf(\"%.10f\\n\", Math.min(from_goal[sy][sx], from_spring[sy][sx] + lower));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE >> 16;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n        \tfor(int i = 0; i < H; i++){\n        \t\tfor(int j = 0; j < W; j++){\n        \t\t\texpected[i][j] = INF;\n        \t\t}\n        \t}\n        \texpected[gy][gx] = 0;\n            \n            \n            int counter = 0;\n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \tcounter++;\n            \n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \t\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tif(counter % 2 == 0){\n            \t\tSystem.gc();\n            \t}\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n    public Point(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State{\n    public Point p;\n    public int cnt;\n    State(Point p, int cnt){\n        this.p = p;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n    public static final int scale = 18;\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main(){\n        Scanner sc = new Scanner(System.in);\n\n        while(sc.hasNext()){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for(int i=0;i<h;i++){\n                String str = sc.next();\n                for(int j=0;j<w;j++){\n                    wall[i][j] = true;\n                    if(str.charAt(j) == 's'){\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if(str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if(str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if(str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis(){\n        Queue<State> q = new LinkedList<State>();\n        int cnt_nowall_i = 0;\n\n        //cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if(!wall[i][j]){\n                    cnt_nowall_i++;\n                    //cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n        cnt_nowall = new BigDecimal(cnt_nowall_i);\n\n        for(q.offer(new State(go, 0)); !q.isEmpty();){\n            State u = q.poll();\n            for(int i=0;i<4;i++){\n                State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                if(!wall[u2.p.y][u2.p.x] && (dis_go[u2.p.y][u2.p.x] == -1 || dis_go[u2.p.y][u2.p.x] > u2.cnt)){\n                    dis_go[u2.p.y][u2.p.x] = u2.cnt;\n                    q.offer(u2);\n                } else u2 = null;\n            }\n        }\n\n        for(Point vi : v){\n            for(q.offer(new State(vi, 0)); !q.isEmpty();){\n                State u = q.poll();\n                for(int i=0;i<4;i++){\n                    State u2 = new State(new Point(u.p.x+dx[i], u.p.y+dy[i]), u.cnt+1);\n                    if(!wall[u2.p.y][u2.p.x] && (dis_sp[u2.p.y][u2.p.x] == -1 || dis_sp[u2.p.y][u2.p.x] > u2.cnt)){\n                        dis_sp[u2.p.y][u2.p.x] = u2.cnt;\n                        q.offer(u2);\n                    } else u2 = null;\n                }\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base){\n        BigDecimal a = BigDecimal.ONE, b = BigDecimal.ZERO, exp_go = BigDecimal.ZERO;\n\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(!wall[i][j]){\n                    if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, scale, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n        BigDecimal dis_sp_st = BigDecimal.valueOf(dis_sp[st.y][st.x]);\n\n        init_dis();\n\n        if(dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if(dis_sp[st.y][st.x] != -1){\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n            while(ri - le >= 4){\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(dis_sp_st);\n                res1 = calc_exp(mid1).add(dis_sp_st);\n                res2 = calc_exp(mid2).add(dis_sp_st);\n                if(mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if(res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for(int i=le;i<le+5;i++) {\n                if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if(res == null) res = calc_exp(i).add(dis_sp_st);\n                else res = res.min(calc_exp(i).add(dis_sp_st));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tSystem.gc();\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Ideone\n{\n\t\n\tpublic static final int[] vs = {1, 0, -1, 0};\n\n\tpublic static final double EPS = 1e-10;\n\t\n\tpublic static boolean bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected){\n\t\tboolean updated = false;\n\t\t\n\t\tLinkedList<Double> expected_queue = new LinkedList<Double>();\n\t\tLinkedList<Integer> x_queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> y_queue = new LinkedList<Integer>();\n\t\tboolean[][] visited = new boolean[H][W];\n\t\t\n\t\texpected_queue.add(expected[sy][sx]);\n\t\tvisited[sy][sx] = true;\n\t\tx_queue.add(sx);\n\t\ty_queue.add(sy);\n\t\t\n\t\twhile(!x_queue.isEmpty()){\n\t\t\tfinal int x = x_queue.poll();\n\t\t\tfinal int y = y_queue.poll();\n\t\t\t\n\t\t\tfor(int v = 0; v < vs.length; v++){\n\t\t\t\tfinal int nx = x + vs[v];\n\t\t\t\tfinal int ny = y + vs[(v + 1) % vs.length];\n\t\t\t\t\n\t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\t\tcontinue;\t\n\t\t\t\t}else if(is_wall[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(visited[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(is_floor[ny][nx] && expected[ny][nx] >= expected[y][x] + 1){\n\t\t\t\t\tif(expected[ny][nx] - EPS >= expected[y][x] + 1){\n\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\texpected[ny][nx] = expected[y][x] + 1;\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t}else if(!is_floor[ny][nx]){\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\ty_queue.add(ny);\n\t\t\t\t\tx_queue.add(nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn updated;\n\t}\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\t{\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tfinal double INF = H * W;\n\t\t\t\n\t\t\tint sx = -1, sy = -1, gx = -1, gy = -1;\n\t\t\tboolean[][] is_floor = new boolean[H][W];\n\t\t\tboolean[][] is_wall = new boolean[H][W];\n\t\t\t\n\t\t\tLinkedList<Integer> spling_xs = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> spling_ys = new LinkedList<Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfinal char[] line = sc.next().toCharArray();\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(line[j] != '#' && line[j] != '*'){\n\t\t\t\t\t\tis_floor[i][j] = true;\n\t\t\t\t\t}else if(line[j] == '*'){\n\t\t\t\t\t\tspling_ys.add(i);\n\t\t\t\t\t\tspling_xs.add(j);\n\t\t\t\t\t}else if(line[j] == '#'){\n\t\t\t\t\t\tis_wall[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(line[j] == 's'){\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t}else if(line[j] == 'g'){\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdouble[][] expected = new double[H][W];\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\texpected[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\texpected[gy][gx] = 0;\n\t\t\t\n\t\t\tdouble prev_expected = expected[sy][sx];\n\t\t\t//while(expected[sy][sx] >= (INF - 1e-9) || Math.abs(expected[sy][sx] - prev_expected) > 1e-9){\n\t\t\twhile(true){\n\t\t\t//for(int t = 0; t < 20; t++){\n\t\t\t\tprev_expected = expected[sy][sx];\n\t\t\t\t\n\t\t\t\tboolean updated = false;\n\t\t\t\t\n\t\t\t\tupdated |= bfs(H, W, gx, gy, is_wall, is_floor, expected);\n\t\t\t\tfor(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n\t\t\t\t\tfinal int x = x_itr.next();\n\t\t\t\t\tfinal int y = y_itr.next();\n\t\t\t\t\t\n\t\t\t\t\tupdated |= bfs(H, W, x, y, is_wall, is_floor, expected);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(!updated){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tdouble sum = 0;\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\t\tif(!is_floor[i][j]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(i == gy && j == gx){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tsum += expected[i][j];\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal double average = sum / count;\n\t\t\t\t\n\t\t\t\tfor(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n\t\t\t\t\tfinal int x = x_itr.next();\n\t\t\t\t\tfinal int y = y_itr.next();\n\t\t\t\t\t\n\t\t\t\t\texpected[y][x] = average;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\t\tSystem.out.printf(\"%2.0f \", expected[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t//System.out.printf(\"%.10f <- %.10f\\n\", expected[sy][sx], prev_expected);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.10f\\n\", expected[sy][sx]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            int counter = 0;\n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \tcounter++;\n            \n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tif(counter % 2 == 0){\n            \t\tSystem.gc();\n            \t}\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                //System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] >= expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = (long)(H) * W * H * W;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE >> 4;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tSystem.gc();\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = (long)(H) * H * W * W;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tSystem.gc();\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            int counter = 0;\n            while(upper - lower > EPS){\\\n            \tfinal double middle = (upper + lower) / 2;\n            \tcounter++;\n            \n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tif(counter % 10 == 0){\n            \t\tSystem.gc();\n            \t}\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.*;\n\nclass Point {\n    public int x, y;\n    public Point(int x, int y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass State{\n    public int x, y, cnt;\n    State(int x, int y, int cnt){\n        this.x = x;\n        this.y = y;\n        this.cnt = cnt;\n    }\n}\n\n\n/**\n * C++???????????????????????????????????????????????????????±????\n */\npublic class Main {\n    public static final BigDecimal EPS = new BigDecimal(1e-10);\n    public static final int H = 500;\n    public static final int W = 500;\n    public static final int[] dy = new int[]{-1, 0, 1, 0};\n    public static final int[] dx = new int[]{0, -1, 0, 1};\n    public static final int scale = 18;\n\n    int w, h;\n    int[][] dis_go, dis_sp;\n    BigDecimal cnt_nowall;\n    Point st, go;\n    List<Point> v;\n    Boolean[][] wall;\n\n    public Main(){\n        Scanner sc = new Scanner(System.in);\n\n        while(sc.hasNext()){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            v = new ArrayList<Point>();\n            wall = new Boolean[h][w];\n\n            for(int i=0;i<h;i++){\n                String str = sc.next();\n                for(int j=0;j<w;j++){\n                    wall[i][j] = true;\n                    if(str.charAt(j) == 's'){\n                        st = new Point(j, i);\n                        wall[i][j] = false;\n                    } else if(str.charAt(j) == 'g') {\n                        go = new Point(j, i);\n                    } else if(str.charAt(j) == '*') {\n                        v.add(new Point(j, i));\n                    } else if(str.charAt(j) == '.') {\n                        wall[i][j] = false;\n                    }\n                }\n            }\n            System.out.println(solve());\n        }\n\n        sc.close();\n    }\n\n    private void init_dis(){\n        Queue<State> q = new LinkedList<State>();\n        int cnt_nowall_i = 0;\n\n        //cnt_nowall = new BigDecimal(0);\n        dis_go = new int[h][w];\n        dis_sp = new int[h][w];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++) {\n                dis_go[i][j] = dis_sp[i][j] = -1;\n                if(!wall[i][j]){\n                    cnt_nowall_i++;\n                    //cnt_nowall = cnt_nowall.add(BigDecimal.ONE);\n                }\n            }\n        }\n        cnt_nowall = new BigDecimal(cnt_nowall_i);\n\n        for(q.offer(new State(go.x, go.y, 0)); !q.isEmpty();){\n            State u = q.poll();\n            for(int i=0;i<4;i++){\n                State u2 = new State(u.x+dx[i], u.y+dy[i], u.cnt+1);\n                if(!wall[u2.y][u2.x] && (dis_go[u2.y][u2.x] == -1 || dis_go[u2.y][u2.x] > u2.cnt)){\n                    dis_go[u2.y][u2.x] = u2.cnt;\n                    q.offer(u2);\n                } else u2 = null;\n            }\n            u = null;\n        }\n\n        for(Point vi : v){\n            for(q.offer(new State(vi.x, vi.y, 0)); !q.isEmpty();){\n                State u = q.poll();\n                for(int i=0;i<4;i++){\n                    State u2 = new State(u.x+dx[i], u.y+dy[i], u.cnt+1);\n                    if(!wall[u2.y][u2.x] && (dis_sp[u2.y][u2.x] == -1 || dis_sp[u2.y][u2.x] > u2.cnt)){\n                        dis_sp[u2.y][u2.x] = u2.cnt;\n                        q.offer(u2);\n                    } else u2 = null;\n                }\n                u = null;\n            }\n        }\n    }\n\n    private BigDecimal calc_exp(int base){\n        BigDecimal a = BigDecimal.ONE, b = BigDecimal.ZERO, exp_go = BigDecimal.ZERO;\n\n        for(int i=1;i<h-1;i++){\n            for(int j=1;j<w-1;j++){\n                if(!wall[i][j]){\n                    if(dis_go[i][j] == -1 || dis_sp[i][j] != -1 && dis_go[i][j] >= dis_sp[i][j] + base){\n                        a = a.subtract(BigDecimal.ONE.divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        b = b.add(BigDecimal.valueOf(dis_sp[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //a -= 1.0 / cnt_nowall;\n                        //b += (long double)dis_sp[i][j] / cnt_nowall;\n                    } else {\n                        exp_go = exp_go.add(BigDecimal.valueOf(dis_go[i][j]).divide(cnt_nowall, scale, BigDecimal.ROUND_HALF_UP));\n                        //exp_go += (long double)dis_go[i][j] / cnt_nowall;\n                    }\n                }\n            }\n        }\n\n        return b.add(exp_go).divide(a, scale, BigDecimal.ROUND_HALF_UP);\n        //return (b + exp_go) / a;\n    }\n\n    private BigDecimal solve() {\n        BigDecimal res = null;\n\n        init_dis();\n        BigDecimal dis_sp_st = BigDecimal.valueOf(dis_sp[st.y][st.x]);\n\n        if(dis_go[st.y][st.x] != -1) res = BigDecimal.valueOf(dis_go[st.y][st.x]);\n\n        if(dis_sp[st.y][st.x] != -1){\n            int le = 2, ri = dis_go[st.y][st.x] - dis_sp[st.y][st.x] + 1, mid1, mid2;\n            BigDecimal res0, res1, res2;\n            if(dis_go[st.y][st.x] == -1) ri = (h-2) * (w-2);\n            while(ri - le >= 4){\n                mid1 = (le * 2 + ri) / 3;\n                mid2 = (le + ri * 2) / 3;\n                res0 = calc_exp(le).add(dis_sp_st);\n                res1 = calc_exp(mid1).add(dis_sp_st);\n                res2 = calc_exp(mid2).add(dis_sp_st);\n                if(mid2 - mid1 <= 1) break;\n                //if(res0 >= res1 - EPS && res1 >= res2 - EPS) le = mid1;\n                if(res0.compareTo(res1.subtract(EPS)) == 1 && res1.compareTo(res2.subtract(EPS)) == 1) le = mid1;\n                else ri = mid2;\n            }\n            for(int i=le;i<le+5;i++) {\n                if(dis_go[st.y][st.x] != -1 && dis_go[st.y][st.x] < dis_sp[st.y][st.x] + i) break;\n                if(res == null) res = calc_exp(i).add(dis_sp_st);\n                else res = res.min(calc_exp(i).add(dis_sp_st));\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n     \n    public static final int[] vs = {1, 0, -1, 0};\n \n    public static final double EPS = 1e-10;\n     \n    public static boolean bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected){\n        boolean updated = false;\n         \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n        boolean[][] visited = new boolean[H][W];\n         \n        expected_queue.add(expected[sy][sx]);\n        visited[sy][sx] = true;\n        x_queue.add(sx);\n        y_queue.add(sy);\n         \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n             \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                 \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }else if(visited[ny][nx]){\n                    continue;\n                }else if(is_floor[ny][nx] && expected[ny][nx] >= expected[y][x] + 1){\n                    if(expected[ny][nx] - EPS >= expected[y][x] + 1){\n                        updated = true;\n                    }\n                     \n                    expected[ny][nx] = expected[y][x] + 1;\n                    visited[ny][nx] = true;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }else if(!is_floor[ny][nx]){\n                    visited[ny][nx] = true;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n         \n        return updated;\n    }\n     \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n             \n            final double INF = H * W;\n             \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n             \n            LinkedList<Integer> spling_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spling_ys = new LinkedList<Integer>();\n             \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spling_ys.add(i);\n                        spling_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                     \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n             \n            double[][] expected = new double[H][W];\n            for(int i = 0; i < H; i++){\n                for(int j = 0; j < W; j++){\n                    expected[i][j] = INF;\n                }\n            }\n            expected[gy][gx] = 0;\n             \n            double prev_expected = expected[sy][sx];\n            //while(expected[sy][sx] >= (INF - 1e-9) || Math.abs(expected[sy][sx] - prev_expected) > 1e-9){\n            while(true){\n            //for(int t = 0; t < 20; t++){\n                prev_expected = expected[sy][sx];\n                 \n                boolean updated = false;\n                 \n                updated |= bfs(H, W, gx, gy, is_wall, is_floor, expected);\n                for(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n                    final int x = x_itr.next();\n                    final int y = y_itr.next();\n                     \n                    updated |= bfs(H, W, x, y, is_wall, is_floor, expected);\n                }\n                 \n                 \n                if(!updated){\n                    break;\n                }\n                 \n                 \n                double sum = 0;\n                int count = 0;\n                for(int i = 0; i < H; i++){\n                    for(int j = 0; j < W; j++){\n                        if(!is_floor[i][j]){\n                            continue;\n                        }else if(i == gy && j == gx){\n                            continue;\n                        }\n                         \n                        sum += expected[i][j];\n                        count++;\n                    }\n                }\n                 \n                final double average = sum / count;\n                 \n                for(Iterator<Integer> x_itr = spling_xs.iterator(), y_itr = spling_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n                    final int x = x_itr.next();\n                    final int y = y_itr.next();\n                     \n                    expected[y][x] = average;\n                }\n                /*\n                for(int i = 0; i < H; i++){\n                    for(int j = 0; j < W; j++){\n                        System.out.printf(\"%2.0f \", expected[i][j]);\n                    }\n                    System.out.println();\n                }\n                */\n                //System.out.printf(\"%.10f <- %.10f\\n\", expected[sy][sx], prev_expected);\n            }\n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected, boolean is_spring){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n           \n        expected_queue.add(expected[sy][sx]);\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }\n                \n                ///System.out.println(nx + \" \" + ny + \" \" + expected[y][x] + \" \" + expected[ny][nx]);\n             \n                if(is_floor[ny][nx] && expected[ny][nx] > expected[y][x] + 1){\n                \texpected[ny][nx] = expected[y][x] + 1;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Long.MAX_VALUE;\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            int counter = 0;\n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \tcounter++;\n            \n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected, false);\n            \t/*for(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected, true);\n            \t}\n            \t/*\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tSystem.out.printf(\"%3.0f \", expected[i][j] >= INF ? Double.NaN : expected[i][j]);\n            \t\t}\n            \t\tSystem.out.println();\n            \t}*/\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            \t\n            \tif(counter % 10 == 0){\n            \t\tSystem.gc();\n            \t}\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint[] dx = { 1, -1, 0, 0 };\n\tint[] dy = { 0, 0, 1, -1 };\n\tchar[][] table;\n\n\tint h, w;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tw = sc.nextInt();// max:500\n\t\th = sc.nextInt();// max:500\n\t\tint sx = -1, sy = -1, gx = -1, gy = -1;\n\t\tdouble n = 0;\n\t\ttable = new char[h][w];\n\t\tint[][] distance_from_goal = new int[h][w];\n\t\tint[][] distance_from_spring = new int[h][w];\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\tArrays.fill(distance_from_goal[i], (1 << 30));\n\t\t\tArrays.fill(distance_from_spring[i], (1 << 30));\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == 's') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t} else if (table[i][j] == 'g') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tdistance_from_goal[gy][gx] = 0;\n\t\t\t\t} else if (table[i][j] == '.')\n\t\t\t\t\tn++;\n\t\t\t\telse if (table[i][j] == '*')\n\t\t\t\t\tdistance_from_spring[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<Pair> que = new ArrayDeque<>();\n\t\tque.add(new Pair(gx, gy));\n\t\twhile (!que.isEmpty()) {\n\t\t\tPair p = que.poll();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\tif (on_filed(nx, ny) && distance_from_goal[ny][nx] > distance_from_goal[p.y][p.x] + 1) {\n\t\t\t\t\tdistance_from_goal[ny][nx] = distance_from_goal[p.y][p.x] + 1;\n\t\t\t\t\tif (table[ny][nx] == '.')\n\t\t\t\t\t\tque.add(new Pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '*') {\n\t\t\t\t\tque.add(new Pair(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!que.isEmpty()) {\n\t\t\tPair p = que.poll();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.x + dx[i];\n\t\t\t\tint ny = p.y + dy[i];\n\t\t\t\tif (on_filed(nx, ny) && distance_from_spring[ny][nx] > distance_from_spring[p.y][p.x] + 1) {\n\t\t\t\t\tdistance_from_spring[ny][nx] = distance_from_spring[p.y][p.x] + 1;\n\t\t\t\t\tif (table[ny][nx] == '.')\n\t\t\t\t\t\tque.add(new Pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong a = 0, b = 0;\n\t\tArrayList<P> list = new ArrayList<>();\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (table[i][j] == '.') {\n\t\t\t\t\tif (distance_from_goal[i][j] >= (1 << 30)) {\n\t\t\t\t\t\ta += distance_from_spring[i][j];\n\t\t\t\t\t\tb++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta += distance_from_goal[i][j];\n\n\t\t\t\t\t\tif (distance_from_spring[i][j] >= (1 << 30)\n\t\t\t\t\t\t\t\t|| distance_from_goal[i][j] <= distance_from_spring[i][j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tlist.add(new P(distance_from_goal[i][j], distance_from_spring[i][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.sort(null);\n\n\t\tdouble e = a / (n - b);\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\ta -= list.get(i).d_goal;\n\t\t\ta += list.get(i).d_spring;\n\t\t\tb++;\n\t\t\tif (i < list.size() - 1 && list.get(i).diff == list.get(i + 1).diff)\n\t\t\t\tcontinue;\n\t\t\tSystem.out.println(a / (n - b));\n\t\t\te = Math.min(e, a / (n - b));\n\t\t}\n\n\t\tSystem.out.println(Math.min(distance_from_goal[sy][sx], e + distance_from_spring[sy][sx]));\n\t}\n\n\tboolean on_filed(int x, int y) {\n\t\tif (0 <= x && x < w && 0 <= y && y < h && table[y][x] != '#')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tclass Pair {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Pair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint d_goal;\n\t\tint d_spring;\n\t\tint diff;\n\n\t\tpublic P(int d_goal, int d_spring) {\n\t\t\tthis.d_goal = d_goal;\n\t\t\tthis.d_spring = d_spring;\n\t\t\tdiff = d_goal - d_spring;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\treturn -Integer.compare(this.diff, o.diff);\n\t\t}\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/* package whatever; // don't place package name! */\n   \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n   \n/* Name of the class has to be \"Main\" only if the class is public. */\nclass Main\n{\n       \n    public static final int[] vs = {1, 0, -1, 0};\n   \n    public static final double EPS = 1e-10;\n       \n    public static void bfs(final int H, final int W, final int sx, final int sy, boolean[][] is_wall, boolean[][] is_floor, double[][] expected){           \n        LinkedList<Double> expected_queue = new LinkedList<Double>();\n        LinkedList<Integer> x_queue = new LinkedList<Integer>();\n        LinkedList<Integer> y_queue = new LinkedList<Integer>();\n        boolean[][] visited = new boolean[H][W];\n           \n        expected_queue.add(expected[sy][sx]);\n        visited[sy][sx] = true;\n        x_queue.add(sx);\n        y_queue.add(sy);\n           \n        while(!x_queue.isEmpty()){\n            final int x = x_queue.poll();\n            final int y = y_queue.poll();\n               \n            for(int v = 0; v < vs.length; v++){\n                final int nx = x + vs[v];\n                final int ny = y + vs[(v + 1) % vs.length];\n                   \n                if(nx < 0 || nx >= W || ny < 0 || ny >= H){\n                    continue;   \n                }else if(is_wall[ny][nx]){\n                    continue;\n                }else if(visited[ny][nx]){\n                    continue;\n                }else if(is_floor[ny][nx] && expected[ny][nx] >= expected[y][x] + 1){\n                    expected[ny][nx] = expected[y][x] + 1;\n                    visited[ny][nx] = true;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }else if(!is_floor[ny][nx]){\n                    visited[ny][nx] = true;\n                    y_queue.add(ny);\n                    x_queue.add(nx);\n                }\n            }\n        }\n    }\n       \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        {\n            final int W = sc.nextInt();\n            final int H = sc.nextInt();\n               \n            int sx = -1, sy = -1, gx = -1, gy = -1;\n            boolean[][] is_floor = new boolean[H][W];\n            boolean[][] is_wall = new boolean[H][W];\n               \n            LinkedList<Integer> spring_xs = new LinkedList<Integer>();\n            LinkedList<Integer> spring_ys = new LinkedList<Integer>();\n               \n            for(int i = 0; i < H; i++){\n                final char[] line = sc.next().toCharArray();\n                for(int j = 0; j < W; j++){\n                    if(line[j] != '#' && line[j] != '*'){\n                        is_floor[i][j] = true;\n                    }else if(line[j] == '*'){\n                        spring_ys.add(i);\n                        spring_xs.add(j);\n                    }else if(line[j] == '#'){\n                        is_wall[i][j] = true;\n                    }\n                       \n                    if(line[j] == 's'){\n                        sy = i;\n                        sx = j;\n                    }else if(line[j] == 'g'){\n                        gy = i;\n                        gx = j;\n                    }\n                }\n            }\n            \n            final double INF = Double.MAX_VALUE / (H * W);\n            \n            double upper = INF;\n            double lower = 0;\n            \n            double[][] expected = new double[H][W];\n            \n            while(upper - lower > EPS){\n            \tfinal double middle = (upper + lower) / 2;\n            \t\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\texpected[i][j] = INF;\n            \t\t}\n            \t}\n            \texpected[gy][gx] = 0;\n            \t\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\texpected[y][x] = middle;\n            \t}\n            \t\n            \tbfs(H, W, gx, gy, is_wall, is_floor, expected);\n            \tfor(Iterator<Integer> x_itr = spring_xs.iterator(), y_itr = spring_ys.iterator(); x_itr.hasNext() && y_itr.hasNext(); ){\n            \t\tfinal int x = x_itr.next();\n            \t\tfinal int y = y_itr.next();\n            \t\t\n            \t\tbfs(H, W, x, y, is_wall, is_floor, expected);\n            \t}\n            \t\n            \tdouble expected_sum = 0;\n            \tint count = 0;\n            \tfor(int i = 0; i < H; i++){\n            \t\tfor(int j = 0; j < W; j++){\n            \t\t\tif(!is_floor[i][j]){\n            \t\t\t\tcontinue;\n            \t\t\t}else if(i == gy && j == gx){\n            \t\t\t\tcontinue;\n            \t\t\t}\n            \t\t\t\n            \t\t\tcount++;\n            \t\t\texpected_sum += expected[i][j];\n            \t\t}\n            \t}\n            \t\n            \tfinal double expected_value = expected_sum / count;\n            \t\n            \tif(expected_value < middle){\n            \t\tupper = middle;\n            \t}else if(expected_value > middle){\n            \t\tlower = middle;\n            \t}else{\n            \t\tupper = middle;\n            \t\tlower = middle;\n            \t}\n            \t\n            \t//System.out.println(upper + \" \" + middle + \" \" + lower + \" \" + expected_value + \" \"  + count);\n            }\n            \n            System.out.printf(\"%.10f\\n\", expected[sy][sx]);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing C = System.Int32;\nusing V = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var m = ri;\n            var n = ri;\n            var s = Enumerate(n, x => rs.ToCharArray());\n            var q = new Queue<int>();\n            var qq = new Queue<int>();\n            var dist = Enumerate(n * m, x => 1L << 61);\n            var eist = Enumerate(n * m, x => 1L << 61);\n            var g = -1;\n            var cnt = 0;\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                {\n                    if (s[i][j] == 's') { g = i * m + j; s[i][j] = '.'; }\n                    if (s[i][j] == 'g') { dist[i * m + j] = 0; q.Enqueue(i * m + j); }\n                    if (s[i][j] == '*') { eist[i * m + j] = 0; qq.Enqueue(i * m + j); }\n                    if (s[i][j] == '.') cnt++;\n                }\n            bfs(s, q, m, dist);\n            bfs(s, qq, m, eist);\n            decimal l = 0.0M; decimal r = 1e15M;\n            for (int _ = 0; _ < 100; _++)\n            {\n                var mid = (l + r) / 2;\n                var sum = 0.0M;\n                for (int i = 0; i < n; i++)\n                    for (int j = 0; j < m; j++)\n                        if (s[i][j] == '.') sum += Math.Min(dist[i * m + j], eist[i * m + j] + mid);\n                sum /= cnt;\n                if (sum > mid) l = mid;\n                else r = mid;\n            }\n            //Debug.WriteLine($\"{l} {r}\");\n            Console.WriteLine(\"{0:0.000000000000}\", Math.Min(dist[g], eist[g] + l));\n\n        }\n        void bfs(char[][] s, Queue<int> q, int m, long[] dist)\n        {\n            while (q.Any())\n            {\n                var p = q.Dequeue();\n                var i = p / m;\n                var j = p % m;\n                for (int k = 0; k < 4; k++)\n                {\n                    var ni = i + dx[k];\n                    var nj = j + dy[k];\n                    if (s[ni][nj] != '.') continue;\n                    if (dist[ni * m + nj] > dist[p] + 1)\n                    {\n                        dist[ni * m + nj] = dist[p] + 1;\n                        q.Enqueue(ni * m + nj);\n                    }\n                }\n            }\n        }\n        const long INF = 1L << 60;\n        int[] dx = { -1, 0, 1, 0 };\n        int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read())\n                if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\ntiles.each{|v|\n\tv.property[:dist] ||= w * h\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\ntiles.select!{|v| v.property[:dist] || v.property[:to_spring]}\ntiles1, tiles2 = tiles.partition{|v| v.property[:to_spring]}\nfix = tiles2.map{|v| v.property[:dist]}.inject(0, :+)\n\nprev_exp = 0\n1000.times {\n\texp = (fix + tiles1.map{|v| v.property[:dist]}.inject(0, :+)) / tiles.size.to_f\n\tbreak if (exp - prev_exp).abs < 1e-12\n\ttiles1.each{|v|\n\t\tnext if !v.property[:to_spring]\n\t\td = v.property[:dist]\n\t\te = exp + v.property[:to_spring]\n\t\tv.property[:dist] = e if e < d\n\t}\n}\n\nprintf(\"%.11f\\n\" ,start.property[:dist])"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\ntiles.each{|v|\n\tv.property[:dist] ||= w * h\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\ntiles.select!{|v| v.property[:dist] || v.property[:to_spring]}\ntiles1, tiles2 = tiles.partition{|v| v.property[:to_spring]}\nfix = tiles2.map{|v| v.property[:dist]}.inject(:+)\n\n300.times {\n\texp = (fix + tiles1.map{|v| v.property[:dist]}.inject(:+)) / tiles.size.to_f\n\ttiles1.each{|v|\n\t\tnext if !v.property[:to_spring]\n\t\td = v.property[:dist]\n\t\te = exp + v.property[:to_spring]\n\t\tv.property[:dist] = e if e < d\n\t}\n}\n\nprintf(\"%.11f\\n\" ,start.property[:dist])"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nextend Graphical\n\nw, h = gets.split.map &:to_i\n$a = (1..h).map{ gets.chomp.split(\"\") }\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] !~ /[#*]/\n\t}\nend\n\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = [i,j] if $a[i][j] == ?s\n\t\tgoal = [i,j] if $a[i][j] == ?g\n\t\ttiles << [i,j] if $a[i][j] !~ /[#*g]/\n\t}\n}\n\ndist = bfs([goal])\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if $a[i][j] == ?#\n\t\tsprings << [i,j] if $a[i][j] == ?*\n\t}\n}\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] != ?#\n\t}\nend\n\nto_spring = bfs(springs)\n\nif !to_spring[start]\n\tputs dist[start]\n\texit\nend\n\ntiles.select!{|v| dist[v] || to_spring[v]}\ntiles1, tiles2 = tiles.partition{|v| dist[v]}\n\ns2 = tiles2.map{|v| to_spring[v]}.inject(0, :+)\n\ne_min = 0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\te_center = (e_min + e_max) / 2.0\n\n\ttiles1, tiles3 = tiles1.partition{|v|\n\t\t!to_spring[v] || dist[v] < to_spring[v] + e_max\n\t}\n\ts2 += tiles3.map{|v| to_spring[v]}.inject(0, :+)\n\ttiles2 += tiles3\n\n\ts1 = 0\n\ttiles1.each{|v|\n\t\tif !to_spring[v]\n\t\t\ts1 += dist[v]\n\t\telse \n\t\t\tx = dist[v]\n\t\t\ty = to_spring[v] + e_center\n\t\t\ts1 += (x < y ? x : y)\n\t\tend\n\t}\n\texp = (s1 + s2 + tiles2.size * e_center) / tiles.size.to_f\n\n\tbreak if (e_center - exp).abs / exp < 1e-12\n\tif e_center < exp\n\t\te_min = exp\n\telse\n\t\te_max = exp\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tdist[start] || Float::INFINITY,\n\t\t(to_spring[start] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\ntiles.each{|v|\n\tv.property[:dist] ||= w * h\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\ntiles.select!{|v| v.property[:dist] || v.property[:to_spring]}\ntiles1, tiles2 = tiles.partition{|v| v.property[:to_spring]}\nfix = tiles2.map{|v| v.property[:dist]}.inject(0, :+)\n\n300.times {\n\texp = (fix + tiles1.map{|v| v.property[:dist]}.inject(:+)) / tiles.size.to_f\n\ttiles1.each{|v|\n\t\tnext if !v.property[:to_spring]\n\t\td = v.property[:dist]\n\t\te = exp + v.property[:to_spring]\n\t\tv.property[:dist] = e if e < d\n\t}\n}\n\nprintf(\"%.11f\\n\" ,start.property[:dist])"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nextend Graphical\n\nw, h = gets.split.map &:to_i\n$a = (1..h).map{ gets.chomp.split(\"\") }\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] !~ /[#*]/\n\t}\nend\n\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = [i,j] if $a[i][j] == ?s\n\t\tgoal = [i,j] if $a[i][j] == ?g\n\t\ttiles << [i,j] if $a[i][j] !~ /[#*g]/\n\t}\n}\n\ndist = {}\ndijkstra([goal]).each{|v, d|\n\tdist[v] = d\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if $a[i][j] == ?#\n\t\tsprings << [i,j] if $a[i][j] == ?*\n\t}\n}\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] != ?#\n\t}\nend\n\nto_spring = {}\ndijkstra(springs).each{|v, d|\n\tto_spring[v] = d\n}\n\nif !to_spring[start]\n\tputs dist[start]\n\texit\nend\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\t#p [itr, (e_max - e_min).abs]\n\te_center = (e_min + e_max) / 2.0\n\texp = tiles.map{|v|\n\t\t[ \n\t\t\tdist[v] || Float::INFINITY,\n\t\t\t(to_spring[v] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+) / tiles.size.to_f\n\tbreak if (e_center - exp).abs < 1e-10\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tdist[start] || Float::INFINITY,\n\t\t(to_spring[start] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\ntiles.each{|v|\n\tv.property[:dist] ||= w * h\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\ntiles.select!{|v| v.property[:dist] || v.property[:to_spring]}\n\n100.times {\n\texp = tiles.map{|v| v.property[:dist]}.inject(:+) / tiles.size.to_f\n\ttiles.each{|v|\n\t\tnext if !v.property[:to_spring]\n\t\td = v.property[:dist]\n\t\te = exp + v.property[:to_spring]\n\t\tv.property[:dist] = e if e < d\n\t}\n}\n\nprintf(\"%.11f\\n\" ,start.property[:dist])"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nextend Graphical\n\nw, h = gets.split.map &:to_i\n$a = (1..h).map{ gets.chomp.split(\"\") }\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] !~ /[#*]/\n\t}\nend\n\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = [i,j] if $a[i][j] == ?s\n\t\tgoal = [i,j] if $a[i][j] == ?g\n\t\ttiles << [i,j] if $a[i][j] !~ /[#*g]/\n\t}\n}\n\ndist = bfs([goal])\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if $a[i][j] == ?#\n\t\tsprings << [i,j] if $a[i][j] == ?*\n\t}\n}\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] != ?#\n\t}\nend\n\nto_spring = bfs(springs)\n\nif !to_spring[start]\n\tputs dist[start]\n\texit\nend\n\ntiles.select!{|v| dist[v] || to_spring[v]}\ntiles1, tiles2 = tiles.partition{|v| dist[v]}\n\ns2 = tiles2.map{|v| to_spring[v]}.inject(0, :+)\n\ne_min = 0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\te_center = (e_min + e_max) / 2.0\n\n\ttiles1, tiles3 = tiles1.partition{|v|\n\t\t!to_spring[v] || dist[v] < to_spring[v] + e_max\n\t}\n\ts2 += tiles3.map{|v| to_spring[v]}.inject(0, :+)\n\ttiles2 += tiles3\n\n\ts1 = 0\n\ttiles1.each{|v|\n\t\tif !to_spring[v]\n\t\t\ts1 += dist[v]\n\t\telse \n\t\t\tx = dist[v]\n\t\t\ty = to_spring[v] + e_center\n\t\t\ts1 += (x < y ? x : y)\n\t\tend\n\t}\n\texp = (s1 + s2 + tiles2.size * e_center) / tiles.size.to_f\n\n\tbreak if (e_center - exp).abs / exp < 1e-15\n\tif e_center < exp\n\t\te_min = exp\n\telse\n\t\te_max = exp\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tdist[start] || Float::INFINITY,\n\t\t(to_spring[start] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\nif !start.property[:to_spring]\n\tputs start.property[:dist]\n\texit\nend\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\te_center = (e_min + e_max) / 2.0\n\texp = tiles.map{|v|\n\t\t[ \n\t\t\tv.property[:dist] || Float::INFINITY,\n\t\t\t(v.property[:to_spring] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+) / tiles.size.to_f\n\tbreak if (e_center - exp).abs < 1e-10\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tstart.property[:dist] || Float::INFINITY,\n\t\t(start.property[:to_spring] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nextend Graphical\n\nw, h = gets.split.map &:to_i\n$a = (1..h).map{ gets.chomp.split(\"\") }\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] !~ /[#*]/\n\t}\nend\n\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = [i,j] if $a[i][j] == ?s\n\t\tgoal = [i,j] if $a[i][j] == ?g\n\t\ttiles << [i,j] if $a[i][j] !~ /[#*g]/\n\t}\n}\n\ndist = {}\ndijkstra([goal]).each{|v, d|\n\tdist[v] = d\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if $a[i][j] == ?#\n\t\tsprings << [i,j] if $a[i][j] == ?*\n\t}\n}\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] != ?#\n\t}\nend\n\nto_spring = {}\ndijkstra(springs).each{|v, d|\n\tto_spring[v] = d\n}\n\nif !to_spring[start]\n\tputs dist[start]\n\texit\nend\n\ntiles1, tiles2 = tiles.partition{|v| dist[v]}\n\ns2 = tiles2.map{|v| to_spring[v]}.inject(0, :+)\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\te_center = (e_min + e_max) / 2.0\n\ts1 = tiles1.map{|v|\n\t\t[ \n\t\t\tdist[v] || Float::INFINITY,\n\t\t\t(to_spring[v] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+)\n\texp = (s1 + s2 + tiles2.size * e_center) / tiles.size.to_f\n\tbreak if (e_center - exp).abs < 1e-15\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tdist[start] || Float::INFINITY,\n\t\t(to_spring[start] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\ntiles.each{|v|\n\tv.property[:dist] ||= w * h\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\ntiles.select!{|v| v.property[:dist] || v.property[:to_spring]}\ntiles1, tiles2 = tiles.partition{|v| v.property[:to_spring]}\nfix = tiles2.map{|v| v.property[:dist]}.inject(0, :+)\n\n300.times {\n\texp = (fix + tiles1.map{|v| v.property[:dist]}.inject(0, :+)) / tiles.size.to_f\n\ttiles1.each{|v|\n\t\tnext if !v.property[:to_spring]\n\t\td = v.property[:dist]\n\t\te = exp + v.property[:to_spring]\n\t\tv.property[:dist] = e if e < d\n\t}\n}\n\nprintf(\"%.11f\\n\" ,start.property[:dist])"
  },
  {
    "language": "Ruby",
    "code": "class Heap\nrequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nextend Graphical\n\nw, h = gets.split.map &:to_i\n$a = (1..h).map{ gets.chomp.split(\"\") }\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] !~ /[#*]/\n\t}\nend\n\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = [i,j] if $a[i][j] == ?s\n\t\tgoal = [i,j] if $a[i][j] == ?g\n\t\ttiles << [i,j] if $a[i][j] !~ /[#*g]/\n\t}\n}\n\ndist = {}\ndijkstra([goal]).each{|v, d|\n\tdist[v] = d\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if $a[i][j] == ?#\n\t\tsprings << [i,j] if $a[i][j] == ?*\n\t}\n}\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] != ?#\n\t}\nend\n\nto_spring = {}\ndijkstra(springs).each{|v, d|\n\tto_spring[v] = d\n}\n\nif !to_spring[start]\n\tputs dist[start]\n\texit\nend\n\ntiles.select!{|v| dist[v] || to_spring[v]}\ntiles1, tiles2 = tiles.partition{|v| dist[v]}\n\ns2 = tiles2.map{|v| to_spring[v]}.inject(0, :+)\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\t#p [itr, (e_max - e_min).abs]\n\te_center = (e_min + e_max) / 2.0\n\ts1 = tiles1.map{|v|\n\t\t[ \n\t\t\tdist[v] || Float::INFINITY,\n\t\t\t(to_spring[v] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+)\n\texp = (s1 + s2 + tiles2.size * e_center) / tiles.size.to_f\n\tbreak if (e_center - exp).abs < 1e-15\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tdist[start] || Float::INFINITY,\n\t\t(to_spring[start] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j| g.add_node(:name => [i,j]) } }\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[i][j] if a[i][j] == ?s\n\t\tgoal = nodes[i][j] if a[i][j] == ?g\n\t\ttiles << nodes[i][j] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[i][j] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i+1][j])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[i][j], nodes[i][j+1])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\nif !start.property[:to_spring]\n\tputs start.property[:dist]\n\texit\nend\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\t#p itr\n\te_center = (e_min + e_max)/2\n\texp = tiles.map{|v|\n\t\t[ \n\t\t\tv.property[:dist] || Float::INFINITY,\n\t\t\t(v.property[:to_spring] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+) / tiles.size.to_f\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n\tbreak if e_max - e_min < 1e-10\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tstart.property[:dist] || Float::INFINITY,\n\t\t(start.property[:to_spring] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nextend Graphical\n\nw, h = gets.split.map &:to_i\n$a = (1..h).map{ gets.chomp.split(\"\") }\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] !~ /[#*]/\n\t}\nend\n\nstart = goal = nil\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = [i,j] if $a[i][j] == ?s\n\t\tgoal = [i,j] if $a[i][j] == ?g\n\t\ttiles << [i,j] if $a[i][j] !~ /[#*g]/\n\t}\n}\n\ndist = bfs([goal])\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if $a[i][j] == ?#\n\t\tsprings << [i,j] if $a[i][j] == ?*\n\t}\n}\n\ndef each_out_connection_of(u)\n\ti, j = u\n\t[[-1,0],[1,0],[0,-1],[0,1]].each{|dy, dx|\n\t\ty, x = i+dy, j+dx\n\t\tyield [[y, x], 1] if (0..$a.size-1) === y && (0..$a[0].size-1) === x && $a[y][x] != ?#\n\t}\nend\n\nto_spring = bfs(springs)\n\nif !to_spring[start]\n\tputs dist[start]\n\texit\nend\n\ntiles.select!{|v| dist[v] || to_spring[v]}\ntiles1, tiles2 = tiles.partition{|v| dist[v]}\n\ns2 = tiles2.map{|v| to_spring[v]}.inject(0, :+)\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\t#p [itr, (e_max - e_min).abs]\n\te_center = (e_min + e_max) / 2.0\n\ts1 = tiles1.map{|v|\n\t\t[ \n\t\t\tdist[v] || Float::INFINITY,\n\t\t\t(to_spring[v] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+)\n\texp = (s1 + s2 + tiles2.size * e_center) / tiles.size.to_f\n\tbreak if (e_center - exp).abs < 1e-15\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tdist[start] || Float::INFINITY,\n\t\t(to_spring[start] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\t\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nw, h = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ng = Graph.new\nnodes = {}\nstart = goal = nil\n\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnodes[[i,j]] = g.add_node if a[i][j] != ?#\n\t}\n}\n\ntiles = []\n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tstart = nodes[[i,j]] if a[i][j] == ?s\n\t\tgoal = nodes[[i, j]] if a[i][j] == ?g\n\t\ttiles << nodes[[i,j]] if a[i][j] !~ /[#*g]/\n\t\tnext if a[i][j] =~ /[#*]/\n\t\tif a[i+1][j] !~ /[#*]/\n\t\t\tg.add_edge(nodes[[i,j]], nodes[[i+1,j]])\n\t\tend\n\t\tif a[i][j+1] !~ /[#*]/\n\t\t\tg.add_edge(nodes[[i,j]], nodes[[i,j+1]])\n\t\tend\n\t}\n}\n\ng.dijkstra([goal]).each{|v, d|\n\tv.property[:dist] = d\n}\n\nsprings = Set.new \n(1..h-2).each{|i|\n\t(1..w-2).each{|j|\n\t\tnext if a[i][j] == ?#\n\t\tsprings << nodes[[i,j]] if a[i][j] == ?*\n\t\tif a[i+1][j] != ?# && (a[i][j] == ?* || a[i+1][j] == ?*)\n\t\t\tg.add_edge(nodes[[i,j]], nodes[[i+1,j]])\n\t\tend\n\t\tif a[i][j+1] != ?# && (a[i][j] == ?* || a[i][j+1] == ?*)\n\t\t\tg.add_edge(nodes[[i,j]], nodes[[i,j+1]])\n\t\tend\n\t}\n}\n\ng.dijkstra(springs).each{|v, d|\n\tv.property[:to_spring] = d\n}\n\nif !start.property[:to_spring]\n\tputs start.property[:dist]\n\texit\nend\n\ne_min = 0.0\ne_max = 1e20\n\nloop.with_index {|_, itr|\n\t#p [itr, (e_max - e_min).abs]\n\te_center = (e_min + e_max) / 2.0\n\texp = tiles.map{|v|\n\t\t[ \n\t\t\tv.property[:dist] || Float::INFINITY,\n\t\t\t(v.property[:to_spring] || Float::INFINITY) + e_center\n\t\t].min\n\t}.inject(0, :+) / tiles.size.to_f\n\tbreak if (e_center - exp).abs < 1e-10\n\tif e_center < exp\n\t\te_min = e_center\n\telse\n\t\te_max = e_center\n\tend\n}\n\nprintf(\"%.11f\\n\", \n\t[\n\t\tstart.property[:dist] || Float::INFINITY,\n\t\t(start.property[:to_spring] || Float::INFINITY) + e_min\n\t].min)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nw, h = map(int, input().split())\nmp = [input() for _ in range(h)]\n\nsprings = []\ntile_cnt = 0\nfor y in range(h):\n  for x in range(w):\n    if mp[y][x] == \"*\":\n      springs.append((x, y))\n    if mp[y][x] == \"g\":\n      gx, gy = x, y\n    if mp[y][x] == \"s\":\n      sx, sy = x, y\n      tile_cnt += 1\n    if mp[y][x] == \".\":\n      tile_cnt += 1\n\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\nINF = 10 ** 10\n\ng_dist = [[INF] * w for _ in range(h)]\nque = deque()\nque.append((0, gx, gy))\ng_dist[gy][gx] = 0\nwhile que:\n  score, x, y = que.popleft()\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] in (\".\", \"s\"):\n      if g_dist[ny][nx] == INF:\n        g_dist[ny][nx] = score + 1\n        que.append((score + 1, nx, ny))\n\ns_dist = [[INF] * w for _ in range(h)]\nque = deque()\nfor x, y in springs:\n  s_dist[y][x] = 0\n  que.append((0, x, y))\nwhile que:\n  score, x, y = que.popleft()\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] in (\".\", \"s\"):\n      if s_dist[ny][nx] == INF:\n        s_dist[ny][nx] = score + 1\n        que.append((score + 1, nx, ny))\n\nsorted_tiles = sorted([(g_dist[y][x] - s_dist[y][x] if g_dist[y][x] != INF else INF, x, y) for y in range(h) for x in range(w) if mp[y][x] in (\".\", \"s\")])\n\nacc_g = 0\nacc_s = 0\nacc_t = 0\nacc_g_dic = {}\nacc_s_dic = {}\nacc_t_dic = {}\nkeys = set()\nfor key, x, y in sorted_tiles:\n  acc_g += g_dist[y][x]\n  acc_s += s_dist[y][x]\n  acc_t += 1\n  acc_g_dic[key] = acc_g\n  acc_s_dic[key] = acc_s\n  acc_t_dic[key] = acc_t\n  keys.add(key)\nkeys = sorted(list(keys))\n\nlength = len(keys)\nfor i in range(length - 1):\n  key = keys[i]\n  next_key = keys[i + 1]\n  E = (acc_g_dic[key] + acc_s - acc_s_dic[key]) / acc_t_dic[key]\n  if key <= E < next_key:\n    print(min(g_dist[sy][sx], s_dist[sy][sx] + E))\n    break\nelse:\n  print(g_dist[sy][sx])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nw, h = map(int, input().split())\nmp = [input() for _ in range(h)]\n\nsprings = []\ntile_cnt = 0\nfor y in range(h):\n  for x in range(w):\n    if mp[y][x] == \"*\":\n      springs.append((x, y))\n    if mp[y][x] == \"g\":\n      gx, gy = x, y\n    if mp[y][x] == \"s\":\n      sx, sy = x, y\n      tile_cnt += 1\n    if mp[y][x] == \".\":\n      tile_cnt += 1\n\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\nINF = 10 ** 10\n\ng_dist = [[INF] * w for _ in range(h)]\nque = deque()\nque.append((0, gx, gy))\ng_dist[gy][gx] = 0\nwhile que:\n  score, x, y = que.popleft()\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] in (\".\", \"s\"):\n      if g_dist[ny][nx] == INF:\n        g_dist[ny][nx] = score + 1\n        que.append((score + 1, nx, ny))\n\ns_dist = [[INF] * w for _ in range(h)]\nque = deque()\nfor x, y in springs:\n  s_dist[y][x] = 0\n  que.append((0, x, y))\nwhile que:\n  score, x, y = que.popleft()\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] in (\".\", \"s\"):\n      if s_dist[ny][nx] == INF:\n        s_dist[ny][nx] = score + 1\n        que.append((score + 1, nx, ny))\n\nsorted_tiles = sorted([(g_dist[y][x] - s_dist[y][x] if g_dist[y][x] != INF else INF, x, y) for y in range(h) for x in range(w) if mp[y][x] in (\".\", \"s\")])\n\nacc_g = 0\nacc_s = 0\nacc_t = 0\nacc_g_dic = {}\nacc_s_dic = {}\nacc_t_dic = {}\nkeys = set()\nfor key, x, y in sorted_tiles:\n  acc_g += g_dist[y][x]\n  acc_s += s_dist[y][x]\n  acc_t += 1\n  acc_g_dic[key] = acc_g\n  acc_s_dic[key] = acc_s\n  acc_t_dic[key] = acc_t\n  keys.add(key)\nkeys = sorted(list(keys))\n\nlength = len(keys)\nfor i in range(length - 1):\n  key = keys[i]\n  next_key = keys[i + 1]\n  E = (acc_g_dic[key] + acc_s - acc_s_dic[key]) / acc_t_dic[key]\n  if key <= E < next_key:\n    break\n\nprint(min(g_dist[sy][sx], s_dist[sy][sx] + E))\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nw, h = map(int, input().split())\nmp = [input() for _ in range(h)]\n\nsprings = []\ntile_cnt = 0\nfor y in range(h):\n  for x in range(w):\n    if mp[y][x] == \"*\":\n      springs.append((x, y))\n    if mp[y][x] == \"g\":\n      gx, gy = x, y\n    if mp[y][x] == \"s\":\n      sx, sy = x, y\n      tile_cnt += 1\n    if mp[y][x] == \".\":\n      tile_cnt += 1\n\nvec = ((1, 0), (0, -1), (-1, 0), (0, 1))\nINF = 10 ** 10\n\ng_dist = [[INF] * w for _ in range(h)]\nque = deque()\nque.append((0, gx, gy))\ng_dist[gy][gx] = 0\nwhile que:\n  score, x, y = que.popleft()\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] in (\".\", \"s\"):\n      if g_dist[ny][nx] == INF:\n        g_dist[ny][nx] = score + 1\n        que.append((score + 1, nx, ny))\n\ns_dist = [[INF] * w for _ in range(h)]\nque = deque()\nfor x, y in springs:\n  s_dist[y][x] = 0\n  que.append((0, x, y))\nwhile que:\n  score, x, y = que.popleft()\n  for dx, dy in vec:\n    nx, ny = x + dx, y + dy\n    if mp[ny][nx] in (\".\", \"s\"):\n      if s_dist[ny][nx] == INF:\n        s_dist[ny][nx] = score + 1\n        que.append((score + 1, nx, ny))\n\nsorted_tiles = sorted([(g_dist[y][x] - s_dist[y][x], x, y) for y in range(h) for x in range(w) if mp[y][x] in (\".\", \"s\")])\n\nacc_g = 0\nacc_s = 0\nacc_t = 0\nacc_g_dic = {}\nacc_s_dic = {}\nacc_t_dic = {}\nkeys = set()\nfor key, x, y in sorted_tiles:\n  acc_g += g_dist[y][x]\n  acc_s += s_dist[y][x]\n  acc_t += 1\n  acc_g_dic[key] = acc_g\n  acc_s_dic[key] = acc_s\n  acc_t_dic[key] = acc_t\n  keys.add(key)\nkeys = sorted(list(keys))\n\nlength = len(keys)\nfor i in range(length - 1):\n  key = keys[i]\n  next_key = keys[i + 1]\n  E = (acc_g_dic[key] + acc_s - acc_s_dic[key]) / acc_t_dic[key]\n  if key <= E < next_key:\n    break\n\nprint(min(g_dist[sy][sx], s_dist[y][x] + E))\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef bs(f, mi, ma):\n    st = time.time()\n    mm = -1\n    mi = fractions.Fraction(mi, 1)\n    ma = fractions.Fraction(ma, 1)\n    while ma > mi + eps:\n        gt = time.time()\n        mm = (ma+mi) / 2\n        if gt - st > 35:\n            return mm\n        if isinstance(mm, float):\n            tk = max(1, int(10**15 / mm))\n            mm = fractions.Fraction(int(mm*tk), tk)\n        if float(mm) == float(ma) or float(mm) == float(mi):\n            return mm\n        if f(mm):\n            mi = mm\n        else:\n            ma = mm\n    if f(mm):\n        return mm + eps\n    return mm\n\ndef main():\n    rr = []\n\n    def f(w,h):\n        a = [S() for _ in range(h)]\n        si = sj = -1\n        for i in range(1,h-1):\n            for j in range(1,w-1):\n                if a[i][j] == 's':\n                    si = i\n                    sj = j\n                    break\n\n        def search(sc):\n            d = collections.defaultdict(lambda: inf)\n            q = []\n            for i in range(1,h-1):\n                for j in range(1,w-1):\n                    if a[i][j] == sc:\n                        d[(i,j)] = 0\n                        heapq.heappush(q, (0, (i,j)))\n\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for di,dj in dd:\n                    ni = u[0] + di\n                    nj = u[1] + dj\n                    if not a[ni][nj] in '.s':\n                        continue\n                    uv = (ni,nj)\n                    if v[uv]:\n                        continue\n                    vd = k + 1\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        gd = search('g')\n        wd = search('*')\n\n        cgs = []\n        cws = []\n        for i in range(1,h-1):\n            for j in range(1,w-1):\n                if not a[i][j] in '.s':\n                    continue\n                if gd[(i,j)] >= inf:\n                    cgs.append((i,j))\n                else:\n                    cws.append((i,j))\n        cc = len(cgs) + len(cws)\n        cgc = len(cgs)\n        cgw = sum([wd[(i,j)] for i,j in cgs])\n\n        sgw = [(inf,0,0)]\n        for i,j in cws:\n            gt = gd[(i,j)]\n            wt = wd[(i,j)]\n            sgw.append((gt-wt, wt, gt))\n        sgw.sort()\n        # print(sgw[:5], sgw[-5:])\n        ls = len(sgw) - 1\n        # print('ls', ls, len(cws))\n\n        def ff(t):\n            # print('ff', t)\n            s = cgw\n            si = bisect.bisect_left(sgw,(t,0,0))\n            # print('si', si, sgw[si], sgw[si-1])\n            tc = cgc\n            s2 = cgw\n            tc2 = tc + ls - si\n            for i in range(si):\n                s2 += sgw[i][2]\n            for i in range(si,ls):\n                s2 += sgw[i][1]\n\n            # for i,j in cws:\n            #     gt = gd[(i,j)]\n            #     wt = wd[(i,j)]\n            #     if t + wt < gt:\n            #         s += wt\n            #         tc += 1\n            #     else:\n            #         s += gt\n\n            # print('s,s2,tc,tc2', s,s2,tc,tc2)\n\n            av = (s2 + t*tc2) / cc\n            # print('av,t', float(av), float(t))\n            return t < av\n\n        k = bs(ff, 0, 10**10)\n        gt = gd[(si,sj)]\n        wt = wd[(si,sj)]\n        r = gt\n        if wt + k < gt:\n            r = wt + k\n        # print('r', r)\n\n        return '{:0.10f}'.format(float(r))\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    W, H = map(int, readline().split())\n    S = [readline().strip() for i in range(H)]\n    R = [[0]*W for i in range(H)]\n    P = []\n    cnt = 0\n    for i in range(H):\n        Si = S[i]\n        for j in range(W):\n            if Si[j] == 's':\n                sx = j; sy = i\n                R[i][j] = 1\n                cnt += 1\n            elif Si[j] == 'g':\n                gx = j; gy = i\n            elif Si[j] == '*':\n                P.append((j, i))\n            elif Si[j] == '.':\n                cnt += 1\n                R[i][j] = 1\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    INF = 10**18\n\n    dist1 = [[INF]*W for i in range(H)]\n    que = deque(P)\n    for x, y in P:\n        dist1[y][x] = 0\n    while que:\n        x, y = que.popleft()\n        c = dist1[y][x]+1\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if S[ny][nx] in '*#' or dist1[ny][nx] != INF:\n                continue\n            dist1[ny][nx] = c\n            que.append((nx, ny))\n\n    dist2 = [[INF]*W for i in range(H)]\n    que = deque([(gx, gy)])\n    dist2[gy][gx] = 0\n    while que:\n        x, y = que.popleft()\n        c = dist2[y][x]+1\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if S[ny][nx] in '*#' or dist2[ny][nx] != INF:\n                continue\n            dist2[ny][nx] = c\n            que.append((nx, ny))\n\n    left = 0; right = 10**21\n    BASE = 10**9\n    for i in range(71):\n        mid = (left + right) // 2\n        su = 0\n        for i in range(H):\n            for j in range(W):\n                if not R[i][j]:\n                    continue\n                su += min(dist1[i][j]*BASE + mid, dist2[i][j]*BASE)\n        if mid*cnt > su:\n            right = mid\n        else:\n            left = mid\n    write(\"%.16f\\n\" % min(dist1[sy][sx] + left / BASE, dist2[sy][sx]))\nsolve()\n"
  }
]