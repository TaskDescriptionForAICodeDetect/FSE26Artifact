[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_H 50\n#define MAX_W 50\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint H, W;\nchar grid[MAX_H][MAX_W];\nint visited[MAX_H][MAX_W];\nPoint leaves[MAX_H * MAX_W];\nint leaf_count;\nPoint start, target;\n\nvoid reset_visited() {\n    memset(visited, 0, sizeof(visited));\n}\n\nvoid dfs(int x, int y) {\n    if (x < 0 || x >= H || y < 0 || y >= W || visited[x][y] || grid[x][y] == '0') \n        return;\n\n    visited[x][y] = 1;\n\n    // Horizontal\n    for (int j = 0; j < W; j++) {\n        if (j != y && grid[x][j] != '0') \n            dfs(x, j);\n    }\n\n    // Vertical\n    for (int i = 0; i < H; i++) {\n        if (i != x && grid[i][y] != '0') \n            dfs(i, y);\n    }\n}\n\nint can_remove_leaves() {\n    reset_visited();\n    dfs(start.x, start.y);\n    return visited[target.x][target.y] == 0;\n}\n\nint solve() {\n    int min_leaves_removed = INT_MAX;\n\n    for (int mask = 0; mask < (1 << leaf_count); mask++) {\n        // Create a copy of the grid\n        char temp_grid[MAX_H][MAX_W];\n        memcpy(temp_grid, grid, sizeof(grid));\n\n        int leaves_removed = 0;\n        for (int i = 0; i < leaf_count; i++) {\n            if (mask & (1 << i)) {\n                Point leaf = leaves[i];\n                if (leaf.x == start.x && leaf.y == start.y) continue;\n                if (leaf.x == target.x && leaf.y == target.y) continue;\n                \n                grid[leaf.x][leaf.y] = '0';\n                leaves_removed++;\n            }\n        }\n\n        if (can_remove_leaves()) {\n            min_leaves_removed = (leaves_removed < min_leaves_removed) ? leaves_removed : min_leaves_removed;\n        }\n\n        // Restore the grid\n        memcpy(grid, temp_grid, sizeof(grid));\n    }\n\n    return min_leaves_removed == INT_MAX ? -1 : min_leaves_removed;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    leaf_count = 0;\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '1') {\n                leaves[leaf_count].x = i;\n                leaves[leaf_count].y = j;\n                leaf_count++;\n            }\n            else if (grid[i][j] == 'S') {\n                start.x = i;\n                start.y = j;\n                grid[i][j] = '1';\n            }\n            else if (grid[i][j] == 'T') {\n                target.x = i;\n                target.y = j;\n                grid[i][j] = '1';\n            }\n        }\n    }\n\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_HW 200\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint H, W;\nchar grid[MAX_HW][MAX_HW + 1];\nPoint S, T;\nint visited[MAX_HW][MAX_HW];\nint min_removed = INT_MAX;\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] != '.';\n}\n\nvoid dfs(int x, int y, int removed) {\n    if (x == T.x && y == T.y) {\n        if (removed < min_removed) {\n            min_removed = removed;\n        }\n        return;\n    }\n    if (visited[x][y] <= removed) {\n        return;\n    }\n    visited[x][y] = removed;\n\n    for (int i = x - 1; i >= 0; --i) {\n        if (grid[i][y] == '.') continue;\n        if (grid[i][y] == 'T') {\n            dfs(i, y, removed);\n            break;\n        }\n        dfs(i, y, removed + 1);\n        break;\n    }\n    for (int i = x + 1; i < H; ++i) {\n        if (grid[i][y] == '.') continue;\n        if (grid[i][y] == 'T') {\n            dfs(i, y, removed);\n            break;\n        }\n        dfs(i, y, removed + 1);\n        break;\n    }\n    for (int j = y - 1; j >= 0; --j) {\n        if (grid[x][j] == '.') continue;\n        if (grid[x][j] == 'T') {\n            dfs(x, j, removed);\n            break;\n        }\n        dfs(x, j, removed + 1);\n        break;\n    }\n    for (int j = y + 1; j < W; ++j) {\n        if (grid[x][j] == '.') continue;\n        if (grid[x][j] == 'T') {\n            dfs(x, j, removed);\n            break;\n        }\n        dfs(x, j, removed + 1);\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                S.x = i;\n                S.y = j;\n            } else if (grid[i][j] == 'T') {\n                T.x = i;\n                T.y = j;\n            }\n            visited[i][j] = INT_MAX;\n        }\n    }\n\n    dfs(S.x, S.y, 0);\n\n    if (min_removed != INT_MAX) {\n        printf(\"%d\\n\", min_removed);\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int to, rev, cap;\n};\n\nclass Dinic {\npublic:\n    vector<vector<Edge>> g;\n    vector<int> level, iter;\n    Dinic(int n) : g(n), level(n), iter(n) {}\n    \n    void add_edge(int from, int to, int cap) {\n        g[from].push_back({to, (int)g[to].size(), cap});\n        g[to].push_back({from, (int)g[from].size() - 1, 0});\n    }\n    \n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for (Edge &e : g[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    \n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < g[v].size(); ++i) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n    \n    int S = -1, T = -1;\n    vector<pair<int, int>> leaves;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                S = leaves.size();\n                leaves.emplace_back(i, j);\n            } else if (grid[i][j] == 'T') {\n                T = leaves.size();\n                leaves.emplace_back(i, j);\n            } else if (grid[i][j] == 'o') {\n                leaves.emplace_back(i, j);\n            }\n        }\n    }\n    \n    if (S == -1 || T == -1) {\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    int N = leaves.size();\n    Dinic dinic(2 * N + 2);\n    int source = 2 * N, sink = 2 * N + 1;\n    \n    for (int i = 0; i < N; ++i) {\n        dinic.add_edge(2 * i, 2 * i + 1, 1);\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i == j) continue;\n            auto [ri, ci] = leaves[i];\n            auto [rj, cj] = leaves[j];\n            if (ri == rj || ci == cj) {\n                dinic.add_edge(2 * i + 1, 2 * j, 1);\n            }\n        }\n    }\n    \n    dinic.add_edge(source, 2 * S + 1, INT_MAX);\n    dinic.add_edge(2 * T, sink, INT_MAX);\n    \n    int flow = dinic.max_flow(source, sink);\n    cout << (flow <= N ? flow : -1) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:21:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FrogPond {\n    static class Edge {\n        int to, rev;\n        long cap;\n        Edge(int to, int rev, long cap) {\n            this.to = to;\n            this.rev = rev;\n            this.cap = cap;\n        }\n    }\n\n    static class Dinic {\n        int n;\n        List<Edge>[] g;\n        int[] level, iter;\n        Dinic(int n) {\n            this.n = n;\n            g = new List[n];\n            for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\n            level = new int[n];\n            iter = new int[n];\n        }\n        void addEdge(int from, int to, long cap) {\n            g[from].add(new Edge(to, g[to].size(), cap));\n            g[to].add(new Edge(from, g[from].size() - 1, 0));\n        }\n        void bfs(int s) {\n            Arrays.fill(level, -1);\n            Queue<Integer> q = new LinkedList<>();\n            level[s] = 0;\n            q.add(s);\n            while (!q.isEmpty()) {\n                int v = q.poll();\n                for (Edge e : g[v]) {\n                    if (e.cap > 0 && level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        q.add(e.to);\n                    }\n                }\n            }\n        }\n        long dfs(int v, int t, long f) {\n            if (v == t) return f;\n            for (; iter[v] < g[v].size(); iter[v]++) {\n                Edge e = g[v].get(iter[v]);\n                if (e.cap > 0 && level[v] < level[e.to]) {\n                    long d = dfs(e.to, t, Math.min(f, e.cap));\n                    if (d > 0) {\n                        e.cap -= d;\n                        g[e.to].get(e.rev).cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        long maxFlow(int s, int t) {\n            long flow = 0;\n            while (true) {\n                bfs(s);\n                if (level[t] < 0) return flow;\n                Arrays.fill(iter, 0);\n                long f;\n                while ((f = dfs(s, t, Long.MAX_VALUE)) > 0) {\n                    flow += f;\n                }\n            }\n        }\n    }\n\n    public static int solve(int H, int W, List<String> grid) {\n        int s = -1, t = -1;\n        List<int[]> leaves = new ArrayList<>();\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c = grid.get(i).charAt(j);\n                if (c == 'S') s = leaves.size();\n                if (c == 'T') t = leaves.size();\n                if (c == 'S' || c == 'T' || c == 'o') {\n                    leaves.add(new int[]{i, j});\n                }\n            }\n        }\n        if (s == -1 || t == -1) return -1;\n        if (s == t) return -1;\n\n        int n = leaves.size();\n        Dinic dinic = new Dinic(2 * n + 2);\n        int source = 2 * n, sink = 2 * n + 1;\n\n        for (int i = 0; i < n; i++) {\n            dinic.addEdge(2 * i, 2 * i + 1, 1);\n        }\n\n        dinic.addEdge(source, 2 * s, Integer.MAX_VALUE);\n        dinic.addEdge(2 * t + 1, sink, Integer.MAX_VALUE);\n\n        for (int i = 0; i < n; i++) {\n            int[] li = leaves.get(i);\n            for (int j = i + 1; j < n; j++) {\n                int[] lj = leaves.get(j);\n                if (li[0] == lj[0] || li[1] == lj[1]) {\n                    dinic.addEdge(2 * i + 1, 2 * j, Integer.MAX_VALUE);\n                    dinic.addEdge(2 * j + 1, 2 * i, Integer.MAX_VALUE);\n                }\n            }\n        }\n\n        long flow = dinic.maxFlow(source, sink);\n        return flow >= Integer.MAX_VALUE ? -1 : (int) flow;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine();\n        List<String> grid = new ArrayList<>();\n        for (int i = 0; i < H; i++) {\n            grid.add(scanner.nextLine());\n        }\n        System.out.println(solve(H, W, grid));\n    }\n}",
    "timestamp": "2025-08-05 23:22:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int removeLeaves(char[][] pond, int H, int W) {\n        int startRow = -1, startCol = -1, targetRow = -1, targetCol = -1;\n        List<int[]> leaves = new ArrayList<>();\n\n        // Find start, target and collect other leaves\n        for (int r = 0; r < H; r++) {\n            for (int c = 0; c < W; c++) {\n                if (pond[r][c] == 'S') {\n                    startRow = r;\n                    startCol = c;\n                } else if (pond[r][c] == 'T') {\n                    targetRow = r;\n                    targetCol = c;\n                } else if (pond[r][c] == '1') {\n                    leaves.add(new int[]{r, c});\n                }\n            }\n        }\n\n        // If no path between start and target, return -1\n        if (!canReach(pond, H, W, startRow, startCol, targetRow, targetCol)) {\n            return -1;\n        }\n\n        // Try removing leaves\n        int minRemoved = H * W;\n        for (int mask = 0; mask < (1 << leaves.size()); mask++) {\n            char[][] tempPond = new char[H][W];\n            for (int r = 0; r < H; r++) {\n                tempPond[r] = pond[r].clone();\n            }\n\n            int removed = 0;\n            for (int i = 0; i < leaves.size(); i++) {\n                if ((mask & (1 << i)) != 0) {\n                    int[] leaf = leaves.get(i);\n                    tempPond[leaf[0]][leaf[1]] = '0';\n                    removed++;\n                }\n            }\n\n            // Check if target is reachable after removing\n            if (!canReach(tempPond, H, W, startRow, startCol, targetRow, targetCol)) {\n                minRemoved = Math.min(minRemoved, removed);\n            }\n        }\n\n        return minRemoved == H * W ? -1 : minRemoved;\n    }\n\n    private boolean canReach(char[][] pond, int H, int W, int startRow, int startCol, int targetRow, int targetCol) {\n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{startRow, startCol});\n        visited[startRow][startCol] = true;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1];\n\n            if (r == targetRow && c == targetCol) return true;\n\n            // Check row\n            for (int nc = 0; nc < W; nc++) {\n                if (pond[r][nc] != '0' && !visited[r][nc]) {\n                    queue.offer(new int[]{r, nc});\n                    visited[r][nc] = true;\n                }\n            }\n\n            // Check column\n            for (int nr = 0; nr < H; nr++) {\n                if (pond[nr][c] != '0' && !visited[nr][c]) {\n                    queue.offer(new int[]{nr, c});\n                    visited[nr][c] = true;\n                }\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 23:23:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    int minRemovedLeaves(std::vector<std::vector<char>>& grid) {\n        int H = grid.size();\n        int W = grid[0].size();\n        \n        std::pair<int, int> start, target;\n        std::vector<std::pair<int, int>> leaves;\n        \n        // Find start, target, and all leaves\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 'S') start = {i, j};\n                else if (grid[i][j] == 'T') target = {i, j};\n                else if (grid[i][j] == 'L') leaves.push_back({i, j});\n            }\n        }\n        \n        int minRemoved = INT_MAX;\n        \n        // Try removing different combinations of leaves\n        for (int mask = 0; mask < (1 << leaves.size()); mask++) {\n            std::vector<std::vector<char>> tempGrid = grid;\n            int removedCount = 0;\n            \n            // Remove leaves based on the current mask\n            for (int i = 0; i < leaves.size(); i++) {\n                if (mask & (1 << i)) {\n                    tempGrid[leaves[i].first][leaves[i].second] = '.';\n                    removedCount++;\n                }\n            }\n            \n            // Check if frog can reach target\n            if (!canReachTarget(tempGrid, start, target)) {\n                minRemoved = std::min(minRemoved, removedCount);\n            }\n        }\n        \n        return minRemoved == INT_MAX ? -1 : minRemoved;\n    }\n    \nprivate:\n    bool canReachTarget(std::vector<std::vector<char>>& grid, \n                        std::pair<int, int>& start, \n                        std::pair<int, int>& target) {\n        int H = grid.size();\n        int W = grid[0].size();\n        \n        std::vector<std::vector<bool>> visited(H, std::vector<bool>(W, false));\n        std::queue<std::pair<int, int>> q;\n        \n        q.push(start);\n        visited[start.first][start.second] = true;\n        \n        while (!q.empty()) {\n            auto [r, c] = q.front();\n            q.pop();\n            \n            if (r == target.first && c == target.second) return true;\n            \n            // Check row\n            for (int j = 0; j < W; j++) {\n                if (j != c && grid[r][j] != '.' && !visited[r][j]) {\n                    q.push({r, j});\n                    visited[r][j] = true;\n                }\n            }\n            \n            // Check column\n            for (int i = 0; i < H; i++) {\n                if (i != r && grid[i][c] != '.' && !visited[i][c]) {\n                    q.push({i, c});\n                    visited[i][c] = true;\n                }\n            }\n        }\n        \n        return false;\n    }\n};",
    "timestamp": "2025-08-05 23:23:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_removals_to_block(S, T, leaves, H, W):\n    rows = [set() for _ in range(H)]\n    cols = [set() for _ in range(W)]\n    positions = {}\n    \n    for r, c in leaves:\n        rows[r].add(c)\n        cols[c].add(r)\n        positions[(r, c)] = True\n        \n    start_r, start_c = S\n    target_r, target_c = T\n    \n    if start_r == target_r or start_c == target_c:\n        return -1\n    \n    intercept_candidates = []\n    \n    for row in rows[start_r]:\n        if row != start_c and row in rows[target_r]:\n            intercept_candidates.append((start_r, row, target_r))\n\n    for col in cols[start_c]:\n        if col != start_r and col in cols[target_c]:\n            intercept_candidates.append((start_c, col, target_c))\n    \n    intercept_set = set()\n    min_intercepts = float('inf')\n    \n    for sr, sc, tr in intercept_candidates:\n        intercept_set.add((sr, sc))\n        intercept_set.add((tr, sc))\n        \n    for sr, sc, tc in intercept_candidates:\n        intercept_set.add((sr, sc))\n        intercept_set.add((sr, tc))\n    \n    if len(intercept_set) < min_intercepts:\n        min_intercepts = len(intercept_set)\n        \n    return min_intercepts if min_intercepts < float('inf') else -1\n\ndef solve(H, W, grid):\n    S, T, leaves = None, None, []\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                S = (i, j)\n            elif grid[i][j] == 'T':\n                T = (i, j)\n            if grid[i][j] != '.':\n                leaves.append((i, j))\n                \n    return min_removals_to_block(S, T, leaves, H, W)\n\n# Example usage:\n# H, W = 3, 4\n# grid = [\n#     ['.', '.', '.', '.'],\n#     ['.', 'S', '.', 'T'],\n#     ['.', '.', '.', '.']\n# ]\n# print(solve(H, W, grid))  # Output: -1",
    "timestamp": "2025-08-13 14:50:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class FrogOnLeaf {\n\n    private static final int INF = Integer.MAX_VALUE;\n\n    public static int minLeavesToRemove(char[][] grid, int H, int W) {\n        int sx = -1, sy = -1, tx = -1, ty = -1;\n        List<int[]> leaves = new ArrayList<>();\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 'S') {\n                    sx = i;\n                    sy = j;\n                } else if (grid[i][j] == 'T') {\n                    tx = i;\n                    ty = j;\n                } else if (grid[i][j] == 'L') {\n                    leaves.add(new int[]{i, j});\n                }\n            }\n        }\n\n        boolean[][] reached = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{sx, sy});\n        reached[sx][sy] = true;\n\n        while (!queue.isEmpty()) {\n            int[] pos = queue.poll();\n            int x = pos[0], y = pos[1];\n\n            // explore the row\n            for (int j = 0; j < W; j++) {\n                if (!reached[x][j] && (grid[x][j] == 'L' || grid[x][j] == 'T')) {\n                    reached[x][j] = true;\n                    queue.offer(new int[]{x, j});\n                }\n            }\n\n            // explore the column\n            for (int i = 0; i < H; i++) {\n                if (!reached[i][y] && (grid[i][y] == 'L' || grid[i][y] == 'T')) {\n                    reached[i][y] = true;\n                    queue.offer(new int[]{i, y});\n                }\n            }\n        }\n\n        if (!reached[tx][ty]) {\n            return 0;\n        }\n\n        int minRemovals = INF;\n        for (int[] leaf : leaves) {\n            grid[leaf[0]][leaf[1]] = '.';\n            for (int i = 0; i < H; i++) {\n                Arrays.fill(reached[i], false);\n            }\n            queue.clear();\n            queue.offer(new int[]{sx, sy});\n            reached[sx][sy] = true;\n\n            while (!queue.isEmpty()) {\n                int[] pos = queue.poll();\n                int x = pos[0], y = pos[1];\n\n                // explore the row\n                for (int j = 0; j < W; j++) {\n                    if (!reached[x][j] && (grid[x][j] == 'L' || grid[x][j] == 'T')) {\n                        reached[x][j] = true;\n                        queue.offer(new int[]{x, j});\n                    }\n                }\n\n                // explore the column\n                for (int i = 0; i < H; i++) {\n                    if (!reached[i][y] && (grid[i][y] == 'L' || grid[i][y] == 'T')) {\n                        reached[i][y] = true;\n                        queue.offer(new int[]{i, y});\n                    }\n                }\n            }\n\n            if (!reached[tx][ty]) {\n                minRemovals = Math.min(minRemovals, 1);\n            }\n            grid[leaf[0]][leaf[1]] = 'L';\n        }\n\n        return minRemovals == INF ? -1 : minRemovals;\n    }\n\n    public static void main(String[] args) {\n        char[][] grid = {\n                {'S', 'L', 'L'},\n                {'L', '.', 'L'},\n                {'L', 'L', 'T'}\n        };\n        int H = grid.length;\n        int W = grid[0].length;\n        System.out.println(minLeavesToRemove(grid, H, W)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 14:50:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 50\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint H, W;\nchar grid[MAX][MAX];\nint visited[MAX][MAX];\nPoint start, target;\n\nint check(int x, int y) {\n    return (x >= 0 && x < H && y >= 0 && y < W && grid[x][y] == 'L');\n}\n\nint dfs(int x, int y) {\n    if (x == target.x && y == target.y) return 1;\n    if (!check(x, y) || visited[x][y]) return 0;\n    \n    visited[x][y] = 1;\n    \n    for (int i = 0; i < H; i++) if (i != x && dfs(i, y)) return 1;\n    for (int j = 0; j < W; j++) if (j != y && dfs(x, j)) return 1;\n    \n    return 0;\n}\n\nint minLeavesToRemove() {\n    memset(visited, 0, sizeof(visited));\n    if (!dfs(start.x, start.y)) return -1;\n    \n    int rowMask[MAX][MAX] = {0}, colMask[MAX][MAX] = {0}, leaves = 0;\n    \n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'L' && !(i == start.x && j == start.y) && !(i == target.x && j == target.y)) {\n                grid[i][j] = '.';\n                memset(visited, 0, sizeof(visited));\n                if (!dfs(start.x, start.y))\n                    leaves++;\n                else {\n                    grid[i][j] = 'L';\n                    for (int k = 0; k < H; k++) if (rowMask[k][j] || (grid[k][j] == 'L' && dfs(k, j))) { rowMask[i][j] = 1; break; }\n                    for (int k = 0; k < W; k++) if (colMask[i][k] || (grid[i][k] == 'L' && dfs(i, k))) { colMask[i][j] = 1; break; }\n                    grid[i][j] = '.';\n                    dfs(start.x, start.y);\n                    grid[i][j] = 'L';\n                }\n            }\n        }\n    \n    memset(rowMask, 0, sizeof(rowMask));\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'L' && !rowMask[i][j] && !colMask[i][j]) {\n                memset(visited, 0, sizeof(visited));\n                if (!dfs(start.x, start.y))\n                    leaves++;\n                else grid[i][j] = '.';\n            }\n        }\n    }\n    return leaves;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++)\n        scanf(\"%s\", grid[i]);\n    \n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'S') start = (Point){i, j};\n            if (grid[i][j] == 'T') target = (Point){i, j};\n        }\n    \n    printf(\"%d\\n\", minLeavesToRemove());\n    return 0;\n}",
    "timestamp": "2025-08-13 14:50:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nstruct Position {\n    int row;\n    int col;\n};\n\nbool bfsCheck(const vector<vector<char>>& pond, int H, int W, Position start, Position target) {\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<Position> q;\n    q.push(start);\n    visited[start.row][start.col] = true;\n    while (!q.empty()) {\n        auto pos = q.front(); q.pop();\n        if (pos.row == target.row && pos.col == target.col) return true;\n\n        for (int i = 0; i < H; i++) {\n            if (pond[i][pos.col] == 'L' && !visited[i][pos.col]) {\n                visited[i][pos.col] = true;\n                q.push({i, pos.col});\n            }\n        }\n        for (int j = 0; j < W; j++) {\n            if (pond[pos.row][j] == 'L' && !visited[pos.row][j]) {\n                visited[pos.row][j] = true;\n                q.push({pos.row, j});\n            }\n        }\n    }\n    return false;\n}\n\nint minLeavesToRemove(vector<vector<char>>& pond, int H, int W, Position start, Position target) {\n    if (!bfsCheck(pond, H, W, start, target)) return -1;\n\n    set<Position> toRemove;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (pond[i][j] == 'L' && !(i == start.row && j == start.col) && !(i == target.row && j == target.col)) {\n                // Try removing this leaf\n                pond[i][j] = '.';\n                if (!bfsCheck(pond, H, W, start, target)) {\n                    toRemove.insert({i, j});\n                }\n                pond[i][j] = 'L'; // restore\n            }\n        }\n    }\n\n    return toRemove.size() > 0 ? toRemove.size() : -1;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> pond(H, vector<char>(W));\n    Position start, target;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> pond[i][j];\n            if (pond[i][j] == 'S') start = {i, j};\n            if (pond[i][j] == 'T') target = {i, j};\n        }\n    }\n\n    cout << minLeavesToRemove(pond, H, W, start, target) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:51:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List\nfrom collections import deque\n\ndef min_leaves_to_remove(grid: List[List[str]], H: int, W: int) -> int:\n    def find_coords(marker):\n        for r in range(H):\n            for c in range(W):\n                if grid[r][c] == marker:\n                    return r, c\n        return -1, -1\n\n    def can_reach(start_r, start_c, end_r, end_c, forbidden_leaves):\n        visited = [[False] * W for _ in range(H)]\n        queue = deque([(start_r, start_c)])\n        visited[start_r][start_c] = True\n\n        while queue:\n            r, c = queue.popleft()\n            if r == end_r and c == end_c:\n                return True\n\n            # Check row\n            for nc in range(W):\n                if nc != c and grid[r][nc] != '#' and (r, nc) not in forbidden_leaves and not visited[r][nc]:\n                    queue.append((r, nc))\n                    visited[r][nc] = True\n\n            # Check column\n            for nr in range(H):\n                if nr != r and grid[nr][c] != '#' and (nr, c) not in forbidden_leaves and not visited[nr][c]:\n                    queue.append((nr, c))\n                    visited[nr][c] = True\n\n        return False\n\n    start_r, start_c = find_coords('S')\n    end_r, end_c = find_coords('T')\n\n    leaves = []\n    for r in range(H):\n        for c in range(W):\n            if grid[r][c] == 'O' and (r, c) != (start_r, start_c) and (r, c) != (end_r, end_c):\n                leaves.append((r, c))\n\n    if not leaves:\n        return -1\n\n    for remove_count in range(len(leaves)):\n        for combination in itertools.combinations(leaves, remove_count):\n            forbidden_leaves = set(combination)\n            if not can_reach(start_r, start_c, end_r, end_c, forbidden_leaves):\n                return remove_count\n\n    return -1",
    "timestamp": "2025-08-13 14:51:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = []\n    S = None\n    T = None\n    for i in range(H):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        for j in range(W):\n            if row[j] == 'S':\n                S = (i, j)\n            elif row[j] == 'T':\n                T = (i, j)\n    \n    if S[0] == T[0] or S[1] == T[1]:\n        print(-1)\n        return\n    \n    # Construct bipartite graph: rows on left, columns on right\n    # Each leaf (i,j) connects row i to column j\n    # We need to find a minimum vertex cut between S's row/column and T's row/column\n    \n    # Nodes:\n    # 0 to H-1: rows\n    # H to H+W-1: columns\n    # Source: H+W, Sink: H+W+1\n    \n    N = H + W + 2\n    source = H + W\n    sink = H + W + 1\n    \n    # We'll use Dinic's algorithm for max flow\n    class Edge:\n        def __init__(self, to, rev, capacity):\n            self.to = to\n            self.rev = rev\n            self.capacity = capacity\n    \n    graph = [[] for _ in range(N)]\n    \n    def add_edge(fr, to, capacity):\n        forward = Edge(to, len(graph[to]), capacity)\n        backward = Edge(fr, len(graph[fr]), 0)\n        graph[fr].append(forward)\n        graph[to].append(backward)\n    \n    # Connect source to S's row and column\n    s_row, s_col = S\n    add_edge(source, s_row, float('inf'))\n    add_edge(source, H + s_col, float('inf'))\n    \n    # Connect T's row and column to sink\n    t_row, t_col = T\n    add_edge(t_row, sink, float('inf'))\n    add_edge(H + t_col, sink, float('inf'))\n    \n    # Connect each leaf (i,j) as row i -> column j\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'o':\n                add_edge(i, H + j, 1)\n                add_edge(H + j, i, 1)  # bidirectional?\n    \n    # Dinic's algorithm\n    level = [0] * N\n    \n    def bfs():\n        q = deque()\n        q.append(source)\n        level[source] = 1\n        while q:\n            v = q.popleft()\n            for edge in graph[v]:\n                if edge.capacity > 0 and level[edge.to] == 0:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n        return level[sink] != 0\n    \n    ptr = [0] * N\n    \n    def dfs(v, flow):\n        if v == sink:\n            return flow\n        while ptr[v] < len(graph[v]):\n            edge = graph[v][ptr[v]]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                pushed = dfs(edge.to, min(flow, edge.capacity))\n                if pushed > 0:\n                    edge.capacity -= pushed\n                    graph[edge.to][edge.rev].capacity += pushed\n                    return pushed\n            ptr[v] += 1\n        return 0\n    \n    max_flow = 0\n    while bfs():\n        ptr = [0] * N\n        while True:\n            pushed = dfs(source, float('inf'))\n            if pushed == 0:\n                break\n            max_flow += pushed\n    print(max_flow if max_flow < float('inf') else -1)\n\nsolve()",
    "timestamp": "2025-08-13 14:51:31"
  }
]