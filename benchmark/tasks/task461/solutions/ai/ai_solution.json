[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define MAX_TIME 1000\n\nint graph[MAX_STATIONS][MAX_STATIONS];\nint restaurant_time[MAX_STATIONS];\nint visited[MAX_STATIONS];\nint max_restaurants;\n\nvoid dfs(int current, int start, int time_left, int restaurants_visited) {\n    max_restaurants = (restaurants_visited > max_restaurants) ? restaurants_visited : max_restaurants;\n\n    for (int next = 0; next < MAX_STATIONS; next++) {\n        if (graph[current][next] > 0 && !visited[next]) {\n            int total_time = graph[current][next];\n            \n            if (restaurant_time[next] > 0) {\n                total_time += restaurant_time[next];\n            }\n\n            if (time_left >= total_time) {\n                visited[next] = 1;\n                dfs(next, start, time_left - total_time, \n                    restaurants_visited + (restaurant_time[next] > 0));\n                visited[next] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        int stations, connections, time_limit;\n        scanf(\"%d %d %d\", &stations, &connections, &time_limit);\n\n        memset(graph, 0, sizeof(graph));\n        memset(restaurant_time, 0, sizeof(restaurant_time));\n        memset(visited, 0, sizeof(visited));\n        max_restaurants = 0;\n\n        for (int i = 0; i < connections; i++) {\n            int u, v, time;\n            scanf(\"%d %d %d\", &u, &v, &time);\n            graph[u][v] = time;\n            graph[v][u] = time;\n        }\n\n        int restaurant_count;\n        scanf(\"%d\", &restaurant_count);\n\n        for (int i = 0; i < restaurant_count; i++) {\n            int station, eat_time;\n            scanf(\"%d %d\", &station, &eat_time);\n            restaurant_time[station] = eat_time;\n        }\n\n        int start_station;\n        scanf(\"%d\", &start_station);\n\n        visited[start_station] = 1;\n        dfs(start_station, start_station, time_limit, 0);\n\n        printf(\"%d\\n\", max_restaurants);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_STATIONS 15\n#define MAX_TIME 301\n\nint N, M, L;\nint start, time_limit;\nint eating_time[MAX_STATIONS];\nint adj_matrix[MAX_STATIONS][MAX_STATIONS];\nint dp[1 << MAX_STATIONS][MAX_STATIONS];\n\nvoid initialize() {\n    for (int i = 0; i < (1 << MAX_STATIONS); i++) {\n        for (int j = 0; j < MAX_STATIONS; j++) {\n            dp[i][j] = MAX_TIME;\n        }\n    }\n}\n\nint solve() {\n    initialize();\n    dp[0][start] = 0;\n\n    int max_restaurants = 0;\n\n    for (int mask = 0; mask < (1 << N); mask++) {\n        for (int u = 0; u < N; u++) {\n            if (dp[mask][u] > MAX_TIME) continue;\n\n            int current_restaurants = __builtin_popcount(mask);\n            if (u == start && current_restaurants > 0) {\n                if (dp[mask][u] <= time_limit && current_restaurants > max_restaurants) {\n                    max_restaurants = current_restaurants;\n                }\n            }\n\n            for (int v = 0; v < N; v++) {\n                if (adj_matrix[u][v] == 0) continue;\n\n                int new_mask = mask;\n                if (v != start && !(mask & (1 << v))) {\n                    new_mask |= (1 << v);\n                }\n\n                int new_time = dp[mask][u] + adj_matrix[u][v];\n                if (new_mask != mask) {\n                    new_time += eating_time[v];\n                }\n\n                if (new_time < dp[new_mask][v]) {\n                    dp[new_mask][v] = new_time;\n                }\n            }\n        }\n    }\n\n    return max_restaurants;\n}\n\nint main() {\n    int dataset_count;\n    scanf(\"%d\", &dataset_count);\n\n    while (dataset_count--) {\n        scanf(\"%d %d %d %d %d\", &N, &M, &L, &start, &time_limit);\n        start--;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                adj_matrix[i][j] = 0;\n            }\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u, v, t;\n            scanf(\"%d %d %d\", &u, &v, &t);\n            u--; v--;\n            adj_matrix[u][v] = t;\n            adj_matrix[v][u] = t;\n        }\n\n        for (int i = 0; i < N; i++) {\n            eating_time[i] = 0;\n        }\n\n        for (int i = 0; i < L; i++) {\n            int s, e;\n            scanf(\"%d %d\", &s, &e);\n            s--;\n            eating_time[s] = e;\n        }\n\n        int result = solve();\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, time;\n};\n\nstruct State {\n    int station, time_left, mask;\n    State(int s, int t, int m) : station(s), time_left(t), mask(m) {}\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (true) {\n        int N, M, L, K, A, H;\n        cin >> N >> M >> L >> K >> A >> H;\n        if (N == 0 && M == 0 && L == 0 && K == 0 && A == 0 && H == 0) break;\n\n        vector<int> is_restaurant(N, 0);\n        for (int i = 0; i < L; ++i) {\n            int city;\n            cin >> city;\n            is_restaurant[city] = 1;\n        }\n\n        vector<vector<Edge>> adj(N);\n        for (int i = 0; i < K; ++i) {\n            int X, Y, T;\n            cin >> X >> Y >> T;\n            adj[X].push_back({Y, T});\n            adj[Y].push_back({X, T});\n        }\n\n        int max_mask = 1 << L;\n        vector<vector<int>> dist(N, vector<int>(max_mask, INT_MAX));\n        queue<State> q;\n\n        dist[A][0] = 0;\n        q.emplace(A, 0, 0);\n\n        int max_restaurants = 0;\n\n        while (!q.empty()) {\n            auto current = q.front();\n            q.pop();\n\n            int u = current.station;\n            int time_used = current.time_left;\n            int mask = current.mask;\n\n            if (dist[u][mask] < time_used) continue;\n\n            if (u == H && time_used <= M) {\n                int cnt = __builtin_popcount(mask);\n                if (cnt > max_restaurants) {\n                    max_restaurants = cnt;\n                }\n            }\n\n            for (const Edge& e : adj[u]) {\n                int v = e.to;\n                int new_time = time_used + e.time;\n\n                if (new_time > M) continue;\n\n                int new_mask = mask;\n                if (is_restaurant[v] && v != A && v != H) {\n                    int bit = 0;\n                    for (int i = 0, temp = 0; i < N; ++i) {\n                        if (is_restaurant[i] && i != A && i != H) {\n                            if (i == v) {\n                                new_mask |= (1 << bit);\n                                break;\n                            }\n                            ++bit;\n                        }\n                    }\n                }\n\n                if (new_time < dist[v][new_mask]) {\n                    dist[v][new_mask] = new_time;\n                    q.emplace(v, new_time, new_mask);\n                }\n            }\n        }\n\n        cout << max_restaurants << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class Edge {\n        int to, time;\n        Edge(int to, int time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int N = sc.nextInt();\n            int M = sc.nextInt();\n            int L = sc.nextInt();\n            int K = sc.nextInt();\n            int A = sc.nextInt();\n            int H = sc.nextInt();\n            \n            if (N == 0 && M == 0 && L == 0 && K == 0 && A == 0 && H == 0) break;\n            \n            boolean[] isSiro = new boolean[N];\n            for (int i = 0; i < L; i++) {\n                int city = sc.nextInt();\n                isSiro[city] = true;\n            }\n            \n            List<List<Edge>> adj = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                adj.add(new ArrayList<>());\n            }\n            \n            for (int i = 0; i < K; i++) {\n                int X = sc.nextInt();\n                int Y = sc.nextInt();\n                int T = sc.nextInt();\n                adj.get(X).add(new Edge(Y, T));\n                adj.get(Y).add(new Edge(X, T));\n            }\n            \n            int[][] dist = new int[N][M + 1];\n            for (int i = 0; i < N; i++) {\n                Arrays.fill(dist[i], Integer.MAX_VALUE);\n            }\n            dist[A][M] = 0;\n            \n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n            pq.offer(new int[]{A, M, 0});\n            \n            while (!pq.isEmpty()) {\n                int[] current = pq.poll();\n                int u = current[0];\n                int fuel = current[1];\n                int time = current[2];\n                \n                if (time > dist[u][fuel]) continue;\n                \n                for (Edge e : adj.get(u)) {\n                    int v = e.to;\n                    int t = e.time;\n                    if (fuel >= t) {\n                        int newFuel = fuel - t;\n                        int newTime = time + t;\n                        if (newTime < dist[v][newFuel]) {\n                            dist[v][newFuel] = newTime;\n                            pq.offer(new int[]{v, newFuel, newTime});\n                        }\n                    }\n                }\n                \n                if (isSiro[u] && fuel < M) {\n                    int newFuel = fuel + 1;\n                    int newTime = time + 1;\n                    if (newTime < dist[u][newFuel]) {\n                        dist[u][newFuel] = newTime;\n                        pq.offer(new int[]{u, newFuel, newTime});\n                    }\n                }\n            }\n            \n            int maxRestaurants = 0;\n            for (int i = 0; i < N; i++) {\n                if (i == A || !isSiro[i]) continue;\n                for (int j = 0; j <= M; j++) {\n                    if (dist[i][j] != Integer.MAX_VALUE) {\n                        int returnTime = dist[i][j] + (isSiro[i] ? 1 : 0) * j;\n                        if (returnTime <= H) {\n                            maxRestaurants++;\n                            break;\n                        }\n                    }\n                }\n            }\n            System.out.println(maxRestaurants);\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 21:47:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SIRORestaurants {\n    static class Station {\n        int id;\n        List<Connection> connections;\n        boolean hasRestaurant;\n        int ramenTime;\n\n        Station(int id) {\n            this.id = id;\n            this.connections = new ArrayList<>();\n            this.hasRestaurant = false;\n            this.ramenTime = 0;\n        }\n    }\n\n    static class Connection {\n        Station destination;\n        int time;\n\n        Connection(Station dest, int travelTime) {\n            this.destination = dest;\n            this.time = travelTime;\n        }\n    }\n\n    public static int maxRestaurants(int start, int timeLimit, List<Station> stations) {\n        boolean[] visited = new boolean[stations.size()];\n        return dfs(start, start, timeLimit, stations, visited, 0, 0);\n    }\n\n    private static int dfs(int start, int current, int remainingTime, \n                            List<Station> stations, boolean[] visited, \n                            int restaurantsVisited, int totalTime) {\n        if (remainingTime < 0) return restaurantsVisited;\n\n        Station currentStation = stations.get(current);\n        int maxRestaurants = restaurantsVisited;\n\n        for (Connection conn : currentStation.connections) {\n            int nextStation = conn.destination.id;\n            Station nextStationObj = stations.get(nextStation);\n\n            if (!visited[nextStation] && nextStation != start) {\n                int travelTime = conn.time;\n                int newRemainingTime = remainingTime - travelTime;\n\n                if (nextStationObj.hasRestaurant && newRemainingTime >= nextStationObj.ramenTime) {\n                    visited[nextStation] = true;\n                    int result = dfs(start, nextStation, \n                                     newRemainingTime - nextStationObj.ramenTime, \n                                     stations, visited, \n                                     restaurantsVisited + 1, \n                                     totalTime + travelTime + nextStationObj.ramenTime);\n                    maxRestaurants = Math.max(maxRestaurants, result);\n                    visited[nextStation] = false;\n                }\n\n                int result = dfs(start, nextStation, newRemainingTime, \n                                 stations, visited, \n                                 restaurantsVisited, \n                                 totalTime + travelTime);\n                maxRestaurants = Math.max(maxRestaurants, result);\n            }\n        }\n\n        return maxRestaurants;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int N = scanner.nextInt(); // number of stations\n            if (N == 0) break;\n\n            int M = scanner.nextInt(); // number of connections\n            int R = scanner.nextInt(); // number of restaurants\n            int T = scanner.nextInt(); // time limit\n\n            List<Station> stations = new ArrayList<>(N);\n            for (int i = 0; i < N; i++) {\n                stations.add(new Station(i));\n            }\n\n            // Read connections\n            for (int i = 0; i < M; i++) {\n                int a = scanner.nextInt() - 1;\n                int b = scanner.nextInt() - 1;\n                int time = scanner.nextInt();\n                stations.get(a).connections.add(new Connection(stations.get(b), time));\n                stations.get(b).connections.add(new Connection(stations.get(a), time));\n            }\n\n            // Read restaurants\n            for (int i = 0; i < R; i++) {\n                int stationIndex = scanner.nextInt() - 1;\n                int ramenTime = scanner.nextInt();\n                stations.get(stationIndex).hasRestaurant = true;\n                stations.get(stationIndex).ramenTime = ramenTime;\n            }\n\n            int startStation = scanner.nextInt() - 1;\n            int result = maxRestaurants(startStation, T, stations);\n            System.out.println(result);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:47:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_STATIONS = 100;\n\nint maxRestaurants(int start, int timeLimit, vector<vector<int>>& graph, vector<int>& restaurantTimes) {\n    int n = graph.size();\n    vector<vector<int>> dp(n, vector<int>(timeLimit + 1, 0));\n    vector<bool> hasRestaurant(n, false);\n    \n    for (int i = 0; i < restaurantTimes.size(); i++) {\n        if (restaurantTimes[i] > 0) {\n            hasRestaurant[i] = true;\n        }\n    }\n    \n    for (int time = 1; time <= timeLimit; time++) {\n        for (int current = 0; current < n; current++) {\n            if (current == start) continue;\n            \n            for (int prev = 0; prev < n; prev++) {\n                if (graph[prev][current] == 0) continue;\n                \n                int remainingTime = time - graph[prev][current];\n                if (remainingTime < 0) continue;\n                \n                int currentCount = dp[prev][remainingTime];\n                \n                if (hasRestaurant[current] && remainingTime >= restaurantTimes[current]) {\n                    currentCount++;\n                }\n                \n                dp[current][time] = max(dp[current][time], currentCount);\n            }\n        }\n    }\n    \n    int maxCount = 0;\n    for (int time = 0; time <= timeLimit; time++) {\n        maxCount = max(maxCount, dp[start][time]);\n    }\n    \n    return maxCount;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    while (datasets--) {\n        int stations, connections, timeLimit;\n        cin >> stations >> connections >> timeLimit;\n        \n        vector<vector<int>> graph(stations, vector<int>(stations, 0));\n        for (int i = 0; i < connections; i++) {\n            int u, v, time;\n            cin >> u >> v >> time;\n            graph[u-1][v-1] = time;\n            graph[v-1][u-1] = time;\n        }\n        \n        vector<int> restaurantTimes(stations);\n        for (int i = 0; i < stations; i++) {\n            cin >> restaurantTimes[i];\n        }\n        \n        int startStation;\n        cin >> startStation;\n        \n        int result = maxRestaurants(startStation-1, timeLimit, graph, restaurantTimes);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\nimport sys\n\ndef max_restaurants(n, m, r_time, start_station, time_limit, connections, restaurants):\n    def bfs(from_station):\n        dist = {i: float('inf') for i in range(1, n + 1)}\n        dist[from_station] = 0\n        queue = deque([from_station])\n        while queue:\n            current = queue.popleft()\n            current_dist = dist[current]\n            for neighbor, travel_time in adj[current]:\n                if current_dist + travel_time < dist[neighbor]:\n                    dist[neighbor] = current_dist + travel_time\n                    queue.append(neighbor)\n        return dist\n\n    adj = defaultdict(list)\n    for u, v, t in connections:\n        adj[u].append((v, t))\n        adj[v].append((u, t))\n\n    dist_from_start = bfs(start_station)\n    \n    rest_times = {station: time for station, time in restaurants}\n    max_restaurants_visited = 0\n\n    def dfs(station, time_left, visited):\n        nonlocal max_restaurants_visited\n        \n        if dist_from_start[station] > time_left:\n            return\n        \n        max_restaurants_visited = max(max_restaurants_visited, len(visited))\n        \n        for neighbor, travel_time in adj[station]:\n            if neighbor in rest_times and neighbor not in visited:\n                if time_left >= 2 * travel_time + rest_times[neighbor]:\n                    dfs(neighbor, time_left - (2 * travel_time + rest_times[neighbor]), visited | {neighbor})\n\n    if dist_from_start[start_station] <= time_limit:\n        dfs(start_station, time_limit, set())\n    \n    return max_restaurants_visited\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    result = []\n    \n    while idx < len(data):\n        n = int(data[idx])\n        m = int(data[idx+1])\n        r_time = int(data[idx+2])\n        start_station = int(data[idx+3])\n        time_limit = int(data[idx+4])\n        idx += 5\n        \n        connections = []\n        for _ in range(m):\n            u, v, t = int(data[idx]), int(data[idx+1]), int(data[idx+2])\n            connections.append((u, v, t))\n            idx += 3\n        \n        restaurants = []\n        for _ in range(r_time):\n            station, time = int(data[idx]), int(data[idx+1])\n            restaurants.append((station, time))\n            idx += 2\n\n        result.append(max_restaurants(n, m, r_time, start_station, time_limit, connections, restaurants))\n\n    for res in result:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:27:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SiroRestaurants {\n\n    static class Edge {\n        int to, time;\n        Edge(int to, int time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    static class Restaurant {\n        int station, eatTime;\n        Restaurant(int station, int eatTime) {\n            this.station = station;\n            this.eatTime = eatTime;\n        }\n    }\n\n    public static int maxRestaurants(int startStation, int timeLimit, List<List<Edge>> connections, List<Restaurant> restaurants) {\n        int n = connections.size();\n        \n        List<Integer> stationRestaurants = new ArrayList<>();\n        int[] distance = new int[n];\n        Arrays.fill(distance, Integer.MAX_VALUE);\n        distance[startStation] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.add(new int[]{startStation, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int station = current[0], dist = current[1];\n            if (dist > distance[station]) continue;\n            for (Edge edge : connections.get(station)) {\n                int nextStation = edge.to, timeCost = edge.time;\n                if (distance[nextStation] > dist + timeCost) {\n                    distance[nextStation] = dist + timeCost;\n                    pq.add(new int[]{nextStation, distance[nextStation]});\n                }\n            }\n        }\n        \n        for (Restaurant restaurant : restaurants) {\n            if (restaurant.station != startStation) {\n                stationRestaurants.add(restaurant.eatTime + 2 * distance[restaurant.station]);\n            }\n        }\n        \n        Collections.sort(stationRestaurants);\n        int totalRestaurants = 0, currentTime = 0;\n        \n        for (int eatTime : stationRestaurants) {\n            if (currentTime + eatTime <= timeLimit) {\n                totalRestaurants++;\n                currentTime += eatTime;\n            } else {\n                break;\n            }\n        }\n        \n        return totalRestaurants;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int startStation = 0;\n        int timeLimit = 120;\n\n        List<List<Edge>> connections = new ArrayList<>();\n        connections.add(Arrays.asList(new Edge(1, 30), new Edge(2, 15)));  // Connections from station 0\n        connections.add(Arrays.asList(new Edge(0, 30), new Edge(2, 20)));  // Connections from station 1\n        connections.add(Arrays.asList(new Edge(0, 15), new Edge(1, 20)));  // Connections from station 2\n        // Add more stations and connections as needed\n\n        List<Restaurant> restaurants = new ArrayList<>();\n        restaurants.add(new Restaurant(1, 45));\n        restaurants.add(new Restaurant(2, 30));\n        // Add more restaurants as needed\n\n        System.out.println(maxRestaurants(startStation, timeLimit, connections, restaurants));\n    }\n}",
    "timestamp": "2025-08-13 07:27:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define MAX_RESTAURANTS 100\n\ntypedef struct {\n    int time;\n    int restaurants[MAX_RESTAURANTS];\n    int num_restaurants;\n} Station;\n\nint num_stations, num_connections, num_restaurants;\nint start_station;\nint time_limit;\nStation stations[MAX_STATIONS];\nint visited[MAX_STATIONS];\nint max_restaurants;\n\nvoid dfs(int station, int time_used, int visited_restaurants) {\n    if (time_used > time_limit) return;\n    if (visited_restaurants > max_restaurants) {\n        max_restaurants = visited_restaurants;\n    }\n    for (int i = 0; i < num_stations; i++) {\n        if (visited[i]) continue;\n        if (stations[station].time == INT_MAX || stations[i].time == INT_MAX) continue;\n\n        int travel_time = stations[station].time + stations[i].time;\n        visited[i] = 1;\n        dfs(i, time_used + travel_time, visited_restaurants + stations[i].num_restaurants);\n        visited[i] = 0;\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &num_stations, &num_connections, &num_restaurants);\n    scanf(\"%d %d\", &start_station, &time_limit);\n    start_station--;  // Convert to zero-based index\n\n    for (int i = 0; i < num_stations; i++) {\n        stations[i].num_restaurants = 0;\n        stations[i].time = INT_MAX;\n    }\n\n    for (int i = 0; i < num_connections; i++) {\n        int u, v, t;\n        scanf(\"%d %d %d\", &u, &v, &t);\n        u--; v--;  // Convert to zero-based index\n        stations[u].time = t;\n        stations[v].time = t;\n    }\n\n    for (int i = 0; i < num_restaurants; i++) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        s--;  // Convert to zero-based index\n        stations[s].restaurants[stations[s].num_restaurants++] = t;\n    }\n\n    visited[start_station] = 1;\n    max_restaurants = 0;\n    dfs(start_station, 0, 0);\n    \n    printf(\"%d\\n\", max_restaurants);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:27:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_restaurants(N, M, L, start, stations, connections, ramen_times):\n    # Create adjacency matrix for stations\n    graph = [[float('inf')] * N for _ in range(N)]\n    for u, v, time in connections:\n        graph[u-1][v-1] = time\n        graph[v-1][u-1] = time\n    \n    # Floyd-Warshall to compute shortest paths between all stations\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n    \n    # Track restaurants at each station\n    restaurant_stations = set(stations)\n    \n    # Find max restaurants Jiro can visit\n    max_restaurants_count = 0\n    \n    # Try all possible restaurant visit combinations using bitmask\n    for mask in range(1, 1 << (N-1)):\n        total_time = 0\n        restaurants_visited = 0\n        current_station = start - 1\n        \n        # Track visited stations\n        visited_stations = [current_station]\n        \n        for station in range(N):\n            if station == current_station:\n                continue\n            \n            # Check if restaurant exists and is selected in bitmask\n            if station in restaurant_stations and (mask & (1 << (station if station < current_station else station - 1))):\n                # Check time to go to restaurant and return\n                round_trip_time = graph[current_station][station] * 2 + ramen_times[stations.index(station+1)]\n                \n                if total_time + round_trip_time <= L:\n                    total_time += round_trip_time\n                    restaurants_visited += 1\n                    visited_stations.append(station)\n        \n        max_restaurants_count = max(max_restaurants_count, restaurants_visited)\n    \n    return max_restaurants_count\n\n# Input processing\nT = int(input())\nfor _ in range(T):\n    N, M, L = map(int, input().split())\n    start = int(input())\n    stations = list(map(int, input().split()))\n    connections = [list(map(int, input().split())) for _ in range(M)]\n    ramen_times = list(map(int, input().split()))\n    \n    result = max_restaurants(N, M, L, start, stations, connections, ramen_times)\n    print(result)",
    "timestamp": "2025-08-13 07:28:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        N = int(input[ptr])\n        ptr += 1\n        if N == 0:\n            break\n        M = int(input[ptr])\n        ptr += 1\n        L = int(input[ptr])\n        ptr += 1\n        K = int(input[ptr])\n        ptr += 1\n        A = int(input[ptr]) - 1\n        ptr += 1\n        H = int(input[ptr])\n        ptr += 1\n        frozen = list(map(int, input[ptr:ptr+N]))\n        ptr += N\n        adj = [[] for _ in range(N)]\n        for _ in range(K):\n            X = int(input[ptr]) - 1\n            ptr += 1\n            Y = int(input[ptr]) - 1\n            ptr += 1\n            T = int(input[ptr])\n            ptr += 1\n            adj[X].append((Y, T))\n            adj[Y].append((X, T))\n        \n        # Dijkstra's algorithm to find shortest time from A to all nodes\n        INF = float('inf')\n        dist = [INF] * N\n        dist[A] = 0\n        heap = []\n        heapq.heappush(heap, (0, A))\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[u]:\n                continue\n            for (v, t) in adj[u]:\n                if dist[v] > dist[u] + t:\n                    dist[v] = dist[u] + t\n                    heapq.heappush(heap, (dist[v], v))\n        \n        # Collect reachable nodes within L/2 time (since round trip)\n        reachable = []\n        for v in range(N):\n            if v != A and dist[v] <= L // 2 and frozen[v] == 1:\n                reachable.append(v)\n        \n        # Now, find maximum subset of reachable where sum of dist[v]*2 <= L\n        # This is a classic knapsack problem\n        times = [dist[v] * 2 for v in reachable]\n        max_time = L\n        dp = [0] * (max_time + 1)\n        for i in range(len(reachable)):\n            t = times[i]\n            for j in range(max_time, t - 1, -1):\n                if dp[j - t] + 1 > dp[j]:\n                    dp[j] = dp[j - t] + 1\n        print(max(dp))\n\nsolve()",
    "timestamp": "2025-08-13 07:28:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to, time;\n};\n\nint dfs(int station, int timeLeft, vector<vector<Edge>>& adj, \n        vector<int>& restaurantTime, vector<bool>& visited, int startStation) {\n    if (station != startStation && restaurantTime[station] > 0) {\n        timeLeft -= restaurantTime[station];\n    }\n    if (timeLeft < 0) return 0;\n    \n    int maxRestaurants = (station != startStation && restaurantTime[station] > 0) ? 1 : 0;\n    \n    visited[station] = true;\n\n    for (const Edge& edge : adj[station]) {\n        if (!visited[edge.to]) {\n            int travelTime = edge.time * 2; // to and from\n            maxRestaurants = max(maxRestaurants, \n                dfs(edge.to, timeLeft - travelTime, adj, restaurantTime, visited, startStation));\n        }\n    }\n    \n    visited[station] = false;\n    return maxRestaurants;\n}\n\nint solve(int n, int m, int r, vector<vector<Edge>>& adjacencyList, vector<int>& restaurantTime, int startStation, int timeLimit) {\n    vector<bool> visited(n, false);\n    return dfs(startStation, timeLimit, adjacencyList, restaurantTime, visited, startStation);\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n    \n    while (numDatasets--) {\n        int n, m, r; // number of stations, connections, restaurants\n        cin >> n >> m >> r;\n        \n        vector<vector<Edge>> adjacencyList(n);\n        for (int i = 0; i < m; ++i) {\n            int u, v, t;\n            cin >> u >> v >> t; \n            adjacencyList[u].push_back({v, t});\n            adjacencyList[v].push_back({u, t});\n        }\n        \n        vector<int> restaurantTime(n, 0);\n        for (int i = 0; i < r; ++i) {\n            int stationIndex, timeForRamen;\n            cin >> stationIndex >> timeForRamen; \n            restaurantTime[stationIndex] = timeForRamen;\n        }\n        \n        int startStation, timeLimit;\n        cin >> startStation >> timeLimit;\n        \n        int result = solve(n, m, r, adjacencyList, restaurantTime, startStation, timeLimit);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:43"
  }
]