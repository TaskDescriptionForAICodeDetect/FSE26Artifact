[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s))),D[1<<idx[s]][s]= SIRO[s];\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n    for(int i=0;i<N;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    memset(idx,0,sizeof(idx));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nint SIRO[N],idx[N];\nint n,m,l,s,T;\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    if(pos == s)res = max(res,__builtin_popcount(bit));\n    \n    for(int i=0;i<n;i++){\n      if(i!=s&&SIRO[i]==0)continue;\n      int ncost= cost+G[pos][i];\n      int nbit = bit;\n      if(D[nbit][i]>ncost){\n\tQ.push(PP(ncost,P(nbit,i)));\n\tD[nbit][i] = ncost;\n      }\n      if(i==s||bit>>idx[i]&1)continue;\n      nbit|=1<<idx[i],ncost+=+SIRO[i];\n      if(D[nbit][i]>ncost){\n      Q.push(PP(ncost,P(nbit,i)));\n      D[nbit][i] = ncost;\n      }\n      \n      \n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++) G[i][j] = T+1;\n      G[i][i] = 0;\n    }\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a][b] = G[b][a] = c;\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    memset(SIRO,0,sizeof(SIRO));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint bitcount(int x){\n  int ret = 0;\n  while(x){\n    ret += x&1;\n    x >>= 1;\n  }\n  return ret;\n}\n\nstruct Edge{\n  int to, cost;\n  Edge(int a, int b){\n    to = a;\n    cost = b;\n  }\n};\n\nint N, M, L, S, T;\n//vector<Edge>G[305];\nint dp[1<<16][16];\nint G[300][300];\nint jiro[16];\nint eat[16];\n\nint main()\n{\n  while(1){\n    cin >> N >> M >> L >> S >> T; \n    if(N == 0 && M == 0 && L == 0 && S == 0 && T == 0) break;\n    S--;\n  rep(i, N) rep(j, N) G[i][j] = INF;\n  rep(i, N) G[i][i] = 0;\n  for(int i=0;i<M;i++){\n    int a, b, c; cin >> a >> b >> c; a--; b--;\n    //    G[a].push_back(Edge(b, c));\n    //    G[b].push_back(Edge(a, c));\n    G[a][b] = G[b][a] = c;\n  }\n\n  rep(i, L){\n    cin >> jiro[i] >> eat[i]; jiro[i]--;\n  }\n\n  rep(k, N) G[k][k] = 0;\n  rep(k, N) rep(i, N) rep(j, N){\n    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n  }\n\n  for(int i=0;i<1<<16;i++) for(int j=0;j<16;j++) dp[i][j] = INF;\n  for(int i=0;i<L;i++) dp[1<<i][i] = G[S][jiro[i]] + eat[i];\n  for(int i=0;i<1<<L;i++){\n    for(int j=0;j<L;j++){\n      for(int k=0;k<L;k++){\n\tdp[i|(1<<k)][k] = min(dp[i|(1<<k)][k], dp[i][j] + G[jiro[j]][jiro[k]] + eat[k]);\n\t//\tif(dp[i|(1<<k)][k] != INF){\n\t//\t  cout << bitset<16>(i|(1<<k)) << \" \" << k << \" \" << dp[i|(1<<k)][k] << endl;\n\t  //\t}\n      }\n    }\n  }\n  int ret = 0;\n  for(int i=0;i<1<<L;i++){\n    for(int j=0;j<L;j++){\n      if(dp[i][j] + G[jiro[j]][S] <= T){\n\t//\tcout << bitset<16>(i) << \" \" << j << \" \" << \" \" << jiro[j] << \" \" << S <<\" \" << dp[i][j] << \" \" <<  G[jiro[j]][S] << endl;      \n\tret = max(ret, bitcount(i));\n      }\n    }\n  }\n\n  cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse{\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=0;\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]=dp[i1][xz]+1;\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint N;\nint dp[18][1 << 18];\nGraph g;\n\nint solve(int i, int bit)\n{\n\tif (dp[i][bit] != -1) return dp[i][bit];\n\tif (bit == (1 << N) - 1) return 0;\n\tint res = INF;\n\tREP(j, N)\n\t{\n\t\tif (i == j || ((bit >> j) & 1)) continue;\n\t\tint nbit = bit | (1 << j);\n\t\tchmin(res, solve(j, nbit) + g[i][j].cost);\n\t}\n\treturn dp[i][bit] = res;\n}\n\nint main()\n{\n\tint n, m, l, s, t;\n\twhile (cin >> n >> m >> l >> s >> t, n)\n\t{\n\t\tg.clear();\n\t\tMS(dp, -1);\n\t\ts--;\n\t\tvector<vi> d(n, vi(n, INF));\n\t\tREP(i, n) d[i][i] = 0;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tg.resize(l + 1);\n\t\tvi v, e;\n\t\tv.push_back(s); e.push_back(0);\n\t\tREP(i, l)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--;\n\t\t\tv.push_back(a);\n\t\t\te.push_back(b);\n\t\t}\n\t\tN = v.size();\n\t\tREP(i, N)\n\t\t{\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tadd_edge(g, i, j, d[v[i]][v[j]]);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, (1 << N) - 1)\n\t\t{\n\t\t\tif ((i >> s) & 1) continue;\n\t\t\tint bit = i << 1, cnt = -1;\n\t\t\tint time = 0;\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tif (((bit >> j) & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\ttime += e[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime += solve(0, bit);\n\t\t\tif (time <= t) chmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{\n  int v,c;\n};\n\nstruct S{\n  int v,t,b;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nbool u[323][1<<16];\n\nint main(){\n  for(int n,m,l,s,t;cin>>n>>m>>l>>s>>t,n|m|l|s|t;){\n    vector<edge> G[323];\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      G[a].push_back({b,c});\n      G[b].push_back({a,c});\n    }\n    int idx[323],e[323];\n    fill(begin(idx),end(idx),-1);\n    for(int i=0;i<l;i++){\n      int j;\n      cin>>j;\n      idx[j]=i;\n      cin>>e[j];\n    }\n    priority_queue<S> que;\n    que.push({s,0,0});\n    int ans=0;\n    fill(*begin(u),*end(u),false);\n    while(!que.empty()){\n      auto c=que.top();\n      if(c.t>t)break;\n      que.pop();\n      if(u[c.v][c.b]++)continue;\n      if(c.v==s){\n\tans=max(ans,__builtin_popcount(c.b));\n      }\n      for(auto elm:G[c.v]){\n\tque.push({elm.v,c.t+elm.c,c.b});\n      }\n      if(idx[c.v]>=0){\n\tque.push({c.v,c.t+e[c.v],c.b|1<<idx[c.v]});\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<29\nusing namespace std;\n \nint Station[301][301];\npair<int,int> p[20];\nint dp[(1<<18)][18];\n \nvoid init(){\n  for(int i=0;i<(1<<17);i++)for(int j=0;j<17;j++)dp[i][j]=inf;\n   \n  for(int i=0;i<301;i++){\n    for(int j=0;j<301;j++){\n      if(i==j)Station[i][j]=0;\n      else Station[i][j]=inf;\n    }\n  }\n}\n \nint main()\n{\n  int n,m,l,s,t,a,b,c,x,y;\n \n  while(1){\n    cin>>n>>m>>l>>s>>t;\n    if(n+m+l+s+t==0)break;\n    s--;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      a--;b--;\n      Station[a][b]=c;\n      Station[b][a]=c;\n    }\n    for(int i=0;i<l;i++){\n      cin>>p[i].f>>p[i].s;\n      p[i].f--;\n    }\n \n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      Station[i][j]=min(Station[i][j],Station[i][k]+Station[k][j]);\n    }\n      }\n    }\n \n    dp[0][0]=0;\n    for(int i=0;i<l;i++)dp[(1<<i)][i]=Station[s][p[i].f]+p[i].s;\n \n    for(int i=1;i<(1<<l);i++){\n      for(int j=0;j<l;j++){\n    if((i>>j)%2==1){\n      for(int k=0;k<l;k++){\n        if((i>>k)%2==0){\n          dp[(i|(1<<k))][k]=min(dp[(i|(1<<k))][k],\n                               dp[i][j]+Station[p[j].f][p[k].f]+p[k].s);\n        }\n      }\n    }\n      }\n    }\n    int ans=0;\n    for(int i=1;i<(1<<l)+1;i++){\n      for(int j=0;j<l;j++){\n    //cout<<dp[i][j]<<\" \"<<Station[p[j].f][s]<<\" \"<<i<<\" \"<<p[j].f<<endl;;\n    if((dp[i][j]+Station[p[j].f][s])<=t){\n      int sum=0;\n      for(int k=0;k<l;k++)if((i>>k)%2==1)sum++;\n      ans=max(ans,sum);\n    }\n      }\n    }\n    cout<<ans<<endl;;\n  }    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\tif (!nbs[nextplace] ||nextplace==0 ) {\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()/2] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nP SIRO[N];\nint n,m,l,s,T;\n\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(0,P(0,s)));\n  D[0][s] = 0;\n  \n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    if(cost + G[pos][s]<=T)res = max(res,__builtin_popcount(bit));\n\n    \n    for(int i=0;i<l;i++){\n      int npos = SIRO[i].first;\n      int ncost= cost+G[pos][npos]+SIRO[i].second;\n      int nbit = bit|1<<i;\n      if(bit==nbit||D[nbit][npos]<=ncost)continue;\n      Q.push(PP(ncost,P(nbit,npos)));\n      D[nbit][npos] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) G[i][j] = i==j? 0:T+1;\n\n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,G[a-1][b-1] = G[b-1][a-1] = c;\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[i] = P(j-1,e);\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return 0;\nelse{\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]=dp[i1][xz]+1;\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\n\nint main()\n{\n  int N, M, L, S, T;\n  int64 g[300][300];\n  int x[16], y[16];\n  int64 dp[1 << 16][16];\n\n  while(scanf(\"%d %d %d %d %d\", &N, &M, &L, &S, &T), N) {\n\n    --S;\n    fill_n(*g, 300 * 300, INF);\n    for(int i = 0; i < 300; i++) g[i][i] = 0;\n    fill_n(*dp, (1 << 16) * 16, INF);\n\n    for(int i = 0; i < M; i++) {\n      int A, B, C;\n      scanf(\"%d %d %d\", &A, &B, &C);\n      --A, --B;\n      g[A][B] = g[B][A] = C;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &x[i], &y[i]);\n      --x[i];\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    for(int i = 0; i < L; i++) {\n      dp[1 << i][i] = g[S][x[i]] + y[i];\n    }\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < L; k++) {\n          if((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + g[x[j]][x[k]] + y[k]);\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] + g[x[j]][S] <= T) {\n          ret = max(ret, __builtin_popcount(i));\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\n\nint main()\n{\n  int N, M, L, S, T;\n  int64 g[300][300];\n  int x[16], y[16];\n  int64 dp[1 << 16][16];\n\n  while(scanf(\"%d %d %d %d %d\", &N, &M, &L, &S, &T), N) {\n\n    fill_n(*g, 300 * 300, INF);\n    for(int i = 0; i < 300; i++) g[i][i] = 0;\n    fill_n(*dp, (1 << 16), INF);\n\n    for(int i = 0; i < M; i++) {\n      int A, B, C;\n      scanf(\"%d %d %d\", &A, &B, &C);\n      --A, --B;\n      g[A][B] = g[B][A] = C;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &x[i], &y[i]);\n      --x[i];\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    for(int i = 0; i < L; i++) {\n      dp[1 << i][i] = g[0][x[i]] + y[i];\n    }\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < L; k++) {\n          if((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + g[x[j]][x[k]] + y[k]);\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] + g[x[j]][0] <= T) {\n          ret = max(ret, __builtin_popcount(i));\n        }\n      }\n    }\n\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\n#define FOR(i, a, b) for(int i=(a), _b=(b); i<=_b; i++)\n#define DOW(i, a, b) for(int i=(a), _b=(b); i>=_b; i--)\n#define REP(i, b) for(int i=0; i<b; i++)\n#define CT(x) ((x) << 1)\n#define CP(x) (CT(x) + 1)\n#define PB push_back\n#define MP make_pair\n\n#define MAXN 333\n#define MAXT 100111\n#define MAXL 16\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, l, s, t;\nvector<pii> adj[MAXN];\nint e[MAXN];\nset<pair<int, pii> > se;\nint d[MAXN][1 << MAXL];\nint cnt[1 << MAXL], pos[MAXN];\n\nint bit_cnt(int x) {\n  int result = 0;\n  for(int i = 0; i < MAXL; i++)\n    if (x & 1 << i) result += 1;\n  return result;\n}\n\nint onbit(int x, int j) {\n  return ((x >> j) & 1);\n} \n\nint calc(int s) {\n  int u, v, k, newk, newd;\n  pair<int, pii> ele;\n  set<pair<int, pii> >::iterator it;\n  int res = 0;\n\n  se.clear();\n  se.insert(MP(0, MP(s, 0)));\n  \n  FOR(i, 1, n)\n    FOR(j, 0, (1 << l) - 1) d[i][j] = t + 1;\n  d[s][0] = 0;\n\n\n  while (!se.empty()) {\n    ele = *se.begin(); \n    se.erase(ele);\n    if (ele.first > t) break;\n    u = ele.second.first;\n    k = ele.second.second;\n    if (u == s && cnt[k] > res) {\n      res = cnt[k];\n      if (cnt[k] == l) break;\n    }\n    FOR(i, 0, adj[u].size()-1) {\n      v = adj[u][i].first;\n      if (pos[v] >= 0) newk = k | (1 << pos[v]);\n       else newk = k;\n      newd = d[u][k] + adj[u][i].second;\n      if ((pos[v] >= 0) && (!onbit(k, pos[v]))) {\n        // not eat yet --> eat at station v\n        newd += e[v];\n      }\n      if (d[v][newk] > newd) {\n        // update\n        d[v][newk] = newd;\n        it = se.find(MP(d[v][newk], MP(v, newk)));\n        if (it != se.end()) se.erase(it);\n        se.insert(MP(newd, MP(v, newk)));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  // freopen(\"in\", \"r\", stdin);\n  \n  int u, v, c;\n\n  FOR(i, 0, (1 << MAXL) - 1) {\n    cnt[i] = bit_cnt(i);\n  }\n\n  while (cin >> n >> m >> l >> s >> t) {\n    if (n == 0) break;\n    FOR(i, 1, n) adj[i].clear();\n    FOR(i, 1, m) {\n      cin >> u >> v >> c;\n      adj[u].push_back(make_pair(v, c));\n      adj[v].push_back(make_pair(u, c));\n    }\n    FOR(i, 1, n) e[i] = -1;\n    FOR(i, 1, n) pos[i] = -1;\n    FOR(i, 0, l-1) {\n      cin >> u >> e[u];\n      pos[u] = i;\n    }\n    cout << calc(s) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    map<int, int> timeTo; // time[nextStation]\n};\nmap<int, Station> stations;\n\nint s;\nint maxNum;\n\nvoid trip(int i, int rest, map<int, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(i == it->first){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    int n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(int i = 0; i < m; ++i){\n            int a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(int i = 0; i < l; ++i){\n            int j,e;\n            cin >> j >> e;\n            stations[j].timeTo[j] = e;\n        }\n        // remove station if it hasn't SIRO.\n        for(auto target = stations.begin(); target != stations.end(); ){\n            auto& nextStations = target->second.timeTo;\n            const bool hasSiro = nextStations.find(target->first) != nextStations.end();\n            if(hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            // reconnect\n            for(auto nextStation = nextStations.begin(); nextStation != nextStations.end(); ++nextStation){\n                auto& connectTargets = stations[target->first].timeTo;\n                for(auto connectTarget = connectTargets.begin(); connectTarget != connectTargets.end(); ++connectTarget){\n                    auto hogeTime = stations[nextStation->first].timeTo[target->first] + stations[target->first].timeTo[connectTarget->first];\n                    if(stations[nextStation->first].timeTo.find(connectTarget->first) == stations[nextStation->first].timeTo.end()){\n                        stations[nextStation->first].timeTo[connectTarget->first] = hogeTime;\n                    }else{\n                        if(stations[nextStation->first].timeTo[connectTarget->first] > hogeTime){\n                            stations[nextStation->first].timeTo[connectTarget->first] = hogeTime;\n                        }\n                    }\n                }\n                stations[nextStation->first].timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        map<int, bool> ate;\n        trip(s, t, ate);\n        cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\n\nint edges[301][301];\nint ramen_time[20];\nint dp[301][1<<16];\n\nint main(){\n  int num_of_stations;\n  int num_of_pairs;\n  int num_of_SIRO;\n  int starting_point;\n  int time_limit;\n  while(~scanf(\"%d %d %d %d %d\",\n               &num_of_stations,\n               &num_of_pairs,\n               &num_of_SIRO,\n               &starting_point,\n               &time_limit)){\n    if(num_of_stations == 0\n       && num_of_pairs == 0\n       && num_of_SIRO == 0\n       && starting_point == 0\n       && time_limit == 0) break;\n\n    memset(edges,0x3f,sizeof(edges));\n    starting_point--;\n\n    vector<int> candidates[301];\n    for(int i = 0; i < num_of_pairs; i++){\n      int from,to;\n      int time;\n      scanf(\"%d %d %d\",&from,&to,&time);\n      from--;\n      to--;\n      edges[from][to] = time;\n      edges[to][from] = time;\n      candidates[from].push_back(to);\n      candidates[to].push_back(from);\n    }\n\n    for(int mid = 0; mid < num_of_stations; mid++){\n      for(int from = 0; from < num_of_stations; from++){\n        for(int i = 0; i < candidates[from].size(); i++){\n          int to = candidates[from][i];\n          edges[from][to] = min(edges[from][to],edges[from][mid] + edges[mid][to]);\n        }\n      }\n    }\n\n    int SIRO_idx[301];\n    memset(SIRO_idx,-1,sizeof(SIRO_idx));\n    memset(ramen_time,0x3f,sizeof(ramen_time));\n    vector<int> SIROs;\n    SIROs.push_back(starting_point);\n    for(int i = 0; i < num_of_SIRO; i++){\n      int station,time;\n      scanf(\"%d %d\",&station,&time);\n      station--;\n      ramen_time[i] = time;\n      SIRO_idx[station] = i;\n      SIROs.push_back(station);\n    }\n\n    memset(dp,0x3f,sizeof(dp));\n    dp[starting_point][0] = 0;\n\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      for(int from_idx = 0; from_idx < SIROs.size(); from_idx++){\n        int from = SIROs[from_idx];\n        if(SIRO_idx[from] != -1){\n          dp[from][S | (1<<SIRO_idx[from])]\n            = min(dp[from][S | (1<<SIRO_idx[from])],\n                  dp[from][S] + ramen_time[SIRO_idx[from]]);\n        }\n\n        for(int to_idx = 0; to_idx < SIROs.size(); to_idx++){\n          int to = SIROs[to_idx];\n          if(from == to) continue;\n\n          if(SIRO_idx[to] == -1){\n            dp[to][S] = min(dp[from][S] + edges[from][to],dp[to][S]);\n          }\n          else{\n            dp[to][S | (1 << SIRO_idx[to])]\n              = min(dp[to][S | (1 << SIRO_idx[to])]\n                    ,dp[from][S] + edges[from][to] + ramen_time[SIRO_idx[to]]);\n            dp[to][S]\n              = min(dp[to][S],dp[from][S] + edges[from][to]);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      if(time_limit >= dp[starting_point][S]){\n        res = max(res,__builtin_popcount(S));\n      }\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\n\n\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()/2] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define inf 1000000000\n\nusing namespace std;\n\nint n, m, l, s, t;\nint g[305][305];\nint p[20], e[20];\nint G[20][20];\n\nint dp[1<<16][17];\n\nvoid WarshallFloyd()\n{\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint count(int s)\n{\n\tint ret = 0;\n\tfor(;s;s >>= 1) if(s&1) ret++;\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m >> l >> s >> t;\n\t\tif(n == 0 && m == 0 && l == 0 && s == 0 && t == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tg[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a, b, c;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\tWarshallFloyd();\n\t\t\n\t\tp[0] = s, e[0] = 0;\n\t\tfor(int i = 1; i <= l; i++){\n\t\t\tcin >> p[i] >> e[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\tG[i][j] = g[p[i]][p[j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N = 1 << l;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tdp[s][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\t\n\t\tint next;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\tdp[s][0] = min(dp[s][0], dp[s][j] + G[j][0]);\n\t\t\t\tfor(int k = 1; k <= l; k++){\n\t\t\t\t\tif(s & (1 << (k-1))) continue;\n\t\t\t\t\tnext = s | (1 << (k-1));\n\t\t\t\t\tdp[next][k] = min(dp[next][k], dp[s][j] + G[j][k] + e[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 1; k <= l; k++){\n\t\t\t\tif(s & (1 << (k-1))) continue;\n\t\t\t\tnext = s | (1 << (k-1));\n\t\t\t\tdp[next][k] = min(dp[next][k], dp[s][0] + G[0][k] + e[k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tif(dp[s][0] <= t) ans = max(ans, count(s));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int INF = 1e9;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint D[1<<16][N];\nint dijkstra(){\n  for(int i=0;i<(1<<l);i++)\n    for(int j=0;j<n;j++) D[i][j] = T+1;\n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s)));\n  Q.push(PP(0,P(0,s)));\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;s--;\n    if(!n)return 0;\n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n\nint dp[(1<<17)][20];\n\nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n\tfor(int j=1; j<=n; j++) {\n\t  if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n\n    fill(dp[0],dp[(1<<l)],MAX);\n    dp[0][l-1]=0;\n    for(int i=0; i<l-1; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    \n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n\tif((p&(1<<i)) && dp[p][i]!=MAX) {\n\t  if(p&(1<<(l-1))) {\n\t    int cnt=0;\n\t    for(int j=0; j<l; j++) {\n\t      if(p&(1<<j)) cnt++;\n\t    }\n\t    if(cnt-1>ans) ans=cnt-1;\n\t  }\n\n\t  for(int j=0; j<l; j++) {\n\t    if(!(p&(1<<j))) {\n\t      dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n\t      if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nP SIRO[N];\nint n,m,l,s,T;\n\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(0,P(0,s)));\n  D[0][s] = 0;\n  \n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    if(cost + G[pos][s]<=T)res = max(res,__builtin_popcount(bit));\n\n    \n    for(int i=0;i<l;i++){\n      int npos = SIRO[i].first;\n      int ncost= cost+G[pos][npos]+SIRO[i].second;\n      int nbit = bit|1<<i;\n      if(bit==nbit||D[nbit][npos]<=ncost)continue;\n      Q.push(PP(ncost,P(nbit,npos)));\n      D[nbit][npos] = ncost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) G[i][j] = i==j? 0:T+1;\n\n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,G[a-1][b-1] = G[b-1][a-1] = c;\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[i] = P(j-1,e);\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s;\n\nint f(int i1,int num,int t,int xz){\nif(xz==0) return num;\nelse{\n    num++;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0) return 0;\n    int hh=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) hh=max(f(i2,num,t-adj[xz][j1],j1),hh);\n        }\n    }\n    return hh;\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 28;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 301;\nconst int L = 16;\nint dist[N][N];\nint min_cost[N][1 << L];\n\nusing Elem = tuple<int, int, int>;\n\nint main(void){\n    for(int n, m, l, sv, t; cin >> n >> m >> l >> sv >> t, n;){\n        sv--;\n\n        rep(i, n) rep(j, n) dist[i][j] = inf;\n        rep(i, n) dist[i][i] = 0;\n        rep(loop, m){\n            int a, b, c; cin >> a >> b >> c;\n            a--, b--;\n            dist[a][b] = dist[b][a] = c;\n        }\n\n        vi jiro(n, -1);\n        vi j2v(l);\n        vi eat_time(l);\n        rep(i, l){\n            int v, e; cin >> v >> e;\n            v--;\n            jiro[v] = i;\n            j2v[i] = v;\n            eat_time[i] = e;\n        }\n\n        rep(k, n) rep(i, n) rep(j, n) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\n        rep(i, n) rep(j, 1 << l) min_cost[i][j] = inf;\n        priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n        q.push(Elem(0, sv, 0));\n\n        while(q.size()){\n            int cost, v, visited;\n            tie(cost, v, visited) = q.top(); q.pop();\n\n            if(not chmin(min_cost[v][visited], cost)) continue;\n\n            rep(ji, l){\n                int nv = j2v[ji];\n                if(dist[v][nv] >= inf) continue;\n\n                int ncost = cost + dist[v][nv];\n\n                int nvisited = visited;\n\n                if(not ((visited >> ji) & 1)){\n                    nvisited |= (1 << ji);\n                    ncost += eat_time[ji];\n\n                    if(min_cost[nv][nvisited] == inf){\n                        q.push(Elem(ncost, nv, nvisited));\n                    }\n                }\n            }\n        }\n\n        int res = 0;\n        rep(v, n){\n            rep(i, 1 << l){\n                if(min_cost[v][i] + dist[v][sv] > t) continue;\n                chmax(res, __builtin_popcount(i));\n            }\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int inf=1<<20;\n\nint main(void){\n\tint n,m,l,s,t;\n\twhile(cin >> n >> m >> l >> s >> t,n){\n\t\ts--;\n\t\tint dist[310][310];\n\t\trep(i,n)rep(j,n) dist[i][j]=i==j?0:inf;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tdist[a-1][b-1]=dist[b-1][a-1]=c;\n\t\t}\n\n\t\trep(k,n)rep(i,n)rep(j,n) chmin(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\n\n\t\tint tsp[1<<16][16],d[16],e[16];\n\t\trep(mask,1<<l)rep(i,l) tsp[mask][i]=inf;\n\n\t\trep(i,l) cin >> d[i] >> e[i],d[i]--;\n\t\trep(i,l) tsp[bit(i)][i]=dist[s][d[i]];\n\t\trep(mask,1,1<<l)rep(i,l) if(mask&bit(i)){\n\t\t\trep(j,l){\n\t\t\t\tif(mask&bit(j)) continue;\n\t\t\t\tchmin(tsp[mask|bit(j)][j],tsp[mask][i]+dist[d[i]][d[j]]);\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\trep(mask,1,1<<l)rep(i,l){\n\t\t\trep(j,l) if(mask&bit(j)) tsp[mask][i]+=e[j];\n\t\t\ttsp[mask][i]+=dist[d[i]][s];\n\t\t\tif(tsp[mask][i]<=t) chmax(ans,popcount(mask));\n\t\t}\n\t\tcout << ans << endl;\n\t}\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int n, m, l, s, t;\n    while(cin >> n >> m >> l >> s >> t, n) {\n        s--;\n        vector<vector<int>> d(n, vector<int>(n, INF));\n        for(int i=0; i<n; ++i) {\n            d[i][i] = 0;\n        }\n        for(int i=0; i<m; ++i) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            d[a][b] = d[b][a] = c;\n        }\n        for(int k=0; k<n; ++k) {\n            for(int i=0; i<n; ++i) {\n                for(int j=0; j<n; ++j) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        vector<int> rp(l), e(l);\n        for(int i=0; i<l; ++i) {\n            cin >> rp[i] >> e[i];\n            rp[i]--;\n        }\n\n        vector<vector<int>> dp(1 << l, vector<int>(l, INF));\n        for(int i=0; i<l; ++i) {\n            dp[1 << i][i] = d[s][rp[i]];\n        }\n        for(int S=1; S<(1<<l); ++S) {\n            for(int i=0; i<l; ++i) {\n                for(int j=0; j<l; ++j) {\n                    if((S >> j) & 1) {\n                        continue;\n                    }\n                    int nS = S | (1 << j);\n                    dp[nS][j] = min(dp[nS][j], dp[S][i] + d[rp[i]][rp[j]]);\n                }\n            }\n        }\n        int res = 0;\n        for(int S=0; S<1<<l; ++S) {\n            int sum = INF;\n            for(int i=0; i<l; ++i) {\n                sum = min(sum, dp[S][i] + d[rp[i]][s]);\n            }\n            for(int i=0; i<l; ++i) {\n                if((S >> i) & 1) {\n                    sum += e[i];\n                }\n            }\n            if(sum <= t) {\n                res = max(res, __builtin_popcount(S));\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 1E.cpp\n *\n *  Created on: Aug 22, 2015\n *      Author: Zhao Huangjie\n */\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nint n,m,l,s,t;\nvector<vector<int> > map,dp,adj;\nvector<int> r,e;\n\nint tsp(int pos,int mask){\n\tif(dp[pos][mask]!=1000000000){\n\t\treturn dp[pos][mask];\n\t}\n\tif(mask==((1<<(l+1))-1)){\n\t\treturn dp[pos][mask]=e[pos]+map[r[0]][r[pos]];\n\t}\n\tfor(int i=0;i<=l;i++){\n\t\tif((i!=pos&&(mask&(1<<i))==0)){\n\t\t\tdp[pos][mask]=min(dp[pos][mask],e[pos]+map[r[pos]][r[i]]+tsp(i,mask|(1<<i)));\n\t\t}\n\t}\n\n\treturn dp[pos][mask];\n}\n\nint main(){\n\twhile(cin>>n>>m>>l>>s>>t&&(!(n==0&&m==0&&l==0&&s==0&&t==0))){\n\t\tmap.assign(n+10,vector<int>(n+10,1000000000));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tmap[x][y]=map[y][x]=z;\n\t\t}\n\t\tadj.assign(n+1,vector<int>(0,0));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(map[i][j]<1000000000){\n\t\t\t\t\tadj[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.assign(l+1,0);\n\t\te.assign(l+1,0);\n\t\tr[0]=s;\n\t\te[0]=0;\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tcin>>r[i]>>e[i];\n\t\t}\n\n\t\t/*for(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tmap[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tfor(int i=0;i<=l;i++){\n\t\t\tint ss = r[i];\n\t\t\tvector<int> dis(n+1,1000000000);;\n\t\t\tdis[ss]=0;\n\t\t\tpriority_queue<ii ,vector<ii>,greater<ii> > pq;\n\t\t\tpq.push(ii(0,ss));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tii front=pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tint d=front.first;\n\t\t\t\tint u=front.second;\n\t\t\t\tif(d>dis[u]) continue;\n\t\t\t\tfor(int j=0;j<(int)adj[u].size();j++){\n\t\t\t\t\tint v=adj[u][j];\n\t\t\t\t\tif(dis[u]+map[u][v]<dis[v]){\n\t\t\t\t\t\tdis[v]=dis[u]+map[u][v];\n\t\t\t\t\t\tpq.push(ii(dis[v],v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j!=ss){\n\t\t\t\t\tmap[j][ss]=map[ss][j]=dis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<=n;i++){\n\t\t\tmap[i][i]=0;\n\t\t}*/\n\t\tdp.assign(l+10,vector<int>((1<<(l+1))+10,1000000000));\n\t\tint ans=0;\n\t\ttsp(0,1);\n\t\tfor(int i=0;i<=l;i++){\n\t\t\tfor(int j=1;j<(1<<(l+1));j+=2){\n\t\t\t\tif(dp[i][j]<=1000000000&&dp[i][j]+map[r[i]][s]<=t){\n\t\t\t\t\tint count=0;\n\t\t\t\t\tfor(int k=1;k<=l;k++){\n\t\t\t\t\t\tif((j&(1<<k))==0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,count+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst double EPS = 1e-8;\n#define pb push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define all(a) (a).begin(),(a).end()\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\ntypedef long long ll;\ntemplate<class T>\nostream& operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()){\n\t\tout << v[i] <<\", \";\n\t}\n\treturn out << \"}\" << endl;\n}\nint N, M, L, S, T;\nint D[310][310];\nvector<Pii> town;\n//jikan = dp[1<<16][now]\nint memo[1<<17][17];\n\nint solve(int bit, int now) {\n\tif(memo[bit][now] != -1){\n\t\treturn memo[bit][now];\n\t}\n\n\tint t = INF;\n\trep(i,town.size()) {\n\t\tif(!(1&(bit>>i))){\n\t\t\t//printf(\"%d->%d %d\\n\",town[now].fr, town[i].fr,D[town[now].fr][town[i].fr] + town[i].sc);\n\t\t\tt = min(t, solve(bit|(1<<i),i) + D[town[now].fr][town[i].fr] + town[i].sc);\n\t\t\tif(memo[bit|(1<<i)][i] == -1){\n\t\t\t\tmemo[bit|(1<<i)][i] = t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main() {\n\n\twhile(cin >> N  >> M >> L >> S >> T,N){\n\t\ttown.clear();\n\t\tmemset(memo,-1,sizeof(memo));\n\t\t--S;\n\t\trep(i,N){\n\t\t\trep(j,N){\n\t\t\t\tD[i][j] = INF*(i!=j);\n\t\t\t}\n\t\t}\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t--a;--b;\n\t\t\tD[a][b] = D[b][a] = c;\n\t\t}\n\t\trep(k,N){\n\t\t\trep(i,N){\n\t\t\t\trep(j,N){\n\t\t\t\t\tD[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttown.pb(mk(S,0));\n\t\trep(i,L){\n\t\t\tint j,e;\n\t\t\tcin >> j >> e;\n\t\t\t--j;\n\t\t\ttown.pb(mk(j,e));\n\t\t}\n\t\t\n\t\tsolve(1<<0, 0);\n\n\t\tint mx = 0;\n\n\t\trep(i,1<<town.size()){\n\t\t\t\n\t\t\t if(!(1&(i>>0))){\n\t\t\t \tcontinue;\n\t\t\t }\n\n\t\t\treps(j,1,town.size()){\n\t\t\t\tif(memo[i][j] == -1)continue;\n\t\t\t\t//printf(\"end ->%d %d\\n\",memo[i][j],D[town[j].fr][S]);\n\t\t\t\tif(memo[i][j]+D[town[j].fr][S] <= T) {\n\t\t\t\t\tmx = max(mx, __builtin_popcount(i)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << mx << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,L,S,T;\n#define INF ( 1<<28 )\nstruct edge{\n  int to,c;\n};\nstruct state{\n  int id,s,c;\n  bool operator>(const state &st) const{\n    return c > st.c;\n  }\n};\nvector<edge> G[22];\nint W[333][333];\nint J[20];\nint E[20];\nint h[21][(1<<16)];\nvoid solve(){\n  fill(h[0],h[L+1],T+1);\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push( (state){L,0,0} );\n  h[L][0] = 0;\n  while( !q.empty() ){\n    state st = q.top(); q.pop();\n    int id = st.id;\n    int bi = st.s;\n    int c = st.c;\n    //   cout << id <<  \" \" << bitset<6>(bi) << \" \" << c << endl;\n    // cout << \"JE \" << J[id] << \" \" << E[id] << endl;\n     if( id < L && (bi&(1<<id))==0 ){\n      int sbi = (bi |(1<<id));\n      if( h[id][sbi] > c + E[id] ){\n\th[id][sbi] = c + E[id];\n\tq.push( (state){id,sbi,c+E[id]} );\n      }\n    } \n    for(int i=0;i<(int)G[id].size();i++){\n      edge &e = G[id][i];\n      if( h[e.to][bi] > e.c + c ){\n\th[e.to][bi] = e.c + c;\n\tq.push( (state){e.to,bi,e.c+c} );\n      }\n    }\n  }\n  int res = 0;\n  for(int i=0;i<(1<<L);i++){\n    //    cout << S << \" \" << bitset<10>(i) << \" \"<< h[L][i] << endl;\n    if( h[L][i] <= T ){\n      res = max(res,__builtin_popcount(i));\n    }\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T && ( N||M||L||S||T ) ){\n    --S;\n    fill(W[0],W[N],INF);\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a>> b >> c ;\n      --a;--b;\n      W[a][b] = c;\n      W[b][a] = c;\n    }\n    for(int i=0;i<N;i++) W[i][i] = 0;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tfor(int k=0;k<N;k++)\n\t  W[j][k] = min(W[j][k],W[j][i] + W[i][k]);\n    for(int i=0;i<L;i++){\n      int j,e;\n      cin >> j >> e;\n      --j;\n      J[i] = j;\n      E[i] = e;\n    }\n    J[L] = S;\n    for(int i=0;i<=L;i++){\n      for(int j=i+1;j<=L;j++){\n\tint c = W[J[i]][J[j]];\n\tif( c < INF ) {\n\t  G[i].push_back( (edge){j,c} );\n\t  G[j].push_back( (edge){i,c} );\n\t}\n      }\n    }\n  \n    solve();\n\n    for(int i=0;i<=L;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[20][1 << 17];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 20; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 17); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][1] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t\n\t\t\tconst int nplace = atop.now;\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tconst int ntime(atop.time);\n\n\t\t\tif (nplace == 0&&ntime <= T) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t}\n\n\t\t\tque.pop();\n\t\t\tfor (auto j : edges[nplace]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\t\n\t\t\t\tconst int nexttime = ntime + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t}\n\t\t\t\tif (ramens[nextplace].second != -1) {\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n,m,l,s,t;cin>>n>>m>>l>>s>>t && n|m|l|s|t;){\n\t\ts--;\n\t\tvvi d(n,vi(n,INF));\n\t\trep(i,n) d[i][i]=0;\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w; u--,v--;\n\t\t\td[u][v]=d[v][u]=w;\n\t\t}\n\t\tvi rs(l),es(l);\n\t\trep(i,l) cin>>rs[i]>>es[i],rs[i]--;\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\n\t\tvvi dp(1<<l,vi(l,INF));\n\t\trep(i,l) dp[1<<i][i]=d[s][rs[i]]+es[i];\n\t\t\n\t\trepi(i,1,1<<l) rep(j,l) if(i>>j&1) rep(k,l) if(!(i>>k&1))\n\t\t\tdp[i|1<<k][k]=min(dp[i|1<<k][k],dp[i][j]+d[rs[j]][rs[k]]+es[k]);\n\t\t\n\t\tint res=0;\n\t\trep(i,1<<l) rep(j,l)\n\t\t\tif(dp[i][j]+d[rs[j]][s]<=t)\n\t\t\t\tres=max(res,__builtin_popcount(i));\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[300][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<16>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 300; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tedges[a].push_back(make_pair(b, c));\n\t\t\tedges[b].push_back(make_pair(a, c));\n\t\t}\n\t\tvector<pair<int,int>>ramens(N,make_pair(-1,-1));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens[j] = make_pair(i,e);\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ S,bitset<16>(0),0 });\n\n\n\t\tmemo[S][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t\n\t\t\tconst int nplace = atop.now;\n\t\t\tbitset<16>nbs(atop.eats);\n\t\t\tconst int ntime(atop.time);\n\n\t\t\tif (nplace == S&&ntime <= T) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t}\n\n\t\t\tque.pop();\n\t\t\tfor (auto j : edges[nplace]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\t\n\t\t\t\tconst int nexttime = ntime + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t}\n\t\t\t\tif (ramens[nextplace].second != -1) {\n\n\t\t\t\t\tconst int aramen = ramens[nextplace].first;\n\t\t\t\t\tif (!nbs[aramen]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 320\n#define INF 1e9\n\nstruct edge{\n  int to,cost,num;\n};\n\nstruct State{\n  int cost,v,S,num;\n  bool operator < (const State &s)const{\n    if(num != s.num){\n      return num < s.num;\n    }else{\n      return cost > s.cost;\n    }\n  }\n};\n\nint N,M,L,S,T;\nvector<edge> G[MAX];\nint dist[1<<16][MAX];\n\nint dijkstra(){\n  priority_queue<State> Q;\n  Q.push((State){0,S,0,0});\n  int ans = 0;\n  for(int i = 0 ; i < (1<<L) ; i++){\n    for(int j = 0 ; j < N+L ; j++){\n      dist[i][j] = INF;\n    }\n  }\n  dist[0][S] = 0;\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v;\n    if(s.cost <= T && v == S){\n      ans = max(ans,s.num);\n    }\n    if(s.cost >= T){ continue; }\n    if(dist[s.S][v] < s.cost) continue;\n    \n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(e.num == L){\n        if(dist[s.S][v] + e.cost < dist[s.S][e.to]){\n          dist[s.S][e.to] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[s.S][e.to],e.to,s.S,s.num});\n        }\n      }else{\n        if((s.S >> e.num) & 1) continue;\n        int next = s.S | (1<<e.num);\n        if(dist[s.S][v]+e.cost < dist[next][v]){\n          dist[next][v] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[next][v],v,next,s.num+1});\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    S--;\n    for(int i = 0 ; i < M ; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back((edge){b,c,L});\n      G[b].push_back((edge){a,c,L});\n    }\n    int n = N;\n    for(int i = 0 ; i < L ; i++){\n      int v,e;\n      cin >> v >> e; v--;\n      G[v].push_back((edge){n,e,i});\n      n++;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8;\nconst int MAX_V = 305;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint main(){\n\tint n, m, l, s, t;\n\twhile(cin >> n >> m >> l >> s >> t, n){\n\t\tint g[MAX_V][MAX_V];\n\t\tinit(g);\n\t\trep(i,m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\twarshallFloyd(g, n);\n\n\t\tvector<pair<int, int>> r(l);\n\t\trep(i,l){\n\t\t\tcin >> r[i].first >> r[i].second;\n\t\t\tr[i].first--;\n\t\t}\n\n\t\t//rep(i,n){ rep(j,n){ cout << g[i][j] << ' '; } cout << endl; }\n\n\t\tvector<vector<pair<int, int>>> ng(l);\n\t\trep(i,l){\n\t\t\trep(j,l){\n\t\t\t\tng[i].emplace_back(j, g[r[i].first][r[j].first]);\n\t\t\t\tng[j].emplace_back(i, g[r[i].first][r[j].first]);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> dp(1 << l, vector<int>(l, INF));\n\t\trep(i,l){\n\t\t\tdp[0][i] = g[s - 1][r[i].first];\n\t\t\t//dp[1 << l][l] = g[s][r[i].first] + r[i].second;\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\t\t//cout << endl;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tdp[setBit(b, i)][i] = min(dp[setBit(b, i)][i], dp[b][i] + r[i].second);\n\t\t\t\trep(j,l){\n\t\t\t\t\tdp[b][j] = min(dp[b][j], dp[b][i] + g[r[i].first][r[j].first]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\n\t\tint ans = 0;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tif(dp[b][i] + g[r[i].first][s - 1] <= t) ans = max<int>(ans, bitset<16>(b).count());\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[300][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<16>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 300; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tedges[a].push_back(make_pair(b, c));\n\t\t\tedges[b].push_back(make_pair(a, c));\n\t\t}\n\t\tvector<pair<int,int>>ramens(N,make_pair(-1,-1));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens[j] = make_pair(i,e);\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ S,bitset<16>(0),0 });\n\n\n\t\tmemo[S][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t\n\t\t\tconst int nplace = atop.now;\n\t\t\tbitset<16>nbs(atop.eats);\n\t\t\tconst int ntime(atop.time);\n\n\t\t\tif (nplace == S&&ntime <= T) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t}\n\n\t\t\tque.pop();\n\t\t\tfor (auto j : edges[nplace]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\t\n\t\t\t\tconst int nexttime = ntime + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t}\n\t\t\t\tif (ramens[nextplace].second != -1) {\n\n\t\t\t\t\tconst int aramen = ramens[nextplace].first;\n\t\t\t\t\tif (!nbs[aramen]) {\n\t\t\t\t\t\tnbs[aramen] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[aramen] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return 0;\nelse{\n    num++;\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]++;\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 334\n#define MAX_L 17\n#define INF 1e9\n \nstruct edge{\n    int to,cost;\n};\n \nstruct State{\n    int cost,v,S;\n    bool operator < (const State &s)const{\n\treturn cost > s.cost;\n    }\n};\n \nint N,M,L,S,T,restv[MAX_L],reste[MAX_L];\nvector<edge> G[MAX_L];\nint dist[1<<MAX_L][MAX_L];\n \nstring bit(int S){\n    string res;\n    for(int i = 0 ; i < L ; i++){\n\tif((S >> i) & 1) res += '1';\n\telse res += '0';\n    }\n    return res;\n}\n \nint dijkstra(){\n    priority_queue<State> Q;\n    Q.push((State){0,L,0});\n    int ans = 0;\n    for(int i = 0 ; i < (1<<L) ; i++){\n\tfor(int j = 0 ; j <= L ; j++){\n\t    dist[i][j] = INF;\n\t}\n    }\n    dist[0][L] = 0;\n    while(!Q.empty()){\n\tState s = Q.top(); Q.pop();\n\tint v = s.v;\n\tif(s.cost <= T && v == L){\n\t    ans = max(ans,__builtin_popcount(s.S));\n\t}\n\tif(s.cost >= T) continue;\n\tif(dist[s.S][v] < s.cost) continue;\n\tif(v != L){\n\t    if(!((s.S >> v) & 1)){\n\t\tint next = s.S | (1<<v);\n\t\tif(dist[s.S][v] + reste[v] < dist[next][v]){\n\t\t    dist[next][v] = dist[s.S][v] + reste[v];\n\t\t    Q.push((State){dist[next][v],v,next});\n\t\t}\n\t    }\n\t}\n\tfor(int i = 0 ; i < (int)G[v].size() ; i++){\n\t    edge &e = G[v][i];\n\t    if(dist[s.S][v] + e.cost < dist[s.S][e.to]){\n\t\tdist[s.S][e.to] = dist[s.S][v] + e.cost;\n\t\tQ.push((State){dist[s.S][e.to],e.to,s.S});\n\t    }\n\t}\n    }\n    return ans;\n}\n \nint main(){\n    while(cin >> N >> M >> L >> S >> T, N){\n\tint d[MAX][MAX];\n\tfor(int i = 0 ; i < N ; i++){\n\t    for(int j = 0 ; j < N ; j++){\n\t\tif(i == j){\n\t\t    d[i][j] = 0;\n\t\t}else{\n\t\t    d[i][j] = INF;\n\t\t}\n\t    }\n\t}\n\tfor(int i = 0 ; i < MAX_L ; i++){\n\t    G[i].clear();\n\t}\n\tS--;\n\tfor(int i = 0 ; i < M ; i++){\n\t    int a,b,c;\n\t    cin >> a >> b >> c;\n\t    a--; b--;\n\t    d[a][b] = d[b][a] = c;\n\t}\n\tfor(int k = 0 ; k < N ; k++){\n\t    for(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t}\n\t    }\n\t}\n\tint restv[MAX_L];\n\tfor(int i = 0 ; i < L ; i++){\n\t    cin >> restv[i] >> reste[i];\n\t    restv[i]--;\n\t}\n\trestv[L] = S; reste[L] = 0;\n\tfor(int i = 0 ; i <= L ; i++){\n\t    for(int j = i+1 ; j <= L ; j++){\n\t\tint time = d[restv[i]][restv[j]];\n\t\tif(time == INF) continue;\n\t\tG[i].push_back((edge){j,time});\n\t\tG[j].push_back((edge){i,time});\n\t    }\n\t}\n\tcout << dijkstra() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  vector<vector<int> >used(1<<l,vector<int>(n,0));   \n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s))),D[1<<idx[s]][s]= SIRO[s];\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost||used[bit][pos]++)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++)G[i].clear();\n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    memset(idx,0,sizeof(idx));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  const int INF = 1e9;\n  int n, m, l, s, t;\n  int dp[1 << 16][17];\n  \n  while (cin >> n >> m >> l >> s >> t && n ){\n    vector<vector<pair<int, int> > > G(n);\n    \n    REP(i, m){\n      int a, b, c;\n      cin >> a >> b >> c; a--, b--;\n      G[a].push_back(make_pair(b, c));\n      G[b].push_back(make_pair(a, c));\n    }\n    \n    vector<int> S(l + 1);\n    vector<int> E(l + 1);\n    vector<vector<int> >C(l + 1, vector<int>(l + 1));\n    \n    REP(i, l){\n      cin >> S[i] >> E[i]; S[i]--;\n    }\n    \n    S[l] = s - 1;\n    E[l] = 0;\n\n    REP(i, l + 1){\n      typedef pair<int, int> P;\n      \n      vector<int> D(n, INF);\n      priority_queue<P, vector<P>, greater<P>> que;\n      \n      que.push(P(0, S[i]));\n      D[S[i]] = 0;\n\n      while (!que.empty()){\n        int v = que.top().second;\n        int c = que.top().first;\n        que.pop();\n\n        if (D[v] < c) continue;\n\n        REP(i, G[v].size()){\n          int to = G[v][i].first;\n          int nc = c + G[v][i].second;\n\n          if (D[to] > nc){\n            D[to] = nc;\n            que.push(P(nc, to));\n          }\n        }\n      }\n      \n      REP(j, l + 1) C[i][j] = D[S[j]];\n    }\n\n    fill(&dp[0][0], &dp[0][0] + 17 * (1 << 16), INF);\n    dp[0][l] = 0;\n    \n    int res = 0;\n    \n    REP(mask, 1 << l) REP(u, l + 1) if (dp[mask][u] < INF){\n\n      if (dp[mask][u] + C[u][l] <= t){\n        res = max(res, __builtin_popcount(mask));\n      } else {\n        continue;\n      }\n      \n      REP(v, l + 1){\n        int nc = dp[mask][u] + C[u][v] + E[v];\n        int nm = v == l ? mask : (mask | (1 << v));\n\n        if (dp[nm][v] == -1 || dp[nm][v] > nc){\n          dp[nm][v] = nc;\n        }\n      }\n    }\n    \n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\n\nint main()\n{\n  int N, M, L, S, T;\n  int64 g[300][300];\n  int x[16], y[16];\n  int64 dp[1 << 16][16];\n\n  while(scanf(\"%d %d %d %d %d\", &N, &M, &L, &S, &T), N) {\n\n    --S;\n    fill_n(*g, 300 * 300, INF);\n    for(int i = 0; i < 300; i++) g[i][i] = 0;\n    fill_n(*dp, (1 << 16), INF);\n\n    for(int i = 0; i < M; i++) {\n      int A, B, C;\n      scanf(\"%d %d %d\", &A, &B, &C);\n      --A, --B;\n      g[A][B] = g[B][A] = C;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &x[i], &y[i]);\n      --x[i];\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    for(int i = 0; i < L; i++) {\n      dp[1 << i][i] = g[S][x[i]] + y[i];\n    }\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < L; k++) {\n          if((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + g[x[j]][x[k]] + y[k]);\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] + g[x[j]][S] < T) {\n          ret = max(ret, __builtin_popcount(i));\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    bool hasSiro;\n    map<long, long> timeTo; // time[nextStation]\n};\nmap<long, Station> stations;\n\nlong s;\nlong maxNum;\n\nvoid trip(long i, long rest, map<long, bool> ate, long last){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        map<long, bool> temp = ate;\n        if(it->first == i){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            temp[i] = true;\n        }\n        if(it->first == last){\n            continue;\n        }\n        trip(it->first, rest - it->second, temp, i);\n    }\n}\n\n// stationごとに最大成績を記録。それを超えないrouteはそこで終了させる。\n\nint main(){\n    long n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(long i = 0; i < m; ++i){\n            long a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(long i = 0; i < l; ++i){\n            long j,e;\n            cin >> j >> e;\n            stations[j].hasSiro = true;\n            stations[j].timeTo[j] = e;\n        }\n        for(auto target = stations.begin(); target != stations.end(); ){\n            if(target->second.hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            auto& nexts = target->second.timeTo;\n\n            for(auto next = nexts.begin(); next != nexts.end(); ++next){\n                auto& connects = stations.at(target->first).timeTo;\n                auto& nextStation = stations.at(next->first);\n                for(auto connect = connects.begin(); connect != connects.end(); ++connect){\n                    if(next->first == connect->first){\n                        continue;\n                    }\n                    auto& targetStation = stations.at(target->first);\n                    long time = nextStation.timeTo.at(target->first) + targetStation.timeTo.at(connect->first);\n                    auto hoge = nextStation.timeTo.find(connect->first);\n                    if(hoge == nextStation.timeTo.end()){\n                        nextStation.timeTo[connect->first] = time;\n                    }else if(hoge->second > time){\n                        hoge->second = time;\n                    }\n                }\n                nextStation.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        // cout << \"new: \" << stations.size() << endl;\n        map<long, bool> ate;\n        trip(s, t, ate, -1);\n        cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[20][1 << 17];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 17); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][1] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (1 << 17); ++i) {\n\t\t\tif (memo[0][i] < 99999999) {\n\t\t\t\tbitset<17>bs(i);\n\t\t\t\tans = max(ans, int(bs.count()));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint const INF = 1<<29;\n\nint N, M, L, S, T;\nint eat[20];\nmap<int, int> loc; int lcnt;\nmap<int, int> locrev;\n\ntypedef long long ll;\n\nll dp[1<<17][17];\n\nvoid init() {\n  loc.clear(); locrev.clear();\n}\n\nint main() {\n  \n  while(cin >> N >> M >> L >> S >> T && (N|M|L|S|T)) {\n    S --;\n    \n    init();\n    \n    int rawg[N][N]; fill(rawg[0], rawg[0]+N*N, INF);\n    \n    rep(i, M) {\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      rawg[a][b] = rawg[b][a] = c;\n    }\n    \n    lcnt = 0;\n    rep(i, L) {\n      int eattime, rawlocation;\n      cin >> rawlocation >> eattime; rawlocation --;\n      loc[rawlocation] = lcnt;\n      eat[lcnt] = eattime;\n      locrev[lcnt] = rawlocation;\n      lcnt ++;\n    }\n    \n    if(loc.find(S) == loc.end()) {\n      eat[lcnt] = 0;\n      loc[S] = lcnt;\n      locrev[lcnt] = S;\n      lcnt ++;\n      // cout << \"S: \" << S << \" loc[S]: \" << loc[S] << endl;\n    }\n    \n    rep(i, N) rawg[i][i] = 0;\n    rep(k, N) rep(i, N) rep(j, N) {\n      if(rawg[i][k] != INF && rawg[k][j] != INF) {\n        rawg[i][j] = min(rawg[i][j], rawg[i][k]+rawg[k][j]);\n      }\n    }\n\n    ll graph[lcnt][lcnt]; fill(graph[0], graph[0]+lcnt*lcnt, INF);\n    \n    rep(i, N) {\n      if(loc.find(i) == loc.end()) { continue; }\n      REP(j, i+1, N) {\n        if(loc.find(j) == loc.end()) { continue; }\n        graph[loc[i]][loc[j]]\n          = graph[loc[j]][loc[i]]\n          = rawg[i][j];\n      }\n    }\n    \n    fill(dp[0], dp[0]+(1<<17)*17, INF);\n    dp[1<<loc[S]][loc[S]] = 0;\n    \n    rep(state, 1<<lcnt) {\n      rep(i, lcnt) {\n        if(!(state >> i & 1)) continue;\n        rep(j, lcnt) {\n          if(state >> j & 1) continue;\n          int next = state | (1<<j);\n          if(graph[i][j] < INF) {\n            int cost = graph[i][j] + eat[j];\n            if(dp[next][j] > dp[state][i] + cost) {\n              dp[next][j] = dp[state][i] + cost;\n            }\n          }\n        }\n      }\n    }\n    \n    //cerr << \"Case\" << endl;\n    \n    int ans = 0;\n    rep(state, 1<<lcnt) {\n      rep(i, lcnt) {\n        if(dp[state][i] >= INF) continue;\n        \n        int sumcost = dp[state][i] + rawg[locrev[i]][S];\n        if(sumcost <= T) {\n          //  cerr << \"PASS \" << sumcost << \" \" << T << endl;;\n          ans = max(ans, __builtin_popcount(state));\n        }\n      }\n    }\n    \n    cout << ans-1 << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nint SIRO[N],idx[N];\nint n,m,l,s,T;\nvector<int> g;\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    if(pos == s)res = max(res,__builtin_popcount(bit));\n    \n    for(int j=0;j<l+1;j++){\n      int i = g[j];\n      if(i!=s&&SIRO[i]==0)continue;\n      int ncost= cost+G[pos][i];\n      int nbit = bit;\n      if(D[nbit][i]>ncost){\n\tQ.push(PP(ncost,P(nbit,i)));\n\tD[nbit][i] = ncost;\n      }\n      if(i==s||bit>>idx[i]&1)continue;\n      nbit|=1<<idx[i],ncost+=+SIRO[i];\n      if(D[nbit][i]>ncost){\n      Q.push(PP(ncost,P(nbit,i)));\n      D[nbit][i] = ncost;\n      }\n      \n      \n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++) G[i][j] = T+1;\n      G[i][i] = 0;\n    }\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a][b] = G[b][a] = c;\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    memset(SIRO,0,sizeof(SIRO));\n    g.resize(l);\n    g.push_back(s);\n    for(int i=0,j,e;i<l;i++){\n      cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i,g[i] = j-1;\n    }\n\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,l,s,inf=1e6,t,a,c,b,ok;\nint g[305][305],G[305][305],re;\nint ind[25],cost[25],dp[20][(1<<18)];\n\n\nint f(int cur,int vis){\nif(dp[cur][vis]!=-1) return dp[cur][vis];\nif((vis&(~(1<<cur)))==0) return dp[cur][vis]=G[l][cur]+cost[cur];\ndp[cur][vis]=1e9;\nfor(int j=0;j<l;j++){\n    if((j!=cur)&&(((1<<j)&vis)!=0)){\n        dp[cur][vis]=min(dp[cur][vis],f(j,vis&(~(1<<cur)))+G[j][cur]);\n    }\n}\ndp[cur][vis]+=cost[cur];\nreturn dp[cur][vis];\n}\n\nint main(){\nfreopen(\"2567-in1.txt\",\"r\",stdin);\nfreopen(\"hahaha.txt\",\"w\",stdout);\nwhile(cin>>n>>m>>l>>s>>t){\n    if(n+m+l+s+t==0) break;\n    memset(dp,-1,sizeof(dp));s--;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++) g[i][j]=inf;\n        g[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        cin>>a>>b>>c;\n        a--;b--;\n        g[a][b]=c;\n        g[b][a]=c;\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++)\n                g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n        }\n    }\n    for(int i=0;i<l;i++){\n        cin>>ind[i]>>cost[i];\n        ind[i]--;\n    }\n    for(int i=0;i<l;i++){\n        G[i][l]=g[ind[i]][s];\n        G[l][i]=g[ind[i]][s];\n        for(int j=0;j<l;j++) G[i][j]=g[ind[i]][ind[j]];\n    }\n    re=0;\n    for(int i=0;i<(1<<l);i++){\n        int cnt=0;\n        for(int j=0;j<l;j++) if(i&(1<<j)) cnt++;\n        for(int j=0;j<l;j++){\n            if(i&(1<<j)){\n                if(f(j,i)+G[j][l]<=t) re=max(re,cnt);\n            }\n        }\n    }\n    cout<<re<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    bool hasSiro;\n    long timeToEat;\n    map<long, long> timeTo; // time[nextStation]\n};\nmap<long, Station> stations;\n\nlong s;\nlong maxNum;\n\nvoid trip(long i, long rest, map<long, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(i == it->first){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    long n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(long i = 0; i < m; ++i){\n            long a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(long i = 0; i < l; ++i){\n            long j,e;\n            cin >> j >> e;\n            stations[j].hasSiro = true;\n            stations[j].timeToEat = e;\n        }\n        for(auto target = stations.begin(); target != stations.end(); ){\n            if(target->second.hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            auto& nexts = target->second.timeTo;\n\n            for(auto next = nexts.begin(); next != nexts.end(); ++next){\n                auto& connects = stations.at(target->first).timeTo;\n                auto& nextStation = stations.at(next->first);\n                for(auto connect = connects.begin(); connect != connects.end(); ++connect){\n                    if(next->first == connect->first){\n                        continue;\n                    }\n                    auto& targetStation = stations.at(target->first);\n                    long time = nextStation.timeTo.at(target->first) + targetStation.timeTo.at(connect->first);\n                    auto hoge = nextStation.timeTo.find(connect->first);\n                    if(hoge == nextStation.timeTo.end()){\n                        nextStation.timeTo[connect->first] = time;\n                    }else if(hoge->second > time){\n                        hoge->second = time;\n                    }\n                }\n                nextStation.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        // cout << \"new: \" << stations.size() << endl;\n        // map<long, bool> ate;\n        // trip(s, t, ate);\n        // cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\n\nint edges[301][301];\nint ramen_time[20];\nint dp[301][1<<16];\n\nint main(){\n  int num_of_stations;\n  int num_of_pairs;\n  int num_of_SIRO;\n  int starting_point;\n  int time_limit;\n  while(~scanf(\"%d %d %d %d %d\",\n               &num_of_stations,\n               &num_of_pairs,\n               &num_of_SIRO,\n               &starting_point,\n               &time_limit)){\n    if(num_of_stations == 0\n       && num_of_pairs == 0\n       && num_of_SIRO == 0\n       && starting_point == 0\n       && time_limit == 0) break;\n\n    memset(edges,0x3f,sizeof(edges));\n    starting_point--;\n\n    for(int i = 0; i < num_of_pairs; i++){\n      int from,to;\n      int time;\n      scanf(\"%d %d %d\",&from,&to,&time);\n      from--;\n      to--;\n      edges[from][to] = time;\n      edges[to][from] = time;\n    }\n\n    for(int mid = 0; mid < num_of_stations; mid++){\n      for(int from = 0; from < num_of_stations; from++){\n        for(int to = 0; to < num_of_stations; to++){\n          edges[from][to] = min(edges[from][to],edges[from][mid] + edges[mid][to]);\n        }\n      }\n    }\n\n    int SIRO_idx[301];\n    memset(SIRO_idx,-1,sizeof(SIRO_idx));\n    memset(ramen_time,0x3f,sizeof(ramen_time));\n    for(int i = 0; i < num_of_SIRO; i++){\n      int station,time;\n      scanf(\"%d %d\",&station,&time);\n      station--;\n      ramen_time[i] = time;\n      SIRO_idx[station] = i;\n    }\n\n    memset(dp,0x3f,sizeof(dp));\n    dp[starting_point][0] = 0;\n\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      for(int from = 0; from < num_of_stations; from++){\n        if(SIRO_idx[from] != -1){\n          dp[from][S | (1<<SIRO_idx[from])]\n            = min(dp[from][S | (1<<SIRO_idx[from])],\n                  dp[from][S] + ramen_time[SIRO_idx[from]]);\n        }\n\n        for(int to = 0; to < num_of_stations; to++){\n          if(from == to) continue;\n\n          if(SIRO_idx[to] == -1){\n            dp[to][S] = min(dp[from][S] + edges[from][to],dp[to][S]);\n          }\n          else{\n            dp[to][S | (1 << SIRO_idx[to])]\n              = min(dp[to][S | (1 << SIRO_idx[to])]\n                    ,dp[from][S] + edges[from][to] + ramen_time[SIRO_idx[to]]);\n            dp[to][S]\n              = min(dp[to][S],dp[from][S] + edges[from][to]);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      if(time_limit >= dp[starting_point][S]){\n        res = max(res,__builtin_popcount(S));\n      }\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[20][1 << 17];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 17); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][1] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint N;\nint dp[18][1 << 18];\nGraph g;\n\nint solve(int i, int bit)\n{\n\tif (dp[i][bit] != -1) return dp[i][bit];\n\tif (bit == (1 << N) - 1) return 0;\n\tint res = INF;\n\tREP(j, N)\n\t{\n\t\tif (i == j || (bit >> j) & 1) continue;\n\t\tint nbit = bit | (1 << j);\n\t\tchmin(res, solve(j, nbit) + g[i][j].cost);\n\t}\n\treturn dp[i][bit] = res;\n}\n\nint main()\n{\n\tint n, m, l, s, t;\n\twhile (cin >> n >> m >> l >> s >> t, n)\n\t{\n\t\tg.clear();\n\t\tMS(dp, -1);\n\t\ts--;\n\t\tvector<vi> d(n, vi(n, INF));\n\t\tREP(i, n) d[i][i] = 0;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tg.resize(l + 1);\n\t\tvi v, e;\n\t\tv.push_back(s); e.push_back(0);\n\t\tREP(i, l)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--;\n\t\t\tv.push_back(a);\n\t\t\te.push_back(b);\n\t\t}\n\t\tN = v.size();\n\t\tREP(i, N)\n\t\t{\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tadd_edge(g, i, j, d[v[i]][v[j]] + e[j]);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, (1 << l) - 1)\n\t\t{\n\t\t\tint bit = i << 1, cnt = -1;\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tif (((bit >> j) & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solve(0, bit) <= t) chmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll N, M, L, S, T;\n\nll dp[1 << 16][16];\nvector<ll> J, E;\n\nvoid solve() {\n    vector<vector<ll>> dist(N, vector<ll>(N, 1e9));\n    for(int i = 0; i < N; i++) dist[i][i] = 0;\n    for(int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        dist[a][b] = c;\n        dist[b][a] = c;\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < N; k++) {\n                chmin(dist[j][k], dist[j][i] + dist[i][k]);\n            }\n        }\n    }\n    J.resize(L);\n    E.resize(L);\n    for(int i = 0; i < L; i++) {\n        cin >> J[i] >> E[i];\n        J[i]--;\n    }\n    for(int bits = 0; bits < (1 << L); bits++) {\n        for(int i = 0; i < L; i++) dp[bits][i] = 1e9;\n        if(bits == 0) continue;\n        if(__builtin_popcount(bits) == 1) {\n            for(int i = 0; i < L; i++) {\n                if(bits & (1 << i)) {\n                    dp[bits][i] = dist[S][J[i]] + E[i];\n                }\n            }\n            continue;\n        }\n        for(int i = 0; i < L; i++) {\n            if(!(bits & (1 << i))) continue;\n            int before = bits & (~(1 << i));\n            for(int j = 0; j < L; j++) {\n                if(!before & (1 << j)) continue;\n                chmin(dp[bits][i], dp[before][j] + dist[J[j]][J[i]] + E[i]);\n            }\n        }\n    }\n    ll ans = 0;\n    for(int bits = 0; bits < (1 << L); bits++) {\n        for(int i = 0; i < L; i++) {\n            ll TIME = dp[bits][i] + dist[S][J[i]];\n            if(TIME <= T) chmax(ans, (ll)__builtin_popcount(bits));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> M >> L >> S >> T) {\n        if(N == 0) break;\n        S--;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define inf 1000000000\n\nusing namespace std;\n\nint n, m, l, s, t;\nint g[305][305];\nint p[20], e[20];\nint G[20][20];\n\nint dp[1<<16][17];\n\nvoid WarshallFloyd()\n{\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint count(int s)\n{\n\tint ret = 0;\n\tfor(;s;s >>= 1) if(s&1) ret++;\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m >> l >> s >> t;\n\t\tif(n == 0 && m == 0 && l == 0 && s == 0 && t == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tg[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a, b, c;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\tWarshallFloyd();\n\t\t\n\t\tp[0] = s, e[0] = 0;\n\t\tfor(int i = 1; i <= l; i++){\n\t\t\tcin >> p[i] >> e[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\tG[i][j] = g[p[i]][p[j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N = 1 << l;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tdp[s][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\t\n\t\tint next;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\t\n\t\t\t\tdp[s][0] = min(dp[s][0], dp[s][j] + G[j][0]);\n\t\t\t\tfor(int k = 1; k <= l; k++){\n\t\t\t\t\tif(s & (1 << (k-1))) continue;\n\t\t\t\t\tnext = s | (1 << (k-1));\n\t\t\t\t\tdp[next][k] = min(dp[next][k], dp[s][j] + G[j][k] + e[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tif(dp[s][0] <= t) ans = max(ans, count(s));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint N, M, L, S, T;\nint dp[20][1<<17];\n\nint bc(int x){\n  int res = 0;\n  while(x > 0){\n\tif(x&1) ++res;\n\tx >>= 1;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>L>>S>>T,N){\n\t--S;\n\tint dist[310][310];\n\tfill((int*)dist, (int*)dist+310*310, INF);\n\tfor(int i=0;i<M;++i){\n\t  int a, b, t; cin >> a >> b >> t;\n\t  --a, --b;\n\t  dist[a][b] = dist[b][a] = t;\n\t}\n\t\n\tint pl[20], ct[20];\n\tfor(int i=0;i<L;++i){\n\t  cin >> pl[i+1] >> ct[i+1];\n\t  --pl[i+1];\n\t}\n\t  \n\t++L;\n\tpl[0] = S;\n\tct[0] = 0;\n\n\tfor(int i=0;i<N;++i)\n\t  dist[i][i] = 0;\n\tfor(int k=0;k<N;++k)\n\t  for(int i=0;i<N;++i)\n\t\tfor(int j=0;j<N;++j)\n\t\t  dist[i][j] = dist[j][i] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tfill((int*)dp, (int*)dp+20*(1<<17), INF);\n\tdp[0][1] = 0;\n\tfor(int b=0;b<(1<<L);++b){\n\t  for(int i=0;i<L;++i){\n\t\tif((b>>i&1) == 0) continue;\n\t\tfor(int j=0;j<L;++j){\n\t\t  if(b>>j&1) continue;\n\t\t  dp[j][b|(1<<j)] = min(dp[j][b|(1<<j)], dp[i][b] + dist[pl[i]][pl[j]] + ct[j]);\n\t\t}\n\t  }\n\t}\n\n\tint ans = 0;\n\tfor(int i=0;i<L;++i)\n\t  for(int b=0;b<(1<<L);++b)\n\t\tif(dp[i][b] + dist[pl[i]][pl[0]] <= T)\n\t\t  ans = max(ans, bc(b)-1);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint N;\nint dp[18][1 << 18];\nint dist[18][18];\n\nint solve(int i, int bit)\n{\n\tif (dp[i][bit] != -1) return dp[i][bit];\n\tif ((bit >> 1) == (1 << (N - 1)) - 1) return dp[i][bit] = dist[i][0];\n\tint res = INF;\n\tFOR(j, 1, N)\n\t{\n\t\tif (i == j || (bit >> j) & 1) continue;\n\t\tint nbit = bit | (1 << j);\n\t\tchmin(res, solve(j, nbit) + dist[i][j]);\n\t}\n\treturn dp[i][bit] = res;\n}\n\nint main()\n{\n\tint n, m, l, s, t;\n\twhile (cin >> n >> m >> l >> s >> t, n)\n\t{\n\t\tMS(dp, -1);\n\t\ts--;\n\t\tvector<vi> d(n, vi(n, INF));\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tvi v, e;\n\t\tv.push_back(s); e.push_back(0);\n\t\tREP(i, l)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--;\n\t\t\tv.push_back(a);\n\t\t\te.push_back(b);\n\t\t}\n\t\tN = v.size();\n\t\tREP(i, N)\n\t\t{\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tif (i == j) dist[i][j] = INF;\n\t\t\t\telse dist[i][j] = d[v[i]][v[j]];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, (1 << l) - 1)\n\t\t{\n\t\t\tint bit = i << 1, cnt = -1;\n\t\t\tint time = 0;\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tif (((bit >> j) & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\ttime += e[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime += solve(0, bit);\n\t\t\tif (time <= t) chmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n\nint dp[(1<<18)][20];\n\nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int i=1; i<=n; i++) v[i][i]=0;\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n\tfor(int j=1; j<=n; j++) {\n\t  if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n\n    fill(dp[0],dp[(1<<l)],MAX);\n    for(int i=0; i<l; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    \n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n\tif((p&(1<<i)) && dp[p][i]!=MAX) {\n\t  if(i==l-1) {\n\t    int cnt=0;\n\t    for(int j=0; j<l-1; j++) {\n\t      if(p&(1<<j)) cnt++;\n\t    }\n\t    if(cnt>ans) ans=cnt;\n\t  }\n\n\t  for(int j=0; j<l; j++) {\n\t    if(!(p&(1<<j))) {\n\t      dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n\t      if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  struct rep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  struct revrep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) noexcept {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> void chmin(T& a, const T& b) noexcept {\n    if (b < a)\n      a = b;\n  }\n  template <class T> void chmax(T& a, const T& b) noexcept {\n    if (a < b)\n      a = b;\n  }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <limits>\n#include <utility>\n\nnamespace n91 {\n\n  void main_() {\n    while (true) {\n\n      static constexpr u64 Inf = std::numeric_limits<u64>::max() / 20;\n      const usize n{ scan<usize>() };\n      const usize m{ scan<usize>() };\n      const usize l{ scan<usize>() };\n      const usize start{ scan<usize>() - 1 };\n      const u64 t{ scan<usize>() };\n\n      if (n == 0) {\n        return;\n      }\n\n      auto d = md_vec(n, n, Inf);\n      for (const auto i : rep(0, n)) {\n        d[i][i] = 0;\n      }\n      for (const auto i : rep(0, m)) {\n        const usize a{ scan<usize>() - 1 };\n        const usize b{ scan<usize>() - 1 };\n        const u64 c{ scan<u64>() };\n        d[a][b] = c;\n        d[b][a] = c;\n      }\n      for (const auto j : rep(0, n)) {\n        for (const auto i : rep(0, n)) {\n          for (const auto k : rep(0, n)) {\n            chmin(d[i][k], d[i][j] + d[j][k]);\n          }\n        }\n      }\n      struct siro_t {\n        usize j;\n        u64 e;\n      };\n      std::vector<siro_t> siro(l);\n      for (auto& e : siro) {\n        e.j = scan<usize>() - 1;\n        e.e = scan<u64>();\n      }\n      siro.push_back({ start, 0 });\n      auto dp = md_vec(l + 1, 1 << l, Inf);\n      dp[l][0] = 0;\n      for (const auto s : rep(0, 1 << l)) {\n        for (const auto i : rep(0, l + 1)) {\n          for (const auto k : rep(0, l)) {\n            chmin(dp[k][s | 1 << k],\n              dp[i][s] + d[siro[i].j][siro[k].j] + siro[k].e);\n          }\n        }\n      }\n      usize ans = 0;\n      for (const auto i : rep(0, l)) {\n        for (const auto s : rep(0, 1 << l)) {\n          if (dp[i][s] + d[siro[i].j][start] <= t) {\n            usize cnt = 0;\n            for (const auto k : rep(0, l)) {\n              if (s >> k & 1) {\n                ++cnt;\n              }\n            }\n            chmax(ans, cnt);\n          }\n        }\n      }\n      std::cout << ans << std::endl;\n    }\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 1e+8;\n\nint main() {\n  while(1){\n    int n,m,l,s,t;\n    cin>>n>>m>>l>>s>>t;\n    --s;\n    if(!n)break;\n    int dist[300][300];\n    REP(i,300)REP(j,300)dist[i][j] = INF;\n    REP(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      --a;--b;\n      dist[a][b] = c;\n      dist[b][a] = c;\n    }\n    REP(k,n)REP(i,n)REP(j,n)dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    vector<tuple<int,int>> siro;\n    siro.emplace_back(s,0);\n    REP(i,l){\n      int j,e;\n      cin>>j>>e;\n      --j;\n      siro.emplace_back(j,e);\n    }\n    ++l;\n    int dp[1<<l][l];\n    REP(i,1<<l)REP(j,l)dp[i][j]=INF;\n    dp[1][0] = 0;\n    int num = 0;\n    REP(i,1<<l){\n      REP(j,l){\n        if(dp[i][j] < INF && ((i>>j)&1) == 1) {\n          if (dp[i][j] + dist[get<0>(siro[j])][get<0>(siro[0])] <= t) {\n            int cnt = 0;\n            REP(k,l) if (((i>>k)&1)==1) ++cnt;\n            num = max(num, cnt-1);\n          }\n          REP(k,l){\n            if (((i>>k)&1)==0) {\n              int sj,se,tj,te;\n              tie(sj,se) = siro[j];\n              tie(tj,te) = siro[k];\n              dp[i|(1<<k)][k] = min(dp[i|(1<<k)][k], dp[i][j] + dist[sj][tj] + te);\n            }\n          }\n        }\n      }\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N,M,L,S,T;\nint D[300][300];\nint J[16],E[16];\nint dp[1<<16][16];\nmain()\n{\n\twhile(cin>>N>>M>>L>>S>>T,N)\n\t{\n\t\tS--;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t{\n\t\t\tD[i][j]=i==j?0:1e9;\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint a,b,c;cin>>a>>b>>c;a--,b--;\n\t\t\tD[a][b]=D[b][a]=c;\n\t\t}\n\t\tfor(int i=0;i<L;i++)\n\t\t{\n\t\t\tcin>>J[i]>>E[i];\n\t\t\tJ[i]--;\n\t\t}\n\t\tfor(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t{\n\t\t\tD[i][j]=min(D[i][j],D[i][k]+D[k][j]);\n\t\t}\n\t\tfor(int i=0;i<1<<L;i++)for(int j=0;j<L;j++)dp[i][j]=1e9;\n\t\tfor(int i=0;i<L;i++)\n\t\t{\n\t\t\tdp[1<<i][i]=D[S][J[i]]+E[i];\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=1;i<1<<L;i++)\n\t\t{\n\t\t\tfor(int j=0;j<L;j++)\n\t\t\t{\n\t\t\t\tif(!(i>>j&1))continue;\n\t\t\t\tif(dp[i][j]+D[J[j]][S]<=T)ans=max(ans,__builtin_popcount(i));\n\t\t\t\tfor(int k=0;k<L;k++)\n\t\t\t\t{\n\t\t\t\t\tif(i>>k&1)continue;\n\t\t\t\t\tdp[i|1<<k][k]=min(dp[i|1<<k][k],dp[i][j]+D[J[j]][J[k]]+E[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n\nint dp[(1<<17)][20];\n\nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int i=1; i<=n; i++) dp[i][i]=0;\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n\tfor(int j=1; j<=n; j++) {\n\t  if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n\n    fill(dp[0],dp[(1<<l)],MAX);\n    for(int i=0; i<l; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    \n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n\tif((p&(1<<i)) && dp[p][i]!=MAX) {\n\t  if(i==l-1) {\n\t    int cnt=0;\n\t    for(int j=0; j<l-1; j++) {\n\t      if(p&(1<<j)) cnt++;\n\t    }\n\t    if(cnt>ans) ans=cnt;\n\t  }\n\n\t  for(int j=0; j<l; j++) {\n\t    if(!(p&(1<<j))) {\n\t      dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n\t      if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[16][1<<16];\nsigned main(){\n  int n,m,l,t,s;\n  while(cin>>n>>m>>l>>s>>t,n){\n    s--;\n    int a[m],b[m],c[m];\n    for(int i=0;i<m;i++) cin>>a[i]>>b[i]>>c[i];\n    int d[l],e[l];\n    for(int i=0;i<l;i++) cin>>d[i]>>e[i];\n    int INF=1LL<<55LL;\n    int g[n][n];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tg[i][j]=INF*(i!=j);\n    for(int i=0;i<m;i++){\n      a[i]--;b[i]--;\n      g[a[i]][b[i]]=g[b[i]][a[i]]=c[i];\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    map<int,int> mi;\n    for(int i=0;i<l;i++){\n      d[i]--;\n      mi[d[i]]=i;\n    }\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<l;i++)\n      dp[i][1<<i]=g[s][d[i]]+e[i];\n    int ans=0;\n    for(int b=0;b<(1<<l);b++){\n      for(int i=0;i<l;i++){\n\tif(dp[i][b]<0||dp[i][b]>t) continue;\n\t//cout<<i<<\" \"<<b<<endl;\n\tif(dp[i][b]+g[d[i]][s]<=t)\n\t  ans=max(ans,(int)__builtin_popcountll(b));\n\tfor(int j=0;j<l;j++){\n\t  if((b>>j)&1) continue;\n\t  if(dp[j][b+(1<<j)]<0||dp[j][b+(1<<j)]>dp[i][b]+g[d[i]][d[j]]+e[j])\n\t    dp[j][b+(1<<j)]=dp[i][b]+g[d[i]][d[j]]+e[j];\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n \nint dp[(1<<18)][20];\n \nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int i=1; i<=n; i++) v[i][i]=0;\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n    for(int j=1; j<=n; j++) {\n      if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n    }\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n \n    fill(dp[0],dp[(1<<l)],MAX);\n    dp[0][l-1]=0;\n    /*\n    for(int i=0; i<l; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    */\n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n    if(dp[p][i]!=MAX) {\n      if(i==l-1) {\n        int cnt=0;\n        for(int j=0; j<l-1; j++) {\n          if(p&(1<<j)) cnt++;\n        }\n        if(cnt>ans) ans=cnt;\n      }\n \n      for(int j=0; j<l; j++) {\n        if(!(p&(1<<j))) {\n          dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n          if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n        }\n      }\n    }\n      }\n    }  \n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,l,s,inf=1e6,t,a,c,b,ok;\nint g[305][305],G[305][305],re;\nint ind[25],cost[25],dp[20][(1<<18)];\n\n\nint f(int cur,int vis){\nif(dp[cur][vis]!=-1) return dp[cur][vis];\nif((vis&(~(1<<cur)))==0) return dp[cur][vis]=G[l][cur]+cost[cur];\ndp[cur][vis]=1e9;\nfor(int j=0;j<l;j++){\n    if((j!=cur)&&(((1<<j)&vis)!=0)){\n        dp[cur][vis]=min(dp[cur][vis],f(j,vis&(~(1<<cur)))+G[j][cur]);\n    }\n}\ndp[cur][vis]+=cost[cur];\nreturn dp[cur][vis];\n}\n\nint main(){\nwhile(cin>>n>>m>>l>>s>>t){\n    if(n+m+l+s+t==0) break;\n    memset(dp,-1,sizeof(dp));s--;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++) g[i][j]=inf;\n        g[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        cin>>a>>b>>c;\n        a--;b--;\n        g[a][b]=c;\n        g[b][a]=c;\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++)\n                g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n        }\n    }\n    for(int i=0;i<l;i++){\n        cin>>ind[i]>>cost[i];\n        ind[i]--;\n    }\n    for(int i=0;i<l;i++){\n        G[i][l]=g[ind[i]][s];\n        G[l][i]=g[ind[i]][s];\n        for(int j=0;j<l;j++) G[i][j]=g[ind[i]][ind[j]];\n    }\n    re=0;\n    for(int i=0;i<(1<<l);i++){\n        int cnt=0;\n        for(int j=0;j<l;j++) if(i&(1<<j)) cnt++;\n        for(int j=0;j<l;j++){\n            if(i&(1<<j)){\n                if(f(j,i)+G[j][l]<=t) re=max(re,cnt);\n            }\n        }\n    }\n    cout<<re<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    struct Edge {\n        int from, to, cost;\n        Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    };\n\n    int N, M, L, S, T;\n    vector< vector<Edge> > G;\n    vector<int> J, E;\n    bool input() {\n        cin >> N >> M >> L >> S >> T;\n        if (N == 0) return false;\n        S--;\n        G.clear(); G.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            G[a].push_back(Edge(a, b, c));\n            G[b].push_back(Edge(b, a, c));\n        }\n        J.clear(); J.resize(L + 1);\n        E.clear(); E.resize(L + 1);\n        J[0] = S;\n        for (int i = 1; i <= L; i++) {\n            cin >> J[i] >> E[i];\n            J[i]--;\n        }\n        return true;\n    }\n\n    vector< vector<int> > W;\n    const int INF = 1<<28;\n\n    struct State {\n        int v, bit, cost;\n        State(int v, int bit, int cost) : v(v), bit(bit), cost(cost) {}\n    };\n\n    void solve() {\n        W.clear(); W.resize(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) W[i][i] = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < G[i].size(); j++) {\n                const Edge& e = G[i][j];\n                W[ e.from ][ e.to ] = e.cost;\n            }\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    W[i][j] = min(W[i][j], W[i][k] + W[k][j]);\n                }\n            }\n        }\n        vector< vector<int> > dp(L + 1, vector<int>(1 << (L + 1), INF));\n        dp[0][0] = 0;\n        queue<State> Q;\n        Q.push(State(0, 0, 0));\n        while (!Q.empty()) {\n            State s = Q.front(); Q.pop();\n            for (int n = 1; n <= L; n++) {\n                if (s.bit & (1 << n)) continue;\n                int nbit = s.bit | (1 << n);\n                int ncost = s.cost + W[ J[s.v] ][ J[n] ] + E[n];\n                if (dp[n][nbit] > ncost) {\n                    dp[n][nbit] = ncost;\n                    Q.push(State(n, nbit, ncost));\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i <= L; i++) {\n            for (int bit = 0; bit < (1 << (L+1)); bit++) {\n                if (dp[i][bit] + W[ J[i] ][ J[0] ] <= T) {\n                    ans = max(ans, __builtin_popcount(bit));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nstruct Graph {\n    std::vector<std::vector<Edge<Cost>>> graph;\n\n    Graph(int n = 0) : graph(n) {}\n\n    void span(bool direct, int src, int dst, Cost cost = 1) {\n        graph[src].emplace_back(src, dst, cost);\n        if (!direct) graph[dst].emplace_back(dst, src, cost);\n    }\n\n    int size() const { return graph.size(); }\n    void clear() { graph.clear(); }\n    void resize(int n) { graph.resize(n); }\n\n    std::vector<Edge<Cost>>& operator[](int v) { return graph[v]; }\n    std::vector<Edge<Cost>> operator[](int v) const { return graph[v]; }\n};\n\nconstexpr int INF = 1 << 29;\n\nbool solve() {\n    int n, m, k, s, t;\n    std::cin >> n >> m >> k >> s >> t;\n    if (n == 0) return false;\n    --s;\n\n    auto dss = vec(n, vec(n, INF));\n    while (m--) {\n        int u, v, c;\n        std::cin >> u >> v >> c;\n        --u, --v;\n        dss[u][v] = dss[v][u] = c;\n    }\n    for (int v = 0; v < n; ++v) dss[v][v] = 0;\n\n    for (int v = 0; v < n; ++v) {\n        for (int u = 0; u < n; ++u) {\n            for (int w = 0; w < n; ++w) {\n                dss[u][w] = std::min(dss[u][w], dss[u][v] + dss[v][w]);\n            }\n        }\n    }\n\n    std::vector<int> vs(k), cs(k);\n    for (int i = 0; i < k; ++i) {\n        std::cin >> vs[i] >> cs[i];\n        --vs[i];\n    }\n    vs.push_back(s);\n\n    auto ndss = vec(k + 1, vec(k + 1, t + 1));\n    for (int i = 0; i <= k; ++i) {\n        for (int j = 0; j <= k; ++j) {\n            ndss[i][j] = dss[vs[i]][vs[j]];\n        }\n    }\n\n    auto dist = vec(k + 1, vec(1 << k, t + 1));\n    dist[k][0] = 0;\n    MinHeap<std::tuple<int, int, int>> que;\n    que.emplace(0, k, 0);\n\n    while (!que.empty()) {\n        int i, b, d;\n        std::tie(d, i, b) = que.top();\n        que.pop();\n        if (d > dist[i][b]) continue;\n\n        for (int j = 0; j <= k; ++j) {\n            int nd = d + ndss[i][j];\n            if (dist[j][b] <= nd) continue;\n            dist[j][b] = nd;\n            que.emplace(nd, j, b);\n        }\n\n        if (i < k && ((b >> i) & 1) == 0) {\n            int nb = b | (1 << i);\n            int nd = d + cs[i];\n            if (dist[i][nb] <= nd) continue;\n            dist[i][nb] = nd;\n            que.emplace(nd, i, nb);\n        }\n    }\n\n    int ans = 0;\n    for (int b = 0; b < (1 << k); ++b) {\n        if (dist[k][b] <= t) ans = std::max(ans, __builtin_popcount(b));\n    }\n\n    std::cout << ans << \"\\n\";\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {};\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    if(t-v1[xz].second<0) return 0;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint main() {\n\tint n, m, l, s, t, a, b, c, i, j, dist[310][310], time[310][310], count[310][310];\n\tint eat[310], k, ans;\n\twhile((scanf(\"%d %d %d %d %d\", &n, &m, &l, &s, &t)) != EOF) {\n\t\tif(n==0 && m==0 && l==0 && s==0 && t==0)\n\t\t\tbreak;\n\t\tfor(i=1;i<=n;++i) {\n\t\t\teat[i] = 0;\n\t\t\tfor(j=1;j<=n;++j) {\n\t\t\t\tdist[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\twhile(m--) {\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tdist[a][b] = c;\n\t\t\tdist[b][a] = c;\n\t\t}\n\t\twhile(l--) {\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\teat[a] = b;\n\t\t\tcount[s][a] = 1;\n\t\t\ttime[s][a] = dist[s][a] + eat[a];\n\t\t}\n\t\tfor(k=1;k<=n;++k) {\n\t\t\tfor(i=1;i<=n;++i) {\n\t\t\t\tfor(j=1;j<=n;++j) {\n\t\t\t\t\tif(dist[i][k] == -1 || dist[k][j] == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(dist[i][k] + dist[k][j] < dist[i][j])\n\t\t\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=1;k<=n;++k) {\n\t\t\tfor(i=1;i<=n;++i) {\n\t\t\t\tfor(j=1;j<=n;++j) {\n\t\t\t\t\tif(dist[i][k] == -1 || dist[k][j] == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(dist[i][k] + dist[k][j] + eat[k] <= t && eat[k] > 0) {\n\t\t\t\t\t\t++count[i][j];\n\t\t\t\t\t\ttime[i][j] = dist[i][k] + dist[k][j] + eat[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tfor(i=1;i<=n;++i) {\n\t\t\tif(i == s)\n\t\t\t\tcontinue;\n\t\t\tif(time[s][i] + dist[i][s] <= t) {\n\t\t\t\tif(count[s][i] > ans)\n\t\t\t\t\tans = count[s][i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<\" \";\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tif (nextplace == 0) {\n\n\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = nexttime;\n\t\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,l,s,t,d[301][301],x[20],tim[20],dl[20][20],dp[1<<16][16],a,b,c;\nmain(){\n  while(cin>>n>>m>>l>>s>>t,n){\n    r(i,(1<<l))r(j,16)dp[i][j]=1e8;\n    int ans=0;s--;\n    r(i,n)r(j,n)d[i][j]=1e8;\n    r(i,m){\n      cin>>a>>b>>c;\n      d[--a][--b]=d[b][a]=c;\n    }\n    r(i,l)cin>>x[i]>>tim[i],x[i]--;\n    r(k,n)r(i,n)r(j,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    r(i,l)r(j,l)dl[i][j]=d[x[i]][x[j]]+tim[j];\n    r(i,l)dp[(1<<i)][i]=d[s][x[i]]+tim[i];\n    r(i,(1<<l))r(j,l)if((1<<j)&i)r(k,l)if(j!=k&&dl[j][k]&&((1<<k)&i)==0)\n      if(dl[j][k]+dp[i][j]<=t)dp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+dl[j][k]);\n    r(i,(1<<l))r(j,l)if(dp[i][j]+d[x[j]][s]<=t)ans=max(ans,__builtin_popcount(i));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\ntemplate<typename A,typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost){\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nint dp[17][(1 << 17)];\nvoid solve(){\n    while (true) {\n        int n, m, l, s, t;\n        cin >> n >> m >> l >> s >> t;\n        if (n == 0) return;\n        s--;\n        auto coster = [](int a) {\n            return a;\n        };\n        Dijkstra<int, decltype(coster)> graph(n, coster);\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            graph.add_edge(a, b, c);\n            graph.add_edge(b, a, c);\n        }\n        vector<pair<int, int>> ramens;\n        ramens.push_back(mp(s, 0));\n        REP(i, l) {\n            int a, b;\n            cin >> a >> b;\n            a--;\n            ramens.push_back(mp(a, b));\n        }\n        l++;\n        ll dist[18][18] = {};\n        REP(i, l) {\n            vector<int> hoge = graph.build_result(ramens[i].first);\n            REP(q, hoge.size()) {\n                REP(j, l) {\n                    if (ramens[j].first == q) {\n                        dist[i][j] = hoge[q];\n                    }\n                }\n            }\n        }\n        REP(i, l) {\n            REP(q, (1 << l)) {\n                dp[i][q] = 2e18;\n            }\n        }\n        dp[0][0] = 0;\n        priority_queue<tuple<int, int, int>> next;\n        next.push(make_tuple(0, 0, 0));\n        int ans = 0;\n        while (next.empty() == false) {\n            tuple<int, int, int> now = next.top();\n            next.pop();\n            get<0>(now) *= -1;\n            if (get<0>(now) > t) continue;\n            if (dp[get<1>(now)][get<2>(now)] != get<0>(now)) continue;\n            if (get<1>(now) == 0) {\n                int cnt = 0;\n                REP(q, l) {\n                    if ((1 << q) & get<2>(now)) cnt++;\n                }\n                ans = max(ans, cnt - 1);\n            }\n            REP(q, l) {\n                if (get<2>(now)& (1 << q)) continue;\n                if(dist[get<1>(now)][q] + get<0>(now) + ramens[q].second <= t)\n                if (dist[get<1>(now)][q] + get<0>(now) + ramens[q].second < dp[q][get<2>(now) + (1 << q)]) {\n                    dp[q][get<2>(now) + (1 << q)] = dist[get<1>(now)][q] + get<0>(now) + ramens[q].second;\n                    next.push(make_tuple(-dp[q][get<2>(now) + (1 << q)], q, get<2>(now) + (1 << q)));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<29\nusing namespace std;\n\nint Station[301][301];\npair<int,int> p[20];\nint dp[(1<<18)][18];\n\nvoid init(){\n  for(int i=0;i<(1<<17);i++)for(int j=0;j<17;j++)dp[i][j]=inf;\n  \n  for(int i=0;i<301;i++){\n    for(int j=0;j<301;j++){\n      if(i==j)Station[i][j]=0;\n      else Station[i][j]=inf;\n    }\n  }\n}\n\nint main()\n{\n  int n,m,l,s,t,a,b,c,x,y;\n\n  while(1){\n    cin>>n>>m>>l>>s>>t;\n    if(n+m+l+s+t==0)break;\n    s--;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      a--;b--;\n      Station[a][b]=c;\n      Station[b][a]=c;\n    }\n    for(int i=0;i<l;i++){\n      cin>>p[i].f>>p[i].s;\n      p[i].f--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  Station[i][j]=min(Station[i][j],Station[i][k]+Station[k][j]);\n\t}\n      }\n    }\n\n    dp[0][0]=0;\n    for(int i=0;i<l;i++)dp[(1<<i)][i]=Station[s][p[i].f]+p[i].s;\n\n    for(int i=1;i<(1<<l);i++){\n      for(int j=0;j<l;j++){\n\tif((i>>j)%2==1){\n\t  for(int k=0;k<l;k++){\n\t    if((i>>k)%2==0){\n\t      dp[(i|(1<<k))][k]=min(dp[(i|(1<<k))][k],\n                               dp[i][j]+Station[p[j].f][p[k].f]+p[k].s);\n\t    }\n\t  }\n\t}\n      }\n    }\n    int ans=0;\n    for(int i=1;i<(1<<l)+1;i++){\n      for(int j=0;j<l;j++){\n\t//cout<<dp[i][j]<<\" \"<<Station[p[j].f][s]<<\" \"<<i<<\" \"<<p[j].f<<endl;;\n\tif((dp[i][j]+Station[p[j].f][s])<=t){\n\t  int sum=0;\n\t  for(int k=0;k<l;k++)if((i>>k)%2==1)sum++;\n\t  ans=max(ans,sum);\n\t}\n      }\n    }\n    cout<<ans<<endl;;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define SIZE 300\n#define INF 1000000000\n\nint dist[SIZE][SIZE];\nint dp[17][1<<16];\n\nbool solve() {\n  int N, M, L, S, T;\n  int J[18], E[18];\n\n  scanf(\"%d%d%d%d%d\", &N, &M, &L, &S, &T);\n  S--;\n\n  if (N == 0) return false;\n\n  for (int i=0; i<N; i++)\n    for (int j=0; j<N; j++)\n      dist[i][j] = INF * (i != j);\n\n  for (int i=0; i<M; i++) {\n    int a, b, c;\n    scanf(\"%d%d%d\", &a, &b, &c);\n    a--; b--;\n    dist[a][b] = dist[b][a] = c;\n  }\n\n  for (int k=0; k<N; k++)\n    for (int i=0; i<N; i++)\n      for (int j=0; j<N; j++)\n        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n  for (int i=0; i<L; i++) {\n    scanf(\"%d%d\", J+i, E+i);\n    J[i]--;\n  }\n  J[L] = S; E[L] = 0;\n\n  for (int i=0; i<=L; i++)\n    for (int j=0; j<(1<<L); j++)\n      dp[i][j] = INF;\n\n  dp[L][0] = 0;\n\n  for (int i=0; i<(1<<L); i++) {\n    for (int j=0; j<=L; j++) {\n      for (int k=0; k<=L; k++) {\n        if (i & (1<<k)) continue;\n\n        int b = k != L ? 1 << k : 0;\n\n        dp[k][i|b] = min(dp[k][i|b], dp[j][i] + dist[J[j]][J[k]] + E[k]);\n      }\n    }\n  }\n\n  int ans = 0;\n\n  for (int i=0; i<(1<<L); i++) {\n    if (dp[L][i] <= T)\n      ans = max(ans, __builtin_popcount(i));\n  }\n\n  cout << ans << endl;\n\n  return true;\n}\n\nint main() {\n  while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\n#define FOR(i, a, b) for(int i=(a), _b=(b); i<=_b; i++)\n#define DOW(i, a, b) for(int i=(a), _b=(b); i>=_b; i--)\n#define REP(i, b) for(int i=0; i<b; i++)\n#define CT(x) ((x) << 1)\n#define CP(x) (CT(x) + 1)\n#define PB push_back\n#define MP make_pair\n\n#define MAXN 333\n#define MAXT 100111\n#define MAXL 16\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, l, s, t;\nset<pair<int, pii> > se;\nint d[MAXN][1 << MAXL];\nint e[MAXN];\nint cnt[1 << MAXL];\nint w[MAXN][MAXN];\nint L[MAXL];\n\nint onbit(int x, int j) {\n  return ((x >> j) & 1);\n} \n\nint bit_cnt(int x) {\n  int result = 0;\n  for(int i = 0; i < MAXL; i++)\n    if (onbit(x, i)) result += 1;\n  return result;\n}\n\n\nint calc(int s) {\n  int u, v, k, newk, newd;\n  pair<int, pii> ele;\n  set<pair<int, pii> >::iterator it;\n  int res = 0;\n\n  se.clear();\n  se.insert(MP(0, MP(s, 0)));\n  \n  FOR(i, 1, n)\n    FOR(j, 0, (1 << l) - 1) d[i][j] = t + 1;\n  d[s][0] = 0;\n\n\n  while (!se.empty()) {\n    ele = *se.begin(); se.erase(ele);\n    if (ele.first > t) break;\n    u = ele.second.first;\n    k = ele.second.second;\n    if (cnt[k] > res && d[u][k] + w[u][s] <= t) {\n      res = cnt[k];\n      if (res == l) break;\n    }\n    FOR(i, 0, l-1) {\n      v = L[i];\n      newk = k | (1 << i);\n      newd = d[u][k] + w[u][v];\n      if (!onbit(k, i)) {\n        // not eat yet --> eat at station v\n        newd += e[v];\n      }\n      if (d[v][newk] > newd) {\n        // update\n        d[v][newk] = newd;\n        it = se.find(MP(d[v][newk], MP(v, newk)));\n        if (it != se.end()) se.erase(it);\n        se.insert(MP(newd, MP(v, newk)));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n//  freopen(\"in\", \"r\", stdin);\n  \n  int u, v, c;\n\n  FOR(i, 0, (1 << MAXL) - 1) {\n    cnt[i] = bit_cnt(i);\n  }\n\n  while (cin >> n >> m >> l >> s >> t) {\n    if (n == 0) break;\n\n    FOR(u, 1, n)\n      FOR(v, 1, n) if (u == v) w[u][v] = 0;\n       else w[u][v] = t + 1;\n\n    FOR(i, 1, m) {\n      cin >> u >> v >> c;\n      w[u][v] = w[v][u] = c;\n    }\n\n    // Floyd\n    FOR(k, 1, n) FOR(u, 1, n) FOR(v, 1, n) \n      if (w[u][v] > w[u][k] + w[k][v]) \n        w[u][v] = w[u][k] + w[k][v];\n         \n    FOR(i, 1, n) e[i] = -1;\n    FOR(i, 0, l-1) {\n      cin >> u >> e[u];\n      L[i] = u;\n    }\n    cout << calc(s) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    struct Edge {\n        int from, to, cost;\n        Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    };\n\n    int N, M, L, S, T;\n    vector< vector<Edge> > G;\n    vector<int> J, E;\n    bool input() {\n        cin >> N >> M >> L >> S >> T;\n        if (N == 0) return false;\n        S--;\n        G.clear(); G.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            G[a].push_back(Edge(a, b, c));\n            G[b].push_back(Edge(b, a, c));\n        }\n        J.clear(); J.resize(L);\n        E.clear(); E.resize(L);\n        for (int i = 0; i < L; i++) {\n            cin >> J[i] >> E[i];\n            J[i]--;\n        }\n        return true;\n    }\n\n    vector< vector<int> > W;\n    const int INF = 1<<28;\n\n    struct State {\n        int v, bit, cost;\n        State(int v, int bit, int cost) : v(v), bit(bit), cost(cost) {}\n    };\n\n    void solve() {\n        W.clear(); W.resize(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) W[i][i] = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < G[i].size(); j++) {\n                const Edge& e = G[i][j];\n                W[ e.from ][ e.to ] = e.cost;\n            }\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    W[i][j] = min(W[i][j], W[i][k] + W[k][j]);\n                }\n            }\n        }\n        vector< vector<int> > dp(L, vector<int>(1 << L, INF));\n        queue<State> Q;\n        for (int i = 0; i < L; i++) {\n            Q.push(State(i, 1<<i, W[S][J[i]] + E[i]));\n            dp[i][1<<i] = W[S][J[i]] + E[i];\n        }\n        while (!Q.empty()) {\n            State s = Q.front(); Q.pop();\n            for (int n = 0; n < L; n++) {\n                if (s.bit & (1 << n)) continue;\n                int nbit = s.bit | (1 << n);\n                int ncost = s.cost + W[ J[s.v] ][ J[n] ] + E[n];\n                if (ncost + W[J[n]][S] > T) continue;\n                if (dp[n][nbit] > ncost) {\n                    dp[n][nbit] = ncost;\n                    Q.push(State(n, nbit, ncost));\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < L; i++) {\n            for (int bit = 0; bit < (1 << L); bit++) {\n                if (dp[i][bit] + W[ J[i] ][ J[0] ] <= T) {\n                    ans = max(ans, __builtin_popcount(bit));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 320\n#define INF 1e9\n\nstruct edge{\n  int to,cost,num;\n};\n\nstruct State{\n  int cost,v,S,num;\n  bool operator < (const State &s)const{\n    if(num != s.num){\n      return num > s.num;\n    }else{\n      return cost > s.cost;\n    }\n  }\n};\n\nint N,M,L,S,T;\nvector<edge> G[MAX];\nint dist[1<<16][MAX];\n\nint dijkstra(){\n  priority_queue<State> Q;\n  Q.push((State){0,S,0,0});\n  int ans = 0;\n  for(int i = 0 ; i < (1<<L) ; i++){\n    for(int j = 0 ; j < N+L ; j++){\n      dist[i][j] = INF;\n    }\n  }\n  dist[0][S] = 0;\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v;\n    if(s.cost <= T && v == S){\n      ans = max(ans,s.num);\n    }\n    if(s.cost >= T){ continue; }\n    if(dist[s.S][v] < s.cost) continue;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(e.num == L){\n        if(dist[s.S][v] + e.cost < dist[s.S][e.to]){\n          dist[s.S][e.to] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[s.S][e.to],e.to,s.S,s.num});\n        }\n      }else{\n        if((s.S >> e.num) & 1) continue;\n        int next = s.S | (1<<e.num);\n        if(dist[s.S][v]+e.cost < dist[next][v]){\n          dist[next][v] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[next][v],v,next,s.num+1});\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    S--;\n    for(int i = 0 ; i < M ; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back((edge){b,c,L});\n      G[b].push_back((edge){a,c,L});\n    }\n    int n = N;\n    for(int i = 0 ; i < L ; i++){\n      int v,e;\n      cin >> v >> e; v--;\n      G[v].push_back((edge){n,e,i});\n      n++;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 500\n#define INF (1<<26)\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nstruct edge{int to,cost;};\nvector<edge> G[MAX];\nvector<int> K;\nint d[MAX];\nint D[MAX][MAX];\nint J[MAX],E[MAX];\nint n,m,l,s,t;\n\nvoid dijkstra(int si){\n  fill(d,d+MAX,INF);\n  d[K[si]]=0;\n  priority_queue< P,vector<P>,greater<P> > Q;\n  Q.push(P(0,K[si]));\n  while(!Q.empty()){\n    P p=Q.top();Q.pop();\n    int cost=p.first,pos=p.second;\n    if(cost>d[pos])continue;\n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      if(cost+e.cost<d[e.to]){\n        d[e.to]=cost+e.cost;\n        Q.push(P(d[e.to],e.to));\n      }\n    }\n  }\n  for(int i=0;i<=l;i++)\n    D[si][i]=d[K[i]];\n}\n\nint dist[17][(1<<16)];\nint solve(){\n  int ans=0;\n  fill(dist[0],dist[17],INF);\n  priority_queue< PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(l,0)));\n  dist[l][0]=0;\n  while(!Q.empty()){\n    PP pp=Q.top();Q.pop();\n    P p=pp.second;\n    int cost=pp.first,pos=p.first,bit=p.second;\n    if(cost<=t&&pos==l)\n      ans=max(ans, __builtin_popcount(bit));\n    for(int i=0;i<=l;i++){\n      int nbit=bit;\n      int ncost=cost+D[pos][i];\n      if(i<l)nbit|=(1<<i),ncost+=E[i];\n      if(ncost<dist[i][nbit]){\n        dist[i][nbit]=ncost;\n        Q.push(PP(ncost,P(i,nbit))); \n      }\n    }\n  }\n  return ans;\n}\n\nvoid init(){\n  K.clear();\n  for(int i=0;i<MAX;i++)G[i].clear();\n}\n\nint main(){\n  int a,b,c;\n  while(1){\n    cin>>n>>m>>l>>s>>t;\n    if(n==0&&m==0&&l==0&&s==0&&t==0)break;\n    s--;\n    init();\n    for(int i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--,b--;\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<l;i++){\n      scanf(\"%d %d\",&J[i],&E[i]);\n      J[i]--;\n      K.push_back(J[i]);\n    }\n    K.push_back(s);\n    for(int i=0;i<=l;i++)dijkstra(i);\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,l,s,t,d[301][301],x[20],tim[20],dl[20][20],dp[1<<16][16],a,b,c;\nint main(){\n  while(cin>>n>>m>>l>>s>>t,n){\n    r(i,(1<<l))r(j,16)dp[i][j]=1e8;\n    int ans=0,p=0;s--;\n    r(i,n)r(j,n)d[i][j]=1e8;\n    r(i,m){\n      cin>>a>>b>>c;\n      d[--a][--b]=d[b][a]=c;\n    }\n    r(i,l)cin>>x[i]>>tim[i],x[i]--;\n    r(k,n)r(i,n)r(j,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    r(i,l)r(j,l)dl[i][j]=d[x[i]][x[j]]+tim[j];\n    r(i,l)dp[(1<<i)][i]=d[s][x[i]]+tim[i];\n    r(i,(1<<l))r(j,l)if((1<<j)&i)r(k,l)if(j!=k&&dl[j][k]&&((1<<k)&i)==0)\n      if(dl[j][k]+dp[i][j]<=t)dp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+dl[j][k]);\n    r(i,(1<<l))r(j,l)if(dp[i][j]+d[x[j]][s]<=t)ans=max(ans,__builtin_popcount(i));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\n\nint edges[301][301];\nint ramen_time[20];\nint dp[301][1<<16];\n\nint main(){\n  int num_of_stations;\n  int num_of_pairs;\n  int num_of_SIRO;\n  int starting_point;\n  int time_limit;\n  while(~scanf(\"%d %d %d %d %d\",\n               &num_of_stations,\n               &num_of_pairs,\n               &num_of_SIRO,\n               &starting_point,\n               &time_limit)){\n    if(num_of_stations == 0\n       && num_of_pairs == 0\n       && num_of_SIRO == 0\n       && starting_point == 0\n       && time_limit == 0) break;\n\n    memset(edges,0x3f,sizeof(edges));\n    starting_point--;\n\n    vector<int> candidates[301];\n    for(int i = 0; i < num_of_pairs; i++){\n      int from,to;\n      int time;\n      scanf(\"%d %d %d\",&from,&to,&time);\n      from--;\n      to--;\n      edges[from][to] = time;\n      edges[to][from] = time;\n      candidates[from].push_back(to);\n      candidates[to].push_back(from);\n    }\n\n    for(int mid = 0; mid < num_of_stations; mid++){\n      for(int from = 0; from < num_of_stations; from++){\n        for(int to = 0; to < num_of_stations; to++){\n          edges[from][to] = min(edges[from][to],edges[from][mid] + edges[mid][to]);\n        }\n      }\n    }\n\n    int SIRO_idx[301];\n    memset(SIRO_idx,-1,sizeof(SIRO_idx));\n    memset(ramen_time,0x3f,sizeof(ramen_time));\n    vector<int> SIROs;\n    SIROs.push_back(starting_point);\n    for(int i = 0; i < num_of_SIRO; i++){\n      int station,time;\n      scanf(\"%d %d\",&station,&time);\n      station--;\n      ramen_time[i] = time;\n      SIRO_idx[station] = i;\n      SIROs.push_back(station);\n    }\n\n    memset(dp,0x3f,sizeof(dp));\n    dp[starting_point][0] = 0;\n\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      for(int from_idx = 0; from_idx < SIROs.size(); from_idx++){\n        int from = SIROs[from_idx];\n        if(SIRO_idx[from] != -1){\n          dp[from][S | (1<<SIRO_idx[from])]\n            = min(dp[from][S | (1<<SIRO_idx[from])],\n                  dp[from][S] + ramen_time[SIRO_idx[from]]);\n        }\n\n        for(int to_idx = 0; to_idx < SIROs.size(); to_idx++){\n          int to = SIROs[to_idx];\n          if(from == to) continue;\n\n          if(SIRO_idx[to] == -1){\n            dp[to][S] = min(dp[from][S] + edges[from][to],dp[to][S]);\n          }\n          else{\n            dp[to][S | (1 << SIRO_idx[to])]\n              = min(dp[to][S | (1 << SIRO_idx[to])]\n                    ,dp[from][S] + edges[from][to] + ramen_time[SIRO_idx[to]]);\n            dp[to][S]\n              = min(dp[to][S],dp[from][S] + edges[from][to]);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      if(time_limit >= dp[starting_point][S]){\n        res = max(res,__builtin_popcount(S));\n      }\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8 + 5;\nconst int MAX_V = 500;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint main(){\n\tint n, m, l, s, t;\n\twhile(cin >> n >> m >> l >> s >> t, n){\n\t\ts--;\n\n\t\tint g[MAX_V][MAX_V];\n\t\tinit(g);\n\t\trep(i,m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\twarshallFloyd(g, n);\n\n\t\tvector<pair<int, int>> r(l);\n\t\trep(i,l){\n\t\t\tcin >> r[i].first >> r[i].second;\n\t\t\tr[i].first--;\n\t\t}\n\n\t\t//rep(i,n){ rep(j,n){ cout << g[i][j] << ' '; } cout << endl; }\n\n\t\tvector<vector<int>> dp(1 << l, vector<int>(l, INF));\n\t\trep(i,l){\n\t\t\tdp[0][i] = g[s][r[i].first];\n\t\t\t//dp[1 << l][l] = g[s][r[i].first] + r[i].second;\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\t\t//cout << endl;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tdp[setBit(b, i)][i] = min(dp[setBit(b, i)][i], dp[b][i] + r[i].second);\n\t\t\t\trep(j,l){\n\t\t\t\t\tdp[b][j] = min(dp[b][j], dp[b][i] + g[r[i].first][r[j].first]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\n\t\tint ans = 0;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tif(dp[b][i] + g[r[i].first][s] <= t) ans = max<int>(ans, bitset<20>(b).count());\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\ninline void update(int& x, int y){\n    if(x > y) x = y;\n}\n\nint main(){\n    int n, m, l, s, t;\n    while(cin >> n >> m >> l >> s >> t && n > 0){\n        s--;\n        int dist[300][300];\n        REP(i, n) REP(j, n) dist[i][j] = (i == j ? 0 : INF);\n\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            dist[a][b] = dist[b][a] = c;\n        }\n\n        REP(k, n) REP(i, n) REP(j, n) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        vector<int> p(l);\n        vector<int> c(l);\n        REP(i, l) cin >> p[i] >> c[i];\n        REP(i, l) p[i]--;\n\n        int dp[1 << 16][16] = {};\n        REP(S, 1 << l) REP(i, l) dp[S][i] = INF;\n        REP(i, l) dp[1 << i][i] = c[i] + dist[s][p[i]];\n\n        REP(S, 1 << l) REP(i, l) if(S >> i & 1) {\n            REP(j, l) if(!(S >> j & 1)) {\n                update(dp[S | (1 << j)][j], dp[S][i] + dist[p[i]][p[j]] + c[j]);\n            }\n        }\n\n        int ans = 0;\n        REP(S, 1 << l) REP(i, l) {\n            if(dp[S][i] + dist[p[i]][s] <= t){\n                ans = max(ans, __builtin_popcount(S));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 1E.cpp\n *\n *  Created on: Aug 22, 2015\n *      Author: Zhao Huangjie\n */\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\nusing namespace std;\nint n,m,l,s,t;\nvector<vector<int> > map,dp;\nvector<int> r,e;\n\nint tsp(int pos,int mask){\n\tif(dp[pos][mask]!=1000000000){\n\t\treturn dp[pos][mask];\n\t}\n\tif(mask==((1<<(l+1))-1)){\n\t\treturn dp[pos][mask]=map[r[0]][r[pos]];\n\t}\n\tfor(int i=0;i<=l;i++){\n\t\tif(i!=pos&&((mask&(1<<i))==0)){\n\t\t\tdp[pos][mask]=min(dp[pos][mask],e[i]+map[r[pos]][r[i]]+tsp(i,mask|(1<<i)));\n\t\t}\n\t}\n\treturn dp[pos][mask];\n}\n\nint main(){\n\twhile(cin>>n>>m>>l>>s>>t&&(!(n==0&&m==0&&l==0&&s==0&&t==0))){\n\t\tmap.assign(n+10,vector<int>(n+10,1000000000));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tmap[x][y]=map[y][x]=z;\n\t\t}\n\t\tr.assign(l+1,0);\n\t\te.assign(l+1,0);\n\t\tr[0]=s;\n\t\te[0]=0;\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tcin>>r[i]>>e[i];\n\t\t}\n\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tmap[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tmap[i][i]=0;\n\t\t}\n\t\tdp.assign(n+1,vector<int>((1<<(l+1))+1,1000000000));\n\t\ttsp(0,1);\n\t\tint ans=0;\n\t\tfor(int i=0;i<n+1;i++){\n\t\t\tfor(int j=0;j<((1<<(l+1))+1);j++){\n\t\t\t\tif(dp[i][j]+map[r[i]][r[0]]<=t){\n\t\t\t\t\tint count=0;\n\t\t\t\t\tfor(int i=0;i<=l;i++){\n\t\t\t\t\t\tif((j&(1<<i))>0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans-1<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<typename T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\ntemplate<class T> T EPS(){assert(false);};\ntemplate<> int EPS<int>(){return 1;};\ntemplate<> ll EPS<ll>(){return 1LL;};\ntemplate<> double EPS<double>(){return 1e-8;};\ntemplate<> long double EPS<long double>(){return 1e-8;};\n\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntypedef int Cost; Cost CINF=1<<28;\nstruct Edge{\n\tint f,t;Cost c;\n\tEdge(int f,int t,Cost c) : f(f),t(t),c(c) {};\n\tbool operator<(Edge r) const{return c<r.c;}\n\tbool operator>(Edge r) const{return c>r.c;}\n};\ntypedef vector<vector<Edge> >  Graph;\n\nstruct Task{\n    int prev,pos;Cost c;\n    Task(int prev,int pos,Cost c)\n        :prev(prev),pos(pos),c(c){};\n    bool operator>(const Task& r) const{ return c > r.c;}\n};\nvector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n    const int V=g.size();\n    vector<Cost> d(V,CINF);d[s]=0;\n    fill(ALL(prev), -2);\n    \n    priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(-1,s,0));// [ ,e,,f, ] <=> e.cost < e.cost\n    vector<bool> visited(V);\n    while(!que.empty()){\n        Task task=que.top();que.pop();\n        if(visited[task.pos])continue;\n        visited[task.pos]=true;\n        prev[task.pos]=task.prev;\n        EACH(e,g[task.pos])if(d[e->t]>d[e->f]+e->c){\n            d[e->t]=d[e->f]+e->c;\n            que.push(Task(e->f,e->t,d[e->t]));\n        }   \n    }\n    return d;\n}\nvector<Cost> dijkstra(const Graph& g,const int s){\n    vector<int> prev(g.size());return dijkstra(g,s,prev);\n}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint n,m,l,s,t;cin >> n >> m >> l >> s >> t;if(n==0)break;\n\t\t\ts--;\n\t\t\tvector<vector<int>> g(n,vector<int>(n,INF<int>()));\n\t\t\tREP(i,n)g[i][i]=0;\n\t\t\tREP(i,m){\n\t\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\t\tg[a][b]=g[b][a]=c;\n\t\t\t}\n\t\t\tREP(k,n)REP(i,n)REP(j,n)\n\t\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\n\t\t\tjs.clear();\n\t\t\tREP(i,l){\n\t\t\t\tint v,e;cin >> v >> e;v--;\n\t\t\t\tjs[v]=e;\n\t\t\t}\n\t\t\tenc.clear();EACH(it,js)enc[it->first]=0;enc[s]=0;\n\t\t\tN=0;EACH(it,enc)enc[it->first]=N++;\n\t\t\tdec.clear();EACH(it,enc)dec[it->second]=it->first;\n\n\t\t\tds = vector<vector<int>>(N,vector<int>(N));\n\t\t\tEACH(i,dec)EACH(j,dec)\n\t\t\t\tds[i->first][j->first]=g[i->second][j->second];\n\t\t\t\t\n\n\t\t\tdp =vector<vector<int>>(N,vector<int>(1<<N,INF<int>()));\n\t\t\tdp[enc[s]][0]=0;\n\t\t\tREP(i,N)REP(bit,1<<N)rec(i,bit);\n\n\t\t\tint Mv=0;\n\t\t\tREP(i,N)REP(bit,1<<N)if(dp[i][bit]+ds[i][enc[s]]<=t){\n\t\t\t\tint bc=0;REP(k,N)if(bit&(1<<k))bc++;\n\t\t\t\tMv=max(Mv,bc);\n\t\t\t}\n\t\t\tcout << Mv <<endl;\n\t\t}\n\t}\n\t\n\tmap<int,int> js;\n\tmap<int,int> enc;\n\tmap<int,int> dec;\n\tvector<vector<int>> dp;\n\tvector<vector<int>> ds;\n\tint N;\n\tint rec(int i,int bit){\n\t\tif(dp[i][bit]!=INF<int>())return dp[i][bit];\n\t\tdp[i][bit]=INF<int>()-1;\n\t\tif(((bit>>i)&1) && js.count(dec[i])){\n\t\t\tREP(j,N)dp[i][bit]=min(dp[i][bit],rec(j,bit-(1<<i))+ds[j][i]+js[dec[i]]);\n\t\t}\n\t\treturn dp[i][bit];\n\t}\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nint dp[1<<16][16];\n\nint main(){\n  for(int n,m,l,s,t;cin>>n>>m>>l>>s>>t,n|m|l|s|t;){\n    int d[323][323];\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=(i==j)?0:1e9;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      d[a][b]=d[b][a]=c;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tfor(int k=0;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int js[323],e[323];\n    for(int i=0;i<l;i++){\n      cin>>js[i]>>e[i];\n    }\n    fill(*begin(dp),*end(dp),1e9);\n    for(int i=0;i<l;i++){\n      dp[1<<i][i]=d[s][js[i]]+e[i];\n    }\n    int ans=0;\n    for(int i=0;i<1<<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i>>j&1){\n\t  for(int k=0;k<l;k++){\n\t    if(j!=k&&i>>k&1){\n\t      dp[i][j]=min(dp[i][j],dp[i^1<<j][k]+d[js[k]][js[j]]+e[j]);\n\t    }\n\t  }\n\t  if(dp[i][j]<=t-d[s][js[j]]){\n\t    ans=max(ans,__builtin_popcount(i));\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\n\nint edges[301][301];\nint ramen_time[20];\nint dp[301][1<<16];\n\nint main(){\n  int num_of_stations;\n  int num_of_pairs;\n  int num_of_SIRO;\n  int starting_point;\n  int time_limit;\n  while(~scanf(\"%d %d %d %d %d\",\n               &num_of_stations,\n               &num_of_pairs,\n               &num_of_SIRO,\n               &starting_point,\n               &time_limit)){\n    if(num_of_stations == 0\n       && num_of_pairs == 0\n       && num_of_SIRO == 0\n       && starting_point == 0\n       && time_limit == 0) break;\n\n    memset(edges,0x3f,sizeof(edges));\n    starting_point--;\n\n    vector<int> candidates[301];\n    for(int i = 0; i < num_of_pairs; i++){\n      int from,to;\n      int time;\n      scanf(\"%d %d %d\",&from,&to,&time);\n      from--;\n      to--;\n      edges[from][to] = time;\n      edges[to][from] = time;\n      candidates[from].push_back(to);\n      candidates[to].push_back(from);\n    }\n\n    for(int mid = 0; mid < num_of_stations; mid++){\n      for(int from = 0; from < num_of_stations; from++){\n        for(int i = 0; i < candidates[from].size(); i++){\n          int to = candidates[from][i];\n          edges[from][to] = min(edges[from][to],edges[from][mid] + edges[mid][to]);\n        }\n      }\n    }\n\n    int SIRO_idx[301];\n    memset(SIRO_idx,-1,sizeof(SIRO_idx));\n    memset(ramen_time,0x3f,sizeof(ramen_time));\n    vector<int> SIROs;\n    SIROs.push_back(starting_point);\n    for(int i = 0; i < num_of_SIRO; i++){\n      int station,time;\n      scanf(\"%d %d\",&station,&time);\n      station--;\n      ramen_time[i] = time;\n      SIRO_idx[station] = i;\n      SIROs.push_back(station);\n    }\n\n    memset(dp,0x3f,sizeof(dp));\n    dp[starting_point][0] = 0;\n\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      for(int from_idx = 0; from_idx < SIROs.size(); from_idx++){\n        int from = SIROs[from_idx];\n        if(SIRO_idx[from] != -1){\n          dp[from][S | (1<<SIRO_idx[from])]\n            = min(dp[from][S | (1<<SIRO_idx[from])],\n                  dp[from][S] + ramen_time[SIRO_idx[from]]);\n        }\n\n        for(int i = 0; i < candidates[from].size(); i++){\n          int to = candidates[from][i];\n          if(from == to) continue;\n\n          if(SIRO_idx[to] == -1){\n            dp[to][S] = min(dp[from][S] + edges[from][to],dp[to][S]);\n          }\n          else{\n            dp[to][S | (1 << SIRO_idx[to])]\n              = min(dp[to][S | (1 << SIRO_idx[to])]\n                    ,dp[from][S] + edges[from][to] + ramen_time[SIRO_idx[to]]);\n            dp[to][S]\n              = min(dp[to][S],dp[from][S] + edges[from][to]);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      if(time_limit >= dp[starting_point][S]){\n        res = max(res,__builtin_popcount(S));\n      }\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\n\nint main()\n{\n  int N, M, L, S, T;\n  int64 g[300][300];\n  int x[16], y[16];\n  int64 dp[1 << 16][16];\n\n  while(scanf(\"%d %d %d %d %d\", &N, &M, &L, &S, &T), N) {\n\n    --S;\n    fill_n(*g, 300 * 300, INF);\n    for(int i = 0; i < 300; i++) g[i][i] = 0;\n    fill_n(*dp, (1 << 16), INF);\n\n    for(int i = 0; i < M; i++) {\n      int A, B, C;\n      scanf(\"%d %d %d\", &A, &B, &C);\n      --A, --B;\n      g[A][B] = g[B][A] = C;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &x[i], &y[i]);\n      --x[i];\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    for(int i = 0; i < L; i++) {\n      dp[1 << i][i] = g[S][x[i]] + y[i];\n    }\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < L; k++) {\n          if((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + g[x[j]][x[k]] + y[k]);\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] + g[x[j]][S] <= T) {\n          ret = max(ret, __builtin_popcount(i));\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,m,l,s,t,jj[16],e[16],INF=1e+9;\nint G[300][300],paths[17][17],dp[1<<17][17];\nint main(){\n\twhile(true){\n\t\tfor(int i=0;i<300;i++){\n\t\t\tfor(int j=0;j<300;j++){\n\t\t\t\tG[i][j]=INF;\n\t\t\t\tif(i==j) G[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m >> l >> s >> t;\n\t\ts--;\n\t\tif(!n) break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tG[a][b]=c;G[b][a]=c;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tG[j][k]=min(G[j][k],G[j][i]+G[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tcin >> jj[i] >> e[i];\n\t\t\tjj[i]--;\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\tpaths[i+1][j+1]=G[jj[i]][jj[j]]+e[j];\n\t\t\t\tif(i==j) paths[i+1][j+1]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<l;i++){\n\t\t\tpaths[0][i+1]=G[s][jj[i]]+e[i];\n\t\t\tpaths[i+1][0]=G[s][jj[i]];\n\t\t}\n\t\tpaths[0][0]=0;\n\t\tfor(int i=0;i<(1<<17);i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tdp[1][0]=0;\n\t\tfor(int i=0;i<(1<<(l+1));i++){\n\t\t\tfor(int j=0;j<l+1;j++){\n\t\t\t\tif((i&(1<<j))==0) continue;\n\t\t\t\tfor(int k=0;k<l+1;k++){\n\t\t\t\t\tif((i&(1<<k))==0) continue;\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-(1<<j)][k]+paths[k][j]);\n\t\t\t\t}\n//\t\t\t\tcout <<\"       \"<< i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\tif(dp[i][j]+paths[j][0]>t) continue;\n\t\t\t\telse{\n\t\t\t\t\tint tmp=i,hoge=-1;\n\t\t\t\t\twhile(tmp>0){\n\t\t\t\t\t\thoge+=(tmp%2);\n\t\t\t\t\t\ttmp/=2;\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,hoge);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <climits>\n#include <numeric>\n#include <cstring>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > vvint;\n\n#define ALL(v) (v).begin(),(v).end()\n\n#define MOD 1000000007LL\n#define INF 1010101010\n\n\nint main(){\n\tint bits[1 << 16];\n\tfor(int S = 1 << 16; S--; ){\n\t\tbits[S] = bitset<32>(S).count();\n\t}\n\n\tint n, m, rnum, s, t, a, b, c;\n\twhile(scanf(\"%d%d%d%d%d\", &n, &m, &rnum, &s, &t), n){\n\t\tvector<vector<int> > Gorig(n + 1, vector<int>(n + 1, INF));\n\t\tfor(int i = 0; i <= n; ++i){\n\t\t\tGorig[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tGorig[a][b] = Gorig[b][a] = c;\n\t\t}\n\t\tfor(int k = 1; k <= n; ++k)\n\t\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tGorig[i][j] = min(Gorig[i][j], Gorig[i][k] + Gorig[k][j]);\n\t\t}\n\t\t\n\t\tvector<pii> rs(rnum);\n\t\tfor(int i = 0; i < rnum; ++i){\n\t\t\tscanf(\"%d%d\", &rs[i].first, &rs[i].second);\n\t\t}\n\t\tsort(ALL(rs));\n\t\t\n\t\tvector<vector<int> > G(rnum, vector<int>(rnum));\n\t\tfor(int i = 0; i < rnum; ++i)\n\t\tfor(int j = 0; j < rnum; ++j){\n\t\t\tG[i][j] = Gorig[rs[i].first][rs[j].first];\n\t\t}\n\n\t\tvvint dp(rnum, vector<int>(1 << rnum, INF));\n\t\tfor(int i = 0; i < rnum; ++i){\n\t\t\tdp[i][1 << i] = Gorig[s][rs[i].first] + rs[i].second;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int S = 1; S < (1 << rnum); ++S){\n\t\t\tfor(int i = 0; i < rnum; ++i){\n\t\t\t\tif(dp[i][S] == INF){ continue; }\n\t\t\t\tint tret = dp[i][S] + Gorig[rs[i].first][s];\n\t\t\t\tif(tret <= t){\n\t\t\t\t\tans = max(ans, bits[S]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < rnum; ++j){\n\t\t\t\t\tif(S >> j & 1){ continue; }\n\t\t\t\t\tint T = S | 1 << j;\n\t\t\t\t\tdp[j][T] = min(dp[j][T], dp[i][S] + G[i][j] + rs[j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 26;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 301;\nconst int L = 17;\nint dist[N][N];\nint min_cost[L][1 << L];\n\nusing Elem = tuple<int, int, int>;\n\nint main(void){\n    for(int n, m, l, sv, t; cin >> n >> m >> l >> sv >> t, n;){\n        sv--;\n        l++;\n\n        rep(i, n) rep(j, n) dist[i][j] = inf;\n        rep(i, n) dist[i][i] = 0;\n        rep(loop, m){\n            int a, b, c; cin >> a >> b >> c;\n            a--, b--;\n            dist[a][b] = dist[b][a] = c;\n        }\n\n        vi jiro(n, -1);\n        vi j2v(l);\n        j2v[0] = sv; jiro[sv] = 0;\n        vi eat_time(l);\n        rep(i, 1, l){\n            int v, e; cin >> v >> e;\n            v--;\n            jiro[v] = i;\n            j2v[i] = v;\n            eat_time[i] = e;\n        }\n\n        rep(k, n) rep(i, n) rep(j, n) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\n        rep(i, l) rep(j, 1 << l) min_cost[i][j] = inf;\n        priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n        q.push(Elem(0, 0, 1));\n\n        int res = 0;\n        while(q.size()){\n            int cost, ji, visited;\n            tie(cost, ji, visited) = q.top(); q.pop();\n            int v = j2v[ji];\n\n            if(not chmin(min_cost[ji][visited], cost)) continue;\n            chmax(res, __builtin_popcount(visited) - 1);\n\n            rep(nji, 1, l){\n                if(visited & (1 << nji)) continue;\n\n                int nv = j2v[nji];\n\n                int ncost = cost + dist[v][nv] + eat_time[nji];\n                if(ncost + dist[nv][sv] > t) continue;\n\n                int nvisited = (visited | (1 << nji));\n\n                if(min_cost[nji][nvisited] == inf){\n                    q.push(Elem(ncost, nji, nvisited));\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 1E.cpp\n *\n *  Created on: Aug 22, 2015\n *      Author: Zhao Huangjie\n */\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nint n,m,l,s,t;\nvector<vector<int> > map,dp;\nvector<int> r,e;\n\nint tsp(int pos,int mask){\n\tif(dp[pos][mask]!=1000000000){\n\t\treturn dp[pos][mask];\n\t}\n\tif(mask==((1<<(l+1))-1)){\n\t\treturn dp[pos][mask]=e[pos]+map[r[0]][r[pos]];\n\t}\n\tfor(int i=0;i<=l;i++){\n\t\tif((i!=pos&&(mask&(1<<i))==0)){\n\t\t\tdp[pos][mask]=min(dp[pos][mask],e[pos]+map[r[pos]][r[i]]+tsp(i,mask|(1<<i)));\n\t\t}\n\t}\n\n\treturn dp[pos][mask];\n}\n\nint main(){\n\twhile(cin>>n>>m>>l>>s>>t&&(!(n==0&&m==0&&l==0&&s==0&&t==0))){\n\t\tmap.assign(n+10,vector<int>(n+10,1000000000));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tmap[x][y]=map[y][x]=z;\n\t\t}\n\t\tr.assign(l+1,0);\n\t\te.assign(l+1,0);\n\t\tr[0]=s;\n\t\te[0]=0;\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tcin>>r[i]>>e[i];\n\t\t}\n\n\t\t/*for(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tmap[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tfor(int i=0;i<=l;i++){\n\t\t\tint ss = r[i];\n\t\t\tvector<int> dis(n+1,1000000000);;\n\t\t\tdis[ss]=0;\n\t\t\tpriority_queue<ii ,vector<ii>,greater<ii> > pq;\n\t\t\tpq.push(ii(0,ss));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tii front=pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tint d=front.first;\n\t\t\t\tint u=front.second;\n\t\t\t\tif(d>dis[u]) continue;\n\t\t\t\tfor(int v=1;v<=n;v++){\n\t\t\t\t\tif(map[u][v]<1000000000){\n\t\t\t\t\t\tif(dis[u]+map[u][v]<dis[v]){\n\t\t\t\t\t\t\tdis[v]=dis[u]+map[u][v];\n\t\t\t\t\t\t\tpq.push(ii(dis[v],v));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j!=ss){\n\t\t\t\t\tmap[j][ss]=map[ss][j]=dis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<=n;i++){\n\t\t\tmap[i][i]=0;\n\t\t}*/\n\t\tdp.assign(l+10,vector<int>((1<<(l+1))+10,1000000000));\n\t\tint ans=0;\n\t\ttsp(0,1);\n\t\tfor(int i=0;i<=l;i++){\n\t\t\tfor(int j=0;j<(1<<(l+1));j++){\n\t\t\t\tif(dp[i][j]<=1000000000&&dp[i][j]+map[r[i]][s]<=t){\n\t\t\t\t\tint count=0;\n\t\t\t\t\tfor(int k=1;k<=l;k++){\n\t\t\t\t\t\tif((j&(1<<k))==0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,count+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong() / 2] && nexttime <= T) {\n\t\t\t\t\t\tif (nextplace == 0) {\n\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = nexttime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\n\nconst ll INF = 1LL << 60;\n\nvoid chmin(ll &a, ll b) {\n  a = min(a, b);\n}\n\nint main() {\n  int N, M, L, S, T;\n  while(1) {\n    scanf(\"%d%d%d%d%d\", &N, &M, &L, &S, &T);\n    if(N == 0) break;\n    \n    S--;\n    vector<ll> siro(L), time(L);\n    vector< vector<ll> > dist(N, vector<ll>(N, INF)), dp(1<<L, vector<ll>(L, INF));\n\n    for(int i=0; i<N; i++) {\n      dist[i][i] = 0;\n    }\n\n    for(int i=0; i<M; i++) {\n      int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n      a--; b--;\n      chmin(dist[a][b], c);\n      chmin(dist[b][a], c);\n    }\n    for(int i=0; i<L; i++) {\n      scanf(\"%lld%lld\", &siro[i], &time[i]);\n      siro[i]--;\n    }\n\n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    dp[0][0] = 0;\n    for(int bit=0; bit<(1<<L); bit++) {\n      for(int k=0; k<L; k++) {\n        for(int i=0; i<L; i++) {\n          if(bit >> i & 1) continue;\n\n          int nbit = bit | (1 << i);\n          \n          int u = (bit == 0 ? S : siro[k]);\n          int v = siro[i];\n          ll cost = dist[u][v] + time[i];\n\n          // printf(\"u = %d, v = %d, cost = %lld\\n\", u+1, v+1, cost);\n          chmin(dp[nbit][i], dp[bit][k] + cost);\n        }\n      }\n    }\n\n    ll ans = 0;\n    for(int bit=0; bit<(1<<L); bit++) {\n      for(int k=0; k<L; k++) {\n        ll cost = dp[bit][k] + dist[ siro[k] ][S];\n        // printf(\"bit = %d, k = %d, cost = %lld\\n\", bit, k, cost);\n        if(cost > T) continue;\n        ans = max(ans, (ll)__builtin_popcount(bit));\n      }\n    }\n\n    printf(\"%lld\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 1E.cpp\n *\n *  Created on: Aug 22, 2015\n *      Author: Zhao Huangjie\n */\n\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nint n,m,l,s,t;\nvector<vector<int> > map,dp,adj;\nvector<int> r,e;\n\nint ans=0;\n\nint tsp(int pos,int mask){\n\tif(dp[pos][mask]!=1000000000){\n\t\treturn dp[pos][mask];\n\t}\n\tif(mask==((1<<(l+1))-1)){\n\n\t\tdp[pos][mask]=e[pos]+map[r[0]][r[pos]];\n\t\tif(dp[pos][mask]+map[s][r[pos]]<=t){\n\t\t\tint count=0;\n\t\t\tfor(int i=1;i<=l;i++){\n\t\t\t\tif((mask&(1<<i))==0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=max(ans,count+1);\n\t\t}\n\t\treturn dp[pos][mask];\n\t}\n\tfor(int i=0;i<=l;i++){\n\t\tif((i!=pos&&(mask&(1<<i))==0)){\n\t\t\tdp[pos][mask]=min(dp[pos][mask],e[pos]+map[r[pos]][r[i]]+tsp(i,mask|(1<<i)));\n\t\t}\n\t}\n\tif(dp[pos][mask]+map[s][r[pos]]<=t){\n\t\tint count=0;\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tif((mask&(1<<i))==0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tans=max(ans,count+1);\n\t}\n\treturn dp[pos][mask];\n}\n\nint main(){\n\twhile(cin>>n>>m>>l>>s>>t&&(!(n==0&&m==0&&l==0&&s==0&&t==0))){\n\t\tmap.assign(n+10,vector<int>(n+10,1000000000));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,z;\n\t\t\tcin>>x>>y>>z;\n\t\t\tmap[x][y]=map[y][x]=z;\n\t\t}\n\t\tadj.assign(n+1,vector<int>(0,0));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(map[i][j]<1000000000){\n\t\t\t\t\tadj[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr.assign(l+1,0);\n\t\te.assign(l+1,0);\n\t\tr[0]=s;\n\t\te[0]=0;\n\t\tfor(int i=1;i<=l;i++){\n\t\t\tcin>>r[i]>>e[i];\n\t\t}\n\n\t\t/*for(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tmap[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tfor(int i=0;i<=l;i++){\n\t\t\tint ss = r[i];\n\t\t\tvector<int> dis(n+1,1000000000);;\n\t\t\tdis[ss]=0;\n\t\t\tpriority_queue<ii ,vector<ii>,greater<ii> > pq;\n\t\t\tpq.push(ii(0,ss));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tii front=pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tint d=front.first;\n\t\t\t\tint u=front.second;\n\t\t\t\tif(d>dis[u]) continue;\n\t\t\t\tfor(int j=0;j<(int)adj[u].size();j++){\n\t\t\t\t\tint v=adj[u][j];\n\t\t\t\t\tif(dis[u]+map[u][v]<dis[v]){\n\t\t\t\t\t\tdis[v]=dis[u]+map[u][v];\n\t\t\t\t\t\tpq.push(ii(dis[v],v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j!=ss){\n\t\t\t\t\tmap[j][ss]=map[ss][j]=dis[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp.assign(l+10,vector<int>((1<<(l+1))+10,1000000000));\n\t\tans=0;\n\t\ttsp(0,1);\n\t\t/*for(int i=1;i<=l;i++){\n\t\t\tfor(int j=1;j<(1<<(l+1));j+=2){\n\t\t\t\tif(dp[i][j]<=1000000000&&dp[i][j]+map[r[i]][s]<=t){\n\t\t\t\t\tint count=0;\n\t\t\t\t\tfor(int k=1;k<=l;k++){\n\t\t\t\t\t\tif((j&(1<<k))==0){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,count+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2567.cc: SIRO Challenge\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300;\nconst int MAX_L = 16;\nconst int LBITS = 1 << MAX_L;\n\nconst int INF = 1 << 29;\n\n/* typedef */\n\n/* global variables */\n\nint cs[MAX_N][MAX_N], ds[MAX_L + 1][MAX_L + 1];\nint js[MAX_L + 1], es[MAX_L + 1];\nint dp[LBITS][MAX_L], bnums[LBITS];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (int bits = 0; bits < LBITS; bits++) {\n    bnums[bits] = 0;\n    for (int i = 0, bi = 1; i < MAX_L; i++, bi <<= 1)\n      if (bits & bi) bnums[bits]++;\n  }\n\n  for (;;) {\n    int n, m, l, s, t;\n    cin >> n >> m >> l >> s >> t;\n    if (n == 0) break;\n    s--;\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) cs[i][j] = INF;\n      cs[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n      int ai, bi, ci;\n      cin >> ai >> bi >> ci;\n      ai--, bi--;\n      cs[ai][bi] = cs[bi][ai] = ci;\n    }\n\n    for (int i = 0; i < l; i++) {\n      cin >> js[i] >> es[i];\n      js[i]--;\n    }\n    js[l] = s;\n    es[l] = 0;\n\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n\tfor (int j = 0; j < n; j++) {\n\t  int d = cs[i][k] + cs[k][j];\n\t  if (cs[i][j] > d) cs[i][j] = d;\n\t}\n    \n    for (int i = 0; i <= l; i++)\n      for (int j = 0; j <= l; j++)\n\tds[i][j] = cs[js[i]][js[j]];\n\n    int lbits = 1 << l;\n    for (int bits = 0; bits < lbits; bits++)\n      for (int i = 0; i < l; i++) dp[bits][i] = INF;\n\n    int maxn = 0;\n\n    for (int i = 0; i < l; i++) {\n      int d = ds[l][i] + es[i];\n      if (d + ds[i][l] <= t) dp[1 << i][i] = d, maxn = 1;\n    }\n\n    for (int bits = 1; bits < lbits; bits++)\n      for (int i = 0; i < l; i++)\n\tif (dp[bits][i] < INF) {\n\t  for (int j = 0, bj = 1; j < l; j++, bj <<= 1) {\n\t    if (! (bits & bj)) {\n\t      int bitsj = bits | bj;\n\t      int d = dp[bits][i] + ds[i][j] + es[j];\n\t      if (d + ds[j][l] <= t && dp[bitsj][j] > d) {\n\t\tdp[bitsj][j] = d;\n\t\tint bn = bnums[bitsj];\n\t\tif (maxn < bn) maxn = bn;\n\t      }\n\t    }\n\t  }\n\t}\n\n    printf(\"%d\\n\", maxn);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[20][1 << 17];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 17); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][1] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t\n\t\t\tconst int nplace = atop.now;\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tconst int ntime(atop.time);\n\n\t\t\t\n\n\t\t\tque.pop();\n\t\t\tfor (auto j : edges[nplace]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = ntime + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (1 << 17); ++i) {\n\t\t\tif (memo[0][i] < 99999999) {\n\t\t\t\tbitset<17>bs(i);\n\t\t\t\tans = max(ans, int(bs.count()));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nofstream fout;\nfout.open(\"H:\\\\MAS\\\\test.txt\");\nwhile(n||m||l||s||t){\nv1.clear();\nmemset(dp,-1,sizeof(dp));\ng.assign(n+1,vector<int>(n+1,inf));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n\nint dp[(1<<17)][20];\n\nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n\tfor(int j=1; j<=n; j++) {\n\t  if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n\n    fill(dp[0],dp[(1<<l)],MAX);\n    dp[0][l-1]=0;\n    for(int i=0; i<l-1; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    \n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n\tif(dp[p][i]!=MAX) {\n\t  if(p&(1<<(l-1))) {\n\t    int cnt=0;\n\t    for(int j=0; j<l; j++) {\n\t      if(p&(1<<j)) cnt++;\n\t    }\n\t    if(cnt-1>ans) ans=cnt-1;\n\t  }\n\n\t  for(int j=0; j<l; j++) {\n\t    if(!(p&(1<<j))) {\n\t      dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n\t      if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    if(t-v1[xz].second<0) return 0;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\n#define INF 1e9\n\nstruct edge{\n  int to,cost,num;\n};\n\nstruct State{\n  int cost,v,S;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint N,M,L,S,T;\nvector<edge> G[MAX];\nint dist[1<<16][MAX];\n\nint dijkstra(){\n  priority_queue<State> Q;\n  Q.push((State){0,S,0});\n  int ans = 0;\n  for(int i = 0 ; i < (1<<16) ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      dist[i][j] = INF;\n    }\n  }\n  dist[0][S] = 0;\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v;\n    if(s.cost <= T && v == S){\n      ans = max(ans,__builtin_popcount(s.S));\n    }else if(s.cost > T){ continue; }\n    if(dist[s.S][v] < s.cost) continue;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(e.num == L){\n        if(dist[s.S][v] + e.cost < dist[s.S][e.to]){\n          dist[s.S][e.to] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[s.S][e.to],e.to,s.S});\n        }\n      }else{\n        if((s.S >> e.num) & 1) continue;\n        int next = s.S | (1<<e.num);\n        if(e.num != L && dist[s.S][v]+e.cost < dist[next][v]){\n          dist[next][v] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[next][v],v,next});\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    S--;\n    for(int i = 0 ; i < M ; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back((edge){b,c,L});\n      G[b].push_back((edge){a,c,L});\n    }\n    int n = N;\n    for(int i = 0 ; i < L ; i++){\n      int v,e;\n      cin >> v >> e; v--;\n      G[v].push_back((edge){n,e,i});\n      n++;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\n\nint main()\n{\n  int N, M, L, S, T;\n  int64 g[300][300];\n  int x[16], y[16];\n  int64 dp[1 << 16][16];\n\n  while(scanf(\"%d %d %d %d %d\", &N, &M, &L, &S, &T), N) {\n\n    fill_n(*g, 300 * 300, INF);\n    for(int i = 0; i < 300; i++) g[i][i] = 0;\n    fill_n(*dp, (1 << 16), INF);\n\n    for(int i = 0; i < M; i++) {\n      int A, B, C;\n      scanf(\"%d %d %d\", &A, &B, &C);\n      --A, --B;\n      g[A][B] = g[B][A] = C;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &x[i], &y[i]);\n      --x[i];\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    for(int i = 0; i < L; i++) {\n      dp[1 << i][i] = g[0][x[i]] + y[i];\n    }\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < L; k++) {\n          if((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + g[x[j]][x[k]] + y[k]);\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] + g[x[j]][0] < T) {\n          ret = max(ret, __builtin_popcount(i));\n        }\n      }\n    }\n\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n\n\nint wf[310][310];\nint dist[17][17];\nint dp[17][1<<17];\n\ntypedef vector<int> vint;\n\nint main(){\n\tint n,m,l,s,t;\n\twhile(cin>>n>>m>>l>>s>>t,n){\n\t\trep(i,n) rep(j,n) wf[i][j] = INF;\n\t\trep(i,n) wf[i][i] = 0;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--,b--;\n\t\t\twf[a][b] = wf[b][a] = c;\n\t\t}\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t}\n\t\tvint ramen(l+1);\n\t\tvint cost(l+1);\n\t\trep(i,l){\n\t\t\tcin>>ramen[i]>>cost[i];\n\t\t\tramen[i]--;\n\t\t}\n\t\ts--;\n\t\tramen[l] = s;\n\t\tcost[l] = 0;\n\t\trep(i,l+1){\n\t\trep(j,l+1){\n\t\t\t\tdist[i][j] = wf[ramen[i]][ramen[j]];\t\t\n\t\t\t}\n\t\t}\n\t\trep(i,l+1){\n\t\t\trep(j,1<<(l+1)){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[l][0] = 0;\n\t\trep(i,1<<(l+1)){\n\t\t\trep(j,l+1){\n\t\t\t\trep(k,l+1){\n\t\t\t\t\tint state = i|(1<<k);\n\t\t\t\t\tdp[k][state] = min(dp[k][state], dp[j][i]+dist[j][k]+cost[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\t\t\t\n\t\tint ans = 0;\n\t\trep(i,1<<(l+1)){\n\t\t\tif(dp[l][i] <= t){\n\t\t\t\tans = max(ans, (int)__builtin_popcount(i));\n\t\t\t}\n\t\t}\n\t\tcout<<ans-1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int from,to;\n    int cost;\n};\nconst int INF=1e8;\nusing Graph=vector<vector<Edge>>;\n\nvoid cmin(int &lhs,int rhs){lhs=min(lhs,rhs);}\nvector<int> Dijkstra(int s,const Graph& g){\n    int n=g.size();\n    vector<int> d(n,INF);\n    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> que;\n    d[s]=0;\n    que.push({0,s});\n    while(!que.empty()){\n        auto tmp=que.top(); que.pop();\n        int v=tmp.second;\n        if(d[v]<tmp.first) continue;\n        for(auto &e:g[v]){\n            if(d[v]+e.cost<d[e.to]){\n                d[e.to]=d[v]+e.cost;\n                que.push({d[e.to],e.to});\n            }\n        }\n    }\n    return d;\n}\nint solve(int n,int m,int l,int s,int t){\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--,b--;\n        g[a].push_back(Edge{a,b,c});\n        g[b].push_back(Edge{b,a,c});\n    }\n    vector<int> j(l);\n    vector<int> e(l);\n    for(int i=0;i<l;i++){\n        cin>>j[i]>>e[i];\n        j[i]--;\n    }\n    Graph ramenG(l+1);\n    auto insert=[&](int idx,int v){\n        auto d=Dijkstra(v,g);\n        if(v!=s) ramenG[idx].push_back({idx,0,d[s]});\n        for(int i=0;i<l;i++){\n            if(i+1!=idx) ramenG[idx].push_back(Edge{idx,i+1,d[j[i]]+e[i]});\n        }\n    };\n    insert(0,s);\n    for(int i=0;i<l;i++) insert(i+1,j[i]);\n    vector<vector<int>> dp(l+1,vector<int>(1<<(l+1),INF));\n    dp[0][0]=0;\n    for(int bit=0;bit<(1<<(l+1));bit++){\n        for(int i=0;i<l+1;i++){\n            for(auto &e:ramenG[i]){\n                int j=e.to;\n                cmin(dp[j][bit|(1<<j)],dp[i][bit]+e.cost);\n            }\n        }\n    }\n    int res=0;\n    for(int bit=0;bit<(1<<(l+1));bit++){\n        if(dp[0][bit]<=t) res=max(res,__builtin_popcount(bit)-1);\n    }\n    return res;\n}\nint main(){\n    int n,m,l,s,t;\n    while(cin>>n>>m>>l>>s>>t,n){\n        s--;\n        cout<<solve(n,m,l,s,t)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n, m, l, s, t;\nint graph[303][303];\nint sta[16], e[16];\n\nint dp[1<<16][16];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n >> m >> l >> s >> t, n) {\n    --s;\n    rep(i, 303) rep(j, 303) graph[i][j] = (i == j ? 0 : inf);\n    rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c; --a, --b;\n      graph[a][b] = graph[b][a] = c;\n    }\n    rep(i, n) rep(j, n) rep(k, n) {\n      chmin(graph[j][k], graph[j][i] + graph[i][k]);\n    }\n    rep(i, l)  {\n      cin >> sta[i] >> e[i]; --sta[i];\n    }\n    rep(i, 1<<16) rep(j, 16) dp[i][j] = inf;\n    rep(i, l) dp[1<<i][i] = graph[s][sta[i]] + e[i];\n    rep(i, 1<<l) rep(j, l) {\n      if(dp[i][j] == inf) continue;\n      rep(k, l) if(!((i>>k)&1)) {\n\tchmin(dp[i|(1<<k)][k], dp[i][j] + graph[sta[j]][sta[k]] + e[k]);\n      }\n    }\n    int ans = 0;\n    rep(i, 1<<l) rep(j, l) {\n      if(dp[i][j] != inf && dp[i][j] + graph[sta[j]][s] <= t) {\n\tchmax(ans, __builtin_popcount(i));\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\tif (!nbs[nextplace]|| nextplace == 0) {\n\t\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong() / 2] && nexttime <= T) {\n\t\t\t\t\t\tif (nextplace == 0) {\n\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = nexttime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint bitcount(int n){\n    n = (n & 0x55555555) + (n >> 1 & 0x55555555);\n    n = (n & 0x33333333) + (n >> 2 & 0x33333333);\n    n = (n & 0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);\n    n = (n & 0x00ff00ff) + (n >> 8 & 0x00ff00ff);\n    return (n & 0x0000ffff) + (n >>16 & 0x0000ffff);\n}\n\nint main(){\n    while(1){\n        int n,m,l,s,t;\n        cin >> n >> m >> l >> s >> t;\n        s--;\n        if(n==0) break;\n        \n        vector<vector<int> > adj(n, vector<int>(n, inf));\n        for(int i=0; i<m; i++){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--; b--;\n            adj[a][b] = adj[b][a] = c;\n        }\n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    adj[i][j] = min(adj[i][j], adj[i][k] +adj[k][j]);\n                }\n            }\n        }\n        \n        vector<int> pos(l), time(l);\n        for(int i=0; i<l; i++){\n            cin >> pos[i] >> time[i];\n            pos[i]--;\n        }\n        \n        vector<vector<int> > dp(l, vector<int>(1<<l, 0));\n        int ans = 0;\n        for(int i=0; i<l; i++){\n            int rem = t - (adj[s][pos[i]] +time[i]);\n            if(rem > 0){\n                 dp[i][1<<i] = rem;\n            }\n        }\n        for(int i=0; i<(1<<l); i++){\n            for(int j=0; j<l; j++){\n            \tint rest = dp[j][i];\n                if(rest <= 0) continue;\n                if(adj[s][pos[j]] <= rest){\n                \tans = max(ans, bitcount(i));\n                }\n                for(int k=0; k<l; k++){\n                \tif((i & 1<<k) == 0 && adj[pos[j]][pos[k]]+time[k] < rest){\n                \t\tdp[k][i|(1<<k)] = max(dp[k][i|(1<<k)], rest-(adj[pos[j]][pos[k]]+time[k]));\n                \t}\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n, m, l, s, t;\nint graph[303][303];\nint siro[303], sta[16], e[16];\n\nint dp[1<<16][16];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n >> m >> l >> s >> t, n) {\n    --s;\n    rep(i, 303) rep(j, 303) graph[i][j] = (i == j ? 0 : inf);\n    rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c; --a, --b;\n      graph[a][b] = graph[b][a] = c;\n    }\n    rep(i, n) rep(j, n) rep(k, n) {\n      chmin(graph[j][k], graph[j][i] + graph[i][k]);\n    }\n    memset(siro, -1, sizeof(siro));\n    rep(i, l) {\n      cin >> sta[i] >> e[i]; --sta[i];\n      siro[sta[i]] = i;\n    }\n    rep(i, 1<<16) rep(j, 16) dp[i][j] = inf;\n    rep(i, l) dp[1<<i][i] = graph[s][sta[i]] + e[i];\n    rep(i, 1<<l) rep(j, l) {\n      if(dp[i][j] == inf) continue;\n      rep(k, l) if(!(i>>k)&1) {\n\tchmin(dp[i|(1<<k)][k], dp[i][j] + graph[sta[j]][sta[k]] + e[k]);\n      }\n    }\n    int ans = 0;\n    rep(i, 1<<l) rep(j, l) {\n      if(dp[i][j] != inf && dp[i][j] + graph[sta[j]][s] <= t) {\n\tchmax(ans, __builtin_popcount(i));\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    bool hasSiro;\n    long timeToEat;\n    map<long, long> timeTo; // time[nextStation]\n};\nmap<long, Station> stations;\n\nlong s;\nlong maxNum;\n\nvoid trip(long i, long rest, map<long, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(it->first == i){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    long n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(long i = 0; i < m; ++i){\n            long a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(long i = 0; i < l; ++i){\n            long j,e;\n            cin >> j >> e;\n            stations[j].hasSiro = true;\n            stations[j].timeToEat = e;\n            stations[j].timeTo[j] = e;\n        }\n        for(auto target = stations.begin(); target != stations.end(); ){\n            if(target->second.hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            auto& nexts = target->second.timeTo;\n\n            for(auto next = nexts.begin(); next != nexts.end(); ++next){\n                auto& connects = stations.at(target->first).timeTo;\n                auto& nextStation = stations.at(next->first);\n                for(auto connect = connects.begin(); connect != connects.end(); ++connect){\n                    if(next->first == connect->first){\n                        continue;\n                    }\n                    auto& targetStation = stations.at(target->first);\n                    long time = nextStation.timeTo.at(target->first) + targetStation.timeTo.at(connect->first);\n                    auto hoge = nextStation.timeTo.find(connect->first);\n                    if(hoge == nextStation.timeTo.end()){\n                        nextStation.timeTo[connect->first] = time;\n                    }else if(hoge->second > time){\n                        hoge->second = time;\n                    }\n                }\n                nextStation.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        cout << \"new: \" << stations.size() << endl;\n        // map<long, bool> ate;\n        // trip(s, t, ate);\n        // cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<18][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse{\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=0;\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]=dp[i1][xz]+1;\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<29\nusing namespace std;\n\nint Station[301][301];\npair<int,int> p[20];\nint dp[20][1000001];\n\nint main()\n{\n  int n,m,l,s,t,a,b,c,x,y;\n\n  while(1){\n    cin>>n>>m>>l>>s>>t;\n    if(n+m+l+s+t==0)break;\n    s--;\n\n    for(int i=0;i<l+1;i++)for(int j=0;j<t+1;j++)dp[i][j]=0;\n    for(int i=0;i<301;i++){\n      for(int j=0;j<301;j++){\n\tif(i==j)Station[i][j]=0;\n\telse Station[i][j]=inf;\n      }\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      a--;b--;\n      Station[a][b]=c;\n      Station[b][a]=c;\n    }\n    p[0].f=s;p[0].s=0;\n    for(int i=1;i<l+1;i++){\n      cin>>p[i].f>>p[i].s;\n      p[i].f--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  Station[i][j]=min(Station[i][j],Station[i][k]+Station[k][j]);\n\t}\n      }\n    }\n\n    for(int i=1;i<l+1;i++){\n      for(int j=1;j<t+1;j++){\n\tfor(int k=0;k<i;k++){\n\t  int a=p[i].f,b=p[k].f;\n\t  if(Station[a][b]!=inf && Station[a][s]!=inf){\n\t    int time=p[i].s+Station[a][b];\n\t    //cout<<a<<\" \"<<b<<\" \"<<Station[a][b]<<\" \"<<time<<endl;\n\t    if(j>=time && (time+Station[a][s])<=t){\n\t      dp[i][j]=max(dp[k][j-time]+1,dp[i][j-1]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<dp[l][t]<<endl;;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nstruct Edge {\n\tint v, t;\n\tEdge(int v_, int t_) : v(v_), t(t_) {}\n\tbool operator > (const Edge& e) const { return t > e.t; }\n};\n\nint n, m, l, lim, J[22], e[22];\nvector< vector< Edge > > edges;\n\nint cost[333][333], dp[1 << 20][20];\n\nvoid djk(int s) {\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > q;\n\tq.push(Edge(s, 0));\n\tcost[s][s] = 0;\n\t\n\twhile (!q.empty()) {\n\t\tEdge e = q.top(); q.pop();\n\t\t\n\t\tif (cost[s][e.v] < e.t) continue;\n\t\t\n\t\tfor_(i,0,(int)edges[e.v].size()) {\n\t\t\tEdge ei = edges[e.v][i];\n\t\t\t\n\t\t\tif (cost[s][ei.v] > e.t + ei.t) {\n\t\t\t\tcost[s][ei.v] = e.t + ei.t;\n\t\t\t\tq.push(Edge(ei.v, e.t + ei.t));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tfor_(i,0,n+1) for_(j,0,n+1) cost[i][j] = 1e9;\n\t\n\tfor_(i,0,l+1) djk(J[i]);\n\t\n\tfor_(i,0,(1 << (l+1))) for_(j,0,l+1) dp[i][j] = 1e9;\n\tdp[0][0] = 0;\n\t\n\tfor_(S,0,(1 << (l+1))) for_(u,0,l+1) {\n\t\tif (dp[S][u] < 1e9) {\n\t\t\tfor_(v,0,l+1) {\n\t\t\t\tif (!(S >> v & 1)) {\n\t\t\t\t\tdp[S | 1 << v][v] = min(dp[S | 1 << v][v], dp[S][u] + cost[J[u]][J[v]] + e[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor_(S,0,(1 << (l+1))) {\n\t\tif (dp[S][0] <= lim) ans = max(ans, __builtin_popcount(S));\n\t}\n\tcout << ans-1 << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> l >> J[0] >> lim, n) {\n\t\tedges.assign(n+1, vector< Edge >());\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\t\t\n\t\te[0] = 0;\n\t\tfor_(i,1,l+1) cin >> J[i] >> e[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nvoid warshallFloyd(Matrix<T> &G,int n){\n\tfor(int k = 0;k < n;k++){\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tG[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint n,m,l,s,t,v[20],e[20];\nint dp[1 << 17][20];\nMatrix<int> dist(310,vector<int>(310));\n\nvoid solve(){\n\ts--;\n\tconst int INF = 1e+11;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++) dist[i][j] = INF;\n\t\tdist[i][i] = 0;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c; a--;b--;\n\t\tdist[a][b] = dist[b][a] = c;\n\t}\n\twarshallFloyd(dist,n);\n\tv[0] = s; e[0] = 0;\n\tfor(int i = 1;i <= l;i++){\n\t\tcin >> v[i] >> e[i]; v[i]--;\n\t}\n\tl++;\n\tfor(int i = 0;i < (1 << l);i++){\n\t\tfor(int j = 0;j < l;j++) dp[i][j] = INF;\n\t}\n\tdp[0][0] = 0;\n\tfor(int i = 0;i < (1 << l);i++){\n\t\tfor(int j = 0;j < l;j++){\n\t\t\tfor(int k = 0;k < l;k++){\n\t\t\t\tif(i >> k & 1) continue;\n\t\t\t\tchmin(dp[i | (1 << k)][k],dp[i][j] + dist[v[j]][v[k]] + e[k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0;i < (1 << l);i++){\n\t\tif(dp[i][0] <= t) chmax(ans,(int)__builtin_popcountll(i) - 1);\n\t}\n\tcout << ans << endl;\n}\n\nsigned main(){\n\twhile(cin >> n >> m >> l >> s >> t,n) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\ninline int popcount(int x){\n\tx=((x>>1)&0x55555555)+(x&0x55555555);\n\tx=((x>>2)&0x33333333)+(x&0x33333333);\n\tx=((x>>4)+x)&0x0f0f0f0f;\n\tx+=(x>>8);\n\tx+=(x>>16);\n\treturn x&0x3f;\n}\n\nint main(){\n\tfor(int n,m,n_jiro,s,T;scanf(\"%d%d%d%d%d\",&n,&m,&n_jiro,&s,&T),n;){\n\t\ts--;\n\n\t\tstatic int d[300][300];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(i,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t}\n\n\t\tint jiro[17],eat[17]; // index 0 is starting point\n\t\tjiro[0]=s;\n\t\teat[0]=0;\n\t\trep(i,n_jiro){\n\t\t\tscanf(\"%d%d\",jiro+i+1,eat+i+1);\n\t\t\tjiro[i+1]--;\n\t\t}\n\t\tn_jiro++;\n\n\t\t// Warshall-Floyd\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tstatic int dp[17][1<<17]; // dp[last visited jiro][eaten jiro] := minimum time\n\t\trep(i,n_jiro) rep(S,1<<n_jiro) dp[i][S]=INF;\n\t\tdp[0][1]=0;\n\t\trep(S,1<<n_jiro) rep(i,n_jiro) if(S&(1<<i)) {\n\t\t\trep(j,n_jiro) if(!(S&(1<<j))) {\n\t\t\t\tdp[j][S|(1<<j)]=min(dp[j][S|(1<<j)],dp[i][S]+d[jiro[i]][jiro[j]]+eat[j]);\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\trep(i,n_jiro) rep(S,1<<n_jiro) if(dp[i][S]+d[jiro[i]][s]<=T) ans=max(ans,popcount(S)-1);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint n,m,l,s,dp[1<<18][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse{\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=0;\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]=dp[i1][xz]+1;\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=z;\n    g[y][x]=z;\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<=l;i++){\n    vector<int> vv;\n    for(int j=0;j<=l;j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nint re=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dist[301][301], p[17], q[17], dp[1 << 16][17], n, m, a, b, c, d, e, f;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m >> a >> b >> c; if (n + m + a + b + c == 0)break;\n\t\tfor (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++)dist[i][j] = 999999999; }\n\t\tfor (int i = 1; i <= n; i++) dp[i][i] = 0;\n\t\tfor (int i = 0; i < m; i++) { cin >> d >> e >> f; dist[d][e] = f; dist[e][d] = f; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++)dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < (1 << a); i++) { for (int j = 0; j <= a; j++)dp[i][j] = 999999999; }\n\t\tfor (int i = 0; i < a; i++)cin >> p[i] >> q[i]; dp[0][a] = 0; p[a] = b;\n\t\tfor (int i = 0; i < (1 << a); i++) {\n\t\t\tfor (int j = 0; j <= a; j++) {\n\t\t\t\tif (dp[i][j] == 999999999)continue;\n\t\t\t\tint bit[16]; for (int k = 0; k < a; k++)bit[k] = (i / (1 << k)) % 2;\n\t\t\t\tfor (int k = 0; k < a; k++) {\n\t\t\t\t\tif (bit[k] == 1)continue;\n\t\t\t\t\tdp[i + (1 << k)][k] = min(dp[i + (1 << k)][k], dp[i][j] + dist[p[j]][p[k]] + q[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxn = 0;\n\t\tfor (int i = 0; i < (1 << a); i++) {\n\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\tint G = 0; for (int k = 0; k < a; k++) G += (i / (1 << k)) % 2;\n\t\t\t\tif (dp[i][j] + dist[p[j]][p[a]] > c)continue;\n\t\t\t\tmaxn = max(maxn, G);\n\t\t\t}\n\t\t}\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    map<int, int> timeTo; // time[nextStation]\n};\nmap<int, Station> stations;\n\nint s;\nint maxNum;\n\nvoid trip(int i, int rest, map<int, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(i == it->first){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    int n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(int i = 0; i < m; ++i){\n            int a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(int i = 0; i < l; ++i){\n            int j,e;\n            cin >> j >> e;\n            stations[j].timeTo[j] = e;\n        }\n        for(int i = 1; i <= n; ++i){\n            auto& timeTo = stations[i].timeTo;\n            // has SIRO\n            if(timeTo.find(i) != timeTo.end()){\n                continue;\n            }\n            // not has SIRO\n            for(auto it = timeTo.begin(); it != timeTo.end(); ++it){\n                // compress here\n            }\n        }\n        maxNum = 0;\n        map<int, bool> ate;\n        trip(s, t, ate);\n        cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1e9;\nconst long long LINF = 1e18;\nconst double EPS = 1e-8;\n#define pb push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define all(a) (a).begin(),(a).end()\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\ntypedef long long ll;\ntemplate<class T>\nostream& operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()){\n\t\tout << v[i] <<\", \";\n\t}\n\treturn out << \"}\" << endl;\n}\nint N, M, L, S, T;\nint D[310][310];\nvector<Pii> town;\nint memo[1<<17][17];\n\nint solve(int bit, int now) {\n\tif(memo[bit][now] != -1){\n\t\treturn memo[bit][now];\n\t}\n\n\tint t = INF;\n\trep(i,town.size()) {\n\t\tif(!(1&(bit>>i))){\n\t\t\t//printf(\"%d->%d %d\\n\",town[now].fr, town[i].fr,D[town[now].fr][town[i].fr] + town[i].sc);\n\t\t\tt = min(t, solve(bit|(1<<i),i) + D[town[now].fr][town[i].fr] + town[i].sc);\n\t\t\tif(memo[bit|(1<<i)][i] == -1){\n\t\t\t\tmemo[bit|(1<<i)][i] = t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main() {\n\n\twhile(cin >> N  >> M >> L >> S >> T,N){\n\t\ttown.clear();\n\t\tmemset(memo,-1,sizeof(memo));\n\t\t--S;\n\t\trep(i,N){\n\t\t\trep(j,N){\n\t\t\t\tD[i][j] = INF*(i!=j);\n\t\t\t}\n\t\t}\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t--a;--b;\n\t\t\tD[a][b] = D[b][a] = c;\n\t\t}\n\t\trep(k,N){\n\t\t\trep(i,N){\n\t\t\t\trep(j,N){\n\t\t\t\t\tD[i][j] = min(D[i][j],D[i][k]+D[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttown.pb(mk(S,0));\n\t\trep(i,L){\n\t\t\tint j,e;\n\t\t\tcin >> j >> e;\n\t\t\t--j;\n\t\t\ttown.pb(mk(j,e));\n\t\t}\n\t\t\n\t\tsolve(1<<0, 0);\n\t\tint mx = 0;\n\n\t\trep(i,1<<town.size()){\n\t\t\t\n\t\t\t /*if(!(1&(i>>0))){\n\t\t\t \tcontinue;\n\t\t\t }*/\n\n\t\t\treps(j,1,town.size()){\n\t\t\t\tif(memo[i][j] == -1)continue;\n\t\t\t\tif(memo[i][j]+D[town[j].fr][S] <= T) {\n\t\t\t\t\tmx = max(mx, __builtin_popcount(i)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << mx << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return 0;\nelse{\n    num++;\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz]+1;\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,L,S,T;\n#define INF ( 1<<29 )\nstruct edge{\n  int to,c;\n};\nstruct state{\n  int id,s,c;\n  bool operator>(const state &st) const{\n    return c > st.c;\n  }\n};\nvector<edge> G[333];\nedge R[333];\n\nint h[301][(1<<16)];\nvoid solve(){\n  fill(h[0],h[N],T+1);\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push( (state){S,0,0} );\n  h[S][0] = 0;\n  while( !q.empty() ){\n    state st = q.top(); q.pop();\n    int id = st.id;\n    int bi = st.s;\n    int c = st.c;\n    //    cout << id <<  \" \" << bitset<6>(bi) << \" \" << c << endl;\n    // cout << \"R \" << R[id].to << \" \" << R[id].c << endl;\n    if( R[id].to != -1 && (bi&(1<<R[id].to))==0 ){\n      int sbi = (bi | (1<<R[id].to));\n      if( h[id][sbi] > c + R[id].c ){\n\th[id][sbi] = c + R[id].c;\n\tq.push( (state){id,sbi,c+R[id].c} );\n      }\n    } \n    for(int i=0;i<(int)G[id].size();i++){\n      edge &e = G[id][i];\n      if( h[e.to][bi] > e.c + c ){\n\th[e.to][bi] = e.c + c;\n\tq.push( (state){e.to,bi,e.c+c} );\n      }\n    }\n  }\n  int res = 0;\n  for(int i=0;i<(1<<L);i++){\n    // cout << S << \" \" << bitset<10>(i) << \" \"<< h[S][i] << endl;\n    if( h[S][i] <= T ){\n      res = max(res,__builtin_popcount(i));\n    }\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T && ( N||M||L||S||T ) ){\n    --S;\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a>> b >> c ;\n      --a;--b;\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<N;i++) R[i] = (edge){-1,-1};\n    for(int i=0;i<L;i++){\n      int j,e;\n      cin >> j >> e;\n      --j;\n      R[j] = (edge){i,e};\n    }\n    solve();\n\n    for(int i=0;i<N;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct edge {\n\tint to, cost;\n};\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint N, M, L, s, t, a, b, c, p[22], e[22], popcount[131111];\nint main() {\n\tfor (int i = 0; i < 17; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\twhile (cin >> N >> M >> L >> s >> t, s--, N) {\n\t\tvector<vector<edge> > G(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c; a--, b--;\n\t\t\tG[a].push_back(edge{ b, c });\n\t\t\tG[b].push_back(edge{ a, c });\n\t\t}\n\t\tfor (int i = 1; i <= L; i++) cin >> p[i] >> e[i], p[i]--; p[0] = s;\n\t\tvector<vector<int> > dist(L + 1, vector<int>(L + 1));\n\t\tfor (int i = 0; i <= L; i++) {\n\t\t\tpriority_queue<edge> que; que.push(edge{ p[i], 0 });\n\t\t\tvector<int> d(N, 999999999); d[p[i]] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tedge u = que.top(); que.pop();\n\t\t\t\tfor (edge e : G[u.to]) {\n\t\t\t\t\tif (d[e.to] > d[u.to] + e.cost) {\n\t\t\t\t\t\td[e.to] = d[u.to] + e.cost;\n\t\t\t\t\t\tque.push(edge{ e.to, -d[e.to] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j <= L; j++) dist[i][j] = d[p[j]];\n\t\t}\n\t\tvector<vector<int> > dp(L + 1, vector<int>(1 << (L + 1), 999999999));\n\t\tdp[0][0] = 0;\n\t\tfor (int i = 0; i < 1 << (L + 1); i++) {\n\t\t\tfor (int j = 0; j <= L; j++) {\n\t\t\t\tif (dp[j][i] == 999999999) continue;\n\t\t\t\tfor (int k = 0; k <= L; k++) {\n\t\t\t\t\tif (!(i & (1 << k))) {\n\t\t\t\t\t\tdp[k][i + (1 << k)] = min(dp[k][i + (1 << k)], dp[j][i] + dist[j][k] + e[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 1 << (L + 1); i++) {\n\t\t\tif (dp[0][i] <= t) ret = max(ret, popcount[i]);\n\t\t}\n\t\tcout << ret - 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    struct Edge {\n        int from, to, cost;\n        Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    };\n\n    int N, M, L, S, T;\n    vector< vector<Edge> > G;\n    vector<int> J, E;\n    bool input() {\n        cin >> N >> M >> L >> S >> T;\n        if (N == 0) return false;\n        S--;\n        G.clear(); G.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            G[a].push_back(Edge(a, b, c));\n            G[b].push_back(Edge(b, a, c));\n        }\n        J.clear(); J.resize(L);\n        E.clear(); E.resize(L);\n        for (int i = 0; i < L; i++) {\n            cin >> J[i] >> E[i];\n            J[i]--;\n        }\n        return true;\n    }\n\n    vector< vector<int> > W;\n    const int INF = 1<<28;\n\n    struct State {\n        int v, bit, cost;\n        State(int v, int bit, int cost) : v(v), bit(bit), cost(cost) {}\n    };\n\n    void solve() {\n        W.clear(); W.resize(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) W[i][i] = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < G[i].size(); j++) {\n                const Edge& e = G[i][j];\n                W[ e.from ][ e.to ] = e.cost;\n            }\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    W[i][j] = min(W[i][j], W[i][k] + W[k][j]);\n                }\n            }\n        }\n        vector< vector<int> > dp(L, vector<int>(1 << L, INF));\n        queue<State> Q;\n        for (int i = 0; i < L; i++) {\n            Q.push(State(i, 1<<i, W[S][J[i]] + E[i]));\n            dp[i][1<<i] = W[S][J[i]] + E[i];\n        }\n        while (!Q.empty()) {\n            State s = Q.front(); Q.pop();\n            for (int n = 0; n < L; n++) {\n                if (s.bit & (1 << n)) continue;\n                int nbit = s.bit | (1 << n);\n                int ncost = s.cost + W[ J[s.v] ][ J[n] ] + E[n];\n                if (ncost + W[n][S] > T) continue;\n                if (dp[n][nbit] > ncost) {\n                    dp[n][nbit] = ncost;\n                    Q.push(State(n, nbit, ncost));\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < L; i++) {\n            for (int bit = 0; bit < (1 << L); bit++) {\n                if (dp[i][bit] + W[ J[i] ][ J[0] ] <= T) {\n                    ans = max(ans, __builtin_popcount(bit));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\n#define FOR(i, a, b) for(int i=(a), _b=(b); i<=_b; i++)\n#define DOW(i, a, b) for(int i=(a), _b=(b); i>=_b; i--)\n#define REP(i, b) for(int i=0; i<b; i++)\n#define CT(x) ((x) << 1)\n#define CP(x) (CT(x) + 1)\n#define PB push_back\n#define MP make_pair\n\n#define MAXN 333\n#define MAXT 100111\n#define MAXL 16\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, l, s, t;\nvector<pii> adj[MAXN];\nint e[MAXN];\nset<pair<int, pii> > se;\nint d[MAXN][1 << MAXL];\nint cnt[1 << MAXL], pos[MAXN];\nint w[MAXN][MAXN];\nint L[MAXN];\n\nint bit_cnt(int x) {\n  int result = 0;\n  for(int i = 0; i < MAXL; i++)\n    if (x & 1 << i) result += 1;\n  return result;\n}\n\nint onbit(int x, int j) {\n  return ((x >> j) & 1);\n} \n\nint calc(int s) {\n  int u, v, k, newk, newd;\n  pair<int, pii> ele;\n  set<pair<int, pii> >::iterator it;\n  int res = 0;\n\n  se.clear();\n  se.insert(MP(0, MP(s, 0)));\n  \n  FOR(i, 1, n)\n    FOR(j, 0, (1 << l) - 1) d[i][j] = t + 1;\n  d[s][0] = 0;\n\n\n  while (!se.empty()) {\n    ele = *se.begin(); \n    se.erase(ele);\n    if (ele.first > t) break;\n    u = ele.second.first;\n    k = ele.second.second;\n    if (cnt[k] > res && d[u][k] + w[k][s] <= t) {\n      res = cnt[k];\n      if (res == l) break;\n    }\n    FOR(i, 0, l-1) {\n      v = L[i];\n      newk = k | (1 << pos[v]);\n      newd = d[u][k] + w[u][v];\n      if (!onbit(k, pos[v])) {\n        // not eat yet --> eat at station v\n        newd += e[v];\n      }\n      if (d[v][newk] > newd) {\n        // update\n        d[v][newk] = newd;\n        it = se.find(MP(d[v][newk], MP(v, newk)));\n        if (it != se.end()) se.erase(it);\n        se.insert(MP(newd, MP(v, newk)));\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n//  freopen(\"in\", \"r\", stdin);\n  \n  int u, v, c;\n\n  FOR(i, 0, (1 << MAXL) - 1) {\n    cnt[i] = bit_cnt(i);\n  }\n\n  while (cin >> n >> m >> l >> s >> t) {\n    if (n == 0) break;\n\n    FOR(u, 1, n)\n      FOR(v, 1, n) if (u == v) w[u][v] = 0;\n       else w[u][v] = t + 1;\n    FOR(i, 1, n) adj[i].clear();\n    FOR(i, 1, m) {\n      cin >> u >> v >> c;\n      w[u][v] = w[v][u] = c;\n      adj[u].push_back(make_pair(v, c));\n      adj[v].push_back(make_pair(u, c));\n    }\n    FOR(u, 1, n)\n      FOR(v, 1, n) {\n        FOR(k, 1, n)\n          if (w[u][v] > w[u][k] + w[k][v]) w[u][v] = w[u][k] + w[k][v];\n      }\n\n    FOR(i, 1, n) e[i] = -1;\n    FOR(i, 1, n) pos[i] = -1;\n    FOR(i, 0, l-1) {\n      cin >> u >> e[u];\n      L[i] = u;\n      pos[u] = i;\n    }\n    cout << calc(s) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    map<int, int> timeTo; // time[nextStation]\n};\nmap<int, Station> stations;\n\nint s;\nint maxNum;\n\nvoid trip(int i, int rest, map<int, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(i == it->first){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    int n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(int i = 0; i < m; ++i){\n            int a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(int i = 0; i < l; ++i){\n            int j,e;\n            cin >> j >> e;\n            stations[j].timeTo[j] = e;\n        }\n        // remove station if it hasn't SIRO.\n        for(auto target = stations.begin(); target != stations.end(); ){\n            auto& nextStations = target->second.timeTo;\n            const bool hasSiro = nextStations.find(target->first) != nextStations.end();\n            if(hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            // reconnect\n            for(auto nextStation = nextStations.begin(); nextStation != nextStations.end(); ++nextStation){\n                auto& connectTargets = stations[target->first].timeTo;\n                auto next = stations[nextStation->first];\n                for(auto connectTarget = connectTargets.begin(); connectTarget != connectTargets.end(); ++connectTarget){\n                    auto targetStation = stations[target->first];\n                    auto hogeTime = next.timeTo[target->first] + targetStation.timeTo[connectTarget->first];\n                    auto hoge = next.timeTo.find(connectTarget->first);\n                    if(hoge == next.timeTo.end()){\n                        hoge->second = hogeTime;\n                    }else{\n                        if(hoge->second > hogeTime){\n                            hoge ->second = hogeTime;\n                        }\n                    }\n                }\n                next.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        map<int, bool> ate;\n        trip(s, t, ate);\n        cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint N;\nint dp[18][1 << 18];\nGraph g;\n\nint solve(int i, int bit)\n{\n\tif (dp[i][bit] != -1) return dp[i][bit];\n\tif (bit == (1 << N) - 1) return 0;\n\tint res = INF;\n\tREP(j, N)\n\t{\n\t\tif (i == j || ((bit >> j) & 1)) continue;\n\t\tint nbit = bit | (1 << j);\n\t\tchmin(res, solve(j, nbit) + g[i][j].cost);\n\t}\n\treturn dp[i][bit] = res;\n}\n\nint main()\n{\n\tint n, m, l, s, t;\n\twhile (cin >> n >> m >> l >> s >> t, n)\n\t{\n\t\tg.clear();\n\t\tMS(dp, -1);\n\t\ts--;\n\t\tvector<vi> d(n, vi(n, INF));\n\t\tREP(i, n) d[i][i] = 0;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tg.resize(l + 1);\n\t\tvi v, e;\n\t\tv.push_back(s); e.push_back(0);\n\t\tREP(i, l)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\ta--;\n\t\t\tv.push_back(a);\n\t\t\te.push_back(b);\n\t\t}\n\t\tN = v.size();\n\t\tREP(i, N)\n\t\t{\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tadd_edge(g, i, j, d[v[i]][v[j]]);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, (1 << N) - 1)\n\t\t{\n\t\t\tif (!((i >> s) & 1)) continue;\n\t\t\tint bit = i << 1, cnt = -1;\n\t\t\tint time = 0;\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tif (((bit >> j) & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\ttime += e[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime += solve(0, bit);\n\t\t\tif (time <= t) chmax(ans, cnt);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()/2] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nstruct data{\n\tint v,bit,c;\n\tdata(int vv=0,int bb=0,int cc=0){\n\t\tv=vv;\n\t\tbit=bb;\n\t\tc=cc;\n\t}\n\tbool operator<(const data &d1)const{\n\t\treturn d1.c<c;\n\t}\n};\n\nint n,m,l,s,t;\nint dist[301][301];\nint dp[18][1<<16];\nint siro[301];\nint cost[18];\n\nvoid dijk(){\n\tfor(int i=0;i<=l;i++){\n\t\tfor(int j=0;j<(1<<l);j++){\n\t\t\tdp[i][j]=t+1;\n\t\t}\n\t}\n\tpriority_queue<data> que;\n\tque.push(data(l,0,0));\n\tdp[l][0]=0;\n\twhile(que.size()){\n\t\tdata q=que.top();\n\t\tque.pop();\n\t\tif(dp[q.v][q.bit]<q.c)continue;\n\t\tif(q.v!=l && !(q.bit>>q.v & 1)){\n\t\t\tif(dp[q.v][q.bit|(1<<q.v)]>dp[q.v][q.bit]+cost[q.v]){\n\t\t\t\tdp[q.v][q.bit|(1<<q.v)]=dp[q.v][q.bit]+cost[q.v];\n\t\t\t\tque.push(data(q.v,q.bit|(1<<q.v),dp[q.v][q.bit|(1<<q.v)]));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=l;i++){\n\t\t\tif(dp[i][q.bit]>dp[q.v][q.bit]+dist[siro[q.v]][siro[i]]){\n\t\t\t\tdp[i][q.bit]=dp[q.v][q.bit]+dist[siro[q.v]][siro[i]];\n\t\t\t\tque.push(data(i,q.bit,dp[i][q.bit]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %d %d %d\",&n,&m,&l,&s,&t);\n\t\tif(n+m+l+s+t==0)break;\n\t\ts--;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdist[i][j]=t+1;\n\t\t\t}\n\t\t\tdist[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tdist[a][b]=c;\n\t\t\tdist[b][a]=c;\n\t\t}\n\t\tmemset(siro,-1,sizeof(siro));\n\t\tfor(int i=0;i<l;i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d %d\",&v,&cost[i]);\n\t\t\tv--;\n\t\t\tsiro[i]=v;\n\t\t}\n\t\tsiro[l]=s;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdijk();\n\t\tint res=0;\n\t\tfor(int bit=0;bit<(1<<l);bit++){\n\t\t\tif(dp[l][bit]<=t){\n\t\t\t\tres=max(res,__builtin_popcount(bit));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,l,s,inf=1e5+1,t,a,c,b,ok;\nint g[305][305],G[305][305],re;\nint ind[25],cost[25],dp[20][(1<<18)];\n\n\nint f(int cur,int vis){\nif(dp[cur][vis]!=-1) return dp[cur][vis];\nif((vis&(~(1<<cur)))==0) return dp[cur][vis]=G[l][cur]+cost[cur];\ndp[cur][vis]=1e9;\nfor(int j=0;j<l;j++){\n    if((j!=cur)&&(((1<<j)&vis)!=0)){\n        dp[cur][vis]=min(dp[cur][vis],f(j,vis&(~(1<<cur)))+G[j][cur]);\n    }\n}\ndp[cur][vis]+=cost[cur];\nreturn dp[cur][vis];\n}\n\nint main(){\nwhile(cin>>n>>m>>l>>s>>t){\n    if(n+m+l+s+t==0) break;\n    memset(dp,-1,sizeof(dp));s--;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++) g[i][j]=inf;\n        g[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        cin>>a>>b>>c;\n        a--;b--;\n        g[a][b]=c;\n        g[b][a]=c;\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++)\n                g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n        }\n    }\n    for(int i=0;i<l;i++){\n        cin>>ind[i]>>cost[i];\n        ind[i]--;\n    }\n    for(int i=0;i<l;i++){\n        G[i][l]=g[ind[i]][s];\n        G[l][i]=g[ind[i]][s];\n        for(int j=0;j<l;j++) G[i][j]=g[ind[i]][ind[j]];\n    }\n    re=0;\n    for(int i=0;i<(1<<l);i++){\n        int cnt=0;\n        for(int j=0;j<l;j++) if(i&(1<<j)) cnt++;\n        for(int j=0;j<l;j++){\n            if(i&(1<<j)){\n                if(f(j,i)+G[j][l]<=t) re=max(re,cnt);\n            }\n        }\n    }\n    cout<<re<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\n\nint edges[301][301];\nint ramen_time[20];\nint dp[301][1<<16];\n\nint main(){\n  int num_of_stations;\n  int num_of_pairs;\n  int num_of_SIRO;\n  int starting_point;\n  int time_limit;\n  while(~scanf(\"%d %d %d %d %d\",\n               &num_of_stations,\n               &num_of_pairs,\n               &num_of_SIRO,\n               &starting_point,\n               &time_limit)){\n    if(num_of_stations == 0\n       && num_of_pairs == 0\n       && num_of_SIRO == 0\n       && starting_point == 0\n       && time_limit == 0) break;\n\n    memset(edges,0x3f,sizeof(edges));\n    starting_point--;\n\n    vector<int> candidates[301];\n    for(int i = 0; i < num_of_pairs; i++){\n      int from,to;\n      int time;\n      scanf(\"%d %d %d\",&from,&to,&time);\n      from--;\n      to--;\n      edges[from][to] = time;\n      edges[to][from] = time;\n      candidates[from].push_back(to);\n      candidates[to].push_back(from);\n    }\n\n    for(int mid = 0; mid < num_of_stations; mid++){\n      for(int from = 0; from < num_of_stations; from++){\n        for(int i = 0; i < candidates[from].size(); i++){\n          int to = candidates[from][i];\n          edges[from][to] = min(edges[from][to],edges[from][mid] + edges[mid][to]);\n        }\n      }\n    }\n\n    int SIRO_idx[301];\n    memset(SIRO_idx,-1,sizeof(SIRO_idx));\n    memset(ramen_time,0x3f,sizeof(ramen_time));\n    for(int i = 0; i < num_of_SIRO; i++){\n      int station,time;\n      scanf(\"%d %d\",&station,&time);\n      station--;\n      ramen_time[i] = time;\n      SIRO_idx[station] = i;\n    }\n\n    memset(dp,0x3f,sizeof(dp));\n    dp[starting_point][0] = 0;\n\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      for(int from = 0; from < num_of_stations; from++){\n        if(SIRO_idx[from] != -1){\n          dp[from][S | (1<<SIRO_idx[from])]\n            = min(dp[from][S | (1<<SIRO_idx[from])],\n                  dp[from][S] + ramen_time[SIRO_idx[from]]);\n        }\n\n        for(int i = 0; i < candidates[from].size(); i++){\n          int to = candidates[from][i];\n          if(from == to) continue;\n\n          if(SIRO_idx[to] == -1){\n            dp[to][S] = min(dp[from][S] + edges[from][to],dp[to][S]);\n          }\n          else{\n            dp[to][S | (1 << SIRO_idx[to])]\n              = min(dp[to][S | (1 << SIRO_idx[to])]\n                    ,dp[from][S] + edges[from][to] + ramen_time[SIRO_idx[to]]);\n            dp[to][S]\n              = min(dp[to][S],dp[from][S] + edges[from][to]);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      if(time_limit >= dp[starting_point][S]){\n        res = max(res,__builtin_popcount(S));\n      }\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  vector<vector<int> >used(1<<l,vector<int>(n,T+1));   \n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s))),D[1<<idx[s]][s]= SIRO[s];\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost||used[bit][pos]++)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++)G[i].clear();\n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    memset(idx,0,sizeof(idx));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    struct Edge {\n        int from, to, cost;\n        Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    };\n\n    int N, M, L, S, T;\n    vector< vector<Edge> > G;\n    vector<int> J, E;\n    bool input() {\n        cin >> N >> M >> L >> S >> T;\n        if (N == 0) return false;\n        S--;\n        G.clear(); G.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            G[a].push_back(Edge(a, b, c));\n            G[b].push_back(Edge(b, a, c));\n        }\n        J.clear(); J.resize(L);\n        E.clear(); E.resize(L);\n        for (int i = 0; i < L; i++) {\n            cin >> J[i] >> E[i];\n            J[i]--;\n        }\n        return true;\n    }\n\n    vector< vector<int> > W;\n    const int INF = 1<<28;\n\n    struct State {\n        int v, bit, cost;\n        State(int v, int bit, int cost) : v(v), bit(bit), cost(cost) {}\n    };\n\n    void solve() {\n        W.clear(); W.resize(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) W[i][i] = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < G[i].size(); j++) {\n                const Edge& e = G[i][j];\n                W[ e.from ][ e.to ] = e.cost;\n            }\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    W[i][j] = min(W[i][j], W[i][k] + W[k][j]);\n                }\n            }\n        }\n        vector< vector<int> > dp(L, vector<int>(1 << L, INF));\n        queue<State> Q;\n        for (int i = 0; i < L; i++) {\n            Q.push(State(i, 1<<i, W[S][J[i]] + E[i]));\n            dp[i][1<<i] = W[S][J[i]] + E[i];\n        }\n        while (!Q.empty()) {\n            State s = Q.front(); Q.pop();\n            for (int n = 0; n < L; n++) {\n                if (s.bit & (1 << n)) continue;\n                int nbit = s.bit | (1 << n);\n                int ncost = s.cost + W[ J[s.v] ][ J[n] ] + E[n];\n                if (dp[n][nbit] > ncost) {\n                    dp[n][nbit] = ncost;\n                    Q.push(State(n, nbit, ncost));\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < L; i++) {\n            for (int bit = 0; bit < (1 << L); bit++) {\n                if (dp[i][bit] + W[ J[i] ][ J[0] ] <= T) {\n                    ans = max(ans, __builtin_popcount(bit));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e9;\nconst int MAX_V = 500;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint main(){\n\tint n, m, l, s, t;\n\twhile(cin >> n >> m >> l >> s >> t, n){\n\t\ts--;\n\n\t\tint g[MAX_V][MAX_V];\n\t\tinit(g);\n\t\trep(i,m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\twarshallFloyd(g, n);\n\n\t\tvector<pair<int, int>> r(l);\n\t\trep(i,l){\n\t\t\tcin >> r[i].first >> r[i].second;\n\t\t\tr[i].first--;\n\t\t}\n\n\t\t//rep(i,n){ rep(j,n){ cout << g[i][j] << ' '; } cout << endl; }\n\n\t\tvector<vector<int>> dp(1 << l, vector<int>(l, INF));\n\t\trep(i,l){\n\t\t\tdp[0][i] = g[s][r[i].first];\n\t\t\t//dp[1 << l][l] = g[s][r[i].first] + r[i].second;\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\t\t//cout << endl;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tdp[setBit(b, i)][i] = min(dp[setBit(b, i)][i], dp[b][i] + r[i].second);\n\t\t\t\trep(j,l){\n\t\t\t\t\tdp[b][j] = min(dp[b][j], dp[b][i] + g[r[i].first][r[j].first]);\n\t\t\t\t\tdp[setBit(b,i)][j] = min(dp[setBit(b,i)][j], dp[b][i] + g[r[i].first][r[j].first] + r[j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\n\t\tint ans = 0;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tif(dp[b][i] + g[r[i].first][s] <= t) ans = max<int>(ans, bitset<16>(b).count());\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    map<int, int> timeTo; // time[nextStation]\n};\nmap<int, Station> stations;\n\nint s;\nint maxNum;\n\nvoid trip(int i, int rest, map<int, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(i == it->first){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    int n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(int i = 0; i < m; ++i){\n            int a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(int i = 0; i < l; ++i){\n            int j,e;\n            cin >> j >> e;\n            stations[j].timeTo[j] = e;\n        }\n        cout << \"old: \" << stations.size() << endl;\n        // remove station if it hasn't SIRO.\n        for(auto target = stations.begin(); target != stations.end(); ){\n            auto& nextStations = target->second.timeTo;\n            const bool hasSiro = nextStations.find(target->first) != nextStations.end();\n            if(hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            // reconnect\n            for(auto nextStation = nextStations.begin(); nextStation != nextStations.end(); ++nextStation){\n                auto& connectTargets = stations[target->first].timeTo;\n                auto next = stations[nextStation->first];\n                for(auto connectTarget = connectTargets.begin(); connectTarget != connectTargets.end(); ++connectTarget){\n                    if(nextStation->first == connectTarget->first){\n                        continue;\n                    }\n                    auto targetStation = stations[target->first];\n                    auto hogeTime = next.timeTo[target->first] + targetStation.timeTo[connectTarget->first];\n                    auto hoge = next.timeTo.find(connectTarget->first);\n                    if(hoge == next.timeTo.end()){\n                        hoge->second = hogeTime;\n                    }else{\n                        if(hoge->second > hogeTime){\n                            hoge ->second = hogeTime;\n                        }\n                    }\n                }\n                next.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        cout << \"new: \" << stations.size() << endl << endl;\n        // map<int, bool> ate;\n        // trip(s, t, ate);\n        // cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<31\nusing namespace std;\n\nint Station[301][301];\npair<int,int> p[20];\nint dp[20][1000001];\n\nint main()\n{\n  int n,m,l,s,t,a,b,c,x,y;\n\n  while(1){\n    cin>>n>>m>>l>>s>>t;\n    if(n+m+l+s+t==0)break;\n    s--;\n\n    for(int i=0;i<l+1;i++)for(int j=0;j<t+1;j++)dp[i][j]=0;\n    for(int i=0;i<301;i++){\n      for(int j=0;j<301;j++){\n\tif(i==j)Station[i][j]=0;\n\telse Station[i][j]=inf;\n      }\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      a--;b--;\n      Station[a][b]=c;\n      Station[b][a]=c;\n    }\n    p[0].f=s;p[0].s=0;\n    for(int i=1;i<l+1;i++){\n      cin>>p[i].f>>p[i].s;\n      p[i].f--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  Station[i][j]=min(Station[i][j],Station[i][k]+Station[k][j]);\n\t}\n      }\n    }\n\n    for(int i=1;i<l+1;i++){\n      for(int j=1;j<t+1;j++){\n\tfor(int k=0;k<i;k++){\n\t  int a=p[i].f,b=p[k].f;\n\t  if(Station[a][b]==inf || Station[a][s]==inf)continue;\n\t  int time=p[i].s+Station[a][b];\n\t  //cout<<a<<\" \"<<b<<\" \"<<Station[a][b]<<\" \"<<time<<endl;\n\t  if(j>=time && (time+Station[a][s])<=t){\n\t    dp[i][j]=max(dp[k][j-time]+1,dp[i][j-1]);\n\t  }\n\t}\n      }\n    }\n    cout<<dp[l][t]<<endl;;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    struct Edge {\n        int from, to, cost;\n        Edge(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    };\n\n    int N, M, L, S, T;\n    vector< vector<Edge> > G;\n    vector<int> J, E;\n    bool input() {\n        cin >> N >> M >> L >> S >> T;\n        if (N == 0) return false;\n        S--;\n        G.clear(); G.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b, c; cin >> a >> b >> c;\n            a--; b--;\n            G[a].push_back(Edge(a, b, c));\n            G[b].push_back(Edge(b, a, c));\n        }\n        J.clear(); J.resize(L);\n        E.clear(); E.resize(L);\n        for (int i = 0; i < L; i++) {\n            cin >> J[i] >> E[i];\n            J[i]--;\n        }\n        return true;\n    }\n\n    vector< vector<int> > W;\n    const int INF = 1<<28;\n\n    struct State {\n        int v, bit, cost;\n        State(int v, int bit, int cost) : v(v), bit(bit), cost(cost) {}\n    };\n\n    void solve() {\n        W.clear(); W.resize(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) W[i][i] = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < G[i].size(); j++) {\n                const Edge& e = G[i][j];\n                W[ e.from ][ e.to ] = e.cost;\n            }\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    W[i][j] = min(W[i][j], W[i][k] + W[k][j]);\n                }\n            }\n        }\n        vector< vector<int> > dp(L, vector<int>(1 << L, INF));\n        queue<State> Q;\n        for (int i = 0; i < L; i++) {\n            Q.push(State(i, 1<<i, W[S][J[i]] + E[i]));\n            dp[i][1<<i] = W[S][J[i]] + E[i];\n        }\n        while (!Q.empty()) {\n            State s = Q.front(); Q.pop();\n            for (int n = 0; n < L; n++) {\n                if (s.bit & (1 << n)) continue;\n                int nbit = s.bit | (1 << n);\n                int ncost = s.cost + W[ J[s.v] ][ J[n] ] + E[n];\n                if (ncost + W[J[n]][S] > T) continue;\n                if (dp[n][nbit] > ncost) {\n                    dp[n][nbit] = ncost;\n                    Q.push(State(n, nbit, ncost));\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < L; i++) {\n            for (int bit = 0; bit < (1 << L); bit++) {\n                if (dp[i][bit] + W[ J[i] ][ S ] <= T) {\n                    ans = max(ans, __builtin_popcount(bit));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 320\n#define INF 1e9\n\nstruct edge{\n  int to,cost,num;\n};\n\nstruct State{\n  int cost,v,S,num;\n  bool operator < (const State &s)const{\n    if(num != s.num){\n      return num > s.num;\n    }else{\n      return cost > s.cost;\n    }\n  }\n};\n\nint N,M,L,S,T;\nvector<edge> G[MAX];\nint dist[1<<16][MAX];\n\nint dijkstra(){\n  priority_queue<State> Q;\n  Q.push((State){0,S,0,0});\n  int ans = 0;\n  for(int i = 0 ; i < (1<<16) ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      dist[i][j] = INF;\n    }\n  }\n  dist[0][S] = 0;\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v;\n    if(s.cost <= T && v == S){\n      ans = max(ans,s.num);\n    }\n    if(s.cost >= T){ continue; }\n    if(dist[s.S][v] < s.cost) continue;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(e.num == L){\n        if(dist[s.S][v] + e.cost < dist[s.S][e.to]){\n          dist[s.S][e.to] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[s.S][e.to],e.to,s.S,s.num});\n        }\n      }else{\n        if((s.S >> e.num) & 1) continue;\n        int next = s.S | (1<<e.num);\n        if(dist[s.S][v]+e.cost < dist[next][v]){\n          dist[next][v] = dist[s.S][v]+e.cost;\n          Q.push((State){dist[next][v],v,next,s.num+1});\n        }\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T, N){\n    for(int i = 0 ; i < MAX ; i++){\n      G[i].clear();\n    }\n    S--;\n    for(int i = 0 ; i < M ; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      G[a].push_back((edge){b,c,L});\n      G[b].push_back((edge){a,c,L});\n    }\n    int n = N;\n    for(int i = 0 ; i < L ; i++){\n      int v,e;\n      cin >> v >> e; v--;\n      G[v].push_back((edge){n,e,i});\n      n++;\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{\n  int v,c;\n};\n\nstruct S{\n  int v,t,b;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nint main(){\n  for(int n,m,l,s,t;cin>>n>>m>>l>>s>>t,n|m|l|s|t;){\n    int d[323][323];\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=(i==j)?0:1e9;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      d[a][b]=d[b][a]=c;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tfor(int k=0;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int js[323],e[323];\n    for(int i=0;i<l;i++){\n      cin>>js[i]>>e[i];\n    }\n    vector<edge> G[17];\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j&&d[js[i]][js[j]]<1e8){\n\t  G[i].push_back({j,d[js[i]][js[j]]});\n\t}\n      }\n      if(d[js[i]][s]<1e8){\n\tG[l].push_back({i,d[js[i]][s]});\n\tG[i].push_back({l,d[js[i]][s]});\n      }\n    }\n    priority_queue<S> que;\n    que.push({l,0,0});\n    int ans=0;\n    bool u[17][1<<16]={};\n    while(!que.empty()){\n      auto c=que.top();\n      if(c.t>t)break;\n      que.pop();\n      if(u[c.v][c.b]++)continue;\n      if(c.v==l){\n\tans=max(ans,__builtin_popcount(c.b));\n      }\n      for(auto elm:G[c.v]){\n\tque.push({elm.v,c.t+elm.c,c.b});\n      }\n      if(c.v<l){\n\tque.push({c.v,c.t+e[c.v],c.b|1<<c.v});\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s))),D[1<<idx[s]][s]= SIRO[s];\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    \n    // if(pos == s)res = max(res,__builtin_popcount(bit));\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n    for(int i=0;i<N;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    memset(idx,0,sizeof(idx));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define inf 1000000000\n\nusing namespace std;\n\nint n, m, l, S, t;\nint g[305][305];\nint p[20], e[20];\nint G[20][20];\n\nint dp[1<<17][20];\n\nvoid WarshallFloyd()\n{\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint count(int s)\n{\n\tint ret = 0;\n\tfor(;s;s >>= 1) if(s&1) ret++;\n\treturn ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m >> l >> S >> t;\n\t\tif(n == 0 && m == 0 && l == 0 && S == 0 && t == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tg[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a, b, c;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\tWarshallFloyd();\n\t\t\n\t\tp[0] = S, e[0] = 0;\n\t\tfor(int i = 1; i <= l; i++){\n\t\t\tcin >> p[i] >> e[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= l; i++){\n\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\tG[i][j] = g[p[i]][p[j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N = 1 << l;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tdp[s][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][0] = 0;\n\t\t\n\t\tint next;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tfor(int j = 0; j <= l; j++){\n\t\t\t\tdp[s][0] = min(dp[s][0], dp[s][j] + G[j][0]);\n\t\t\t\tfor(int k = 1; k <= l; k++){\n\t\t\t\t\tif(s & (1 << (k-1))) continue;\n\t\t\t\t\tnext = s | (1 << (k-1));\n\t\t\t\t\tdp[next][k] = min(dp[next][k], dp[s][j] + G[j][k] + e[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 1; k <= l; k++){\n\t\t\t\tif(s & (1 << (k-1))) continue;\n\t\t\t\tnext = s | (1 << (k-1));\n\t\t\t\tdp[next][k] = min(dp[next][k], dp[s][0] + G[0][k] + e[k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int s = 0; s < N; s++){\n\t\t\tif(dp[s][0] <= t) ans = max(ans, count(s));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nint SIRO[N],idx[N],g[N];\nint n,m,l,s,T;\n\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n\n  Q.push(PP(0,P(0,s)));\n  D[0][s] = 0;\n  \n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    if(cost + G[pos][s]<=T)res = max(res,__builtin_popcount(bit));\n    \n    for(int j=0;j<l;j++){\n      int i = g[j];\n      int ncost= cost+G[pos][i];\n      int nbit = bit;\n      if(bit>>idx[i]&1)continue;\n      nbit|=1<<idx[i], ncost+=+SIRO[i];\n      if(D[nbit][i]>ncost){\n\tQ.push(PP(ncost,P(nbit,i)));\n\tD[nbit][i] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++) G[i][j] = T+1;\n      G[i][i] = 0;\n    }\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a][b] = G[b][a] = c;\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    for(int i=0,j,e;i<l;i++){\n      cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i,g[i] = j-1;\n    }\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\n\n\t\t\t\tif (!nbs[nextplace]||nextplace==0) {\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tif (nextplace == 0) {\n\n\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = nexttime;\n\t\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <string,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\n\nint edges[301][301];\nint ramen_time[20];\nint dp[301][1<<16];\n\nint main(){\n  int num_of_stations;\n  int num_of_pairs;\n  int num_of_SIRO;\n  int starting_point;\n  int time_limit;\n  while(~scanf(\"%d %d %d %d %d\",\n               &num_of_stations,\n               &num_of_pairs,\n               &num_of_SIRO,\n               &starting_point,\n               &time_limit)){\n    if(num_of_stations == 0\n       && num_of_pairs == 0\n       && num_of_SIRO == 0\n       && starting_point == 0\n       && time_limit == 0) break;\n\n    memset(edges,0x3f,sizeof(edges));\n    starting_point--;\n\n    vector<int> candidates[301];\n    for(int i = 0; i < num_of_pairs; i++){\n      int from,to;\n      int time;\n      scanf(\"%d %d %d\",&from,&to,&time);\n      from--;\n      to--;\n      edges[from][to] = time;\n      edges[to][from] = time;\n      candidates[from].push_back(to);\n      candidates[to].push_back(from);\n    }\n\n    for(int mid = 0; mid < num_of_stations; mid++){\n      for(int from = 0; from < num_of_stations; from++){\n        for(int to = 0; to < num_of_stations; to++){\n          edges[from][to] = min(edges[from][to],edges[from][mid] + edges[mid][to]);\n        }\n      }\n    }\n\n    int SIRO_idx[301];\n    memset(SIRO_idx,-1,sizeof(SIRO_idx));\n    memset(ramen_time,0x3f,sizeof(ramen_time));\n    for(int i = 0; i < num_of_SIRO; i++){\n      int station,time;\n      scanf(\"%d %d\",&station,&time);\n      station--;\n      ramen_time[i] = time;\n      SIRO_idx[station] = i;\n    }\n\n    memset(dp,0x3f,sizeof(dp));\n    dp[starting_point][0] = 0;\n\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      for(int from = 0; from < num_of_stations; from++){\n        if(SIRO_idx[from] != -1){\n          dp[from][S | (1<<SIRO_idx[from])]\n            = min(dp[from][S | (1<<SIRO_idx[from])],\n                  dp[from][S] + ramen_time[SIRO_idx[from]]);\n        }\n\n        for(int i = 0; i < candidates[from].size(); i++){\n          int to = candidates[from][i];\n          if(from == to) continue;\n\n          if(SIRO_idx[to] == -1){\n            dp[to][S] = min(dp[from][S] + edges[from][to],dp[to][S]);\n          }\n          else{\n            dp[to][S | (1 << SIRO_idx[to])]\n              = min(dp[to][S | (1 << SIRO_idx[to])]\n                    ,dp[from][S] + edges[from][to] + ramen_time[SIRO_idx[to]]);\n            dp[to][S]\n              = min(dp[to][S],dp[from][S] + edges[from][to]);\n          }\n        }\n      }\n    }\n\n    int res = 0;\n    for(int S = 0; S < (1<<num_of_SIRO); S++){\n      if(time_limit >= dp[starting_point][S]){\n        res = max(res,__builtin_popcount(S));\n      }\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N >> M >> K >> L >> T, N) {\n\t\tvector<vector<int>>edge(N, vector<int>(N, MOD));\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--, b--;\n\t\t\tedge[a][b] = c;\n\t\t\tedge[b][a] = c;\n\t\t}\n\t\tfor (int i = 0; i < N; i++)edge[i][i] = 0;\n\t\tvector<int>node(K);\n\t\tvector<int>cost(K);\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcin >> node[i] >> cost[i];\n\t\t\tnode[i]--;\n\t\t}\n\t\tL--;\n\t\tnode.push_back(L);\n\t\tcost.push_back(0);\n\t\tK++;\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>dp(1 << K, vector<int>(K, MOD));\n\t\tdp[0][K - 1] = 0;\n\t\tdp[1 << (K - 1)][K - 1] = 0;\n\t\tfor (int i = 0; i < 1 << K; i++) {\n\t\t\tfor (int j = 0; j < K; j++) {\n\t\t\t\tfor (int k = 0; k < K; k++) {\n\t\t\t\t\tif ((i >> k) & 1)continue;\n\t\t\t\t\tdp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + edge[node[j]][node[k]] + cost[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for (int i = 0; i < 1 << K; i++) {\n\t\t//\tfor (int j = 0; j < K; j++) {\n\t\t//\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t//\t}\n\t\t//}\n\t\tint ans = 0;\n\t\tfor (int i = 1 << (K - 1); i < 1 << K; i++) {\n\t\t//\tcout << dp[i][K - 1] << endl;\n\t\t\tif (dp[i][K - 1] <= T) {\n\t\t\t\tint box = i;\n\t\t\t\tint num = 0;\n\t\t\t\twhile (box) {\n\t\t\t\t\tnum += box & 1;\n\t\t\t\t\tbox >>= 1;\n\t\t\t\t}\n\t\t\t\tans = max(ans, num - 1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 305\n#define L 16\nusing namespace std;\n\nint main(){\n\n  while(1){\n    \n    int n,m,l,s,t;\n    cin>>n>>m>>l>>s>>t;\n    \n    if(!n&&!m&&!l&&!s&&!t)break;\n    \n    s--;\n\n    int d[N][N];\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++) d[i][j]=INF;\n\n    for(int i=0;i<n;i++) d[i][i]=0;\n  \n    for(int i=0;i<m;i++){\n      \n      int a,b,c;\n      cin>>a>>b>>c;\n      a--,b--;\n      \n      d[a][b]=d[b][a]=c;\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    \n    int r[L],tim[L];\n    \n    for(int i=0;i<l;i++) cin>>r[i]>>tim[i],r[i]--;\n    \n    int dp[(1<<L)][L];\n\n    for(int i=0;i<(1<<l);i++)\n      for(int j=0;j<l;j++) dp[i][j]=INF;\n\n    for(int i=0;i<l;i++)\n      dp[(1<<i)][i]=min(dp[(1<<i)][i],d[s][r[i]]+tim[i]);\n    \n    int ans=0;\n    \n    for(int i=0;i<(1<<l);i++){\n      for(int j=0;j<l;j++){\n\t\n\tif(dp[i][j]==INF) continue;\n\t\n\tif(dp[i][j]+d[r[j]][s]<=t)\n\t  ans=max(ans,__builtin_popcount(i));\n\t\n\tfor(int k=0;k<l;k++){\n\t  \n\t  if(i&(1<<k))continue;\n\t  \n\t  dp[i|(1<<k)][k]=min(dp[i|(1<<k)][k],dp[i][j]+d[r[j]][r[k]]+tim[k]);\n\t\n\t}\n      \n      }\n    }\n\n    cout<<ans<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 26;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 301;\nconst int L = 17;\nint dist[N][N];\nint min_cost[L][1 << L];\n\nusing Elem = tuple<int, int, int>;\n\nint main(void){\n    for(int n, m, l, sv, t; cin >> n >> m >> l >> sv >> t, n;){\n        sv--;\n        l++;\n\n        rep(i, n) rep(j, n) dist[i][j] = inf;\n        rep(i, n) dist[i][i] = 0;\n        rep(loop, m){\n            int a, b, c; cin >> a >> b >> c;\n            a--, b--;\n            dist[a][b] = dist[b][a] = c;\n        }\n\n        vi jiro(n, -1);\n        vi j2v(l);\n        j2v[0] = sv; jiro[sv] = 0;\n        vi eat_time(l);\n        rep(i, 1, l){\n            int v, e; cin >> v >> e;\n            v--;\n            jiro[v] = i;\n            j2v[i] = v;\n            eat_time[i] = e;\n        }\n\n        rep(k, n) rep(i, n) rep(j, n) chmin(dist[i][j], dist[i][k] + dist[k][j]);\n\n        rep(i, l) rep(j, 1 << l) min_cost[i][j] = inf;\n        priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n        q.push(Elem(0, 0, 1));\n\n        while(q.size()){\n            int cost, ji, visited;\n            tie(cost, ji, visited) = q.top(); q.pop();\n            int v = j2v[ji];\n\n            if(not chmin(min_cost[ji][visited], cost)) continue;\n\n            rep(nji, l){\n                if(visited & (1 << nji)) continue;\n\n                int nv = j2v[nji];\n                if(dist[v][nv] >= inf) continue;\n\n                int ncost = cost + dist[v][nv] + eat_time[nji];\n                int nvisited = (visited | (1 << nji));\n\n                if(min_cost[nji][nvisited] == inf){\n                    q.push(Elem(ncost, nji, nvisited));\n                }\n            }\n        }\n\n        int res = 0;\n        rep(ji, l){\n            rep(i, 1 << l){\n                if(min_cost[ji][i] + dist[j2v[ji]][sv] > t) continue;\n                chmax(res, __builtin_popcount(i) - 1);\n            }\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    bool hasSiro;\n    long timeToEat;\n    map<long, long> timeTo; // time[nextStation]\n};\nmap<long, Station> stations;\n\nlong s;\nlong maxNum;\n\nvoid trip(long i, long rest, map<long, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(it->first == i){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    long n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(long i = 0; i < m; ++i){\n            long a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(long i = 0; i < l; ++i){\n            long j,e;\n            cin >> j >> e;\n            stations[j].hasSiro = true;\n            stations[j].timeToEat = e;\n            stations[j].timeTo[j] = e;\n        }\n        for(auto target = stations.begin(); target != stations.end(); ){\n            if(target->second.hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            auto& nexts = target->second.timeTo;\n\n            for(auto next = nexts.begin(); next != nexts.end(); ++next){\n                auto& connects = stations.at(target->first).timeTo;\n                auto& nextStation = stations.at(next->first);\n                for(auto connect = connects.begin(); connect != connects.end(); ++connect){\n                    if(next->first == connect->first){\n                        continue;\n                    }\n                    auto& targetStation = stations.at(target->first);\n                    long time = nextStation.timeTo.at(target->first) + targetStation.timeTo.at(connect->first);\n                    auto hoge = nextStation.timeTo.find(connect->first);\n                    if(hoge == nextStation.timeTo.end()){\n                        nextStation.timeTo[connect->first] = time;\n                    }else if(hoge->second > time){\n                        hoge->second = time;\n                    }\n                }\n                nextStation.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        // cout << \"new: \" << stations.size() << endl;\n        map<long, bool> ate;\n        trip(s, t, ate);\n        cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint N, M, L, S, T;\nint dp[20][1<<17];\n\nint bc(int x){\n  int res = 0;\n  while(x > 0){\n\tif(x&1) ++res;\n\tx >>= 1;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M>>L>>S>>T,N){\n\t--S;\n\tint dist[310][310];\n\tfill((int*)dist, (int*)dist+310*310, INF);\n\tfor(int i=0;i<M;++i){\n\t  int a, b, t; cin >> a >> b >> t;\n\t  --a, --b;\n\t  dist[a][b] = dist[b][a] = t;\n\t}\n\t\n\tint pl[20], ct[20];\n\tfor(int i=0;i<L;++i){\n\t  cin >> pl[i+1] >> ct[i+1];\n\t  --pl[i+1];\n\t}\n\t  \n\t++L;\n\tpl[0] = S;\n\tct[0] = 0;\n\n\tfor(int i=0;i<N;++i)\n\t  dist[i][i] = 0;\n\tfor(int k=0;k<N;++k)\n\t  for(int i=0;i<N;++i)\n\t\tfor(int j=0;j<N;++j)\n\t\t  dist[i][j] = dist[j][i] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tfill((int*)dp, (int*)dp+20*(1<<17), INF);\n\tdp[0][1] = 0;\n\tfor(int i=0;i<L;++i){\n\t  for(int b=0;b<(1<<L);++b){\n\t\tif((b>>i&1) == 0) continue;\n\t\tfor(int j=0;j<L;++j){\n\t\t  if(b>>j&1) continue;\n\t\t  dp[j][b|(1<<j)] = min(dp[j][b|(1<<j)], dp[i][b] + dist[pl[i]][pl[j]] + ct[j]);\n\t\t}\n\t  }\n\t}\n\n\tint ans = 0;\n\tfor(int i=0;i<L;++i)\n\t  for(int b=0;b<(1<<L);++b)\n\t\tif(dp[i][b] + dist[pl[i]][pl[0]] <= T)\n\t\t  ans = max(ans, bc(b)-1);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 1e+8;\nint dist[300][300];\n\nint main() {\n  while(1){\n    int n,m,l,s,t;\n    cin>>n>>m>>l>>s>>t;\n    --s;\n    if(!n)break;\n    REP(i,300)REP(j,300)dist[i][j] = INF;\n    REP(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      --a;--b;\n      dist[a][b] = c;\n      dist[b][a] = c;\n    }\n    REP(k,n)REP(i,n)REP(j,n)dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n    vector<tuple<int,int>> siro;\n    siro.emplace_back(s,0);\n    REP(i,l){\n      int j,e;\n      cin>>j>>e;\n      --j;\n      siro.emplace_back(j,e);\n    }\n    ++l;\n    vector<vector<int>> dp(1<<l,vector<int>(l,INF));\n    dp[1][0] = 0;\n    int num = 0;\n    REP(i,1<<l){\n      REP(j,l){\n        if(dp[i][j] < INF && ((i>>j)&1) == 1) {\n          if (dp[i][j] + dist[get<0>(siro[j])][get<0>(siro[0])] <= t) {\n            int cnt = 0;\n            REP(k,l) if (((i>>k)&1)==1) ++cnt;\n            num = max(num, cnt-1);\n          }\n          REP(k,l){\n            if (((i>>k)&1)==0) {\n              int sj,se,tj,te;\n              tie(sj,se) = siro[j];\n              tie(tj,te) = siro[k];\n              dp[i|(1<<k)][k] = min(dp[i|(1<<k)][k], dp[i][j] + dist[sj][tj] + te);\n            }\n          }\n        }\n      }\n    }\n    cout<<num<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int INF = 1e9;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint D[1<<16][N];\nint dijkstra(){\n  for(int i=0;i<(1<<l);i++)\n    for(int j=0;j<n;j++) D[i][j] = T+1;\n  \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s))),D[1<<idx[s]][s]= SIRO[s];\n  Q.push(PP(0,P(0,s))),D[0][0] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;s--;\n    if(!n&&!m&&!l&&!T)return 0;\n    for(int i=0;i<N;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    memset(idx,0,sizeof(idx));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,l,s,inf=1e5+1,t,a,c,b,ok;\nint g[305][305],G[305][305],re;\nint ind[25],cost[25],dp[20][(1<<18)];\n\n\nint f(int cur,int vis){\nif(dp[cur][vis]!=-1) return dp[cur][vis];\nif((vis&(~(1<<cur)))==0) return dp[cur][vis]=G[l][cur]+cost[cur];\ndp[cur][vis]=1e9;\nfor(int j=0;j<l;j++){\n    if((j!=cur)&&(((1<<j)&vis)!=0)){\n        dp[cur][vis]=min(dp[cur][vis],f(j,vis&(~(1<<cur)))+G[j][cur]);\n    }\n}\ndp[cur][vis]+=cost[cur];\nreturn dp[cur][vis];\n}\n\nint main(){\nwhile(cin>>n>>m>>l>>s>>t){\n    if(n+m+l+s+t==0) break;\n    memset(dp,-1,sizeof(dp));s--;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++) g[i][j]=inf;\n        g[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        cin>>a>>b>>c;\n        a--;b--;\n        g[a][b]=c;\n        g[b][a]=c;\n    }\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++)\n                g[i][j]=min(g[i][k]+g[k][j],g[i][j]);\n        }\n    }\n    for(int i=0;i<l;i++){\n        cin>>ind[i]>>cost[i];\n        ind[i]--;\n    }\n    for(int i=0;i<l;i++){\n        G[i][l]=g[ind[i]][s];\n        G[l][i]=g[ind[i]][s];\n        for(int j=0;j<l;j++) G[i][j]=g[ind[i]][ind[j]];\n    }\n    re=0;\n    for(int i=0;i<(1<<l);i++){\n        int cnt=0;\n        for(int j=0;j<l;j++) if(i&(1<<j)) cnt++;\n        for(int j=0;j<l;j++){\n            if(i&(1<<j)){\n                if(f(j,i)+G[j][l]<=t) re=max(re,cnt);\n            }\n        }\n    }\n    cout<<re<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\nmemset(dp,-1,sizeof(dp));\ng.assign(n+1,vector<int>(n+1,inf));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct Station{\n    map<int, int> timeTo; // time[nextStation]\n};\nmap<int, Station> stations;\n\nint s;\nint maxNum;\n\nvoid trip(int i, int rest, map<int, bool> ate){\n    if( i == s && maxNum < ate.size()){\n        maxNum = ate.size();\n    }\n    for(auto it = stations[i].timeTo.begin(); it != stations[i].timeTo.end(); ++it){\n        if(rest - it->second < 0){\n            continue;\n        }\n        if(i == it->first){\n            if(ate.find(i) != ate.end()){\n                continue;\n            }\n            ate[i] = true;\n        }\n        trip(it->first, rest - it->second, ate);\n    }\n}\n\nint main(){\n    int n,m,l,t;\n    while(1){\n        cin >> n >> m >> l >> s >> t;\n        if(n == 0){\n            break;\n        }\n        stations.clear();\n        for(int i = 0; i < m; ++i){\n            int a,b,c;\n            cin >> a >> b >> c;\n            stations[a].timeTo[b] = c;\n            stations[b].timeTo[a] = c;\n        }\n        for(int i = 0; i < l; ++i){\n            int j,e;\n            cin >> j >> e;\n            stations[j].timeTo[j] = e;\n        }\n        // cout << \"old: \" << stations.size() << endl;\n        // remove station if it hasn't SIRO.\n        for(auto target = stations.begin(); target != stations.end(); ){\n            auto& nextStations = target->second.timeTo;\n            const bool hasSiro = nextStations.find(target->first) != nextStations.end();\n            if(hasSiro || target->first == s){\n                ++target;\n                continue;\n            }\n            // reconnect\n            for(auto nextStation = nextStations.begin(); nextStation != nextStations.end(); ++nextStation){\n                auto& connectTargets = stations[target->first].timeTo;\n                auto next = stations[nextStation->first];\n                for(auto connectTarget = connectTargets.begin(); connectTarget != connectTargets.end(); ++connectTarget){\n                    if(nextStation->first == connectTarget->first){\n                        continue;\n                    }\n                    auto targetStation = stations[target->first];\n                    auto hogeTime = next.timeTo[target->first] + targetStation.timeTo[connectTarget->first];\n                    auto hoge = next.timeTo.find(connectTarget->first);\n                    if(hoge == next.timeTo.end()){\n                        hoge->second = hogeTime;\n                    }else{\n                        if(hoge->second > hogeTime){\n                            hoge ->second = hogeTime;\n                        }\n                    }\n                }\n                next.timeTo.erase(target->first);\n            }\n            target = stations.erase(target);\n        }\n        maxNum = 0;\n        // cout << \"new: \" << stations.size() << endl << endl;\n        map<int, bool> ate;\n        trip(s, t, ate);\n        cout << maxNum << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\nstruct edge{ int to,cost; };\n\nconst int N=300, INF=123456789;\nvector<edge> G[N];\n\nint dp[16][1<<16];\nint dist[16][16];\n\nint d[N];\nvoid dijkstra(int start)\n{\n    fill(d,d+N,INF);\n\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n    d[start]=0;\n    que.push(pi(0,start));\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n,m,l,s,t;\n    while(scanf(\" %d %d %d %d %d\", &n, &m, &l, &s, &t),n)\n    {\n        --s;\n        rep(i,N) G[i].clear();\n\n        rep(i,m)\n        {\n            int a,b,c;\n            scanf(\" %d %d %d\", &a, &b, &c);\n            --a;\n            --b;\n            G[a].pb(edge{b,c});\n            G[b].pb(edge{a,c});\n        }\n\n        vector<int> J(l), E(l);\n        rep(i,l)\n        {\n            scanf(\" %d %d\", &J[i], &E[i]);\n            --J[i];\n        }\n\n        fill(dp[0],dp[16],INF);\n\n        // ??????????????°?????????\n        dijkstra(s);\n        rep(i,l) dp[i][1<<i] = d[J[i]] + E[i];\n\n        rep(i,l)\n        {\n            dijkstra(J[i]);\n            rep(j,l) dist[i][j] = d[J[j]];\n        }\n\n        for(int mask=1; mask<(1<<l); ++mask)rep(last,l)\n        {\n            if(!(mask>>last&1)) continue;\n\n            rep(nx,l)if(!(mask>>nx&1))\n            {\n                int nmask = mask|(1<<nx);\n                dp[nx][nmask] = min(dp[nx][nmask], dp[last][mask] + dist[last][nx] + E[nx]);\n            }\n        }\n\n        int ans=0;\n\n        dijkstra(s);\n        rep(mask,1<<l)\n        {\n            rep(i,l)\n            {\n                if(dp[i][mask] + d[J[i]] <= t) ans=max(ans,__builtin_popcount(mask));\n            }\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int INF = 1e9;\nvector<P> G[N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint D[1<<16][N];\nint dijkstra(){\n  for(int i=0;i<(1<<l);i++)\n    for(int j=0;j<n;j++) D[i][j] = T+1;\n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  if(SIRO[s])Q.push(PP(SIRO[s],P(1<<idx[s],s)));\n  Q.push(PP(0,P(0,s)));\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      int nbit = bit;\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n      \n      if(SIRO[npos]) nbit |= 1<<idx[npos],ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;s--;\n    if(!n)return 0;\n    for(int i=0;i<n;i++)G[i].clear();\n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n    }\n\n    memset(SIRO,0,sizeof(SIRO));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define falze(n)\t\tmemset(n,false,sizeof(n))\n#define zero(n)\t\t\tmemset(n,0,sizeof(n))\n#define init(n)\t\t\tmemset(n,-1,sizeof(n))\n#define REP(i,n) \t\tfor(i=0;i<n;i++)\n#define FOR(i,a,b) \t\tfor(i=a;i<=b;i++)\n#define FORD(i,a,b) \tfor(i=a;i>=b;i--)\n#define FOR2(i,a,b,c) \tfor(i=a;i<=b;i+=c)\n#define FORD2(i,a,b,c)\tfor(i=a;i>=b;i-=c)\n#define mod(x,y) \t\t(((x%y)<0)?((x%y)+y):(x%y))\n#define PB \t\t\t\tpush_back\n#define endll \t\t\t\"\\n\"\n#define INF \t\t\t0x3FFFFFFF\n#define in(a,b)\t\t\tsubstr(a,b-a+1) // INCLUSIVE\n#define ff\t\t\t\tfirst\n#define ss\t\t\t\tsecond\n#define LEN(x)\t\t\t((ll)x.size())\n#define mm\t\t\t\t1000000007\n#define check(x)\t\t(((x%=mm)+=mm)%=mm)\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n\nll n,m,len;\nll d[200004];\n\nint main(){\n\tll i,j,k,t,a,b;\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(NULL);\n\t//cout.tie(NULL);\n\t\n\t//freopen(\"input.in\", \"r\",stdin);\n\t//freopen(\"output.out\",\"w\",stdout);\n\t\n\tll tot = 0LL;\n\tscanf(\"%lld%lld\", &n, &a);\n\tREP(i,n)\n\t{\n\t\tscanf(\"%lld\", &d[i]);\n\t\ttot += d[i];\n\t}\n\tREP(i,n)\n\t{\n\t\tll mak = a-n+1LL,\n\t\t\tmik = a-tot+d[i];\n\t\t\n\t\tif (mak > d[i]) mak = d[i];\n\t\tif (mik < 1LL) mik = 1LL;\n\t\t\n\t\tprintf(\"%s%lld\", (i?\" \":\"\"), (d[i]-(mak-mik+1LL)));\n\t}\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\nmemset(dp,-1,sizeof(dp));\ng.assign(n+1,vector<int>(n+1,inf));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  const int INF = 1e9;\n  int n, m, l, s, t;\n  int dp[1 << 16][17];\n  \n  while (cin >> n >> m >> l >> s >> t && n ){\n    vector<vector<pair<int, int> > > G(n);\n    \n    REP(i, m){\n      int a, b, c;\n      cin >> a >> b >> c; a--, b--;\n      G[a].push_back(make_pair(b, c));\n      G[b].push_back(make_pair(a, c));\n    }\n    \n    vector<int> S(l + 1);\n    vector<int> E(l + 1);\n    vector<vector<int> >C(l + 1, vector<int>(l + 1));\n    \n    REP(i, l){\n      cin >> S[i] >> E[i]; S[i]--;\n    }\n    \n    S[l] = s - 1;\n    E[l] = 0;\n\n    REP(i, l + 1){\n      typedef pair<int, int> P;\n      \n      vector<int> D(n, INF);\n      priority_queue<P, vector<P>, greater<P>> que;\n      \n      que.push(P(0, S[i]));\n      D[S[i]] = 0;\n\n      while (!que.empty()){\n        int v = que.top().second;\n        int c = que.top().first;\n        que.pop();\n\n        if (D[v] < c) continue;\n\n        REP(i, G[v].size()){\n          int to = G[v][i].first;\n          int nc = c + G[v][i].second;\n\n          if (D[to] > nc){\n            D[to] = nc;\n            que.push(P(nc, to));\n          }\n        }\n      }\n      \n      REP(j, l + 1) C[i][j] = D[S[j]];\n    }\n\n    fill(&dp[0][0], &dp[0][0] + 17 * (1 << 16), INF);\n    dp[0][l] = 0;\n    \n    int res = 0;\n    \n    REP(mask, 1 << l) REP(u, l + 1) if (dp[mask][u] < INF){\n\n      if (dp[mask][u] + C[u][l] <= t){\n        res = max(res, __builtin_popcount(mask));\n      } else {\n        continue;\n      }\n      \n      REP(v, l + 1){\n        int nc = dp[mask][u] + C[u][v] + E[v];\n        int nm = v == l ? mask : (mask | (1 << v));\n\n        if (dp[nm][v] == -1 || dp[nm][v] > nc){\n          dp[nm][v] = nc;\n        }\n      }\n    }\n    \n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<18][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse{\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=0;\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]=dp[i1][xz]+1;\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=z;\n    g[y][x]=z;\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<=l;i++){\n    vector<int> vv;\n    for(int j=0;j<=l;j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tvoid set(int arg_state,int arg_station,int arg_total_time,int arg_eat_num){\n\t\tstate = arg_state;\n\t\tstation = arg_station;\n\t\ttotal_time = arg_total_time;\n\t\teat_num = arg_eat_num;\n\t}\n\tint state,station,total_time,eat_num;\n};\n\nint N,M,L,start,TIME_LIMIT,cost[301][301];\nint POW[17],eat_time[301];\nint** min_Time;\n\nvoid func(){\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k)cost[i][k] = BIG_NUM;\n\t\t\telse{\n\t\t\t\tcost[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,tmp_cost;\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&tmp_cost);\n\t\tcost[from][to] = tmp_cost;\n\t\tcost[to][from] = tmp_cost;\n\t}\n\n\tvector<int> V;\n\n\tint left,right;\n\n\tfor(int i = 0; i < L; i++){\n\t\tscanf(\"%d %d\",&left,&right);\n\t\teat_time[left] = right;\n\t\tV.push_back(left);\n\t}\n\n\tfor(int mid = 1; mid <= N; mid++){\n\t\tfor(int st = 1; st <= N; st++){\n\t\t\tif(cost[st][mid] == BIG_NUM)continue;\n\t\t\tfor(int gl = 1; gl <= N; gl++){\n\t\t\t\tif(cost[mid][gl] == BIG_NUM)continue;\n\t\t\t\tcost[st][gl] = min(cost[st][gl],cost[st][mid]+cost[mid][gl]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint limit = POW[L];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 0; k < limit; k++)min_Time[i][k] = BIG_NUM;\n\t}\n\n\tInfo first;\n\tfirst.station = start;\n\tfirst.state = 0;\n\tfirst.total_time = 0;\n\tfirst.eat_num = 0;\n\n\tmin_Time[start][0] = 0;\n\n\tint ans = 0,next_station,next_state;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().state == limit-1){\n\t\t\tans = L;\n\t\t\tbreak;\n\t\t}else if(Q.front().total_time > min_Time[Q.front().station][Q.front().state]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tfor(int loop = 0; loop < L; loop++){\n\n\t\t\t\tif(Q.front().state & (1 << loop)){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tnext_station = V[loop];\n\n\t\t\t\t\tif(cost[Q.front().station][next_station] != BIG_NUM && cost[next_station][start] != BIG_NUM &&\n\t\t\t\t\t\t\tQ.front().total_time+cost[Q.front().station][next_station]+eat_time[V[loop]] + cost[next_station][start] <= TIME_LIMIT){\n\n\t\t\t\t\t\tnext_state = Q.front().state + POW[loop];\n\t\t\t\t\t\tif(min_Time[next_station][next_state] > Q.front().total_time+cost[Q.front().station][next_station]+eat_time[V[loop]]){\n\t\t\t\t\t\t\tmin_Time[next_station][next_state] = Q.front().total_time+cost[Q.front().station][next_station]+eat_time[V[loop]];\n\t\t\t\t\t\t\tans = max(ans,Q.front().eat_num+1);\n\t\t\t\t\t\t\tInfo new_info;\n\t\t\t\t\t\t\tnew_info.set(next_state,next_station,min_Time[next_station][next_state],Q.front().eat_num+1);\n\n\t\t\t\t\t\t\tQ.push(new_info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tmin_Time = new int*[301];\n\tfor(int i = 1; i <= 300; i++){\n\t\tmin_Time[i] = new int[POW[16]];\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&L,&start,&TIME_LIMIT);\n\t\tif(N == 0 && M == 0 && L == 0 && start == 0 && TIME_LIMIT == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{\n  int v,c;\n};\n\nstruct S{\n  int v,t,b;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nbool u[323][1<<16];\n\nint main(){\n  for(int n,m,l,s,t;cin>>n>>m>>l>>s>>t,n|m|l|s|t;){\n    int d[323][323];\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\td[i][j]=(i==j)?0:1e9;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      d[a][b]=d[b][a]=c;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tfor(int k=0;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int js[323],e[323];\n    for(int i=0;i<l;i++){\n      cin>>js[i]>>e[i];\n    }\n    vector<edge> G[17];\n    for(int i=0;i<l;i++){\n      for(int j=0;j<l;j++){\n\tif(i!=j&&d[js[i]][js[j]]<1e8){\n\t  G[i].push_back({j,d[js[i]][js[j]]});\n\t}\n      }\n      if(d[js[i]][s]<1e8){\n\tG[l].push_back({i,d[js[i]][s]});\n\tG[i].push_back({l,d[js[i]][s]});\n      }\n    }\n    priority_queue<S> que;\n    que.push({l,0,0});\n    int ans=0;\n    fill(*begin(u),*end(u),false);\n    while(!que.empty()){\n      auto c=que.top();\n      if(c.t>t)break;\n      que.pop();\n      if(u[c.v][c.b]++)continue;\n      if(c.v==l){\n\tans=max(ans,__builtin_popcount(c.b));\n      }\n      for(auto elm:G[c.v]){\n\tque.push({elm.v,c.t+elm.c,c.b});\n      }\n      if(c.v<l){\n\tque.push({c.v,c.t+e[c.v],c.b|1<<c.v});\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\n\nsigned main(){\n\tint n,m,c,s,t;\n\twhile(cin>>n>>m>>c>>s>>t,n){\n\t\tvvp G(n);\n\t\tvvi cost(n,vi(n,inf));\n\t\trep(i,n)cost[i][i]=0;\n\t\trep(i,m){\n\t\t\tint a,b,co;\n\t\t\tcin>>a>>b>>co;\n\t\t\ta--;b--;\n\t\t\tG[a].pb({b,co});\n\t\t\tG[b].pb({a,co});\n\t\t\tcost[a][b]=cost[b][a]=co;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tcmin(cost[i][j],cost[i][k]+cost[k][j]);\n\t\tvvi in(c,vi(2));\n\t\trep(i,c)rep(j,2)cin>>in[i][j];\n\t\ts--;\n\t\tvvi dp(1<<c,vi(c,inf));\n\t\trep(i,c)dp[1<<i][i]=cost[s][in[i][0]-1]+in[i][1];\n\t\trep(i,1<<c)rep(j,c)if(dp[i][j]-inf){\n\t\t\trep(k,c)if((i&1<<k)==0)\n\t\t\t\tcmin(dp[i|1<<k][k],dp[i][j]+cost[in[j][0]-1][in[k][0]-1]+in[k][1]);\n\t\t}\n\t\t// show2d(dp);\n\t\tint out=0;\n\t\trep(i,1<<c)rep(j,c)if(dp[i][j]+inf){\n\t\t\tint dist=dp[i][j]+cost[in[j][0]-1][s];\n\t\t\tif(dist<=t){\n\t\t\t\tint co=0;\n\t\t\t\trep(k,c)if(i&1<<k)co++;\n\t\t\t\tcmax(out,co);\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint n, m, l, s, t;\nvoid solve() {\n\ts--;\n\tvector < vector<ll>> d(n);\n\trep(i, n) {\n\t\td[i].resize(n, INF);\n\t\td[i][i] = 0;\n\t}\n\trep(i, m) {\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\td[a][b] = d[b][a] = min(d[b][a],(ll)c);\n\t}\n\trep(k, n) {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll> e(l);\n\tvector<int> k(l);\n\trep(i, l) {\n\t\tcin >> k[i] >> e[i]; k[i]--;\n\t}\n\tvector<vector<ll>> dp;\n\tvector<vector<bool>> used;\n\tdp.resize(1 << l); used.resize(1 << l);\n\trep(i, (1 << l)) {\n\t\tdp[i].resize(l, INF); used[i].resize(l, false);\n\t}\n\tqueue<P> q;\n\trep(i, l) {\n\t\tdp[(1<<i)][i] = d[s][k[i]];\n\t\tq.push({(1<<i),i});\n\t}\n\twhile (!q.empty()) {\n\t\tP p = q.front(); q.pop();\n\t\tint sp = p.first; int id = p.second;\n\t\trep(j, l) {\n\t\t\tif (sp&(1 << j))continue;\n\t\t\tll nd = dp[sp][id] + d[k[id]][k[j]];\n\t\t\tint ns = sp ^ (1 << j);\n\t\t\tdp[ns][j] = min(dp[ns][j], nd);\n\t\t\tif (!used[ns][j]) {\n\t\t\t\tused[ns][j] = true; q.push({ ns,j });\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, (1 << l)) {\n\t\tint cnt = 0;\n\t\tll csum = 0;\n\t\trep(j, l) {\n\t\t\tif (i&(1 << j)) {\n\t\t\t\tcnt++;\n\t\t\t\tcsum += e[j];\n\t\t\t}\n\t\t}\n\t\trep(j, l) {\n\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\tll sum = csum+dp[i][j] + d[k[j]][s];\n\t\t\tif (sum <= t) {\n\t\t\t\t//cout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t\t\tans = max(ans, cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >> n >> m>>l>>s>>t, n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return 0;\nelse{\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    dp[i1][xz]=dp[i1][xz];\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct edge{\n  int v,c;\n};\n\nstruct S{\n  int v,t,b;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nbool u[323][1<<16];\n\nint main(){\n  for(int n,m,l,s,t;cin>>n>>m>>l>>s>>t,n|m|l|s|t;){\n    vector<edge> G[323];\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      G[a].push_back({b,c});\n      G[b].push_back({a,c});\n    }\n    int idx[323],e[323];\n    fill(begin(idx),end(idx),-1);\n    for(int i=0;i<l;i++){\n      int j;\n      cin>>j;\n      idx[j]=i;\n      cin>>e[j];\n    }\n    priority_queue<S> que;\n    que.push({s,0,0});\n    int ans=0;\n    fill(*begin(u),*end(u),false);\n    while(!que.empty()){\n      auto c=que.top();\n      if(c.t>t)break;\n      que.pop();\n      if(u[c.v][c.b]++)continue;\n      if(c.v==s){\n\tans=max(ans,__builtin_popcount(c.b));\n      }\n      for(auto e:G[c.v]){\n\tque.push({e.v,c.t+e.c,c.b});\n      }\n      if(idx[c.v]>=0){\n\tque.push({c.v,c.t+e[c.v],c.b|1<<idx[c.v]});\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return 0;\nelse{\n    num++;\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return num+dp[i1][xz]-1;\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n\nint dp[(1<<18)][20];\n\nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int i=1; i<=n; i++) v[i][i]=0;\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n\tfor(int j=1; j<=n; j++) {\n\t  if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n\n    fill(dp[0],dp[(1<<l)],MAX);\n    dp[0][l-1]=0;\n    /*\n    for(int i=0; i<l; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    */\n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n\tif(dp[p][i]!=MAX) {\n\t  if(i==l-1) {\n\t    int cnt=0;\n\t    for(int j=0; j<l-1; j++) {\n\t      if(p&(1<<j)) cnt++;\n\t    }\n\t    if(cnt>ans) ans=cnt;\n\t  }\n\n\t  for(int j=0; j<l; j++) {\n\t    if(!(p&(1<<j))) {\n\t      dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n\t      if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n\t    }\n\t  }\n\t}\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int INF = (1 << 29);\n\ninline void warshall_floyd(vector<vector<int>> &mat) {\n\tconst int n = mat.size();\n\tfor(int k = 0; k < n; ++k) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint tsp(int limit, const vector<int> &s_cost, const vector<vector<int>> &mat, const vector<int> &eat) {\n\tconst int n = mat.size();\n\tvector<vector<int>> dp(1 << n, vector<int>(n, INF));\n\tfor(int v = 0; v < n; ++v) {\n\t\tdp[1 << v][v] = s_cost[v] + eat[v];\n\t}\n\n\tint res = 0;\n\tfor(int used = 1; used < (1 << n); ++used) {\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(!(used & (1 << v)) || dp[used][v] + s_cost[v] > limit) continue;\n\t\t\tchmax(res, __builtin_popcount(used));\n\n\t\t\tfor(int to = 0; to < n; ++to) {\n\t\t\t\tif(used & (1 << to)) continue;\n\t\t\t\tchmin(dp[used | (1 << to)][to], dp[used][v] + mat[v][to] + eat[to]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, l, s, t; cin >> n >> m >> l >> s >> t && n;) {\n\t\t--s;\n\t\tvector<vector<int>> mat(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tmat[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t--a; --b;\n\t\t\tmat[a][b] = mat[b][a] = c;\n\t\t}\n\n\t\twarshall_floyd(mat);\n\n\t\tvector<int> jiro(l);\n\t\tvector<int> eat_time(l);\n\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\tcin >> jiro[i] >> eat_time[i];\n\t\t\t--jiro[i];\n\t\t}\n\n\t\tvector<vector<int>> mat_jiro(l, vector<int>(l));\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\tfor(int j = i + 1; j < l; ++j) {\n\t\t\t\tmat_jiro[i][j] = mat_jiro[j][i] = mat[jiro[i]][jiro[j]];\n\t\t\t}\n\t\t}\n\n\t\tvector<int> s_cost(l);\n\t\tfor(int i = 0; i < l; ++i) {\n\t\t\ts_cost[i] = mat[s][jiro[i]];\n\t\t}\n\n\t\tcout << tsp(t, s_cost, mat_jiro, eat_time) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nconst int MAX=1000000007;\n\nint main() {\n  int n,m,l,s,t;\n  while(cin >> n >> m >> l >> s >> t && n) {\n    int v[n+1][n+1];\n    fill(v[0],v[n+1],MAX);\n    for(int i=0; i<m; i++) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      v[x][y]=z;\n      v[y][x]=z;\n    }\n    for(int k=1; k<=n; k++) {\n      for(int i=1; i<=n; i++) {\n\tfor(int j=1; j<=n; j++) {\n\t  if(v[i][k]!=MAX && v[k][j]!=MAX) v[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\n      }\n    }\n    P r[l+1];\n    for(int i=0; i<l; i++) cin >> r[i].F >> r[i].S;\n    r[l].F=s;r[l].S=0;\n    l++;\n    int dp[(1<<l)][l+1];\n    fill(dp[0],dp[(1<<l)],MAX);\n    dp[0][l-1]=0;\n    \n    for(int i=0; i<l-1; i++) {\n      dp[(1<<i)][l-1]=v[r[i].F][s]+r[i].S;\n      if(dp[(1<<i)][l-1]>t) dp[(1<<i)][l-1]=MAX;\n    }\n    \n    int ans=0;\n    for(int p=0; p<(1<<l); p++) {\n      for(int i=0; i<l; i++) {\n\tif(dp[p][i]!=MAX) {\n\t  int cnt=0;\n\t  for(int j=0; j<l; j++) {\n\t    if(p&(1<<j)) cnt++;\n\t  }\n\t  if(cnt>ans) ans=cnt-1;\n\n\t  for(int j=0; j<l; j++) {\n\t    if(!(p&(1<<j))) {\n\t      dp[p|(1<<j)][j]=min(dp[p|(1<<j)][j],dp[p][i]+v[r[j].F][r[i].F]+r[j].S);\n\t      if(dp[p|(1<<j)][j]>t) dp[p|(1<<j)][j]=MAX;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=305,INF=1<<30;\nint N;\nll dis[MAX][MAX],dp[1<<17][17];\n\nvoid floyd(){\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                chmin(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int M,l,s,t;\n        cin>>N>>M>>l>>s>>t;\n        s--;\n        if(N==0) break;\n        for(int i=0;i<N;i++) for(int j=0;j<N;j++) dis[i][j]=INF;\n        for(int bit=0;bit<(1<<(l+1));bit++) for(int i=0;i<l+1;i++) dp[bit][i]=INF;\n        for(int i=0;i<M;i++){\n            int a,b,c;cin>>a>>b>>c;\n            a--;b--;\n            chmin(dis[a][b],ll(c));\n            chmin(dis[b][a],ll(c));\n        }\n        \n        floyd();\n        \n        vector<int> pos(l+1),cost(l+1);\n        for(int i=1;i<=l;i++){\n            cin>>pos[i]>>cost[i];\n            pos[i]--;\n        }\n        pos[0]=s;\n        cost[0]=0;\n        \n        dp[0][0]=0;\n        \n        for(int bit=0;bit<(1<<(l+1));bit++){\n            for(int i=0;i<l+1;i++){\n                if(bit&&(!(bit&(1<<i)))) continue;\n                if(dp[bit][i]>t) continue;\n                \n                for(int j=0;j<l+1;j++){\n                    if(i==j) continue;\n                    if(bit&(1<<j)) continue;\n                    \n                    chmin(dp[bit|(1<<j)][j],dp[bit][i]+dis[pos[i]][pos[j]]+cost[j]);\n                }\n            }\n        }\n        \n        int ans=0;\n        \n        for(int bit=1;bit<(1<<(l+1));bit+=2) if(dp[bit][0]<=t) chmax(ans,__builtin_popcount(bit)-1);\n        \n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<typename T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\ntemplate<class T> T EPS(){assert(false);};\ntemplate<> int EPS<int>(){return 1;};\ntemplate<> ll EPS<ll>(){return 1LL;};\ntemplate<> double EPS<double>(){return 1e-8;};\ntemplate<> long double EPS<long double>(){return 1e-8;};\n\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntypedef int Cost; Cost CINF=1<<28;\nstruct Edge{\n\tint f,t;Cost c;\n\tEdge(int f,int t,Cost c) : f(f),t(t),c(c) {};\n\tbool operator<(Edge r) const{return c<r.c;}\n\tbool operator>(Edge r) const{return c>r.c;}\n};\ntypedef vector<vector<Edge> >  Graph;\n\nstruct Task{\n    int prev,pos;Cost c;\n    Task(int prev,int pos,Cost c)\n        :prev(prev),pos(pos),c(c){};\n    bool operator>(const Task& r) const{ return c > r.c;}\n};\nvector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n    const int V=g.size();\n    vector<Cost> d(V,CINF);d[s]=0;\n    fill(ALL(prev), -2);\n    \n    priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(-1,s,0));// [ ,e,,f, ] <=> e.cost < e.cost\n    vector<bool> visited(V);\n    while(!que.empty()){\n        Task task=que.top();que.pop();\n        if(visited[task.pos])continue;\n        visited[task.pos]=true;\n        prev[task.pos]=task.prev;\n        EACH(e,g[task.pos])if(d[e->t]>d[e->f]+e->c){\n            d[e->t]=d[e->f]+e->c;\n            que.push(Task(e->f,e->t,d[e->t]));\n        }   \n    }\n    return d;\n}\nvector<Cost> dijkstra(const Graph& g,const int s){\n    vector<int> prev(g.size());return dijkstra(g,s,prev);\n}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint n,m,l,s,t;cin >> n >> m >> l >> s >> t;if(n==0)break;\n\t\t\ts--;\n\t\t\tGraph g(n);\n\t\t\tREP(i,m){\n\t\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\t\tg[a].push_back(Edge(a,b,c));\n\t\t\t\tg[b].push_back(Edge(b,a,c));\n\t\t\t}\n\n\t\t\tjs.clear();\n\t\t\tREP(i,l){\n\t\t\t\tint v,e;cin >> v >> e;v--;\n\t\t\t\tjs[v]=e;\n\t\t\t}\n\n\t\t\tenc.clear();EACH(it,js)enc[it->first]=0;enc[s]=0;\n\t\t\tN=0;EACH(it,enc)enc[it->first]=N++;\n\t\t\tdec.clear();EACH(it,enc)dec[it->second]=it->first;\n\n\t\t\tds = vector<vector<int>> (N,vector<int>(N));\n\t\t\tEACH(it,dec){\n\t\t\t\tvector<int> d=dijkstra(g,it->second);\n\t\t\t\tEACH(itj,dec)ds[it->first][itj->first]=d[itj->second];\n\t\t\t}\n\t\t\t\t\n\t\t\tdp =vector<vector<int>>(N,vector<int>(1<<N,INF<int>()));\n\t\t\tdp[enc[s]][0]=0;\n\t\t\tREP(i,N)REP(bit,1<<N)rec(i,bit);\n\n\t\t\tint Mv=0;\n\t\t\tREP(i,N)REP(bit,1<<N)if(dp[i][bit]+ds[i][enc[s]]<=t){\n\t\t\t\tint bc=0;REP(k,N)if(bit&(1<<k))bc++;\n\t\t\t\tMv=max(Mv,bc);\n\t\t\t}\n\t\t\tcout << Mv <<endl;\n\t\t}\n\t}\n\t\n\tmap<int,int> js;\n\tmap<int,int> enc;\n\tmap<int,int> dec;\n\tvector<vector<int>> dp;\n\tvector<vector<int>> ds;\n\tint N;\n\tint rec(int i,int bit){\n\t\tif(dp[i][bit]!=INF<int>())return dp[i][bit];\n\t\tif(((bit>>i)&1) && js.count(dec[i])){\n\t\t\tREP(j,N)dp[i][bit]=min(dp[i][bit],rec(j,bit-(1<<i))+ds[j][i]+js[dec[i]]);\n\t\t}\n\t\treturn dp[i][bit];\n\t}\n\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nint SIRO[N];\nint idx[N];\nint n,m,l,s,T;\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  vector<vector<int> >used(1<<l,vector<int>(n,0));   \n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  Q.push(PP(0,P(0,s))),D[0][s] = 0;\n\n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost||used[bit][pos]++)continue;\n    \n    if(pos == s)res = max(res,__builtin_popcount(bit));\n\n    for(int i=0;i<n;i++){\n      int npos = i;\n      int ncost = cost+G[pos][i];\n      int nbit = bit;\n      if(SIRO[npos]==0||bit>>idx[npos]&1)continue;\n      nbit |= 1<<idx[npos];\n      ncost+=SIRO[npos];\n      if(D[nbit][npos]>ncost){\n\tQ.push(PP(ncost,P(nbit,npos)));\n\tD[nbit][npos] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++) G[i][j] = T+1;\n      G[i][i] = 0;\n    }\n\n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a][b] = G[b][a] = c;\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    \n    memset(SIRO,0,sizeof(SIRO));\n    for(int i=0,j,e;i<l;i++)cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i;\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,M,L,S,T;\n#define INF ( 1<<27 )\nstruct edge{\n  int to,c;\n};\nstruct state{\n  int id,s,c;\n  bool operator>(const state &st) const{\n    return c > st.c;\n  }\n};\nvector<edge> G[22];\nint W[333][333];\nint J[20];\nint E[20];\nint h[21][(1<<16)];\nvoid solve(){\n  fill(h[0],h[L+1],T+1);\n  priority_queue<state,vector<state>,greater<state> > q;\n  q.push( (state){L,0,0} );\n  h[L][0] = 0;\n  while( !q.empty() ){\n    state st = q.top(); q.pop();\n    int id = st.id;\n    int bi = st.s;\n    int c = st.c;\n    //   cout << id <<  \" \" << bitset<6>(bi) << \" \" << c << endl;\n    // cout << \"JE \" << J[id] << \" \" << E[id] << endl;\n     if( id < L && (bi&(1<<id))==0 ){\n      int sbi = (bi |(1<<id));\n      if( h[id][sbi] > c + E[id] ){\n\th[id][sbi] = c + E[id];\n\tq.push( (state){id,sbi,c+E[id]} );\n      }\n    } \n    for(int i=0;i<(int)G[id].size();i++){\n      edge &e = G[id][i];\n      if( h[e.to][bi] > e.c + c ){\n\th[e.to][bi] = e.c + c;\n\tq.push( (state){e.to,bi,e.c+c} );\n      }\n    }\n  }\n  int res = 0;\n  for(int i=0;i<(1<<L);i++){\n    //    cout << S << \" \" << bitset<10>(i) << \" \"<< h[L][i] << endl;\n    if( h[L][i] <= T ){\n      res = max(res,__builtin_popcount(i));\n    }\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T && ( N||M||L||S||T ) ){\n    --S;\n    fill(W[0],W[N],INF);\n    for(int i=0;i<M;i++){\n      int a,b,c;\n      cin >> a>> b >> c ;\n      --a;--b;\n      W[a][b] = c;\n      W[b][a] = c;\n    }\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tfor(int k=0;k<N;k++)\n\t  W[j][k] = min(W[j][k],W[j][i] + W[i][k]);\n    for(int i=0;i<L;i++){\n      int j,e;\n      cin >> j >> e;\n      --j;\n      J[i] = j;\n      E[i] = e;\n    }\n    J[N] = S;\n    for(int i=0;i<=L;i++){\n      for(int j=i+1;j<=L;j++){\n\tint c = W[J[i]][J[j]];\n\tif( c < INF ) {\n\t  G[i].push_back( (edge){j,c} );\n\t  G[j].push_back( (edge){i,c} );\n\t}\n      }\n    }\n  \n    solve();\n\n    for(int i=0;i<=L;i++) G[i].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n \n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n \nconst int MAX_N = 17;\nconst int inf = (int)1e8;\nint V;\n \nint d[MAX_N][MAX_N];\nint dp[MAX_N][1 << MAX_N];\nint eat[MAX_N];\n \nint tsp(int v, int b) {\n    if(dp[v][b] != -1) return dp[v][b];\n    if(v == 0 && b == 0) return 0;\n    int res = inf;\n    for(int i = 0; i < V; i++) {\n        if(b & (1 << i)) {\n            res = min(res, tsp(i, b ^ (1 << i)) + d[i][v] + eat[i]);\n        }\n    }\n    return dp[v][b] = res;\n}\n \nint main() {\n    while(true) {\n        int N, M, L, S, T;\n        cin >> N >> M >> L >> S >> T;\n        if(N == 0 && M == 0 && L == 0 && S == 0 && T == 0) break;\n        vector<vector<int> > D(N, vector<int>(N, inf));\n        for(int i = 0; i < N; i++) {\n            D[i][i] = 0;\n        }\n        for(int i = 0; i < M; i++) {\n            int a, b, c; cin >> a >> b >> c;\n            a--, b--;\n            D[a][b] = c;\n            D[b][a] = c;\n        }\n \n        REP(k,N) REP(i,N) REP(j,N) {\n            D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n        }\n \n \n        V = L + 1;\n        vector<int> LS(V);\n        S--;\n        LS[0] = S;\n        eat[0] = 0;\n        for(int i = 1; i < V; i++) {\n            cin >> LS[i];\n            cin >> eat[i];\n            LS[i]--;\n        }\n        REP(i,V) {\n            REP(j,V) {\n                d[i][j] = D[LS[i]][LS[j]];\n            }\n        }\n \n        // REP(i,V) REP(j,V) cerr << i << \",\" << j << \" = \" << d[i][j] << endl;\n \n        memset(dp, -1, sizeof(dp));\n        int ans = 0;\n        for(int b = 0; b < (1 << V); b++) {\n            if(b & 1) { // 0 is houmonzumi\n                int cost = tsp(0, b);\n                if(cost <= T) ans = max(ans, __builtin_popcount(b) - 1);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 300\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint G[N][N];\nint SIRO[N],idx[N],g[N];\nint n,m,l,s,T;\n\n\nint dijkstra(){\n  vector<vector<int> >D(1<<l,vector<int>(n,T+1));   \n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n\n  Q.push(PP(0,P(0,s)));\n  D[0][s] = 0;\n  \n  int res = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int bit = t.second.first;\n    int pos = t.second.second;\n    if(D[bit][pos]<cost)continue;\n    if(pos == s)res = max(res,__builtin_popcount(bit));\n    \n    for(int j=0;j<=l;j++){\n      int i = g[j];\n      int ncost= cost+G[pos][i];\n      int nbit = bit;\n      \n      if(i==s||bit>>idx[i]&1)continue;\n      nbit|=1<<idx[i], ncost+=+SIRO[i];\n      if(D[nbit][i]>ncost){\n\tQ.push(PP(ncost,P(nbit,i)));\n\tD[nbit][i] = ncost;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>l>>s>>T;\n    if(!n&&!m&&!l&&!s&&!T)return 0;\n    s--;\n\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++) G[i][j] = T+1;\n      G[i][i] = 0;\n    }\n    \n    for(int i=0,a,b,c;i<m;i++){\n      cin>>a>>b>>c;a--,b--;\n      G[a][b] = G[b][a] = c;\n    }\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n    \n    memset(SIRO,0,sizeof(SIRO));\n    g[l] = s;\n    for(int i=0,j,e;i<l;i++){\n      cin>>j>>e,SIRO[j-1]=e,idx[j-1] = i,g[i] = j-1;\n    }\n    cout<< dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    //int src, to;\n    int to;\n    T cost;\n\n    edge() {}\n    //edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int to, T cost) : to(to), cost(cost) {}\n    //edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\ntemplate<typename T>\nvector<vector<T>> warshall_floyd(vector<vector<T>> g) {\n    const auto INF = numeric_limits<T>::max();\n    int n = g.size();\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (g[i][k] == INF or g[k][j] == INF) continue;\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            }\n        }\n    }\n    return g;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n, m, l, s, t;\n        cin >> n >> m >> l >> s >> t; --s;\n        if (n == 0) break;\n        vector<vector<edge<int>>> G(n);\n        for (int i = 0; i < m; ++i) {\n            int a, b, c; cin >> a >> b >> c; --a, --b;\n            G[a].emplace_back(b, c);\n            G[b].emplace_back(a, c);\n        }\n        vector<int> j(l+1), e(l+1);\n        for (int i = 0; i < l; ++i) {\n            cin >> j[i] >> e[i]; --j[i];\n        }\n        j[l] = s, e[l] = 0;\n        ++l;\n\n        const LL INF = numeric_limits<LL>::max();\n        auto mat = make_vector<LL>(n, n, INF);\n        for (int i = 0; i < n; ++i) {\n            mat[i][i] = 0;\n            for (const auto& eg : G[i]) {\n                mat[i][eg.to] = eg.cost;\n            }\n        }\n        mat = warshall_floyd(mat);\n        //for (int i = 0; i < n; ++i) {\n        //    DUMP(mat[i]);\n        //}\n\n        auto dp = make_vector<LL>(l, 1<<l, INF);\n        dp[l-1][0] = 0;\n        //for (int i = 0; i < l; ++i) {\n        //    DUMP(dp);\n        //}\n        for (int bit = 0; bit < 1<<l; ++bit) {\n            for (int u = 0; u < l; ++u) {\n                if (dp[u][bit] == INF) {\n                    continue;\n                }\n                for (int v = 0; v < l; ++v) if (u != v) {\n                    if (mat[j[u]][j[v]] == INF) {\n                        continue;\n                    }\n                    chmin(dp[v][bit | 1<<v],\n                            dp[u][bit] + mat[j[u]][j[v]] + e[v]);\n                }\n            }\n        }\n        //for (int i = 0; i < l; ++i) {\n        //    DUMP(dp);\n        //}\n\n        int ans = 0;\n        for (int bit = 0; bit < 1<<l; ++bit) {\n            if (dp[l-1][bit] <= t) {\n                chmax(ans, __builtin_popcount(bit) - 1);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define falze(n)\t\tmemset(n,false,sizeof(n))\n#define zero(n)\t\t\tmemset(n,0,sizeof(n))\n#define init(n)\t\t\tmemset(n,-1,sizeof(n))\n#define REP(i,n) \t\tfor(i=0;i<n;i++)\n#define FOR(i,a,b) \t\tfor(i=a;i<=b;i++)\n#define FORD(i,a,b) \tfor(i=a;i>=b;i--)\n#define FOR2(i,a,b,c) \tfor(i=a;i<=b;i+=c)\n#define FORD2(i,a,b,c)\tfor(i=a;i>=b;i-=c)\n#define mod(x,y) \t\t(((x%y)<0)?((x%y)+y):(x%y))\n#define PB \t\t\t\tpush_back\n#define endll \t\t\t\"\\n\"\n#define INF \t\t\t0xFFFFFFFFF\n#define in(a,b)\t\t\tsubstr(a,b-a+1) // INCLUSIVE\n#define ff\t\t\t\tfirst\n#define ss\t\t\t\tsecond\n#define LEN(x)\t\t\t((ll)x.size())\n#define mm\t\t\t\t1000000007\n#define check(x)\t\t(((x%=mm)+=mm)%=mm)\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n\nll n,m,len;\nll l,s;\nll rest[301];\nll eat[301];\nll dist[301][301];\n\nll dp[20][(1LL<<16)+1];\n\nll maxz;\n\n/*\ndp[i][j] = minimum time arriving at restaurant i and have visited\n\t\t   popcount(j) restaurants including i itself now  \n\t\t   (kth bit is on means it's visited)\n*/\n\nvoid solve(){\n\tll i,bs;\n\t\n\tREP(i,l) REP(bs,(1LL<<l)) {\n\t\t\n\t\tif(!(bs&(1LL<<i))){ \n\t\t\tdp[i][bs] = INF; \n\t\t\tcontinue; \n\t\t}\n\t\t\n\t\tif(__builtin_popcountll(bs) == 1){\n\t\t\tdp[i][bs] = dist[s][rest[i]] + eat[i];\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tll &ret = dp[i][bs];\n\t\tret = INF;\n\t\t\n\t\tll j; ll pbs = bs&(~(1<<i));\n\t\tREP(j,l) if(pbs&(1LL<<j)){\n\t\t\tret = min(ret, dp[j][pbs] + dist[rest[j]][rest[i]] + eat[i]);\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\tll i,j,k,t,a,b;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\t\n\t//freopen(\"input.in\", \"r\",stdin);\n\t//freopen(\"output.out\",\"w\",stdout);\n\t\n\t\n\twhile(cin >> n >> m >> l >> s >> t){\n\t\t\n\t\tif(n == 0 and m == 0 and l == 0 and s == 0 and t == 0)\n\t\t\treturn 0;\n\t\t\n\t\ts--;\n\t\t\n\t\tREP(i,n) REP(j,n) dist[i][j] = INF;\n\t\t\n\t\tREP(i,m){\n\t\t\tll c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tdist[a][b] = min(dist[a][b],c);\n\t\t\tdist[b][a] = min(dist[b][a],c);\n\t\t}\n\t\t\n\t\tREP(i,l){\n\t\t\tcin >> a >> b;\n\t\t\trest[i] = --a;\n\t\t\teat[i] = b;\n\t\t}\n\t\t\n\t\t// fw\n\t\tREP(k,n) REP(i,n) REP(j,n){\n\t\t\tdist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n\t\t}\n\t\t\n\t\tmaxz = 0;\n\t\tREP(i,l) REP(j,(1LL<<l)) dp[i][j] = INF;\n\t\tsolve();\n\t\t\n\t\tREP(i,l) REP(j,(1LL<<l)) if(j&(1LL<<i)){\n\t\t\tif(dp[i][j] >= 0 and dp[i][j] + dist[rest[i]][s] <= t){\n\t\t\t\tmaxz = max(maxz,(ll)__builtin_popcountll(j));\n\t\t\t}\n\t\t}\n\t\tcout << maxz << endll;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nusing namespace std;\ntypedef long long ll;\n \nconst ll INF = (ll)1e16;\nll n,m,l,s,t;\nll a,b,c;\nll r[20],e[20];\nll d[330][300], dis[20][20];\nll cycle[1<<20][20];\n \nint main(){\n  while(cin >> n >> m >> l >> s >> t, n){\n    rep(i,n)rep(j,n)d[i][j] = INF;\n    rep(i,n)d[i][i] = 0;\n \n    rep(i,m){\n      cin >> a >> b >> c; a--; b--;\n      d[a][b] = d[b][a] = c;\n    }\n \n    rep(k,n)rep(i,n)rep(j,n)d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n \n    rep(i,l)cin >> r[i] >> e[i];\n    \n    rep(i,l+1)rep(j,l+1)dis[i][j] = INF;\n    rep(i,l+1)dis[i][i] = 0;\n \n    rep(i,l)dis[l][i] = dis[i][l] = d[s-1][r[i]-1];\n    rep(i,l)rep(j,l)dis[i][j] = d[r[i]-1][r[j]-1];\n \n    rep(i,1<<(l+1))rep(j,l+1)cycle[i][j] = INF;\n    cycle[0][l] = 0;\n \n    rep(i,1<<(l+1)){\n      rep(j,l+1){\n\trep(k,l+1){\n\t  cycle[i|1<<j][k] = min(cycle[i|1<<j][k], cycle[i][j] + dis[j][k]);\n\t}\n      }\n    }\n \n    int ans = 0;\n    rep(bit,1<<(l+1)){\n      ll sum = 0;\n      rep(i,l){\n\tif((bit>>i)&1)sum += e[i];\n      }\n      if(sum + cycle[bit][l] <= t)ans = max(ans,__builtin_popcount(bit));\n    }\n    cout << ans-1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re<<endl;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\n#include <stack>\n#include <bitset>\n#define INF 0x3f3f3f3f\n#define eps 1e-8\n#define FI first\n#define SE second\nusing namespace std;\ntypedef long long LL;\nint G[305][305];\nint D[20][20],siro[20],cost[20];\nint dp[17][1<<16],bit[1<<16];\nbool done[17][1<<16];\nstruct node\n{\n    int u,st,dis;\n    inline node(int _u=0,int _st=0,int _dis=0)\n    {\n        u=_u; st=_st; dis=_dis;\n    }\n    inline bool operator <(const node &a)const\n    {\n        return dis>a.dis;\n    }\n};\npriority_queue <node> Q;\n\ninline void Dijkstra(int n,int t)\n{\n    memset(dp,0x3f,sizeof(dp));\n    memset(done,0,sizeof(done));\n    dp[0][0]=0;\n    Q.push(node(0,0,0));\n    node u;\n    while(!Q.empty())\n    {\n        u=Q.top(); Q.pop();\n        if(done[u.u][u.st]) continue;\n        done[u.u][u.st]=1;\n        for(int i=1;i<=n;++i) if(D[u.u][i]!=INF)\n        {\n            if(u.st&(1<<(i-1))) continue;\n            int v=u.dis+D[u.u][i]+cost[i];\n            if(v+D[0][i]>t) continue;\n            int nst=u.st|(1<<(i-1));\n            if(dp[i][nst]>v)\n            {\n                dp[i][nst]=v;\n                Q.push(node(i,nst,v));\n            }\n        }\n    }\n    int res=0;\n    for(int i=1;i<=n;++i)\n        for(int j=(1<<n)-1;j>=0;--j)\n            if(dp[i][j]+D[0][i]<=t) res=max(res,bit[j]);\n    printf(\"%d\\n\",res);\n}\n\ninline int bit_count(int st)\n{\n    int res=0;\n    for(;st;st^=st&-st) ++res;\n    return res;\n}\n\nint main()\n{\n    for(int i=(1<<16)-1;i>=0;--i) bit[i]=bit_count(i);\n    int n,m,l,s,t;\n    while(scanf(\"%d%d%d%d%d\",&n,&m,&l,&s,&t)&&n)\n    {\n        for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) G[i][j]=INF;\n        while(m--)\n        {\n            int u,v,w;\n            scanf(\"%d%d%d\",&u,&v,&w);\n            G[u][v]=G[v][u]=w;\n        }\n        for(int k=1;k<=n;++k)\n            for(int i=1;i<=n;++i)\n                for(int j=1;j<=n;++j)\n                {\n                    if(k==i||k==j||i==j) continue;\n                    G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n                }\n        for(int i=1;i<=l;++i) scanf(\"%d%d\",siro+i,cost+i);\n        siro[0]=s;\n        memset(D,0x3f,sizeof(D));\n        for(int i=0;i<=l;++i)\n            for(int j=i+1;j<=l;++j)\n                D[i][j]=D[j][i]=G[siro[i]][siro[j]];\n        Dijkstra(l,t);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\nusing namespace std;\n\ntypedef long long ll;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nclass range {\nprivate:\n\tstruct Iter{\n\t\tint v;\n\t\tint operator*(){return v;}\n\t\tbool operator!=(Iter& itr) {return v < itr.v;}\n\t\tvoid operator++() {++v;}\n\t};\n\tIter i, n;\npublic:\n\trange(int n) : i({0}), n({n}) {}\n\trange(int i, int n) : i({i}), n({n}) {}\n\tIter& begin() {return i;}\n\tIter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T>>& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){for(auto a:ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;for(auto& p:m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\ntemplate<typename T1> ostream& operator << (ostream& os, const tuple<T1>& t){os << get<0>(t);return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const tuple<T1,T2>& t){os << get<0>(t)<<\" \"<<get<1>(t);return os;}\ntemplate<typename T1,typename T2,typename T3> ostream& operator << (ostream& os, const tuple<T1,T2,T3>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t);return os;}\ntemplate<typename T1,typename T2,typename T3,typename T4,typename T5,typename T6,typename T7> ostream& operator << (ostream& os, const tuple<T1,T2,T3,T4,T5,T6,T7>& t){os << get<0>(t)<<\" \"<<get<1>(t)<<\" \"<<get<2>(t)<<\" \"<<get<3>(t)<<\" \"<<get<4>(t)<<\" \"<<get<5>(t)<<\" \"<<get<6>(t);return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<typename T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\n\ntemplate<class T> T EPS(){assert(false);};\ntemplate<> int EPS<int>(){return 1;};\ntemplate<> ll EPS<ll>(){return 1LL;};\ntemplate<> double EPS<double>(){return 1e-8;};\ntemplate<> long double EPS<long double>(){return 1e-8;};\n\n\ntemplate<typename T,typename U> T pmod(T v,U M){return (v%M+M)%M;}\n\n\ntypedef int Cost; Cost CINF=1<<28;\nstruct Edge{\n\tint f,t;Cost c;\n\tEdge(int f,int t,Cost c) : f(f),t(t),c(c) {};\n\tbool operator<(Edge r) const{return c<r.c;}\n\tbool operator>(Edge r) const{return c>r.c;}\n};\ntypedef vector<vector<Edge> >  Graph;\n\nstruct Task{\n    int prev,pos;Cost c;\n    Task(int prev,int pos,Cost c)\n        :prev(prev),pos(pos),c(c){};\n    bool operator>(const Task& r) const{ return c > r.c;}\n};\nvector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n    const int V=g.size();\n    vector<Cost> d(V,CINF);d[s]=0;\n    fill(ALL(prev), -2);\n    \n    priority_queue<Task,vector<Task>,greater<Task> > que;que.push(Task(-1,s,0));// [ ,e,,f, ] <=> e.cost < e.cost\n    vector<bool> visited(V);\n    while(!que.empty()){\n        Task task=que.top();que.pop();\n        if(visited[task.pos])continue;\n        visited[task.pos]=true;\n        prev[task.pos]=task.prev;\n        EACH(e,g[task.pos])if(d[e->t]>d[e->f]+e->c){\n            d[e->t]=d[e->f]+e->c;\n            que.push(Task(e->f,e->t,d[e->t]));\n        }   \n    }\n    return d;\n}\nvector<Cost> dijkstra(const Graph& g,const int s){\n    vector<int> prev(g.size());return dijkstra(g,s,prev);\n}\n\nclass Main{\n\tpublic:\n\n\tvoid run(){\n\n\t\twhile(true){\n\t\t\tint n,m,l,s,t;cin >> n >> m >> l >> s >> t;if(n==0)break;\n\t\t\ts--;\n\t\t\tGraph g(n);\n\t\t\tREP(i,m){\n\t\t\t\tint a,b,c;cin >> a >> b >> c;a--;b--;\n\t\t\t\tg[a].push_back(Edge(a,b,c));\n\t\t\t\tg[b].push_back(Edge(b,a,c));\n\t\t\t}\n\n\t\t\tjs.clear();\n\t\t\tREP(i,l){\n\t\t\t\tint v,e;cin >> v >> e;v--;\n\t\t\t\tjs[v]=e;\n\t\t\t}\n\n\t\t\tenc.clear();EACH(it,js)enc[it->first]=0;enc[s]=0;\n\t\t\tN=0;EACH(it,enc)enc[it->first]=N++;\n\t\t\tdec.clear();EACH(it,enc)dec[it->second]=it->first;\n\n\t\t\tds = vector<vector<int>> (N,vector<int>(N));\n\t\t\tEACH(it,dec){\n\t\t\t\tvector<int> d=dijkstra(g,it->second);\n\t\t\t\tEACH(itj,dec)ds[it->first][itj->first]=d[itj->second];\n\t\t\t}\n\t\t\t\t\n\t\t\tdp =vector<vector<int>>(N,vector<int>(1<<N,INF<int>()));\n\t\t\tdp[enc[s]][0]=0;\n\t\t\tREP(i,N)REP(bit,1<<N)rec(i,bit);\n\n\t\t\tint Mv=0;\n\t\t\tREP(i,N)REP(bit,1<<N)if(dp[i][bit]+ds[i][enc[s]]<=t){\n\t\t\t\tint bc=0;REP(k,N)if(bit&(1<<k))bc++;\n\t\t\t\tMv=max(Mv,bc);\n\t\t\t}\n\t\t\tcout << Mv <<endl;\n\t\t}\n\t}\n\t\n\tmap<int,int> js;\n\tmap<int,int> enc;\n\tmap<int,int> dec;\n\tvector<vector<int>> dp;\n\tvector<vector<int>> ds;\n\tint N;\n\tint rec(int i,int bit){\n\t\tif(dp[i][bit]!=INF<int>())return dp[i][bit];\n\t\tdp[i][bit]=INF<int>()-1;\n\t\tif(((bit>>i)&1) && js.count(dec[i])){\n\t\t\tREP(j,N)dp[i][bit]=min(dp[i][bit],rec(j,bit-(1<<i))+ds[j][i]+js[dec[i]]);\n\t\t}\n\t\treturn dp[i][bit];\n\t}\n\n};\n\nint main(){\n\tcout <<fixed<<setprecision(20);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8 + 5;\nconst int MAX_V = 500;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nint main(){\n\tint n, m, l, s, t;\n\twhile(cin >> n >> m >> l >> s >> t, n){\n\t\ts--;\n\n\t\tint g[MAX_V][MAX_V];\n\t\tinit(g);\n\t\trep(i,m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tg[a][b] = g[b][a] = c;\n\t\t}\n\t\twarshallFloyd(g, n);\n\n\t\tvector<pair<int, int>> r(l + 1);\n\t\trep(i,l){\n\t\t\tcin >> r[i].first >> r[i].second;\n\t\t\tr[i].first--;\n\t\t}\n\t\tr[l] = make_pair(s, 0);\n\n\t\t//rep(i,n){ rep(j,n){ cout << g[i][j] << ' '; } cout << endl; }\n\n\t\tl++;\n\t\tvector<vector<int>> dp(1 << l, vector<int>(l, INF));\n\t\trep(i,l){\n\t\t\tdp[1 << i][i] = g[s][r[i].first] + r[i].second;\n\t\t\t//dp[1 << i][i] = g[s][r[i].first] + r[i].second;\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\t\t//cout << endl;\n\t\trep(b, 1 << l){\n\t\t\trep(i,l){\n\t\t\t\tif(not getBit(b, i)) continue;\n\t\t\t\t//dp[setBit(b, i)][i] = min(dp[setBit(b, i)][i], dp[b][i] + r[i].second);\n\t\t\t\trep(j,l){\n\t\t\t\t\tif(getBit(b, j)) continue;\n\t\t\t\t\tdp[setBit(b, j)][j] = min(dp[setBit(b, j)][j], dp[b][i] + g[r[i].first][r[j].first] + r[j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(b, 1 << l){ rep(i,l){ cout << dp[b][i] << ' '; } cout << endl; }\n\n\t\tint ans = 0;\n\t\trep(b, 1 << l){\n\t\t\tif(dp[b][l - 1] <= t) ans = max<int>(ans, bitset<20>(b).count());\n\t\t\t//rep(i,l){\n\t\t\t//\tif(dp[b][i] + g[r[i].first][s] <= t) ans = max<int>(ans, bitset<20>(b).count());\n\t\t\t//}\n\t\t}\n\t\tcout << ans - 1 << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 334\n#define MAX_L 17\n#define INF 1e9\n\nstruct edge{\n  int to,cost;\n};\n\nstruct State{\n  int cost,v,S;\n  bool operator < (const State &s)const{\n    return cost > s.cost;\n  }\n};\n\nint N,M,L,S,T,restv[MAX_L],reste[MAX_L];\nvector<edge> G[MAX_L];\nint dist[1<<MAX_L][MAX_L];\n\nstring bit(int S){\n  string res;\n  for(int i = 0 ; i < L ; i++){\n    if((S >> i) & 1) res += '1';\n    else res += '0';\n  }\n  return res;\n}\n\nint dijkstra(){\n  priority_queue<State> Q;\n  Q.push((State){0,L,0});\n  int ans = 0;\n  for(int i = 0 ; i < (1<<L) ; i++){\n    for(int j = 0 ; j <= L ; j++){\n      dist[i][j] = INF;\n    }\n  }\n  dist[0][L] = 0;\n  while(!Q.empty()){\n    State s = Q.top(); Q.pop();\n    int v = s.v;\n    if(s.cost <= T && v == L){\n      ans = max(ans,__builtin_popcount(s.S));\n    }\n    if(s.cost >= T){ continue; }\n    if(dist[s.S][v] < s.cost) continue;\n    if(v != L){\n      if(!((s.S >> v) & 1)){\n        int next = s.S | (1<<v);\n        if(dist[s.S][v] + reste[v] < dist[next][v]){\n          dist[next][v] = dist[s.S][v] + reste[v];\n          Q.push((State){dist[next][v],v,next});\n        }\n      }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(dist[s.S][v] + e.cost < dist[s.S][e.to]){\n        dist[s.S][e.to] = dist[s.S][v] + e.cost;\n        Q.push((State){dist[s.S][e.to],e.to,s.S});\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  while(cin >> N >> M >> L >> S >> T, N){\n    int d[MAX][MAX];\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < N ; j++){\n        if(i == j){\n          d[i][j] = 0;\n        }else{\n          d[i][j] = INF;\n        }\n      }\n    }\n    for(int i = 0 ; i < MAX_L ; i++){\n      G[i].clear();\n    }\n    S--;\n    for(int i = 0 ; i < M ; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--; b--;\n      d[a][b] = d[b][a] = c;\n    }\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        }\n      }\n    }\n    int restv[MAX_L];\n    for(int i = 0 ; i < L ; i++){\n      cin >> restv[i] >> reste[i];\n      restv[i]--;\n    }\n    restv[L] = S; reste[L] = 0;\n    for(int i = 0 ; i <= L ; i++){\n      for(int j = i+1 ; j <= L ; j++){\n        int time = d[restv[i]][restv[j]];\n        if(time == INF) continue;\n        G[i].push_back((edge){j,time});\n        G[j].push_back((edge){i,time});\n      }\n    }\n    cout << dijkstra() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: SIRO Challenge\n//Level: 3\n//Category: グラフ,Graph,縮約,巡回セールスマン問題,TSP,練習問題\n//Note:\n\n/**\n * 問題となるのはいくつの店を回ったかであるから、あるパターンで店が訪問済みになる最短時間を覚えておけば良い。\n * これは巡回セールスマン問題のようにすればできる。\n * ただし、与えられたグラフに対してそのまま訪問済みの店集合を持たせるように拡張すると、頂点数が多くなりすぎるため、先に縮約しておく。\n * 縮約は、全点対最短距離を求めておき、スタートと店だけからなるグラフに再構成すればよい（Dijkstra法などを使えばもっと速くなる）。\n *\n * グラフが連結とは限らないことに注意。\n *\n * オーダーは O(N^3 + L^2 2^L)。\n */\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nbool solve() {\n    int N, M, L, S, T;\n    if(!(cin >> N >> M >> L >> S >> T)) return false;\n    if(!N && !M && !L && !S && !T) return false;\n    --S;\n\n    vector<vector<int>> org_g(N, vector<int>(N, -1));\n    for(int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a; --b;\n        org_g[a][b] = org_g[b][a] = c;\n    }\n    for(int i = 0; i < N; ++i) {\n        org_g[i][i] = 0;\n    }\n    for(int k = 0; k < N; ++k) {\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(org_g[i][k] == -1 || org_g[k][j] == -1) continue;\n                const int nl = org_g[i][k] + org_g[k][j];\n                if(org_g[i][j] == -1 || org_g[i][j] > nl) {\n                    org_g[i][j] = nl;\n                }\n            }\n        }\n    }\n\n    // グラフを再構築する。\n    unordered_map<int,int> dict;\n    dict[0] = S;\n    vector<vector<int>> graph(L+1, vector<int>(L+1, -1));\n    vector<int> es(L+1, 0);\n    for(int i = 1; i <= L; ++i) {\n        int j;\n        cin >> j >> es[i];\n        --j;\n        for(const auto &p : dict) {\n            graph[p.first][i] = graph[i][p.first] = org_g[p.second][j];\n        }\n        dict[i] = j;\n    }\n    for(int i = 0; i <= L; ++i) {\n        graph[i][i] = 0;\n    }\n\n    // TSP\n    vector<vector<int>> dp(1<<(L+1), vector<int>(L+1, -1));\n    dp[0][0] = 0;\n    for(int pat = 0; pat < (1<<(L+1)); ++pat) {\n        for(int i = 0; i <= L; ++i) {\n            if(dp[pat][i] == -1) continue;\n            for(int j = 0; j <= L; ++j) {\n                if(graph[i][j] == -1) continue;\n                const int nt = dp[pat][i] + graph[i][j] + es[j];\n                const int np = pat | (1<<j);\n                if(nt <= T && (dp[np][j] == -1 || dp[np][j] > nt)) {\n                    dp[np][j] = nt;\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int pat = 0; pat < (1<<(L+1)); ++pat) {\n        if(dp[pat][0] != -1) {\n            ans = max(ans, __builtin_popcount(pat & ~1));\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define falze(n)\t\tmemset(n,false,sizeof(n))\n#define zero(n)\t\t\tmemset(n,0,sizeof(n))\n#define init(n)\t\t\tmemset(n,-1,sizeof(n))\n#define REP(i,n) \t\tfor(i=0;i<n;i++)\n#define FOR(i,a,b) \t\tfor(i=a;i<=b;i++)\n#define FORD(i,a,b) \tfor(i=a;i>=b;i--)\n#define FOR2(i,a,b,c) \tfor(i=a;i<=b;i+=c)\n#define FORD2(i,a,b,c)\tfor(i=a;i>=b;i-=c)\n#define mod(x,y) \t\t(((x%y)<0)?((x%y)+y):(x%y))\n#define PB \t\t\t\tpush_back\n#define endll \t\t\t\"\\n\"\n#define INF \t\t\t0xFFFFFFFFF\n#define in(a,b)\t\t\tsubstr(a,b-a+1) // INCLUSIVE\n#define ff\t\t\t\tfirst\n#define ss\t\t\t\tsecond\n#define LEN(x)\t\t\t((ll)x.size())\n#define mm\t\t\t\t1000000007\n#define check(x)\t\t(((x%=mm)+=mm)%=mm)\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\n\nll n,m,len;\nll l,s;\nll rest[301];\nll eat[301];\nll dist[301][301];\n\nll dp[20][(1LL<<16)+1];\n\nll maxz;\n\n\nll arr[(1LL<<16)+1];\nbool cmp(ll a, ll b){\n\treturn __builtin_popcountll(a) < __builtin_popcountll(b);\n}\n\nvoid prec(){\n\tll i;\n\tFOR(i,0,(1LL<<16)-1) arr[i] = i;\n\tsort(arr,arr+((1LL<<16)),cmp);\n}\n\n/*\ndp[i][j] = minimum time arriving at restaurant i and have visited\n\t\t   popcount(j) restaurants including i itself now  \n\t\t   (kth bit is on means it's visited)\n*/\n\nvoid solve(){\n\tll i,bs;\n\t\n\tREP(i,l) REP(bs,(1LL<<16)) if(arr[bs] <= (1LL<<16)-1) {\n\t\t\n\t\tif(!(arr[bs]&(1LL<<i))){ \n\t\t\tdp[i][arr[bs]] = INF; \n\t\t\tcontinue; \n\t\t}\n\t\t\n\t\tif(__builtin_popcountll(arr[bs]) == 1){\n\t\t\tdp[i][arr[bs]] = dist[s][rest[i]] + eat[i];\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tll &ret = dp[i][arr[bs]];\n\t\tret = INF;\n\t\t\n\t\tll j; ll pbs = arr[bs]&(~(1<<i));\n\t\tREP(j,l) if(pbs&(1LL<<j)){\n\t\t\tret = min(ret, dp[j][pbs] + dist[rest[j]][rest[i]] + eat[i]);\n\t\t}\n\t\t\n\t}\n}\n\nint main(){\n\tll i,j,k,t,a,b;\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\t\n\t//freopen(\"input.in\", \"r\",stdin);\n\t//freopen(\"output.out\",\"w\",stdout);\n\t\n\tprec();\n\t\n\twhile(cin >> n >> m >> l >> s >> t){\n\t\t\n\t\tif(n == 0 and m == 0 and l == 0 and s == 0 and t == 0)\n\t\t\treturn 0;\n\t\t\n\t\ts--;\n\t\t\n\t\tREP(i,n) REP(j,n) dist[i][j] = INF;\n\t\t\n\t\tREP(i,m){\n\t\t\tll c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tdist[a][b] = min(dist[a][b],c);\n\t\t\tdist[b][a] = min(dist[b][a],c);\n\t\t}\n\t\t\n\t\tREP(i,l){\n\t\t\tcin >> a >> b;\n\t\t\trest[i] = --a;\n\t\t\teat[i] = b;\n\t\t}\n\t\t\n\t\t// fw\n\t\tREP(k,n) REP(i,n) REP(j,n){\n\t\t\tdist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);\n\t\t}\n\t\t\n\t\tmaxz = 0;\n\t\tREP(i,l) REP(j,(1LL<<l)) dp[i][j] = INF;\n\t\tsolve();\n\t\t\n\t\tREP(i,l) REP(j,(1LL<<l)) if(j&(1LL<<i)){\n\t\t\tif(dp[i][j] >= 0 and dp[i][j] + dist[rest[i]][s] <= t){\n\t\t\t\tmaxz = max(maxz,(ll)__builtin_popcountll(j));\n\t\t\t}\n\t\t}\n\t\tcout << maxz << endll;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nbool solve(){\n    int n,m,l,s,t;\n    cin >> n >> m >> l >> s >> t;\n    if(n==0 and m==0 and l==0 and s==0 and t==0) return false;\n\n    --s;\n    vector<vector<pii>> graph1(n);\n    vector<pii> jiro(l);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        graph1[a].emplace_back(make_pair(b,c));\n        graph1[b].emplace_back(make_pair(a,c));\n    }\n    rep(i,0,l){\n        cin >> jiro[i].first >> jiro[i].second;\n        --jiro[i].first;\n    }\n\n    vector<vector<int>> dist(l+1,vector<int>(l+1,inf));\n    auto dijkstra=[&](const int start,const int idx){\n        vector<int> d(n,inf);\n        priority_queue<pii,vector<pii>,greater<pii>> q;\n        d[start]=0;\n        q.push(make_pair(0,start));\n        while(!q.empty()){\n            auto p=q.top();\n            q.pop();\n            if(p.first>d[p.second]) continue;\n            for(auto &e:graph1[p.second]){\n                int tmp=p.first+e.second;\n                if(tmp>=d[e.first]) continue;\n                d[e.first]=tmp;\n                q.push(make_pair(tmp,e.first));\n            }\n        }\n        dist[idx][0]=d[s];\n        rep(i,0,l) dist[idx][i+1]=d[jiro[i].first];\n    };\n    dijkstra(s,0);\n    rep(i,0,l) dijkstra(jiro[i].first,i+1);\n\n    static int memo[17][1<<17];\n    static bool done[17][1<<17];\n    fill_n((int*)memo,17*(1<<17),inf);\n    fill_n((bool*)done,17*(1<<17),false);\n    function<int(int,int)> rec=[&](int u,int state){\n        if(u==0 and state==1) return memo[0][1]=0;\n        int &res=memo[u][state];\n        if(done[u][state]) return res;\n        rep(i,0,l+1){\n            if(i==u) continue;\n            if(((state>>i)&1)==0) continue;\n            if(dist[i][u]==inf) continue;\n            res=min(res,rec(i,state&~(1<<u))+dist[i][u]+(u?jiro[u-1].second:0));\n        }\n        done[u][state]=true;\n        return res;\n    };\n    \n    int ans=0;\n    rep(i,0,l+1) rep(j,0,1<<(l+1)) if(dist[i][0]!=inf and ((j>>i)&1) and rec(i,j)+dist[i][0]<=t) ans=max(ans,__builtin_popcount(j)-1);\n    cout << ans << endl;\n    return true;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint g[500][500];\nint dp[17][1<<16];\nint dat[500];\nint val[20];\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a){\n\t\td--;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<a;j++)g[i][j]=999999999;\n\t\t\tg[i][i]=0;\n\t\t\tdat[i]=-1;\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r;\n\t\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tp--;q--;\n\t\t\tg[p][q]=g[q][p]=r;\n\t\t}\n\t\tfor(int k=0;k<a;k++){\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tfor(int j=0;j<a;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<c+1;i++){\n\t\t\tfor(int j=0;j<(1<<c);j++)dp[i][j]=999999999;\n\t\t}\n\t\tdp[c][0]=0;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tp--;\n\t\t\tval[i]=p;\n\t\t\tdat[p]=q;\n\t\t}\n\t\tval[c]=d;\n\t\tfor(int i=0;i<(1<<c);i++){\n\t\t\tfor(int j=0;j<c+1;j++){\n\t\t//\t\tprintf(\"%d \",dp[j][i]);\n\t\t\t\tfor(int k=0;k<c+1;k++){\n\t\t\t\t\tif(k==c)dp[k][i]=min(dp[k][i],dp[j][i]+g[val[j]][val[k]]);\n\t\t\t\t\tif(k<c&&!(i&(1<<k)))dp[k][i+(1<<k)]=min(dp[k][i+(1<<k)],dp[j][i]+g[val[j]][val[k]]+dat[val[k]]);\n\t\t\t\t}\n\t\t\t}\n\t\t//\tprintf(\"\\n\");\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=(1<<c)-1;i>=0;i--){\n\t\t\tfor(int j=0;j<c+1;j++)\n\t\t\t\tif(dp[j][i]+g[val[c]][val[j]]<=e){\t\n\t\t\t\t\tret=max(ret,__builtin_popcount(i));\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[17][1 << 16];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 16); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][0] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tif (atop.now == 0) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t\tif (ans == L + 1)break;\n\t\t\t}\n\n\t\t\tfor (auto j : edges[atop.now]) {\n\t\t\t\tconst int nextplace = j.first;\t\t\n\t\t\t\tconst int nexttime = atop.time + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()/2] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()/2] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong() / 2] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong() / 2] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int64 INF = 1LL << 58;\n\n\nint main()\n{\n  int N, M, L, S, T;\n  int64 g[300][300];\n  int x[16], y[16];\n  int64 dp[1 << 16][16];\n\n  while(scanf(\"%d %d %d %d %d\", &N, &M, &L, &S, &T), N) {\n\n    --S;\n    fill_n(*g, 300 * 300, INF);\n    for(int i = 0; i < 300; i++) g[i][i] = 0;\n    fill_n(*dp, (1 << 16) * 16, INF);\n\n    for(int i = 0; i < M; i++) {\n      int A, B, C;\n      scanf(\"%d %d %d\", &A, &B, &C);\n      --A, --B;\n      g[A][B] = g[B][A] = C;\n    }\n    for(int i = 0; i < L; i++) {\n      scanf(\"%d %d\", &x[i], &y[i]);\n      --x[i];\n    }\n\n    for(int k = 0; k < N; k++) {\n      for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    for(int i = 0; i < L; i++) {\n      dp[1 << i][i] = g[S][x[i]] + y[i];\n    }\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < L; k++) {\n          if((i >> k) & 1) continue;\n          dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + g[x[j]][x[k]] + y[k]);\n        }\n      }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < 1 << L; i++) {\n      for(int j = 0; j < L; j++) {\n        if(dp[i][j] + g[x[j]][S] < T) {\n          ret = max(ret, __builtin_popcount(i));\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<31\nusing namespace std;\n\nint Station[301][301];\npair<int,int> p[17];\nint dp[17][100001];\n\nint main()\n{\n  int n,m,l,s,t,a,b,c,x,y;\n\n  while(1){\n    cin>>n>>m>>l>>s>>t;\n    if(n+m+l+s+t==0)break;\n    s--;\n\n    for(int i=0;i<l+1;i++)for(int j=0;j<t+1;j++)dp[i][j]=0;\n    for(int i=0;i<301;i++){\n      for(int j=0;j<301;j++){\n\tif(i==j)Station[i][j]=0;\n\telse Station[i][j]=inf;\n      }\n    }\n\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      a--;b--;\n      Station[a][b]=c;\n      Station[b][a]=c;\n    }\n    p[0].f=s;p[0].s=0;\n    for(int i=1;i<l+1;i++){\n      cin>>p[i].f>>p[i].s;\n      p[i].f--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  Station[i][j]=min(Station[i][j],Station[i][k]+Station[k][j]);\n\t}\n      }\n    }\n\n    for(int i=1;i<l+1;i++){\n      for(int j=1;j<t+1;j++){\n\tfor(int k=0;k<i;k++){\n\t  int a=p[i].f,b=p[k].f;\n\t  if(Station[a][b]==inf || Station[a][s]==inf)continue;\n\t  int time=p[i].s+Station[a][b];\n\t  //cout<<a<<\" \"<<b<<\" \"<<Station[a][b]<<\" \"<<time<<endl;\n\t  if(j>=time && (time+Station[a][s])<=t){\n\t    dp[i][j]=max(dp[k][j-time]+1,dp[i][j-1]);\n\t  }\n\t}\n      }\n    }\n    cout<<dp[l][t]<<endl;;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<vector<pair<int,int>>>edges;\n\nint memo[20][1 << 17];\nstruct aa {\n\tint now;\n\tbitset<17>eats;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\n\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tfor (int j = 0; j < (1 << 17); ++j) {\n\t\t\t\tmemo[i][j] =99999999;\n\t\t\t}\n\t\t}\n\t\tint N, M, L, S, T; cin >> N >> M >> L >> S >> T;\n\t\tif (!N)break;\n\t\tS--;\n\t\tedges.clear();\n\t\tedges.resize(L+1);\n\t\tint diss[300][300];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\n\t\t\tfor (int j = 0; j< N; ++j) {\n\n\t\t\t\tdiss[i][j] = i==j?0:99999999;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdiss[a][b] = c;\n\t\t\tdiss[b][a] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (size_t j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tfor (size_t k = 0; k < N; k++)\n\t\t\t\t{\n\t\t\t\t\tdiss[j][k] = min(diss[j][k],diss[j][i] + diss[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pair<int, int>>ramens;\n\t\tramens.push_back(make_pair(S, 0));\n\t\tfor (int i = 0; i < L; ++i) {\n\t\t\tint j, e; cin >> j >> e;\n\t\t\tj--;\n\t\t\tramens.push_back(make_pair(j,e));\n\t\t}\n\t\tfor (int i = 0; i < L+1; ++i) {\n\t\t\tfor (int j = 0; j< L + 1; ++j) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tedges[i].push_back(make_pair(j, diss[ramens[i].first][ramens[j].first]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ 0,bitset<17>(1),0 });\n\n\n\t\tmemo[0][1] = 0;\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\t\n\t\t\tconst int nplace = atop.now;\n\t\t\tbitset<17>nbs(atop.eats);\n\t\t\tconst int ntime(atop.time);\n\n\t\t\tif (nplace == 0&&ntime <= T) {\n\t\t\t\tans = max(ans, int(nbs.count()));\n\t\t\t}\n\n\t\t\tque.pop();\n\t\t\tfor (auto j : edges[nplace]) {\n\t\t\t\tconst int nextplace = j.first;\n\t\t\t\t\n\t\t\t\tconst int nexttime = ntime + j.second;\n\t\t\t\tif (nexttime < memo[nextplace][nbs.to_ulong()] && nexttime <= T) {\n\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = nexttime;\n\t\t\t\t\tque.push(aa{ nextplace,nbs,nexttime });\n\n\t\t\t\t\tif (!nbs[nextplace]) {\n\t\t\t\t\t\tnbs[nextplace] = true;\n\t\t\t\t\t\tint alltime = nexttime + ramens[nextplace].second;\n\t\t\t\t\t\tif (alltime < memo[nextplace][nbs.to_ulong()] && alltime <= T) {\n\t\t\t\t\t\t\tmemo[nextplace][nbs.to_ulong()] = alltime;\n\t\t\t\t\t\t\tque.push(aa{ nextplace,nbs, alltime });\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnbs[nextplace] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\n\nconst ll INF = 1LL << 60;\n\nvoid chmin(ll &a, ll b) {\n  a = min(a, b);\n}\n\nint main() {\n  int N, M, L, S, T;\n  while(1) {\n    scanf(\"%d%d%d%d%d\", &N, &M, &L, &S, &T);\n    if(N == 0) break;\n    \n    S--;\n    vector<ll> siro(L), time(L);\n    vector< vector<ll> > dist(N, vector<ll>(N, INF)), dp(1<<L, vector<ll>(L, INF));\n\n    for(int i=0; i<N; i++) {\n      dist[i][i] = 0;\n    }\n\n    for(int i=0; i<M; i++) {\n      int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n      a--; b--;\n      chmin(dist[a][b], c);\n      chmin(dist[b][a], c);\n    }\n    for(int i=0; i<L; i++) {\n      scanf(\"%lld%lld\", &siro[i], &time[i]);\n      siro[i]--;\n    }\n\n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          chmin(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n\n    dp[0][0] = 0;\n    for(int bit=0; bit<(1<<L); bit++) {\n      for(int k=0; k<L; k++) {\n        for(int i=0; i<L; i++) {\n          if(bit >> i & 1) continue;\n\n          int nbit = bit | (1 << i);\n          \n          int u = (bit == 0 ? S : siro[k]);\n          int v = siro[i];\n          ll cost = dist[u][v] + time[i];\n\n          // printf(\"u = %d, v = %d, cost = %lld\\n\", u+1, v+1, cost);\n          chmin(dp[nbit][i], dp[bit][k] + cost);\n        }\n      }\n    }\n\n    ll ans = 0;\n    for(int bit=0; bit<(1<<L); bit++) {\n      for(int k=0; k<L; k++) {\n        ll cost = dp[bit][k] + dist[ siro[k] ][S];\n        // printf(\"bit = %d, k = %d, cost = %lld\\n\", bit, k, cost);\n        if(cost > T) continue;\n        ans = max(ans, (ll)__builtin_popcount(bit));\n      }\n    }\n\n    printf(\"%lld\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1e9\nusing namespace std;\ntypedef pair<int,int> ii;\nvector< vector<int> > g;\nvector< vector<int> > adj;\nvector<ii> v1;\nint re,n,m,l,s,dp[1<<19][20];\n\nint f(int i1,int num,int t,int xz){\nif(dp[i1][xz]!=-1) return dp[i1][xz];\nelse if(xz==0) return num;\nelse{\n    num++;\n    if(t-v1[xz].second<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    t=t-v1[xz].second;\n    int i2=i1;\n    i2|=(1<<xz);\n    if(t-adj[xz][0]<0){\n        dp[i1][xz]=0;\n        return dp[i1][xz];\n    }\n    dp[i1][xz]=f(i2,num,t-adj[xz][0],0);\n    for(int j1=1;j1<=l;j1++){\n        if(!(i2&(1<<j1))){\n            if(t-adj[xz][j1]>=0) dp[i1][xz]=max(f(i2,num,t-adj[xz][j1],j1),dp[i1][xz]);\n        }\n    }\n    return dp[i1][xz];\n}\n}\n\nint main(){\nint t,x,y,z;\ncin>>n>>m>>l>>s>>t;\nwhile(n||m||l||s||t){\nv1.clear();\ng.assign(n+1,vector<int>(n+1,inf));\nmemset(dp,-1,sizeof(dp));\nfor(int i=0;i<m;i++){\n    cin>>x>>y>>z;\n    g[x][y]=min(z,g[x][y]);\n    g[y][x]=min(z,g[y][x]);\n}\nv1.push_back(ii(s,0));\nfor(int i=0;i<l;i++){\n    cin>>x>>y;\n    v1.push_back(ii(x,y));\n}\nfor(int k=1;k<=n;k++){\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        }\n    }\n}\nadj.clear();\nfor(int i=0;i<v1.size();i++){\n    vector<int> vv;\n    for(int j=0;j<v1.size();j++) vv.push_back(g[v1[i].first][v1[j].first]);\n    adj.push_back(vv);\n}\nre=0;\nfor(int i=1;i<=l;i++){\n    if(adj[0][i]<=t){\n        re=max(f(1,0,t-adj[0][i],i),re);\n    }\n}\ncout<<re;\ncin>>n>>m>>l>>s>>t;\n}\nreturn 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tdef actual_capacity(from)\n\t\t\tv = @opposite[from]\n\t\t\tcap = @property[:capacity]\n\t\t\tflow = (@property[:flow] ||= 0)\n\t\t\tto = (@property[:flow_to] ||= v)\n\t\t\tto == v ? cap - flow : cap + flow\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\n\n\tdef get_augmenting_path(s, t)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tcomming_edge = {}\n\t\tuntil queue.empty?\n\t\t\tu = queue.shift\n\t\t\tu.each_edge do |e|\t\n\t\t\t\tv = e.opposite[u]\n\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\tnext if e.actual_capacity(u) <= 0\n\n\t\t\t\treached << v\n\t\t\t\tcomming_edge[v] = e\n\t\t\t\tqueue << v\n\n\t\t\t\tif v == t\n\t\t\t\t\tqueue = []\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\t\n\t\tend\n\n\t\tif comming_edge[t]\n\t\t\tpath = [t]\n\t\t\tv = t\n\t\t\tuntil path[0] == s\n\t\t\t\te = comming_edge[v]\n\t\t\t\tu = e.opposite[v]\n\t\t\t\tpath = [u, e, *path]\n\t\t\t\tv = u\n\t\t\tend\n\t\t\treturn path\n\t\tend\n\t\treturn nil\n\tend\nend\n\nloop do\n\tn, m, l, s, t = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tg = Graph.new\n\tnodes = (0..n).map { g.add_node }\n\tm.times do\n\t\ta, b, c = gets.split.map(&:to_i)\n\t\ta = 0 if a == s\n\t\tb = 0 if b == s\n\t\tg.add_edge(nodes[a], nodes[b], {:length => c})\n\tend\n\n\tsiros = [[0, 0]] + (1..l).map { gets.split.map(&:to_i) }\n\tdist = []\n\tsiros.each do |j, e|\n\t\tdij = g.dijkstra([nodes[j]])\t\n\t\tdist << siros.map {|i, f| f + (dij[nodes[i]] || Float::INFINITY)}\n\tend\n\n\tmax_num = 0\n\thash = { 0 => {0 => 0} }\n\t(1..2**l-1).each do |visited|\n\t\t(1..l).each do |last_idx|\n\t\t\tnext if visited[last_idx-1] == 0\n\t\t\tmin = Float::INFINITY\n\t\t\thash[visited - (1 << last_idx-1)].each do |k, d|\n\t\t\t\tnew_d = d + dist[k][last_idx]\n\t\t\t\tmin = new_d if new_d < min\n\t\t\tend\n\t\t\t(hash[visited] ||= {})[last_idx] = min\n\t\t\treturn_dist = min + dist[last_idx][0]\n\t\t\tif return_dist <= t\n\t\t\t\tc = visited.to_s(2).count(?1)\n\t\t\t\tmax_num = c if c > max_num\n\t\t\telse\n\t\t\t\thash[visited].delete(last_idx)\n\t\t\tend\n\t\tend\n\tend\n\n\tp max_num\nend"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t(0..n-1).each{|k|\n\t\tdist_k = dist[k]\n\t\t(0..n-1).each{|i|\n\t\t\tdist_i = dist[i]\n\t\t\tnext_dist_i = next_dist[i]\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist_i[j]\n\t\t\t\ty = dist_i[k] + dist_k[j]\n\t\t\t\tnext_dist_i[j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop do\n\tn, m, l, s, t = gets.split.map(&:to_i)\n\tbreak if n == 0\n\n\tadj_mat = (0..n).map { (0..n).map { Float::INFINITY } }\n\tm.times do\n\t\ta, b, c = gets.split.map(&:to_i)\n\t\tadj_mat[a][b] = adj_mat[b][a] = c\n\tend\n\tdist = warshall_floyd(adj_mat)\n\n\tsiros = [[s, 0]] + (1..l).map { gets.split.map(&:to_i) }\n\tsiros.each do |j, e|\n\t\tdist.each {|to_dist| to_dist[j] += e}\n\tend\n\tdist = siros.map {|j, e| dist[j]}\n\tdist.map! {|to_dist| siros.map {|j, e| to_dist[j]}}\n\n\tmax_num = 0\n\thash = { 0 => {0 => 0} }\n\t(1..2**l-1).each do |visited|\n\t\t(1..l).each do |last_idx|\n\t\t\tnext if visited[last_idx-1] == 0\n\t\t\tmin = Float::INFINITY\n\t\t\thash[visited - (1 << last_idx-1)].each do |k, d|\n\t\t\t\tnew_d = d + dist[k][last_idx]\n\t\t\t\tmin = new_d if new_d < min\n\t\t\tend\n\t\t\t(hash[visited] ||= {})[last_idx] = min\n\t\t\tif min + dist[last_idx][0] <= t\n\t\t\t\tc = visited.to_s(2).count(?1)\n\t\t\t\tmax_num = c if c > max_num\n\t\t\tend\n\t\tend\n\tend\n\n\tp max_num\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.bitop;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    int n, m, l, s, t;\n    while (readf(\"%d %d %d %d %d\\n\", &n, &m, &l, &s, &t), n || m || l || s || t) {\n        //writeln(\"CASE \", n, \" \", m, \" \", l, \" \", s, \" \", t);\n        s--;\n        int[][] G = new int[][](n, n);\n        foreach (ref _; G) _[] = int.max;\n        foreach (i; 0 .. m) {\n            int a, b, c; readf(\"%d %d %d\\n\", &a, &b, &c);\n            a--; b--;\n            G[a][b] = c;\n            G[b][a] = c;\n        }\n\n        foreach (k; 0 .. n) {\n            foreach (i; 0 .. n) {\n                foreach (j; 0 .. n) {\n                    if (G[i][k] == int.max) continue;\n                    if (G[k][j] == int.max) continue;\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                }\n            }\n        }\n\n        int[int] id;\n        int[] rid = [s];\n        id[s] = 0;\n        int I = 1;\n        int[] T = [0];\n        int[] L = [t];\n        foreach (i; 0 .. l) {\n            int j, e; readf(\"%d %d\\n\", &j, &e);\n            j--;\n            rid ~= I++;\n            id[j] = rid.back;\n            T ~= e;\n            L ~= t - G[s][i];\n        }\n        //T.writeln;\n\n        int[][] memo = new int[][](l + 1, 1 << I);\n        foreach (ref _; memo) _[] = int.max;\n\n        struct S {int v, used, t;}\n        BinaryHeap!(Array!S, \"a.t > b.t\") Q; Q.insert(S(0, 0, 0));\n        bool[][] used = new bool[][](I, (1<<I));\n        while (!Q.empty) {\n            S cur = Q.front; Q.removeFront;\n            //cur.writeln;\n            if (cur.t < memo[cur.v][cur.used]) {\n                memo[cur.v][cur.used] = cur.t;\n                foreach (i, k; id) {\n                    if (cur.used & (1 << k)) continue;\n                    if (G[s][i] == int.max) continue;\n                    int nt = cur.t + T[k] + G[ rid[cur.v] ][i];\n                    if (nt > t) continue;\n                    int nused = cur.used | 1<<k;\n                    if (used[k][nused]) continue;\n                    used[k][nused] = true;\n                    Q.insert(S(k, nused, nt));\n                }\n            }\n        }\n\n        int ans = 0;\n        foreach (i; 0 .. (1 << I)) {\n            if (memo[0][i] != int.max && i % 2 == 1) {\n                ans = max(ans, i.popcnt - 1);\n            }\n        }\n        writeln(ans);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys\ndef main():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    L2 = 1 << 16\n    bc = [0]*L2\n    for i in range(1, L2):\n        bc[i] = bc[i ^ (i & -i)] + 1\n    INF = 10**18\n    def solve():\n        N, M, L, s, T = map(int, readline().split())\n        if N == M == 0:\n            return False\n        G = [[] for i in range(N)]\n        for i in range(M):\n            a, b, c = map(int, readline().split()); a -= 1; b -= 1\n            G[a].append((b, c))\n            G[b].append((a, c))\n        def dijkstra(s):\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n            while que:\n                cost, v = heappop(que)\n                if dist[v] < cost:\n                    continue\n                for w, d in G[v]:\n                    if cost + d < dist[w]:\n                        dist[w] = cost + d\n                        heappush(que, (cost + d, w))\n            return dist\n\n        G0 = [[] for i in range(L)]\n        RS = []\n        BS = [0]*L\n        for i in range(L):\n            j, e = map(int, readline().split()); j -= 1\n            d0 = dijkstra(j)\n            for k, p in enumerate(RS):\n                v = d0[p]\n                if v+BS[k] <= T:\n                    G0[i].append((k, v+BS[k], 1 << k))\n                if v+e <= T:\n                    G0[k].append((i, v+e, 1 << i))\n            RS.append(j)\n            BS[i] = e\n\n        ans = 0\n        ds = dijkstra(s-1)\n        que = []\n        Q = [[{} for j in range(L)] for i in range(L+1)]\n        L2 = 1 << L\n        dw = [0]*L\n        for i in range(L):\n            d = ds[RS[i]]\n            r = d + BS[i]\n            dw[i] = T - d + 1\n            if r < dw[i]:\n                Q[1][i][1 << i] = r\n                ans = 1\n        for k in range(1, L):\n            qs = Q[k]\n            qs1 = Q[k+1]\n            if any(qs):\n                ans = k\n            for v in range(L):\n                qsv = qs[v]\n                for w, d, b in G0[v]:\n                    dww = dw[w]\n                    qs1w = qs1[w]\n                    for state, cost in qsv.items():\n                        if state & b:\n                            continue\n                        r = cost + d\n                        if r < qs1w.get(state | b, dww):\n                            qs1w[state | b] = r\n        if any(Q[L]):\n            ans = L\n        write(\"%d\\n\" % ans)\n        return True\n    while solve():\n        ...\nmain()\n"
  }
]