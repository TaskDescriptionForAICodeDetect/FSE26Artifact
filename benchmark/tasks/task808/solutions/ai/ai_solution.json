[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint n, m;\nint graph[MAX_N][MAX_N];\nint degree[MAX_N];\nint is_reachable[MAX_N];\n\nvoid dfs(int v, int color[], int black_color) {\n    is_reachable[v] = 1;\n    for (int i = 0; i < degree[v]; i++) {\n        int u = graph[v][i];\n        if (color[u] == black_color && !is_reachable[u]) {\n            dfs(u, color, black_color);\n        }\n    }\n}\n\nint check_connectivity(int color[], int black_color) {\n    memset(is_reachable, 0, sizeof(is_reachable));\n    int black_start = -1;\n    \n    for (int i = 1; i <= n; i++) {\n        if (color[i] == black_color) {\n            black_start = i;\n            break;\n        }\n    }\n    \n    if (black_start == -1) return 0;\n    \n    dfs(black_start, color, black_color);\n    \n    for (int i = 1; i <= n; i++) {\n        if (color[i] == black_color && !is_reachable[i]) {\n            return 0;\n        }\n    }\n    \n    return 1;\n}\n\nint solve(int black_vertex) {\n    int ways = 0;\n    \n    for (int mask = 0; mask < (1 << (n - 1)); mask++) {\n        int color[MAX_N] = {0};\n        color[black_vertex] = 1;\n        \n        int color_idx = 1;\n        for (int i = 1; i <= n; i++) {\n            if (i == black_vertex) continue;\n            color[i] = (mask & (1 << (color_idx - 1))) ? 1 : 0;\n            color_idx++;\n        }\n        \n        if (check_connectivity(color, 1)) {\n            ways++;\n        }\n    }\n    \n    return ways % m;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    for (int i = 1; i < n; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        graph[x][degree[x]++] = y;\n        graph[y][degree[y]++] = x;\n    }\n    \n    for (int v = 1; v <= n; v++) {\n        printf(\"%d\\n\", solve(v));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100010\n\ntypedef struct Node {\n    int to;\n    struct Node *next;\n} Node;\n\nNode *adj[MAXN];\nint N, M;\nint size[MAXN];\nlong long dp[MAXN], res[MAXN];\n\nvoid addEdge(int u, int v) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->to = v;\n    node->next = adj[u];\n    adj[u] = node;\n}\n\nvoid dfs1(int u, int parent) {\n    dp[u] = 1;\n    size[u] = 1;\n    for (Node *p = adj[u]; p != NULL; p = p->next) {\n        int v = p->to;\n        if (v == parent) continue;\n        dfs1(v, u);\n        size[u] += size[v];\n        dp[u] = dp[u] * (dp[v] + 1) % M;\n    }\n}\n\nvoid dfs2(int u, int parent, long long parent_dp) {\n    res[u] = dp[u] * (parent_dp + 1) % M;\n    \n    int deg = 0;\n    for (Node *p = adj[u]; p != NULL; p = p->next) {\n        if (p->to != parent) deg++;\n    }\n    \n    long long prefix[deg + 2], suffix[deg + 2];\n    int idx = 0;\n    prefix[0] = 1;\n    for (Node *p = adj[u]; p != NULL; p = p->next) {\n        int v = p->to;\n        if (v == parent) continue;\n        idx++;\n        prefix[idx] = prefix[idx - 1] * (dp[v] + 1) % M;\n    }\n    suffix[idx + 1] = 1;\n    idx = deg + 1;\n    for (Node *p = adj[u]; p != NULL; p = p->next) {\n        int v = p->to;\n        if (v == parent) continue;\n        idx--;\n        suffix[idx] = suffix[idx + 1] * (dp[v] + 1) % M;\n    }\n    \n    idx = 0;\n    for (Node *p = adj[u]; p != NULL; p = p->next) {\n        int v = p->to;\n        if (v == parent) continue;\n        idx++;\n        long long temp = parent_dp + 1;\n        temp = temp * prefix[idx - 1] % M;\n        temp = temp * suffix[idx + 1] % M;\n        dfs2(v, u, temp);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 1; i < N; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        addEdge(x, y);\n        addEdge(y, x);\n    }\n    \n    dfs1(1, -1);\n    dfs2(1, -1, 0);\n    \n    for (int v = 1; v <= N; v++) {\n        printf(\"%lld\\n\", res[v]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> dp;\nvector<int> res;\nint MOD;\n\nvoid dfs1(int u, int parent) {\n    dp[u] = 1;\n    for (int v : adj[u]) {\n        if (v == parent) continue;\n        dfs1(v, u);\n        dp[u] = (1LL * dp[u] * (dp[v] + 1)) % MOD;\n    }\n}\n\nvoid dfs2(int u, int parent, int parent_contribution) {\n    res[u] = (1LL * dp[u] * (parent_contribution + 1)) % MOD;\n    int n = adj[u].size();\n    vector<int> prefix(n, 1), suffix(n, 1);\n    \n    for (int i = 0; i < n; ++i) {\n        int v = adj[u][i];\n        if (v == parent) {\n            prefix[i] = (i > 0 ? prefix[i-1] : 1);\n            continue;\n        }\n        prefix[i] = (1LL * (i > 0 ? prefix[i-1] : 1) * (dp[v] + 1)) % MOD;\n    }\n    \n    for (int i = n-1; i >= 0; --i) {\n        int v = adj[u][i];\n        if (v == parent) {\n            suffix[i] = (i < n-1 ? suffix[i+1] : 1);\n            continue;\n        }\n        suffix[i] = (1LL * (i < n-1 ? suffix[i+1] : 1) * (dp[v] + 1)) % MOD;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        int v = adj[u][i];\n        if (v == parent) continue;\n        int left = (i > 0 ? prefix[i-1] : 1);\n        int right = (i < n-1 ? suffix[i+1] : 1);\n        int new_contribution = (1LL * left * right) % MOD;\n        new_contribution = (1LL * new_contribution * (parent_contribution + 1)) % MOD;\n        dfs2(v, u, new_contribution);\n    }\n}\n\nvector<int> solve(int N, vector<pair<int, int>>& edges, int M) {\n    MOD = M;\n    adj.assign(N+1, vector<int>());\n    dp.assign(N+1, 0);\n    res.assign(N+1, 0);\n    \n    for (auto& e : edges) {\n        int x = e.first, y = e.second;\n        adj[x].push_back(y);\n        adj[y].push_back(x);\n    }\n    \n    dfs1(1, -1);\n    dfs2(1, -1, 0);\n    \n    vector<int> ans(N);\n    for (int i = 1; i <= N; ++i) {\n        ans[i-1] = res[i];\n    }\n    return ans;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pair<int, int>> edges(N-1);\n    for (int i = 0; i < N-1; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n    vector<int> ans = solve(N, edges, M);\n    for (int num : ans) {\n        cout << num << '\\n';\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:00:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static List<Integer>[] tree;\n    static int N, M;\n    static int[] res;\n    static int[][] dp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        \n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            tree[x].add(y);\n            tree[y].add(x);\n        }\n        \n        res = new int[N + 1];\n        dp = new int[N + 1][2];\n        \n        for (int v = 1; v <= N; v++) {\n            dfs(v, -1);\n            res[v] = dp[v][1] % M;\n        }\n        \n        for (int v = 1; v <= N; v++) {\n            System.out.println(res[v]);\n        }\n    }\n    \n    static void dfs(int u, int parent) {\n        dp[u][0] = 1;\n        dp[u][1] = 1;\n        \n        for (int v : tree[u]) {\n            if (v == parent) continue;\n            dfs(v, u);\n            dp[u][1] = (int)((long)dp[u][1] * (dp[v][0] + dp[v][1]) % M);\n            dp[u][0] = (int)((long)dp[u][0] * dp[v][0] % M);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:01:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreePainting {\n    static final int MOD = 1000000007;\n    static List<List<Integer>> graph;\n    static int N;\n\n    public static int[] countPaintings(int N, int[][] edges, int M) {\n        graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        int[] result = new int[N + 1];\n        for (int v = 1; v <= N; v++) {\n            result[v] = countWays(v, M);\n        }\n\n        return result;\n    }\n\n    static int countWays(int blackVertex, int M) {\n        boolean[] visited = new boolean[N + 1];\n        List<Integer> blackVertices = new ArrayList<>();\n        findBlackVertexComponent(blackVertex, visited, blackVertices);\n\n        return countValidPaintings(blackVertices, M);\n    }\n\n    static void findBlackVertexComponent(int vertex, boolean[] visited, List<Integer> blackVertices) {\n        visited[vertex] = true;\n        blackVertices.add(vertex);\n\n        for (int neighbor : graph.get(vertex)) {\n            if (!visited[neighbor]) {\n                findBlackVertexComponent(neighbor, visited, blackVertices);\n            }\n        }\n    }\n\n    static int countValidPaintings(List<Integer> blackVertices, int M) {\n        int numBlackVertices = blackVertices.size();\n        boolean[] blackVertexSet = new boolean[N + 1];\n        for (int v : blackVertices) {\n            blackVertexSet[v] = true;\n        }\n\n        return dfs(1, blackVertexSet, M);\n    }\n\n    static int dfs(int vertex, boolean[] blackVertexSet, int M) {\n        if (vertex > N) {\n            return 1;\n        }\n\n        int ways = 0;\n        if (!blackVertexSet[vertex]) {\n            // Paint vertex white\n            ways = dfs(vertex + 1, blackVertexSet, M);\n        }\n\n        // Paint vertex black\n        blackVertexSet[vertex] = true;\n        boolean canPaintBlack = true;\n        for (int neighbor : graph.get(vertex)) {\n            if (neighbor < vertex && !blackVertexSet[neighbor]) {\n                canPaintBlack = false;\n                break;\n            }\n        }\n\n        if (canPaintBlack) {\n            ways = (ways + dfs(vertex + 1, blackVertexSet, M)) % M;\n        }\n\n        blackVertexSet[vertex] = false;\n        return ways;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int[][] edges = {{1, 2}, {1, 3}, {2, 4}, {2, 5}};\n        int M = 1000000007;\n        int[] result = countPaintings(N, edges, M);\n        for (int i = 1; i <= N; i++) {\n            System.out.println(\"Vertex \" + i + \": \" + result[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:01:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MAXN = 2e5 + 5;\nvector<int> graph[MAXN];\nint N, M;\n\nvector<int> find_black_component(int black_vertex) {\n    vector<bool> visited(N + 1, false);\n    vector<int> black_component;\n    \n    function<void(int)> dfs = [&](int v) {\n        visited[v] = true;\n        black_component.push_back(v);\n        \n        for (int u : graph[v]) {\n            if (!visited[u]) {\n                dfs(u);\n            }\n        }\n    };\n    \n    dfs(black_vertex);\n    return black_component;\n}\n\nll count_painting_ways(int black_vertex) {\n    vector<int> black_component = find_black_component(black_vertex);\n    vector<bool> in_black_component(N + 1, false);\n    \n    for (int v : black_component) {\n        in_black_component[v] = true;\n    }\n    \n    vector<vector<int>> components;\n    vector<bool> component_visited(N + 1, false);\n    \n    for (int v = 1; v <= N; v++) {\n        if (!component_visited[v] && !in_black_component[v]) {\n            vector<int> component;\n            \n            function<void(int)> dfs = [&](int u) {\n                component_visited[u] = true;\n                component.push_back(u);\n                \n                for (int w : graph[u]) {\n                    if (!component_visited[w] && !in_black_component[w]) {\n                        dfs(w);\n                    }\n                }\n            };\n            \n            dfs(v);\n            components.push_back(component);\n        }\n    }\n    \n    ll ways = 1;\n    for (const auto& component : components) {\n        ways = (ways * 2) % M;\n    }\n    \n    return ways;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    cin >> N >> M;\n    \n    for (int i = 1; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    \n    for (int v = 1; v <= N; v++) {\n        cout << count_painting_ways(v) << \" \";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\nMOD = 10**9 + 7  # Assume a generic large prime for modulus if not provided in input\n\ndef count_ways(N, edges, M):\n    tree = defaultdict(list)\n    for x, y in edges:\n        tree[x].append(y)\n        tree[y].append(x)\n\n    def dfs(v, parent):\n        sizes[v] = 1\n        for neighbor in tree[v]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, v)\n            sizes[v] += sizes[neighbor]\n            subtree_ways[v] = (subtree_ways[v] * subtree_ways[neighbor]) % M\n\n        subtree_ways[v] = (subtree_ways[v] * pow(2, sizes[v] - 1, M)) % M\n\n    def reroot(v, parent):\n        nonlocal res\n        res[v-1] = (subtree_ways[v] * pow(2, N - sizes[v], M)) % M\n\n        for neighbor in tree[v]:\n            if neighbor == parent:\n                continue\n\n            prev_ways_v = subtree_ways[v]\n            prev_ways_neighbor = subtree_ways[neighbor]\n            prev_size_v = sizes[v]\n            prev_size_neighbor = sizes[neighbor]\n\n            sizes[v] -= sizes[neighbor]\n            subtree_ways[v] = (subtree_ways[v] * pow(pow(2, sizes[neighbor] - 1, M), M-2, M) * pow(2, N - sizes[neighbor] - 1, M)) % M\n            subtree_ways[neighbor] = (subtree_ways[neighbor] * subtree_ways[v]) % M\n\n            sizes[neighbor] = N\n            reroot(neighbor, v)\n\n            sizes[v] = prev_size_v\n            sizes[neighbor] = prev_size_neighbor\n            subtree_ways[v] = prev_ways_v\n            subtree_ways[neighbor] = prev_ways_neighbor\n\n    subtree_ways = [1] * (N + 1)\n    sizes = [0] * (N + 1)\n    res = [0] * N\n\n    dfs(1, -1)\n    reroot(1, -1)\n\n    return res\n\n# Example usage:\n# N = 3\n# edges = [(1, 2), (2, 3)]\n# M = 1000\n# print(count_ways(N, edges, M))",
    "timestamp": "2025-08-13 13:13:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreePainting {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        List<List<Integer>> tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            tree.get(x).add(y);\n            tree.get(y).add(x);\n        }\n        \n        int[] subTreeSize = new int[N + 1];\n        int[] dp = new int[N + 1];\n        \n        calculateSubtreeSize(1, -1, tree, subTreeSize);\n        calculateWays(1, -1, tree, subTreeSize, dp, M);\n        \n        for (int v = 1; v <= N; v++) {\n            System.out.println(waysGivenBlack[v] % M);\n        }\n    }\n\n    static int[] waysGivenBlack;\n\n    private static void calculateSubtreeSize(int node, int parent, List<List<Integer>> tree, int[] subTreeSize) {\n        subTreeSize[node] = 1;\n        for (int child : tree.get(node)) {\n            if (child != parent) {\n                calculateSubtreeSize(child, node, tree, subTreeSize);\n                subTreeSize[node] += subTreeSize[child];\n            }\n        }\n    }\n\n    private static void calculateWays(int node, int parent, List<List<Integer>> tree, int[] subTreeSize, int[] dp, int M) {\n        dp[node] = 1;\n        int productWays = 1;\n        for (int child : tree.get(node)) {\n            if (child != parent) {\n                calculateWays(child, node, tree, subTreeSize, dp, M);\n                dp[node] *= (dp[child] + 1);\n                dp[node] %= M;\n                productWays *= dp[child];\n                productWays %= M;\n            }\n        }\n        waysGivenBlack[node] = productWays;\n    }\n}",
    "timestamp": "2025-08-13 13:13:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100005\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[2 * MAXN];\nint head[MAXN], edge_count;\nint N, M;\nint dp[MAXN];\nint subsize[MAXN];\n\nvoid add_edge(int x, int y) {\n    edges[edge_count].to = y;\n    edges[edge_count].next = head[x];\n    head[x] = edge_count++;\n}\n\nvoid dfs(int u, int parent) {\n    subsize[u] = 1;\n    dp[u] = 1;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v != parent) {\n            dfs(v, u);\n            dp[u] = (dp[u] * (dp[v] + 1)) % M;\n            subsize[u] += subsize[v];\n        }\n    }\n}\n\nvoid solve() {\n    for (int v = 1; v <= N; ++v) {\n        memset(dp, 0, sizeof(dp));\n        memset(subsize, 0, sizeof(subsize));\n        dfs(v, -1);\n        printf(\"%d\\n\", dp[v]);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    edge_count = 0;\n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        add_edge(x, y);\n        add_edge(y, x);\n    }\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-13 13:13:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function paintTree(N, edges, M) {\n    const adjacencyList = Array.from({length: N + 1}, () => []);\n    const mod = x => ((x % M) + M) % M;\n\n    edges.forEach(([x, y]) => {\n        adjacencyList[x].push(y);\n        adjacencyList[y].push(x);\n    });\n\n    function dfs(node, parent) {\n        let size = 1;\n        let ways = 1;\n        \n        adjacencyList[node].forEach(child => {\n            if (child !== parent) {\n                const [subTreeSize, subTreeWays] = dfs(child, node);\n                ways = mod(ways * subTreeWays);\n                size += subTreeSize;\n            }\n        });\n\n        return [size, size > 1 ? ways : 1];\n    }\n\n    const result = [];\n    for (let v = 1; v <= N; v++) {\n        let totalWays = 1;\n        \n        adjacencyList[v].forEach(neighbor => {\n            const [subTreeSize, subTreeWays] = dfs(neighbor, v);\n            totalWays = mod(totalWays * subTreeWays);\n        });\n\n        result.push(mod(totalWays));\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 13:13:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef count_painting_ways(N, edges, M):\n    graph = defaultdict(list)\n    for x, y in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n    \n    def is_connected_black_vertices(black_vertices):\n        if not black_vertices:\n            return False\n        \n        start = list(black_vertices)[0]\n        visited = set()\n        queue = deque([start])\n        visited.add(start)\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor in black_vertices and neighbor not in visited:\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        \n        return len(visited) == len(black_vertices)\n    \n    def count_ways(fixed_black_vertex):\n        ways = 0\n        for mask in range(1 << (N - 1)):\n            black_vertices = {fixed_black_vertex}\n            white_vertices = set()\n            \n            remaining_vertices = set(range(1, N + 1)) - {fixed_black_vertex}\n            for i, v in enumerate(remaining_vertices):\n                if mask & (1 << i):\n                    black_vertices.add(v)\n                else:\n                    white_vertices.add(v)\n            \n            if is_connected_black_vertices(black_vertices):\n                ways += 1\n        \n        return ways % M\n    \n    return [count_ways(v) for v in range(1, N + 1)]\n\n# Example usage\nN = 5\nedges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nM = 1000000007\n\nresult = count_painting_ways(N, edges, M)\nprint(result)",
    "timestamp": "2025-08-13 13:13:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges, M) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    for (const [x, y] of edges) {\n        graph[x].push(y);\n        graph[y].push(x);\n    }\n\n    const result = new Array(N + 1).fill(0);\n\n    for (let blackVertex = 1; blackVertex <= N; blackVertex++) {\n        const visited = new Array(N + 1).fill(false);\n        const blackComponents = [];\n\n        const dfs = (node, isBlack) => {\n            visited[node] = true;\n            if (isBlack) blackComponents[blackComponents.length - 1].push(node);\n\n            for (const neighbor of graph[node]) {\n                if (!visited[neighbor]) {\n                    dfs(neighbor, isBlack && node === blackVertex);\n                }\n            }\n        };\n\n        for (let i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                if (i === blackVertex) {\n                    blackComponents.push([i]);\n                    dfs(i, true);\n                } else {\n                    dfs(i, false);\n                }\n            }\n        }\n\n        let ways = 1;\n        for (const component of blackComponents) {\n            ways = (ways * Math.pow(2, component.length - 1)) % M;\n        }\n\n        result[blackVertex] = ways;\n    }\n\n    return result.slice(1);\n}",
    "timestamp": "2025-08-13 13:14:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        x, y = map(int, sys.stdin.readline().split())\n        adj[x].append(y)\n        adj[y].append(x)\n    \n    parent = [0]*(N+1)\n    children = [[] for _ in range(N+1)]\n    root = 1\n    q = deque([root])\n    parent[root] = 0\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if v != parent[u]:\n                parent[v] = u\n                children[u].append(v)\n                q.append(v)\n    \n    dp = [1]*(N+1)\n    stack = []\n    post_order = []\n    stack.append((root, False))\n    while stack:\n        node, processed = stack.pop()\n        if not processed:\n            stack.append((node, True))\n            for child in reversed(children[node]):\n                stack.append((child, False))\n        else:\n            post_order.append(node)\n    \n    for u in post_order:\n        for v in children[u]:\n            dp[u] = dp[u] * (dp[v] + 1) % M\n    \n    ans = [0]*(N+1)\n    ans[root] = dp[root]\n    \n    partial = [[] for _ in range(N+1)]\n    for u in range(N+1):\n        m = len(children[u])\n        left = [1]*(m+2)\n        right = [1]*(m+2)\n        for i in range(1, m+1):\n            v = children[u][i-1]\n            left[i] = left[i-1] * (dp[v] + 1) % M\n        for i in range(m, 0, -1):\n            v = children[u][i-1]\n            right[i] = right[i+1] * (dp[v] + 1) % M\n        partial[u] = [ (left[i-1] * right[i+1] % M) for i in range(m+2)]\n    \n    stack = [(root, 0)]\n    while stack:\n        u, val = stack.pop()\n        m = len(children[u])\n        for idx in range(m):\n            v = children[u][idx]\n            new_val = (val * partial[u][idx+1] + 1) % M\n            ans[v] = new_val * dp[v] % M\n            stack.append((v, new_val))\n    \n    for v in range(1, N+1):\n        print(ans[v] % M)\n\nsolve()",
    "timestamp": "2025-08-13 13:14:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync(0, 'utf-8').split('\\n');\n    let ptr = 0;\n    const [N, M] = input[ptr++].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    for (let i = 0; i < N - 1; i++) {\n        const [x, y] = input[ptr++].split(' ').map(Number);\n        adj[x].push(y);\n        adj[y].push(x);\n    }\n\n    const parent = new Array(N + 1).fill(0);\n    const children = Array.from({ length: N + 1 }, () => []);\n    const stack = [1];\n    parent[1] = 0;\n\n    while (stack.length > 0) {\n        const u = stack.pop();\n        for (const v of adj[u]) {\n            if (v !== parent[u]) {\n                parent[v] = u;\n                children[u].push(v);\n                stack.push(v);\n            }\n        }\n    }\n\n    const dp = new Array(N + 1).fill(1);\n    const res = new Array(N + 1).fill(0);\n\n    function dfs(u) {\n        for (const v of children[u]) {\n            dfs(v);\n            dp[u] = dp[u] * (dp[v] + 1) % M;\n        }\n    }\n\n    function reroot(u, parentVal) {\n        res[u] = dp[u] * (parentVal + 1) % M;\n        const prefix = [1];\n        const suffix = [1];\n        const k = children[u].length;\n        for (let i = 0; i < k; i++) {\n            const v = children[u][i];\n            prefix.push(prefix[i] * (dp[v] + 1) % M);\n        }\n        for (let i = k - 1; i >= 0; i--) {\n            const v = children[u][i];\n            suffix.push(suffix[k - 1 - i] * (dp[v] + 1) % M);\n        }\n        for (let i = 0; i < k; i++) {\n            const v = children[u][i];\n            const newParentVal = prefix[i] * suffix[k - 1 - i] % M * (parentVal + 1) % M;\n            reroot(v, newParentVal);\n        }\n    }\n\n    dfs(1);\n    reroot(1, 0);\n\n    const output = [];\n    for (let v = 1; v <= N; v++) {\n        output.push(res[v] % M);\n    }\n    console.log(output.join('\\n'));\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:14:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\nvoid dfs(int v, int parent, const Graph& graph, vector<int>& dp, vector<int>& subtree_sizes) {\n    int combinations = 1;\n    int subtree_size = 1;\n    for (int u : graph[v]) {\n        if (u == parent) continue;\n        dfs(u, v, graph, dp, subtree_sizes);\n        combinations = (combinations * (1 + dp[u])) % MOD;\n        subtree_size += subtree_sizes[u];\n    }\n    dp[v] = combinations;\n    subtree_sizes[v] = subtree_size;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    Graph graph(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int x, y;\n        cin >> x >> y;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n\n    vector<int> dp(N + 1), subtree_sizes(N + 1);\n    vector<int> ways(N + 1);\n\n    for (int v = 1; v <= N; ++v) {\n        fill(dp.begin(), dp.end(), 0);\n        fill(subtree_sizes.begin(), subtree_sizes.end(), 0);\n        dp[v] = 1;\n        dfs(v, -1, graph, dp, subtree_sizes);\n        ways[v] = dp[v];\n    }\n\n    for (int v = 1; v <= N; ++v) {\n        cout << ways[v] % M << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:38:38"
  }
]