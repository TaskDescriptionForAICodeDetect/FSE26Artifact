[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100000\n\nint parent[MAX_N + 1];\nint marked[MAX_N + 1];\n\nint find_nearest_marked(int node) {\n    while (node != 0 && !marked[node]) {\n        node = parent[node];\n    }\n    return node;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n\n    for (int i = 2; i <= N; i++) {\n        scanf(\"%d\", &parent[i]);\n    }\n\n    marked[1] = 1;\n    long long sum = 0;\n\n    while (Q--) {\n        char op;\n        int v;\n        scanf(\" %c %d\", &op, &v);\n\n        if (op == 'M') {\n            marked[v] = 1;\n        } else if (op == 'Q') {\n            int res = find_nearest_marked(v);\n            sum += res;\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> parent;\nvector<int> marked;\n\nint find_marked_ancestor(int node) {\n    while (node != 1 && !marked[node]) {\n        node = parent[node];\n    }\n    return marked[node] ? node : 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    parent.resize(N + 1);\n    marked.resize(N + 1, 0);\n    marked[1] = 1;\n\n    for (int i = 2; i <= N; ++i) {\n        cin >> parent[i];\n    }\n\n    long long sum = 0;\n    while (Q--) {\n        char op;\n        int v;\n        cin >> op >> v;\n        if (op == 'M') {\n            marked[v] = 1;\n        } else if (op == 'Q') {\n            sum += find_marked_ancestor(v);\n        }\n    }\n\n    cout << sum << '\\n';\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class NearestMarkedAncestor {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n\n    static int[] parent;\n    static int[] marked;\n\n    public static void main(String[] args) {\n        FastReader fr = new FastReader();\n        int N = fr.nextInt();\n        int Q = fr.nextInt();\n\n        parent = new int[N + 1];\n        marked = new int[N + 1];\n        marked[1] = 1; // Root is initially marked\n\n        for (int i = 2; i <= N; i++) {\n            parent[i] = fr.nextInt();\n        }\n\n        long sum = 0;\n        while (Q-- > 0) {\n            String op = fr.next();\n            int v = fr.nextInt();\n\n            if (op.equals(\"Q\")) {\n                sum += findMarkedAncestor(v);\n            } else {\n                marked[v] = 1;\n            }\n        }\n        System.out.println(sum);\n    }\n\n    static int findMarkedAncestor(int v) {\n        while (v != 0) {\n            if (marked[v] == 1) {\n                return v;\n            }\n            v = parent[v];\n        }\n        return 1; // should not reach here as root is marked\n    }\n}",
    "timestamp": "2025-08-05 21:12:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TreeMarking {\n    static class Node {\n        int id;\n        Node parent;\n        boolean marked;\n        \n        Node(int id) {\n            this.id = id;\n            this.marked = false;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String[] input = br.readLine().split(\" \");\n        int N = Integer.parseInt(input[0]);\n        int Q = Integer.parseInt(input[1]);\n        \n        Node[] nodes = new Node[N+1];\n        for (int i = 1; i <= N; i++) {\n            nodes[i] = new Node(i);\n        }\n        \n        input = br.readLine().split(\" \");\n        for (int i = 2; i <= N; i++) {\n            int parent = Integer.parseInt(input[i-2]);\n            nodes[i].parent = nodes[parent];\n        }\n        \n        nodes[1].marked = true;\n        \n        int totalSum = 0;\n        \n        for (int q = 0; q < Q; q++) {\n            input = br.readLine().split(\" \");\n            int op = Integer.parseInt(input[0]);\n            \n            if (op == 1) {\n                int x = Integer.parseInt(input[1]);\n                nodes[x].marked = true;\n            } else {\n                int x = Integer.parseInt(input[1]);\n                int result = findNearestMarkedAncestor(nodes[x]);\n                totalSum += result;\n            }\n        }\n        \n        bw.write(String.valueOf(totalSum));\n        bw.flush();\n        bw.close();\n    }\n    \n    static int findNearestMarkedAncestor(Node node) {\n        Node current = node;\n        while (current != null) {\n            if (current.marked) {\n                return current.id;\n            }\n            current = current.parent;\n        }\n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 21:12:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint parent[MAX_N];\nint marked[MAX_N];\nint depth[MAX_N];\n\nvoid init_tree(int n) {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = 0;\n        marked[i] = 0;\n        depth[i] = 0;\n    }\n    marked[1] = 1;\n}\n\nvoid set_parent(int child, int p) {\n    parent[child] = p;\n    depth[child] = depth[p] + 1;\n}\n\nint find_nearest_marked_ancestor(int node) {\n    while (node != 0) {\n        if (marked[node]) {\n            return node;\n        }\n        node = parent[node];\n    }\n    return 0;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    init_tree(n);\n\n    for (int i = 2; i <= n; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        set_parent(i, p);\n    }\n\n    long long total_sum = 0;\n\n    while (q--) {\n        int type, x;\n        scanf(\"%d %d\", &type, &x);\n\n        if (type == 1) {\n            marked[x] = 1;\n        } else {\n            int result = find_nearest_marked_ancestor(x);\n            total_sum += result;\n        }\n    }\n\n    printf(\"%lld\\n\", total_sum);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nconst int LOG = 20;\n\nvector<int> graph[MAXN];\nint parent[MAXN][LOG];\nint depth[MAXN];\nbool marked[MAXN];\n\nvoid dfs(int node, int par, int d) {\n    parent[node][0] = par;\n    depth[node] = d;\n    \n    for (int i = 1; i < LOG; i++) {\n        parent[node][i] = parent[parent[node][i-1]][i-1];\n    }\n    \n    for (int child : graph[node]) {\n        if (child != par) {\n            dfs(child, node, d + 1);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) swap(u, v);\n    \n    int diff = depth[u] - depth[v];\n    for (int i = LOG - 1; i >= 0; i--) {\n        if (diff & (1 << i)) {\n            u = parent[u][i];\n        }\n    }\n    \n    if (u == v) return u;\n    \n    for (int i = LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    \n    return parent[u][0];\n}\n\nint find_nearest_marked_ancestor(int node) {\n    while (node != 0 && !marked[node]) {\n        node = parent[node][0];\n    }\n    return node;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int N, Q;\n    cin >> N >> Q;\n    \n    for (int i = 2; i <= N; i++) {\n        int p;\n        cin >> p;\n        graph[p].push_back(i);\n        graph[i].push_back(p);\n    }\n    \n    dfs(1, 0, 0);\n    marked[1] = true;\n    \n    long long total_sum = 0;\n    \n    while (Q--) {\n        int type, x;\n        cin >> type >> x;\n        \n        if (type == 1) {\n            marked[x] = true;\n        } else {\n            int nearest_marked = find_nearest_marked_ancestor(x);\n            total_sum += nearest_marked;\n        }\n    }\n    \n    cout << total_sum << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeAncestor:\n    def __init__(self, n, parent):\n        self.n = n\n        self.parent = parent\n        self.marked = [False] * (n + 1)\n        self.marked[1] = True\n        self.dist = [0] * (n + 1)\n        self.build_LCA()\n\n    def build_LCA(self):\n        self.lca_parent = [[-1] * (self.n + 1) for _ in range(20)]\n        for node in range(1, self.n + 1):\n            self.lca_parent[0][node] = self.parent[node]\n\n        for i in range(1, 20):\n            for node in range(1, self.n + 1):\n                if self.lca_parent[i - 1][node] != -1:\n                    self.lca_parent[i][node] = self.lca_parent[i - 1][self.lca_parent[i - 1][node]]\n\n    def mark(self, x):\n        self.marked[x] = True\n\n    def query(self, x):\n        if self.marked[x]:\n            return x\n        for i in range(19, -1, -1):\n            if self.lca_parent[i][x] != -1 and not self.marked[self.lca_parent[i][x]]:\n                x = self.lca_parent[i][x]\n        return self.parent[x]\n\n\ndef solve(N, parent, operations):\n    tree = TreeAncestor(N, parent)\n    total_sum = 0\n\n    for operation, x in operations:\n        if operation == 'M':\n            tree.mark(x)\n        elif operation == 'Q':\n            nearest_marked_ancestor = tree.query(x)\n            total_sum += nearest_marked_ancestor\n\n    return total_sum\n\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nparent = [0] * (N + 1)\nfor i in range(2, N + 1):\n    parent[i] = int(data[i - 1])\n\nnum_operations = int(data[N])\nindex = N + 1\noperations = []\nfor _ in range(num_operations):\n    op, x = data[index], int(data[index + 1])\n    operations.append((op, x))\n    index += 2\n\n# Calculating result\nresult = solve(N, parent, operations)\n\n# Print the result\nprint(result)",
    "timestamp": "2025-08-13 05:26:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeQuery {\n    static Map<Integer, Set<Integer>> tree = new HashMap<>();\n    static Set<Integer> marked = new HashSet<>();\n    static Map<Integer, Integer> parent = new HashMap<>();\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n        \n        for (int i = 1; i <= N; i++) {\n            tree.put(i, new HashSet<>());\n        }\n        \n        for (int i = 2; i <= N; i++) {\n            int p = sc.nextInt();\n            tree.get(p).add(i);\n            parent.put(i, p);\n        }\n        \n        marked.add(1);\n        \n        long querySum = 0;\n        for (int i = 0; i < Q; i++) {\n            String operation = sc.next();\n            int u = sc.nextInt();\n            if (operation.equals(\"mark\")) {\n                mark(u);\n            } else if (operation.equals(\"query\")) {\n                querySum += query(u);\n            }\n        }\n        \n        System.out.println(querySum);\n    }\n    \n    static void mark(int u) {\n        marked.add(u);\n    }\n    \n    static int query(int u) {\n        while (!marked.contains(u)) {\n            u = parent.get(u);\n        }\n        return u;\n    }\n}",
    "timestamp": "2025-08-13 05:26:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100000\n\ntypedef struct Node {\n    int parent;\n    int markedAncestor;\n} Node;\n\nNode nodes[MAXN + 1];\nint N, Q;\n\nvoid markNode(int x) {\n    nodes[x].markedAncestor = x;\n}\n\nint findMarkedAncestor(int x) {\n    if (nodes[x].parent == x) {\n        return nodes[x].markedAncestor;\n    }\n    int ancestor = findMarkedAncestor(nodes[x].parent);\n    nodes[x].markedAncestor = ancestor;\n    return ancestor;\n}\n\nint main() {\n    int i, operationType, node;\n    scanf(\"%d\", &N); // Number of nodes\n    for (i = 2; i <= N; i++) {\n        scanf(\"%d\", &nodes[i].parent); // Parent of the ith node\n    }\n    nodes[1].parent = 1; // Root node case\n    nodes[1].markedAncestor = 1; // Initially only root is marked\n    \n    scanf(\"%d\", &Q); // Number of operations\n    int sumQueries = 0;\n    while (Q--) {\n        scanf(\"%d%d\", &operationType, &node);\n        if (operationType == 1) { // Mark the node\n            markNode(node);\n        } else if (operationType == 2) { // Query the nearest marked ancestor\n            sumQueries += findMarkedAncestor(node);\n        }\n    }\n    printf(\"%d\\n\", sumQueries);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:27:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeAncestor:\n    def __init__(self, N):\n        self.N = N\n        self.parent = [0] * (N + 1)\n        self.depth = [0] * (N + 1)\n        self.marked = [False] * (N + 1)\n        self.marked[1] = True\n\n    def set_parent(self, node, p):\n        self.parent[node] = p\n        self.depth[node] = self.depth[p] + 1\n\n    def mark(self, node):\n        self.marked[node] = True\n\n    def query(self, node):\n        current = node\n        while current > 0:\n            if self.marked[current]:\n                return current\n            current = self.parent[current]\n        return -1\n\ndef solve():\n    N, Q = map(int, input().split())\n    ancestor = TreeAncestor(N)\n\n    for i in range(2, N + 1):\n        p = int(input())\n        ancestor.set_parent(i, p)\n\n    total_sum = 0\n    for _ in range(Q):\n        op = list(map(int, input().split()))\n        \n        if op[0] == 1:\n            ancestor.mark(op[1])\n        else:\n            result = ancestor.query(op[1])\n            total_sum += result\n\n    print(total_sum)\n\nsolve()",
    "timestamp": "2025-08-13 05:27:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom math import log2, floor\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, Q = map(int, input[ptr:ptr+2])\n    ptr +=2\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr +=2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    LOG = floor(log2(N)) + 1\n    parent = [[-1]*(N+1) for _ in range(LOG)]\n    depth = [0]*(N+1)\n    \n    stack = [(1, -1)]\n    while stack:\n        u, p = stack.pop()\n        parent[0][u] = p\n        for v in adj[u]:\n            if v != p:\n                depth[v] = depth[u] + 1\n                stack.append((v, u))\n    \n    for k in range(1, LOG):\n        for u in range(1, N+1):\n            if parent[k-1][u] != -1:\n                parent[k][u] = parent[k-1][parent[k-1][u]]\n    \n    marked = [False]*(N+1)\n    marked[1] = True\n    \n    res = 0\n    \n    for _ in range(Q):\n        parts = input[ptr]\n        ptr +=1\n        if parts == '1':\n            u = int(input[ptr])\n            ptr +=1\n            marked[u] = True\n        else:\n            u = int(input[ptr])\n            ptr +=1\n            if marked[u]:\n                res += u\n                continue\n            current = u\n            for k in range(LOG-1, -1, -1):\n                if parent[k][current] != -1 and not marked[parent[k][current]]:\n                    current = parent[k][current]\n            if parent[0][current] != -1 and marked[parent[0][current]]:\n                res += parent[0][current]\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:27:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\n// Function to perform DFS and build parent relationships\nvoid dfs(int node, const vector<vector<int>>& tree, vector<int>& parent) {\n    for (int child : tree[node]) {\n        if (parent[child] == -1) {\n            parent[child] = node;\n            dfs(child, tree, parent);\n        }\n    }\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    \n    vector<vector<int>> tree(N + 1);\n    vector<int> parent(N + 1, -1);\n    parent[1] = 0; // Root has no parent.\n    \n    for (int i = 1; i < N; ++i) {\n        int u, v;\n        cin >> u >> v;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n    }\n    \n    dfs(1, tree, parent);\n    \n    unordered_set<int> marked;\n    marked.insert(1);\n    \n    int sum_of_results = 0;\n    \n    while (Q--) {\n        int type, node;\n        cin >> type >> node;\n        \n        if (type == 1) {\n            marked.insert(node);\n        } else if (type == 2) {\n            int current = node;\n            while (current != 0) {\n                if (marked.count(current)) {\n                    sum_of_results += current;\n                    break;\n                }\n                current = parent[current];\n            }\n        }\n    }\n    \n    cout << sum_of_results << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:14"
  }
]