[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst int MAX = 1e5;\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvector<int> tr[MAX+1];\nint par[MAX+1],n,q;\nbool mark[MAX+1];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    \n    par[y] = x;\n}\n\nbool same(int x,int y){\n    return find(x) == find(y);\n}\n\nint tmp[MAX+1];\nvoid rec(int x,int y,int z){\n    int t = z;\n    tmp[x] = y;\n    if(mark[x]){\n        t = x;\n    }\n    unite(t,x);\n    \n    for(int i = 0 ; i < tr[x].size() ; i++){\n        rec(tr[x][i],x,t);\n    }\n}\n\nint main(){\n    int p,num;\n    char m;\n    while(cin >> n >> q , n + q){\n        ll sum = 0;\n        stack<P> st;\n        init();\n        fill(mark,mark+MAX,false);\n        fill(tmp,tmp+MAX,0);\n        mark[0] = true;\n        for(int i = 0 ; i < MAX ; i++){\n            tr[i].clear();\n        }\n        for(int i = 1 ; i < n ; i++){\n            cin >> p; --p;\n            tr[p].push_back(i);\n        }\n        for(int i = 0 ; i < q ; i++){\n            cin >> m >> num; --num;\n            st.push(P(m,num));\n            \n            if(m == 'M'){\n                mark[num] = true;\n            }\n        }\n        rec(0,-1,-1);\n        while(q--){\n            P p = st.top(); st.pop();\n            \n            if(p.first == 'Q'){\n                sum += find(p.second);\n            }\n            else{\n                if(!mark[p.second]) {\n                    mark[p.second] = false;\n                    unite(tmp[p.second],p.second);\n                }\n            }\n        }\n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            if(a==1){ans++; continue;}\n            a=P[a-1];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m+1;}\n            }\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; break;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 100001\n\ntypedef unsigned long long ull;\n\nbool M[MAX_N];   // マークされてるかどうか\nint P[MAX_N];   // 親\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N != 0 && Q != 0) {\n        memset(M, 0, sizeof(M));\n        M[1] = true;\n        memset(P, 0, sizeof(P));\n        for (int i = 2; i < N+1; i++) {\n            int p; cin >> p;\n            P[i] = p;\n        }\n\n//        for (int i = 1; i <= N; i++) cout << P[i] << ' ';\n//        cout << endl;\n//        for (int i = 1; i <= N; i++) cout << M[i] << ' ';\n//        cout << endl;\n\n        ull sum = 0;\n        for (int i = 0; i < Q; i++) {\n            char q; int v;\n            cin >> q >> v;\n            if (q == 'Q') {\n                while (!M[v]) {\n                    v = P[v];\n                }\n                sum += v;\n            } else {\n                M[v] = true;\n            }\n        }\n//        for (int i = 1; i <= N; i++) cout << M[i] << ' ';\n//        cout << endl;\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint parent[100001];\nint ans[100001];\npair<char,int> query[100001];\n\nvoid Init(int n){\n\n    for(int i=1;i<=n;++i)\n        ans[i] = parent[i];\n\n}\n\nint Find(int x){\n\n    return x==ans[x]?x:(ans[x]=Find(ans[x]));\n\n}\n\nvoid Union(int x, int y){\n\n    ans[Find(x)] = Find(y);\n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    int N,Q;\n\n    while(1){\n\n        cin >> N >> Q;\n\n        if(N==0 && Q==0)break;\n\n        parent[1] = 1;\n\n        for(int i=2;i<=N;++i){\n\n            int x;\n\n            cin >> x;\n\n            parent[i] = x;\n\n        }\n\n        Init(N);\n\n        long long sum = 0;\n\n        for(int i=0;i<Q;++i){\n\n            string str;\n            int x;\n\n            cin >> str >> x;\n\n            query[i] = make_pair(str[0],x);\n\n            if(str==\"M\") ans[x] = x;\n\n        }\n\n        for(int i=Q-1;i>=0;--i){\n\n            pair<char,int> p = query[i];\n\n            if(p.first == 'Q'){\n\n                sum += Find(p.second);\n\n            } else {\n\n                Union(p.second,parent[p.second]);\n\n            }\n\n        }\n       \n        cout << sum << endl;\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100005;\n\nstruct Node\n{\n\tint p; //親のノード番号\n\tbool m; //Markされているか否か\n};\n\nNode A[MAX]; //memo:ノード番号は1~Nなので0は使わないことにする\n\nvoid init()\n{\n\tfor (int i = 1; i < MAX; ++i)\n\t{\n\t\tA[i].m = false;\n\t}\n\tA[1].m = true;\n\n\tA[1].p = 1;\n}\n\nint query(int n)\n{\n\tif (A[n].m)\n\t{\n\t\treturn n;\n\t}\n\telse\n\t{\n\t\tquery(A[n].p);\n\t}\n}\n\nvoid mark(int n)\n{\n\tA[n].m = true;\n}\n\nint main()\n{\n\tinit();\n\tint N,Q,v;\n\tchar s;\n\twhile((cin >> N >> Q)&&(N > 0))\n\t{\n\t\tinit();\n\n\t\tfor (int i = 2; i <= N; ++i)\n\t\t{\n\t\t\tcin >> v;\n\t\t\tA[i].p = v;\n\t\t}\n\n\t\tlong long ans = 0;\n\n\t\tfor (int i = 0; i < Q; ++i)\n\t\t{\n\t\t\tcin >> s >> v;\n\t\t\tif (s == 'M')\n\t\t\t{\n\t\t\t\tmark(v);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += query(v);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <cmath>\n#include <string.h>\n#include <iostream>\n#include<algorithm>\n#include <queue>\n#include <vector>\n#include<string>\n//******************************************************\n#define lrt (rt*2)\n#define rrt  (rt*2+1)\n#define LL long long\n#define inf 0x3f3f3f3f\n#define pi acos(-1.0)\n#define exp 1e-8\nconst double temp=(1+sqrt(5))/2;\n//***************************************************\n#define eps             1e-8\n#define inf             0x3f3f3f3f\n#define INF             2e18\n#define LL              long long\n#define ULL             unsigned long long\n#define PI              acos(-1.0)\n#define pb              push_back\n#define mk              make_pair\n\n#define all(a)          a.begin(),a.end()\n#define rall(a)         a.rbegin(),a.rend()\n#define SQR(a)          ((a)*(a))\n#define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\n#define min3(a,b,c)     min(a,min(b,c))\n#define max3(a,b,c)     max(a,max(b,c))\n#define min4(a,b,c,d)   min(min(a,b),min(c,d))\n#define max4(a,b,c,d)   max(max(a,b),max(c,d))\n#define max5(a,b,c,d,e) max(max3(a,b,c),max(d,e))\n#define min5(a,b,c,d,e) min(min3(a,b,c),min(d,e))\n#define Iterator(a)     __typeof__(a.begin())\n#define rIterator(a)    __typeof__(a.rbegin())\n#define FastRead        ios_base::sync_with_stdio(0);cin.tie(0)\n#define CasePrint       pc('C'); pc('a'); pc('s'); pc('e'); pc(' '); write(qq++,false); pc(':'); pc(' ')\n#define vi              vector <int>\n#define vL              vector <LL>\n#define For(I,A,B)      for(int I = (A); I < (B); ++I)\n#define rFor(I,A,B)     for(int I = (A); I >= (B); --I)\n#define Rep(I,N)        For(I,0,N)\nusing namespace std;\nconst int maxn=1e5+10;\nint pre[maxn];\nvoid iint()\n{\n    for(int i=0;i<maxn;i++) pre[i]=i;\n}\nint find(int x)\n{\n    return x==pre[x]?x:find(pre[x]);\n}\nvoid join(int x,int y)\n{\n    int fx=find(x),fy=find(y);\n    if(fx!=fy)  pre[fx]=fy;\n}\nint main()\n{\n    int n,k,num;\n    char str[5];\n    while(cin>>n>>k)\n    {\n        LL sum=0;\n        if(n+k==0)  break;\n        iint();\n        for(int i=2;i<=n;i++)\n        {\n            scanf(\"%d\",&pre[i]);\n        }\n        while(k--)\n        {\n            scanf(\"%s%d\",str,&num);\n            if(str[0]=='M') pre[num]=num;\n            else if(str[0]=='Q')    sum+=find(num);\n        }\n        cout<<sum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 2e5 + 4;\nint par[maxn];\nint x[1010], y[1010];\nint find(int x){\n\tif(par[x] == x) return x;\n\telse return find(par[x]);\n}\nint main(){\n\tint n, q;\n\twhile(scanf(\"%d%d\", &n, &q)!=EOF){\n\t\tif(n == 0 && q == 0) break;\n\t\tpar[1] = 1;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tll ans = 0;\n\t\twhile(q--){\n\t\t\tchar s[2];\n\t\t\tint x;\n\t\t\tscanf(\"%s\", s);\n\t\t\tif(s[0] == 'Q'){\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tans += find(x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tpar[x] = x;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint par[100000];\nint mark[100000];\nint uf[100000];\nint root(int x){\n  if(uf[x] == x) return x;\n  return uf[x] = root(uf[x]);\n}\nint main(){\n  int N, Q;\n  while(cin>>N>>Q && N){\n    par[0] = -1;\n    uf[0] = 0;\n    REP(i, N - 1){\n      cin>>par[i + 1];\n      uf[i + 1] = par[i + 1];\n    }\n    memset(mark, 0, sizeof(mark));\n    char c[100000];\n    int v[100000];\n    REP(i, Q){\n      cin>>c[i]>>v[i];\n      if(c[i] == 'M'){\n        mark[v[i]]++;\n      }\n    }\n    REP(i, N) if(mark[i] > 0){\n      uf[i] = i;\n    }\n    ll ans = 0;\n    for(int i = Q - 1; i >= 0; i--){\n      if(c[i] == 'M'){\n        mark[v[i]]--;\n        if(mark[v[i]] == 0){\n          uf[v[i]] = par[v[i]];\n        }\n      }else{\n        ans += root(v[i]);\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[i+1].emplace_back(p, 1);\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tvector<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.push_back(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, pii>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), pii(*u, -1));\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tconst pii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second.first;\n\t\t\t\t\tconst int p = que.front().second.second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v].first <= c.first) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tFOR(e, g[v])if(e->first!=p)\n\t\t\t\t\t\tque.emplace(pii(c.first+1, c.second), pii(e->first, v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int maxn=1e5+10;\nint m[maxn],par[maxn];\nint n,i,j,q,v;\n\nint find(int x){ return (par[x]==x)?x:find(par[x]);}\n\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\twhile (n!=0&&q!=0){\n\t  ll ans=0; par[1]=1;\n\t  for (i=2;i<=n;i++) scanf(\"%d\",&par[i]);\n\t  for (i=1;i<=q;i++){\n        char ch; getchar();\n\t    scanf(\"%c %d\",&ch,&v);\n\t    if (ch=='M') par[v]=v; else ans+=find(v);\n      }\n      printf(\"%lld\\n\",ans);\n      scanf(\"%d%d\",&n,&q);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(auto & e : es) addEdge(e >> 32, e & 0xFFFFFFFF);\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]].emplace(-depth[v], v);\n    }\n    int query(int v){\n        while(1){\n            dump(v);\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(v);\n            if(it != ms.end()){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        return 0;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nint solve(){\n    int ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q'){\n            ans += h.query(qv[i]) + 1;\n        } else {\n            h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[i+1].eb(i+1,par);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nll sum;\nint find(int x,int flag){\n    if(flag)    return 0;\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                if(vis[t])  sum+=t;\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        if(x!=0) return root(x)-n+1;\n        else     return 0;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nstruct Chain {\n\tvector<int> nodes;\n\tset<int> marked; // INDEX of marked nodes\n};\n\nint n, q;\nvector<int> G[100005];\nint parent[100005];\nint ts[100005]; // treesize\nint heavy[100005]; // heavy child\nint dep[100005]; // depth\nint chainof[100005]; // chain id\nvector<Chain> chains; // HLD-chains\n\nint progress = 0;\n\nvoid dfs(int n) {\n\t//cout << \"DFS \" << n << \" \" << ++progress << \" \" << ::n << endl;\n\tts[n] = 1;\n\tdep[n] = n == 1 ? 1 : dep[parent[n]] + 1;\n\tfor (int h : G[n]) {\n\t\tdfs(h);\n\t\tts[n] += ts[h];\n\t\tif (!heavy[n] || ts[h] > ts[heavy[n]]) heavy[n] = h;\n\t}\n}\n\nvoid hld(int n, int chain = -1) {\n\t//cout << \"HLD \" << n << ++progress << \" \" << ::n << endl;\n\tif (n == 1) {\n\t\tchain = chainof[n] = chains.size();\n\t\tchains.push_back(Chain());\n\t\tchains[chain].marked.insert(0); // root node is always marked\n\t}\n\t//cout << n << \" belongs to chain \" << chain << endl;\n\tchainof[n] = chain;\n\tchains[chainof[n]].nodes.push_back(n);\n\tif (heavy[n]) hld(heavy[n], chain);\n\tfor (int h : G[n]) if (h != heavy[n]) {\n\t\tchainof[h] = chains.size();\n\t\tchains.push_back(Chain());\n\t\thld(h, chainof[h]);\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(false); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\twhile (true) {\n\t\tcin >> n >> q; if (!n && !q) break;\n\n\t\t// reset\n\t\tchains.clear();\n\t\trep(i, 1, n + 1) {\n\t\t\tG[i].clear();\n\t\t\tparent[i] = ts[i] = dep[i] = chainof[i] = heavy[i] = 0;\n\t\t}\n\t\tchains.push_back(Chain());\n\n\t\tparent[1] = 0;\n\t\trep(i, 2, n + 1) { cin >> parent[i]; G[parent[i]].push_back(i); }\n\n\t\tdfs(1);\n\t\thld(1);\n\n\t\tll acc = 0;\n\n\t\trep(i, 0, q) {\n\t\t\tstring op; int v;\n\t\t\tcin >> op >> v;\n\t\t\t//cout << op << \" \" << v << flush << endl;\n\n\t\t\tif (op[0] == 'M') {\n\t\t\t\tChain& chain = chains[chainof[v]];\n\t\t\t\tchain.marked.insert(dep[v] - dep[chain.nodes.front()]);\n\t\t\t\t//cout << \"Inserted \" << (dep[v] - dep[chain.nodes.front()]) << \" to chain \" << chainof[v] << endl;\n\t\t\t} else if (op[0] == 'Q') {\n\t\t\t\tint cnode = v;\n\t\t\t\t//cout << \"Chain: \" << chainid << \", size: \" << chains[chainid].nodes.size() << endl;\n\t\t\t\twhile (true) {\n\t\t\t\t\tint chainid = chainof[cnode];\n\t\t\t\t\tChain& chain = chains[chainid];\n\t\t\t\t\t//cout << \"Chain \" << chainid << \", Node \" << cnode << endl;\n\t\t\t\t\t//getchar();\n\t\t\t\t\tauto it = chain.marked.upper_bound(dep[cnode] - dep[chain.nodes.front()]);\n\t\t\t\t\tif (it != chain.marked.begin()) {\n\t\t\t\t\t\tacc += chain.nodes[*prev(it)];\n\t\t\t\t\t\t//cout << \"Is: \" << chain.nodes[*prev(it)] << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcnode = parent[chain.nodes.front()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << acc << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<vector>\n#include<cstdio>\n#define MAXN 2555\n#define INF 0x3f3f3f3f\n#define v first\n#define b second\nusing namespace std;\nint p[100005];\nbool vis[100005];\nlong long sum;\nint Find(int x)\n{\n   if(p[x]==x)\n      return x;\n   else return p[x]=Find(p[x]);\n}\nvoid Find2(int x)\n{\n   if(vis[x])\n   {\n      sum+=x;\n      return ;\n   }\n   if(p[x]==x)\n      return ;\n   else Find2(p[x]);\n}\nvoid init(int n)\n{\n   memset(vis,false,sizeof(vis));\n   for(int i=1;i<=n;i++)\n      p[i]=i;\n}\nint main()\n{\n   #ifdef XT\n   freopen(\"2170-input.txt\",\"r\",stdin);\n   #endif // XT\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m)==2)\n   {\n      if(n==m&&n==0)\n         break;\n      init(n);\n      vis[1]=true;\n      for(int i=2;i<=n;i++)\n      {\n         int a;\n         scanf(\"%d\",&a);\n         int x=Find(i);\n         p[x]=a;\n      }\n      sum=0;\n      for(int i=0;i<m;i++)\n      {\n         char a[5];int b;\n         scanf(\"%s %d\",a,&b);\n         if(a[0]=='M') vis[b]=true;\n         if(a[0]=='Q')\n         Find2(b);\n      }\n      cout<<sum<<endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nint parent[MAX_N+1];\nchar op[MAX_N+1];\nint node[MAX_N+1];\nbool marked[MAX_N+1];\n\nvoid init()\n{\n  marked[1] = true;\n  for (int i = 2; i <= N; i++)\n  {\n    marked[i] = false;\n  }\n}\n\nint find(int x)\n{\n  if (marked[x]) return x;\n  else return find(parent[x]);\n}\n\nint main()\n{\n  parent[1] = 1;\n\n  while(1)\n  {\n    int ans = 0;\n\n    cin >> N >> Q;\n    if (N == 0 && Q == 0)\n    {\n      printf(\"%d\\n\", ans);\n      return 0;\n    }\n    for(int i=2; i<=N; i++)\n    {\n      scanf(\"%d\", &parent[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n      cin >> op[i] >> node[i];\n    }\n\n    init();\n\n    for(int i = 0; i < Q; i++)\n    {\n      switch (op[i]) {\n      case 'Q':\n        ans += find(node[i]);\n        break;\n      case 'M':\n        marked[node[i]] = true;\n        break;\n      default:\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 10001;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  int ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool vis[100000], marked[100000];\nint qtype[100000], vertex[100000];\n\nint par[100000], pp[100000];\n\nvoid init()\n{\n\tfor (int i = 0; i < 100000; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return (x);\n\treturn (par[x] = find(par[x]));\n}\n\nbool same(int x, int y)\n{\n\treturn (find(x) == find(y));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x != y){\n\t\tpar[y] = x;\n\t}\n}\n\nvoid dfs(int v, int p, int m)\n{\n\tint nm = m;\n\tif (marked[v]) nm = v;\n\tpp[v] = p;\n\t\n\tmerge(nm, v);\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tdfs(G[v][i], v, nm);\n\t}\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\twhile (scanf(\"%d %d\", &N, &Q) && N){\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\t\n\t\tfor (int i = 1; i < N; i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tG[--v].push_back(i);\n\t\t}\n\t\t\n\t\tinit();\n\t\t\n\t\tmarked[0] = true;\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tchar t[10];\n\t\t\tscanf(\"%s %d\", t, vertex + i);\n\t\t\tqtype[i] = (t[0] == 'Q');\n\t\t\t--vertex[i];\n\t\t\tif (!qtype[i]) marked[vertex[i]] = true;\n\t\t}\n\t\t\n\t\tdfs(0, -1, -1);\n\t\t\n\t\tlong long int ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--){\n\t\t\tif (qtype[i]){\n\t\t\t\tans += find(vertex[i]) + 1;\n\t\t\t}\n\t\t\telse merge(pp[vertex[i]], vertex[i]);\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#pragma warning(disable: 4996)\n//FILE *ins = freopen(\"2170_input.txt\", \"r\", stdin);\n//FILE *out = freopen(\"2170_output.txt\", \"w\", stdout);\nint N, Q, T[100000], V[100000]; char W[100001]; bool marked[100000];\nint par[100000];\nint root(int x) {\n\treturn par[x] == x ? x : par[x] = root(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = root(x), y = root(y); if (x != y) par[x] = y;\n}\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break; T[0] = -1;\n\t\tfor (int i = 1; i < N; i++) scanf(\"%d\", &T[i]), T[i]--; getchar();\n\t\tfor (int i = 0; i < Q; i++) scanf(\"%c%d\", &W[i], &V[i]), V[i]--, getchar();\n\t\tfor (int i = 0; i < N; i++) par[i] = i, marked[i] = false;\n\t\tfor (int i = 0; i < N; i++) if (W[i] == 'M') marked[V[i]] = true;\n\t\tfor (int i = 1; i < N; i++) if (!marked[i]) unite(i, T[i]);\n\t\tlong long ret = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tif (W[i] == 'Q') {\n\t\t\t\tret += root(V[i]) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunite(V[i], T[V[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tscanf(\"%d%d\", &n, &q);\n//\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[1] = true;\n\tfor(int i = 1;i < n;i++){\n\t    cin >> root[i];\n\t    root[i]--;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    query[i].second--;\n\t    marked[query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q;i-- > 0;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second) + 1;\n\t    }\n\t}\n\tprintf(\"%lld\\n\", res);\n//\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],pa[MAXN],n,m,used[MAXN];\nlong long ans;\nchar c;\npair<int,int> a[MAXN];\nint get_fa(int x){\n    if(fa[x]==0)\n        return x;\n    fa[x]=get_fa(fa[x]);\n    return fa[x];\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    while(n*m!=0){\n        memset(fa,0,sizeof fa);\n        for(int i=2;i<=n;i++)\n            SF(\"%d\",&pa[i]);\n        int x;\n        for(int i=1;i<=m;i++){\n            SF(\"\\n\");\n            SF(\"%c\",&c);\n            SF(\"%d\",&x);\n            if(c=='M'){\n                a[i].first=0;\n                a[i].second=x;\n                used[x]=1;\n            }\n            else{\n                a[i].first=1;\n                a[i].second=x;\n            }\n        }\n        for(int i=2;i<=n;i++)\n            if(used[i]==0)\n                fa[i]=get_fa(pa[i]);\n        for(int i=m;i>=1;i--){\n            if(a[i].first==0)\n                fa[i]=get_fa(pa[i]);\n            else\n                ans+=get_fa(i);\n        }\n        PF(\"%lld\\n\",ans);\n        SF(\"%d%d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            (uf.c[p-1]).push_back(i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        int a,b;\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct node{\n    int id;\n    node* parent;\n    int h;\n    vector<node*> child;\n};\nbool com(node* n1,node* n2){\n    return n1->id<n2->id;\n}\nint main(){\n    int n,q,p;\n    while(cin>>n>>q,n){\n        vector<node*>vec;\n        vector<node*>marked;\n        node* no=new node;\n        no->id=1;\n        no->parent=no;\n        no->h=1;\n        vec.push_back(no);\n        marked.push_back(no);\n        for(int i=2;i<=n;i++){\n            cin>>p;\n            node* no=new node;\n            no->id=i;\n            no->parent=vec[p-1];\n            no->h=no->parent->h+1;\n            vec[p-1]->child.push_back(no);\n            vec.push_back(no);\n        }\n        int ans=0;\n        for(int i=0;i<q;i++){\n            char que;int num;\n            cin>>que>>num;\n            if(que=='M'){\n                marked.push_back(vec[num-1]);\n            }\n            else{\n                node* pa=vec[num-1]->parent;\n                int found=0;\n                while(true){\n                    int ma=0;\n                    sort(marked.begin(),marked.end(),com);\n                    if(binary_search(marked.begin(), marked.end(), pa, com)){\n                        ma=max(ma,pa->id);\n                        found=1;\n                    }\n                    if(found){\n                        ans+=ma;\n                        goto next;\n                    }\n                    if(pa->id==1){\n                        goto next;\n                    }\n                    pa=vec[pa->id]->parent;\n                }\n                \n            next:;\n            }\n        }\n        cout<<ans<<endl;;\n        vec.clear();\n        marked.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\n// lazy evaluate segment tree\ntypedef int data_type;\nconst data_type dINF = iINF;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\t//update_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\t//update_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \" << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q; int v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t\t\n\t\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\ntypedef long long int lli;\n\nusing namespace std;\n\nint N,Q;\nint a[100005][2];\nchar q1[100005];\nint q2[100005];\nvector<int> vec[1000000];\n//vector<vector<int> > vec(1000000);\n//vec = vector < vector <int> >(1000000,vector<int>(100000,0)) ;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); ++it){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  lli res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%lld\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n//    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\troot[p] = v;\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\tif( root[edge[p][i]] == edge[p][i] ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tupdate(edge[p][i], v);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, q;\n\twhile(cin >> n >> q, n||q) {\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = -1;\n\t\tint sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nclass UnionFind\n{\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n)\n  {\n    par.resize(n);\n    rank.resize(n);\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x)\n  {\n    if (par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main()\n{\n  while (cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for (int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for (int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    M[0] = true;\n    for (int i = 0; i < Q; ++i)\n      if (op[i] == 'M') M[v[i]] = true;\n\n    UnionFind uf(N);\n    vector<int> nearest(N);\n    for (int st = 0; st < N; ++st) {\n      if (!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while (que.size()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if (M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    lli res = 0;\n    for (int i = 0; i < Q; ++i) {\n      if (op[i] == 'Q') {\n        res += nearest[uf.find(par[v[i]])] + 1;\n      } else {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout<< res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nbool flag[MAX_N];\nint ran[MAX_N];\nvoid init(int n) {\n\tfor(int i=2; i<=n; i++) {\t\t\n\t\tflag[i] = false;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif(flag[x])\n\t\treturn x;\n\telse\n\t\tfind(par[x]);\n}\n\nvoid unite(int x,int y) {\n\tx = find(x);\n\ty = find(y);\n\n\tif(x==y) return;\n\n\tif(ran[x]<ran[y]) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif(ran[x]==ran[y]) ran[x]++;\n\t}\n}\n\nbool same(int x,int y) {\n\treturn find(x)==find(y);\n}\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tlong long sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tflag[1] = true;\n\t\tinit(n);\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(par[p]);\n\t\t\t}else{\n\t\t\t\tflag[p] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(long i=0; i<(n); i++)\n#define dmp(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nbool m[100009];\nlong a[100009];\nchar c[100009];\nlong d[100009];\n\nlong long calc(int n)\n{\n  if(m[n])\n    return n;\n  else\n    return calc(a[n]);\n}\n\nint main()\n{\n  int N,Q;\n  while(scanf(\"%d %d\", &N, &Q),N+Q){\n    for(int i=2;i<N+1;i++)\n      scanf(\"%ld\",a+i);\n    rep(i,N+2) m[i]=false;\n    m[1]=true;\n    rep(i,Q)\n      scanf(\" %c %ld\", c+i,d+i);\n    \n    long long ret=0;\n    \n    rep(i,Q) switch(c[i]) {\n    case 'M':\n      m[d[i]]=true;\n      break;\n    case 'Q':\n      ret += calc(d[i]);\n      break;\n    }\n    printf(\"%lld\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "class UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parents = [-1] + [int(input()) - 1 for _ in range(N - 1)]\n    queries = []\n    marked = set()\n    for _ in range(Q):\n        k, v = input().split()\n        v = int(v) - 1\n        queries.append((k, v))\n        if k == \"M\":\n            marked.add(v)\n    uf = UnionFindTree(N)\n    for i in range(1, N):\n        if i not in marked:\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    ans = 0\n    for k, v in reversed(queries):\n        if k == \"Q\":\n            ans += uf.find(v)\n        elif not uf.same(v, parents[v]):\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    print(ans)\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, Graph& revg, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        g.addEdge(s, to);\n        revg.addEdge(to, s);\n        make_dfs(to, g_, g, revg, visited);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        for (int i = 0; i < N - 1; i++) {\n            int to;\n            cin >> to;\n            to--;\n            g_.addEdge(to, i);\n            g_.addEdge(i, to);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        Graph revg(N);\n        make_dfs(0, g_, g, revg, visited);\n\n        using P = pair<char, int>;\n        vector<P> query(Q);\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = 0;\n        }\n        vector<bool> drawn(N, false);\n        drawn[0] = true;\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            query[q] = make_pair(c, n);\n            if (c == 'M') {\n                if (drawn[n]) {\n                    continue;\n                }\n                drawn[n] = true;\n                comp[n] = n;\n                marked[n] = true;\n            }\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        int sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n\n                const int s = q.second;\n                const int par = revg.edge[s][0];\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        // y を x に統合\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(parent[i], i);\n            }\n        }\n\n        ll ans = 0;\n        for(int i=Q-1; i>=0; i--) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define FOR(i,x,y) for(int i=(x);i<=(y);i++)\n#define DOR(i,x,y) for(int i=(x);i>=(y);i--)\n#define M 200005\n#define N 100005\nstruct node{\n\tchar op[3];\n\tint x;\n}Q[M];\nbool mark[N];\nint Fa[N],fa[N],ans[M];\nint find(int x){return x==Fa[x]?x:Fa[x]=find(Fa[x]);}\n\nint main(){\n\tint n,q;\n\tfa[1]=1;\n\twhile(~scanf(\"%d%d\",&n,&q)&&(n||q)){\n\t\tmemset(mark,0,sizeof mark);\n\t\tFOR(i,2,n)scanf(\"%d\",&fa[i]);\n\t\tFOR(i,1,n)Fa[i]=i;\n\t\tFOR(i,1,q){\n\t\t\tscanf(\"%s%d\",Q[i].op,&Q[i].x);\n\t\t\tif(Q[i].op[0]=='M'){\n\t\t\t\tif(!mark[Q[i].x])mark[Q[i].x]=1;\n\t\t\t\telse Q[i].x=0;\n\t\t\t}\n\t\t}\n\t\tFOR(i,1,n)if(!mark[i])Q[++q].op[0]='M',Q[q].x=i;\n\t\t\n\t\tmemset(mark,0,sizeof mark);\n\t\tDOR(i,q,1){\n\t\t\tint x=Q[i].x;\n\t\t\tif(Q[i].op[0]=='M'){\n\t\t\t\tif(Q[i].x!=0)Fa[x]=find(fa[Fa[x]]);\t\n\t\t\t}\n\t\t\telse ans[i]=find(x);\n\t\t}\n\t\t\n\t\tlong long tmp=0;\n\t\tFOR(i,1,q)if(Q[i].op[0]=='Q')tmp+=ans[i];\n\t\tprintf(\"%lld\\n\",tmp);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\tint t;\n\t\trep(i, n-1) {\n\t\t\tcin >> t; t--;\n\t\t\tpar0[i + 1] = t;\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)(find(p[i].second)+1);\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\nint par[100001];\nint rank1[100001];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n);\n\t\trep(i, n-1) {\n\t\t\tcin >> par[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tint marked[100001] = {}; marked[0] = 1;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\tll out = 0;\n\t\trep(i,n+1) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100005][2];\nchar q1[100005];\nint q2[100005];\nvector<vector<int> > vec(1000000);\n//vec = vector < vector <int> >(1000000,vector<int>(100000,0)) ;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); it++){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 1e5 + 10;\n\nstruct UnionFind{\n\tvector<int> par;\n\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trep(i, n) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tpar[find(x)] = find(y);\n\t}\n};\n\nint p[N], qv[N];\nchar qc[N];\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n){\n\t\tFOR(i, 1, n) cin >> p[i], --p[i];\n\t\tset<int> ok;\n\t\trep(i, q){\n\t\t\tcin >> qc[i] >> qv[i], --qv[i];\n\t\t\tif (qc[i] == 'M'){\n\t\t\t\tif (ok.count(qv[i])) qv[i] = -1;\n\t\t\t\telse ok.insert(qv[i]);\n\t\t\t}\n\t\t}\n\t\tset<int> s;\n\t\trep(i, q){\n\t\t\tif (qc[i] == 'M') s.insert(qv[i]);\n\t\t}\n\n\t\tUnionFind uf(n);\n\n\t\trep(i, n) if (!s.count(i)) uf.unite(i, p[i]);\n\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; --i){\n\t\t\tif (qv[i] < 0) continue;\n\t\t\tif (qc[i] == 'M'){\n\t\t\t\tuf.unite(qv[i], p[qv[i]]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += uf.find(qv[i]) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n//< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy += max(seg[2 * k+1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl , vr);\n}\n\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root),cnum(V),place(V),id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v]+=dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v]+1;\n\t}\n\n\tvoid getid(const int v, const int p,int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tupdate(1, N, 0);\n\t\tvector<int>nums;\n\t\tnums.push_back(0);\n\t\tTree t(N,0);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tt.unite(a, i+1);\n\t\t}\n\t\tt.init();\n\t\tint asum = 0;\n\t\twhile (Q--) {\n\t\t\tchar c;int  n;\n\t\t\tcin >> c >> n;\n\t\t\tconst int aplace = t.place[n];\n\t\t\tif (c == 'M') {\n\t\t\t\tupdate(aplace+1, aplace + t.cnum[n-1]+1, n-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans = get(aplace, aplace);\n\t\t\t\tasum += ans+1;\n\t\t\t}\n\t\t}\n\t\tcout << asum << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nint pre[maxn];\nvoid init(int n)\n{\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tpre[i]=i;\n\t}\n}\nint find(int x)\n{\n\tint r=x;\n\twhile(r!=pre[r])\n\t{\n\t\tr=pre[r];\n\t}\n\treturn r;\n}\nint main()\n{\n\tint n,m;\n\twhile(~scanf(\"%d%d\",&n,&m))\n\t{\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpre[i]=x;\n\t\t}\n\t\tint a,b;ll ans=0;\n\t\twhile(scanf(\"%d%d\",&a,&b),a|b)\n\t\t{\n\t\t\tchar s[10];int x;\n\t\t\tscanf(\"%s%d\",s,&x);\n\t\t\tif(s[0]=='Q')\n\t\t\t{\n\t\t\t\tans+=find(x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpre[x]=x;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][18],ff[100000],ss[100000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, Q, T[100000], V[100000], marked[100000], par[100000]; char W[100001];\nint root(int x) {\n\treturn par[x] == x ? x : par[x] = root(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = root(x), y = root(y); if (x != y) par[x] = y;\n}\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break; T[0] = -1;\n\t\tfor (int i = 1; i < N; i++) scanf(\"%d\", &T[i]), T[i]--; getchar();\n\t\tfor (int i = 0; i < Q; i++) scanf(\"%c%d\", &W[i], &V[i]), V[i]--, getchar();\n\t\tfor (int i = 0; i < N; i++) par[i] = i, marked[i] = -1;\n\t\tfor (int i = 0; i < Q; i++) if (W[i] == 'M') marked[V[i]] = (marked[V[i]] == -1 ? i : marked[V[i]]);\n\t\tfor (int i = 1; i < N; i++) if (marked[i] == -1) unite(i, T[i]);\n\t\tlong long ret = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tif (W[i] == 'Q') ret += root(V[i]) + 1;\n\t\t\telse if(marked[V[i]] == i && V[i] != 0) unite(V[i], T[V[i]]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n \nusing namespace std;\n \nlong long int n, q, res;\nint root[105000], parent[105000], marktime[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n \nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    y = root[x];\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n \nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n \nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfill(marktime, marktime + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M'){\n\t\troot[query[i].second] = query[i].second;\n\t\tmarktime[query[i].second]++;\n\t    }\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tmarktime[num]--;\n\t\tif(marktime[num] == 0)\n\t\t    unite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }       \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct UF {\n    int *par;\n    UF(int n) {\n        par=new int[n];\n        for(int i=0;i<n;i++) par[i]=i;\n    }\n    int find(int x) {\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void unite(int x,int y) {\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        par[x]=y;\n    }\n    bool same(int x,int y) {\n        return find(x)==find(y);\n    }\n};\nint marked[100000];\nchar op[100000][2];\nint v[100000];\nint par[100000];\nint main() {\n    int N,Q;\n    while(scanf(\"%d %d\",&N,&Q),N) {\n        par[0]=-1;\n        for(int i=1;i<N;i++) {\n            scanf(\"%d\",&par[i]);par[i]--;\n        }\n        fill(marked,marked+100000,0);\n        marked[0]=1;\n        for(int i=0;i<Q;i++) {\n            scanf(\"%s %d\",op[i],&v[i]);v[i]--;\n            if(op[i][0]=='M') marked[v[i]]++;\n        }\n        UF u(N);\n        for(int i=1;i<N;i++) {\n            if(marked[i]==0) u.unite(i,par[i]);\n        }\n        long long ans=0;\n        for(int i=Q-1;i>=0;i--) {\n            if(op[i][0]=='M') {\n                if(marked[v[i]]>0) {\n                    marked[v[i]]--;\n                    if(marked[v[i]]==0) u.unite(v[i],par[v[i]]);\n                }\n            }else {\n                ans+=u.find(v[i])+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nlong long par[MAX_N+1];//parents\nlong long Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(long long n){\n\tfor(long long i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nlong long find(long long x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(long long x,long long y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(long long x, long long y){\n\treturn find(x) == find(y);\n}\n\nlong long N,Q;\nlong long sum = 0;\nlong long tree[MAX_N+1];\n\nlong long nearestAncstr(long long num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,long long num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nlong long num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\ttree[0] = 0;\n\tfor(long long i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tfor(int i = 0;i < Q;i++){\n\t\tcin >>symbol >>num;num--;\n\t\toperate(symbol,num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\twhile(true){\n\t\tcin >>N >>Q;\n\t\tif(N == 0 && Q == 0)break;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define SIZE_SEG 100000\n\nstruct SegNode {\n\tint depth, id;\n};\n\nstruct Node {\n\tint p, id, chsz, depth;\n\tvector<int> ch;\n};\nbool operator <(const SegNode& sn1, const SegNode& sn2) {\n\treturn sn1.depth < sn2.depth;\n}\nbool operator >(const SegNode& sn1, const SegNode& sn2) {\n\treturn sn2 < sn1;\n}\n\nint N, segSize;\nvector<Node> G;\nSegNode seg[SIZE_SEG*4];\n\nint dfs(int n, int& id, int depth) {\n\tG[n].id = id++;\n\tG[n].depth = depth;\n\n\tint sz = 0;\n\tfor (int i = 0; i < G[n].ch.size(); ++i) {\n\t\tsz += dfs(G[n].ch[i], id, depth+1);\n\t}\n\tG[n].chsz = sz;\n\n\treturn sz+1;\n}\n\nvoid init(int sz) {\n\tfor (segSize = 1; segSize < N; segSize <<= 1);\n\tfor (int i = 0; i < segSize*2-1; ++i) {\n\t\tseg[i] = (SegNode){0, 0};\n\t}\n}\nvoid update(int n, int l, int r, int L, int R, SegNode& sn) {\n\tif (L <= l && r <= R) {\n\t\tif (sn > seg[n]) seg[n] = sn;\n\t}\n\telse if (r <= L || R <= l) {\n\t\treturn;\n\t}\n\telse {\n\t\tint m = (l + r) / 2;\n\t\tupdate(n*2+1, l, m, L, R, sn);\n\t\tupdate(n*2+2, m, r, L, R, sn);\n\t}\n}\nvoid update(int L, int R, SegNode node) {\n\tupdate(0, 0, segSize, L, R, node);\n}\nSegNode get(int target) {\n\tSegNode ret = (SegNode){0, 0};\n\tint n = segSize+target-1;\n//\tcout << target << \" : \";\n\twhile (1) {\n//\t\tcout << n << \" \";\n\t\tif (seg[n] > ret) ret = seg[n];\n\t\tif (n == 0) break;\n\t\tn = (n-1)/2;\n\t}\n//\tcout << endl;\n\treturn ret;\n}\n\nint main() {\n\tint Q;\n\twhile ( cin >> N >> Q, N || Q ) {\n\t\tG.clear(); G.resize(N);\n\t\tG[0].p = 0;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tcin >> G[i].p; --G[i].p;\n\t\t\tG[G[i].p].ch.push_back(i);\n\t\t}\n\n\t\t{ int temp = 0; dfs(0, temp, 0); }\n\n\t\tinit(N);\n\n\t\tll ans = 0;\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tchar op; int id; cin >> op >> id; --id;\n\t\t\tif (op == 'M') {\n\t\t\t\tupdate(G[id].id, G[id].id+1+G[id].chsz, (SegNode){G[id].depth, id});\n//\t\t\t\tfor (int i = 0; i < segSize*2-1; ++i) {\n//\t\t\t\t\tcout << seg[i].depth << \" \" << seg[i].id << endl;\n//\t\t\t\t}\n//\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\telse { // Q\n\t\t\t\tans += get(G[id].id).id+1;\n//\t\t\t\tcout << get(G[id].id).id+1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,q,i,fa[100005],ans,a;\nbool r[100005];\nchar c;\nint find(int x)\n{\n\tif(r[x]==1)\n\t\treturn x;\n\treturn find(fa[x]);\n}\nint main()\n{\n\tfa[1]=1;\n\tr[1]=1;\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0||q==0)\n\t\t\treturn 0;\n\t\tans=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tr[i]=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tscanf(\"%d\",&fa[i]);\n\t\tfor(i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"\\n%c %d\",&c,&a);\n\t\t\tif(c=='M')\n\t\t\t\tr[a]=1;\n\t\t\tif(c=='Q')\n\t\t\t\tans=ans+find(a);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: 王文宇\n* @Date:   2018-03-18 23:31:38\n* @Last Modified by:   王文宇\n* @Last Modified time: 2018-03-18 23:38:56\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define _for(i,a,b) for(int i=a;i<=b;i++)\nconst int maxn = 100007;\nint fa[maxn],vis[maxn],n,m;\nint main(int argc, char const *argv[])\n{\n\twhile(cin>>n>>m)\n\t{\n\t\tint sum = 0;\n\t\tif(n==0&&m==0)break;\t\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfa[1]=1;\n\t\tvis[1]=1;\n\t\t_for(i,2,n)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tfa[i]=x;\n\t\t}\n\t\t_for(i,1,m)\n\t\t{\n\t\t\tchar s;\n\t\t\tint x;\n\t\t\tcin>>s>>x;\n\t\t\tif(s=='Q')\n\t\t\t{\n\t\t\t\tint k = x;\n\t\t\t\twhile(vis[k]!=1)\n\t\t\t\t{\n\t\t\t\t\tk=fa[k];\n\t\t\t\t}\n\t\t\t\tsum+=k;\n\t\t\t}\n\t\t\telse vis[x]=1;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,q;\nint tree[100001];\n\nint find(int x){\n  if(tree[x]==x) return x;\n  return tree[x]=find(tree[x]);\n}\n\nint main(){\n\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q)break;\n\n    tree[1]=1;\n    for(int i=2;i<=n;i++)cin>>tree[i];\n    \n    char ch[100001];\n    int num[100001],par[100001];\n    for(int i=0;i<q;i++){\n      cin>>ch[i]>>num[i];\n      if(ch[i]=='M'){\n\tpar[num[i]]=tree[num[i]];\n\ttree[num[i]]=num[i];\n      }\n    }\n\n    int ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(ch[i]=='M') tree[num[i]]=par[num[i]];\n      if(ch[i]=='Q') ans+=find(num[i]);\n    }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstdio>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define maxSize 100001\nusing namespace std;\n\nbool mark[maxSize];\nint p[maxSize] , f[maxSize];\nvector<int> v[maxSize];\nqueue<int> que;\npair<char, int> query[maxSize];\nstack<int> ans ;\n\nvoid init()\n{\n\tfor (int i = 0; i < maxSize; ++i)\n\t{\n\t\t p[i] = i;\n\t}\n}\n \nint parent(int i)\n{\n\tif(p[i] == i) return i;\n\treturn p[i] = parent(p[i]);\n }\n\nvoid u(int a, int b) \n{\n\tp[parent(a)] =  parent(b);\n\treturn ;\n}\n\nvoid Bfs() \n{\n\tque.push (1);\n\tp[1] = 1;\n\twhile(!que.empty())\n\t{\n\t\tint cur  = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < v[cur].size(); ++i)\n\t\t{\n\t\t\tif(mark[v[cur][i]] == true) {p[v[cur][i]] = v[cur][i];}\n\t\t\telse  p[v[cur][i]] = p[cur];\t\t \n\t\t\tque.push(v[cur][i]);\n\t\t}\t\n\t}\n\treturn ;\n}\n\nint main( )\n{\n\tint  a, N, Q;\t\n\twhile ( cin >>  N >> Q  && N && Q) {\n\t\tmemset(mark,0,sizeof(mark));\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\t if(i == 1) { f[1] = 1; continue;}\n\t\t\t cin >> a;\n\t\t\t v[a].push_back(i);\n\t\t\t f[i] = a;\n\t\t}\n\t\tmark[1] = true;\n\t\tfor (int i = 1; i <= Q; ++i)\n\t\t{\n\t\t\t  cin >> query[i].first  >> query[i].second ;\n\t\t\t  if(query[i].first == 'M') mark[query[i].second] = true;\n\t\t}\n\t\t \n\t\tBfs();\n\t\t \n\t\tfor (int i = Q; i >= 1; --i)\n\t\t{\n\t\t\t if(query[i].first == 'Q') { ans.push(parent(query[i].second)) ; continue;}\n\t\t\t mark[query[i].second] = false;\n\t\t\t p[query[i].second] = p[f[query[i].second] ];\n\t\t}\n\t\tlong long int num =0;\n\t\twhile(!ans.empty()) {\n\t \t\tnum += ans.top();\n\t \t    \tans.pop();\n\t\t}\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX_N 100001\n#define MAX_Q 100001\n\nbool M[MAX_N];   // マークされてるかどうか\nint P[MAX_N];   // 親\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N != 0 && Q != 0) {\n        memset(M, 0, sizeof(M));\n        M[1] = true;\n        memset(P, 0, sizeof(P));\n        for (int i = 2; i < N+1; i++) {\n            int p; cin >> p;\n            P[i] = p;\n        }\n\n        int sum = 0;\n        for (int i = 0; i < Q; i++) {\n            char q; int v;\n            cin >> q >> v;\n            if (q == 'Q') {\n                while (!M[v]) {\n                    v = P[v];\n                }\n                sum += v;\n            } else {\n                M[v] = true;\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q;\nlong long ans;\n// int Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\n// int find(int x) {\n//   if (par[x] == x) return x;\n//   else return par[x] = find(par[x]);\n// }\n\nint search(int x) {\n  // int a = par[x];\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n\n// void unite(int x, int y) {\n//   par[find(x)] = find(y);\n// }\n\n// bool same(int x, int y) {\n//   return find(x) == find(y);\n// }\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%lld\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\t//h.clear();\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll mini=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[mini]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tbuf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+1));\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint flag[100010],par[100010];\nvector<int> gg[100010];\nint n,q;\nlong long ans;\nvoid setpar(int parr,int x)\n{\n\tpar[x]=parr;\n\tif(!flag[x])\n\t{\n\t\tfor(int i=0;i<gg[x].size();i++)\n\t\t\tsetpar(parr,gg[x][i]);\n\t}\n}\nint main()\n{\n\tcin>>n>>q;\n\tflag[1]=1;\n\tint a;\n\tchar b;\n\tpar[1]=1;\n\tans=0;\n\tfor(int i=2;i<=n;i++)\n\t\tpar[i]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a);\n\t\tgg[a].push_back(i);\n\t\tgetchar();\n\t}\n\twhile(q--)\n\t{\n\t\tscanf(\"%c%d\",&b,&a);\n\t\tgetchar();\n\t\tif(b=='M')\n\t\t{\n\t\t\tflag[a]=1;\n\t\t\tpar[a]=a;\n\t\t\tfor(int i=0;i<gg[a].size();i++)\n\t\t\t\tsetpar(a,gg[a][i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=par[a];\n\t\t}\n\t}\n\tcin>>n>>q;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\nclass union_find{\n\tvector<int> parent;\npublic:\n\tvector<int> marked;\n\tint root(int a){return parent[a]==a||marked[a]?a:(parent[a]=root(parent[a]));}\n\tunion_find(int n):parent(n),marked(n){for(int i=1;i<n;i++)parent[i]=i;}\n\tint same(int a,int b){return root(a)==root(b);}\n\tint unite(int a,int b){\n\t\tint x=root(a),y=root(b);//if(x==y)return 0;\n\t\tparent[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint main(){\n\tint N,M;\n\tfor(;scanf(\"%d%d\",&N,&M),N;){\n\t\tvector<int>parent(N);\n\t\tfor(int i=1;i<N;i++)scanf(\"%d\",&parent[i]),parent[i]--;\n\t\tunion_find uf(N);\n\t\tvector<pair<char,int> >query;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tchar s[2];int n;\n\t\t\tscanf(\"%s%d\",s,&n),n--;\n\t\t\tif(*s=='Q'||!uf.marked[n]){\n\t\t\t\tif(*s=='M')uf.marked[n]=1;\n\t\t\t\tquery.emplace_back(*s,n);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<N;i++)if(!uf.marked[i])uf.unite(i,parent[i]);\n\t\treverse(query.begin(),query.end());\n\t\tint R=0;\n\t\tfor(auto &e:query){\n\t\t\tif(e.first=='Q')R+=uf.root(e.second)+1;\n\t\t\telse uf.marked[e.second]=0,uf.unite(e.second,parent[e.second]);\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q;\nlong long ans;\n// int Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\n// int find(int x) {\n//   if (par[x] == x) return x;\n//   else return par[x] = find(par[x]);\n// }\n\nint search(int x) {\n  // int a = par[x];\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n\n// void unite(int x, int y) {\n//   par[find(x)] = find(y);\n// }\n\n// bool same(int x, int y) {\n//   return find(x) == find(y);\n// }\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100000][2];\nchar q1[100000];\nint q2[100000];\n\nint queue(int x){\n//    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      res+=queue(q2[i]);\n    }else{\n      mark(q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=0;\n    }\n//    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n     // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n      if(q2[i]==0)\n        return 0;\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n) {\n    par.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main() {\n  while(cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for(int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for(int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    for(int i = 0; i < Q; ++i) {\n      if(op[i] != 'M') continue;\n      M[v[i]] = true;\n    }\n\n    UnionFind uf(N);\n    vector<int> nearest(N);\n    for(int st = 0; st < N; ++st) {\n      if(!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while(que.size()) {\n        int v = que.front();\n        que.pop();\n        for(int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if(M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    int res = 0;\n    for(int i = 0; i < Q; ++i) {\n      if(op[i] == 'Q') {\n        res += nearest[uf.find(par[v[i]])] + 1;\n      } else {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = -1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tll ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\ttb[e[j].m] = e[e[j].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\tint last = to;\n\t\t\t\tto = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\ttb[to] = last;\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\tans += tb[to] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    for(int j = 0;j <= -1;j++){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\tr[0] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct node{\n\tint parent;\n\tbool marked;\n};\nnode V[100000];\nint query(int v){\n\tif(V[v].marked) return v+1;\n\telse return query(V[v].parent);\n}\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n){\n\t\tV[0].marked = true;\n\t\tfor(int i = 1; i < n; ++i){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tV[i].parent = --p;\n\t\t\tV[i].marked = false;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tchar q;int v;\n\t\t\tcin >> q >> v;\n\t\t\t--v;\n\t\t\tif(q == 'M') V[v].marked = true;\n\t\t\telse{\n\t\t\t\tsum += query(v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N=100000,MAX_Q=100000;\n\nint N,Q;\nint p[MAX_N];\nchar q[MAX_Q+1];\nint v[MAX_Q];\n\nint colored[MAX_N];\t//?????????????????°\n\nvector<ll> out;\n\nint find(int i){\n\t//?????????i?????????????????????????????????????????????\n\tif (colored[i]){\n\t\treturn i;\n\t}\n\treturn p[i]=find(p[i]);\n}\n\nll solve(){\n\t//?????¨?????????????????????\n\tfill(colored,colored+N,0);\n\tcolored[0]=1;\t//????????????????????????????????????\n\tfor (int i=0;i<Q;i++){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]++;\n\t\t}\n\t}\n\tll sum=0;\n\tfor (int i=Q-1;i>=0;i--){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]--;\n\t\t}\n\t\telse{\n\t\t\tsum+=find(v[i])+1;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif (N || Q){\n\t\t\tp[0]=0;\n\t\t\tfor (int i=0;i<N-1;i++){\n\t\t\t\tscanf(\"%d\",&p[i+1]);\n\t\t\t\tp[i+1]--;\n\t\t\t}\n\t\t\tfor (int i=0;i<Q;i++){\n\t\t\t\tscanf(\" %c %d\",&q[i],&v[i]);\n\t\t\t\tv[i]--;\n\t\t\t}\n\t\t\tout.push_back(solve());\n\t\t}\n\t}while(N || Q);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%lld\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c;\n\t__int64 sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t\tmark[i] = maxN;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = nn = 1; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'M')\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i = nn - 1, sum = 0; i >= 1; i--)\n\t\t{\n\t\t\ttt = qt[i];\n\t\t\tsum += find(qx[i]);\n\t\t}\n\t\tprintf(\"%I64d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair<char,int>\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    stack<pair<char,int>> qu;\n    \n    UF(int n):par(2*n),rank(2*n)\n    {\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x=0)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) break;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin>>n>>q;\n    Uf uf(n);\n    for(int i=1;i<n;i++)\n    {\n        int p;\n        cin>>p;\n        (uf.c[p]).push_back(i);\n    }\n    for(int i=0;i<q;i++)\n    {\n        char temp;\n        int v;\n        cin>>temp>>v;\n        (uf.qu).push(P(temp,v-1));\n        if(temp=='M') uf.m[v-1]=true;\n    }\n    int a,b;\n    cin>>a>>b;\n    uf.furiwake(0);\n    \n    ll ans=0;\n    for(int i=0;i<q;i++)\n    {\n        pair<char,int> a=qu.top();\n        qu.pop();\n        if(a.first=='Q')\n        {\n            ans+=uf.score(a.second);\n        }\n        else\n        {\n            uf.delmark(a.second);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(k),rank(k)\n    {\n        n=k;\n        for(int i=0;i<n;i++) par[i]=i;\n        for(int i=0;i<n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[c[x][i]]) par[c[x][i]]=c[x][i];\n            else           par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, Q;\nvector<int> G[100000];\n\nbool M[100000];\nint par[100000];\nint U[100000], R[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  //if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N >> Q) {\n    if (N == 0 && Q == 0) break;\n    rep(i, N) {\n      G[i].clear();\n      M[i] = false;\n    }\n    for (int i=0; i<N; i++) U[i] = i, R[i] = 1;\n    rep(i, N-1) {\n      int p;\n      cin >> p;\n      p--;\n      G[p].pb(i+1);\n      par[i+1] = p;\n    }\n    M[0] = true;\n    vector<P> qs;\n    rep(i, Q) {\n      char c; int v;\n      cin >> c >> v;\n      v--;\n      if (c == 'M') {\n        if (M[v]) continue;\n        M[v] = true;\n        qs.pb(P(0, v));\n      }\n      else {\n        qs.pb(P(1, v));\n      }\n    }\n    rep(x, N) {\n      for (int t : G[x]) {\n        if (M[t]) continue;\n        unite(x, t);\n      }\n    }\n    long long ans = 0;\n    reverse(all(qs));\n    for (P &p : qs) {\n      if (p._1 == 0) {\n        // unmark\n        unite(par[p._2], p._2);\n      }\n      else {\n        ans += find(p._2)+1;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\t/*Tree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);*/\n\t\t//h.clear();\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\n/*\n\n6 3\n1\n1\n2\n3\n3\nQ 5\nM 3\nQ 5\n\n10 3\n1\n1\n2\n3\n5\n5\n8\n9\n4\nQ 1\nM 3\nQ 2\n0 0\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N = 100005;\nint pre[N];\t\t//存??点之?的?系\nint marked[N];\t//存?是否被??以及??的?序\n\nint operation_order[N];\t\t//按?序存??入的Q操作\nint operation_node_index[N];//存?Q操作??的?点下?\n\nlong long sum;\nint process_time;\n\nint find_ance(int index) {\n\tif (marked[index] < process_time) {\n\t\treturn index;\n\t}\n\telse {\n\t\tpre[index] = find_ance(pre[index]);\n\t\treturn pre[index];\n\t}\n}\n\nint main() {\n\tint n, q;\n\tchar op;\n\tint index;\n\n\twhile (cin >> n >> q, n) {\n\t\tsum = 0;\n\t\tpre[1] = 1;\n\t\tmarked[1] = 0;\n\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\tcin >> pre[i];\n\t\t\tmarked[i] = q + 1;\n\t\t}\n\t\tint Q_operation_num = 0;\n\t\tfor (int i = 1; i <= q; ++i) {\n\t\t\tcin >> op >> index;\n\t\t\tif (op == 'Q') {\n\t\t\t\toperation_order[Q_operation_num] = i;\n\t\t\t\toperation_node_index[Q_operation_num++] = index;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmarked[index] = min(marked[index], i);\n\t\t\t}\n\t\t}\n\n\t\twhile (Q_operation_num--) {\n\t\t\tprocess_time = operation_order[Q_operation_num];\n\t\t\tsum += find_ance(operation_node_index[Q_operation_num]);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint tpar[100000],par[100000];\nint mark[100000];\nint search(int a){\n    if(mark[a]) return a;\n    else return search(tpar[a]);\n}\nint find(int a){\n    if(par[a]==a) return a;\n    else return par[a]=find(par[a]);\n}\nvoid unite(int a,int b){\n    par[find(a)]=find(b);\n}\nint main(){\n    int N,Q;\n    for(;;){\n        scanf(\"%d %d\\n\",&N,&Q);\n        if(N==0 && Q==0) break;\n        tpar[0]=0;\n        int p;\n        for(int i=1;i<N;i++){\n            scanf(\"%d\\n\",&p);\n            tpar[i]=p-1;\n        }\n        fill(mark,mark+N,0);\n        mark[0]=1;\n        char q;\n        int a;\n        vector<pair<char,int>> query;\n        for(int i=0;i<Q;i++){\n            scanf(\"%c %d\\n\",&q,&a);\n            a--;\n            query.PB(MP(q,a));\n            if(q=='M') mark[a]++;\n        }\n        for(int i=0;i<N;i++){\n            par[i]=search(i);\n        }\n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            int now=query[i].second;\n            if(query[i].first=='Q') ans+=find(now)+1;\n            else if(!--mark[now]) unite(now,tpar[now]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nclass UnionFind\n{\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n)\n  {\n    par.resize(n);\n    rank.resize(n);\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x)\n  {\n    if (par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main()\n{\n  while (cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for (int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for (int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    M[0] = 1;\n    for (int i = 0; i < Q; ++i)\n      if (op[i] == 'M') ++M[v[i]];\n\n    UnionFind uf(N);\n    vector<int> nearest(N, -1);\n    for (int st = 0; st < N; ++st) {\n      if (!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while (que.size()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if (M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    lli res = 0;\n    for (int i = 0; i < Q; ++i) {\n      if (op[i] == 'Q') {\n        res += nearest[uf.find(v[i])] + 1;\n      } else if(!--M[v[i]]) {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout<< res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    //if(n == 0)\n//\tint m = 1;\n    \n    if(flag[t[n]] == 1)\n    {\n\treturn t[n];\t    \n    }\n\n    else\n    {\t\n\treturn t[n] = find(t[n]);    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 1;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]] = 1;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M' && idx[i] != 1 ) flag[idx[i]] = 0;\n\t    else ret = ret + find(idx[i]);\n\t    //std::cout<<idx[i]<<std::endl;\n\t    //if(idx[i] == 0)\n\t    //int m = 1;\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define INF (1<<29)\n\n\n\n\ntemplate<class T>\nclass BinomialHeap{\n\t/*template<class S>\n\tstruct Vector{\n\t\tint sz,cap;\n\t\tS *p;\n\t\tVector():sz(0),cap(0),p(0){}\n\t\t~Vector(){\n\t\t\tclear();\n\t\t}\n\t\tvoid swap(Vector &v){\n\t\t\tstd::swap(sz,v.sz);\n\t\t\tstd::swap(cap,v.cap);\n\t\t\tstd::swap(p,v.p);\n\t\t}\n\t\tint size()const{return sz;}\n\t\tbool empty()const{return !sz;}\n\t\tS& back()const{\n\t\t\treturn p[sz-1];\n\t\t}\n\t\tvoid push_back(S v){\n\t\t\tif(sz==cap)reserve(sz?sz*2:1);\n\t\t\tnew(p+sz++) S(v);\n\t\t}\n\t\tvoid pop_back(){\n\t\t\tp[--sz].~S();\n\t\t\tif(sz&&sz*4<cap){\n\t\t\t\treserve(cap/2);\n\t\t\t}\n\t\t}\n\t\tvoid reserve(int n){\n\t\t\tS *p=(S*)operator new(n*sizeof(S));\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tnew(p+i) S(this->p[i]);\n\t\t\t\tp[i].~S();\n\t\t\t}\n\t\t\tif(this->p)operator delete(this->p);\n\t\t\tthis->p=p;\n\t\t\tcap=n;\n\t\t}\n\t\tvoid clear(){\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tp[i].~S();\n\t\t\t}\n\t\t\tif(p)operator delete(p);\n\t\t\tsz=cap=0;\n\t\t\tp=0;\n\t\t}\n\t\tS& operator[](int i)const{\n\t\t\treturn p[i];\n\t\t}\n\t};*/\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree*> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\t//if(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\twhile(trees.size()<h.trees.size())trees.push_back(NULL);\n\t\twhile(trees.size()>h.trees.size())h.trees.push_back(NULL);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\t//if(carry==NULL && h.trees.size()<=i)break;\n\t\t\tif(carry){\n\t\t\t\tif(h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn (trees[imax])->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\t//while(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\t//return trees.empty();\n\t\timax=-1;findmax();\n\t\treturn imax==-1;\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nint marked[100000];\nBinomialHeap<int> bh[100000];\nvector<int> edge[100000];\nlong long ans;\n\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\n//int orig[NN];\nvector<int> child[20][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\n//bool marked[NN];\nvoid setLevel(int i, int n)\n{\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tif (!scanf(\"%d%d\",&N,&Q))\n\t{\n\t\texit(0);\n\t}\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t\tchild[1][i].clear();\n\t\tparent[0][i]=0;\n\t\tparent[1][i]=0;\n\t\tlevel[i]=0;\n\t\tnearest[i]=P(0,0);\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\t//orig[i]=p;\n\t\t//marked[i]=false;\n\t\tchild[0][p].push_back(i);\n\t}\n\t//marked[1]=true;\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\n\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n//*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif((level[i]%step)==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step){\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}//*/\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}//*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tLL sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\t//cout << \"zzz \" << endl;\n\t\t//int ov=v;\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\t/*\n\t\t\tint vv=v;\n\t\t\twhile(!marked[vv]){\n\t\t\t\tvv=orig[vv];\n\t\t\t}*/\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\t//assert(vv==nearest[v].second);\n\t\t\t/*\n\t\t\tif(vv!=nearest[v].second)\n\t\t\t{\n\t\t\t\tcout << endl;\n\t\t\t\tcout << i << \", \" << vv << \", \" << nearest[v].second << \", \" << ov << endl;\n\t\t\t\twhile (!marked[ov]){\n\t\t\t\t\tcout << ov << \", \" << level[ov] << endl;\n\t\t\t\t\tov=orig[ov];\n\t\t\t\t}\n\t\t\t\tcout << ov << level[ov] << endl;\n\t\t\t\treturn;\n\t\t\t}*/\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//marked[v]=true;\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\nint main() {\n\t//while(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int maxn = 100005;\nint par[maxn];\n\nvoid init() {\n\tfor (int i = 0; i < maxn; i++) {\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x) {\n\twhile (par[x] != x) x = par[x];\n\treturn par[x];\n}\n\nint main() {\n\t//freopen(\"aoj2170.txt\", \"r\", stdin);\n\twhile (1) {\n\t\tint n, q;\n\t\tscanf(\"%d%d\", &n, &q);\n\t\tif (n == 0) break;\n\n\t\t//init();\n\t\tpar[1] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tpar[i+1] = t;\n\t\t}\n\n\t\tlong long res = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tchar c;\n\t\t\tint t;\n\t\t\tgetchar();\n\t\t\tscanf(\"%c%d\", &c, &t);\n\t\t\tif ('Q' == c) {\n\t\t\t\tres += find(t);\n\t\t\t} else {\n\t\t\t\tpar[t] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 1e6;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  par[1] = 1;\n  marked[1] = true;\n  for (int i = 2; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    if (N > 1) {\n      for (int i = 2; i <= N; i++) {\n        cin >> par[i];\n      }\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100016\n\nusing namespace std;\n\nint par[maxN], rank[maxN];\n\nvoid init(int x)\n{\n\tint i;\n\tfor (i = 0; i < x; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, j, x, sum;\n\tchar c;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tinit(n);\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = sum = 0; i < t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'Q')\n\t\t\t\tsum += find(x);\n\t\t\telse\n\t\t\t\tpar[x] = x;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x] ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t\tchk[x] = true;\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\tassert( near.size() == 0 );\n\t\tnear.clear();\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\t//for( auto i : memo ) cout << i << endl;\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      same(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          // printf(\"%d\", nodeNum);\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n    Node[1] = 1;\n  while(1){\n    if(N == 0 || Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\nvoid setLevel(int i, int n)\n{\n\tnearest[i]=P(0,0);\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\t//cout << \"nearest \" << p << \", \" << n.second << endl;\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\tchild[0][p].push_back(i);\n\t}\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\nfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << level[i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tLL sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nconst int max_n = 100000;\nint par[max_n * 2];\nint mrank[max_n * 2];\nbool marked[max_n * 2];\n\nvoid init(int n) {\n    for(int i = 0; i < n; i++) {\n        par[i] = i;\n        mrank[i] = 0;\n        marked[i] = false;\n    }\n    marked[0] = true;\n}\n\nint find(int x) {\n    if(marked[x]) return x;\n    else return find(par[x]);\n}\n\n\nint main() {\n    while(true) {\n        int n, q, sum = 0;\n        cin >> n >> q;\n        init(n);\n        if(n == 0 && q == 0) break;\n\n        for(int i = 0; i < n - 1; i++) {\n            int x;\n            cin >> x;\n            x--;\n            par[i + 1] = x;\n        }\n\n        for(int i = 0; i < q; i++) {\n            char qt;\n            int x;\n            cin >> qt >> x;\n            x--;\n            if(qt == 'M') {\n                marked[x] = true;\n            } else {\n                sum += find(par[x]);\n                sum++;\n            }\n        }\n\n        cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, Q;\nint par[100001];\nVI chd[100001];\nVI node(100001, 1);\nvector<bool> mkd(100001, false);\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nvoid init(int i, int p, UnionFind& uf){\n  if(mkd[i]){\n\tfor(int c: chd[i]){\n\t  init(c, i, uf);\n\t}\n  }\n  else{\n\tnode[i] = node[p];\n\tuf.unite(p, i);\n\tfor(int c: chd[i]){\n\t  init(c, p, uf);\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> N >> Q, N){\n\tREP(i,100001) chd[i].clear();\n\tUnionFind uf(N+1);\n\tREP(i,N-1){\n\t  cin >> par[i+2];\n\t  chd[par[i+2]].PB(i+2);\n\t}\t\n\t\n\tvector<PII> q;\n\tfor(int i=1;i<=N;++i)\n\t  node[i] = i;\n\tfill(ALL(mkd), false);\n\tmkd[1] = true;\n\tREP(i,Q){\n\t  char ch; int x;\n\t  cin >> ch >> x;\n\t  if(ch == 'M')\n\t\tq.PB(MP(0,x)), mkd[x] = true;\n\t  else\n\t\tq.PB(MP(1,x));\n\t}\n\n\tinit(1, 1, uf);\n\t\n\tLL ans = 0;\n\tfor(int i=Q-1;i>=0;--i){\n\t  if(q[i].first == 0 && q[i].second != 1){\n\t\tnode[uf.find(q[i].second)] = node[uf.find(par[q[i].second])];\n\t\tuf.unite(q[i].second, par[q[i].second]);\n\t  }\n\t  else{\n\t\tans += node[uf.find(q[i].second)];\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define INF (1<<29)\n\n\n\n\ntemplate<class T>\nclass BinomialHeap{\n\ttemplate<class S>\n\tstruct Vector{\n\t\tint sz,cap;\n\t\tS *p;\n\t\tVector():sz(0),cap(0),p(0){}\n\t\t~Vector(){\n\t\t\tclear();\n\t\t}\n\t\tvoid swap(Vector &v){\n\t\t\tstd::swap(sz,v.sz);\n\t\t\tstd::swap(cap,v.cap);\n\t\t\tstd::swap(p,v.p);\n\t\t}\n\t\tint size()const{return sz;}\n\t\tbool empty()const{return !sz;}\n\t\tS& back()const{\n\t\t\treturn p[sz-1];\n\t\t}\n\t\tvoid push_back(S v){\n\t\t\tif(sz==cap)reserve(sz?sz*2:1);\n\t\t\tnew(p+sz++) S(v);\n\t\t}\n\t\tvoid pop_back(){\n\t\t\tp[--sz].~S();\n\t\t\tif(sz&&sz*4<cap){\n\t\t\t\treserve(cap/2);\n\t\t\t}\n\t\t}\n\t\tvoid reserve(int n){\n\t\t\tS *p=(S*)operator new(n*sizeof(S));\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tnew(p+i) S(this->p[i]);\n\t\t\t\tp[i].~S();\n\t\t\t}\n\t\t\tif(this->p)operator delete(this->p);\n\t\t\tthis->p=p;\n\t\t\tcap=n;\n\t\t}\n\t\tvoid clear(){\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tp[i].~S();\n\t\t\t}\n\t\t\tif(p)operator delete(p);\n\t\t\tsz=cap=0;\n\t\t\tp=0;\n\t\t}\n\t\tS& operator[](int i)const{\n\t\t\treturn p[i];\n\t\t}\n\t};\n\tstruct Tree{\n\t\tT val;\n\t\tVector<Tree*> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tVector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry==NULL && h.trees.size()<=i)break;\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn (trees[imax])->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nint marked[100000];\nBinomialHeap<int> bh[100000];\nvector<int> edge[100000];\nlong long ans;\n\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\n\nclass UnionFindTree{\npublic:\n  // indexÌÌem[h( éWÌeð©Â¯½¢Æ«Í±±ð¼ÚQÆ¹¸Afindðg¤)\n  vector<int> par;\n  // indexðªÆ·éØÌN\n  vector<int> rank;\n  //  éWÌã\\l\n  vector<int> val;\n  // ØÌÅål\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // øÅ^¦çê½lðÅåi[Æ·éUnionFindTreeÌì¬\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      val.push_back(-1);\n    }\n  }\n  // ^¦çê½ªi[³êÄ¢éØÌ[gðTõ\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // aWðÆéB½¾µ±±ÅÍeWÌeÌt¯Ö¦ÍN±çÈ¢\n  void unite(int x,int y,int a){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    // valÌ«·¦\n    val[find(x)]=a;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n    \n};\n\ntypedef pair<char,int>  pci;\nconst int MAX_V=100001;\nvector<int> G[MAX_V];\npci ods[MAX_V];\nint N,Q;\nbool mark[MAX_V];\nint firstMark[MAX_V];\nint pars[MAX_V];\n\n// curMarkÍ»ÝÌm[hª®·éem[h\nvoid dfs(int s,int curMark,UnionFindTree &uft){\n  if(mark[s]){\n    for(int i=0;i<G[s].size();i++){\n      int to=G[s][i];\n      dfs(to,s,uft);\n    }\n    int idx=uft.find(s);\n    uft.val[idx]=s;\n  }\n  else{\n    uft.unite(s,curMark,-1);\n    for(int i=0;i<G[s].size();i++){\n      int to=G[s][i];\n      dfs(to,curMark,uft);\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N>>Q&&(N|Q)){\n    memset(mark,0,sizeof(mark));\n    memset(firstMark,0,sizeof(firstMark));\n    UnionFindTree uft(N);\n    for(int i=0;i<N;i++)G[i].clear();\n    for(int i=1;i<N;i++){\n      int par;\n      cin>>par;\n      par--;\n      G[par].push_back(i);\n      pars[i]=par;\n    }\n    mark[0]=true;\n    firstMark[0]++;\n    // }[NðÂ¯Ä¨­\n    for(int i=0;i<Q;i++){\n      cin>>ods[i].first>>ods[i].second;\n      ods[i].second--;\n      if(ods[i].first=='M'){\n\tfirstMark[ods[i].second]++;\n\tmark[ods[i].second]=true;\n      }\n    }\n    // ÄAÉæèAeWðª·é\n    dfs(0,-1,uft);\n    ll res=0;\n    // ªãANGðãë©çµÄ¢­\n    for(int i=Q-1;i>=0;i--){\n      if(ods[i].first=='Q'){\n\tint a=uft.find(ods[i].second);\n\tint b=uft.val[a];\n\tres+=b+1;\n      }\n      else{\n\tfirstMark[ods[i].second]--;\n\tif(firstMark[ods[i].second]>0)continue;\n\t// em[hÌ®·éØÆ\n\tint a=uft.val[uft.find(pars[ods[i].second])];\n\tuft.unite(ods[i].second,pars[ods[i].second],a);\n      }\n    }\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nstruct UnionFind{\n\tint par[100100],rank[100100];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t\treturn;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tpar[y]=x;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nint N,Q;\nchar qtype[100100];\nint qval[100100];\nint par[100100];\nint col[100100];\nvector<int> g[100100];\nbool used[100100];\nvoid dfs(int v,int val){\n\tif(col[v]==-1)col[v]=val;\n\tfor(int i=0;i<g[v].size();i++)dfs(g[v][i],col[v]);\n}\nint solve(){\n\tscanf(\"%d %d\",&N,&Q);\n\tif(N+Q==0)return 1;\n\tuf.init(N+10);\n\tmemset(used,false,sizeof(used));\n\tfor(int i=1;i<=N;i++)g[i].clear();\n\tfor(int i=2;i<=N;i++)scanf(\"%d\",&par[i]);\n\tfor(int i=2;i<=N;i++){\n\t\tg[par[i]].pb(i);\n\t}\n\tcol[1]=1;\n\tfor(int i=2;i<=N;i++)col[i]=-1;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\" %c %d\",&qtype[i],&qval[i]);\n\t\tif(qtype[i]=='M')col[qval[i]]=qval[i];\n\t}\n\tdfs(1,1);\n\t//for(int i=1;i<=N;i++)printf(\"%d:%d\\n\",i,col[i]);\n\tfor(int i=1;i<=N;i++){\n\t\tif(col[i]!=i)uf.unite(col[i],i);\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tif(qtype[i]=='M'){\n\t\t\tif(used[qval[i]]){\n\t\t\t\tqtype[i]=='E';\n\t\t\t}else{\n\t\t\t\tused[qval[i]]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i=Q-1;i>=0;i--){\n\t\tint val = qval[i];\n\t\tif(qtype[i]=='M'){\n\t\t\tuf.unite(par[val],val);\n\t\t}else if(qtype[i]=='Q'){\n\t\t\tans += (ll)uf.find(val);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\nint dat[2*MAX_SEG];\n\nclass segment{\npublic:\n    int n;\n    void init(int n_){\n        for(int i=0;i<2*MAX_SEG-1;++i)dat[i]=0;\n\n    }\n    void update(int a,int b,int x,int k=0,int l=0,int r=MAX_SEG){\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            dat[k]=max(dat[k],x);\n            return;\n        }\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n    int query(int k){\n        k+=MAX_SEG-1;\n        int ret=dat[k];\n        while(k){\n            k=(k-1)/2;\n            ret=max(ret,dat[k]);\n        }\n        return ret;\n    }\n};\n\nint N,M;\nvector<int> g[MAX_N+5];\nint depth[MAX_N+5];\nint par[20][MAX_N];\nint tin[2*MAX_N+5],tout[2*MAX_N+5];\nint k=0;\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    tin[v]=k++;\n    for(int u=0;u<g[v].size();++u){\n        dfs(g[v][u],v,d+1);\n        k++;\n    }\n    tout[v]=k;\n}\n\nvoid fill_table(){\n    for(int i=0;i<19;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        int ans=0;\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        for(int i=0;i<N;++i)g[i].clear();\n        memset(par,0,sizeof(par));\n        for(int i=1;i<N;++i){\n            int p;\n            cin>>p;\n            p--;\n            g[p].PB(i);\n        }\n        k=0;\n        dfs(0,-1,0);\n        fill_table();\n        segment seg;\n        seg.init(N);\n        for(int t=0;t<M;++t){\n            char que;\n            int v;\n            cin>>que;\n            cin>>v;\n            v--;\n            //cout<<tin[v]<<\" \"<<tout[v]<<\" \"<<depth[v]<<endl;\n            if(que=='M'){\n                seg.update(tin[v],tout[v],depth[v]);\n            }\n            else{\n                int q=seg.query(tin[v]);\n                for(int i=19;i>=0;--i){\n                    if((depth[v]-q)>>i&1)v=par[i][v];\n                }\n                ans+=v+1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint N,Q;\nint pa[100010];\npair<char,int> que[100010];\nvector<int> ch[100010];\nbool mark[100010];\nint qpa[100010];\n\nint find(int x){\n  vector<int> st;\n  while(true){\n    //cout << x << ' ' << mark[x] << endl;\n    if(mark[x]) break;    \n    st.pb(x);\n\n    x=qpa[x];\n  }\n  FOR(it,st) qpa[*it] = x;\n  return x;\n}\n\nvoid solve(){\n  CLR(mark);\n  rep(i,N) ch[i].clear();\n  rep(i,N-1) {\n    cin >> pa[i+1];\n    --pa[i+1];\n    ch[pa[i+1]].pb(i+1);\n  }\n\n  rep(i,Q){\n    cin >> que[i].F >> que[i].S;\n    --que[i].S;\n    if(que[i].F=='M') mark[que[i].S]=1;\n  }\n  mark[0]=1;\n  reverse(que,que+Q);\n  queue<PI> q;\n  q.push(mp(0,0));\n  while(!q.empty()){\n    int cv=q.front().F;\n    int ma=q.front().S;\n    q.pop();\n    qpa[cv]=ma;\n    //cout << cv << ' ' << ma << endl;\n    FOR(it,ch[cv]) q.push(mp(*it,mark[cv]?cv:ma));\n  }\n  \n  ll ans=0;\n  rep(i,Q){\n    if(que[i].F=='Q'){\n      //cout << find(pa[que[i].S])+1 << endl;\n      ans += find(pa[que[i].S])+1;\n    }else{\n      mark[que[i].S]=0;\n      //qpa[que[i].S]=qpa[pa[que[i].S]];\n    }\n  }\n  \n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> Q && N) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> G[100000];\nbool isMarked[100000];\nint parent[100000];\nusing P = pair<char,int>;\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n        init(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(isMarked[x]){\n            par[y]=x;\n        }else{\n            par[x]=y;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\nvoid dfs1(int v, int pre, union_find &UF){\n    if(!isMarked[v]) UF.unite(pre,v);\n    for(auto to:G[v]){\n        if(to!=pre) dfs1(to,v,UF);\n    }\n    return;\n}\n\nint main(){\n    int N,Q;\n    while(cin>>N>>Q,N){\n        for(auto &g:G) g.clear();\n        fill(isMarked,isMarked+100000,false);\n        fill(parent,parent+100000,-1);\n        parent[0]=-1;\n        for(int i=1;i<N;i++){\n            int p;\n            cin>>p; p--;\n            parent[i]=p;\n            G[p].push_back(i);\n            G[i].push_back(p);\n        }\n        isMarked[0]=true;\n        vector<P> V;\n        for(int i=0;i<Q;i++){\n            char C;\n            int v;\n            cin>>C>>v; v--;\n            if(C=='M') isMarked[v]=true;\n            V.emplace_back(C,v);\n        }\n        reverse(V.begin(), V.end());\n        union_find UF(N);\n        dfs1(0,-1,UF);\n        int ans = 0;\n        for(auto p:V){\n            char C; int v;\n            tie(C,v)=p;\n            if(C=='Q'){\n                ans+=UF.find(v)+1;\n            }else{\n                isMarked[v]=false;\n                UF.unite(v,parent[v]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int gmax_n = 100005;\n\nint par[gmax_n]; //???\nint depth[gmax_n];//??¨?????±???\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] > depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid dfs(vector<int> t[gmax_n], int g[gmax_n], int cur){\n    rep(i,t[cur].size()){\n        int next = t[cur][i];\n        if(g[next] != -1) continue;\n\n        depth[next] = depth[cur] + 1;\n        g[next] = cur;\n        dfs(t,g,next);\n    }\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        vector<int> tree[gmax_n];\n        init(n);\n        rep(i,n - 1){ //??¨????§????\n            int a;\n            cin >> a;\n            a--;\n            tree[i + 1].emplace_back(a);\n            tree[a].emplace_back(i + 1);\n        }\n\n        bool marked[gmax_n] = {false};//???????????????????????????????¨????\n        marked[0] = true;\n        vector<pair<char, int>> q;\n        rep(i,m){\n            char a;\n            int b;\n            cin >> a >> b;\n            b--;\n            if(a == 'M'){\n                if(marked[b]) continue; //????????¨???????????????????????´?????????????????\\???????????????\n                else{\n                    marked[b] = true;\n                    q.emplace_back(make_pair(a, b));\n                }\n            }else{\n                q.emplace_back(make_pair(a,b));\n            }\n        }\n\n        int g[gmax_n] = {0};\n        range(i,1,gmax_n) g[i] = -1;\n        dfs(tree, g, 0);\n\n        rep(i,n){\n            if(not marked[i]) unite(g[i], i);\n        }\n\n        //rep(i,n) show(g[i])\n        //rep(i,n){ show(find(i)) }\n        //rep(i,n){ show(depth[i]) }\n\n        long long ans = 0;\n        for(int i = q.size() - 1; i >= 0; i--){ //?????¨?????????????????????\n            if(q[i].first == 'Q') ans += find(q[i].second) + 1;\n            else{\n                unite(g[q[i].second], q[i].second);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\nvoid setLevel(int i, int n)\n{\n\tnearest[i]=P(0,0);\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\t//cout << \"nearest \" << p << \", \" << n.second << endl;\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\tchild[0][p].push_back(i);\n\t}\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tfor(int k=0;k<child[pre][j].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << level[i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << j << \", \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tint sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n#define INF 0x7f7f7f7f\nint n,q,askl;\nlong long father[110001]={},ask[110001][2],Time[110001];\nlong long getF(long long t)\n{\n    if(Time[t]<ask[askl][1])\n        return t;\n    return father[t]=getF(father[t]);\n}\nint main()\n{\n    char c;\n    int x,i,t;\n    long long ans;\n    while(cin>>n>>q&&n&&q){\n        askl=ans=0;\n        t=0;\n        memset(Time,INF,sizeof(Time));\n        for(i=2;i<=n;++i)\n            cin>>father[i];\n        Time[1]=0;\n        while(q>0){\n            getchar();\n            cin>>c>>x;\n            ++t;\n            if(c=='M')\n                Time[x]=t;\n            else{\n                ++askl;\n                ask[askl][0]=x;\n                ask[askl][1]=t;\n            }\n            --q;\n        }\n        while(askl>0){\n            ans+=getF(ask[askl][0]);\n            --askl;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=100000;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tvoid update_min(int l,int r,int a,int b,int u,T v){\n\t\tif(l<=a && b<=r){ dat[u]=min(dat[u],v); return; }\n\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) update_min(l,r,a,c,2*u,v);\n\t\tif(l<b && c<r) update_min(l,r,c,b,2*u+1,v);\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update_min(int l,int r,T v){ update_min(l,r,0,n,1,v); }\n\n\tT query(int u){\n\t\tu+=n;\n\t\tT res=dat[u];\n\t\tfor(u/=2;u>=1;u/=2) res=min(res,dat[u]);\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tfor(int n,q;scanf(\"%d%d\",&n,&q),n;){\n\t\tstatic vector<int> T[100000]; // tree\n\t\trep(u,n) T[u].clear();\n\t\trep(i,n-1){\n\t\t\tint u,v=i+1; scanf(\"%d\",&u); u--;\n\t\t\tT[u].push_back(v);\n\t\t}\n\n\t\t// euler tour technique ( 再帰でやったらスタックあふれた... )\n\t\tstatic int start[100000],end[100000];\n\t\tint idx=0;\n\t\tstack< pair<int,int> > D; D.push(make_pair(0,0));\n\t\twhile(!D.empty()){\n\t\t\tint u=D.top().first,type=D.top().second; D.pop();\n\t\t\tif(type==0){ // in\n\t\t\t\tstart[u]=idx++;\n\t\t\t\tD.push(make_pair(u,1));\n\t\t\t\trep(i,T[u].size()) D.push(make_pair(T[u][i],0));\n\t\t\t}\n\t\t\telse{ // out\n\t\t\t\tend[u]=idx;\n\t\t\t}\n\t\t}\n\n\t\tstatic segment_tree_RMQ<int> S;\n\t\tS.build(n,0);\n\n\t\tll ans=0;\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint u; scanf(\" %c%d\",&c,&u); u--;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=-S.query(start[u])+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tS.update_min(start[u],end[u],-u);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntypedef long long int ll;\nusing ll = long long int;\nusing ull = long long unsigned int;\nusing Int = long long int;\nusing uInt = long long unsigned int;\nusing Double = long double;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//edit\ntemplate<typename T, typename E>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, size_t)>;\n    int n;\n    F f; //要素と要素のマージ\n    G g; //要素に作用素を作用\n    H h; //作用素と作用素をマージ\n    T ti; //要素の単位元?\n    E ei; //作用素の単位元?\n    P p; //b個の作用素aをマージした場合\n    vector<T> dat;\n    vector<E> laz;\n\n    SegmentTree(int n_, F f, G g, H h, T ti, E ei,\n                P p = [](E a, size_t b) {\n                    b++;\n                    return a;\n                }) :\n            f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n        dat.assign(2 * n - 1, ti);\n        laz.assign(2 * n - 1, ei);\n    }\n\n    void build(int n_, vector<T> v) {\n        for (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k) {\n        if (laz[k] == ei) return;\n        if (k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = ei;\n    }\n\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return dat[k];\n        if (a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    T update(int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return ti;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    /**\n     * kをxに更新する\n     */\n    void update(int k, T x) {\n        update(k, k + 1, x);\n//        query(k,k+1);//evaluate\n//        k+=n-1;\n//        dat[k]=x;\n//        while(k){\n//            k=(k-1)/2;\n//            dat[k]=f(dat[k*2+1],dat[k*2+2]);\n//        }\n    }\n};\n\n\nclass Solve {\npublic:\n\n\n    bool solve() {\n        Int N, Q;\n        cin >> N >> Q;\n        if (N == 0) return false;\n\n\n        using T = pair<Int, Int>; // depth, value\n        using E = pair<Int, Int>; //\n        auto f = [](T a, T b) {\n            // 深さが深い方を残す\n            if (a.first < b.first) return b;\n            return a;\n        }; // 要素と要素のマージ\n        auto g = [](T a, E b) {\n            if (a.first < b.first) return b;\n            return a;\n        }; // 要素に作用素を作用\n        auto h = [](E a, E b) {\n            if (a.first < b.first) return b;\n            return a;\n        }; // 作用素と作用素をマージ\n\n        auto p = [](E a, int b) { return a; }; // 作用素を区間加算する場合\n        T ti = T(0, 1); //要素の単位元?\n        E ei = E(0, 1); //作用素の単位元?\n\n        vector<vector<Int>> tree(N);\n        vector<Int> tour(2 * N); // eulor tour\n        vector<Int> in(N), out(N);\n        vector<Int> depth(N);\n        SegmentTree<T, E> treeone(2 * N + 1, f, g, h, ti, ei, p);\n\n\n        rep(i, 1, N) {\n            Int tmp;\n            cin >> tmp;\n            Int a = i;\n            Int b = tmp - 1;\n            tree[b].push_back(a);\n        }\n\n        if (N >= 1000000) {\n            rep(_, 0, Q) {\n                char c;\n                Int v;\n                cin >> c >> v;\n            }\n            cout << \"CUT\" << endl;\n            return true;\n        }\n\n        //euler-tour\n        {\n            Int idx = 0;\n            auto dfs = [&](auto self, Int v, Int d) -> void {\n                tour[idx] = v;\n                in[v] = idx++;\n                depth[v] = d;\n\n                for (auto e : tree[v]) {\n                    self(self, e, d + 1);\n                }\n\n                tour[idx] = v;\n                out[v] = idx++;\n            };\n\n            dfs(dfs, 0, 0);\n        }\n\n\n        Int uku = 13 + 33;\n\n\n        //クエリー\n        Int ans = 0;\n//        while (Q--) {\n\n        auto print_state = [&]() {\n            // すべての状態を出力\n            return;\n\n            cout << \"--------begin-------\" << endl;\n            for (int i = 0; i < N; ++i) {\n                int v = i;\n                T tapu = treeone.query(in[v], in[v] + 1);\n                Int tmp = tapu.second;\n                cout << v << \" : \" << tmp << endl;\n            }\n            cout << \"---------end--------\" << endl;\n        };\n\n        print_state();\n        rep(_, 0, Q) {\n\n            char c;\n            Int v;\n            cin >> c >> v;\n            v--;\n\n            if (c == 'M') {\n                // treeone の [ in[v], out[v] ] をT(depth[v], v) で更新する\n                treeone.update(in[v], out[v] + 1, T(depth[v], v + 1));\n\n            } else {\n                // treeone の in[v] の secondを求める\n                T tapu = treeone.query(in[v], in[v] + 1);\n                Int tmp = tapu.second;\n                ans += tmp;\n            }\n            print_state();\n        }\n//        }\n        cout << ans << endl;\n\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n//    std::ifstream ifs(\"./input.txt\");\n\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n\n//    string s;\n//    getline(ifs, s);\n//    cout << s << endl;\n    while (Solve().solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        while(1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf) return it->second;\n            else v = goUp(v);\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        map<int,int> marks;\n        marks[0] = 0;\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q') ans += marks.lower_bound(d)->second + 1;\n            else marks.insert(mp(-d, qv[i]));\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n            else h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\n// lazy evaluate segment tree\ntypedef int data_type;\nconst data_type dINF = iINF;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\t//update_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\t//update_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn mn;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \" << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q; int v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t\t\n\t\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define maxn 100005\nusing namespace std;\n\nint pre[maxn],rank[maxn],vis[maxn];\n\nint find(int x)\n{\n\n    while(!vis[x])\n        x=pre[x];\n    return x;\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF && (n||m))\n    {\n        memset(vis,0,sizeof(vis));\n        pre[1]=1;\n\n        for(int i=2;i<=n;i++)\n        {\n            int fat;\n            scanf(\"%d\",&fat);\n            pre[i]=fat;\n        }\n\n        int ans=0;\n        vis[1]=vis[0]=1;\n        while(m--)\n        {\n            char str[10];\n            int x;\n            scanf(\"%s%d\",str,&x);\n            if(str[0]=='Q')\n            ans+=find(x);\n            else vis[x]=1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss,*height;\n\nstruct Info{\n\tbool isMarked;\n\tvector<int> Children;\n};\n\nInfo*info;\n\nvoid update(int new_marked_boss_id){\n\n\tint current_boss_id = marked_boss[new_marked_boss_id],id;\n\tmarked_boss[new_marked_boss_id] = new_marked_boss_id;\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < info[new_marked_boss_id].Children.size();i++){\n\n\t\tif(marked_boss[info[new_marked_boss_id].Children[i]] == current_boss_id){\n\t\t\tmarked_boss[info[new_marked_boss_id].Children[i]] = new_marked_boss_id;\n\t\t\tQ.push(info[new_marked_boss_id].Children[i]);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tid = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i < info[id].Children.size();i++){\n\t\t\tif(marked_boss[info[id].Children[i]] == current_boss_id){\n\t\t\t\tmarked_boss[info[id].Children[i]] = new_marked_boss_id;\n\t\t\t\tQ.push(info[id].Children[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint Q,value;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\theight = new int[100001];\n\tinfo = (Info*)malloc(sizeof(Info)*(100001));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tmarked_boss[i] = 1;\n\t\t\theight[i] = 0;\n\t\t\tinfo[i].isMarked = false;\n\t\t\tinfo[i].Children.clear();\n\t\t}\n\n\t\tinfo[1].isMarked = true;\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tinfo[value].Children.push_back(i);\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < Q; i++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){ //?????¨???\n\t\t\t\tans += marked_boss[value];\n\t\t\t}else{ //???????????????\n\t\t\t\tinfo[value].isMarked = true;\n\t\t\t\tupdate(value);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\n \nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nint parent[100010];\nbool marked[100010];\n\n// sky58\nstruct unionf{\n\tvector <int> data;\n\tunionf(int size):data(size,-1){}\n\tbool unions(int x,int y){\n\t\tx=root(x);y=root(y);\n\t\tif(x!=y){\n\t\t\tif(data[y]<data[x]){int d=x;x=y;y=d;}\n\t\t\tdata[x]+=data[y];data[y]=x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\tbool finds(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tint root(int x){\n\t\treturn data[x]<0?x:data[x]=root(data[x]);\n\t}\n\tint find(int x){\n\t\treturn -data[x];\n\t}\n};\n\nint main(void) {\n\twhile(true) {\n\t\tint N, Q;\n\t\tscanf(\"%d\", &N);\n\t\tscanf(\"%d\", &Q);\n\t\t\n\t\tif ( N==0 ) { break; }\n\t\t\n\t\tmarked[1] = true;\n\t\tREP(i, N-1) {\n\t\t\tscanf(\"%d\", &parent[i+2]);\n\t\t\tmarked[i+2] = false;\n\t\t}\n\t\t\n\t\tlong long ret = 0;\n\t\tREP(i, Q) {\n\t\t\tchar met[256];\n\t\t\tint id;\n\t\t\tscanf(\"%s\", met);\n\t\t\tscanf(\"%d\", &id);\n\t\t\t\n\t\t\tif ( met[0] == 'Q' ) {\n\t\t\t\tint node = id;\n\t\t\t\twhile ( !marked[node] ) {\n\t\t\t\t\tnode = parent[node];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret += node;\n\t\t\t} else {\n\t\t\t\tmarked[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000,MAX_Q=100000;\n\nint N,Q;\nint p[MAX_N];\nchar q[MAX_Q+1];\nint v[MAX_Q];\n\nint colored[MAX_N];\t//?????????????????°\n\nvector<int> out;\n\nint find(int i){\n\t//?????????i?????????????????????????????????????????????\n\tif (colored[i]){\n\t\treturn i;\n\t}\n\treturn p[i]=find(p[i]);\n}\n\nint solve(){\n\t//?????¨?????????????????????\n\tfill(colored,colored+N,0);\n\tcolored[0]=1;\t//????????????????????????????????????\n\tfor (int i=0;i<Q;i++){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]++;\n\t\t}\n\t}\n\tint sum=0;\n\tfor (int i=Q-1;i>=0;i--){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]--;\n\t\t}\n\t\telse{\n\t\t\tp[v[i]]=find(p[v[i]]);\n\t\t\tsum+=p[v[i]]+1;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif (N || Q){\n\t\t\tp[0]=0;\n\t\t\tfor (int i=0;i<N-1;i++){\n\t\t\t\tscanf(\"%d\",&p[i+1]);\n\t\t\t\tp[i+1]--;\n\t\t\t}\n\t\t\tfor (int i=0;i<Q;i++){\n\t\t\t\tscanf(\" %c %d\",&q[i],&v[i]);\n\t\t\t\tv[i]--;\n\t\t\t}\n\t\t\tout.push_back(solve());\n\t\t}\n\t}while(N || Q);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%d\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nbool marked[100000];\nint prt[100000];\n\nint gm(int i) {\n  if (marked[i]) return i;\n  return prt[i] = gm(prt[i]);\n}\n\nint main() {\n  while(1) {\n    int n,q;\n    cin>>n>>q;\n    if(!n) break;\n    REP(i,n)marked[i]=false;\n    marked[0] = true;\n    REP(i,n-1) {\n      cin>>prt[i+1];\n      --prt[i+1];\n    }\n    vector<tuple<int,int>> ql;\n    REP(i,q){\n      string c;\n      int v;\n      cin>>c>>v;\n      --v;\n      if (c==\"M\") {\n        if (marked[v]) continue;\n        marked[v] = true;\n      }\n      ql.emplace_back(c==\"Q\", v);\n    }\n    reverse(begin(ql),end(ql));\n    int sum = 0;\n    REP(i,ql.size()){\n      int c,v;\n      tie(c,v) = ql[i];\n      if(c) // Q\n        sum += gm(v) + 1;\n      else\n        marked[v] = false;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass IN{\npublic:\n  char c;\n  int a;\n  IN(char c, int a):c(c),a(a){}\n};\n\nclass UF{\npublic:\n  vector<int> per;\n  void init(int n){\n    per = vector<int>(n+1);\n    rep(i,per.size())per[i]=i;\n\n  }\n  int find(int a){\n    if(per[a]==a)return a;\n    return per[a] = find(per[a]);\n  }\n  void uni(int a, int b){\n\n    a = find(a);\n    b = find(b);\n\n\n    if(a==b)return;\n    per[b] = a;\n  }\n  bool same(int a,int b){\n    return find(a)==find(b);\n  }\n  void print(){\n    reps(i,1,per.size())printf(\"%d \",per[i]);puts(\"\");\n  }\n};\n\nint n,m;\nvector<int> tree;\nvector<IN> in;\n\nbool input(){\n  cin>>n>>m;\n  if(n==0)return false;\n  tree = vector<int>(n+1);\n  tree[1] = -1;\n\n  rep(i,n-1){\n    cin>>tree[i+2];\n  }\n  in.clear();\n\n  vector<int> check(n+1,0);\n  check[1]=1;\n  in.push_back(IN('M',1));\n  rep(i,m){\n    char c;\n    int a;\n    cin>>c>>a;\n    if(c=='M' && check[a]==1)continue;\n    check[a]=1;\n    in.push_back(IN(c,a));\n  }\n  return true;\n}\n\n\nUF uf;\n\nint solve(){\n  vector<IN> rev = in;\n  reverse(rev.begin(),rev.end());\n  uf.init(n);\n  vector<int> check(n+1,0);\n  rep(i,in.size()){\n    if(in[i].c=='M')check[in[i].a]=1;\n  }\n\n  reps(i,1,n){\n    if(check[i]==0)uf.uni(tree[i], i);\n  }\n  \n  int ret = 0;\n  rep(i,rev.size()){\n\n    if(rev[i].c=='Q'){\n      ret += uf.find(rev[i].a);\n    }else{\n      uf.uni(tree[rev[i].a], rev[i].a);\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nvector<int> G[100000];\nint par[100000];\nint ord[100000], dst[100000], rev[200000], time;\n\nvoid dfs(int v, int p)\n{\n\tpar[v] = p;\n\tord[v] = time++;\n\trev[time - 1] = v;\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (G[v][i] != p){\n\t\t\tdfs(G[v][i], v);\n\t\t}\n\t}\n\tdst[v] = time++;\n}\n\nint seg[1 << 19], lazy[1 << 19];\n\nvoid eval(int k)\n{\n\tseg[k] = max(seg[k], lazy[k]);\n\tif (k < (1 << 18) - 1){\n\t\tlazy[k * 2 + 1] = max(lazy[k * 2 + 1], lazy[k]);\n\t\tlazy[k * 2 + 2] = max(lazy[k * 2 + 2], lazy[k]);\n\t}\n\tlazy[k] = 0;\n}\n\nvoid updateNode(int k)\n{\n\tseg[k] = max(seg[k * 2 + 1], seg[k * 2 + 2]);\n}\n\nvoid changeMax(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 18)\n{\n\teval(k);\n\tif (b <= l || r <= a) return;\n\t\n\tif (a <= l && r <= b){\n\t\tlazy[k] = max(lazy[k], x);\n\t\teval(k);\n\t\treturn;\n\t}\n\t\n\tchangeMax(a, b, x, k * 2 + 1, l, l + r >> 1);\n\tchangeMax(a, b, x, k * 2 + 2, l + r >> 1, r);\n\tupdateNode(k);\n}\n\nint get(int a, int k = 0, int l = 0, int r = 1 << 18)\n{\t\n\teval(k);\n\tif (a + 1 <= l || r <= a) return (-1);\n\t\n\tif (a <= l && r <= a + 1){\n\t\treturn (seg[k]);\n\t}\n\t\n\tint lch = get(a, k * 2 + 1, l, l + r >> 1);\n\tint rch = get(a, k * 2 + 2, l + r >> 1, r);\n\tupdateNode(k);\n\treturn (max(lch, rch));\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\twhile (scanf(\"%d %d\", &N, &Q) && N){\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\t\n\t\tfor (int i = 1; i < N; i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tG[--v].push_back(i);\n\t\t}\n\t\t\n\t\ttime = 0;\n\t\tdfs(0, -1);\n\t\tmemset(seg, 0, sizeof(seg));\n\t\tmemset(lazy, 0, sizeof(lazy));\n\t\t\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tchar t[10];\n\t\t\tint v;\n\t\t\tscanf(\"%s %d\", t, &v);\n\t\t\t--v;\n\t\t\t\n\t\t\tif (t[0] == 'Q'){\n\t\t\t\tans += rev[get(ord[v])] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchangeMax(ord[v], dst[v] + 1, ord[v]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int MAX_N = 100000 + 10;\nint N, Q;\nint P[MAX_N];\nint vis[MAX_N];\n\nvoid build(int N) {\n    for (int i = 0; i <= N; i++)\n        P[i] = 1;\n}\n\nint find(int x) {\n    if (vis[P[x]])\n        return P[x];\n    else\n        return find(P[x]);\n}\n\nvoid Unite(int parent, int child) {\n    P[child] = parent;\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &N, &Q) && (N || Q)) {\n        memset(vis, 0, sizeof(vis));\n        vis[1] = 1;\n        build(N);\n        int x;\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", &x);\n            Unite(x, i);\n        }\n        char s;\n        long long sum = 0;\n        getchar();\n        for (int i = 0; i < Q; i++) {\n            scanf(\"%c %d\", &s, &x);\n            getchar();\n            if (s == 'M')\n                vis[x] = 1;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint mark[MAX_N];\nint used[MAX_N];\nint par[MAX_N];\nint root;\nmap<int,vector<int> > child;\nvoid dfs(int start){\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++){\n        if(used[child[start][i]]==0) dfs(child[start][i]);\n    }\n}\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        used[0]=1;\n        if(a=='0' and b==0)break;\n        if (a=='Q') {\n            //cout<<\"as\"<<mark[b-1]<<endl;\n            ans+=mark[b-1];\n            ans++;\n        }\n        else {\n            root=b-1;\n            dfs(b-1);\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int MAX_N=100001;\nvector<int>edge[MAX_N];\nvector<int>id[MAX_N];\nint vi[MAX_N*2];\nint DFS(int n,int d)\n{\n\tvi[d]=n;\n\tid[n].push_back(d);\n\tfor(int i=0;i<edge[n].size();++i)\n\t{\n\t\td=DFS(edge[n][i],d+1)+1;\n\t\tvi[d]=n;\n\t\tid[n].push_back(d);\n\t}\n\treturn d;\n}\n\n\nint main()\n{\n\tint N,Q,x,i,t;\n\tchar c;\n\tlong long res;\n\ttypedef map<int,int>M;\n\tM m;\n\tM::iterator ite;\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tm.clear();\n\t\tfor(i=1;i<=N;++i)edge[i].clear();\n\t\tfor(i=2;i<=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tedge[x].push_back(i);\n\t\t}\n\t\tDFS(1,1);\n\t\tm[1]=1;\n\t\tm[N*2]=-1;\n\t\tres=0;\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c-'Q')\n\t\t\t{\n\t\t\t\tite=m.lower_bound(x);\n\t\t\t\tif(ite->second==x)continue;\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tfor(i=0;i<id[x].size();++i)\n\t\t\t\t{\n\t\t\t\t\tm[id[x][i]]=x;\n\t\t\t\t}\n\t\t\t\tm[id[x].back()+1]=t;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tite=m.upper_bound(id[x][0]);\n\t\t\t\tres+=(--ite)->second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {};\n\t\trep(i, n-1) {\n\t\t\tcin >> par0[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[i] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\n//再利用する場合はMAX_Nの値を設定し直すことを忘れない！！！\n//Union-Find木を少し改造\n\nconst int MAX_N = 100005;\n\nint Par[MAX_N+1];\nbool Marked[MAX_N+1];\n//int Rank[MAX_N];\n\nvoid init(int n){  //1~nまで初期化\n    for (int i = 1; i <= n; i++) {\n        Par[i] = i;\n        //Rank[i] = 0;\n    }\n}\n\nint find(int x) {  //xの根を返す\n    if (Marked[x]) return x;\n    else {\n        return find(Par[x]);\n    }\n}\n\nvoid unite(int x, int y) {  //xとyを併合.ただし、yをxに繋げる\n    Par[y] = x;\n}\n\nint N;  //Nodeの数\nint Q;  //Operationの数\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) break;\n        init(N);  //1~Nまで\n        fill(Marked, Marked+N+1, false);\n        Marked[1] = true;\n        for (int i = 2; i <= N; i++) {  //2~Nまで\n            int p;  //iの親\n            scanf(\"%d\", &p);\n            unite(p,i);  //iをpに繋げる\n        }\n        long long ret = 0;\n        for (int i = 0; i < Q; i++) {\n            char c;\n            int v;\n            scanf(\" %c %d\", &c, &v);\n            if (c == 'Q') {  //Markの付いた最近の祖先を調べる\n                ret += find(Par[v]);  //自分にMarkが入っている時に、自分をカウントしないようにする\n            } else if (c == 'M') {  //印をつける\n                Marked[v] = !Marked[v];\n            }\n        }\n        printf(\"%lld\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nconst int MAX_N=100000+16;\nint a[MAX_N*2];\nbool mark[MAX_N*2];\nint N,Q;\nint main(){\n    //freopen(\"1.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&N,&Q)!=EOF){\n        if(N==0&&Q==0)break;\n        memset(mark,false,sizeof(bool)*(N+10));\n        a[1]=0;\n        mark[1]=1;\n        for(int i=2;i<=N;i++){\n            scanf(\"%d\",&a[i]);\n        }\n        long ans=0;\n        while(Q--){\n            char c[2];\n            int x;\n            scanf(\"%s %d\",c,&x);\n            if(c[0]=='Q'){\n                while(!mark[x]){\n                    x=a[x];\n                }\n                ans+=x;\n            }\n            else {\n                mark[x]=true;\n            }\n        }\n        printf(\"%ld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\nint N,Q;\nvector<int> son[100005];\nint nepar[100005];\nint main()\n{\n    while(scanf(\"%d%d\",&N,&Q)==2&&(N!=0&&Q!=0))\n    {\n        for(int i=1;i<=N;i++)\n            son[i].clear();\n        long long ans=0;\n        nepar[1]=1;\n        int x;\n        for(int i=2; i<=N; i++)\n        {\n            scanf(\"%d\",&x);\n            son[x].push_back(i);\n            nepar[i]=1;\n        }\n        char str[5];\n        while(Q--)\n        {\n            scanf(\"%s%d\",str,&x);\n            if(str[0]=='Q')\n            {\n                ans+=nepar[x];\n            }\n            else\n            {\n                int u=nepar[x];\n                nepar[x]=x;\n                queue<int> q;\n                q.push(x);\n                while(!q.empty())\n                {\n                    int v=q.front();\n                    q.pop();\n                    for(int i=0; i<son[v].size(); i++)\n                    {\n                        int t=son[v][i];\n                        if(nepar[t]!=u)\n                            continue;\n                        nepar[t]=x;\n                        q.push(t);\n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y;\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\", ans);\n}\n  \nint main()\n{\n  Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m,x,sum,flg;\nstring str;\nint t[100001],u[100001];\nint dfs(int x){\n  if(u[x]==1)return x;\n  return dfs(t[x]);\n}\nint main(){\n  while(cin>>n>>m,n){\n    for(int i=0;i<100001;i++)u[i]=0;\n    t[1]=u[1]=1;\n    sum=0;\n    for(int i=0;i<n-1;i++)cin>>t[i+2];\n    for(int i=0;i<m;i++){\n      cin>>str>>x;\n      if(str==\"Q\"){\n    sum+=dfs(x);\n      }else{\n    u[x]=1;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n//#define int long long\nusing ll = long long;\ntemplate <typename T> struct SegmentTree {\n    int n;\n    T unit;\n    vector<T> dat;\n    function<T(T, T)> func;\n    SegmentTree(const int N, T unit, function<T(T, T)> func) : unit(unit), func(func) {\n        n = 1;\n        while (n < N) n *= 2;\n        dat.assign(2 * n, unit);\n    }\n    void update(int k, T a) {\n        k += n - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void add(int a, int b, int x) {\n        update(a, query(a, a + 1) + x);\n        update(b, query(b, b + 1) - x);\n    }\n    T getsum(int x) { return query(0, x + 1); }\n    T _query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return unit;\n        if (a <= l && r <= b)\n            return dat[k];\n        else {\n            T vl = _query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = _query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return func(vl, vr);\n        }\n    }\n    //[a,b)\n    T query(int a, int b) { return _query(a, b, 0, 0, n); }\n};\n\n// vector<int> G[100010];\nint parent[100010][26];\nint par[100010];\nint id[100010];\nint R[100010];\nint depth[100010];\nint q = 0;\nbool vis[100010];\nbool marked[100010];\nint idx = 0;\nbool DEBUG = false;\nvoid dfs(int n, int pre, vector<vector<int>>& G, int d = 0) {\n    // if (q >= 2) cerr << d << endl;\n    // if (q >= 2) cerr << n << endl;\n    // if (n == 70538 || n == 1708) {\n    //     cerr << n << endl;\n    //     cerr << G[n].size();\n    //     for (auto nxt : G[n]) cerr << nxt << \" \";\n    //     cerr << endl;\n    // }\n    assert(n >= 0 && n <= 100000);\n    assert(idx <= 100000);\n    id[n] = idx;\n    idx++;\n    // vis[n] = true;\n    for (auto nxt : G[n]) {\n        assert(nxt != n);\n        if (nxt == par[n] || nxt == pre) continue;\n        assert(0 < nxt && nxt <= 100000);\n        // if (vis[nxt]) continue;\n        depth[nxt] = depth[n] + 1;\n        par[nxt] = n;\n        dfs(nxt, n, G, d + 1);\n    }\n    R[n] = idx;\n}\nvoid init_par(int N) {\n    REP(i, N) { parent[i][0] = par[i]; }\n    FOR(k, 1, 25) {\n        REP(i, N) { parent[i][k] = parent[parent[i][k - 1]][k - 1]; }\n    }\n}\nint kth_parent(int n, int k) {\n    for (int i = 20; i >= 0; i--) {\n        if (k & (1 << i)) {\n            n = parent[n][i];\n        }\n    }\n    return n;\n}\n\nbool solve() {\n    int N;\n\n    cin >> N;\n    // cerr << N << endl;\n    assert(N <= 100000);\n    if (N == 0) return false;\n    // cerr << ++q << endl;\n    vector<vector<int>> G;\n    G.resize(N + 1);\n    REP(i, N + 10) {\n        // G[i].clear();\n        id[i] = 0;\n        marked[i] = false;\n        depth[i] = 0;\n        R[i] = 0;\n        vis[i] = false;\n        par[i] = 0;\n    }\n    int Q;\n    cin >> Q;\n    N++;\n\n    // if (q >= 1) {\n    //     FOR(i, 2, N) {\n    //         int v;\n    //         cin >> v;\n    //     }\n    //     while (Q--) {\n    //         char c;\n    //         int v;\n    //         cin >> c >> v;\n    //     }\n    //     return true;\n    // }\n    G[0].push_back(1);\n    G[1].push_back(0);\n\n    FOR(i, 2, N) {\n        int v;\n        cin >> v;\n        G[i].push_back(v);\n        G[v].push_back(i);\n    }\n    idx = 0;\n    // cerr << \"init tree... \";\n    dfs(0, 0, G);\n    // cerr << \"dfs done \";\n    // REP(i, N) { cerr << id[i] << \" \" << R[i] << endl; }\n    init_par(N);\n    // cerr << \"done\" << endl;\n    auto f = [](ll a, ll b) { return a + b; };\n    // cerr << \"init seg... \";\n    SegmentTree<ll> seg(N + 1, 0, f);\n    // cerr << \"done\" << endl;\n    seg.add(1, R[1], 1);\n    ll ans = 0;\n    while (Q--) {\n        char sign;\n        cin >> sign;\n        int v;\n        cin >> v;\n        if (sign == 'M') {\n            if (marked[v]) continue;\n            // assert(!marked[v]);\n            marked[v] = true;\n            seg.add(id[v], R[v], v);\n            if (DEBUG) REP(i, N) {\n                    cerr << i << \" \" << seg.getsum(id[i]) << endl;\n                }\n        } else {\n            int ok = 0, ng = depth[v];\n            if (DEBUG) {\n                cerr << \"depth:\" << depth[v] << endl;\n            }\n            ll sum = seg.getsum(id[v]);\n            if (DEBUG) {\n                cerr << \"sum:\" << sum << endl;\n            }\n            while (abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n                int p = kth_parent(v, mid);\n                ll tmp = seg.getsum(id[p]);\n                if (tmp == sum) {\n                    ok = mid;\n                } else\n                    ng = mid;\n            }\n            if (DEBUG) {\n                cerr << kth_parent(v, ok) << endl;\n            }\n            ans += kth_parent(v, ok);\n        }\n    }\n    // cerr << \"finish\" << endl;\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n    // solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 500000\nvector<int>conq[MAX_N]; int group[MAX_N], root[MAX_N];\nint n, m, a[MAX_N], b[MAX_N], c[MAX_N], ret[MAX_N]; bool M[MAX_N];\nvoid init() {\n\tfor (int i = 0; i < MAX_N; i++) { conq[i].clear(); a[i] = 0; b[i] = 0; c[i] = 0; group[i] = 0; root[i] = 0; ret[i] = 0; }\n\tfor (int i = 0; i < MAX_N; i++) { conq[i].push_back(i); group[i] = i; root[i] = i; M[i] = false; }\n}\nvoid unite(int p, int q) {\n\tint P = group[p], Q = group[q];\n\tint F1 = conq[P].size(), F2 = conq[Q].size();\n\tif (P == Q)return;\n\tint E = min(root[P], root[Q]);\n\tif (F1 >= F2) {\n\t\tfor (int i = 0; i < F2; i++) {\n\t\t\tconq[P].push_back(conq[Q][i]);\n\t\t\tgroup[conq[Q][i]] = P; root[conq[Q][i]] = E;\n\t\t}\n\t\tconq[Q].clear();\n\t}\n\tif (F1 < F2) {\n\t\tfor (int i = 0; i < F1; i++) {\n\t\t\tconq[Q].push_back(conq[P][i]);\n\t\t\tgroup[conq[P][i]] = Q; root[conq[P][i]] = E;\n\t\t}\n\t\tconq[P].clear();\n\t}\n}\nint Query(int p) {\n\treturn root[p];\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0)break; init(); for (int i = 1; i < n; i++) { cin >> a[i]; a[i]--; }\n\t\tfor (int i = 0; i < m; i++) { char C; cin >> C >> c[i]; c[i]--; if (C == 'M')b[i] = 0; else b[i] = 1; }\n\t\tfor (int i = 0; i < m; i++)if (b[i] == 0)M[c[i]] = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (M[i] == false)unite(a[i], i);\n\t\t}\n\t\tfor (int i = m - 1; i >= 0; i--) {\n\t\t\tif (b[i] == 0)unite(a[c[i]], c[i]);\n\t\t\tif (b[i] == 1)ret[i] = Query(c[i]) + 1;\n\t\t}\n\t\tint sum = 0; for (int i = 0; i < m; i++)sum += ret[i]; cout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    return h.size;\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T>\nvoid dump(vector<T> &vec){\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i];\n\t\tif(i+1<vec.size())cout << ' ';\n\t\telse cout << endl;\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid input(vector<T>& vec,int n){\n\tvec.resize(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> vec[i];\n\t}\n}\nint N,Q;\nvector<int> g[100100];\nchar type[100100];\nint p[100100];\nint ver[100100];\nint depth[100100];\nint marked[100100];\nconst int SIZE = 100100;\nstruct UnionFind{\n\tint par[SIZE];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(depth[x] > depth[y])par[x] = y;\n\t\telse par[y] = x;\t\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n}uf;\nvoid dfs(int v,int pa,int d){\n\tdepth[v] = d;\n\tif(!marked[v]){\n\t\tif(pa!=-1)uf.par[v]=pa;\n\t}\n\tfor(int i=0;i<g[v].size();i++){\n\t\tint u = g[v][i];\n\t\tif(u==pa)continue;\n\t\tdfs(u,v,d+1);\n\t}\n}\nvoid add_edge(int a,int b){\n\tg[a].pb(b);\n\tg[b].pb(a);\n}\nbool solve(){\n\tscanf(\"%d %d\",&N,&Q);\n\tif(N==0)return false;\n\tfor(int i=0;i<N;i++)g[i].clear();\n\tmemset(marked,0,sizeof(marked));\n\tfor(int i=1;i<N;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t\tp[i]--;\n\t\tadd_edge(i,p[i]);\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\" %c %d\",&type[i],&ver[i]);\n\t\tver[i]--;\n\t\tif(type[i]=='M')marked[ver[i]]++;\n\t}\n\tuf.init(N);\n\tdfs(0,-1,0);\n\tll ans = 0ll;\n\tfor(int i=Q-1;i>=0;i--){\n\t\tif(type[i]=='Q'){\n\t\t\t// cout << uf.find(ver[i]) << endl;\n\t\t\tans += 1+uf.find(ver[i]);\n\t\t}else{\n\t\t\tmarked[ver[i]]--;\n\t\t\tif(marked[ver[i]]==0)uf.par[ver[i]] = p[ver[i]];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 300003;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init();\n    for(int i = 1 ; i < n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tsum += find(num)+1;\n      }\n      else{\n\tpar[num] = num;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100000+5;\n\nint parent[MAXN];\nint marked[MAXN];\nint N,Q;\n\nint main()\n{\n    while(scanf(\"%d%d\", &N, &Q)!=EOF){\n        if(N==0 || Q==0) break;\n        memset(parent, -1, sizeof(parent));\n        memset(marked, 0, sizeof(marked));\n        int p;\n        for(int i=1;i<N;++i){\n            scanf(\"%d\", &p);\n            parent[i+1] = p;\n        }\n        getchar();\n        char c;\n        ll ans = 0;\n        marked[1] = 1;\n        for(int i=0;i<Q;++i){\n            scanf(\"%c%d\", &c, &p);\n            getchar();\n            if(c=='M'){\n                marked[p] = 1;\n            }\n            else{\n                while(!marked[p]){\n                    p = parent[p];\n                }\n                ans += p;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long \nusing namespace std;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 30;\n\nstruct BIT{\n    int N;\n    vector<int> dat;\n    BIT() {}\n    BIT(int n) {\n        N = n;\n        dat.resize(N + 1);\n    }\n    // update k th element (0-index)\n    void add(int k, int x){\n        k++;\n        while(k <= N){\n            dat[k] += x;\n            k += k&-k;\n        }\n    }\n    // sum [0, k) (0-index)\n    int sum(int k){\n        int s = 0;\n        while(k > 0){\n            s += dat[k];\n            k -= k&-k;\n        }\n        return s;\n    }\n    // sum [a, b) (0-index)\n    int query(int a, int b){\n        return sum(b) - sum(a);\n    }\n};\n\nint n, q;\nvector<int> G[MAX_V]; \n\nclass Euler_Tour{\npublic:\n    // vector<vector<int> > g;\n    //begin[v],end[v]はそれぞれvがオイラーツアー上で最初と最後に現れるインデックス\n    //[begin[v], end[v])がvを根とする部分木 (半開区間に注意)\n    vector<int> euler_tour, begin, end, dist;\n    Euler_Tour(int n) : /*g(n),*/ begin(2 * n), end(2 * n){};\n    int k = 0, root = 0;\n    void dfs(int curr, int par){\n        begin[curr] = k;\n        euler_tour.push_back(curr);\n        k++;\n        for(auto next : G[curr]){\n            if(next == par) continue;\n            dfs(next, curr);\n            euler_tour.push_back(curr);\n            k++;\n        }\n        end[curr] = k;\n    }\n};\n\nint root = 0;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    dfs(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & 1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];    \n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> q;\n        if(n + q == 0) break;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 1, n){\n            int v;\n            cin >> v;\n            v--;\n            G[v].push_back(i);\n            G[i].push_back(v);\n        }\n        Euler_Tour et(n);\n        et.dfs(0, -1);\n        init(n);\n        BIT bt(2 * n);\n        // mark 0\n        bt.add(et.begin[0], 1);\n        bt.add(et.end[0] - 1, -1);\n\n        int ans = 0;\n        rep(i, 0, q){\n            char c; int v;\n            cin >> c >> v;\n            v--;\n            if(c == 'M'){\n                bt.add(et.begin[v], 1);\n                bt.add(et.end[v] - 1, -1);\n            }else{\n                int nowv = v;\n                for(int k = MAX_LOG_V - 1; k >= 0; k--){\n                    int tmpv = parent[k][nowv];\n                    int val = bt.query(et.begin[tmpv], et.begin[v]);\n                    if(val == 0){\n                        nowv = tmpv;\n                    }\n                }\n                int tmp = parent[0][nowv];\n                // cout << tmp << endl;\n                ans += (tmp + 1);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nconst int max_n = 100000;\nint par[max_n * 2];\nbool marked[max_n * 2];\ntypedef long long ll;\n\nvoid init(int n) {\n    for(int i = 0; i < n; i++) {\n        par[i] = i;\n        marked[i] = false;\n    }\n    marked[0] = true;\n}\n\nint find(int x) {\n    if(marked[x]) return x;\n    else return find(par[x]);\n}\n\n\nint main() {\n    while(true) {\n        int n, q;\n        ll sum = 0;\n        cin >> n >> q;\n        init(n);\n        if(n == 0 && q == 0) break;\n\n        for(int i = 0; i < n - 1; i++) {\n            int x;\n            cin >> x;\n            x--;\n            par[i + 1] = x;\n        }\n\n        for(int i = 0; i < q; i++) {\n            char qt;\n            int x;\n            cin >> qt >> x;\n            x--;\n            if(qt == 'M') {\n                marked[x] = true;\n            } else {\n                sum += find(par[x]);\n                sum++;\n            }\n        }\n\n        cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x] ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t\tchk[x] = true;\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\t//for( auto i : memo ) cout << i << endl;\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N, Q;\nint p[100010];\nstring T[100010];\nint NUM[100010];\n\nvector<int> G[100010];\nint ans[100010];\nbool used[100010];\n\nvoid dfs(int u, int k) {\n\tfor(auto v : G[u]){\n\t\tans[v] = k;\n\t\tif(used[v]) continue;\n\t\tdfs(v, k);\n\t}\n}\n\nint main(void) {\n\twhile(1){\n\t\tscanf(\"%d %d\", &N, &Q);\n\t\tif(N == 0 && Q == 0) break;\n\t\trep(i, N - 1) scanf(\"%d\", &p[i]);\n\t\trep(i, Q){\n\t\t\tcin >> T[i] >> NUM[i];\n\t\t}\n\t\trep(i, Q) NUM[i]--;\n\n\t\trep(i, 100010) G[i].clear();\n\t\trep(i, 100010) ans[i] = 0;\n\t\trep(i, 100010) used[i] = false;\n\n\t\trep(i, N - 1) G[p[i] - 1].pb(i + 1);\n\n\t\tint ret = 0;\n\t\trep(i, Q) {\n\t\t\tif(T[i] == \"Q\") {\n\t\t\t\t// printf(\"ans %d\\n\", ans[NUM[i]] + 1);\n\t\t\t\tret += ans[NUM[i]] + 1;\n\t\t\t}else{\n\t\t\t\tused[NUM[i]] = true;\n\t\t\t\tdfs(NUM[i], NUM[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n\nusing namespace std;\n\nint fa[100005];\nint marked[100005];\n\nint find(int x){\n\tif (marked[x]) return x;\n\telse return find(fa[x]);\n\t\n}\n\nint main(){\n\tint n, q;\n\twhile (scanf(\"%d%d\", &n, &q) != EOF){\n\t\tif (n == 0&&q == 0) break;\n\n\t\tfor (int i = 1; i <=n; i++) {\n\t\t\tfa[i] = i;\n\t\t\tmarked[i] = 0;\n\t\t}\n\t\tmarked[1] = 1;\n\n         int x;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfa[i] = x;\n\t\t}\n\n\t\tchar ch;\n\t\tint dex;\n\t\tscanf(\"%c\", &ch);\n\t\tlong long ans = 0;\n\t\tint t;\n\t\tfor (int i = 0; i < q;i++){\n\t\t\tscanf(\"%c%d\", &ch, &dex);\n\t\t\t\n         if (ch == 'Q'){\n\t\t\t t = find(dex); \n\t\t\t\tans += t;\n\t\t\t}\n\t\telse marked[dex] = 1;\n\t\tscanf(\"%c\", &ch);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  UnionFind(int n = 0): par(n, -1){}\n  int root(int x){\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return;\n    par[y] = x;\n  }\nprivate:\n  vector<int> par;\n};\n\nint n, q;\nint p[100000];\nstring t[100000];\nint v[100000];\nint m[100000];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  while (cin >> n >> q, n){\n    memset(m, 0, sizeof(m));\n    m[0]++;\n    UnionFind uf(n);\n    for (int i = 1; i < n; i++){\n      cin >> p[i], p[i]--;\n    }\n    for (int i = 0; i < q; i++){\n      cin >> t[i] >> v[i], v[i]--;\n      if (t[i] == \"M\") m[v[i]]++;\n    }\n    for (int i = 0; i < n; i++){\n      if (!m[i]){\n        uf.unite(p[i], i);\n      }\n    }\n    int s = 0;\n    for (int i = q - 1; i >= 0; i--){\n      if (t[i] == \"M\"){\n        if (!--m[v[i]]){\n          uf.unite(p[v[i]], v[i]);\n        }\n      }\n      else s += uf.root(v[i]) + 1;\n    }\n    cout << s << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint size = 0, value[100000], parent[100000];\nbool is_mark[100000], is_root[100000];\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\n\t\tif(x > y)\n\t\t\tswap(x, y);\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\ninline void push(int x) {\n\tvalue[size++] = x;\n}\n\ninline int pop() {\n\treturn value[--size];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tcin >> parent[i];\n\t\t\t--parent[i];\n\t\t}\n\n\t\tmemset(is_root, false, sizeof(is_root));\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tpush(--v);\n\t\t\tif(ope == 'Q')\n\t\t\t\tis_mark[i] = false;\n\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tis_root[v] = true;\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tlong long ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tint v = pop();\n\n\t\t\tif(is_mark[i])\n\t\t\t\tuf.unite(v, parent[v]);\n\t\t\telse\n\t\t\t\tans += uf.find(v) + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q),n|q){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] = true;\n\t\tlong long sum = 0;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = false;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <set>\nusing namespace  std;\nconst int maxn = 1e5 + 5;\ntypedef long long ll;\n#define mid (l + r) / 2\n#define lc (rt << 1)\n#define rc (rt << 1 | 1)\n//set<int> st;\nvector<int> mp[maxn];\nint f[maxn];\nint in[maxn],out[maxn];\nint te = 0;\nstruct tr{\n    struct node{\n        int v,set;\n    }seg[maxn << 2];//就是不知道怎?pushup\n    void init(int l,int r,int rt)\n    {\n        if(l == r) {seg[rt].v = 1;seg[rt].set = 0;return;}\n        init(l, mid, lc);\n        init(mid + 1, r, rc);\n       seg[rt].v = 1;seg[rt].set = 0;//反正?点??。。。?不重要?？？？\n    }\n    int ql,qr;\n    int query(int pos,int l,int r,int rt)//?点??\n    {\n        if(l == r) {return seg[rt].v;}\n        if(pos <= mid) return query(pos, l, mid, lc);\n        else return query(pos, mid + 1, r, rc);\n    }\n    void pushdown(int l,int r,int rt)\n    {\n        if(seg[rt].set)\n        {\n            seg[lc].set = seg[rt].set;\n            seg[rc].set = seg[rt].set;\n            seg[lc].v = seg[rc].v = seg[rt].set;\n            seg[rt].set = 0;\n        }\n    }\n    void update(int l,int r,int rt,int val)//区?修改//当?点是叶子的?候，他不??修改rt的v，\n    {\n        if(ql == qr + 1){\n            seg[rt].set = val;\n            return;\n        }\n        if(ql <= l && r <= qr){\n            seg[rt].set = seg[rt].v = val;\n            return;\n        }\n        pushdown(l,r,rt);\n        if(ql <= mid) update(l, mid, lc, val);\n        if(mid < qr) update(mid + 1, r, rc, val);\n        seg[rt].v = seg[lc].v;\n        //no pushup?\n    }\n};\nvoid init(int n)\n{\n    for (int i = 1; i <= n; i ++) {\n        mp[i].clear();\n    }\n    memset(in, 0, sizeof(int) * (n + 1));\n    memset(out, 0, sizeof(int) * (n + 1));\n    //st.clear();\n}\nvoid dfs(int u)\n{\n    in[u] = ++te;\n    for (int i = 0; i < mp[u].size(); i ++) {\n        if(mp[u][i] != f[u]){\n            dfs(mp[u][i]);\n        }\n    }\n    out[u] = te;\n}\nint main()\n{\n    int n,q;\n    while (scanf(\"%d%d\",&n,&q) != EOF) {\n        if(n == 0 && q == 0) break;\n        init(n);\n        int tmp;\n        for (int i = 2; i <= n; i ++) {\n            scanf(\"%d\",&tmp);\n            mp[tmp].push_back(i);\n            mp[i].push_back(tmp);\n            f[i] = tmp;\n        }\n        getchar();\n        dfs(1);\n        tr tree;\n        tree.init(1, n, 1);\n//        for (int i = 1; i <= n; i ++) {\n//            printf(\"%d \",in[i]);\n//        }printf(\"\\n\");\n//        for (int i = 1; i <= n; i ++) {\n//            printf(\"%d \",out[i]);\n//        }printf(\"\\n\");\n        \n        char op;\n        int v;\n        ll sum = 0;\n      //  st.insert(1);\n        for (int i = 0; i < q; i ++) {\n            scanf(\"%c%d%*c\",&op,&v);\n            if(op == 'M')\n            {\n               // if(st.find(v) == st.end()){\n                //st.insert(v);\n                tree.qr = out[v];\n                tree.ql = in[v] + 1;\n                tree.update(1, n, 1, v);\n               // }\n            }else{\n                sum += tree.query(in[v],1,n,1);\n            }\n           // printf(\"%lld\\n\",sum);\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\nvector<int> mark_parent;\nvector<int> marked;\n\nvoid walk_graph(int v, int mark_p, graph& g) {\n\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p, g);\n    }\n}\n\nint find_mark_parent(int v) {\n    if (marked[v]){\n        // cout << endl;\n        return v;\n    }\n    // cout << v << \"->\";\n    mark_parent[v] = find_mark_parent(mark_parent[v]);\n    return mark_parent[v];\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    mark_parent = vector<int>(N, 0);\n    marked = vector<int>(N, 0);\n\n    graph g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            ++marked[q.second];\n        }\n    }\n\n    walk_graph(0, -1, g);\n    \n    // cout << \"####walk_graph####\" << endl;\n\n    long long ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n        // cout << \"####\" << j << \" \" << queries[j].first << \" \" << queries[j].second << \"####\" << endl;\n\n        if (ch == 'Q') {\n            ret += find_mark_parent(v) + 1;\n        }\n\n        if (ch == 'M') {\n            --marked[v];\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        // cout << N << \" \" << Q << endl;\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\ntypedef struct q\n{\n\tchar Op;\n\tint n;\n}q;\n\nint t[100001],pa[100001],N,Q,ans,j;\nq query[100001];\nvoid i(int n)\n{\n\tfor(j=0;j<=n;j++)\n\t\tt[j]=j;\n}\n\nint p(int n)\n{\n\tif(t[n]==n)\n\t\treturn n;\n\telse\n\t\treturn t[n]=p(t[n]);\n}\n\nvoid u(int a,int b)\n{\n\tt[p(a)]=p(b);\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0)\n\t{\n\t\tans=0;\n\t\tfor(i(N),j=1;j<=N;j++)\n\t\t{\n\t\t\tscanf(\"%d\\n\",&pa[j+1]);\n\t\t\tt[j+1]=pa[j+1];\n\t\t}\n\t\tfor(j=0;j<Q;j++)\n\t\t{\n\t\t\tscanf(\"%c%d\\n\",&query[j].Op,&query[j].n);\n\t\t\tif(query[j].Op=='M')\n\t\t\t{\n\t\t\t\tif(t[query[j].n]==query[j].n)\n\t\t\t\t\tquery[j].Op='X';\n\t\t\t\telse\n\t\t\t\t\tt[query[j].n]=query[j].n;\n\t\t\t}\n\t\t}\n\t\tfor(j=Q-1;j>=0;j--)\n\t\t{\n\t\t\tif(query[j].Op=='M')\n\t\t\t\tu(query[j].n,pa[query[j].n]);\n\t\t\telse if(query[j].Op=='Q')\n\t\t\t\tans+=p(query[j].n);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 temp.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint N,Q;\nint p[100000];\nchar op[100000];\nint v[100000];\nbool is_painted[100000];\n\n/////////\nint par[100000+10], ranks[100000+10];\n\nvoid init(int m){\n\tREP(i,m){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx=find(x); y=find(y);\n\tif(x==y) return;\n\tif(ranks[x]<ranks[y])par[x]=y;\n\telse{\n\t\tpar[y]=x;\n\t\tif(ranks[x]==ranks[y])ranks[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\n/////////////\n\nint main(){\n\twhile(1){\n\t\tcin>>N>>Q;\n\t\tif(N==0&&Q==0)break;\n\t\tp[0]=0;\n\t\tFOR(i,1,N){\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t\tp[i]--;\n\t\t}\n\t\tREP(i,N) is_painted[i]=false;\n\t\tis_painted[0]=true;\n\t\tREP(i,Q){\n\t\t\tcin>>op[i]>>v[i];\n\t\t\tv[i]--;\n\t\t\tif(op[i]=='M'){\n\t\t\t\tif(is_painted[v[i]]){\n\t\t\t\t\ti--; Q--; continue;\n\t\t\t\t}\n\t\t\t\tis_painted[v[i]]=true;\n\t\t\t}\n\t\t}\n\t\tinit(N);\n\t\tREP(i,N){\n\t\t\tif(!is_painted[i]) unite(i,p[i]);\n\t\t}\n\t\tll res = 0;\n\t\tfor(int i=Q-1;i>=0;i--){\n\t\t\tif(op[i]=='Q'){\n\t\t\t\tint nv = v[i];\n\t\t\t\twhile(nv!=0&&same(nv,p[nv])) nv=p[nv];\n\t\t\t\tres+=nv+1;\n\t\t\t\t//dbg(nv);\n\t\t\t}else if(op[i]=='M'){\n\t\t\t\tunite(v[i],p[v[i]]);\n\t\t\t\t//dbg(v[i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tTree *child,*next;\n\t\tTree(){}\n\t\tTree(T &v):val(v),child(0),next(0){}\n\t\t~Tree(){\n\t\t\tif(child)delete child;\n\t\t\tif(next)delete next;\n\t\t}\t\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\tb->next=a->child;\n\t\t\ta->child=b;\n\t\t\treturn a;\n\t\t}else{\n\t\t\ta->next=b->child;\n\t\t\tb->child=a;\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(int n):trees(n){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\th.trees.clear();\n\t\tif(carry)trees.push_back(carry);\n\t}\n\t//O(log n)\n\tvoid push(T v){\n\t\timax=-1;\n\t\t/*BinomialHeap h(1);\n\t\th.trees[0]=new Tree(v);\n\t\tmeld(h);*/\n\t\tTree* carry=new Tree(v);\n\t\tfor(int i=0;carry&&i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else {\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tif(imax==0){\n\t\t\tdelete trees[0];\n\t\t\ttrees[0]=NULL;\n\t\t}else{\n\t\t\tBinomialHeap h(imax);\n\t\t\tTree *p,*t=trees[imax]->child;\n\t\t\tint i=imax;\n\t\t\twhile(t){\n\t\t\t\th.trees[--i]=t;\n\t\t\t\tp=t;\n\t\t\t\tt=t->next;\n\t\t\t\tp->next=NULL;\n\t\t\t}\n\t\t\ttrees[imax]->child=NULL;\n\t\t\tdelete trees[imax];\n\t\t\ttrees[imax]=NULL;\n\t\t\tmeld(h);\n\t\t}\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])delete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nlong long ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\twhile(!bh[u].empty() && marked[u]<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tbh[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].push(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> to;\n\tUnionFind(int size) : data(size, -1), to(size,-1) {\n\t\trep(i, size)to[i] = i;\n\t}\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tvoid setTo(int x, int to) {\n\t\tthis->to[root(x)] = to;\n\t}\n\tint findTo(int x) {\n\t\treturn to[root(x)];\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i]; v[i]--;\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a, int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tint root = uf.findTo(e[e[j].p].m);\n\t\t\t\t\tuf.unionSet(e[j].m, e[e[j].p].m);\n\t\t\t\t\tuf.setTo(e[j].m, root);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findTo(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            (uf.c[p-1]).push_back(i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        int a,b;\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        if(x > y) swap(x, y);\n        // y を x に統合 (数字の小さい方に合わせる)\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(i, parent[i]);\n            }\n        }\n        debug();\n\n        ll ans = 0;\n        for(int i=0; i<Q; i++) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n            debug();\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tconst int N;\n\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tint groups_;\n\tstd::vector< int > sizes;\n\npublic:\n\tUnionFind( int n ) : N( n ), parent( N ), rank( N, 0 ), groups_( N ), sizes( N, 1 )\n\t{\n\t\tstd::iota( parent.begin(), parent.end(), 0 );\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tbool unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t\tsizes[y] += sizes[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tsizes[x] += sizes[y];\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\t++rank[x];\n\t\t\t}\n\t\t}\n\n\t\t--groups_;\n\t\treturn true;\n\t}\n\n\tint groups() const\n\t{\n\t\treturn groups_;\n\t}\n\n\tint groupSize( const int x )\n\t{\n\t\treturn sizes[ find( x ) ];\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n// groups()\n// groupSize( x )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, Q; scanf( \"%d%d\", &N, &Q ), ( N | Q ); )\n\t{\n\t\tVI parents( N, -1 );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tscanf( \"%d\", &parents[i] );\n\t\t\t--parents[i];\n\t\t}\n\t\tVT( char ) types( Q );\n\t\tVI vs( Q );\n\t\tREP( i, Q )\n\t\t{\n\t\t\tscanf( \" %c%d\", &types[i], &vs[i] );\n\t\t\t--vs[i];\n\t\t}\n\t\t// end of input\n\n\t\tVI marked( N );\n\t\tmarked[0] = 1;\n\t\tREP( i, Q )\n\t\t{\n\t\t\tif ( types[i] == 'M' )\n\t\t\t{\n\t\t\t\t++marked[ vs[i] ];\n\t\t\t}\n\t\t}\n\t\tREP( i, N )\n\t\t{\n\t\t\tif ( !marked[i] )\n\t\t\t{\n\t\t\t\ttypes.PB( 'M' );\n\t\t\t\tvs.PB( i );\n\t\t\t\t++marked[i];\n\t\t\t}\n\t\t}\n\n\t\tVI answers( N );\n\t\tiota( ALL( answers ), 1 );\n\t\tUnionFind uf( N );\n\t\tLL res = 0;\n\t\tfor ( int i = SZ( types ) - 1; 0 <= i; --i )\n\t\t{\n\t\t\tconst char T = types[i];\n\t\t\tconst int v = vs[i];\n\n\t\t\tif ( T == 'M' )\n\t\t\t{\n\t\t\t\t--marked[v];\n\t\t\t\tif ( !marked[v] )\n\t\t\t\t{\n\t\t\t\t\tconst int p = parents[v];\n\t\t\t\t\tconst int na = answers[ uf.find( p ) ];\n\t\t\t\t\tuf.unite( v, p );\n\t\t\t\t\tanswers[ uf.find( v ) ] = na;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += answers[ uf.find( v ) ];\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%I64d\\n\", res );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nint par[100001], e[100001], v[100000];\nint cnt[100001];\nchar op[100000];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    par[find(x)] = find(y);\n}\n\nint main(void) {\n    int i, n, q;\n    for (;;) {\n        scanf(\"%d%d\",&n,&q);\n        if (n == 0 && q == 0) break;\n        e[1] = 1;\n        REP (i,2,n) scanf(\"%d\\n\",&e[i]);\n        REP (i,1,n) par[i] = e[i];\n        REP (i,q) {\n            scanf(\"%c%d\\n\",&op[i],&v[i]);\n            if (op[i] == 'M') {\n                par[v[i]] = v[i];\n                cnt[v[i]]++;\n            }\n        }\n        ll ans = 0;\n        RREP (i,q) {\n            if (op[i] == 'M') {\n                if (--cnt[v[i]] == 0)\n                    unite(v[i],e[v[i]]);\n            }\n            else\n                ans += find(v[i]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n/* \n author:hdsdogge \n begin: \n end: \n cost: \n *//*   author \n#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<bitset>\n#include<cstdlib>\n#include<list>\n#include <sstream>\n#include<ctype.h>\nusing namespace std;\nconst int maxn=1000000+10;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst double PI = acos(-1.0);\nconst double eps = 1e-6;\nconst int INF = 1000000000;\nint T,n,m;\nint par[maxn];\nint vis[maxn];\nint main() {\n    //freopen(\"test\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    while(cin>>n>>m&&(n+m)){\n        memset(par,0,sizeof(par));\n        memset(vis,0, sizeof(vis));\n        par[1]=1;\n        vis[1]=1;\n        ll ans=0;\n        for(int i=2;i<=n;i++){\n            int x;\n            cin>>x;\n            par[i]=x;\n        }\n        for(int i=0;i<m;i++){\n            char c;\n            int x;\n            cin>>c>>x;\n            if(c=='Q'){\n                //x=par[x];\n                while(vis[x]==0){\n                    x=par[x];\n                }\n                ans+=x;\n            }\n            else if(c=='M'){\n               vis[x]=1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int UFSIZE = 100010;\nint P[UFSIZE]; // 親\nint T[UFSIZE]; // 木\n\nvoid init() {\n  for (auto i=0; i<UFSIZE; i++) {\n    P[i] = i;\n  }\n}\n\nint root(int a) {\n  if (a == P[a]) return a;\n  return (P[a] = root(P[a]));\n}\n\nbool issame(int a, int b) {\n  return root(a) == root(b);\n}\n\nvoid unite(int a, int b) {\n  P[root(a)] = root(b);\n}\n\nbool isroot(int a) {\n  return root(a) == a;\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    T[0] = 0;\n    for (auto i=1; i<N; i++) {\n      cin >> T[i];\n      T[i]--;\n    }\n    vector< pair<bool, int> > V;\n    for (auto i=0; i<Q; i++) {\n      char op;\n      int v;\n      cin >> op >> v;\n      V.push_back(make_pair((op == 'M'), --v));\n    }\n    for (auto i=0; i<N; i++) {\n      P[i] = T[i];\n    }\n    for (auto i=0; i<Q; i++) {\n      if (V[i].first) {\n\tP[V[i].second] = V[i].second;\n      }\n    }\n    reverse(V.begin(), V.end());\n    long long ans = 0;\n    for (auto i=0; i<Q; i++) {\n      if (V[i].first) {\n\tunite(V[i].second, T[V[i].second]);\n      } else {\n\tans += root(V[i].second)+1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nLL int N,E,cnt;\nLL int par[100005];\nLL int find(LL int n){\n\treturn n==par[n]?n:find(par[n]);\n}\nint main(){\n\twhile(scanf(\"%lld%lld\",&N,&E)==2){\n\t\tgetchar();\n\t\tif(N==0&&E==0) break;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tscanf(\"%lld\",&par[i+1]);\n\t\t}\n\t\tpar[1]=1;getchar();\n\t\tchar c;\n\t\tlong long int sum = 0;\n\t\tfor(int i=0;i<E;i++){\n\t\t\tscanf(\"%c %lld\",&c,&cnt);\n\t\t\tgetchar();\n\t\t\tif(c=='M') par[cnt]=cnt;\n\t\t\telse{\n\t\t\t\tsum += find(cnt);\n\t\t\t}\n\t\t} \n\t\tcout<<sum<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long Long;\n\n#define MN 100000\n#define MQ 100000\nint N, Q;\nint parent[MN + 1];\nbool marked[MN + 1];\npair<int, int> queries[MQ];\n\nint root(int x) {\n    if (marked[x]) return x;\n    return parent[x] = root(parent[x]);\n}\nvoid merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return;\n    parent[x] = y;\n}\n\nbool input() {\n    scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) return false;\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        parent[i] = p;\n    }\n    memset(marked, false, N + 1);\n    marked[1] = true;\n    for (int i = 0; i < Q; i++) {\n        char t; int n;\n        scanf(\"%*[ \\t\\r\\n]%c %d\", &t, &n);\n        if (t == 'M') {\n            if (marked[n]) {\n                queries[i] = make_pair('X', 0);\n                continue;\n            }\n            marked[n] = true;\n        }\n        queries[i] = make_pair(t, n);\n    }\n    return true;\n}\n\nvoid solve() {\n    Long ans = 0;\n    for (int q = Q - 1; q >= 0; q--) {\n        pair<int, int> query = queries[q];\n        if (query.first == 'Q') {\n            ans += root(query.second);\n        } else if (query.first == 'M') {\n            marked[query.second] = false;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    while (input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for (int (i) = (a); (i)<=(b); (i)++)\n#define INFI 100000000\nusing namespace std;\n\nint N, Q;\nconst int maxn = 100000+100;\nint par[maxn];\nbool marked[maxn];\nlong long ans;\n\nint print(int n);\n\nint main() {\n\twhile (cin>>N>>Q && N && Q) {\n\t\tmarked[1] = true; par[1] = 1;\n\t\tREP(i,2,N) scanf(\"%d\", &par[i]);\n\t\tREP(k,1,3) {\n\t\t\tchar ch; int v;\n\t\t\tgetchar();\n\t\t\tscanf(\"%c %d\", &ch, &v);\n\t\t\tif (ch=='M') marked[v] = true;\n\t\t\telse if (ch=='Q') ans+=print(v);\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tREP(i,0,N+1) marked[i] = false, par[i] = 0;\n\t\tans = 0;\n\t}\n\n\treturn 0;\n}\n\nint print(int n) {\n\tif (marked[n]) return n;\n\telse return print(par[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = (1<<17);\n\nclass RMQ{\n  int n,dat[2*MAX_N-1];\n\npublic:\n  void init(int _n = MAX_N){ \n    n = 1;\n    while(n < _n) n *= 2;\n    fill(dat,dat+2*n-1,1);\n  }\n\n  int get(int k){\n    k += n - 1;\n    int ret = dat[k];\n    while(k > 0){\n      k = (k - 1) / 2;\n      ret = max( ret, dat[k] );\n    }\n    return ret;\n  }\n\n  void query(int a, int b,int x){ query(a, b, x, 0, 0, n);}\n  void query(int a, int b, int x, int k, int l, int r){\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) dat[k]=max(dat[k],x);\n    else{\n      query(a, b, x, k*2+1, l, (l+r)/2);\n      query(a, b, x, k*2+2, (l+r)/2, r);      \n    }\n  }\n};\n\nRMQ seg;\nvector<int> G[100003];\nint L[100003];\nint R[100003];\nint cnt;\nvoid dfs(int id){\n  L[id] = cnt++; \n  for(int i=0;i<(int)G[id].size();i++){\n    dfs(G[id][i]);\n  }\n  R[id] = cnt;\n}\n\nint main(){\n  int n,q;\n  while(cin >> n >> q && (n||q) ){\n    seg.init(n+1);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=2;i<=n;i++){\n      int p; cin >> p;\n      G[p].push_back( i );\n    }\n    cnt = 0;\n    dfs(1);\n    long long res = 0;\n    for(int i=0;i<q;i++){\n      char c; cin >> c;\n      int d; cin >> d;\n      if( c  == 'Q' ){\n\tres += (long long)seg.get(L[d]);\n      } else {\n\tseg.query(L[d],R[d],d);\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint par[100010],o[100010];\n\nint find(int pos){\n  if(o[pos]) return pos;\n  return find(par[pos]);\n}\n\nint main(){\n  while(1){\n    int n,q;\n    cin>>n>>q;\n    if(!n&&!q)break;\n    for(int i=0;i<=n;i++) o[i]=0;\n    for(int i=2;i<=n;i++) cin>>par[i];\n    \n    o[1]=1;\n    int ans=0;\n    while(q--){\n      char ch;int idx;\n      cin>>ch>>idx;\n      if(ch=='M') o[idx]=1;\n      if(ch=='Q')ans+=find(idx);\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#define INF 1000000000\n#define M 100005\n#define LL long long\nusing namespace std;\nstruct node{\n    int x,y;\n}A[M],Q[M];\nint fa[M];\nbool mark[M];\nint edge[M];\nint get(int x){\n    if(fa[x]==x) return x;\n    else return fa[x]=get(fa[x]);\n}\nint get_ans(int x){\n    x=get(x);\n    while(!mark[x]){\n        if(x==0) return -1;\n        fa[x]=edge[x];\n        x=edge[x];\n        x=get(x);\n    }\n    return x;\n}\nint readin(){\n    int res=0;\n    char a;\n    while(a=getchar(),!isdigit(a));\n    do{\n        res=(res<<3)+(res<<1)+(a^48);\n    }while(a=getchar(),isdigit(a));\n    return res;\n}\nint main(){\n    int n,q,j,k;\n    while(scanf(\"%d%d\",&n,&q)!=EOF){\n        if(n==0&&q==0) break;\n        memset(mark,0,sizeof(mark));\n        mark[1]=1;edge[1]=1;\n        for(j=1;j<=n;j++) fa[j]=j;\n        for(j=2;j<=n;j++){\n            int a;\n            a=readin();\n            edge[j]=a;\n        }\n        char s[2];\n        for(j=1;j<=q;j++){\n            scanf(\"%s\",s);Q[j].y=readin();\n            if(s[0]=='Q') Q[j].x=0;\n            else{\n                mark[Q[j].y]=1;\n                Q[j].x=1;\n            }\n        }\n        long long ans=0;\n        for(j=q;j>=1;j--){\n            if(Q[j].x==0){\n                int t=get_ans(Q[j].y);\n                ans+=t;\n            }\n            else mark[Q[j].y]=0;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry==NULL && h.trees.size()<=i)break;\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nint par[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nvector<int> edge[100000];\nlong long ans;\n\n\nvector<int> nodes;\n\nvoid bfs(){\n\tnodes.clear();\n\tint u=0;\n\tqueue<int> q;\n\tq.push(u);\n\twhile(!q.empty()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tnodes.push_back(u);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tq.push(edge[u][i]);\n\t\t}\n\t}\n}\n/*なぜかstack over flowする\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}*/\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tpar[0]=-1;\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t\tpar[i]=p-1;\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tbfs();\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tint u=nodes[i];\n\t\t\tint t=marked[u];\n\t\t\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\t\t\tans+=u+1;\n\t\t\t\tcout<<u<<endl;\n\t\t\t\tbh[u].popmax();\n\t\t\t}\n\t\t\tif(u!=0){\n\t\t\t\tbh[par[u]].meld(bh[u]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\n\nstruct UnionFind{\n    vector <int> data;\n    UnionFind(int N) : data(N, -1){}\n    void unite(int x, int y){\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    int root(int x){ return data[x] < 0 ? x : data[x] = root(data[x]);}\n};\n\ntypedef pair<bool, int> pbt;;\nbool marked[100000];\nint p[100000];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, Q, _t;\n    char _c;\n    while(cin >> N >> Q && N){\n        memset(marked, 0, sizeof(marked));\n        marked[0] = true;;\n        UnionFind uf(N);\n        vector<pbt> query;\n        \n        REP(i, 1, N){\n            cin >> p[i];\n            --p[i];\n        }\n        rep(i, Q){\n            cin >> _c >>_t;\n            --_t;\n            if(_c == 'Q')\n              query.push_back(pbt(1, _t));\n            else if(!marked[_t]){\n                query.push_back(pbt(0, _t));\n                marked[_t] = true;\n            }\n        }\n\n        rep(i, N)\n          if(!marked[i])\n            uf.unite(p[i], i);\n        ll sum = 0LL;\n        for(int i = query.size() - 1; i >= 0; --i){\n            int v = query[i].second;\n            if(query[i].first)\n              sum += uf.root(v) + 1;\n            else\n              uf.unite(p[v], v);\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<stdio.h>\n#include<string>\nusing namespace std;\nconst int MAX_N=100005;\nint par[MAX_N];//父亲数组\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        par[i]=i;\n    }\n}\n\n\n\nint find(int x)//查询最近的已标记的祖先节点\n{\n    if(x==par[x])return x;\n    else return find(par[x]);\n}\n\n\nvoid unite(int x,int y)//记x为y的子节点\n{\n    par[x]=y;\n}\n\nint main()\n{\n    //freopen(\"c://Users/kkk/Destop/acm.txt\",\"r\",stdin);\n    int N,M;\n    while(1)\n    {\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    int parent;\n    init(N+1);\n    for(int i=2;i<=N;i++)\n    {\n        cin>>parent;\n        unite(i,parent);\n    }\n    long long ans=0;\n    while(M--)\n    {\n        char c;int t;\n        cin>>c;\n        cin>>t;\n        if(c=='Q')\n        {\n            ans+=find(t);\n        }\n        else if(c=='M')\n        {\n            par[t]=t;\n        }\n    }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n        /*\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t\tbreak;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000], R[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)K[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint D = i;\n\t\t\tfor (int j = 0; j < 50; j++) D = a[i];\n\t\t\tR[i] = D;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M' && K[i] != 1)UF.unite(a[K[i]], K[i]);\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\tbool flag = true;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(R[D], K[i]) == false) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\t\t\tsum += D; flag = false; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tD = a[D];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag == false)break;\n\t\t\t\t\t}\n\t\t\t\t\tD = R[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\nconst int B = 450;\n\nint N, Q;\nstd::vector<int> G[100100];\nint start[100100], friends[100100];\nint buckets[450], parts[200200];\nint doubling[17][100100];\n\nvoid makeDoubling(){\n    for(int i=0;i+1<=16;++i){\n        for(int j=1;j<=N;++j){\n            if(doubling[i][j] == -1){\n                doubling[i+1][j] = -1;\n            }else{\n                doubling[i+1][j] = doubling[i][doubling[i][j]];\n            }\n        }\n    }\n}\n\nvoid dfs(int v, int& n){\n    start[v] = n++;\n    \n    for(int u : G[v]){\n        dfs(u, n);\n    }\n\n    friends[v] = n++;\n}\n\nvoid update(int l, int r){\n    while(l < r && l % B > 0){\n        ++parts[l];\n        ++l;\n    }\n\n    while(l < r && r % B > 0){\n        --r;\n        ++parts[r];\n    }\n\n    l /= B;\n    r /= B;\n\n    while(l < r){\n        ++buckets[l];\n        ++l;\n    }\n}\n\ninline int query2(int v){\n    return buckets[start[v] / B] + parts[start[v]];\n}\n\nint query(int v){\n    int lb = 0, ub = 100100, res = v;\n    \n    while(std::abs(ub - lb) > 1){\n        int mid = (lb + ub) / 2;\n        int x = v, y = mid, z = 0;\n\n        while(y > 0){\n            if(x != -1 && y % 2 == 1){\n                x = doubling[z][x];\n            }\n            ++z;\n            y >>= 1;\n        }\n        \n        if(x != -1 && query2(x) == query2(v)){\n            lb = mid;\n            res = x;\n        }else{\n            ub = mid;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> N >> Q;\n        if(N == 0){return 0;}\n\n        memset(doubling[0], -1, sizeof(doubling[0]));\n\n        for(int i=1;i<=N;++i){\n            G[i].clear();\n        }\n        \n        for(int i=0;i<N-1;++i){\n            int p;\n            std::cin >> p;\n\n            G[p].emplace_back(i+2);\n            doubling[0][i+2] = p;\n        }\n\n        makeDoubling();\n\n        // for(int i=0;i<16;++i){\n        //     printf(\"# %d\\n\", i);\n        //     for(int j=1;j<=N;++j){\n        //         printf(\"%d\\n\", doubling[i][j]);            \n        //     }\n        // }\n    \n        int ET_N = 0;\n        dfs(1, ET_N);\n\n        memset(buckets, 0, sizeof(buckets));\n        memset(parts, 0, sizeof(parts));\n        \n        update(start[1], friends[1]);\n    \n        // {\n        // int v = 3;\n        // update(start[v], friends[v]);\n        // }    \n        // for(int v = 1;v<=N;++v){\n        //     int q = query(v);\n        //     printf(\"%d\\n\", q);\n        // }\n        // exit(0);\n        \n        ll sum = 0;\n        for(int i=0;i<Q;++i){\n            std::string q;\n            int v;\n            std::cin >> q >> v;\n\n            if(q[0] == 'M'){\n                update(start[v], friends[v]);\n            }else{\n                sum += query(v);\n                // printf(\"%d\\n\", query(v));\n            }\n        }\n\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tconst int N;\n\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tint groups_;\n\tstd::vector< int > sizes;\n\npublic:\n\tUnionFind( int n ) : N( n ), parent( N ), rank( N, 0 ), groups_( N ), sizes( N, 1 )\n\t{\n\t\tstd::iota( parent.begin(), parent.end(), 0 );\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tbool unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t\tsizes[y] += sizes[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tsizes[x] += sizes[y];\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\t++rank[x];\n\t\t\t}\n\t\t}\n\n\t\t--groups_;\n\t\treturn true;\n\t}\n\n\tint groups() const\n\t{\n\t\treturn groups_;\n\t}\n\n\tint groupSize( const int x )\n\t{\n\t\treturn sizes[ find( x ) ];\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n// groups()\n// groupSize( x )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, Q; scanf( \"%d%d\", &N, &Q ) && ( N | Q ); )\n\t{\n\t\tVI parents( N, -1 );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tscanf( \"%d\", &parents[i] );\n\t\t\t--parents[i];\n\t\t}\n\t\tVT( char ) types( Q );\n\t\tVI vs( Q );\n\t\tREP( i, Q )\n\t\t{\n\t\t\tscanf( \" %c%d\", &types[i], &vs[i] );\n\t\t\t--vs[i];\n\t\t}\n\t\t// end of input\n\n\t\tVI marked( N );\n\t\tmarked[0] = 1;\n\t\tREP( i, Q )\n\t\t{\n\t\t\tif ( types[i] == 'M' )\n\t\t\t{\n\t\t\t\tmarked[ vs[i] ] = 1;\n\t\t\t}\n\t\t}\n\t\tREP( i, N )\n\t\t{\n\t\t\tif ( marked[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttypes.PB( 'M' );\n\t\t\tvs.PB( i );\n\t\t}\n\n\t\tVI answers( N );\n\t\tiota( ALL( answers ), 1 );\n\t\tUnionFind uf( N );\n\t\tLL res = 0;\n\t\tfor ( int i = SZ( types ) - 1; 0 <= i; --i )\n\t\t{\n\t\t\tconst char T = types[i];\n\t\t\tconst int v = vs[i];\n\n\t\t\tif ( T == 'M' )\n\t\t\t{\n\t\t\t\tconst int na = answers[ parents[v] ];\n\t\t\t\tuf.unite( v, parents[v] );\n\t\t\t\tanswers[ uf.find( v ) ] = na;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += answers[ uf.find( v ) ];\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%lld\\n\", res );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vl =vector<ll>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define all(a) a.begin(),a.end()\nstruct UnionFind{\n    vl par,rank;\n    UnionFind(int x){par.resize(x); iota(all(par),0); rank.resize(x,0);}\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x]=find(par[x]);\n    }\n    void unite(int x, int y){ // xにyをつなぐ\n        if(same(x,y))return;\n        x=find(x); \n        par[y]=x;\n    }\n    bool same(int x, int y){\n        return find(x)==find(y);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,q;\n    while(cin>>n>>q, n){\n        vl p(n,0);\n        rep(i,n-1){cin>>p[i+1];p[i+1]--;}\n        vector<char> type(q);\n        vl query(q);\n\n        vl marked(n,0);\n        marked[0]=1;\n        rep(i,q){\n            char c; ll num;\n            cin>>c>>num;\n            type[i]=c;\n            query[i]=num-1;\n            if(c=='M'){\n                marked[query[i]]++;\n            }\n        }\n        \n        UnionFind uf(n);\n        rep(i,n)if(marked[i]==0){\n            uf.unite(p[i], i);\n        }\n\n        ll ans=0;\n        for(ll i=q-1; i>=0;i--){\n            if(type[i]=='M'){\n                marked[query[i]]--;\n                if(marked[query[i]]==0){\n                    uf.unite(p[query[i]], query[i]);\n                }\n            }else{\n                ans += uf.find(query[i])+1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nchar Ope[MAX_N];\nint Openum[MAX_N], Marked[MAX_N];\nvector<int> child[MAX_N];\n\nvoid mark(int x, int num) {\n  if(Marked[x] == x || Marked[x] == num) return;\n  Marked[x] = num;\n  for(int i = 0; i < child[x].size(); i++){\n    mark(child[x][i], num);\n  }\n}\n\nvoid solve() {\n  int ans = 0;\n  for(int i = 0; i < N; i++){\n    Marked[i] = 1;\n  }\n  for(int i = 0; i < Q; i++){\n    char ope = Ope[i];\n    int num = Openum[i];\n    if(ope == 'M') mark(num, num);\n    else if(ope == 'Q') ans += Marked[num];\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 0; i <= N; i++) child[i].clear();\n    for(int i = 2; i <= N; i++){\n      int par;\n      scanf(\"%d\", &par);\n      child[par].push_back(i);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define RG register ll\n#define rep(i,a,b)\tfor(RG i=a;i<=b;++i)\n#define per(i,a,b)\tfor(RG i=a;i>=b;--i)\n#define ll long long\n#define inf (1<<29)\n#define maxn 100005\nusing namespace std;\nll n,T,x,cnt,tim,ans;\nll fa[maxn],tag[maxn],qa[maxn],qb[maxn];\ninline ll read()\n{\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nll find(ll x)\n{\n\treturn tag[x]<tim?x:fa[x]=find(fa[x]);\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tn=read(),T=read();\n\t\tif(n==0&&T==0)\treturn 0;\n\t\tans=cnt=0;\n\t\trep(i,2,n)\tfa[i]=read(),tag[i]=i+n;\n\t\tchar s[5];\n\t\trep(i,1,T)\n\t\t{\n\t\t\tscanf(\"%s\",s);x=read();\n\t\t\tif(s[0]=='M')\n\t\t\t\ttag[x]=min(tag[x],i);\n\t\t\telse\n\t\t\t\tqa[++cnt]=x,qb[cnt]=i;\n\t\t}\n\t\tper(i,cnt,1)\n\t\t{\n\t\t\ttim=qb[i];\n\t\t\tans+=find(qa[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> to;\n\tUnionFind(int size) : data(size, -1), to(size,-1) {\n\t\trep(i, size)to[i] = i;\n\t}\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tvoid setTo(int x, int to) {\n\t\tthis->to[root(x)] = to;\n\t}\n\tint findTo(int x) {\n\t\treturn to[root(x)];\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tuf.unionSet(e[j].m, e[e[j].p].m);\n\t\t\t\t\tif (e[j].m == uf.findTo(e[j].m)) {\n\t\t\t\t\t\tuf.setTo(e[j].m, e[e[j].p].m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findTo(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss;\n\nstruct Node{\n\tbool isMarked;\n\tint marked_time;\n};\n\nstruct Query{\n\tQuery(int arg_query_time,int arg_value){\n\t\tquery_time = arg_query_time;\n\t\tvalue = arg_value;\n\t}\n\tint query_time,value;\n};\n\nNode*info;\n\nint get_marked_boss(int id,int query_time){\n\n\tif(info[id].isMarked == true && info[id].marked_time < query_time){\n\t\treturn id;\n\t}else{\n\t\treturn marked_boss[id] = get_marked_boss(marked_boss[id],query_time);\n\t}\n}\n\n\nint main(){\n\n\tint Q,value,tmp;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\tinfo = (Node*)malloc(sizeof(Node)*(100001));\n\n\tstack<Query> S;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tinfo[i].isMarked = false;\n\t\t\tinfo[i].marked_time = BIG_NUM;\n\t\t}\n\n\t\tmarked_boss[1] = 1;\n\t\tinfo[1].isMarked = true;\n\t\tinfo[1].marked_time = 0;\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tmarked_boss[i] = value;\n\t\t}\n\n\t\tfor(int time = 1; time <= Q; time++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){\n\t\t\t\tS.push(Query(time,value));\n\t\t\t}else{\n\t\t\t\tinfo[value].isMarked = true;\n\t\t\t\tinfo[value].marked_time = min(info[value].marked_time,time);\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\n\t\twhile(!S.empty()){\n\t\t\ttmp = get_marked_boss(S.top().value,S.top().query_time);\n\t\t\tans += tmp;\n\t\t\tS.pop();\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\n\n//&#36755;入\nint N, Q;\n\nint par[MAX_N + 1];\t\t\t\t//父&#32467;点\nbool marked[MAX_N + 1];\t\t\t//&#26631;&#35760;&#32467;点\n\nvoid init(){\n\t//初始化\n\tpar[1] = 1;\n\tmemset(marked, 0, sizeof(marked));\n\tmarked[1] = true;\n\tfor(int i = 2; i <= N; i ++)\n\t\tscanf(\"%d\", &par[i]);\n}\n\nint find(int x){\n\t//找到最近被&#26631;&#35760;的父&#32467;点\n\tif(marked[x])return x;\n\telse return find(par[x]);\n}\n\nvoid solve(){\n\tlong long ans = 0;\n\tfor(int i = 0; i < Q; i ++){\n\t\tgetchar();\n\t\tchar c;\n\t\tint v;\n\t\tscanf(\"%c %d\", &c, &v);\n\t\tif(c == 'M'){\n\t\t\tmarked[v] = true;\n\t\t}\n\t\telse{\n\t\t\tans += find(v);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main(int argc, char const *argv[]){\n\n\twhile(scanf(\"%d %d\", &N, &Q)){\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tinit();\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct UF\n{\n\tvector<ll> par; // ???\n\t// ?????????\n\tUF(int n):par(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t// ??¨??????????±???????\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// x??¨y????±??????????????????????\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\t// ??¨??????????????????????????£??¨??????????????????\n\t\tpar[x] = y;\n\t}\n\t// x??¨y?????????????????????true\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct node\n{\n\tint par;\n\tvector<int> chi;\n};\n\n\nint main()\n{\n\tint n,q;\n\twhile(cin >> n >> q,n|q)\n\t{\n\t\tbool me[100100] = {};\n\t\tUF uf(n+1);\n\t\t\n\t\tvector<node> v(n+1);\n\t\tv[1].par = 1;me[1] = true;\n\t\t\n\t\t\n\t\tREP(i,n-1)\n\t\t{\n\t\t\tint tmp;cin >> tmp;\n\t\t\tv[tmp].chi.PB(i+2);\n\t\t\tv[i+2].par = tmp;\n\t\t}\n\t\t\n\t\tvector<pair<char,int> > p;\n\t\t\n\t\tREP(i,q)\n\t\t{\n\t\t\tchar c;int num;\n\t\t\tcin >> c >> num;\n\t\t\tif(c == 'M')\n\t\t\t{\n\t\t\t\tif(me[num])continue;\n\t\t\t\tme[num] = true;\n\t\t\t}\n\t\t\tp.PB(MP(c,num));\n\t\t}\n\t\t\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tif(me[i])\n\t\t\t{\n\t\t\t\tqueue<int> Q;\n\t\t\t\tQ.push(i);\n\t\t\t\twhile(!Q.empty())\n\t\t\t\t{\n\t\t\t\t\tint tmp = Q.front();Q.pop();\n\t\t\t\t\t\n\t\t\t\t\tREP(j,v[tmp].chi.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(me[v[tmp].chi[j]])continue;\n\t\t\t\t\t\tuf.unite(v[tmp].chi[j],i);\n\t\t\t\t\t\tQ.push(v[tmp].chi[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tll ans = 0;\n\t\t\n\t\tfor(int i = p.size()-1;i >= 0;--i)\n\t\t{\n\t\t\tif(p[i].FI == 'Q')\n\t\t\t{\n\t\t\t\tans += uf.find(p[i].SE);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuf.unite(p[i].SE,v[p[i].SE].par);\n\t\t\t}\n\t\t}\n\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\nusing namespace std;\n\n#define MAX_N 100002\n\n/* union find */\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める(あえて根の張りなおしをしない)\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    if(rank[x] < rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\nint N,Q, marked[MAX_N];\n\nint find_nearest_idx(int index) {\n    if(marked[index]) return index;\n    return find_nearest_idx(par[index]);\n}\n\nmain() {\n    while(1) {\n        scanf(\"%d %d\",&N,&Q);\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        init(N+2);\n        \n        marked[1] = 1; // node 1 is already marked \n        for(int i=2;i<=N;i++) {\n            int d;\n            scanf(\"%d\", &d);\n            par[i] = d; // parent of i is d\n            //unite(i,d);\n        }\n\n        // Question\n        int ans = 0;\n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            //scanf(\"%c %d\", &op, &index);\n            if(op == 'Q')\n                ans += find_nearest_idx(par[index]);\n            else if(op == 'M')\n                marked[index] = 1;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <limits>\n\ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n\n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n\ntemplate <typename Weight>\nstruct edge {\n  using value_type = Weight;\n  size_t src, dst;\n  value_type cost;\n\n  edge(size_t src, size_t dst, value_type cost = 1):\n    src(src), dst(dst), cost(cost)\n  {}\n\n  bool operator <(edge<value_type> const& rhs) const {\n    if (cost != rhs.cost) return cost < rhs.cost;\n    if (src != rhs.src) return src < rhs.src;\n    return dst < rhs.dst;\n  }\n};\n\ntemplate <typename Weight>\nstruct graph: public std::vector<std::vector<edge<Weight>>> {\n  using value_type = Weight;\n  graph(size_t n): std::vector<std::vector<edge<value_type>>>(n) {}\n\n  void connect_with(size_t src, size_t dst, value_type cost = 1) {\n    (*this)[src].emplace_back(src, dst, cost);\n    (*this)[dst].emplace_back(dst, src, cost);\n  }\n};\n\ntemplate <typename Tp>\nstd::array<std::vector<size_t>, 2> euler_tour(graph<Tp> const& g, size_t s = 0) {\n  std::array<std::vector<size_t>, 2> res;\n  res[0] = res[1] = std::vector<size_t>(g.size());\n  size_t j = 0;\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    res[0][i] = j++;\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      dfs(e.dst, i);\n    }\n    res[1][i] = j++;\n  })(s, -1);\n  return res;\n}\n\ntemplate <typename Tp>\nstd::vector<size_t> depth(graph<Tp> const& g, size_t s = 0) {\n  std::vector<size_t> res(g.size());\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      res[e.dst] = res[e.src] + 1;\n      dfs(e.dst, e.src);\n    }\n  })(s, -1);\n  return res;\n}\n\ntemplate <\n  typename Monoid,\n  typename Container = std::vector<typename Monoid::first_type>,\n  typename SubContainer = std::vector<typename Monoid::second_type>\n>\nclass segment_tree {\npublic:\n  using first_type = typename Monoid::first_type;\n  using second_type = typename Monoid::second_type;\n  using value_type = first_type;\n  using binary_operation = typename Monoid::binary_operation;\n  using external_binary_operation = typename Monoid::external_binary_operation;\n  using merge_operation = typename Monoid::merge_operation;\n  using container = Container;\n  using sub_container = SubContainer;\n\nprivate:\n  size_t M_base_size;\n  binary_operation M_op1;\n  external_binary_operation M_op2;\n  merge_operation M_op3;\n  container M_c;\n  sub_container M_d;  // deferred\n\n  void M_build(size_t i) {\n    while (i > 1) {\n      i >>= 1;\n      M_c[i] = M_op2(M_op1(M_c[i<<1|0], M_c[i<<1|1]), M_d[i]);\n    }\n  }\n\n  void M_resolve(size_t i) {\n    size_t h = (sizeof(size_t) * CHAR_BIT) - __builtin_clzll(M_base_size*2);\n    for (size_t s = h; s > 0; --s) {\n      size_t p = i >> s;\n      if (M_d[p] != M_op3.identity) {\n        M_apply(p<<1|0, M_d[p]);\n        M_apply(p<<1|1, M_d[p]);\n        M_d[p] = M_op3.identity;\n      }\n    }\n  }\n\n  void M_apply(size_t i, second_type const& x) {\n    M_c[i] = M_op2(M_c[i], x);\n    if (i < M_base_size) M_d[i] = M_op3(M_d[i], x);\n  }\n\npublic:\n  segment_tree() = default;\n  segment_tree(segment_tree const&) = default;\n  segment_tree(segment_tree&&) = default;\n\n  segment_tree(size_t n, first_type const& x = binary_operation().identity):\n    M_base_size(n),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(n+n, x), M_d(n, M_op3.identity)\n  {\n    for (size_t i = n; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n\n  template <typename InputIt>\n  segment_tree(InputIt first, InputIt last):\n    M_base_size(std::distance(first, last)),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(M_base_size*2), M_d(M_base_size, M_op3.identity)\n  {\n    for (size_t i = M_base_size; first != last; ++i)\n      M_c[i] = *first++;\n    for (size_t i = M_base_size; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n\n  segment_tree& operator =(segment_tree const&) = default;\n  segment_tree& operator =(segment_tree&&) = default;\n\n  void modify(size_t l, size_t r, second_type const& x) {\n    l += M_base_size;\n    r += M_base_size;\n    size_t l0 = l;\n    size_t r0 = r;\n    while (l < r) {\n      if (l & 1) M_apply(l++, x);\n      if (r & 1) M_apply(--r, x);\n      l >>= 1;\n      r >>= 1;\n    }\n    M_build(l0);\n    M_build(r0-1);\n  }\n\n  first_type accumulate(size_t l, size_t r) {\n    first_type resl = M_op1.identity;\n    first_type resr = resl;\n    l += M_base_size;\n    r += M_base_size;\n    M_resolve(l);\n    M_resolve(r-1);\n    while (l < r) {\n      if (l & 1) resl = M_op1(resl, M_c[l++]);\n      if (r & 1) resr = M_op1(M_c[--r], resr);\n      l >>= 1;\n      r >>= 1;\n    }\n    return M_op1(resl, resr);\n  }\n\n  first_type operator [](size_t i) {\n    i += M_base_size;\n    M_resolve(i);\n    i >>= __builtin_ctzll(i);\n    return M_c[i];\n  }\n};\n\nnamespace std {\n  template <typename T1, typename T2>\n  struct numeric_limits<std::pair<T1, T2>> {\n    static std::pair<T1, T2> constexpr min() {\n      return std::make_pair(std::numeric_limits<T1>::min(), std::numeric_limits<T2>::min());\n    }\n  };\n}\n\ntemplate <typename Tp>\nstruct range_max_range_max {\n  using first_type = Tp;\n  using second_type = Tp;\n  struct binary_operation {\n    first_type identity = std::numeric_limits<Tp>::min();\n    first_type operator ()(first_type const& x, first_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct external_binary_operation {\n    first_type operator ()(first_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct merge_operation {\n    second_type identity = std::numeric_limits<Tp>::min();\n    second_type operator ()(second_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n};\n\nint testcase_ends() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n  if (n == 0 && q == 0) return 1;\n\n  graph<int> g(n);\n  for (size_t i = 1; i < n; ++i) {\n    size_t p;\n    scanf(\"%zu\", &p);\n    --p;\n    g.connect_with(i, p);\n  }\n\n  auto d = depth(g);\n  auto et = euler_tour(g);\n\n  // for (size_t i = 0; i < n; ++i)\n  //   fprintf(stderr, \"%zu%c\", d[i], i+1<n? ' ':'\\n');\n  // for (size_t i = 0; i < n; ++i)\n  //   fprintf(stderr, \"(%zu-%zu)%c\", et[0][i], et[1][i], i+1<n? ' ':'\\n');\n\n  // {depth, nma}\n  segment_tree<range_max_range_max<std::pair<size_t, size_t>>> st(n+n, std::make_pair(0, 0));\n\n  size_t res = 0;\n  for (size_t i = 0; i < q; ++i) {\n    char t;\n    size_t v;\n    scanf(\" %c %zu\", &t, &v);\n    --v;\n\n    // for (size_t i = 0; i < n+n; ++i)\n    //   fprintf(stderr, \"(%zu:%zu)%c\", st[i].first, st[i].second, i+1<n+n? ' ':'\\n');\n\n    if (t == 'Q') {\n      res += st[et[0][v]].second+1;\n    } else if (t == 'M') {\n      st.modify(et[0][v], et[1][v], std::make_pair(d[v], v));\n    }\n  }\n\n  printf(\"%zu\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        } else {\n            g.addEdge(s, to);\n            make_dfs(to, g_, g, visited);\n        }\n    }\n}\n\nint main()\n{\n    // int cnt = 0;\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        vector<int> parent(N, 0);\n        for (int i = 1; i < N; i++) {\n            int from;\n            cin >> from;\n            from--;\n            parent[i] = from;\n            g_.addEdge(from, i);\n            g_.addEdge(i, from);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        make_dfs(0, g_, g, visited);\n\n\n        using P = pair<char, int>;\n        vector<P> query;\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = 0;\n        }\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            if (c == 'M') {\n                if (marked[n]) {\n                    continue;\n                }\n                comp[n] = n;\n                marked[n] = true;\n            }\n            query.push_back(make_pair(c, n));\n        }\n        // if (cnt < 4 or cnt >= 5) {\n        //     cnt++;\n        //     continue;\n        // }\n        // cnt++;\n\n        // show(g_.edge);\n        // show(g.edge);\n        // show(query);\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        long long sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n                const int s = q.second;\n                const int par = parent[s];\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 100000;\n\nint n, p;\nint pre[N+1];\n\nint find(int x)\n{\n    while (x != pre[x])\n        x = pre[x];\n    return x;\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &n, &p) != EOF) {\n        if (!n && !p) break;\n        pre[1] = 1;\n        for (int i = 2; i <= n; i ++)\n            scanf(\"%d\", &pre[i]);\n        long long sum = 0;\n        for (int i = 1; i <= p; i ++) {\n            char s[2];\n            int x;\n            scanf(\"%s%d\", s, &x);\n            if (s[0] == 'M')\n                pre[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint mark[MAX_N];\nint used[MAX_N];\nint par[MAX_N];\nint root;\nmap<int,vector<int> > child;\nvoid dfs(int start){\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++){\n        if(used[child[start][i]]==0) dfs(child[start][i]);\n    }\n}\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if(a=='0' and b==0)break;\n        if (a=='Q') {\n            //cout<<\"as\"<<mark[b-1]<<endl;\n            ans+=mark[b-1];\n            ans++;\n        }\n        else {\n            root=b-1;\n            dfs(b-1);\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define TEST 0\nint par[100001];\nbool marked[100001];\nint find_marked(int id)\n{\n    if(marked[id])return id;\n    return find_marked(par[id]);\n}\nint main(void)\n{\n    int n,q;\n    while(scanf(\"%d%d\",&n,&q)==2 && (n!=0 || q != 0))\n    {\n        par[1]=0;\n        marked[1]=true;\n        int sum=0;\n        for(int i=0;i<n-1;i++)\n        {\n            scanf(\"%d\",par + i+2);\n            marked[i+2]=false;\n        }\n        for(int j=0;j<q;j++)\n        {\n            char str[8];\n            int num;\n            scanf(\"\\n%[QM]%d\",str,&num);\n#if TEST\n            printf(\"%c:%d\\n\",str[0],num);\n#endif\n            switch(str[0])\n            {\n            case 'Q':\n                    sum+=find_marked(num);\n                    break;\n            case 'M':\n                    marked[num]=true;\n                    break;\n            }\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[100005];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tfa[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')fa[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (fa[a] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 18;\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=0,dat[i].second=0;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n    dat[k]=max(dat[k],p);\n  }else{\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  }\n}\n\nvector<int> G[MAX_N];\nint st[MAX_N],en[MAX_N],de[MAX_N],po[MAX_N];\nint pos;\nvoid dfs(int v,int p=-1,int d=0){\n  de[v]=d;\n  po[v]=pos;\n  st[v]=pos++;\n  for(auto i:G[v]) if(i!=p) dfs(i,v,d+1);\n  en[v]=pos;\n}\n\nvoid update(int k,P p){\n  update(st[k],en[k],p);\n}\n\nsigned main(){\n  int _n,q;\n  while(cin>>_n>>q,_n||q){\n    for(int i=0;i<MAX_N;i++) G[i].clear();\n    init(_n+1);\n    for(int i=1;i<_n;i++) {\n      int p;\n      cin>>p;\n      p--;\n      G[p].push_back(i);\n      G[i].push_back(p);\n    }\n    pos=0;dfs(0);\n    int ans=0;\n    for(int i=0;i<q;i++){\n      char c;\n      int u;\n      cin>>c>>u;\n      u--;\n      if(c=='M') update(u,P(de[u],u));\n      else ans+=query(po[u])+1;\n      //for(int j=0;j<_n;j++) cout<<query(po[j])<<\" \\n\"[j==_n-1];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define val first\n#define idx second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vp;\n\n//Segment Tree\nclass SegmentTree{\n  int n;\n  vp node;\npublic:\n  SegmentTree(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    node = vp(2*n, pii(0,0));\n  }\n\n  void update_range(int a,int b,pii v,int k=0,int l=0,int r=0){\n    //cerr << l << \" \" << r << \" \" << node[k].first << \" \" << v.first << endl;\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return;\n    if(a<=l && r<=b){\n      //cerr << k << \" \" << node[k].first << \" \" << v.first << endl;\n      if(node[k]<v)node[k] = v;\n      return;\n    }\n    update_range(a,b,v,2*k+1,l,(l+r)/2);\n    update_range(a,b,v,2*k+2,(l+r)/2,r);\n  }\n\n  pii is_val(int k){\n    k += n-1;\n//cout << k << \" \" << node[k].first << \" \" << node[k].second << endl;\n    pii res = node[k];\n    while(k>0){\n      k = (k-1)/2;\n//cout << k << \" \" << node[k].first << \" \" << node[k].second << endl;\n      res = max(res,node[k]);\n    }\n    return res;\n  }\n};\n\nvoid dfs(int v, int d, vi &level, vi &tour, vp &interval,\n\t const vector<vi> &tree){\n  interval[v].first = tour.size();\n  tour.push_back(v);\n  level[v] = d;\n\n  for(int child : tree[v]){\n    dfs(child, d+1, level, tour, interval, tree);\n  }\n\n  tour.push_back(v);\n  interval[v].second = tour.size();\n}\n\nint main(){\n  int n,q,v;\n  char qtype;\n\n  while(scanf(\"%d%d\",&n,&q),n){\n    vector<vi> tree(n,vi());\n\n    rep(i,n-1){\n      scanf(\"%d\",&v); v--;\n      tree[v].push_back(i+1);\n    }\n\n    vi level(n,0), tour;\n    vp interval(n);\n    dfs(0,0,level,tour,interval,tree);\n    /*\n    rep(i,level.size())cout << level[i] << \" \"; cout << endl;\n    rep(i,tour.size())cout << tour[i] << \" \"; cout << endl;\n    rep(i,interval.size())cout << interval[i].first << \" \" << interval[i].second << endl;\n    */\n\n    SegmentTree st(tour.size());\n    st.update_range(0,2*n,pii(0,0));\n\n    int ans = 0;\n    rep(i,q){\n      cin >> qtype >> v; v--;\n      if(qtype == 'M'){\n\tst.update_range(interval[v].first, interval[v].second, pii(level[v], v));\n      }else{\n\tpii tmp = st.is_val(interval[v].first);\n\t//cout << tmp.second << endl;\n\tans += tmp.second + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define M 100005\nint n,q;\nbool mark[M];\nstruct node {\n\tint tp,u;\n} Q[M];\nlong long ans;\nstruct together {\n\tint fa,sum;\n} A[M];\nint Find(int x) {\n\tif(mark[A[x].sum])return A[x].fa;\n\tint f=A[x].fa;\n\tA[x].fa=Find(f);\n\tA[x].sum=A[f].sum;\n\treturn A[x].fa;\n}\nint main() {\n\tint x,u;\n\tchar op[5];\n\twhile(scanf(\"%d %d\",&n,&q),n||q) {\n\t\tA[1].fa=1,A[1].sum=1;\n\t\tmark[1]=1;\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tscanf(\"%d\",&x);\n\t\t\tA[i].fa=x;\n\t\t\tA[i].sum=0;\n\t\t\tmark[i]=0;\n\t\t}\n\t\tfor(int i=1; i<=q; i++) {\n\t\t\tscanf(\"%s %d\",op,&Q[i].u);\n\t\t\tif(op[0]=='M') {\n\t\t\t\tQ[i].tp=1;\n\t\t\t\tmark[Q[i].u]=1;\n\t\t\t\tA[Q[i].u].sum=Q[i].u;\n\t\t\t} else Q[i].tp=2;\n\t\t}\n\t\tans=0;\n\t\tfor(int i=q; i>=1; i--) {\n\t\t\t//printf(\"id=%d\\n\",i);\n\t\t\tif(Q[i].tp==1) {\n\t\t\t\tmark[Q[i].u]=0;\n\t\t\t} else {\n\t\t\t\tFind(Q[i].u);\n\t\t\t\tans+=A[Q[i].u].sum;\n\t\t\t\t//printf(\"sum=%d\\n\",A[Q[i].u].sum);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int maxn=100000+5;\nint par[maxn]={};\nint n,q;\nint vis[maxn]={};\nint fin(int x){\n    return x==par[x]?par[x]:fin(par[x]);\n}\nint main()\n{\n    while(scanf(\"%d%d\",&n,&q)==2 && n &&q){\n        long long int ans=0;\n        for(int i=0;i<=n;i++) par[i]=i,vis[i]=0;\n        for(int i=2;i<=n;i++){\n            int x;\n            scanf(\"%d\",&x);\n            par[i]=x;\n        }\n        while(q--){\n            char c;\n            int x;\n            scanf(\"\\n%c%d\",&c,&x);\n            if(c=='M') par[x]=x;\n            else ans+=fin(x);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nint sum;\nint find(int x,int flag){\n    if(flag)    return 0;\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                if(vis[t])  sum+=t;\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n//\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2*k+1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nvoid dfs(const int now, vector<pair<int, int>>&ps,vector<int>&ids,int&id,const vector<vector<int>>&edges) {\n\tids[now] = id;\n\tps[now].first = id;\n\tid++;\n\tfor (auto e : edges[now]) {\n\t\tdfs(e, ps, ids, id, edges);\n\t}\n\tps[now].second = id - 1;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i] = NODE();\n\t\t}\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tedges[a - 1].push_back(i + 1);\n\t\t}\n\t\tvector<pair<int, int>>ps(N);\n\t\tvector<int>ids(N);\n\t\tvector<int>revids(N);\n\t\tint id = 0;\n\t\tdfs(0, ps, ids, id, edges);\n\t\tfor (int i = 0; i < ids.size(); ++i) {\n\t\t\trevids[ids[i]] = i;\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'Q') {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tint aid = ids[a];\n\t\t\t\tint ans = get(aid, aid);\n\t\t\t\tans = revids[ans];\n\t\t\t\tsum += ans+1;\n\t\t\t\t//cout << ans+1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tupdate(ps[a].first, ps[a].second,ids[a]);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool vis[100000];\nint qtype[100000], vertex[100000], marked[100000];\n\nint par[100000], pp[100000];\n\nvoid init()\n{\n\tfor (int i = 0; i < 100000; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return (x);\n\treturn (par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x != y){\n\t\tpar[y] = x;\n\t}\n}\n\nvoid dfs(int v, int p, int m)\n{\n\tint nm = m;\n\tif (marked[v]) nm = v;\n\tpp[v] = p;\n\t\n\tmerge(nm, v);\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tdfs(G[v][i], v, nm);\n\t}\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\twhile (scanf(\"%d %d\", &N, &Q) && N){\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\t\n\t\tfor (int i = 1; i < N; i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tG[--v].push_back(i);\n\t\t}\n\t\t\n\t\tinit();\n\t\t\n\t\tmemset(marked, 0, sizeof(marked));\n\t\tmarked[0]++;\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tchar t[10];\n\t\t\tscanf(\"%s %d\", t, vertex + i);\n\t\t\tqtype[i] = (t[0] == 'Q');\n\t\t\t--vertex[i];\n\t\t\tif (!qtype[i]) ++marked[vertex[i]];\n\t\t}\n\t\t\n\t\tdfs(0, -1, -1);\n\t\t\n\t\tlong long int ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--){\n\t\t\tif (qtype[i]){\n\t\t\t\tans += find(vertex[i]) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t--marked[vertex[i]];\n\t\t\t\tif (!marked[vertex[i]]) merge(pp[vertex[i]], vertex[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nchar ch[MAX_Q+1];\nint num[MAX_Q+1];\nint N, Q;\n\nint main(){\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(int i=1; i<=N; i++) scanf(\"%d\", &par[i]);\n        getchar();\n        for(int i=1; i<=Q; i++) {scanf(\"%c \", &ch[i]); scanf(\"%d\", &num[i]); getchar();}\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n            if(ch[i]=='M'){\n                vis[num[i]]=1;\n            }\n            else if(ch[i]=='Q'){\n                int cur=num[i];\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> children[100010];\npriority_queue<int> query[100010];\nint markedAt[100010];\nusing ll = long long;\n\nll pull(int v) {\n    ll res = 0;\n    for (int c : children[v]) {\n        res += pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            query[v].push(query[c].top());\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        res += v + 1;\n        query[v].pop();\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(markedAt, markedAt+n, 1e9);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        cout << pull(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: 王文宇\n* @Date:   2018-03-18 23:31:38\n* @Last Modified by:   王文宇\n* @Last Modified time: 2018-03-18 23:38:56\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define _for(i,a,b) for(int i=a;i<=b;i++)\nconst int maxn = 100007;\nint fa[maxn],vis[maxn],n,m;\nint main(int argc, char const *argv[])\n{\n\twhile(cin>>n>>m)\n\t{\n\t\tlong long sum = 0;\n\t\tif(n==0&&m==0)break;\t\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfa[1]=1;\n\t\tvis[1]=1;\n\t\t_for(i,2,n)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tfa[i]=x;\n\t\t}\n\t\t_for(i,1,m)\n\t\t{\n\t\t\tchar s;\n\t\t\tint x;\n\t\t\tcin>>s>>x;\n\t\t\tif(s=='Q')\n\t\t\t{\n\t\t\t\tint k = x;\n\t\t\t\twhile(vis[k]!=1)\n\t\t\t\t{\n\t\t\t\t\tk=fa[k];\n\t\t\t\t}\n\t\t\t\tsum+=k;\n\t\t\t}\n\t\t\telse vis[x]=1;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 18;\n#define int long long\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=0;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n    dat[k]=max(dat[k],p);\n  }else{\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  }\n}\n\nvector<int> G[MAX_N];\nint st[MAX_N],en[MAX_N],de[MAX_N];\nint pos=0;\nvoid dfs(int v,int p=-1,int d=0){\n  de[v]=d;\n  st[v]=pos++;\n  for(auto i:G[v]) if(i!=p) dfs(i,v,d+1);\n  en[v]=pos;\n}\n\nvoid update(int k,P p){\n  update(st[k],en[k],p);\n}\n\nsigned main(){\n  int _n,q;\n  while(cin>>_n>>q,_n||q){\n    for(int i=0;i<MAX_N;i++) G[i].clear();\n    init(_n+1);\n    for(int i=1;i<_n;i++) {\n      int p;\n      cin>>p;\n      p--;\n      G[p].push_back(i);\n      G[i].push_back(p);\n    }\n    dfs(0);\n    int ans=0;\n    for(int i=0;i<q;i++){\n      char c;\n      int u;\n      cin>>c>>u;\n      u--;\n      if(c=='M') update(u,P(de[u],u));\n      else ans+=query(u)+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n//< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2 * k+1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl , vr);\n}\n\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root),cnum(V),place(V),id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v]+=dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v]+1;\n\t}\n\n\tvoid getid(const int v, const int p,int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tupdate(1, N, 0);\n\t\tvector<int>nums;\n\t\tnums.push_back(0);\n\t\tTree t(N,0);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tt.unite(a, i+1);\n\t\t}\n\t\tt.init();\n\t\tlong long int asum = 0;\n\t\twhile (Q--) {\n\t\t\tchar c;int  n;\n\t\t\tcin >> c >> n;\n\t\t\tconst int aplace = t.place[n-1];\n\t\t\tif (c == 'M') {\n\t\t\t\tupdate(aplace+1, aplace + t.cnum[n-1]+1, n-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans = get(aplace+1, aplace+1);\n\t\t\t\tasum += ans+1;\n\t\t\t\tcout << ans + 1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << asum << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\ntypedef pair<int,int> pii;\n\nint N,M;\nint res;\nint ans;\nvector<int> V[MAX_N];\nbool Mark[MAX_N];\n\nvoid dfs(int n){\n    if(res!=inf)return ;\n    if(Mark[n]==true)res=n;\n    else{\n        for(int i=0;i<V[n].size();++i){\n            dfs(V[n][i]);\n        }\n    }\n}\n\n\nsigned main(){\n    cin>>N>>M;\n    Mark[1]=true;\n    for(int i=2;i<=N;++i){\n        int v;\n        cin>>v;\n        V[i].PB(v);\n    }\n    ans=0;\n    for(int i=0;i<M;++i){\n        char que;\n        int k;\n        cin>>que;\n        cin>>k;\n        if(que =='M')Mark[k]=true;\n        else{\n            res=inf;\n            dfs(k);\n            if(res!=inf)ans+=res;\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstruct query {\n        char s;\n        int node;\n};\n\nstruct state {\n        int d;\n        int timing;\n        int node;\n        bool operator < (const state& r) const { return d < r.d; }\n        bool operator > (const state& r) const { return d > r.d; }\n};\n\nvector<int> depth;\nvector<vector<int> > g;\nvector<bool> used;\nvector<int> mark;\nvector<priority_queue<state>> st;\nvector<query> v;\n\nvoid depth_init_dfs(int s, int d) {\n        depth[s] = d;\n        for (auto v : g[s]) if (!used[v]) { \n                used[v] = true;\n                depth_init_dfs(v, d + 1);\n        }\n}\n\nvoid dfs(int s) {\n        if (mark[s] != -1) {\n                priority_queue<state> tmp;\n                tmp = st[s];\n                tmp.push({depth[s], mark[s], s + 1});\n                for (auto v : g[s]) if (!used[v]) {\n                        used[v] = true;\n                        st[v] = tmp;\n                        dfs(v);\n                }\n        } else {\n                for (auto v : g[s]) if (!used[v]) {\n                        used[v] = true;\n                        st[v] = st[s];\n                        dfs(v);\n                }\n        }\n}\n\nint main() {\n        int n, q;\n        cin >> n >> q;\n        v.clear();\n        v.resize(q);\n        g.clear();\n        g.resize(n);\n        rep(i, n - 1) {\n                int p;\n                cin >> p;\n                p --;\n                g[p].push_back(i + 1);\n        }\n        rep(i, q) {\n                cin >> v[i].s >> v[i].node;\n                v[i].node --;\n        }\n        depth.clear();\n        depth.resize(n);\n        used.clear();\n        used.resize(n, false);\n        used[0] = true;\n        depth_init_dfs(0, 0);\n        //rep(i, n) {\n        //        cout << depth[i] << ' ' << i << endl;\n        //}\n        mark.clear();\n        mark.resize(n, -1);\n        mark[0] = 0;\n        rep(i, q) {\n                if (v[i].s == 'M') {\n                        mark[v[i].node] = i + 1;\n                }\n        }\n        st.clear();\n        st.resize(n);\n        used.clear();\n        used.resize(n, false);\n        st[0].push({0, 0, 1});\n        dfs(0);\n        //rep(i, n) {\n        //        state s = st[i].top();\n        //        cout << s.d << ' ' << s.timing << ' ' << s.node << endl;\n        //}\n        int ans = 0;\n        for (int i = q - 1; i >= 0; i --) {\n                if (v[i].s == 'Q') {\n                        while (!st[v[i].node].empty()) {\n                                if (i < st[v[i].node].top().timing < i + 1) {\n                                        ans += st[v[i].node].top().node;\n                                        break;\n                                }\n                                st[v[i].node].pop();\n                        }\n                }\n        }\n        cout << ans << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100001;\n     \nint N, Q;\nlong long int ans;\nint par[MAX_N]; \nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint search(int x) {\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n  \nint main()\n{\n  marked[1] = true;\n  while(1){\n    int num;\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    ans = 0;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      par[i] = num;\n      marked[i] = false;\n    }\n    char ope;\n    for(int i = 0; i < Q; i++){\n      scanf(\" %c\", &ope);\n      scanf(\"%d\", &num);\n      if (ope == 'M') {\n        marked[num] = true;\n      }\n    \n      else if(ope == 'Q'){\n        ans += search(num);\n      }\n    } \n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nint main() {\n  int N, Q, sum = 0, ps[100001], qv[100000];\n  char qc[100000];\n  bool ms[100001];\n  for (;;) {\n    scanf(\"%d %d\\n\", &N, &Q);\n    if (!N && !Q) return 0;\n    for (int i = 1; i <= N; i++)\n      scanf(\"%d\\n\", &ps[i]);\n    fill(ms, ms+N+1, false);\n    ms[1] = true;\n    for (int i = 0; i < Q; i++) {\n      scanf(\"%c %d\\n\", &qc[i], &qv[i]);\n      if (qc[i] == 'M')\n        ms[qv[i]] = true;\n    }\n    for (int i = Q-1; i >= 0; i--)\n      if (qc[i] == 'M')\n        ms[qv[i]] = false;\n      else {\n        int v = qv[i];\n        while (!ms[v])\n          v = ps[v];\n        int p = v;\n        sum += p;\n        while (!ms[v]) {\n          int t = ps[v];\n          ps[v] = p;\n          v = t;\n        }\n      }\n    printf(\"%d\\n\", sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<bool, int>;\n\nstruct UnionFind {\n  vector<int> par;\n  UnionFind(int n) : par(n, -1) {}\n  int root(int x) { return (par[x] < 0) ? x : par[x] = root(par[x]); }\n  bool isSame(int x, int y) { return root(x) == root(y); }\n  void unite(int x, int y) {   // x is the ancestor of y\n    x = root(x);\n    y = root(y);\n    if (x == y) return;\n    par[x] += par[y];\n    par[y] = x;\n  }\n};\n\nint main() {\n  int n, q;\n  while (cin >> n >> q, n) {\n    vector<int> p(n);\n    for (int i = 1; i < n; i++) {\n      cin >> p[i], p[i]--;\n    }\n    UnionFind uf(n);\n    vector<bool> marked(n, false);\n    vector<P> op;\n    for (int i = 0; i < q; i++) {\n      char c;\n      int v;\n      cin >> c >> v, v--;\n      if (c == 'Q') {\n        op.push_back({0, v});\n      } else {\n        if (!marked[v]) op.push_back({1, v});\n        marked[v] = true;\n      }\n    }\n    marked[0] = true;\n    for (int i = 0; i < n; i++) {\n      if (!marked[i]) uf.unite(p[i], i);\n    }\n    ll ans = 0LL;\n    for (int i = op.size() - 1; i >= 0; i--) {\n      int v = op[i].second;\n      if (op[i].first) {\n        uf.unite(p[v], v);\n      } else {\n        ans += uf.root(v) + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nconstexpr int MAX_N = (int)1e5 + 1;\n\nint n, q;\nint p[MAX_N];\nbool isMarked[MAX_N];\n\nint find(int x) {\n\tif (isMarked[x])\n\t\treturn x;\n\treturn find(p[x]);\n}\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n >> q;\n\t\tif (n + q == 0)\n\t\t\tbreak;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t\tstd::cin >> p[i];\n\t\tstd::memset(isMarked, false, sizeof(isMarked));\n\t\tisMarked[1] = true;\n\t\tp[1] = 1;\n\t\tchar in;\n\t\tint tar, ans = 0;\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tstd::cin >> in >> tar;\n\t\t\tif (in == 'M')\n\t\t\t\tisMarked[tar] = true;\n\t\t\telse\n\t\t\t\tans += find(tar);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\n\nvector<int> mark_parent;\nvector<int> marked;\ngraph g;\n\n\nvoid walk_graph(int v, int mark_p) {\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p);\n    }\n}\n\n\nint find_mark_parent(int v) {\n    if (marked[v]){\n        // cout << endl;\n        return v;\n    }\n    // cout << v << \"->\";\n    return mark_parent[v] = find_mark_parent(mark_parent[v]);\n}\n\n\nlong long solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    mark_parent = vector<int>(N, 0);\n    marked = vector<int>(N, 0);\n\n    g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            ++marked[q.second];\n        }\n    }\n\n    walk_graph(0, 0);\n    \n    long long ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n\n        if (ch == 'Q') {\n            int ind = find_mark_parent(v) + 1;\n            ret += ind;\n        }\n\n        if (ch == 'M') {\n            --marked[v];\n        }\n    }\n\n    return ret;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 100001\nusing namespace std;\ntypedef long long ll;\nint func(int);\nint n,q,e,k;\nbool marked[N];\nvector<int> edge[N];\n\nint main(){\n  char c;\n  ll cnt;\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n-1;i++) cin>>e,edge[i+2].push_back(e);\n    for(int i=0;i<n-1;i++) marked[i+2]=false;\n    marked[1]=true;\n    cnt=0;\n    while(q--){\n      cin>>c>>k;\n      if(c=='M') marked[k]=true;\n      else cnt+=func(k);\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}\n\nint func(int x){\n  if(marked[x]) return x;\n  return func(edge[x][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 100000 + 10;\n\nvector<int> V[N];\nint scope[N][2];\nint stree[N*6];\nbool marked[N];\nint cnt, r;\n\nvoid dfs(int u)\n{\n\tint i;\n\tscope[u][0] = cnt ++;\n\tfor (i=0; i<V[u].size(); i++) dfs(V[u][i]);\n\tscope[u][1] = cnt ++;\n}\n\nvoid mark(int index, int begin, int end, int left, int right, int x)\n{\n\tint mid;\n\tif (left <= begin && right >= end) \n\t{\n\t\tstree[index] = x;\n\t\treturn;\n\t}\n\tmid = (begin + end) / 2;\n\tif (right <= mid) mark(index * 2, begin, mid, left, right, x);\n\telse if (left > mid) mark(index * 2 + 1, mid + 1, end, left, right, x);\n\telse\n\t{\n\t\tmark(index * 2, begin, mid, left, mid, x);\n\t\tmark(index * 2 + 1, mid + 1, end, mid + 1, right, x);\n\t}\n}\n\nint query(int index, int begin, int end, int x)\n{\n\tint mid;\n\tif (stree[index]) r = stree[index];\n\tif (begin == end) return r;\n\tmid = (begin + end) / 2;\n\tif (x <= mid) return query(index * 2, begin, mid, x);\n\telse return query(index * 2 + 1, mid + 1, end, x);\n}\n\nint main()\n{\n\tlli res;\n\tint n, q, p, u, i;\n\tchar cmd[5];\n\twhile (scanf(\"%d %d\", &n, &q), n > 0)\n\t{\n\t\tfor (i=1; i<=n; i++) marked[i] = false;\n\t\tmarked[1] = true;\n\t\tmemset(stree, 0, sizeof(stree));\n\t\tstree[1] = 1;\n\t\tfor (i=2; i<=n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &p);\n\t\t\tV[p].push_back(i);\n\t\t}\n\t\tcnt = 0;\n\t\tdfs(1);\n\t\tres = 0;\n\t\twhile (q --)\n\t\t{\n\t\t\tscanf(\"%s\", cmd);\n\t\t\tif (cmd[0] == 'M')\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &u);\n\t\t\t\tif (marked[u]) continue;\n\t\t\t\tmark(1, 0, n * 2 - 1, scope[u][0], scope[u][1], u);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &u);\n\t\t\t\tr = 0;\n\t\t\t\tres += query(1, 0, n * 2 - 1, scope[u][0]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[200000],euler;\nint dbl[200000][30],ff[200000],ss[200000],bit[400001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tassert(v!=0);\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<long long int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<long long int> sizes;\n\n  UnionFind(long long int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    rep(i,n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  long long int find(long long int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(long long int x, long long int y) {\n    // ?????????????????????????????????\n    x = find(x);\n    y = find(y);\n\n    // ??¢???????????¨????±?????????????????????????????????????\n    if (x == y) return;\n\n    // x?????¨???y?????¨????????§???????????????????????????\n    if (x > y) swap(x, y);\n\n    // x???y??????????????????????????£?????????\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]????????????????????¨???????????§0?????\\????????????????????????\n  }\n\n  // 2???????????????x, y????±?????????¨???????????????true?????????\n  bool same(long long int x, long long int y) {\n    return find(x) == find(y);\n  }\n\n  // ?????????x?????????????????¨?????§???????????????\n  int size(long long int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unite(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unite(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.find(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* global variables */\n\nint n, q;\nint prnts[MAX_N + 1];\nbool marked[MAX_N + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> q;\n    if (n == 0) break;\n\n    marked[1] = true;\n    prnts[1] = 0;\n    for (int i = 2; i <= n; i++) {\n      cin >> prnts[i];\n      marked[i] = false;\n    }\n\n    ll sum = 0;\n    \n    for (int qi = 0; qi < q; qi++) {\n      char op;\n      int i;\n      cin >> op >> i;\n\n      if (op == 'M') {\n\tmarked[i] = true;\n      }\n      else {\n\twhile (! marked[i]) i = prnts[i];\n\tsum += i;\n      }\n    }\n\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// input\ntemplate<typename T>\nvoid input(T& a) { cin >> a; }\ntemplate<typename T,typename... Ts>\nvoid input(T& a,Ts&... ts) {\n    input<T>(a);\n    input<T>(ts...);\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) {\n        par.resize(n);\n        sz.resize(n, 1);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        // if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n        return true;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\n\nint main()\n{\n    while (true) {\n        int n, Q; cin >> n >> Q;\n        if (n == 0 && Q == 0) {\n            break;\n        }\n        vector<int> p(n, -1);\n        for (int i = 1; i < n; ++i) {\n            cin >> p[i]; --p[i];\n        }\n\n        auto uf = UnionFind(n);\n\n        vector<char> t(Q);\n        vector<int> v(Q);\n        vector<bool> used(n, false);\n        used[0] = true;\n        for (int i = 0; i < Q; ++i) {\n            cin >> t[i] >> v[i]; --v[i];\n            if (t[i] == 'M') {\n                if (used[v[i]]) {\n                    v[i] = -1;\n                } else {\n                    used[v[i]] = true;\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (!used[i]) {\n                uf.merge(p[i], i);\n            }\n        }\n\n        LL ans = 0;\n        for (int i = Q-1; i >= 0; --i) {\n            if (t[i] == 'M') {\n                if (v[i] == -1) continue;\n                uf.merge(p[v[i]], v[i]);\n            } else {\n                ans += uf.root(v[i]) + 1;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint par[1000001];\nint rank[1000001];\nbool flag[1000001];\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=0;\n\t\trank[i]=0;\n\t}\n\tmemset(flag,false,sizeof(flag));\n}\n\nint find(int x){\n\tif(flag[x])return x;\n\treturn find(par[x]);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&par[i]);\n\t\t}\n\t\tflag[1]=true;\n\t\tlong long res=0;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar s;\n\t\t\tint v;\n\t\t\tcin >> s >> v;\n\t\t\tif(s=='M'){\n\t\t\t\tflag[v]=true;\n\t\t\t}\n\t\t\tif(s=='Q'){\n\t\t\t\tres+=find(v);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define vec vector\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define brep(i, n) for (int i = (int)n - 1; i >= 0; i--)\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\nvec<int> p;\n\nint root(int a)\n{\n\tif (p[a] == a) return a;\n\tp[a] = root(p[a]);\n\treturn p[a];\n}\n\nvoid unite(int a, int b)\n{\n\tp[root(a)] = root(b);\n}\n\nvoid init(int n)\n{\n\tp.resize(n);\n\trep(i, n) p[i] = i;\n}\n\nint main(void)\n{\n\twhile(1) {\n\tint n, q;\n\tcin >> n >> q;\n\tif (!n && !q) break;\n\tinit(n);\n\tvec<int> keep(n);\n\trep(i, n - 1) {\n\t\tint get;\n\t\tcin >> get;\n\t\tget--;\n\t\tp[i + 1] = get;\n\t}\n\tkeep = p;\n\n\tvec<pii> query;\n\trep(i, q) {\n\t\tchar c;\n\t\tint v;\n\t\tcin >> c >> v;\n\t\tv--;\n\t\tint get;\n\t\tif (c == 'Q') get = 0;\n\t\telse get = 1;\n\t\tif (!get) query.pb(mp(get, v));\n\t\telse {\n\t\t\tif (p[v] == v) continue;\n\t\t\tp[v] = v;\n\t\t\tquery.pb(mp(get, v));\n\t\t}\n\t}\n\n\tll sum = 0;\n\tbrep(i, query.size()) {\n\t\tif (!query[i].first) sum += (ll)root(query[i].second) + 1;\n\t\telse unite(query[i].second, keep[query[i].second]);\n\t}\n\n\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define TEST 0\nint par[100001];\nbool marked[100001];\nint find_marked(int id)\n{\n    if(marked[id])return id;\n    return find_marked(par[id]);\n}\nint main(void)\n{\n    int n,q;\n    while(scanf(\"%d%d\",&n,&q)==2 && (n!=0 || q != 0))\n    {\n        par[1]=0;\n        marked[1]=true;\n        long long int sum=0;\n        for(int i=0;i<n-1;i++)\n        {\n            scanf(\"%d\",par + i+2);\n            marked[i+2]=false;\n        }\n        for(int j=0;j<q;j++)\n        {\n            char str[8];\n            int num;\n            scanf(\"\\n%[QM]%d\",str,&num);\n#if TEST\n            printf(\"%c:%d\\n\",str[0],num);\n#endif\n            switch(str[0])\n            {\n            case 'Q':\n                    sum+=find_marked(num);\n                    break;\n            case 'M':\n                    marked[num]=true;\n                    break;\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, Q;\nvector<int> G[100000];\n\nbool M[100000];\nint par[100000];\nint U[100000], R[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  //if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N >> Q) {\n    if (N == 0 && Q == 0) break;\n    rep(i, N) {\n      G[i].clear();\n      M[i] = false;\n    }\n    for (int i=0; i<N; i++) U[i] = i, R[i] = 1;\n    rep(i, N-1) {\n      int p;\n      cin >> p;\n      p--;\n      G[p].pb(i+1);\n      par[i+1] = p;\n    }\n    M[0] = true;\n    vector<P> qs;\n    rep(i, Q) {\n      char c; int v;\n      cin >> c >> v;\n      v--;\n      if (c == 'M') {\n        if (M[v]) continue;\n        M[v] = true;\n        qs.pb(P(0, v));\n      }\n      else {\n        qs.pb(P(1, v));\n      }\n    }\n    rep(x, N) {\n      for (int t : G[x]) {\n        if (M[t]) continue;\n        unite(x, t);\n      }\n    }\n    long long ans = 0;\n    for (P &p : qs) {\n      if (p._1 == 0) {\n        // unmark\n        unite(par[p._2], p._2);\n      }\n      else {\n        ans += find(p._2)+1;\n      }\n    }\n    cout << ans << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nclass union_find{\n\tvector<int> parent;\npublic:\n\tvector<int> marked;\n\tint root(int a){return parent[a]==a||marked[a]?a:(parent[a]=root(parent[a]));}\n\tunion_find(int n):parent(n),marked(n){for(int i=1;i<n;i++)parent[i]=i;}\n\tint same(int a,int b){return root(a)==root(b);}\n\tint unite(int a,int b){\n\t\tint x=root(a),y=root(b);//if(x==y)return 0;\n\t\tparent[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint main(){\n\tint N,M;\n\tfor(;scanf(\"%d%d\",&N,&M),N;){\n\t\tvector<int>parent(N);\n\t\tfor(int i=1;i<N;i++)scanf(\"%d\",&parent[i]),parent[i]--;\n\t\tunion_find uf(N);\n\t\tvector<pair<char,int> >query;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tchar s[2];int n;\n\t\t\tscanf(\"%s%d\",s,&n),n--;\n\t\t\tif(*s=='Q'||!uf.marked[n]){\n\t\t\t\tif(*s=='M')uf.marked[n]=1;\n\t\t\t\tquery.emplace_back(*s,n);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<N;i++)if(!uf.marked[i])uf.unite(i,parent[i]);\n\t\treverse(query.begin(),query.end());\n\t\tint R=0;\n\t\tfor(auto &e:query){\n\t\t\tif(e.first=='Q')R+=uf.root(e.second)+1;\n\t\t\telse uf.marked[e.second]=0,uf.unite(e.second,parent[e.second]);\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int gmax_n = 100005;\n\nint par[gmax_n]; //???\nint depth[gmax_n];//??¨?????±???\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint g[gmax_n];\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        init(n);\n        rep(i,n - 1){ //??¨????§????\n            int a;\n            cin >> a;\n            a--;\n            g[i + 1] = a;\n        }\n\n        bool marked[gmax_n] = {0};//???????????????????????????????¨????\n        marked[0] = true;\n        vector<pair<char, int>> q;\n        rep(i,m){\n            char a;\n            int b;\n            cin >> a >> b;\n            b--;\n            if(a == 'M'){\n                if(marked[a]) continue; //????????¨???????????????????????´?????????????????\\???????????????\n                else{\n                    marked[a] = true;\n                    q.emplace_back(make_pair(a, b));\n                }\n            }else{\n                q.emplace_back(make_pair(a,b));\n            }\n        }\n\n        rep(i,n){ //???????????????????????????????????¨?????????????????????unite\n            if(not marked[i]){\n                unite(i, g[i]);\n            }\n        }\n\n        long long ans = 0;\n        for(int i = q.size() - 1; i >= 0; i--){ //?????¨?????????????????????\n            if(q[i].first == 'Q') ans += find(q[i].second) + 1;\n            else{\n                unite(q[i].second, g[q[i].second]);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[100005];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tfa[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')fa[a] = a;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (fa[a] != a)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int MAX=1e5+5;\nint par[MAX];\nbool marked[MAX];\nint findpar(int s){\n    if (s==par[s]) return s;\n    else           return par[s];\n}\nint main(){\n    int N,M;\n    while (~scanf(\"%d%d\",&N,&M)&&N&&M){\n        memset(marked,false,sizeof(marked));\n        marked[1]=true;par[1]=1;\n        for (int i=2;i<=N;i++){\n            int a;\n            scanf(\"%d\",&a);\n            par[i]=a;\n        }\n        char s[2];\n        int k,ans=0;\n        for (int i=0;i<M;i++){\n            scanf(\"%s%d\",s,&k);\n            if (!strcmp(s,\"Q\")){\n                while (!marked[k]){\n                    k=findpar(k);\n                    if (marked[k]) ans+=k;\n                }\n            }\n            else if (!strcmp(s,\"M\"))\n                marked[k]=true;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\n// int Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nint search(int x) {\n  int a = par[x];\n  if (marked[a]) return a;\n  else return search(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (x == 1 || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct UF {\n    int *par;\n    UF(int n) {\n        par=new int[n];\n        for(int i=0;i<n;i++) {\n            par[i]=i;\n        }\n    }\n    int find(int x) {\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void unite(int x,int y) {\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        par[x]=y;\n    }\n    bool same(int x,int y) {\n        return find(x)==find(y);\n    }\n};\nint marked[100000];\nchar op[100000][2];\nint v[100000];\nint par[100000];\nint main() {\n    int N,Q;\n    while(scanf(\"%d %d\",&N,&Q),N) {\n        par[0]=-1;\n        for(int i=1;i<N;i++) {\n            scanf(\"%d\",&par[i]);par[i]--;\n        }\n        fill(marked,marked+100000,0);\n        marked[0]=1;\n        for(int i=0;i<Q;i++) {\n            scanf(\"%s %d\",op[i],&v[i]);v[i]--;\n            if(op[i][0]=='M') marked[v[i]]++;\n        }\n        UF u(N);\n        for(int i=0;i<N;i++) {\n            if(marked[i]>0) u.unite(i,par[i]);\n        }\n        long long ans=0;\n        for(int i=Q-1;i>=0;i--) {\n            if(op[i][0]=='M') {\n                if(v[i]!=0&&marked[v[i]]>0) {\n                    u.unite(v[i],par[v[i]]);\n                    marked[v[i]]--;\n                }\n            }else {\n                ans+=u.find(v[i])+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    //if(n == 0)\n//\tint m = 1;\n    if(flag[n] != 0)\n    {\n\treturn n;\t    \n    }\n\n    else\n    {\t\n\treturn t[n] = find(t[n]);    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n#ifndef ONLINE_JUDGE\n    READ;\n#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint ii = 0;\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 1;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tii = ii + 1;\n\tif(ii == 5)\n\t    int m = 0;\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]]++;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M') flag[idx[i]]--;\n\t    else ret = ret + find(idx[i]);\n\t    //std::cout<<idx[i]<<std::endl;\n\t    //if(idx[i] == 0)\n\t    //int m = 1;\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e12;\nconst int MAX_V = 100010;\n\nint p[MAX_V];\nbool marked[MAX_V];\n\nint dfs(int v){\n    return (marked[v] ? v : dfs(p[v]));\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, q, v;\n    char c;\n    while(cin >> n >> q && n){\n        memset(marked, false, sizeof(marked));\n        rep(i, 1, n){\n            cin >> v; v--;\n            p[i] = v;\n        }\n        marked[0] = true;\n        int ans = 0;\n        rep(i, 0, q){\n            cin >> c >> v; v--;\n            if(c == 'M'){\n                marked[v] = true;\n            }else{\n                ans += dfs(v) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define SIZE_SEG 100000\n\nstruct SegNode {\n\tint depth, id;\n};\n\nstruct Node {\n\tint p, id, chsz, depth;\n\tvector<int> ch;\n};\nbool operator <(const SegNode& sn1, const SegNode& sn2) {\n\treturn sn1.depth < sn2.depth;\n}\nbool operator >(const SegNode& sn1, const SegNode& sn2) {\n\treturn sn2 < sn1;\n}\n\nint N, segSize;\nvector<Node> G;\nSegNode seg[SIZE_SEG*4];\n\nint dfs(int n, int& id, int depth) {\n\tG[n].id = id++;\n\tG[n].depth = depth;\n\n\tint sz = 0;\n\tfor (int i = 0; i < G[n].ch.size(); ++i) {\n\t\tsz += dfs(G[n].ch[i], id, depth+1);\n\t}\n\tG[n].chsz = sz;\n\n\treturn sz+1;\n}\n\nvoid init(int sz) {\n\tfor (segSize = 1; segSize < N; segSize <<= 1);\n\tfor (int i = 0; i < segSize*2-1; ++i) {\n\t\tseg[i] = (SegNode){0, 0};\n\t}\n}\nvoid update(int n, int l, int r, int L, int R, SegNode& sn) {\n\tif (L <= l && r <= R) {\n\t\tif (sn > seg[n]) seg[n] = sn;\n\t}\n\telse if (r <= L || R <= l) {\n\t\treturn;\n\t}\n\telse {\n\t\tint m = (l + r) / 2;\n\t\tupdate(n*2+1, l, m, L, R, sn);\n\t\tupdate(n*2+2, m, r, L, R, sn);\n\t}\n}\nvoid update(int L, int R, SegNode node) {\n\tupdate(0, 0, segSize, L, R, node);\n}\nSegNode get(int target) {\n\tSegNode ret = (SegNode){0, 0};\n\tint n = segSize+target-1;\n//\tcout << target << \" : \";\n\twhile (1) {\n//\t\tcout << n << \" \";\n\t\tif (seg[n] > ret) ret = seg[n];\n\t\tif (n == 0) break;\n\t\tn = (n-1)/2;\n\t}\n//\tcout << endl;\n\treturn ret;\n}\n\nint main() {\n\tint Q;\n\twhile ( cin >> N >> Q, N || Q ) {\n\t\tG.clear(); G.resize(N);\n\t\tG[0].p = 0;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tcin >> G[i].p; --G[i].p;\n\t\t\tG[G[i].p].ch.push_back(i);\n\t\t}\n\n\t\t{ int temp = 0; dfs(0, temp, 0); }\n\n\t\tinit(N);\n\n\t\tll ans = 0;\n\t\tfor (int t = 0; t < Q; ++t) {\n\t\t\tchar op; int id; cin >> op >> id; --id;\n\t\t\tif (op == 'M') {\n\t\t\t\tupdate(G[id].id+1, G[id].id+1+G[id].chsz, (SegNode){G[id].depth, id});\n//\t\t\t\tfor (int i = 0; i < segSize*2-1; ++i) {\n//\t\t\t\t\tcout << seg[i].depth << \" \" << seg[i].id << endl;\n//\t\t\t\t}\n//\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\telse { // Q\n\t\t\t\tans += get(G[id].id).id+1;\n//\t\t\t\tcout << get(G[id].id).id+1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par;\n\tUnion_Find_Tree(int n){\n\t\tPar=vi(n);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tPar[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint n,q;\nvi a;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>q;\n\t\tif(!n) break;\n\t\ta=vi(n+1);\n\t\tfor(int i=2;i<=n;i++) cin>>a[i];\n\t\tvp p(q);\n\t\tvi b(n+1);\n\t\tUnion_Find_Tree uft(n+1);\n\t\tll res=0;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin>>c>>v;\n\t\t\tif(c=='Q') p[i]={0,v};\n\t\t\telse{\n\t\t\t\tp[i]={1,v};\n\t\t\t\tb[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=n;i++) if(!b[i]) uft.Unite(i,a[i]);\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tbool B=p[i].first;\n\t\t\tint v=p[i].second;\n\t\t\tif(B){\n\t\t\t\tb[v]--;\n\t\t\t\tif(!b[v]) uft.Unite(v,a[v]);\n\t\t\t}\n\t\t\telse res+=uft.Find_Par(v);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define maxn 100005\nusing namespace std;\n\nint pre[maxn],rank[maxn],vis[maxn];\n\nvoid init(int n)\n{\n    int i;\n    for(i=1;i<=n;i++)\n    {\n        pre[i]=i;\n        rank[i]=1;\n    }\n}\n\nint find(int x)\n{\n\n    while(!vis[x])\n        x=pre[x];\n\n    return x;\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF && (n||m))\n    {\n        memset(vis,0,sizeof(vis));\n\n        for(int i=2;i<=n;i++)\n        {\n            int fat;\n            scanf(\"%d\",&fat);\n            pre[i]=fat;\n        }\n\n        int ans=0;\n        vis[1]=1;\n        while(m--)\n        {\n            char str[2];\n            int x;\n            scanf(\"%s%d\",str,&x);\n            if(str[0]=='Q')\n            ans+=find(x);\n            else\n            {\n                vis[x]=1;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid read(int &x){\n\tx=0; char c=getchar();\n\tfor (;c<48;c=getchar());\n\tfor (;c>47;c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\n#define M 100005\nint op[M],fa[M],x[M],n,q;\nbool mark[M];\nvoid in(){\n\tint i;\n\tmemset(mark,0,sizeof(mark)); mark[1]=1; fa[1]=1;\n\tfor (i=2;i<=n;i++)read(fa[i]);\n\tfor (i=1;i<=q;i++){read(op[i]); read(x[i]); if(op[i]!=97)mark[x[i]]=1;}\n}\nint getf(int x){\n\tif (mark[x])return x;\n\treturn fa[x]=getf(fa[x]);\n}\nvoid solve(){\n\tint fx,i,res=0;\n\tfor (i=q;i;i--){\n//\t\tprintf(\"op[%d]=%d %d\\n\",i,op[i],x[i]);\n\t\tif (op[i]==97){\n\t\t\tfx=getf(fa[x[i]]); res+=fx;\n\t\t}\n\t\telse{\n\t\t\tmark[x[i]]=0;\n\t\t}\t\t\n\t}\n\tprintf(\"%d\\n\",res);\n}\n\nint main(){\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\tfor (;;){\n\t\tread(n); read(q);\n\t\tif (n==0&&q==0)return 0;\n\t\tin(); solve();\t\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<math.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {\n\tcww() { CIN_ONLY{ ios::sync_with_stdio(false); cin.tie(0); } }\n}star;\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\nnamespace _DSU {\n\tconst int BUF = 112345 * 2;\n\tint ptr = 0;\n\tint mem[BUF];\n\tint* get(int size) {\n\t\tptr += size;\n\t\treturn mem + ptr - size;\n\t}\n\tvoid reset() {\n\t\tptr = 0;\n\t}\n}\nclass UF {\npublic:\n\tint *par, *rank;\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tUF(int n) :par(_DSU::get(n + 10)), rank(_DSU::get(n + 10)) {\n\t\tREP(i, n)par[i] = i, rank[i] = 0;\n\t}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y)return false;\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint N, Q;\ntypedef vector<int> V;\ntypedef vector<V> VV;\nVV g;\nint query[112345][2];\nint m[112345];\nint p[112345];\nconst int MARK = 0;\nconst int QUERY = 1;\nvoid dfs(int v,int near,UF& uf) {\n\tif (m[v] == 1) {\n\t\tnear = v;\n\t\tm[v] = near;\n\t}\n\telse {\n\t\tm[v] = -1;\n\t}\n\tuf.unite(near, v);\n\tint ch = g[v].size();\n\tREP(i, ch)dfs(g[v][i], near, uf);\n}\n void solve() {\n\t_DSU::reset();\n\tg=VV(N);\n\tFOR(i, 1, N) {\n\t\tcin >> p[i]; p[i]--;\n\t\tg[p[i]].push_back(i);\n\t\tm[i] = 0;\n\t}\n\tm[0] = 1;\n\tREP(i, Q) {\n\t\tstring s; int v;\n\t\tcin >> s >> v;\n\t\tv--;\n\t\tif (s[0] == 'Q')query[i][0] = QUERY;\n\t\telse {\n\t\t\tif (m[v] == 1)query[i][0] = -1;\n\t\t\telse {\n\t\t\t\tquery[i][0] = MARK;\n\t\t\t\tm[v] = 1;\n\t\t\t}\n\t\t}\n\t\tquery[i][1] = v;\n\t}\n\tUF uf(N);\n\tdfs(0, 0, uf);\n\n\tLL ret = 0;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t//cout << i << \" \" << uf.find(32999) << \" \" << uf.find(88725) << endl;\n\t\tif (query[i][0] == -1)continue;\n\t\tif (query[i][0] == MARK) {\n\t\t\tint v = query[i][1];\n\t\t\tint u = p[v];\n\t\t\t//cout << m[uf.find(u)] << \" \" << m[uf.find(v)] << endl;\n\t\t\tm[uf.find(v)] = -1;\n\t\t\tuf.unite(u, v);\n\t\t\t//assert(m[uf.find(v)] != -1);\n\t\t}\n\t\telse {\n\t\t\tint v = query[i][1];\n\t\t\t//assert(m[uf.find(v)]!=-1);\n\t\t\tret+= m[uf.find(v)]+1;\n\t\t\t//cout << m[uf.find(v)]+1;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\twhile (cin >> N >> Q, N + Q)solve();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=100000;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tvoid update_min(int l,int r,int a,int b,int u,T v){\n\t\tif(l<=a && b<=r){ dat[u]=min(dat[u],v); return; }\n\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) update_min(l,r,a,c,2*u,v);\n\t\tif(l<b && c<r) update_min(l,r,c,b,2*u+1,v);\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update_min(int l,int r,T v){ update_min(l,r,0,n,1,v); }\n\n\tT query(int u){\n\t\tu+=n;\n\t\tT res=dat[u];\n\t\tfor(u/=2;u>=1;u/=2) res=min(res,dat[u]);\n\t\treturn res;\n\t}\n};\n\nint n;\nvector<int> T[100000]; // tree\n\nint start[100000],end[100000];\n\nint idx;\nvoid dfs(int u){\n\tstart[u]=idx++;\n\trep(i,T[u].size()) dfs(T[u][i]);\n\tend[u]=idx;\n}\n\nint main(){\n\tfor(int q;scanf(\"%d%d\",&n,&q),n;){\n\t\trep(u,n) T[u].clear();\n\t\trep(i,n-1){\n\t\t\tint u,v=i+1; scanf(\"%d\",&u); u--;\n\t\t\tT[u].push_back(v);\n\t\t}\n\n\t\tidx=0;\n\t\tdfs(0);\n\n\t\tstatic segment_tree_RMQ<int> S;\n\t\tS.build(n,0);\n\n\t\tll ans=0;\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint u; scanf(\" %c%d\",&c,&u); u--;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=-S.query(u)+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tS.update_min(start[u],end[u],-u);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint flag[100010],par[100010];\nvector<int> gg[100010];\nint n,q;\nlong long ans;\nvoid setpar(int parr,int x)\n{\n\tpar[x]=parr;\n\tif(!flag[x])\n\t{\n\t\tfor(int i=0;i<gg[x].size();i++)\n\t\t\tsetpar(parr,gg[x][i]);\n\t}\n}\nint main()\n{\n\tcin>>n>>q;\n\tflag[1]=1;\n\tint a;\n\tchar b;\n\tpar[i]=0;\n\tfor(int i=2;i<=n;i++)\n\t\tpar[i]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a);\n\t\tgg[a].push_back(i);\n\t\tgetchar();\n\t}\n\twhile(q--)\n\t{\n\t\tscanf(\"%c%d\",&b,&a);\n\t\tgetchar();\n\t\tif(b=='M')\n\t\t{\n\t\t\tflag[a]=1;\n\t\t\tfor(int i=0;i<gg[a].size();i++)\n\t\t\t\tsetpar(a,gg[a][i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=par[a];\n\t\t}\n\t}\n\tcin>>n>>q;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2170: Marked Ancestor\n * ?¢???????\n * ?±?????????¶??\\???+dfs+??????????????????+dfs???\n * ?????????????????????????????¢???????±??????\\????????????????\\?????????????dfs?????°????????????????\\??????????????\\???????????????¨??¶??\\????????????????????????????????????????????????????????????????????¶?°???\\???????????¶????????¨???????????¶????????????????????????dfs?????°?????????????????????????????°?????????????????°??\\??????????????????????????´?????????????????°?????°??????\n */\n\n#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<char, int> pci;\n\nstack<pci> s;\n\nint fa[100010];\nint p[100010];\nint vis[100010];\n\nvector<int> e[100010];\n\nint n;\n\nvoid dfs(int i, int f = 1) {\n  if(vis[i]) {\n    f = i;\n  }\n  fa[i] = f;\n  for(auto c: e[i]) {\n    dfs(c, f);\n  }\n}\n\nint find(int x) {\n  if(x == fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\n\nint main() {\n  int i, j, q;\n  long long ans;\n  char op[3];\n  while(scanf(\"%d%d\", &n, &q) != EOF && n > 0) {\n    memset(vis, 0, sizeof(vis));\n    for(i = 1; i <= n; ++i) {\n      e[i].clear();\n    }\n    ans = 0;\n\n    vis[1] = 1;\n    for(i = 2; i <= n; ++i) {\n      scanf(\"%d\", &j);\n      e[j].push_back(i);\n      p[i] = j;\n    }\n    for(i = 0; i < q; ++i) {\n      scanf(\"%s%d\", op, &j);\n      if(op[0] == 'M') {\n        ++vis[j];\n      }\n      s.push(make_pair(op[0], j));\n    }\n    dfs(1);\n\n    while(!s.empty()) {\n      i = s.top().second;\n      if(s.top().first == 'M') {\n        if(--vis[i] == 0) {\n          fa[i] = find(p[i]);\n        }\n      } else {\n        ans += find(i);\n      }\n      s.pop();\n    }\n\n    printf(\"%lld\\n\", ans);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nchar ch[MAX_Q+1];\nint num[MAX_Q+1];\nint N, Q;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(int i=1; i<=N; i++) scanf(\"%d\", &par[i]);\n        for(int i=1; i<=Q; i++) scanf(\" %c %d\", &ch[i], &num[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n            if(ch[i]=='M'){\n                vis[num[i]]=1;\n            }\n            else if(ch[i]=='Q'){\n                int cur=num[i];\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nint ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)&&(q+n)!=0){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] += 1;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] -= 1;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define ll long long\nint q, n, v;\nchar c;\nint p[100005];\nbool m[100005];\nint main() {\n    while ((~scanf(\"%d %d\", &n, &q)) && q && n) {\n        for (int i = 1; i <= n; ++i) scanf(\"%d\", &p[i]);\n        memset(m, 0, sizeof m);\n        m[1] = true;\n        ll ans = 0;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"\\n%c %d\", &c, &v);\n            if (c == 'M')p[v] = v;\n            else {\n                while (p[v] != v) v = p[v];\n                ans += v;\n                //printf(\"%d**\\n\", v);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n \nusing namespace std;\n \nlong long int n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n \nvoid set_root(int x, int y){\n    if(root[x] == 0)\n    root[x] = y;\n    y = root[x];\n    for(int i = 0;i < child[x].size();i++){\n    set_root(child[x][i], y);\n    }\n}\n \nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n \nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n \nint main(){\n    while(true){\n    cin >> n >> q;\n    if(n == 0 && q == 0)return 0;\n    res = 0;\n    fill(root, root + n + 1, 0);\n    for(int i = 0;i <= n;i++)child[i].clear();\n    for(int i = 2;i <= n;i++){\n        cin >> parent[i];\n        child[parent[i]].push_back(i);\n    }\n    for(int i = 0;i < q;i++){\n        cin >> query[i].first >> query[i].second;\n        if(query[i].first == 'M')\n        root[query[i].second] = query[i].second;\n    }\n    set_root(1, 1);\n    for(int i = q;i--;){\n        int num = query[i].second;\n        if(query[i].first == 'M'){\n        unite(num, parent[num]);\n        }\n        else{\n        res += r(num);\n        }\n    }\n    cout << res << endl;\n    }       \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n,q;\nint tree[100050];\n\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&q)==2)\n    {\n        if(n==0&&q==0)\n            break;\n        tree[1]=1;\n        for(int i=2;i<=n;i++)\n            scanf(\"%d\",&tree[i]);\n        getchar();\n        long long ans=0;\n        for(int i=1;i<=q;i++)\n        {\n            int temp;\n            char s;    \n            scanf(\"%c %d\",&s, &temp);\n            if(s=='M')\n                tree[temp]=temp;\n            else if(s=='Q')\n                ans+=Find(temp);\n             cin.ignore();    \n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint f[100010],sum[100010],v[100010];\n\nint father(int x)\n{\n\tif (f[x]==x) return x;\n\tif (sum[x]==sum[f[x]]) return f[x];\n\tf[x]=father(v[x]);\n\tsum[x]=sum[f[x]]; \n\treturn f[x];\n}\n\nint main()\n{\n\tint t,n,m,i,x;\n\tchar op;\n\twhile (scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tf[1]=1; sum[1]=0;\n\t\tfor (i=2;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x);\n\t\t\tv[i]=x;\n\t\t\tf[i]=1;\n\t\t\tsum[i]=0;\n\t\t}\n\t\tint s=0;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tgetchar();\n\t\t\tscanf(\"%c%d\",&op,&x);\n\t\t\tif (op=='M')\n\t\t\t{\n\t\t\t\tsum[father(x)]++;\n\t\t\t\tf[x]=x;\n\t\t\t}\n\t\t\telse s+=father(x); \n\t\t}\n\t\tcout<<s<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#define LL long long\nusing namespace std;\nconst int N = 100010;\nvector<int> edge[N];\nvector<int> mark[N], query[N];\nint n, m;\nint L(int x){return x << 1;}\nint R(int x){return x << 1 | 1;}\nstruct Tree{\n\tstruct node{\n\t\tint v;\n\t}tr[N << 2];\n\tvoid build(int a, int b, int x){\n\t\ttr[x].v = 0;\n\t\tif(a < b){\n\t\t\tint mid = a + b >> 1;\n\t\t\tbuild(a, mid, L(x));\n\t\t\tbuild(mid + 1, b, R(x));\n\t\t}\n\t}\n\tvoid update(int x){\n\t\ttr[x].v = max(tr[L(x)].v, tr[R(x)].v);\n\t}\n\tvoid modify(int x, int a, int b, int pos, int ad){\n\t\tif(a == b){\n\t\t\ttr[x].v = ad;\n\t\t\treturn;\n\t\t}\n\t\tint mid = a + b >> 1;\n\t\tif(pos <= mid) modify(L(x), a, mid, pos, ad);\n\t\telse modify(R(x), mid + 1, b, pos, ad);\n\t\tupdate(x);\n\t}\n\tint query(int x, int a, int b, int l, int r){\n\t\tif(l <= a && b <= r) return tr[x].v;\n\t\tint mid = a + b >> 1;\n\t\tif(r <= mid) return query(L(x), a, mid, l, r);\n\t\telse if(l > mid) return query(R(x), mid + 1, b, l, r);\n\t\telse return max(query(L(x), a, mid, l, r), query(R(x), mid + 1, b, l, r));\n\t}\n}sg;\n\nLL ans = 0;\nint list[N];\nvoid dfs(int u, int d){\n\tlist[d] = u;\n\t/*for(int i = 0; i < query[u].size(); i ++){\n\t\tint _index = query[u][i];\n\t\tans = ans + list[sg.query(1, 1, m, 1,  _index)];\n\t}\n\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\tint _index = mark[u][i];\n\t\tsg.modify(1, 1, m, _index, d);\n\t}*/\n\tfor(int i = 0; i < edge[u].size(); i ++){\n\t\tint v = edge[u][i];\n\t\tdfs(v, d + 1);\n\t}/*\n\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\tint _index = mark[u][i];\n\t\tsg.modify(1, 1, m, _index, 0);\n\t}*/\n}\nvoid solve(){\n\tans = 0;\n\tfor(int i = 1; i <= n; i ++){\n\t\tedge[i].clear();\n\t\tquery[i].clear();\n\t\tmark[i].clear();\n\t}\n\tmemset(list, 0, sizeof(list));\n\tfor(int i = 2; i <= n; i ++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tedge[x].push_back(i);\n\t}\n\t\n\tmark[1].push_back(1);\n\tm ++;\n\tfor(int i = 2; i <= m; i ++){\n\t\tchar str[2];\n\t\tint v;\n\t\tscanf(\"%s%d\", str, &v);\n\t\tif(str[0] == 'Q') query[v].push_back(i);\n\t\telse mark[v].push_back(i);\n\t}\n\t\n\tsg.build(1, m, 1);\n\tdfs(1, 1);\n\t\n\tprintf(\"%lld\\n\", ans);\n}\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2 && n + m){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass UnionFind{\n\nprivate:\n    vector<int> data;\n    int num;\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n          data = vector<int>(size, -1);\n          num = size;\n      }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    bool unite(int x, int y){\n        if(same(x,y)) return(false);\n        x = find(x);\n        y = find(y);\n        //if(data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        num--;\n        return(true);\n    }\n\n    int find(int x){\n        if(data[x] < 0) return(x);\n        return(data[x] = find(data[x]));\n    }\n\n    int size(int x){\n        return(-data[find(x)]);\n    }\n\n    int count(){\n        return num;\n    }\n    void show(){\n        rep(i,data.size())cout << \" \" << data[i];cout << endl;\n        rep(i,data.size())cout << \" \" << find(i);cout << endl;\n    }\n};\n\nsigned main(void) {\n    int n,q;\n    while(1){\n        scanf(\"%lld %lld\",&n,&q);\n        if(n == 0)return 0;\n        vector<vi> g(n);\n        vi par(n);\n        loop(i,1,n){\n            int a;\n            scanf(\"%lld\",&a);\n            a--;\n            g[a].push_back(i);\n            par[i] = a;\n        }\n        set<int> st;\n        vp query(q,pii(0,0));\n        rep(i,q){\n            string s;\n            cin >> s;\n            cin >> query[i].second;\n            query[i].second--;\n            if(s == \"M\"){\n                st.insert(query[i].second);\n                query[i].first = 1;\n            }\n        }\n        UnionFind uf(n);\n        queue<int> que;\n        que.push(0);\n        while(que.size()){\n            int now = que.front();\n            que.pop();\n            rep(i,g[now].size()){\n                int ne = g[now][i];\n                if(!st.count(ne))uf.unite(now,ne);\n                que.push(ne);\n            }\n        }\n        int ans = 0;\n        for(int i = q-1; i >= 0; i--){\n            int v = query[i].second;\n            if(query[i].first){//unite\n                uf.unite(par[v],v);\n            }else{\n                ans += uf.find(v)+1;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> e[100000];\nint par[18][100000];\nint index[200000];\nint fapr[100000];\nint lapr[100000];\nint bit[200000];\nint bit_n;\nint n;\nvoid add(int i,int x){\n\twhile(i<bit_n){\n\t\tbit[i]+=x;\n\t\ti+=i&-i;\n\t}\n}\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-=i&-i;\n\t}\n\treturn s;\n}\nint dfs(int v,int k){\n\tindex[k]=v;\n\tfapr[v]=k++;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tk=dfs(e[v][i],k);\n\t\tindex[k++]=v;\n\t}\n\tlapr[v]=k-1;\n\treturn k;\n}\nint main(){\n\twhile(1){\n\tint q;\n\tint i,j;\n\tscanf(\"%d %d\",&n,&q);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;1<<j<n;j++)par[j][i]=-1;\n\tfor(i=0;i<n;i++)e[i].clear();\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d\",&par[0][i]);\n\t\tpar[0][i]--;\n\t\te[par[0][i]].push_back(i);\n\t}\n\tfor(i=1;1<<i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(par[i-1][j]==-1)continue;\n\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint m=i-1;\n\tdfs(0,1);\n\tbit_n=n*2;\n\tfor(i=0;i<bit_n;i++)bit[i]=0;\n\tadd(1,1);\n\tlong long ans=0;\n\tfor(i=0;i<q;i++){\n\t\tchar t;int v;\n\t\tscanf(\" %c %d\",&t,&v);\n\t\tv--;\n\t\tif(t=='M'){\n\t\t\tadd(fapr[v],1);\n\t\t\tadd(lapr[v]+1,-1);\n\t\t}else{\n\t\t\tint k=sum(fapr[v]);\n\t\t\tfor(j=m;j>=0;j--){\n\t\t\t\tif(par[j][v]==-1)continue;\n\t\t\t\tint s=sum(fapr[par[j][v]]);\n\t\t\t\tif(s==k){\n\t\t\t\t\tv=par[j][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=v+1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)b[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]]++;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M' && K[i] != 1) {\n\t\t\t\tb[K[i]]--;\n\t\t\t\tif (b[K[i]] == 0)UF.unite(a[K[i]], K[i]);\n\t\t\t}\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\tsum += D; break;\n\t\t\t\t\t}\n\t\t\t\t\tD = a[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int maxn=100010;\ntypedef struct p\n{\n\tint par,vis;\n}p;\np s[maxn];\nvoid init(int n){\n\tfor(int i=1;i<=n;i++){\n\t\ts[i].par=i;\n\t\ts[i].vis=0;\n\t}\n}\nint main()\n{\n    int n,q;\n\tcin>>n>>q;\n\tinit(n);\n\ts[1].vis=1;\n\tfor(int i=2;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ts[i].par=x;\n\t}\n\tgetchar();\n\tint sum=0;\n\twhile(q--){\n\t\tchar sh;\n\t\tint a;\n\t\tscanf(\"%c%d%*c\",&sh,&a);\n\t\tif(sh=='M'){\n\t\t\ts[a].vis=1;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tif(s[a].vis==1){\n\t\t\t\t\tsum+=a;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\ta=s[a].par;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//int w,y;\n//\tscanf(\"%d%d\",&w,&y);\n\tcout<<sum<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n, q;\n\twhile (cin >> n >> q, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, n-1)\n\t\t{\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\ta--;\n\t\t\tg[a].push_back(edge{ i + 1, 0 });\n\t\t}\n\t\tvi ans(n), mark(n);\n\t\tmark[0] = true;\n\t\tll sum = 0;\n\t\tREP(i, q)\n\t\t{\n\t\t\tchar c; int v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif (c == 'Q') sum += ans[v]+1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (mark[v]) continue;\n\t\t\t\tmark[v] = true;\n\t\t\t\tqueue<int> que;\n\t\t\t\tque.push(v);\n\t\t\t\twhile (que.size())\n\t\t\t\t{\n\t\t\t\t\tint t = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tans[t] = v;\n\t\t\t\t\tREP(j, g[t].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mark[g[t][j].to] == 1) continue;\n\t\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100001;\n     \nint N, Q;\nint par[MAX_N]; \nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint search(int x) {\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n  \nint main()\n{\n  marked[1] = true;\n  while(1){\n    int num;\n    char ope;\n    long long int ans;\n    \n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    ans = 0;\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      par[i] = num;\n      marked[i] = false;\n    }\n\n    for(int i = 0; i < Q; i++){\n      scanf(\" %c\", &ope);\n      scanf(\"%d\", &num);\n      if (ope == 'M') {\n        marked[num] = true;\n      }\n      else if(ope == 'Q'){\n        ans += search(num);\n      }\n    }\n    \n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\nvector<int> par,Rank;\nvector<bool> mark;\nvoid init(int n){\n\tpar.resize(n,0);\n\tRank.resize(n,0);\n\tmark.resize(n,false);\n\tmark[0] = true;\n\tmark[1] = true;\n\tpar[1] = 1;\n\tREP(i,n-2)par[i+2] = i+1;\n}\n\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\n\nvector<bool> is_cf;\nint mark_find(int x){\n\tis_cf[x] = true;\n\tif(mark[x] || par[x] == x)return x;\n\telse if(is_cf[x])return 0;\n\telse return mark_find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\tif(Rank[x] > Rank[y])par[y] = x;\n\telse{\n\t\tpar[x] = y;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x,int y){return find(x) == find(y);}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n||m){\n\t\tinit(n+1);\n\t\tREP(i,n-1){cin >> par[i+1];\n\t\t}\n\t\tlong long ans = 0;\n\t\tREP(i,m){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M'){\n\t\t\t\tmark[v] = true;\n\t\t\t}else if(c == 'Q'){\n\t\t\t\tis_cf.resize(n+1,false);\n\t\t\t\tans += mark_find(v);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\n\n//int used[MAX_N];\n//int mark[MAX_N];\n//map<int,vector<int> > child;\n\nvoid dfs(int start,int root){\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        int mark[MAX_N];\n        /*\n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n        */\n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        int ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n//\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2*k+1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nvoid dfs(const int now, vector<pair<int, int>>&ps,vector<int>&ids,int&id,const vector<vector<int>>&edges) {\n\tids[now] = id;\n\tps[now].first = id;\n\tid++;\n\tfor (auto e : edges[now]) {\n\t\tdfs(e, ps, ids, id, edges);\n\t}\n\tps[now].second = id - 1;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tedges[a - 1].push_back(i + 1);\n\t\t}\n\t\tvector<pair<int, int>>ps(N);\n\t\tvector<int>ids(N);\n\t\tint id = 0;\n\t\tdfs(0, ps, ids, id, edges);\n\t\tlong long int sum = 0;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'Q') {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tint aid = ids[a];\n\t\t\t\tint ans = get(aid, aid);\n\t\t\t\tsum += ans+1;\n\t\t\t\tcout << ans+1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tupdate(ps[a].first, ps[a].second,a);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define maxn 100005\nll fa[maxn];\nint n,q;\n\nll find_fa(ll x){\n\tif(x==fa[x]){\n\t\treturn fa[x];\n\t}\n\treturn find_fa(fa[x]);\n}\n\nint main(){\n\twhile(cin>>n>>q){\n\t\tif(!n&&!q) break;\n\t\tchar s[2];\n\t\tll x;\n\t\tfa[1] = 1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin>>x;\n\t\t\tfa[i] = x;\n\t\t}\n\t\tll ans = 0;\n\t\twhile(q--){\n\t\t\tcin>>s>>x;\n\t\t\tif(s[0]=='M'){\n\t\t\t\tfa[x] = x;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += find_fa(x);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nconst int MAX_N=100000+16;\nint a[MAX_N];\nint N,Q;\nint main(){\n    //freopen(\"1.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&N,&Q)!=EOF){\n        if(N==0&&Q==0)break;\n        a[1]=1;\n        for(int i=2;i<=N;i++){\n            scanf(\"%d\",&a[i]);\n        }\n        long long ans=0;\n        while(N--){\n            char c[2];int x;\n            scanf(\"%s %d\",c,&x);\n            if(c[0]=='Q'){\n                while(x!=a[x]){\n                    x=a[x];\n                }\n                ans+=x;\n            }\n            else {\n                a[x]=x;\n            }\n        }\n        printf(\"%ld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tmarked[1] = true;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t\tmarked[i]= false;\n\t}\n}\nint getnode(int x){\n\tif(par[x]==x||marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tlong long sum;\n\twhile(cin>>n>>q,n||q){\n\t\tinit(n);\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\tsum +=getnode(par[k]);\n\t\t\t}\n\t\t\tif(op=='M'&&!marked[k]){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t\tcout <<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct node{\n\tint parent;\n\tbool marked;\n};\nnode V[10000];\nint query(int v){\n\tif(V[v].marked) return v+1;\n\telse return query(V[v].parent);\n}\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n){\n\t\tV[0].marked = true;\n\t\tfor(int i = 1; i < n; ++i){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tV[i].parent = --p;\n\t\t\tV[i].marked = false;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tchar q;int v;\n\t\t\tcin >> q >> v;\n\t\t\t--v;\n\t\t\tif(q == 'M') V[v].marked = true;\n\t\t\telse{\n\t\t\t\tsum += query(v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nclass UnionFind {\nprivate:\n  vector<int> a;\npublic:\n  UnionFind(int n) {rep (i, n) a.push_back(i);}\n  int find(int x) {return a[x] == x ? x : (a[x] = find(a[x]));}\n  bool equal(int x, int y) {return find(x) == find(y);}\n  void unite(int x, int y) {a[find(y)] = find(x);}\n};\n\nint parent[100000], m[100000];\n\nint main() {\n  while (true) {\n    int n, q;\n    cin >> n >> q;\n    if (n == 0 && q == 0) break;\n    rep (i, n - 1) {\n      cin >> parent[i + 1];\n      --parent[i + 1];\n    }\n    UnionFind uf(n);\n    vector<pair<int, int> > query;\n    rep (i, q) {\n      string s;\n      int v;\n      cin >> s >> v;\n      --v;\n      if (s == \"M\") query.push_back(make_pair(0, v));\n      else query.push_back(make_pair(1, v));\n    }\n    reverse(query.begin(), query.end());\n    rep (i, n) m[i] = 0;\n    m[0] = 1;\n    rep (i, q) if (query[i].first == 0) ++m[query[i].second];\n    rep (i, n) if (m[i] == 0) {\n      uf.unite(parent[i], i);\n    }\n    long long res = 0;\n    rep (i, q) {\n      if (query[i].first == 0) {\n\t--m[query[i].second];\n\tif (m[query[i].second] == 0) uf.unite(parent[query[i].second], query[i].second);\n      } else {\n\tres += uf.find(query[i].second) + 1;\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 100001\nusing namespace std;\ntypedef long long ll;\nint func(int);\nint n,q,e,k;\nbool marked[N];\nvector<int> edge[N];\n\nint main(){\n  char c;\n  ll cnt;\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n-1;i++) cin>>e,edge[i+2].push_back(e);\n    for(int i=0;i<n-1;i++) marked[i+2]=false;\n    marked[1]=true;\n    cnt=0;\n    while(q--){\n      cin>>c>>k;\n      if(c=='M') marked[k]=true;\n      else cnt+=func(k);\n    }\n    cout<<cnt<<endl;\n    for(int i=2;i<=n;i++) edge[i].clear();\n  }\n  return 0;\n}\n\nint func(int x){\n  if(marked[x]) return x;\n  return func(edge[x][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct UnionFind {\n  int parent[110000];\n  void unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) { return; }\n    parent[y] = x;\n  }\n  int findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n};\n\nint n, q;\nUnionFind ufind;\nint parent[110000];\nbool mark[110000];\nint query[110000];\n\nint main() {\n  while (scanf(\"%d %d\", &n, &q), n|q) {\n    memset(&ufind, -1, sizeof(ufind));\n    MEMSET(mark, false);\n    parent[0] = 0;\n    REP(i, n -1) {\n      int p;\n      scanf(\"%d\", &p);\n      parent[i + 1] = p - 1;\n    }\n    int m = 0;\n    REP(i, q) {\n      char c;\n      int v;\n      scanf(\" %c %d\", &c, &v);\n      if (c == 'Q') {\n        query[m++] = v;\n      } else if (c == 'M' && !mark[v - 1]) {\n        mark[v - 1] = true;\n        query[m++] = -v;\n      }\n    }\n    REP(i, n) {\n      if (mark[i]) { continue; }\n      ufind.unionSet(parent[i], i);\n    }\n    reverse(query, query + m);\n    ll ans = 0;\n    REP(i, m) {\n      int index = abs(query[i]) - 1;\n      if (query[i] > 0) {\n        ans += ufind.root(index) + 1;\n      } else {\n        ufind.unionSet(parent[index], index);\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<set>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n#define MOD 1000000007\n#define ARRAY_MAX 2005\n\nconst int INF = 1e9+7;\n\n\ntypedef struct union_find{\n    \n    vector<ll> pa;//親\n    vector<ll> ra;//木の深さ\n    vector<ll> siz;\n    //n要素で初期化\n    void init(ll n){\n        pa.resize(n);\n        ra.resize(n);\n        siz.resize(n);\n        for(ll i = 0;i < n;i++){\n            pa[i] = i;/*各ノードに番号を振る,この時par[x]=xとなる時は木の根となる*/\n            ra[i] = 0;/*各ノード自体の高さは0*/\n            siz[i] = i;\n        }\n    }\n    //木の根を求める\n    ll find(ll x){\n        if(pa[x] == x){\n            return x;/*根ならそのノードの番号を返す*/\n        }else{\n            return pa[x] = find(pa[x]);/*根でないならさらにノードの根を探す*/\n        }\n    }\n\n    //xとyの属する集合を併合する\n    void unite(ll x,ll y){\n        x = find(x);//xの根の番号を探す\n        y = find(y);//yの根の番号を探す\n        if(x == y){//一致すればつながっている\n            return;\n        }\n        pa[y] = x;\n        siz[x] += siz[y];\n        /*if(ra[x] < ra[y]){//xの高さが低いなら高いほうにつなぐ、そして高さは大きい方(y)になる\n            pa[x] = y;\n            siz[y] += siz[x];\n        }else{\n            pa[y] = x;//yの高さが低いなら高いほうにつなぐ、そして高さは大きいほう(x)になる\n            siz[x] += siz[y];\n            if(ra[x] == ra[y]){//高さが一致しているなら併合の高さは1増える\n                ra[x]++;\n            }\n        }*/\n    }\n\n    //xとyが同じ集合に属するか判定\n    bool same(ll x,ll y){\n        return find(x) == find(y);//同じ集合なら1、違うなら0が返る\n    }\n    ll size(ll x){\n        x = find(x);\n        return siz[x];\n    }\n}UF;\n\n\nint main(){\n\n    ll n,q;\n    while(cin >> n >> q,n|q){\n\n        UF tree;\n        tree.init(n+10);\n        vector<ll> query,parent(n+10,0);\n        vector<bool> used(n+10,false);\n        //1-indexで扱う\n        for(int i = 2;i <= n;i++){//親を格納\n            cin >> parent[i];\n        }\n        parent[1] = 0;\n        used[1] = true;\n\n        for(int i = 0;i < q;i++){\n\n            char c;\n            ll k;\n            cin >> c >> k;\n            if(c == 'Q'){\n                query.push_back(k);\n            }else{\n                if(used[k] == false){//既にマークした頂点はマークしない\n                    query.push_back(-k);//負数なら色を付けるクエリとみなす\n                    used[k] = true;\n                }\n            }\n        }\n        for(ll i = 2;i <= n;i++){\n            if(used[i] == false){//色を付けないノードは先につなげておく\n                tree.unite(parent[i],i);\n            }\n        }\n        reverse(query.begin(),query.end());\n        //クエリ逆順に見る\n        ll sum = 0;\n        ll q_siz = query.size();\n\n        for(ll i = 0;i < q_siz;i++){\n            if(query[i] < 0){\n                tree.unite(parent[-query[i]],-query[i]);\n            }else{\n                sum += (ll)tree.find(query[i]);\n            }\n        }\n        cout << sum << endl;\n        query.shrink_to_fit();\n        parent.shrink_to_fit();\n        used.shrink_to_fit();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint flag[100010],par[100010];\nvector<int> gg[100010];\nint n,q;\nlong long ans;\nvoid setpar(int parr,int x)\n{\n\tpar[x]=parr;\n\tif(!flag[x])\n\t{\n\t\tfor(int i=0;i<gg[x].size();i++)\n\t\t\tsetpar(parr,gg[x][i]);\n\t}\n}\nint main()\n{\n\tcin>>n>>q;\n\tflag[1]=1;\n\tint a;\n\tchar b;\n\tpar[1]=1;\n\tans=0;\n\tfor(int i=2;i<=n;i++)\n\t\tpar[i]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a);\n\t\tgg[a].push_back(i);\n\t\tgetchar();\n\t}\n\twhile(q--)\n\t{\n\t\tscanf(\"%c%d\",&b,&a);\n\t\tgetchar();\n\t\tif(b=='M')\n\t\t{\n\t\t\tflag[a]=1;\n\t\t\tfor(int i=0;i<gg[a].size();i++)\n\t\t\t\tsetpar(a,gg[a][i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=par[a];\n\t\t}\n\t}\n\tcin>>n>>q;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\nint n, q;\nvector<int> t[100000];\nint nseq;\nint pid[100000];\nint pid_to_node[200000];\nint nid[100000];\nint bit[200001];\n\nvoid add(int i, int x){\n    while(i <= 2 * n){\n        bit[i] += x;\n        i += i & -i;\n    }\n}\n\nint sum(int i){\n    int s = 0;\n    while(i > 0){\n        s += bit[i];\n        i -= i & -i;\n    }\n    return s;\n}\n\nvoid tour(int i){\n    pid[i] = nseq;\n    pid_to_node[nseq++] = i;\n    for(int v: t[i]){\n        tour(v);\n    }\n    nid[i] = nseq++;\n}\n\nint solve(){\n    tour(0);\n\n    add(pid[0] + 1, 1);\n    add(nid[0] + 1, -1);\n\n    int ans = 0;\n    rep(i, q){\n        char c;\n        int k;\n        cin >> c >> k;\n        if(c == 'Q'){\n            int f = sum(pid[k - 1]);\n            int l = 0;\n            int r = pid[k - 1];\n            while(r - l > 1){\n                int m = (l + r) / 2;\n                if(sum(m) >= f){\n                    r = m;\n                }\n                else{\n                    l = m;\n                }\n            }\n            ans += pid_to_node[r - 1] + 1;\n        }\n        else{\n            add(pid[k - 1] + 1, 1);\n            add(nid[k - 1] + 1, -1);\n        }\n    }\n    return ans;\n}\n\nvoid init(){\n    rep(i, 100000){\n        t[i].clear();\n    }\n    nseq = 0;\n    fill_n(bit, 100001, 0);\n}\n\nint main(){\n    while(1){\n        cin >> n >> q;\n        if(n == 0){\n            break;\n        }\n        for(int i = 1; i < n; ++i){\n            int p;\n            cin >> p;\n            t[p - 1].push_back(i);\n        }\n\n        cout << solve() << endl;\n\n        init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint root;\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start){\n            if(used[start]==1) return ;\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++) dfs(child[start][i]);\n        }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        int par;\n        scanf(\"%d\",&par);\n        par--;\n        tmp.child[par].push_back(i+1);\n    }\n    int ans=0;\n    tmp.used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if (a=='Q') {\n            //cout<<\"as\"<<tmp.mark[b-1]<<endl;\n            ans+=(tmp.mark[b-1]+1);\n        }\n        else {\n            root=b-1;\n            tmp.dfs(b-1);\n            tmp.used[b-1]=1;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint n,q,tree[100010];\n\nint find(int x){\n  if(tree[x]==x) return x;\n  return tree[x]=find(tree[x]);\n}\n\nint main(){\n\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q)break;\n\n\n    char ch[100010];\n    int num[100010],par[100010];\n    tree[1]=par[1]=1;\n\n    for(int i=2;i<=n;i++)scanf(\"%d\",&tree[i]),par[i]=tree[i];\n    \n\n    for(int i=0;i<q;i++){\n      cin>>ch[i]>>num[i];\n      if(ch[i]=='M'&&tree[num[i]]==num[i])i--,q--;\n      else if(ch[i]=='M')tree[num[i]]=num[i];\n    }\n\n    long long ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(ch[i]=='M') tree[num[i]]=par[num[i]];\n      if(ch[i]=='Q') ans+=find(num[i]);\n    }\n\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n//  AOJ 2170 Marked Ancestor\n//\n//  Created by TaoSama on 2015-03-16\n//  Copyright (c) 2015 TaoSama. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n#define CLR(x,y) memset(x, y, sizeof(x))\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint n, q, par[N], rank[N];\nbool marked[N];\n\nvoid init(int n) {\n\tfor(int i = 1; i <= n; ++i) {\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x) {\n\tif(marked[par[x]]) return par[x];\n\treturn find(par[x]);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\n\twhile(~scanf(\"%d%d\", &n, &q) && n && q) {\n\t\tinit(n);\n\t\tmemset(marked, false, sizeof marked);\n\t\tmarked[1] = true;\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor(int i = 1; i <= q; ++i) {\n\t\t\tchar op[2]; int x;\n\t\t\tscanf(\"%s%d\", op, &x);\n\t\t\tif(op[0] == 'Q') {\n\t\t\t\tans += find(x);\n\t\t\t} else {\n\t\t\t\tmarked[x] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> children[100010];\npriority_queue<int> query[100010];\nint markedAt[100010];\nint ans[100010];\n\nvoid pull(int v) {\n    for (int c : children[v]) {\n        pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            query[v].push(query[c].top());\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        ans[query[v].top()] = v;\n        query[v].pop();\n    }\n}\n\nint main() {\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(query, query + n, priority_queue<int>());\n        fill(markedAt, markedAt+n, 1e9);\n        fill(ans, ans + q, -1);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        pull(0);\n        long long sum = 0;\n        for (int i = 0; i < q; ++i) {\n            if (ans[i] != -1) {\n                sum += ans[i] + 1;\n            }\n        }\n        cout << sum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define INF (1<<29)\n\n\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry==NULL && h.trees.size()<=i)break;\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nint marked[100000];\nBinomialHeap<int> bh[100000];\nvector<int> edge[100000];\nlong long ans;\n\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint par[100001];\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, q, x;\n    char s[2];\n    par[1] = 1;\n    while (scanf(\"%d%d\", &n, &q) != EOF) {\n        if (n == 0 && q == 0) break;\n        for (int i = 2; i <= n; i++) scanf(\"%d\", &par[i]);\n        long long sum = 0;\n        for (int i = 0; i < q; i++) {\n            scanf(\"%s%d\", s, &x);\n            if (s[0] == 'Q') {\n                while (x != par[x]) x = par[x];\n                sum += x;\n            } else {\n                par[x] = x;\n            }\n        }\n        cout << sum << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\n//{{{ uf.hpp\n#ifndef INCLUDE_UF_HPP\n#define INCLUDE_UF_HPP\n#include <vector>\n#include <algorithm>\nnamespace orliv {\n//{{{ UF merge, same, root, size, count\nstruct UF {\n  std::vector<int> data;\n  int cnt;\n  UF(int n) : data(n, -1), cnt(n) {}\n  bool merge(int a, int b){\n    a = root(a);\n    b = root(b);\n    if (a != b){\n      cnt--;\n      data[a] += data[b];\n      data[b] = a;\n    }\n    return a != b;\n  }\n  bool same(int a, int b){ return root(a) == root(b); }\n  int root(int a){ return data[a] >= 0 ? data[a] = root(data[a]) : a; }\n  int size(int a){ return -data[root(a)]; }\n  int count(){ return cnt; }\n};\n//}}}\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orliv;\n\ntypedef long long ll;\ntypedef pair<char, int> QT;\n\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nint par[100100];\nint B[100100];\n\nint main()\n{\n  int N, Q;\n  while (N = in(), Q = in()){\n    memset(B, 0, sizeof(B));\n    for (int i = 2; i <= N; i++) par[i] = in();\n    UF uf(N + 1);\n    vector<QT> Qs;\n    Qs.reserve(Q);\n    for (int i = 0; i < Q; i++){\n      char S[4];\n      int v;\n      scanf(\"%s %d\", S, &v);\n      Qs.push_back(QT(*S, v));\n      if (*S == 'M' && !B[v]++) par[v] = -par[v];\n    }\n    par[1] = 1;\n    for (int i = 2; i <= N; i++){\n      if (par[i] < 0) par[i] = -par[i];\n      else uf.merge(par[i], i);\n    }\n    reverse(Qs.begin(), Qs.end());\n    ll ans = 0;\n    for (const auto& q : Qs){\n      int v = q.second;\n      if (q.first == 'Q') ans += uf.root(v);\n      else if (!--B[v]) uf.merge(par[v], v);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nint N, Q;\n\nint main(){\n\tfreopen(\"in.txt\", \"r\", stdin);\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        par[1]=1;\n        for(int i=2; i<=N; i++) scanf(\"%d\", &par[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n\t\t\tchar ch; int num;\n        \tscanf(\"%c \", &ch); \n\t\t\tscanf(\"%d \", &num); \n           if(ch=='M'){\n                vis[num]=1;\n            }\n            else if(ch=='Q'){\n                int cur=num;\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n//#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,Q,par[100010],par2[100010],markpar[100010],q[100010];\nchar c[100010];\n\nint f(int v){\n    if(markpar[v]==v) return v;\n    return par2[v]=f(par[v]);\n}\n\nint main(){\n\twhile(cin>>N>>Q && N){\n        fill(markpar,markpar+N+1,0);\n        markpar[1]=1;\n        \n        rep2(i,2,N+1) cin>>par[i];\n        \n        rep(i,Q){\n            cin>>c[i]>>q[i];\n            if(c[i]=='M'){\n                markpar[q[i]]=q[i];\n            }\n        }\n        rep2(i,1,N+1){\n            par2[i]=f(i);\n        }\n        \n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            if(c[i]=='M'){\n                markpar[q[i]]=0;\n                markpar[q[i]]=f(q[i]);\n                //cout<<q[i]<<\" \"<<markpar[q[i]]<<endl;\n            }else{\n                ans+=markpar[par2[q[i]]];\n                //cout<<\"+\"<<markpar[par2[q[i]]]<<endl;\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nll find(ll node, vector<ll> parent, vector<bool> marked){\n    return (marked[node]?node:find(parent[node], parent, marked));\n}\n\nint main() {\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    ll n,q,node;\n    char c;\n    while(scanf(\"%lld %lld\", &n, &q) && n && q){\n        vector<ll> children[n+1], parent(n+1, 1);\n        vector<bool> marked(n+1, false);\n        ll ans = 0;\n        reppp(i, 2, n+1){\n            scanf(\"%lld\", &node);\n            debug(i);\n            children[node].push_back(i);\n            parent[i] = node;\n        }\n\n        marked[1] = true;\n        rep(q){\n            scanf(\"\\n%c %lld\", &c, &node);\n            if(c == 'Q'){\n                ans += find(node, parent, marked);\n            }else{\n                marked[node] = true;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long Long;\n\n#define MN 100000\n#define MQ 100000\nint N, Q;\nint parent[MN + 1];\nbool marked[MN + 1];\npair<int, int> queries[MQ];\nint group[MN + 1];\n\nint fillGroup(int n) {\n    if (group[n] >= 1) return group[n];\n    return group[n] = fillGroup(parent[n]);\n}\nint findGroup(int n) {\n    if (marked[ group[n] ]) return group[n];\n    return group[n] = findGroup(parent[n]);\n}\n\nbool input() {\n    scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) return false;\n    if (getchar() == EOF) return false;\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        parent[i] = p;\n    }\n    memset(marked, false, N + 1);\n    marked[1] = true;\n    memset(group, 0, sizeof(int) * (N + 1));\n    group[1] = 1;\n    for (int i = 0; i < Q; i++) {\n        char t; int n;\n        scanf(\"%*[ \\t\\r\\n]%c %d\", &t, &n);\n        if (t == 'M') {\n            if (marked[n]) {\n                queries[i] = make_pair('X', 0);\n                continue;\n            }\n            marked[n] = true;\n            group[n] = n;\n        }\n        queries[i] = make_pair(t, n);\n    }\n    for (int i = 1; i <= N; i++) {\n        if (group[i] <= 0) fillGroup(i);\n    }\n    return true;\n}\n\nvoid solve() {\n    Long ans = 0;\n    for (int q = Q - 1; q >= 0; q--) {\n        pair<int, int> query = queries[q];\n        if (query.first == 'Q') {\n            ans += findGroup(query.second);\n        } else if (query.first == 'M') {\n            marked[query.second] = false;\n        }\n        //for (int i = 1; i <= N; i++) cout << setw(3) << group[i]; cout << endl;\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    while (input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst int qmax=100010;\n\nvi trees[nmax];\nint p[nmax];\nint last[nmax];\n\nvoid add_edge(int a,int b){\n\ttrees[a].pb(b);\n\ttrees[b].pb(a);\n}\n\nint uf[nmax];\nint find(int i){\n\tif(uf[i]==i)\n\t\treturn i;\n\treturn uf[i]=find(uf[i]);\n}\n\nvoid unite(int p,int c){\n\tuf[c]=p;\n\treturn;\n}\n\n\nvoid dfs(int v,int p){\n\tif(last[v]==-1)\n\t\tunite(p,v);\n\tfor(auto &e:trees[v]){\n\t\tif(e!=p)\n\t\t\tdfs(e,v);\n\t}\n}\n\n\nchar type[qmax];\nint num[qmax];\n\nint main(void){\n\tint n,q;\n\twhile(cin >> n >> q){\n\t\tfor(int i=1;i<=n;++i){\n\t\t\ttrees[i].clear();\n\t\t\tuf[i]=i;\n\t\t\tlast[i]=-1;\n\t\t}\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tcin >> p[i];\n\t\t\tadd_edge(p[i],i);\n\t\t}\n\t\tlast[1]=-2;\n\t\trep(i,q){\n\t\t\tcin >> type[i] >> num[i];\n\t\t\tif(type[i]=='M'&&last[num[i]]==-1)\n\t\t\t\tlast[num[i]]=i;\n\t\t}\n\t\tdfs(1,-1);\n\t\tll ans=0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tdump(i)\n\t\t\tdump(ans)\n\t\t\tif(type[i]=='Q')\n\t\t\t\tans+=find(num[i]);\n\t\t\telse{\n\t\t\t\tif(last[num[i]]==i)\n\t\t\t\t\tunite(p[num[i]],num[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n\nusing namespace std;\n\nconstexpr int kMaxN = 100000;\nconstexpr int kMaxQ = 100000;\n\n///-----\nint ma[kMaxN];\nint urank[kMaxN];\nint color[kMaxN];\nvoid init() {\n  rep (i,kMaxN) {\n    ma[i] = i;\n    urank[i] = 0;\n    color[i] = i;\n  }\n}\n\nint find(int x) {\n  if (ma[x] == x)return x;\n  return ma[x] = find(ma[x]);\n}\n\nvoid unite(int x, int y) { // xの方の色にする\n  x = find(x);\n  y = find(y);\n\n  if (x == y) return;\n\n  color[y] = color[x];\n\n  if (urank[x] < urank[y]) {\n    ma[x] = y;\n  } else {\n    ma[y] = x;\n    if (urank[x] == urank[y]) urank[x]++;\n  }\n}\n\nint get_now_color(int x) {\n  x = find(x);\n  return color[x];\n}\n\n///-----\nusing P = pair<char,int>;\n\nstruct Op {\n  char com;\n  int idx;\n};\n\nint N,Q;\nint par[kMaxN];\nvector<int> col;\nvector<int> G[kMaxN];\nvector<Op> ops;\nvector<bool> used;\n\nvoid Init(void) {\n  used.resize(N);\n  fill(used.begin(), used.end(), false);\n\n  col.resize(N);\n  rep (i,N) col[i] = -1;\n  set<int> S;\n  for (auto &op:ops) {\n    if (op.com == 'Q') continue;\n    if (S.find(op.idx) != S.end()) {\n      op.idx = -1;\n    } else {\n      S.insert(op.idx);\n    }\n  }\n  for (auto op : ops) if (op.com == 'M' && op.idx >= 0) col[op.idx] = op.idx;\n  col[0] = 0;\n}\n\nvoid dfs(int i, int c) {\n  if (used[i]) return;\n  used[i] = true;\n  if (col[i] >= 0) c = col[i];\n  else col[i] = c;\n\n  for (auto e : G[i]) {\n    dfs(e, c);\n  }\n}\nvoid solve(void) {\n  Init();\n\n  dfs(0,0);\n\n  init();\n  int ans = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    auto& op = ops[i];\n\n    if (op.com == 'M') {\n      if (op.idx < 0) continue;\n      int j = op.idx;\n      unite(col[par[j]],col[j]);\n    } else {\n      ans += get_now_color(col[op.idx]) + 1;\n    }\n  }\n  cout << ans << endl;\n}\n\nsigned main(void) {\n  while(true) {\n    cin >> N >> Q;\n    if ( N == 0 && Q == 0) break;\n    rep (i,N) G[i].clear();\n    par[0] = 0;\n    rep (i, N-1) {\n      cin >> par[i + 1];\n      par[i + 1]--;\n      G[par[i+1]].push_back(i+1);\n    }\n    ops.resize(Q);\n    rep (i,Q) {\n      cin >> ops[i].com >> ops[i].idx;\n      ops[i].idx--;\n    }\n    solve();\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\n#define INF 0x3f3f3f3f\n#define N 100100\nlong long baba[N],vis[N];\nusing namespace std;\nint main()\n{\n    long long n,m,a,b,sum;\n    char x;\n    while(scanf(\"%lld%lld\",&n,&m),(n+m))\n    {\n        sum=0;\n        memset(baba,0,sizeof(baba));\n        memset(vis,0,sizeof(vis));\n        baba[1]=1;\n        vis[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            scanf(\"%lld\",&a);\n            baba[i]=a;\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\" %c %lld\",&x, &b);\n            if(x=='M')\n                vis[b]=1;\n            else\n            {\n                b=baba[b];\n                while(vis[b]==0)\n                {\n                    b=baba[b];\n                }\n                sum+=b;\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint N, Q, T[100000], V[100000]; char W[100001]; bool marked[100000];\nint par[100000];\nint root(int x) {\n\treturn par[x] == x ? x : par[x] = root(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = root(x), y = root(y); if (x != y) par[x] = y;\n}\nint main() {\n\twhile (true) {\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0) break; T[0] = -1;\n\t\tfor (int i = 1; i < N; i++) scanf(\"%d\", &T[i]), T[i]--; getchar();\n\t\tfor (int i = 0; i < Q; i++) scanf(\"%c%d\", &W[i], &V[i]), V[i]--, getchar();\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t\tfor (int i = 0; i < N; i++) if (W[i] == 'M') marked[V[i]] = true;\n\t\tfor (int i = 1; i < N; i++) if (!marked[i]) unite(i, T[i]);\n\t\tlong long ret = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tif (W[i] == 'Q') {\n\t\t\t\tret += root(V[i]) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunite(V[i], T[V[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 0\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nchar Ope[MAX_N];\nint Openum[MAX_N], Marked[MAX_N];\nvector<int> child[MAX_N];\n\nvoid mark(int x, int num) {\n  if(Marked[x] == x || Marked[x] == num) return;\n  Marked[x] = num;\n  for(int i = 0; i < child[x].size(); i++){\n    mark(child[x][i], num);\n  }\n}\n\nvoid solve() {\n  int ans = 0;\n  fill(Marked, Marked+N, 1);\n  for(int i = 0; i < Q; i++){\n    char ope = Ope[i];\n    int num = Openum[i];\n    if(ope == 'M') mark(num, num);\n    else if(ope == 'Q') ans += Marked[num];\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 0; i <= N; i++) child[i].clear();\n    for(int i = 2; i <= N; i++){\n      int par;\n      scanf(\"%d\", &par);\n      child[par].push_back(i);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n// union-find\nconst int MAXN = 100010;\nint par[MAXN];\nint num[MAXN];\nbool exist[MAXN];\nint parent[MAXN];\n\nvoid init(int n) {\n    for (int i = 0; i <= n; i++) {\n        par[i] = i;\n        num[i] = 0;\n        exist[i] = false;\n    }\n    exist[1] = true;\n}\n\nint find(int x) {\n    if (exist[x]) return x;\n    return par[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return;\n    if (num[x] < num[y]) par[x] = y;\n    else {\n        par[y] = x;\n        if (num[x] == num[y]) num[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint query[MAXN];\nint number[MAXN];\n\nint main(void) {\n    int N, Q;\n    while (cin >> N >> Q) {\n        if (N == 0 && Q == 0) break;\n        init(N);\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", parent+i);\n        }\n        for (int i = 0; i < Q; i++) {\n            char c;\n            scanf(\" %c %d\", &c, number+i);\n            if (c == 'Q') query[i] = 0;\n            else {\n                query[i] = 1;\n                exist[number[i]] = true;\n            }\n        }\n        ll ans = 0;\n        for (int i = Q-1; i >= 0; i--) {\n            if (query[i] == 0) {\n                ans += find(number[i]);\n//                cout << \"now ans is \" << ans << endl;\n            } else {\n                exist[number[i]] = false;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int MAXN=100010;\n\nint f[MAXN], mark[MAXN];\nP Q[MAXN];\n\nint getf(int k, int id)\n{\n\treturn mark[k] < id ? k : f[k] = getf(f[k], id);\n\t/*如果k?点被??的??早于????，就返回k。否?????k的父?点，\n\t且因???路径上有一些?点未被??或者???期，可以路径??,直接?被\n\t???点到最近???点路径上的所有?点都指向最近???点*/\n}\n\nint main()\n{\n\tint n, q;\n\twhile(~scanf(\"%d %d\", &n, &q),n + q)\n\t{\n\t\tfor(int i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &f[i]);\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tint cnt = 0;\n\t\tchar c;\n\t\tint x;\n\t\tfor(int i = 1; i <= q; i++)\n\t\t{\n            getchar();\n\t\t\tscanf(\"%c %d\", &c, &x);\n\t\t\tif(c == 'Q')\n\t\t\tQ[cnt++] = P(i, x);//P(i,x)表示在i?刻??x的最近??点\n\t\t\telse\n\t\t\tmark[x] = min(mark[x], i);//mark[i]表示i?点第一次被??的??，inf表示未被??\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i = cnt - 1; i >= 0; i--)\n\t\tans += getf(Q[i].second, Q[i].first);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry==NULL && h.trees.size()<=i)break;\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nint par[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nvector<int> edge[100000];\nlong long ans;\n\n\nvector<int> nodes;\n\nvoid bfs(){\n\tnodes.clear();\n\tint u=0;\n\tqueue<int> q;\n\tq.push(u);\n\twhile(!q.empty()){\n\t\tu=q.front();\n\t\tq.pop();\n\t\tnodes.push_back(u);\n\t\tfor(int i=0;i<edge[u].size();i++){\n\t\t\tq.push(edge[u][i]);\n\t\t}\n\t}\n}\n/*なぜかstack over flowする\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}*/\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tmemset(par,-1,sizeof(par));\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t\tpar[i]=p-1;\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tbfs();\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tint u=nodes[i];\n\t\t\tint t=marked[u];\n\t\t\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\t\t\tans+=u+1;\n\t\t\t\tcout<<u<<endl;\n\t\t\t\tbh[u].popmax();\n\t\t\t}\n\t\t\tif(u!=0){\n\t\t\t\tbh[par[u]].meld(bh[u]);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint un[100000];\nint find(int x){\n  if(x==un[x]) return x;\n  return un[x]=find(un[x]);\n}\n\nvoid unit(int a,int b){\n  un[find(a)]=find(b);\n}\n\nint pa[100000];\n\nint main(){\n  int n,q;\n  while(cin >> n >> q && n){\n    rep(i,n-1){\n      cin >> pa[i+1];\n      --pa[i+1];\n      un[i+1]=pa[i+1];\n    }\n  \n    vector<PI> que;\n    set<int> app;\n    ll ans=0;\n    rep(i,q){\n      char ch;\n      int a;\n      cin >> ch >> a;\n      --a;\n      if(ch=='M' && app.count(a))continue;\n      que.pb(mp(ch,a));\n      if(ch=='M') un[a]=a,app.insert(a);\n    }\n\n    reverse(ALL(que));\n    FOR(it,que){\n      if(it->F=='M') unit(it->S,pa[it->S]);\n      else ans+=find(it->S)+1;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int np){\n  p[v]=np;\n  if(!m[v]){\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],np);\n    }\n  }\n}\n\nvoid dfsa(int v,int pn){\n  if(!m[v]){\n    p[v]=pn;\n    for(int i=0;i<t[v].size();i++){\n      dfsa(t[v][i],pn);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    long long s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tm[v]=true;\n\tfor(int i=0;i<t[v].size();i++){\n\t  dfs(t[v][i],v);\n\t  //\t  dfsa(t[v][i],v);\n\t}\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nint par[MAX_N+1];//parents\nint Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint N,Q;\nlong long sum = 0;\nint tree[MAX_N+1];\n\nint nearestAncstr(int num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,int num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nint num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\ttree[0] = 0;\n\tfor(int i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tcin >>symbol >>num;num--;\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(true){\n\t\tif(symbol == '0' && num == 0)break;\n\t\toperate(symbol,num);\n\t\tcin >>symbol >>num;num--;\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\tcin >>N >>Q;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n \n//思路：并?集 + ? + ?列 （??取出方式） \n\nint parent[100016];\nint height[100005];\n\n//并?集 \nvoid init(int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(int x)\n{\n\tif(parent[x] == x)  return x;\n\telse  return parent[x] = find(parent[x]);\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)  return;\n\tif(height[x] < height[y])  parent[x] = y;\n\telse{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])  height[x]++;\n\t}\n}\n \nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n \n//用来描述原始? \nvector<int> children[100016];\nint parent_tree[100016];\nbool marked[100016];\nint ancestor[100016];\n// ?条指令被拆分? 操作 + 目?\nstack<char> operation;\nstack<int>  target;\n \nvoid bfs(int index, int the_ancestor)\n{\n\tqueue<int> q_index;\n\tqueue<int> q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile (!q_index.empty())\n\t{\n\t\tthe_ancestor = q_ancestor.front(); \n\t\tq_ancestor.pop();\n\t\tindex = q_index.front(); \n\t\tq_index.pop();\n\t\tif(marked[index] == true)  the_ancestor = index;  //如果?点自身被??，?它的染色祖先是自己，它的自己不??的儿子的最近染色祖先是它\n\t\tancestor[index] = the_ancestor;  //??index的最近染色祖先 \n\t\tfor(vector<int>::iterator it = children[index].begin(); it != children[index].end(); it++){  //将index的儿子加入?列 \n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n \nint main()\n{\n \n\tint N, Q;\n\twhile(scanf(\"%d %d\", &N, &Q) && (N || Q)){\n\t\tfor(int i = 1; i <= N; ++i){\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i] = false;\n\t\t}\n\t\tmarked[1] = true;\n\t\tparent_tree[1] = 1;\n\t\tint p;\n\t\tfor(int i = 2; i <= N; ++i){\n\t\t\tscanf(\"%d\", &p);\n\t\t\tparent_tree[i] = p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tgetchar(); \n\t\tfor(int i = 0; i < Q; ++i){\n\t\t\tchar ch;\n\t\t\tint t;\n\t\t\tscanf(\"%c %d\", &ch, &t);\n\t\t\tgetchar();\n\t\t\tif(ch == 'M')  marked[t] = true;\n\t\t\toperation.push(ch);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(1, 1);\n\t\tinit(N);\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tunite(i, ancestor[i]);\n\t\t}\n\t\tunsigned long long result = 0;\n\t\twhile(!operation.empty()){  //从后往前取出操作\n\t\t\tchar ch = operation.top(); \n\t\t\toperation.pop();\n\t\t\tint t = target.top(); \n\t\t\ttarget.pop();\n\t\t\tif(ch == 'Q')  result += ancestor[find(t)];  //?目index从1?始\n\t\t\telse{  //??点t反染色（取消染色），t的祖先??其父?点的祖先\n\t\t\t\tint p = ancestor[find(parent_tree[t])];\n\t\t\t\tunite(t, parent_tree[t]);\n\t\t\t\tancestor[find(t)] = p;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tconst int N;\n\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tint groups_;\n\tstd::vector< int > sizes;\n\npublic:\n\tUnionFind( int n ) : N( n ), parent( N ), rank( N, 0 ), groups_( N ), sizes( N, 1 )\n\t{\n\t\tstd::iota( parent.begin(), parent.end(), 0 );\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tbool unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t\tsizes[y] += sizes[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tsizes[x] += sizes[y];\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\t++rank[x];\n\t\t\t}\n\t\t}\n\n\t\t--groups_;\n\t\treturn true;\n\t}\n\n\tint groups() const\n\t{\n\t\treturn groups_;\n\t}\n\n\tint groupSize( const int x )\n\t{\n\t\treturn sizes[ find( x ) ];\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n// groups()\n// groupSize( x )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, Q; scanf( \"%d%d\", &N, &Q ), ( N | Q ); )\n\t{\n\t\tVI parents( N, -1 );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tscanf( \"%d\", &parents[i] );\n\t\t\t--parents[i];\n\t\t}\n\t\tVT( char ) types( Q );\n\t\tVI vs( Q );\n\t\tREP( i, Q )\n\t\t{\n\t\t\tscanf( \" %c%d\", &types[i], &vs[i] );\n\t\t\t--vs[i];\n\t\t}\n\t\t// end of input\n\n\t\tVI marked( N );\n\t\tmarked[0] = 1;\n\t\tREP( i, Q )\n\t\t{\n\t\t\tif ( types[i] == 'M' )\n\t\t\t{\n\t\t\t\t++marked[ vs[i] ];\n\t\t\t}\n\t\t}\n\t\tREP( i, N )\n\t\t{\n\t\t\tif ( !marked[i] )\n\t\t\t{\n\t\t\t\ttypes.PB( 'M' );\n\t\t\t\tvs.PB( i );\n\t\t\t\t++marked[i];\n\t\t\t}\n\t\t}\n\n\t\tVI answers( N );\n\t\tiota( ALL( answers ), 1 );\n\t\tUnionFind uf( N );\n\t\tLL res = 0;\n\t\tfor ( int i = SZ( types ) - 1; 0 <= i; --i )\n\t\t{\n\t\t\tconst char T = types[i];\n\t\t\tconst int v = vs[i];\n\n\t\t\tif ( T == 'M' )\n\t\t\t{\n\t\t\t\t--marked[v];\n\t\t\t\tif ( !marked[v] )\n\t\t\t\t{\n\t\t\t\t\tconst int p = parents[v];\n\t\t\t\t\tconst int na = answers[ uf.find( p ) ];\n\t\t\t\t\tuf.unite( v, p );\n\t\t\t\t\tanswers[ uf.find( v ) ] = na;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += answers[ uf.find( v ) ];\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%lld\\n\", res );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct EulerTour {\n  vector< vector<int> > graph;\n  vector<int> tour, s, t;\n  int idx, root;\n  EulerTour(){}\n  EulerTour(int n):idx(0), root(0), graph(n), s(n), t(n){}\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n  void dfs(int cur, int par) {\n    s[cur] = idx;\n    tour.push_back(cur);\n    idx++;\n    for(int to : graph[cur]) {\n      if(to == par) continue;\n      dfs(to, cur);\n    }\n    t[cur] = idx;\n  }\n  void build() {\n    dfs(root, -1);\n  }\n};\n\nEulerTour graph;\n\nstruct SegmentTree {\n  vector<int> data, lazy;\n  int sz;\n  SegmentTree(){}\n  SegmentTree(int n) {\n    sz = 1; while(sz < n) sz *= 2;\n    data.resize(2*sz-1, 0);\n    lazy.resize(2*sz-1, -1);\n  }\n  void push(int k, int l, int r) {\n    if(~lazy[k]) {\n      chmax(data[k], lazy[k]);\n      if(r - l > 1) {\n\tchmax(lazy[2*k+1], lazy[k]);\n\tchmax(lazy[2*k+2], lazy[k]);\n      }\n      lazy[k] = -1;\n    }\n  }\n  void update(int a, int b, int x, int k, int l, int r) {\n    push(k, l, r);\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) {\n      lazy[k] = x;\n      push(k, l, r);\n      return;\n    }\n    update(a, b, x, 2*k+1, l, (l+r)/2);\n    update(a, b, x, 2*k+2, (l+r)/2, r);\n  }\n  void update(int a, int b, int x) {\n    update(a, b, x, 0, 0, sz);\n  }\n  int query(int i, int k, int l, int r) {\n    push(k, l, r);\n    if(r - l == 1) return data[k];\n    if(l <= i && i <= r) {\n      if(i < (l+r)/2) return query(i, 2*k+1, l, (l+r)/2);\n      else return query(i, 2*k+2, (l+r)/2, r);\n    }\n    return -1;\n  }\n  int query(int i) {\n    return query(i, 0, 0, sz);\n  }\n};\n\nint N, Q;\nSegmentTree seg;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> Q, N || Q) {\n    graph = EulerTour(N);\n    rep(i, N-1) {\n      int p; cin >> p; --p;\n      graph.add_edge(p, i+1);\n    }\n    graph.build();\n    seg = SegmentTree(N);\n    int ans = 0;\n    rep(i, Q) {\n      char c; int v;\n      cin >> c >> v; --v;\n      if(c == 'M') {\n\tseg.update(graph.s[v], graph.t[v], graph.s[v]);\n      } else if(c == 'Q') {\n\tans += graph.tour[seg.query(graph.s[v])]+1;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct uni {\n  int p[111111];\n  uni(){memset(p,-1,sizeof(p));}\n  int root(int a){return p[a]<0?a:(p[a]=root(p[a]));}\n  bool find(int a,int b){return root(a)==root(b);}\n  // aをbの親に\n  void merge(int a,int b){if(!find(a,b))p[root(b)]=root(a);}\n};\n\nint p[111111];\nint m[111111];\nint Q[111111];\nint Qm[111111];\nint Qi[111111];\nint Qc,Qmc;\nint main(void)\n{\n  int n,q;\n  long long res;\n  for(;;) {\n    scanf(\"%d%d\",&n,&q); if(n+q==0)return 0;\n    uni u;\n    memset(m,-1,sizeof(m));\n    res = 0;\n    Qc = 0;\n    Qmc = 0;\n    m[0] = 0;\n    for(int i = 0; i < n-1; i++) {\n      int a; scanf(\"%d\",&a);\n      p[i+1] = a-1;\n    }\n    for(int i = 0; i < q; i++) {\n      char c;int a; scanf(\" %c%d\",&c,&a);\n      --a;\n      if(c=='Q') {\n        Qi[Qc] = i;\n        Q[Qc++] = a;\n      } else {\n        if(m[a] < 0) {\n          m[a] = i;\n          Qm[Qmc++] = a;\n        }\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      if(m[i]<0) u.merge(p[i],i);\n    }\n    while(Qmc--) {\n      while( Qc && Qi[Qc-1] > m[Qm[Qmc]] ) {\n        Qc--;\n        res += u.root(Q[Qc])+1;\n      }\n      u.merge(p[Qm[Qmc]],Qm[Qmc]);\n    }\n    \n    res += Qc;\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<bool, int> bi;\nint T[100000];\nbool marked[100000];\nint N;\nint dfs(int v){\n    if(marked[v])\n      return v;\n    else\n      return dfs(T[v]);\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int Q, _t;\n    char _c;\n    while(cin >> N >> Q && N){\n        vector<bi> query;\n        memset(marked, 0, sizeof(marked));\n        REP(i, 1, N){\n            cin >> _t; _t--;\n            T[i] = _t;\n        }\n        marked[0] = true;\n        int sum = 0;\n        rep(i, Q){\n            cin >> _c >> _t; _t--;\n            if(_c == 'Q')\n                sum += dfs(_t) + 1;\n            else\n              marked[_t] = true;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[i+1].emplace_back(p, 1);\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tvector<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tint sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.push_back(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, pii>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), pii(*u, -1));\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tconst pii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second.first;\n\t\t\t\t\tconst int p = que.front().second.second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v].first <= c.first) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tFOR(e, g[v])if(e->first!=p)\n\t\t\t\t\t\tque.emplace(pii(c.first+1, c.second), pii(e->first, v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint mark[MAX_N];\n\nmap<int,vector<int> > child;\nvoid dfs(int start,int root){\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n\n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        int ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct SkewHeap {\n    struct Node {\n        Node *left, *right;\n        int dat;\n        Node(int x) : left(nullptr), right(nullptr), dat(x) {}\n    };\n    Node *root;\n    int sz;\n    SkewHeap() : root(nullptr) {}\n\n    Node *meld(Node *a, Node *b) {\n        if (a == nullptr) return b;\n        if (b == nullptr) return a;\n        if (a->dat < b->dat) swap(a, b);\n        a->right = meld(a->right, b);\n        swap(a->left, a->right);\n        return a;\n    }\n\n    /// \n    const int &top() const {\n        return root->dat;\n    }\n    int size() const {\n        return sz;\n    }\n    void push(int x) {\n        Node *p = new Node(x);\n        root = meld(root, p);\n        ++sz;\n    }\n    void pop() {\n        Node *p = root;\n        root = meld(root->right, root->left);\n        delete p;\n        --sz;\n    }\n    void meld(SkewHeap &other) {\n        root = meld(root, other.root);\n    }\n};\n\n\nvector<int> children[100010];\nSkewHeap query[100010];\nint markedAt[100010];\nusing ll = long long;\n\nll pull(int v) {\n    ll res = 0;\n    for (int c : children[v]) {\n        res += pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            query[v].push(query[c].top());\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        res += v + 1;\n        query[v].pop();\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(markedAt, markedAt + n, 1e9);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        cout << pull(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\n\n//&#36755;入\nint N, Q;\n\nint par[MAX_N + 1];\t\t\t\t//父&#32467;点\nbool marked[MAX_N + 1];\t\t\t//&#26631;&#35760;&#32467;点\n\nvoid init(){\n\t//初始化\n\tpar[1] = 1;\n\tmemset(marked, 0, sizeof(marked));\n\tmarked[1] = true;\n\tfor(int i = 2; i <= N; i ++)\n\t\tscanf(\"%d\", &par[i]);\n}\n\nint find(int x){\n\t//找到最近被&#26631;&#35760;的父&#32467;点\n\tif(marked[x])return x;\n\telse return find(par[x]);\n}\n\nvoid solve(){\n\tint ans = 0;\n\tfor(int i = 0; i < Q; i ++){\n\t\tgetchar();\n\t\tchar c;\n\t\tint v;\n\t\tscanf(\"%c %d\", &c, &v);\n\t\tif(c == 'M'){\n\t\t\tmarked[v] = true;\n\t\t}\n\t\telse{\n\t\t\tans += find(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(int argc, char const *argv[]){\n\n\twhile(scanf(\"%d %d\", &N, &Q)){\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tinit();\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    lowmark[0]=1;\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n\tcontinue;\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r+3 && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(int i=0;i<2*r;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nint n,q,tree[100010];\n\nint find(int x){\n  if(tree[x]==x) return x;\n  return tree[x]=find(tree[x]);\n}\n\nint main(){\n\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q)break;\n\n\n    char ch[100010];\n    int num[100010],par[100010];\n    tree[1]=1;\n\n    for(int i=2;i<=n;i++)scanf(\"%d\",&tree[i]),par[i]=tree[i];\n    \n\n    for(int i=0;i<q;i++){\n      cin>>ch[i]>>num[i];\n      if(ch[i]=='M')tree[num[i]]=num[i];\n    }\n\n    long long ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(ch[i]=='M') tree[num[i]]=par[num[i]];\n      if(ch[i]=='Q') ans+=find(num[i]);\n    }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint s[100001];\nint N, Q;\nint p[100001];\nint operation[100001];\nint mark_time[100001];\n\nint find_root(int i);\n\nint find_p_root(int i)\n{\n\tif (s[i]==0) {\n\t\ts[i] = find_p_root(p[i]);\n\t\treturn s[i];\n\t}\n\telse if (s[i]!=-i) {\n\t\ts[i] = find_root(s[i]);\n\t\treturn s[i];\n\t}\n\telse\n\t\treturn i;\n\n}\n\nint find_root(int i)\n{\n\tif (s[i]!=-i) {\n\t\ts[i] = find_root(s[i]);\n\t\treturn s[i];\n\t}\n\telse\n\t\treturn i;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &Q)==2) {\n\t\tif (N==0 && Q==0) break;\n\t\tint i;\n\t\tp[1] = 1;\n\t\tfor (i=2; i<=N; i++) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tchar c;\n\t\tfor (i=0; i<Q; i++) {\n\t\t\tdo { c = getchar();\n\t\t\t} while (c!='M' && c!='Q');\n\t\t\tscanf(\"%d\", &operation[i]);\n\t\t\tif (c=='Q')\n\t\t\t\toperation[i] = -operation[i];\n\t\t}\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\ts[i] = 0;\n\t\t\tmark_time[i]=0;\n\t\t}\n\t\ts[1] = -1;\n\t\tmark_time[1]=1;\n\t\tfor (i=0; i<Q; i++) {\n\t\t\tif (operation[i]>0) {\n\t\t\t\ts[operation[i]] = -operation[i];\n\t\t\t\tmark_time[operation[i]]++;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (s[i]==0) {\n\t\t\t\tint root = find_p_root(i);\n\t\t\t\ts[i] = root;\n\t\t\t}\n\t\t}\n\n\t\tlong long sum = 0;\n\t\tfor (i=Q-1; i>=0; i--) {\n\t\t\tif (operation[i]<0) {\n\t\t\t\tint root = find_root(-operation[i]);\n\t\t\t\tsum += root;\n\t\t\t}\n\t\t\telse if (operation[i]>0) {\n\t\t\t\tif (--mark_time[operation[i]]==0) {\n\t\t\t\t\tint parent = p[operation[i]];\n\t\t\t\t\ts[operation[i]] = parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint N,Q;\nint pa[100010];\npair<char,int> que[100010];\nvector<int> ch[100010];\nbool mark[100010];\nint qpa[100010];\n\nint find(int x){\n  vector<int> st;\n  while(true){\n    //cout << x << ' ' << mark[x] << endl;\n    if(mark[x]) break;\n    st.pb(x);\n    x=qpa[x];\n  }\n  FOR(it,st) qpa[*it] = x;\n  return x;\n}\n\nvoid solve(){\n  CLR(mark);\n  rep(i,N) ch[i].clear();\n  rep(i,N-1) {\n    cin >> pa[i+1];\n    --pa[i+1];\n    ch[pa[i+1]].pb(i+1);\n  }\n\n  rep(i,Q){\n    cin >> que[i].F >> que[i].S;\n    --que[i].S;\n    if(que[i].F=='M') mark[que[i].S]=1;\n  }\n  mark[0]=1;\n  reverse(que,que+Q);\n  queue<PI> q;\n  q.push(mp(0,0));\n  while(!q.empty()){\n    int cv=q.front().F;\n    int ma=q.front().S;\n    q.pop();\n    qpa[cv]=ma;\n    //cout << cv << ' ' << ma << endl;\n    FOR(it,ch[cv]) q.push(mp(*it,mark[*it]?*it:ma));\n  }\n  \n  ll ans=0;\n  rep(i,Q){\n    //cout << que[i].F << ' ' << que[i].S << endl;\n    if(que[i].F=='Q'){\n      //cout << find(pa[que[i].S])+1 << endl;\n      ans += find(que[i].S)+1;\n    }else{\n      mark[que[i].S]=0;\n      qpa[que[i].S]=find(pa[que[i].S]);\n    }\n  }\n  \n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> Q && N) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 1e5 + 10;\n\nstruct UnionFind{\n\tvector<int> par;\n\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trep(i, n) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tpar[find(x)] = find(y);\n\t}\n};\n\nint p[N], qv[N];\nchar qc[N];\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n){\n\t\tFOR(i, 1, n) cin >> p[i], --p[i];\n\t\trep(i, q) cin >> qc[i] >> qv[i], --qv[i];\n\t\tset<int> s;\n\t\trep(i, q){\n\t\t\tif (qc[i] == 'M') s.insert(qv[i]);\n\t\t}\n\n\t\tUnionFind uf(n);\n\n\t\trep(i, n) if (!s.count(i)) uf.unite(i, p[i]);\n\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; --i){\n\t\t\tif (qc[i] == 'M'){\n\t\t\t\tuf.unite(qv[i], p[qv[i]]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += uf.find(qv[i]) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\nvector <ll> par;\nvector <bool> ism;\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\treverse(all(q));\n\n\t\trep(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (!ism[par[q[i].snd]]) {\n\t\t\t\tpar[q[i].snd] = par[par[q[i].snd]];\n\t\t\t}\n\t\t\tans += par[q[i].snd] + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n\nint const M = 1000100;\n\nint N,Q;\nint par[M];\nvector<int> ch[M];\nchar q[M];\nint v[M];\nbool use[M];\nbool flg[M];\nint g[M];\nbool marked[M];\nint top[M]; // グループ→グループの根\n\n// markを外すときにunionしていく。\n// その際、グループ→グループの根の表を更新する\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nUnionFind uf(0);\n\nvoid rec(int v){\n    for(int c : ch[v]){\n        if(marked[c]){\n            g[c] = c;\n        } else {\n            g[c] = g[v];\n            uf.unionSet(c,v);\n        }\n        rec(c);\n    }\n}\n\nint solve(){\n    rep(i,N+1) flg[i] = false;\n    rep(i,Q)if(q[i]=='M'){\n        if(flg[v[i]]) use[i] = false;\n        else {\n            use[i] = true;\n            flg[v[i]] = true;\n        }\n    }\n    marked[1] = true;\n    per(i,Q)if(use[i]){\n        marked[v[i]] = true;\n    }\n\n    uf = UnionFind(N+1);\n    par[1] = 1;\n    g[1] = 1;\n    rec(1);\n\n    rep(i,N+1)if(i){\n        top[uf.root(i)] = g[i];\n    }\n\n    int ans = 0;\n    per(i,Q)if(use[i] || q[i]=='Q'){\n        if(q[i]=='M'){\n            top[uf.root(v[i])] = top[uf.root(par[v[i]])];\n            uf.unionSet(v[i], par[v[i]]);\n        } else {\n            ans += top[uf.root(v[i])];\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>Q && N){\n        rep(i,N-1){\n            int v; cin>>v;\n            par[i+2] = v;\n            ch[v].push_back(i+2);\n        }\n        rep(i,Q){\n            cin >> q[i] >> v[i];\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = (1<<17);\ntypedef pair<int,int> P;\nclass RMQ{\n  int n;\n  P dat[2*MAX_N-1];\n\npublic:\n  void init(int _n = MAX_N){ \n    n = 1;\n    while(n < _n) n *= 2;\n    fill(dat,dat+2*n-1,P(1,1));\n  }\n\n  int get(int k){\n    k += n - 1;\n    P ret = dat[k];\n    while(k > 0){\n      k = (k - 1) / 2;\n      ret = max( ret, dat[k] );\n    }\n    return ret.second;\n  }\n\n  void query(int a, int b,P x){ query(a, b, x, 0, 0, n);}\n  void query(int a, int b, P x, int k, int l, int r){\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) dat[k]=max(dat[k],x);\n    else{\n      query(a, b, x, k*2+1, l, (l+r)/2);\n      query(a, b, x, k*2+2, (l+r)/2, r);      \n    }\n  }\n};\n\nRMQ seg;\nvector<int> G[100003];\nP L[100003];\nint R[100003];\nint cnt;\nvoid dfs(int id,int h){\n  L[id] = P(cnt++,h); \n  for(int i=0;i<(int)G[id].size();i++){\n    dfs(G[id][i],h+1);\n  }\n  R[id] = cnt;\n}\n\nint main(){\n  int n,q;\n  while(cin >> n >> q && (n||q) ){\n    seg.init(n+1);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=2;i<=n;i++){\n      int p; cin >> p;\n      G[p].push_back( i );\n    }\n    cnt = 0;\n    dfs(1,0);\n    long long res = 0;\n    for(int i=0;i<q;i++){\n      char c; cin >> c;\n      int d; cin >> d;\n      if( c  == 'Q' ){\n\tres += (long long)seg.get(L[d].first);\n      } else {\n\tseg.query(L[d].first,R[d],P(L[d].second,d));\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint parent[100001];\nint ans[100001];\npair<char,int> query[100001];\n\nvoid Init(int n){\n\n    for(int i=1;i<=n;++i)\n        ans[i] = parent[i];\n\n}\n\nint Find(int x){ \n    \n    return x==ans[x]?x:(ans[x]=Find(ans[x])); \n\n}\n\nvoid Union(int x, int y){\n   \n    ans[Find(x)] = Find(y); \n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    while(1){\n\n        int N,Q;\n        cin >> N >> Q;\n\n        if(N==0 && Q==0)break;\n\n        parent[1] = 1;\n\n        for(int i=2;i<=N;++i){\n\n            int x;\n\n            cin >> x;\n\n            parent[i] = x;\n\n        }\n\n        Init(N);\n\n        int cnt = 0;\n\n        for(int i=0;i<Q;++i){\n\n            string str;\n            int x;\n\n            cin >> str >> x;\n\n            if(str[0]=='M' && ans[x] == x)continue;\n\n            query[cnt].first  = str[0];\n            query[cnt].second = x;\n            ++cnt;\n\n            if(str[0]=='M') ans[x] = x;\n\n        }\n\n        long long sum = 0;\n\n        for(int i=cnt-1;i>=0;--i){\n\n            pair<char,int> p = query[i];\n\n            if(p.first == 'Q'){\n\n                sum += Find(p.second);\n\n            } else {\n\n                Union(p.second, parent[p.second]);\n\n            }\n\n        }\n       \n        cout << sum << endl;\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n\nint to[123456];\nchar o[123456];\nint v[123456];\n\nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n\n  bool findset(int x,int y)\n  {\n    return root(x) == root(y);\n  }\n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void sep(int x){\n    data[x] = -1;\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    memset(to,0,sizeof(to));\n    memset(o,0,sizeof(o));\n    memset(v,0,sizeof(v));\n    unionfind uf(n+10);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+2] = a;\n      uf.unionset(i+2,a);\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      if(o[i]=='M'){\n        uf.sep(v[i]);\n      }    \n    }\n    int sum = 0;\n    \n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i]);\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nint parent[MAX_N+1];\nchar op[MAX_N+1];\nint node[MAX_N+1];\nbool marked[MAX_N+1];\n\nvoid init()\n{\n  marked[1] = true;\n  for (int i = 2; i <= N; i++)\n  {\n    marked[i] = false;\n  }\n}\n\nint find(int x)\n{\n  if (marked[x]) return x;\n  else return find(parent[x]);\n}\n\nint main()\n{\n  parent[1] = 1;\n\n  while(1)\n  {\n    cin >> N >> Q;\n    if (N == 0 && Q == 0)\n    {\n      return 0;\n    }\n    for(int i=2; i<=N; i++)\n    {\n      scanf(\"%d\", &parent[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n      cin >> op[i] >> node[i];\n    }\n\n    init();\n\n    int ans = 0;\n    for(int i = 0; i < Q; i++)\n    {\n      switch (op[i]) {\n      case 'Q':\n        ans += find(node[i]);\n        break;\n      case 'M':\n        marked[node[i]] = true;\n        break;\n      default:\n        break;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int maxn = 100005;\nint par[maxn];\n\nvoid init() {\n\tfor (int i = 0; i < maxn; i++) {\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x) {\n\twhile (par[x] != x) x = par[x];\n\treturn par[x];\n}\n\nint main() {\n\tfreopen(\"aoj2170.txt\", \"r\", stdin);\n\twhile (1) {\n\t\tint n, q;\n\t\tscanf(\"%d%d\", &n, &q);\n\t\tif (n == 0) break;\n\n\t\t//init();\n\t\tpar[1] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tpar[i+1] = t;\n\t\t}\n\n\t\tlong long res = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tchar c;\n\t\t\tint t;\n\t\t\tgetchar();\n\t\t\tscanf(\"%c%d\", &c, &t);\n\t\t\tif ('Q' == c) {\n\t\t\t\tres += find(t);\n\t\t\t} else {\n\t\t\t\tpar[t] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    int node = n;\n    while(flag[t[node]] != 1 )\n\t{\n\t    node = t[node];\n\t}\n    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n//#ifndef ONLINE_JUDGE\n//    READ;\n//#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 0;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    if(ch == 'M')\n\t\tflag[tmp] = 1;\n\t    if(ch == 'Q')\n\t\tret = ret + find(tmp);\n\t}\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define N 100005\n\ntypedef long long ll;\n\nint parents[N];\n\nint find(int x){\n        if (x == parents[x]) return x;\n        else return find(parents[x]);\n}\n\nint main(){\n        int n, q;\n        while(~scanf(\"%d %d\", &n, &q)){\n                if (n == 0 && q == 0) break;\n                for (int i = 2; i <= n; i++){\n                        scanf(\"%d\", &parents[i]);\n                }\n                parents[1] = 1;\n                ll sum = 0;\n                char c;\n                int x;\n                for (int i = 0; i < q; i++){\n                        getchar();\n                        scanf(\"%c %d\", &c, &x);\n                        if (c == 'Q') sum += find(x);\n                        else parents[x] = x;\n                }\n                printf(\"%lld\\n\", sum);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint tpar[100000],par[100000];\nbool mark[100000];\nint search(int a){\n    if(mark[a]) return a;\n    else return search(tpar[a]);\n}\nint find(int a){\n    if(par[a]==a) return a;\n    else return par[a]=find(par[a]);\n}\nvoid unite(int a,int b){\n    par[find(a)]=find(b);\n}\nint main(){\n    int N,Q;\n    for(;;){\n        scanf(\"%d %d\\n\",&N,&Q);\n        if(N==0 && Q==0) break;\n        tpar[0]=0;\n        int p;\n        for(int i=1;i<N;i++){\n            scanf(\"%d\\n\",&p);\n            tpar[i]=p-1;\n        }\n        fill(mark,mark+N,false);\n        mark[0]=true;\n        char q;\n        int a;\n        vector<pair<char,int>> query;\n        for(int i=0;i<Q;i++){\n            scanf(\"%c %d\\n\",&q,&a);\n            a--;\n            query.PB(MP(q,a));\n            if(q=='M') mark[a]=true;\n        }\n        for(int i=0;i<N;i++){\n            par[i]=search(i);\n        }\n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            int now=query[i].second;\n            if(query[i].first=='Q') ans+=find(tpar[now])+1;\n            else unite(find(now),tpar[find(now)]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define si(x) int(x.size())\n#define double long double\nconst int mod=1000000007,MAX=100005,INF=1<<29;\n\nint idx[MAX],ridx[MAX];\nvector<int> G2[MAX];\n\nvoid init(){\n    idx[0]=0;\n    ridx[0]=1;\n    queue<int> Q;\n    Q.push(0);\n    int k=1;\n    \n    while(!Q.empty()){\n        auto u=Q.front();Q.pop();\n        for(int to:G2[u]){\n            idx[to]=k;\n            ridx[k]=to+1;\n            k++;\n            Q.push(to);\n        }\n    }\n}\n\nstruct HeavyLightDecomposition{\n    int n;\n    vector<int> sz,in,out,nxt,par;\n    vector<vector<int>> G;\n    \n    HeavyLightDecomposition(int n_){\n        n=n_;\n        sz.assign(n,0);\n        in.assign(n,0);\n        out.assign(n,0);\n        nxt.assign(n,0);\n        par.assign(n,0);\n        G.assign(n,vector<int>());\n    }\n    \n    void add_edge(int u,int v){\n        G[u].push_back(v);\n        //G[v].push_back(u);\n    }\n    \n    void dfs_sz(int u,int p){\n        par[u]=p;\n        sz[u]=1;\n        if(G[u].size()&&G[u][0]==p) swap(G[u][0],G[u].back());\n        for(auto &a:G[u]){\n            if(a==p) continue;\n            dfs_sz(a,u);\n            sz[u]+=sz[a];\n            if(sz[a]>sz[G[u][0]]){\n                swap(a,G[u][0]);\n            }\n        }\n    }\n    \n    void dfs_hld(int u,int p,int &t){\n        in[u]=t++;\n        for(auto a:G[u]){\n            if(a==p) continue;\n            nxt[a]=(a==G[u][0] ? nxt[u] : a);\n            dfs_hld(a,u,t);\n        }\n        out[u]=t;\n    }\n    \n    void build(int u){\n        int t=0;\n        dfs_sz(u,-1);\n        dfs_hld(u,-1,t);\n    }\n    \n    int lca(int u,int v){\n        if(in[u]>in[v]) swap(u,v);\n        if(nxt[u]==nxt[v]) return u;\n        return lca(u,par[nxt[v]]);\n    }\n};\n\ntemplate<typename T,typename E>\nstruct LazySegmentTree{\n    using F=function<T(T,T)>;\n    using G=function<T(T,E)>;\n    using H=function<E(E,E)>;\n    \n    int n;\n    vector<T> dat;\n    vector<E> lazy;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    \n    LazySegmentTree(int n_,F f,G g,H h,T ti,E ei) :f(f),g(g),h(h),ti(ti),ei(ei){\n        n=1;\n        while(n<n_) n*=2;\n        dat.assign(2*n-1,ti);\n        for(int i=n-2;i>=0;i--) dat[i]=f(dat[i*2+1],dat[i*2+2]);\n        \n        lazy.assign(2*n-1,ei);\n    }\n    \n    LazySegmentTree(int n_,vector<T> &v,F f,G g,H h,T ti,E ei) :f(f),g(g),h(h),ti(ti),ei(ei){\n        n=1;\n        while(n<n_) n*=2;\n        dat.assign(2*n-1,ti);\n        \n        for(int i=n-1;i-(n-1)<v.size();i++) dat[i]=v[i-(n-1)];\n        \n        for(int i=n-2;i>=0;i--) dat[i]=f(dat[i*2+1],dat[i*2+2]);\n        \n        lazy.assign(2*n-1,ei);\n    }\n    \n    inline void eval(int k,int l,int r){\n        \n        if(lazy[k]==ei) return;\n        \n        dat[k]=g(dat[k],lazy[k]);\n        \n        if(r-l>1){\n            lazy[k*2+1]=h(lazy[k*2+1],lazy[k]);\n            lazy[k*2+2]=h(lazy[k*2+2],lazy[k]);\n        }\n        \n        lazy[k]=ei;\n    }\n    \n    void update_(int a,int b,E x,int k,int l,int r){\n        \n        eval(k,l,r);\n        \n        if(r<=a||b<=l) return;\n        \n        if(a<=l&&r<=b){\n            lazy[k]=h(lazy[k],x);\n            eval(k,l,r);\n        }\n        \n        else{\n            update_(a,b,x,2*k+1,l,(l+r)/2);\n            update_(a,b,x,2*k+2,(l+r)/2,r);\n            dat[k]=f(dat[2*k+1],dat[2*k+2]);\n        }\n        \n    }\n    \n    void update(int a,int b,E x){\n        return update_(a,b,x,0,0,n);\n    }\n    \n    T query_(int a,int b,int k,int l,int r){\n        \n        eval(k,l,r);\n        \n        if(r<=a||b<=l) return ti;\n        if(a<=l&&r<=b) return dat[k];\n        \n        T vl=query_(a,b,2*k+1,l,(l+r)/2);\n        T vr=query_(a,b,2*k+2,(l+r)/2,r);\n        return f(vl,vr);\n    }\n    \n    T query(int a,int b){\n        return query_(a,b,0,0,n);\n    }\n    \n};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,Q;cin>>N>>Q;\n        if(N+Q==0) break;\n        HeavyLightDecomposition hld(N);\n        LazySegmentTree<int,int> seg(N,\n                                     [](int a,int b){return max(a,b);},\n                                     [](int a,int b){return max(a,b);},\n                                     [](int a,int b){return max(a,b);},\n                                     0,\n                                     0);\n        \n        seg.update(0,N,0);\n        \n        for(int i=0;i<N;i++){\n            idx[i]=INF;\n            ridx[i]=INF;\n            G2[i].clear();\n        }\n        \n        vector<pair<int,int>> edge(N-1);\n        \n        for(int i=1;i<N;i++){\n            int p;cin>>p;\n            p--;\n            edge[i-1]={p,i};\n            G2[p].push_back(i);\n        }\n        init();\n        \n        for(int i=0;i<N-1;i++){\n            int a=idx[edge[i].fi],b=idx[edge[i].se];\n            hld.add_edge(a,b);\n        }\n        hld.build(0);\n        \n        ll ans=0;\n        \n        for(int q=0;q<Q;q++){\n            char c;cin>>c;\n            int x;cin>>x;\n            x--;\n            x=idx[x];\n            if(c=='M'){\n                seg.update(hld.in[x],hld.out[x],x);\n            }else{\n                ans+=ridx[seg.query(hld.in[x],hld.in[x]+1)];\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n    \n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* vim: set st=2 sts=2 : */\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<char,int> P;\n\nint N,Q;\nbool mark[100000];\nint tree[100000];\nP query[100000];\n\nint get(int i){\n  if(mark[i]) return i;\n  return tree[i]=get(tree[i]);\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c %d\",&query[i].first,&query[i].second);\n      query[i].second--;\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second]+=1;\n      }\n    }\n\n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      if(query[i].first=='M'){\n        mark[query[i].second]-=1;\n      }else{\n        c+=get(query[i].second)+1;\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> e[100000];\nint par[18][100000];\nint index[200000];\nint fapr[100000];\nint lapr[100000];\nint bit[200000];\nint bit_n;\nint n;\nvoid add(int i,int x){\n\twhile(i<bit_n){\n\t\tbit[i]+=x;\n\t\ti+=i&-i;\n\t}\n}\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-=i&-i;\n\t}\n\treturn s;\n}\nint dfs(int v,int k){\n\tindex[k]=v;\n\tfapr[v]=k++;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tk=dfs(e[v][i],k);\n\t\tindex[k++]=v;\n\t}\n\tlapr[v]=k-1;\n\treturn k;\n}\nint main(){\n\twhile(1){\n\tint q;\n\tint i,j;\n\tscanf(\"%d %d\",&n,&q);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;1<<j<n;j++)par[j][i]=-1;\n\tfor(i=0;i<n;i++)e[i].clear();\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d\",&par[0][i]);\n\t\tpar[0][i]--;\n\t\te[par[0][i]].push_back(i);\n\t}\n\tfor(i=1;1<<i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(par[i-1][j]==-1)continue;\n\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint m=i-1;\n\tdfs(0,1);\n\tbit_n=n*2;\n\tfor(i=0;i<bit_n;i++)bit[i]=0;\n\tadd(2,1);\n\tlong long ans=0;\n\tfor(i=0;i<q;i++){\n\t\tchar t;int v;\n\t\tscanf(\" %c %d\",&t,&v);\n\t\tv--;\n\t\tif(t=='M'){\n\t\t\tif(fapr[v]==lapr[v])continue;\n\t\t\tadd(fapr[v]+1,1);\n\t\t\tadd(lapr[v],-1);\n\t\t}else{\n\t\t\tint k=sum(fapr[v]);\n\t\t\tfor(j=m;j>=0;j--){\n\t\t\t\tif(par[j][v]==-1)continue;\n\t\t\t\tint s=sum(fapr[par[j][v]]);\n\t\t\t\tif(s==k){\n\t\t\t\t\tv=par[j][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=par[0][v]+1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (par[x] == x || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(p.second);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n, q, f[100005], sum;\nvoid init(int n)\n{\n    for (int i = 1; i <= n; i++)\n        f[i] = i;\n}\nint find(int v)\n{\n    if (f[v] == v)\n        return v;\n    else\n        return find(f[v]);\n}\nint main()\n{\n    while (scanf(\"%d %d\", &n, &q) != EOF)\n    {\n        if (n == 0 && q == 0)\n            break;\n        sum = 0;\n        init(n);\n        for (int i = 2; i <= n; i++)\n        {\n            int a;\n            scanf(\"%d\", &a);\n            f[i] = a;\n        }\n        for (int i = 0; i < q; i++)\n        {\n            getchar();\n            char c;\n            int a;\n            scanf(\"%c %d\", &c, &a);\n            if (c == 'M')\n                f[a] = a;\n            else if (c == 'Q')\n                sum += find(a);\n        }\n        printf(\"%d\\n\", sum);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nusing P = pair<char,int>;\nstruct union_find{\n    vector<int> par;\n    union_find(int n){\n        par = vector<int>(n);\n        init(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){//y???????????????\n        x = find(x);\n        y = find(y);\n        par[x]=y;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nint main(){\n    int N,Q;\n    while(cin>>N>>Q,N){\n        bool isMarked[100000];\n        int parent[100000];\n        fill(isMarked,isMarked+100000,false);\n        fill(parent,parent+100000,5000000);\n        parent[0]=0;\n        for(int i=1;i<N;i++){\n            int p;\n            cin>>p; p--;\n            parent[i]=p;\n        }\n        vector<P> V;\n        isMarked[0]=true;\n        for(int i=0;i<Q;i++){\n            char C;\n            int v;\n            cin>>C>>v; v--;\n            if(C=='Q'){\n                V.emplace_back(C,v);\n            }else if(!isMarked[v]){\n                isMarked[v]=true;\n                V.emplace_back(C,v);\n            }\n        }\n        union_find UF(N);\n        for(int i=1;i<N;i++){\n            if(!isMarked[i]) UF.unite(i,parent[i]);\n        }\n\n        reverse(V.begin(), V.end());\n        int64_t ans = 0;\n        for(auto p:V){\n            char C; int v;\n            tie(C,v)=p;\n            if(C=='Q'){\n                ans+=UF.find(v)+1;\n            }else{\n                if(v==0) cout<<'A'<<endl;\n                isMarked[v]=false;\n                UF.unite(v,parent[v]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nbool flag[MAX_N];\nint ran[MAX_N];\nvoid init(int n) {\n\tfor(int i=2; i<=n; i++) {\t\t\n\t\tflag[i] = false;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif(flag[x])\n\t\treturn x;\n\telse\n\t\tfind(par[x]);\n}\n\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tlong long sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tpar[1]= 1;\n\t\tflag[1] = true;\n\t\tinit(n);\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(par[p]);\n\t\t\t}else{\n\t\t\t\tflag[p] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int INF=0x3f3f3f3f;\n#define N 200005\n\nint p[N],m[N];\n\nint find(int x){\n\tif(m[x]!=0)return x;\n\telse return p[x]=find(p[x]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,q;\n\twhile(cin>>n>>q){\n\t\tif(n==0&&q==0)break;\n\t\tmemset(p,0,sizeof(p));\n\t\tmemset(m,0,sizeof(m));\n\t\tp[1]=1;\n\t\tm[1]=-1;\n\t\tfor (int i = 0; i < n-1; i++){\n\t\t\tcin>>p[i+2];\n\t\t}\n\t\tvector<pair<char,int>> st;\n\t\twhile(q--){\n\t\t\tchar t;\n\t\t\tint x;\n\t\t\tcin>>t>>x;\n\t\t\tst.push_back({t,x});\n\t\t\tif(t=='M'&&m[x]==0){\n\t\t\t\tm[x]=st.size();\n\t\t\t}\n\t\t}\n\t\tll sum=0;\n\t\tfor(int i=st.size()-1;i>=0;i--){\n\t\t\tif(st[i].fi=='M'){\n\t\t\t\tif(m[st[i].se]==i+1)m[st[i].se]=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum+=find(st[i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std;\n\nconst int maxn = 1e5+5;\nint pa[maxn];\nint Mrk[maxn];\n\nint qt[maxn],qv[maxn];\nint Qt;\nint fdst(int x)\n{\n    return Mrk[x] < Qt ? x :pa[x] = fdst(pa[x]);\n}\n\n\nint main()\n{\n    int N, Q;\n    while(scanf(\"%d%d\",&N,&Q),N){\n        for(int i = 2; i <= N; i++){\n            scanf(\"%d\",pa+i);\n            Mrk[i] = Q+1;\n        }\n        int c = 0;\n        for(int i = 1; i <= Q; i++){\n            char op[2];\n            int v;\n            scanf(\"%s%d\",op,&v);\n            if(*op == 'Q'){\n                qt[c] = i;\n                qv[c++] = v;\n            }else {\n                Mrk[v] = min(Mrk[v],i);//取最早生效的??\n            }\n        }\n        long long ans = 0;\n        while(c--){\n            Qt = qt[c];\n            ans += fdst(qv[c]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N = 100005;\nint par[N], flag[N];\nint find(int x)\n{\n\tif (flag[x] == 1)\n\t\treturn x;\n\telse\n\t\treturn find(par[x]);\n}\nint main()\n{\n\tint n, m;\n\tchar s[10];\n\twhile (~scanf(\"%d%d\", &n, &m))\n\t{\n\t\t__int64 ans;\n\t\tans = (__int64)0;\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\t\tpar[1] = 1;\n\t\tmemset(flag, 0, sizeof(flag));\n\t\tflag[1] = 1;\n\t\tint i, x;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\twhile (m--)\n\t\t{\n\t\t\tscanf(\"%s%d\", s,&x);\n\t\t\tif (s[0] == 'M')\n\t\t\t\tflag[x] = 1;\n\t\t\telse\n\t\t\t\tans += (__int64)find(x);\n\t\t}\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int gmax_n = 1000005;\n\nint par[gmax_n]; //???\nint dps[gmax_n];//??¨?????±???\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        dps[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == 0){\n        return x;\n    }\n    //show(x)\n    if(par[x] == x){\n        return x;\n    }else {\n        return find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    //x = find(x);\n    //y = find(y);\n    if(x == y) return;\n\n    if(dps[x] < dps[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(dps[x] == dps[y]) dps[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        init(n + 2);\n        unite(0, 1);\n        range(i,2,n + 1){\n            int inp;\n            cin >> inp;\n            unite(inp, i);\n        //rep(i, n + 2){ cout << dps[i] << ' '; }cout << endl;\n        }\n\n        int ans = 0;\n        rep(i,m){\n            char c;\n            int inp;\n            cin >> c >> inp;\n            if(c == 'M'){\n                unite(0, inp);\n            }else{\n                ans+= find(inp);\n            }\n        //rep(i, n + 2){ cout << dps[i] << ' '; }cout << endl;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    int n;\n    vector<int> parent; // 親ノード\n    vector<int> num;    // グループの要素数\npublic:\n    UnionFindTree(int n0){ // コンストラクタ\n        n = n0;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        num.assign(n, 1);\n    }\n    void unite(int x, int y){ // xとyのグループを併合\n        if((x = find(x)) != (y = find(y))){\n            parent[y] = x;\n            num[x] += num[y];\n            -- n;\n        }\n    }\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, q;\n        cin >> n >> q;\n        if(n == 0)\n            return 0;\n\n        vector<int> parent(n+1, -1);\n        for(int i=2; i<=n; ++i)\n            cin >> parent[i];\n\n        vector<char> ope(q);\n        vector<int> v(q);\n        vector<int> cnt(n+1, 0);\n        for(int i=0; i<q; ++i){\n            cin >> ope[i] >> v[i];\n            if(ope[i] == 'M')\n                ++ cnt[v[i]];\n        }\n\n        UnionFindTree uft(n+1);\n        for(int i=2; i<=n; ++i){\n            if(cnt[i] == 0)\n                uft.unite(parent[i], i);\n        }\n\n        long long ret = 0;\n        for(int i=q-1; i>=0; --i){\n            if(ope[i] == 'Q'){\n                ret += uft.find(v[i]);\n            }else if(-- cnt[v[i]] == 0){\n                uft.unite(parent[v[i]], v[i]);\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint par[100000];\nint mark[100000];\nint uf[100000];\nint root(int x){\n  if(uf[x] == x) return x;\n  return uf[x] = root(uf[x]);\n}\nint main(){\n  int N, Q;\n  while(cin>>N>>Q && N){\n    par[0] = 0;\n    uf[0] = 0;\n    mark[0] = 1;\n    REP(i, N - 1){\n      cin>>par[i + 1];\n      par[i + 1]--;\n      uf[i + 1] = par[i + 1];\n    }\n    memset(mark, 0, sizeof(mark));\n    char c[100000];\n    int v[100000];\n    REP(i, Q){\n      cin>>c[i]>>v[i];\n      v[i]--;\n      if(c[i] == 'M'){\n        mark[v[i]]++;\n      }\n    }\n    REP(i, N) if(mark[i] > 0){\n      uf[i] = i;\n    }\n    ll ans = 0;\n    for(int i = Q - 1; i >= 0; i--){\n      if(c[i] == 'M'){\n        mark[v[i]]--;\n        if(mark[v[i]] == 0){\n          uf[v[i]] = par[v[i]];\n        }\n      }else{\n        ans += root(v[i]) + 1;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N][2];\nchar Ope[MAX_N];\nint Openum[MAX_N];\n\nvoid mark(int x) {\n  for(int i = x+1; i <= N; i++){\n    if(x == Node[i][0]) {\n      Node[i][1] = x;\n      mark(i);\n    }\n  }\n}\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      mark(num);\n    }\n    \n    else if(ope == 'Q'){\n      ans += Node[num][1];\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  Node[1][0] = 1;\n  Node[1][1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i][0]);\n      Node[i][1] = 1;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint main()\n{\n\tchar op[3];\n\tint id,ans;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tans=0;\n\t\tSet[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=Root(Que[i][1]);\n\t\t\telse\n\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int maxn = 100005;\nint par[maxn];\nint n,q;\nvoid init()\n{\n\tmemset(par,0,sizeof(par));\n}\n\nint find(int x)\n{\n\treturn par[x] == x ? x : find(par[x]);\n}\n\nint main()\n{\n\tchar op[2];\n\tint x;\n\twhile(scanf(\"%d %d\",&n,&q) != EOF && (n || q)){\n\t\tinit();\n\t\tpar[1] = 1;\n\t\tfor(int i = 2;i <= n;i++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tlong long y = 0;\n\t\twhile(q--){\n\t\t\tscanf(\"%s\",op);\n\t\t\tif(op[0] == 'M'){\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tpar[x] = x;\n\t\t\t}else if(op[0] == 'Q'){\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\ty += find(x);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",y);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct Node {\n    int parent;\n    vi child;\n};\n\nvi ancestor;\nvector<Node> nodes;\n\nvoid mark(int v, int pos){\n    if(ancestor[pos] == pos) return;\n\n    ancestor[pos] = v;\n    \n    rep(i, nodes[pos].child.size()){\n        mark(v, nodes[pos].child[i]);\n    }\n}\n\nint main(void){\n    ll res;\n    for(int n, q; cin >> n >> q, n; cout << res << endl){\n        res = 0;\n        nodes = vector<Node>(n + 1);\n        ancestor = vi(n + 1, 1);\n\n        range(u, 2, n + 1){\n            int p; cin >> p;\n\n            nodes[u].parent = p;\n            nodes[p].child.pb(u);\n        }\n\n        rep(i, q){\n            char op; int v; cin >> op >> v;\n\n            if(op == 'M'){\n                mark(v, v);\n            }\n            else {\n                res += ancestor[v];\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nconst int MAX_N = 100000;\n\nint _par[MAX_N];\n\nint ancestor(vector<int>& parents, vector<int>& marked, int u){\n    int& p = parents[u];\n    if(marked[p])\n        return _par[u] = p;\n    return _par[u] = ancestor(parents, marked, p);\n}\n\nvoid init(vector<int>& parents, vector<int>& marked){\n    int n = marked.size();\n    for(int i=0; i<n; i++)\n        _par[i] = i;\n    \n    for(int i=1; i<n; i++){\n        if(marked[i]==0 && _par[i]==i)\n            ancestor(parents, marked, i);\n    }\n}\n\nint root(int u){\n    if(_par[u] == u)\n        return u;\n    return _par[u] = root(_par[u]);\n}\n\nint main(){\n    int N, Q;\n    while(cin >> N >> Q, N|Q){\n        vector<int> parents(N);\n        parents[0] = 0;\n        for(int i=1; i<N; i++){\n            cin >> parents[i];\n            parents[i]--;\n        }\n        \n        vector<pair<string, int>> operations(Q);\n        for(int i=0; i<Q; i++){\n            cin >> operations[i].first >> operations[i].second;\n            operations[i].second--;\n        }\n        \n        vector<int> marked(N);\n        marked[0] = 1;\n        for(auto& o : operations){\n            if(o.first == \"M\")\n                marked[o.second]++;\n        }\n        \n        init(parents, marked);\n        \n        long long int ans = 0;\n        for(int i=Q-1; i>=0; i--){\n            auto& o = operations[i];\n            int& u = o.second;\n            if(o.first == \"M\"){\n                if(--marked[u] == 0)\n                    _par[u] = parents[_par[u]];\n            }else if(o.first == \"Q\"){\n                ans += root(u) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(x);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nbool marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tscanf(\"%d\",fa+i);\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;marked[id]=1;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n#include <map>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <memory>\n\nusing namespace std;\n\n#if 1\n#define PRINT(x) { cout << #x << \": \" << (x) << endl; }\n#define PRINT_CONTAINER(x)  { cout << #x << \": \";                       \\\n        for (size_t ix = 0; ix < (x).size(); ++ix) cout << (x)[ix] << \", \"; \\\n        cout << endl; }\n#else\n#define PRINT(x)\n#define PRINT_CONTAINER(x)\n#endif\n\n#define MAX_N 100005\nint parent[MAX_N];\nint rank[MAX_N];\nint mark[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\n// find a root of tree\nint find(int x) {\n    if (parent[x] == x) return x;\n    if (mark[x]) return x;\n    return parent[x] = find(parent[x]);\n}\n\n// unite a group which includes x and a group which includes y\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) {\n            ++rank[x];\n        }\n    }\n}\n\n// check if x and y belong to the same group\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\ntypedef pair<char, int> p;\n\nint n, q;\nvector<p> qs;\n\nint main(int argc, char *argv[]) {\n    char buf[1024];\n    while (true) {\n        fgets(buf, 1024, stdin);\n        sscanf(buf, \"%d%d\", &n, &q);\n        //cout << n << \", \" << q << endl;\n        if (n == 0) break;\n        init(n);\n        memset(mark, 0, sizeof(mark));\n        qs.clear();\n        for (int i = 1; i < n; ++i) {\n            int par;\n            fgets(buf, 1024, stdin);\n            sscanf(buf, \"%d\", &par); --par;\n            //cout << i << \", \" << par << endl;\n            parent[i] = par;\n        }\n        for (int i = 0; i < q; ++i) {\n            fgets(buf, 1024, stdin);\n            char c;\n            int a;\n            sscanf(buf, \"%c %d\", &c, &a); --a;\n            //cout << c << \", \" << a << endl;\n            if (c == 'M') {\n                if (!mark[a])\n                {\n                    qs.push_back(p(c, a));\n                    mark[a] = 1;\n                }\n            } else {\n                qs.push_back(p(c, a));\n            }\n        }\n        long long int sum = 0;\n        for (int i = qs.size()-1; i >= 0; --i)\n        {\n            //cout << qs[i].first << \", \" << qs[i].second << endl;\n            if (qs[i].first == 'M') {\n                mark[qs[i].second] = 0;\n            } else {\n                int t = find(qs[i].second);\n                //cout << t << endl;\n                sum += t + 1;\n            }\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <utility>\n\nusing namespace std;\n\nint N, Q;\npair<char, int> S[100000];\nint parent[100001];\nint set[100001];\n\nint findRoot(int p) {\n  int root = p;\n  while (set[root] != -1) {\n    root = set[root];\n  }\n  while (p != root) {\n    int t = set[p];\n    set[p] = root;\n    p = t;\n  }\n  return root;\n}\n\nvoid unionSet(int p, int q) {\n  int root1 = findRoot(p);\n  int root2 = findRoot(q);\n  if (root1 != root2) {\n    set[root1] = root2;\n  }\n}\n\nint main() {\n  //freopen(\"MarkedAncestor.in\", \"r\", stdin);\n  //freopen(\"2170-input.txt\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &Q) == 2 && !(N == 0 && Q == 0)) {\n    parent[1] = 1;\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%d\", &parent[i]);\n    }\n    set[1] = -1;\n    for (int i = 2; i <= N; ++i) {\n      set[i] = parent[i];\n    }\n    for (int i = 0; i < Q; ++i) {\n      char buf[10];\n      scanf(\"%s%d\", buf, &S[i].second);\n      S[i].first = buf[0];\n      if (S[i].first == 'M') {\n        set[S[i].second] = -1;\n      }\n    }\n    long long sum = 0;\n    // From back to front.\n    for (int i = Q - 1; i >= 0; --i) {\n      if (S[i].first == 'M') {\n        unionSet(S[i].second, parent[S[i].second]);\n      } else if (S[i].first == 'Q') {\n        int v = findRoot(parent[S[i].second]);\n        //printf(\"findRoot(%d) = %d\\n\", S[i].second, v);\n        sum += v;\n      }\n    }\n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\nbool marked[MAX_N+5];\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n        marked[i] = false;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nvoid show_par() {\n    for(int i = 1; i <= N; i++) {\n        cout << i << \": \" << par[i] << \", \";\n    }\n    cout << endl;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par2[i] = p;\n        }\n        vector<P> v;\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                marked[t] = true;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            v.push_back(q);\n        }\n\n        // solve\n        for(int i = 1; i <= N; i++) {\n            if(!marked[i]) unite(par2[i], i);\n        }\n        long long int ans = 0;\n        // show_par();\n        for(int i = v.size()-1; i >= 0; i--) {\n            if(v[i].first == 'M') {\n                unite(par2[v[i].second], v[i].second);\n            } else {\n                ans += find(v[i].second);\n            }\n            // cout << v[i].first << \" \" << v[i].second << endl;\n            // show_par();\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define vec vector\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define brep(i, n) for (int i = (int)n - 1; i >= 0; i--)\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\nvec<int> p;\n\nint root(int a)\n{\n\tif (p[a] == a) return a;\n\tp[a] = root(p[a]);\n\treturn p[a];\n}\n\nvoid unite(int a, int b)\n{\n\tp[root(a)] = root(b);\n}\n\nbool is_same(int a, int b)\n{\n\treturn root(a) == root(b);\n}\n\nvoid init(int n)\n{\n\tp.resize(n);\n\trep(i, n) p[i] = i;\n}\n\nint main(void)\n{\n\twhile(1) {\n\tint n, q;\n\tcin >> n >> q;\n\tif (!n && !q) break;\n\tinit(n);\n\tvec<int> keep(n);\n\trep(i, n - 1) {\n\t\tint get;\n\t\tcin >> get;\n\t\tget--;\n\t\tp[i + 1] = get;\n\t}\n\tkeep = p;\n\n\tvec<pii> query(q);\n\trep(i, q) {\n\t\tchar c;\n\t\tint v;\n\t\tcin >> c >> v;\n\t\tv--;\n\t\tint get;\n\t\tif (c == 'Q') get = 0;\n\t\telse get = 1;\n\t\tquery[i] = mp(get, v);\n\t\tif (get) p[v] = v;\n\t}\n\n\tll sum = 0;\n\tbrep(i, q) {\n\t\tif (!query[i].first) sum += (ll)root(query[i].second) + 1;\n\t\telse unite(query[i].second, keep[query[i].second]);\n\t}\n\n\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n//unionfind??????????????\\??????????????????????????´???\nstruct UnionFind {\n\tvector<int> to;\n\tvector<int> data;\n\tUnionFind(int size) : to(size, -1),data(size, -1) { }\n\t\n\t//??????x?????????y????¶????????????????(data[root(x | y)] = data[root(x)]???????????????)\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tint rootData = data[root(x)];\n\t\tif (x != y) {\n\t\t\tif (to[y] < to[x]) swap(x, y);\n\t\t\tto[x] += to[y]; to[y] = x;\n\t\t}\n\t\tsetData(x, rootData);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn to[x] < 0 ? x : to[x] = root(to[x]);\n\t}\n\tint size(int x) {\n\t\treturn -to[root(x)];\n\t}\n\n\tint findData(int x) {\n\t\treturn data[root(x)];\n\t}\n\tvoid setData(int x, int d) {\n\t\tdata[root(x)] = d;\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a, int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tuf.unionSet(e[e[j].p].m, e[j].m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findData(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint n, q;\nint p[100005];\nvector<int> G[100005];\nchar c[100005]; int v[100005];\nbool mark[100005];\nUnionFind uf(100005);\n\nvoid dfs(int v)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!mark[G[v][i]]) uf.unite(G[v][i], v);\n\t\tdfs(G[v][i]);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> q;\n\t\tif(n == 0 && q == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> p[i];\n\t\t\tG[p[i]].push_back(i);\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c[i] >> v[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) mark[i] = false;\n\t\tmark[1] = true;\n\t\t\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'M') mark[v[i]] = true;\n\t\t}\n\t\tuf.init();\n\t\tdfs(1);\n\t\t\n\t\treverse(c, c+q);\n\t\treverse(v, v+q);\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'Q') ans += uf.root(p[v[i]]);\n\t\t\telse uf.unite(v[i], p[v[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001],mpar[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n  fill(mpar, mpar+N+1, 1);\n  \n  marked[1] = 1;\n  par[1] = 1;\n}\n\nint ans(int v){\n\n  //if(marked[par[v]] == 1) return mpar[v] = par[v];\n  //return mpar[v] = ans(par[v]);\n\n  while(marked[v]==0)\n    v = par[v];\n  \n  return v;\n  \n}\n\n\nint main(){\n  \n  while(1){\n\n    ll res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=2;i<=N;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%lld\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint root[100001];\nbool marked[100001];\n\nint getroot(int v) { return marked[v] ? v : root[v] = getroot(root[v]); }\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tfor(int i=2;i<=n;i++) cin >> root[i];\n\t\tvector<bool> vb;\n\t\tvector<int>  vi;\n\t\tmemset(marked, false, sizeof(marked));\n\t\tmarked[1] = true;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tchar c; int t; cin >> c >> t;\n\t\t\tif(c=='Q'){ vb.push_back(true); vi.push_back(t); }\n\t\t\telse {\n\t\t\t\tif(marked[t]) continue;\n\t\t\t\tvb.push_back(false); vi.push_back(t);\n\t\t\t\tmarked[t] = true;\n\t\t\t}\n\t\t}\n\t\tlong long ans = 0;\n\t\treverse(vb.begin(), vb.end());\n\t\treverse(vi.begin(), vi.end());\n\t\tfor(int i=0;i<vb.size();i++){\n\t\t\tif(vb[i]) ans += getroot(vi[i]);\n\t\t\telse      marked[vi[i]] = false;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N=2*1e5;\nconstexpr int Log=log2(MAX_N)+10;\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\tnex=rootpar[v];\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(;;){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n\nint to[123456];\nchar o[123456];\nint v[123456];\nbool mark[123456];\n\nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (y < x) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void print(){\n    REP(i,data.size()){\n      cout << i << \"->\" << data[i] << endl;\n    }\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    REP(i,123456){\n      mark[i] = false;\n      to[i] = 0;\n      o[i] = '0';\n      v[i] = 0;\n    }\n    v[0]=true;\n    unionfind uf(n);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+1] = a-1;\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      v[i]--;\n      if(o[i]=='M')\n        mark[v[i]] = true;\n    }\n    int sum = 0;\n    \n    REP(i,n-1){\n      if(!mark[i+1]){\n        uf.unionset(i+1,to[i+1]);\n      }\n    }\n\n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i])+1;\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tconst int N;\n\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tint groups_;\n\tstd::vector< int > sizes;\n\npublic:\n\tUnionFind( int n ) : N( n ), parent( N ), rank( N, 0 ), groups_( N ), sizes( N, 1 )\n\t{\n\t\tstd::iota( parent.begin(), parent.end(), 0 );\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tbool unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t\tsizes[y] += sizes[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tsizes[x] += sizes[y];\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\t++rank[x];\n\t\t\t}\n\t\t}\n\n\t\t--groups_;\n\t\treturn true;\n\t}\n\n\tint groups() const\n\t{\n\t\treturn groups_;\n\t}\n\n\tint groupSize( const int x )\n\t{\n\t\treturn sizes[ find( x ) ];\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n// groups()\n// groupSize( x )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, Q; scanf( \"%d%d\", &N, &Q ), ( N | Q ); )\n\t{\n\t\tVI parents( N, -1 );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tscanf( \"%d\", &parents[i] );\n\t\t\t--parents[i];\n\t\t}\n\t\tVT( char ) types( Q );\n\t\tVI vs( Q );\n\t\tREP( i, Q )\n\t\t{\n\t\t\tscanf( \" %c%d\", &types[i], &vs[i] );\n\t\t\t--vs[i];\n\t\t}\n\t\t// end of input\n\n\t\tVI marked( N );\n\t\tmarked[0] = 1;\n\t\tREP( i, Q )\n\t\t{\n\t\t\tif ( types[i] == 'M' )\n\t\t\t{\n\t\t\t\tmarked[ vs[i] ] = 1;\n\t\t\t}\n\t\t}\n\t\tREP( i, N )\n\t\t{\n\t\t\tif ( marked[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttypes.PB( 'M' );\n\t\t\tvs.PB( i );\n\t\t}\n\n\n\t\tVI answers( N );\n\t\tiota( ALL( answers ), 1 );\n\t\tUnionFind uf( N );\n\t\tLL res = 0;\n\t\tfor ( int i = SZ( types ) - 1; 0 <= i; --i )\n\t\t{\n\t\t\tconst char T = types[i];\n\t\t\tconst int v = vs[i];\n\n\t\t\tif ( T == 'M' )\n\t\t\t{\n\t\t\t\tif ( marked[v] )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst int na = answers[ parents[v] ];\n\t\t\t\tuf.unite( v, parents[v] );\n\t\t\t\tanswers[ uf.find( v ) ] = na;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += answers[ uf.find( v ) ];\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%I64d\\n\", res );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// ?????????????????§??¨???!!!!!!!!!!!!!\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ????£???????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ????£??????????\n    /**********************/\n\n    // x?????????????§???????op=+, invop=1, T=int, T0=0?????´???\n    // i????????????????????°?????????s[i]??¨?????????x[i] = s[i]????????? (???: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n    // O(log n)\n    T query(int j) {\n        T S = T0;\n        for (j; j >= 0; j = (j & (j + 1)) - 1)  // j??????C->B->7??¨????§??????????0??????C?????????????????????????????°???????????????????£???¶\n            S = op(S, x[j]); \n        return S;\n    }\n    // O(log n)\n    void update(int k, T a) {\n        for (; k < x.size(); k |= k+1) // k??????C->D->F??¨????§??????????C????????????????????°????????¨???????£???¶\n            x[k] = op(x[k], a); \n    }\n    // O(1)\n    // ??????x[i]?????¢???????????????\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n// ????????¨\n//\n// ?§????O(n): ?????????????????¢???, ??¨?????????, ?\\??????????????????°\n//\n// LCA O(log n)\n// ?????????????°??????° O(log n)\n// ????????????????????§????????????????????¢?´¢ O(log n)\nclass Tree {\npublic:\n    static const int MAXLOGV = 25;\n    vector<vector<int> > m_edges; // m_edges[i][j]????????¨: i->j??????????????¨\n    int vn; // ???????????°, vn<2^MAXLOGV\n    int root; // ?????????????????????\n\n    vector<vector<int>> parent; // parent[i][j]: j???i^2???????????????j=0??§??´????????????\n    vector<int> depth; // depth[i]: ??????i?????????????????±???, ??????0\n\n    vector<int> euler; // ??????????§????????????????????????¢????????????vn*2\n    vector<int> f; // f[i] = euler??§i???????????????1???????????????, ??????vn\n    vector<int> s; // f[i] = euler??§i???????????????2???????????????, ??????vn\n\n    /*********/\n    // ?§????\n    /*********/\n    Tree(int vn, int root) : vn(vn), root(root) {\n        parent.resize(MAXLOGV);\n        m_edges.resize(vn);\n        for (int i = 0; i < MAXLOGV; i++) \n            parent[i].resize(vn);\n        depth.resize(vn);\n    }\n\n    // ?????????????§????\n    void unite(int u, int v) {\n        m_edges[u].push_back(v);\n        m_edges[v].push_back(u);\n    }\n\n    // root???????????±?????¨???????¢???????\n    // unite???????????£??????????????????????????¶?????¨???\n    void init() {\n        euler.clear(); euler.reserve(2 * vn);\n        f.clear(); f.resize(vn);\n        s.clear(); s.resize(vn);\n        dfs(root, -1, 0);\n        for (int k = 0; k+1 < MAXLOGV; k++) // 2^k??£?\\????????¨????\n            for (int v = 0; v < vn; v++) \n                if (parent[k][v] < 0) \n                    parent[k+1][v] = -1; // 2^k??£????????????????¶???????????????????2^(k+1)??£????????????????????????????¶?????????????\n                else \n                    parent[k+1][v] = parent[k][parent[k][v]]; // 2^(k+1)??£????????????2^k??£?????????2^k??£?????????\n    }\n\n    // 1????????¨??±?????¨?????????????????¢???????§????\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        f[v]=euler.size();\n        euler.push_back(v);\n        for (int next : m_edges[v]) \n            if (next != p)\n                dfs(next, v, d+1);\n        s[v]=euler.size();\n        euler.push_back(v);\n    }\n\n    /*********/\n    // ?????¨???\n    /*********/\n    // ??????u, v???????°???±???????\\?\n    //\n    // O(log n)\n    int lca(int u, int v) const {\n        if (depth[u] > depth[v]) swap(u, v); // u?????????????????????????????????\n        for (int k = 0; k < MAXLOGV; k++)    // v???u??¨????????±????????§??????\n            if ((depth[v] - depth[u])>>k & 1) \n                v = parent[k][v];\n        if (u == v) return u;\n        for (int k = MAXLOGV-1; k >= 0; k--) { // ????????????????????????????????§??????\n            if (parent[k][u] == parent[k][v]) // ????????????\n                continue; \n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n\n    // u??¨v????????¢????±???????\n    // ?????¢?????¨?????????????????§????????????????§??????°??§??????\n    //\n    // O(log n)\n    int dist(int u, int v) const {\n        int p = lca(u, v);\n        return (depth[u]-depth[p]) + (depth[v]-depth[p]);\n    }\n\n    // [root, v]????????????f???????????????????????´?????????????????????\n    // 1???????????????????????????-1????????????\n    //\n    // O(log n)\n    int binary_search(int v, function<bool(int)> f) const {\n        for(int j = MAXLOGV - 1; j >= 0;j--) \n            if(parent[j][v] != -1 && f(parent[j][v]))\n                v = parent[j][v];\n        return f(v) ? v : -1;\n    }\n\n    // ??¨????§??????????\n    void print_dfs(int v, int p) const {\n        for (int i = 0; i < depth[v]; i++)\n            cout << \" \";\n        cout << v << endl;\n        for (int next : m_edges[v]) if (next != p) \n            print_dfs(next, v);\n    }\n    void print(void) const {\n        print_dfs(root, -1);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, q; \n    while (cin >> n >> q && n && q) {\n        Tree t(n, 0);\n        rep(i, n-1) {\n            ll tmp; cin >> tmp;\n            t.unite(i+1, tmp-1); \n        }\n        t.init();\n\n        fenwick_tree<ll> ft(n*2);\n        ft.update(t.f[0], 1);\n        ft.update(t.s[0], -1);\n\n        ll ret = 0;\n        rep(_, q) {\n            char c; ll v; cin >> c >> v; v--;\n            if (c == 'M') {\n                if (ft.access(t.f[v]))\n                    continue;\n                ft.update(t.f[v], 1);\n                ft.update(t.s[v], -1);\n            } else {\n                ll marked_num = ft.query(t.f[v]);\n                ret += t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1; \n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nint sum;\nint find(int x,int flag){\n    if(flag)    return 0;\n    if(f[x]==x){\n        return x;\n    }\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else{\n\tif(marked[t[i]]) ans+=t[i]+1;\n\telse ans+=find(t[i])+1;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\ntemplate <typename T>\nclass SegmentTree{\nprivate:\n    int n;\n    vector<T> dat;\n    T init_value;\npublic:\n    void init(int n_, T init_value_){\n        n = 1;\n        init_value = init_value_;\n        while(n < n_) n *= 2;\n        dat.assign(2*n-1, init_value);\n    }\n    // k: index(0-indexed), a: value\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k>0){\n            k = (k-1)/2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    // query(a, b) =>  minimum in [a,b]\n    T query(int a, int b){\n        return _query(a, b, 0, 0, n-1);\n    }\n    // dat[k] is minimum in [l,r]\n    T _query(int a, int b, int k, int l, int r){\n        if(r<a || b<l) return init_value;\n        if(a<=l&&r<=b){\n            return dat[k];\n        }else{\n            T vl = _query(a, b, k*2+1, l, (l+r)/2);\n            T vr = _query(a, b, k*2+2, (l+r)/2+1, r);\n            return max(vl, vr);\n        }\n    }\n    // k: index(0-indexed)\n    T get(int k){\n        return dat[k+n-1];\n    }\n};\n\nSegmentTree<P> seg;\nvector<vector<int>> children;\nvector<int> mark;\nvector<vector<int>> queries;\n\nint dfs(int v, int depth){\n    if(mark[v] != -1) seg.update(mark[v], P(depth, v));\n    int ret = 0;\n    for(int t : queries[v]){\n        P p = seg.query(0, t);\n        ret += p.second + 1;\n    }\n    for(int child : children[v]){\n        ret += dfs(child, depth + 1);\n    }\n    if(mark[v] != -1) seg.update(mark[v], P(-1, -1));\n    return ret;\n}\n\nint main(){\n    while(true){\n        int N, Q;\n        cin >> N >> Q;\n        if(N == 0) break;\n\n        children.assign(N, {});\n        for(int i=1;i<N;i++){\n            int par;\n            cin >> par;\n            children[par-1].push_back(i);\n        }\n\n        mark.assign(N, -1);\n        mark[0] = 0;\n        queries.assign(N, {});\n        for(int i=1;i<=Q;i++){\n            char c;\n            int v;\n            cin >> c >> v;\n            v--;\n            if(c == 'M'){\n                if(mark[v] == -1) mark[v] = i;\n            }else{\n                queries[v].push_back(i);\n            }\n        }\n\n        seg.init(N, P(-1, -1));\n        cout << dfs(0, 0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#define rep(i, a, b) for (int i = a; i < b; ++i)\n#define repr(i, a, b) for (int i = a; i <= b; ++i)\n#define dep(i, a, b) for (int i = a; i > b; --i)\n#define depr(i, a, b) for (int i = a; i >= b; --i)\n#define getnum(n) scanf(\"%d\", &n)\n#define LL long long\n#define INF 0x7f7f7f7f\n#define PI acos(-1.0)\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nint f[MAXN], n, q, tmp;\nLL ans;\n\nint Find(int x) {\n\treturn f[x] == x ? x : Find(f[x]);\n}\n\nvoid Init() {\n\trepr(i, 1, n) {\t//初始化也要改 \n\t\tf[i] = i;\n\t}\n}\n\nvoid Solve() {\n\trepr(i, 2, n) {\n\t\tgetnum(tmp);\n\t\tf[i] = tmp;\n\t}\n\tchar op[2];\n\trep(i, 0, q) {\n\t\tscanf(\"%s%d\", op, &tmp);\n\t\tif (op[0] == 'Q') ans += Find(tmp);\n\t\telse {\n\t\t\tf[tmp] = tmp;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%d\", &n, &q) && (n || q)) {\n\t\tans = 0;\n\t\tInit();\n\t\tSolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\tr[0] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint par[100001],o[100001];\n\nint find(int pos){\n  if(o[pos]) return pos;\n  return find(par[pos]);\n}\n\nint main(){\n  while(1){\n    int n,q;\n    cin>>n>>q;\n    if(!n&&!q)break;\n    for(int i=0;i<=n;i++) o[i]=0;\n    for(int i=2;i<=n;i++) cin>>par[i];\n    \n    o[1]=1;\n    int ans=0;\n    while(q--){\n      char ch;int idx;\n      cin>>ch>>idx;\n      if(ch=='M') o[idx]=1;\n      if(ch=='Q')ans+=find(idx);\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1LL<<55)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nstruct SegmentTree {\n    int n;\n    P dat[2*MAX-1];    \n    \n    SegmentTree(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = P(0, 1);\n        }\n    }\n\n    ll get_nearest_marked_node(int k)\n    {\n        k += n - 1;\n        P p = dat[k];\n        while (k > 0) {\n            k = (k - 1) / 2;\n            p = max(p, dat[k]);\n        }\n        return p.second;\n    }\n        \n    void mark(int a, int b, int k, int l, int r, P x)\n    {\n        if (r <= a || b <= l) return;\n\n        if (a <= l && r <= b) {\n            dat[k] = max(dat[k], x);\n        } else {\n            mark(a, b, k * 2 + 1, l, (l + r) / 2, x);\n            mark(a, b, k * 2 + 2, (l + r) / 2, r, x);\n        }\n    }    \n};\n\nll L[MAX], R[MAX], D[MAX], p;\nvector<int> G[MAX];\n\nvoid init(int N)\n{\n    p = 0;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();        \n    }\n}\n\nvoid dfs(int v, int depth)\n{\n    L[v] = p++;\n    D[v] = depth;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        dfs(G[v][i], depth + 1);\n    }\n    R[v] = p;\n}\n\nint main()\n{\n    int N, Q, x;\n    while (scanf(\"%d %d\", &N, &Q), N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            scanf(\"%d\", &x);\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0, 0);\n\n        SegmentTree st(N);\n        \n        char m;\n        ll v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.mark(L[v], R[v], 0, 0, st.n, P(D[v], v+1));\n            } else {\n                res += st.get_nearest_marked_node(L[v]);\n            }\n        }\n        printf(\"%lld\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tll ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\ttb[e[j].m] = e[e[j].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\ttb[e[j].m] = to;\n\t\t\t\tans += tb[to] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n\n  marked[1]=1;\n\n}\n\nint ans(int v){\n\n  int u = par[v];\n  \n  while(marked[u]==0)\n    u = par[u];\n  \n  return u;\n\n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    cin>>N>>Q;\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=1;i<=N-1;i++)\n      cin>>par[i];\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      cin>>op>>v;\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N]; //i(i = 0,1,2,...,n)?????????node???????????\\????????????\nchar Ope[MAX_N]; //operations?????\\????????????\nint Openum[MAX_N]; //operation??¨??????????????°????????\\????????????\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      \n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          // printf(\"%d\", nodeNum);\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n\n     \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n    Node[1] = 1;\n  while(1){\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\troot[ edge[p][i] ] = v;\n\t\tupdate(edge[p][i], v);\n\t}\n}\n\nint main() {\n\tint n, q;\n\twhile(cin >> n >> q, n||q) {\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = -1;\n\t\tint sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss;\n\nstruct Info{\n\tvector<int> Children;\n};\n\nInfo*info;\n\nvoid update(int new_marked_boss_id){\n\n\tint current_boss_id = marked_boss[new_marked_boss_id],id;\n\tmarked_boss[new_marked_boss_id] = new_marked_boss_id;\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < info[new_marked_boss_id].Children.size();i++){\n\n\t\tif(marked_boss[info[new_marked_boss_id].Children[i]] == current_boss_id){\n\t\t\tmarked_boss[info[new_marked_boss_id].Children[i]] = new_marked_boss_id;\n\t\t\tQ.push(info[new_marked_boss_id].Children[i]);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tid = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i < info[id].Children.size();i++){\n\t\t\tif(marked_boss[info[id].Children[i]] == current_boss_id){\n\t\t\t\tmarked_boss[info[id].Children[i]] = new_marked_boss_id;\n\t\t\t\tQ.push(info[id].Children[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint Q,value;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\tinfo = (Info*)malloc(sizeof(Info)*(100001));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tmarked_boss[i] = 1;\n\t\t\tinfo[i].Children.clear();\n\t\t}\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tinfo[value].Children.push_back(i);\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < Q; i++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){\n\t\t\t\tans += marked_boss[value];\n\t\t\t}else{\n\t\t\t\tupdate(value);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi col,in;\nint dfs(int a){\n\tif(col[a])return a;\n\telse return dfs(in[a]);\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tcol=vi(n);\n\t\tcol[0]=1;\n\t\tin=vi(n);\n\t\trep(i,n-1){\n\t\t\tint a;cin>>a;\n\t\t\tin[i+1]=a-1;\n\t\t}\n\t\tll out=0;\n\t\trep(i,m){\n\t\t\tchar c;int a;\n\t\t\tcin>>c>>a;\n\t\t\tif(c=='M')col[a-1]=true;\n\t\t\telse{\n\t\t\t\tout+=1+dfs(a-1);\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int maxn = 1e5+5;\nstd::vector<int> v[maxn];\nint p[maxn], r[maxn];\n\nint find(int x) {\n\tint t = x;\n\twhile(t != p[t]){\n\t\tt = p[t];\n\t}\n\treturn t;\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t//freopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, q;\n\tp[1] = 1;\n\twhile(cin >> n >> q && n){\n\t\tLL ans = 0;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tp[i] = x;\n\t\t}\n\t\twhile(q--){\n\t\t\tchar op[2];\n\t\t\tint x;\n\t\t\tcin >> op >> x;\n\t\t\tif(op[0] == 'M') p[x] = x;\n\t\t\telse ans += find(x); \n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\nbool marked[MAX_N+5];\n\nstack<P> s;\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n        marked[i] = false;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nvoid show_par() {\n    for(int i = 1; i <= N; i++) {\n        cout << i << \": \" << par[i] << \", \";\n    }\n    cout << endl;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par2[i] = p;\n        }\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                marked[t] = true;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            s.push(q);\n        }\n\n        // solve\n        for(int i = 1; i <= N; i++) {\n            if(!marked[i]) unite(par2[i], i);\n        }\n        long long int ans = 0;\n        // show_par();\n        while(s.size()) {\n            P q = s.top(); s.pop();\n            if(q.first == 'M') {\n                unite(par2[q.second], q.second);\n            } else {\n                ans += find(q.second);\n            }\n            // cout << v[i].first << \" \" << v[i].second << endl;\n            // show_par();\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nvector<vector<ll>> v(200010);\nll l[200010],r[200010];\nll cnt = 0;\n\n// LCA\n// verify: https://atcoder.jp/contests/abc014/submissions/9535352\nbool used[200010];\nll depth[200010];\nll par[200010][20];\n\n// 根からの深さと1つ上の親を求める. initの中で使う\n// ついでにオイラーツアーもやってる\nvoid dfs(ll p=0,ll d=0){\n    l[p]=cnt;\n    cnt++;\n    used[p] = 1;\n    depth[p] = d;\n    for(auto i:v[p]){\n        if(!used[i]){\n            dfs(i,d+1);\n            par[i][0] = p;\n        }\n    }\n    r[p]=cnt;\n    cnt++;\n}\n\n// init(n, root) でダブリングテーブルを作製する\n// n: 頂点数\nvoid init(ll n, ll root=0){\n    for(ll i=0;i<n;i++){\n        used[i]=false;\n        for(ll j=0;j<20;j++){\n            par[i][j] = -1;\n        }\n    }\n    dfs(root,0);\n    for(ll j=1;j<20;j++){\n        for(ll i=0;i<n;i++){\n            if(par[i][j-1] == -1) continue;\n            par[i][j] = par[par[i][j-1]][j-1];\n        }\n    }\n}\n\n//頂点aのd個上の親を求める\nll get_nyaa(ll a,ll d){\n    for(ll i=19;i>=0;i--){\n        if(d & (1<<i)) a = par[a][i];\n    }\n    return a;\n}\n\n// a,bのLCAを求める\nll lca(ll a,ll b){\n    if(depth[a] < depth[b]) swap(a,b);\n    ll dif = depth[a] - depth[b];\n    for(ll i=19;i>=0;i--){\n        if(dif & (1<<i)) a = par[a][i];\n    }\n    if(a==b) return a;\n    for(ll i=19;i>=0;i--){\n        if(par[a][i]!=par[b][i]){\n            a = par[a][i], b = par[b][i];\n        }\n    }\n    return par[a][0];\n}\n\n\n// Segment Tree\ntemplate<class Monoid, class Action> struct SegTree {\n    using FuncMonoid = function< Monoid(Monoid, Monoid) >;\n    using FuncAction = function< void(Monoid&, Action) >;\n    using FuncLazy = function< void(Action&, Action) >;\n    FuncMonoid FM;\n    FuncAction FA;\n    FuncLazy FL;\n    Monoid UNITY_MONOID;\n    Action UNITY_LAZY;\n    ll SIZE, HEIGHT;\n    vector<Monoid> dat;\n    vector<Action> lazy;\n\n    SegTree() { }\n    SegTree(ll n, const FuncMonoid fm, const FuncAction fa, const FuncLazy fl,\n            const Monoid &unity_monoid, const Action &unity_lazy)\n    : FM(fm), FA(fa), FL(fl), UNITY_MONOID(unity_monoid), UNITY_LAZY(unity_lazy) {\n        SIZE = 1; HEIGHT = 0;\n        while (SIZE < n) SIZE <<= 1, ++HEIGHT;\n        dat.assign(SIZE * 2, UNITY_MONOID);\n        lazy.assign(SIZE * 2, UNITY_LAZY);\n    }\n    void init(ll n, const FuncMonoid fm, const FuncAction fa, const FuncLazy fl,\n            const Monoid &unity_monoid, const Action &unity_lazy) {\n        FM = fm; FA = fa; FL = fl;\n        UNITY_MONOID = unity_monoid; UNITY_LAZY = unity_lazy;\n        SIZE = 1; HEIGHT = 0;\n        while (SIZE < n) SIZE <<= 1, ++HEIGHT;\n        dat.assign(SIZE * 2, UNITY_MONOID);\n        lazy.assign(SIZE * 2, UNITY_LAZY);\n    }\n\n    /* set, a is 0-indexed */\n    void set(ll a, const Monoid &v) { dat[a + SIZE] = v; }\n    void build() {\n        for (ll k = SIZE - 1; k > 0; --k)\n            dat[k] = FM(dat[k*2], dat[k*2+1]);\n    }\n\n    /* update [a, b) */\n    inline void evaluate(ll k) {\n        if (lazy[k] == UNITY_LAZY) return;\n        if (k < SIZE) FL(lazy[k*2], lazy[k]), FL(lazy[k*2+1], lazy[k]);\n        FA(dat[k], lazy[k]);\n        lazy[k] = UNITY_LAZY;\n    }\n    inline void update(ll a, ll b, const Action &v, ll k, ll l, ll r) {\n        evaluate(k);\n        if (a <= l && r <= b)  FL(lazy[k], v), evaluate(k);\n        else if (a < r && l < b) {\n            update(a, b, v, k*2, l, (l+r)>>1), update(a, b, v, k*2+1, (l+r)>>1, r);\n            dat[k] = FM(dat[k*2], dat[k*2+1]);\n        }\n    }\n    inline void update(ll a, ll b, const Action &v) { update(a, b, v, 1, 0, SIZE); }\n\n    /* get [a, b) */\n    inline Monoid get(ll a, ll b, ll k, ll l, ll r) {\n        evaluate(k);\n        if (a <= l && r <= b)\n            return dat[k];\n        else if (a < r && l < b)\n            return FM(get(a, b, k*2, l, (l+r)>>1), get(a, b, k*2+1, (l+r)>>1, r));\n        else\n            return UNITY_MONOID;\n    }\n    inline Monoid get(ll a, ll b) { return get(a, b, 1, 0, SIZE); }\n    inline Monoid operator [] (ll a) { return get(a, a+1); }\n    /* debug */\n    void prll() {\n        for (ll i = 0; i < SIZE; ++i) { cout << (*this)[i]; if (i != SIZE) cout << \",\"; }\n        cout << endl;\n    }\n};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n \n    //ifstream cin(\"in.txt\");\n    ll n,q;\n    while(cin>>n>>q){\n        if(n==0) break;\n        v = vector<vector<ll>>(200010);\n        cnt = 0;\n        for(ll i=1;i<n;i++){\n            ll a;\n            cin>>a;\n            a--;\n            v[i].push_back(a);\n            v[a].push_back(i);\n        }\n        auto fm = [](ll a, ll b) { return max(a, b); };\n        auto fa = [](ll &a, ll d) { a = max(a, d); };\n        auto fl = [](ll &d, ll e) { d = max(d, e); };\n        init(n,0);\n        ll ans = 0;\n        SegTree<ll, ll> seg(2*n, fm, fa, fl, 0, 0);\n        while(q--){\n            char c;\n            ll a; \n            cin>>c>>a;\n            a--;\n            if(c=='M'){\n                seg.update(l[a],r[a]+1,depth[a]);\n            }\n            if(c=='Q'){\n                ll ret = get_nyaa(a,depth[a]-seg.get(l[a],l[a]+1))+1;\n                ans += ret;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nint par[MAX_N+1];//parents\nint Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint N,Q;\nlong long sum = 0;\nint tree[MAX_N+1];\n\nint nearestAncstr(int num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,int num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nint num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\tfor(int i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tcin >>symbol >>num;num--;\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(!(symbol == '0' && num == -1)){\n\t\toperate(symbol,num);\n\t\tcin >>symbol >>num;num--;\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\tcin >>N >>Q;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool vis[100000], marked[100000];\nint qtype[100000], vertex[100000];\n\nint par[100000], pp[100000];\n\nvoid init()\n{\n\tfor (int i = 0; i < 100000; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return (x);\n\treturn (par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x != y){\n\t\tpar[y] = x;\n\t}\n}\n\nvoid dfs(int v, int p, int m)\n{\n\tint nm = m;\n\tif (marked[v]) nm = v;\n\tpp[v] = p;\n\t\n\tmerge(nm, v);\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tdfs(G[v][i], v, nm);\n\t}\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\twhile (scanf(\"%d %d\", &N, &Q) && N){\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\t\n\t\tfor (int i = 1; i < N; i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tG[--v].push_back(i);\n\t\t}\n\t\t\n\t\tinit();\n\t\t\n\t\tmemset(marked, 0, sizeof(marked));\n\t\tmarked[0] = true;\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tchar t[10];\n\t\t\tscanf(\"%s %d\", t, vertex + i);\n\t\t\tqtype[i] = (t[0] == 'Q');\n\t\t\t--vertex[i];\n\t\t\tif (!qtype[i]) marked[vertex[i]] = true;\n\t\t}\n\t\t\n\t\tdfs(0, -1, -1);\n\t\t\n\t\tlong long int ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--){\n\t\t\tif (qtype[i]){\n\t\t\t\tans += find(vertex[i]) + 1;\n\t\t\t}\n\t\t\telse merge(pp[vertex[i]], vertex[i]);\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\n\nstruct UnionFind {\nprivate:\n\tvector< int > data;\n\t\npublic:\n\tUnionFind(int _size) : data(_size, -1) {}\n\t\n\tbool unite(int _x, int _y) {\n\t\t_x = root(_x); _y = root(_y);\n\t\tif (_x != _y) data[_x] += data[_y]; data[_y] = _x;\n\t\treturn _x != _y;\n\t}\n\t\n\tbool same(int _x, int _y) { return root(_x) == root(_y); }\n\t\n\tint root(int _x) { return data[_x] < 0 ? _x : data[_x] = root(data[_x]); }\n\t\n\tint size(int _x) { return -data[root(_x)]; }\n};\n\nint N, Q, p[100010];\nchar q[100010];\nint mark[100010], v[100010];\nlint anc[100010];\n\nvoid solve() {\n\tUnionFind uf(N+1);\n\t\n\tfor_(i,1,N) if (!mark[i]) uf.unite(p[i], i);\n\t\n\tlint ans = 0;\n\t\n\tfor_rev(i,Q-1,0) {\n\t\tif (q[i] == 'M') {\n\t\t\t--mark[ v[i] ];\n\t\t\tif (!mark[ v[i] ]) uf.unite(p[ v[i] ], v[i]);\n\t\t} else {\n\t\t\tans += uf.root(v[i]);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\t++N;\n\t\tfor_(i,2,N) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\t\n\t\tminit(mark, 0);\n\t\tmark[1] = 1;\n\t\t\n\t\tfor_(i,0,Q) {\n\t\t\tscanf(\"%s %d\", &q[i], &v[i]);\n\t\t\tif (q[i] == 'M') ++mark[ v[i] ];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n//\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2*k+1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nvoid dfs(const int now, vector<pair<int, int>>&ps,vector<int>&ids,int&id,const vector<vector<int>>&edges) {\n\tids[now] = id;\n\tps[now].first = id;\n\tid++;\n\tfor (auto e : edges[now]) {\n\t\tdfs(e, ps, ids, id, edges);\n\t}\n\tps[now].second = id - 1;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tedges[a - 1].push_back(i + 1);\n\t\t}\n\t\tvector<pair<int, int>>ps(N);\n\t\tvector<int>ids(N);\n\t\tint id = 0;\n\t\tdfs(0, ps, ids, id, edges);\n\t\tlong long int sum = 0;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'Q') {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tint aid = ids[a];\n\t\t\t\tint ans = get(aid, aid);\n\t\t\t\tsum += ans+1;\n\t\t\t\t//cout << ans+1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tupdate(ps[a].first, ps[a].second,a);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nstruct UnionFind\n{\nprivate:\n  vi data;\n  int cnt;\n\npublic:\n  UnionFind(const int size) : data(size, -1), cnt(size) {}\n  bool unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x != y){\n      data[x] += data[y];\n      data[y] = x;\n      cnt -= 1;\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return root(x) == root(y); }\n  int root(int x){ return data[x] < 0 ? x : data[x] = root(data[x]); }\n  int size(int x){ return -data[root(x)]; }\n  int group(){ return cnt; }\n};\n\nconst int MAX_Q = 111111;\nconst int MAX_N = 111111;\nint N, Q;\nint q[MAX_Q];\nint p[MAX_N];\npair<char, int> query[MAX_N];\nbool flag[MAX_N];\n\nint main()\n{\n  while(cin >> N >> Q, Q){\n    rep(i, N) flag[i] = false;\n\n    UnionFind uf(N);\n    p[0] = 0;\n    rep(i, N - 1) cin >> p[i + 1],  p[i + 1] -= 1;\n    rep(i, Q) cin >> query[i].first >> query[i].second, query[i].second -= 1;\n\n    rep(i, Q) if(query[i].first == 'M') flag[query[i].second] = true;\n    rep(i, N) if(!flag[i]) uf.unite(p[i], i);\n    ll res = 0LL;\n    rev(i, Q){\n      if(query[i].first == 'M') uf.unite(p[query[i].second], query[i].second);\n      if(query[i].first == 'Q') res += (ll)uf.root(query[i].second) + 1LL;\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Tree {\n    vector<int> par;\n    vector<int> mark;\n    Tree(int n) : par(n, -1), mark(n, 0) { }\n\n    void unmark(int k) {\n        mark[k]--;\n    }\n\n    int query(int k) {\n        if(mark[k]) return k;\n        return par[k] = query(par[k]);\n    }\n};\n\nint main() {\n    for(int N, Q; cin >> N >> Q, N + Q > 0; ) {\n        Tree tree(N);\n        tree.mark[0]++;\n        for(int i = 0; i < N - 1; i++) {\n            int p; cin >> p; p--;\n            tree.par[i + 1] = p;\n        }\n        vector<int> type;\n        vector<int> node;\n        for(int i = 0; i < Q; i++) {\n            char t; int n; cin >> t >> n; n--;\n            type.push_back(t == 'Q');\n            node.push_back(n);\n            if(t == 'M') tree.mark[n]++;\n        }\n        reverse(type.begin(), type.end());\n        reverse(node.begin(), node.end());\n        lli res = 0;\n        for(int i = 0; i < Q; i++) {\n            if(type[i]) {\n                res += tree.query(node[i]) + 1;\n            }\n            else {\n                tree.unmark(node[i]);\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string.h>\n#include<sstream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\nconst int maxn=100010;\nint tree[maxn];\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\nint main()\n{\n    int n,m,id,i;\n    char com[10];\n    ll ans;\n\n    while(scanf(\"%d%d\",&n,&m),n||m)\n    {\n        tree[1]=1;\n        ans=0;\n        for(i=1;i<n;i++)\n            scanf(\"%d\",&tree[i]);\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s%d\",com,&id);\n            if(com[0]=='M')\n                tree[id]=id;\n            else\n                ans+=Find(id);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(k),rank(k)\n    {\n        n=k;\n        for(int i=0;i<n;i++) par[i]=i;\n        for(int i=0;i<n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n           // if(m[c[x][i]]) par[c[x][i]]=c[x][i];\n           // else           par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100001;\n     \n// int N, Q;\n// long long int ans;\n// int par[MAX_N]; \n// bool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint search(int x) {\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n  \nint main()\n{\n  marked[1] = true;\n  while(1){\n    int num, N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    int par[N+1]; \n    bool marked[N+1];\n    long long int ans = 0;\n    init();\n    // ans = 0;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\" %c\", &Ope);\n      scanf(\"%d\", &Openum);\n      if (ope == 'M') {\n        marked[num] = true;\n      }\n    \n      else if(ope == 'Q'){\n        ans += search(num);\n      }\n    } \n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\troot[p] = v;\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\tif( root[edge[p][i]] == edge[p][i] ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tupdate(edge[p][i], v);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, q;\n\twhile(cin >> n >> q, n||q) {\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = 1;\n\t\tint sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<string.h>\n//aoj 2170\nusing namespace std;\nint n,q,ans;\nint f[100003];\nint find(int x)\n{\n\tif(f[x]==x)\n\t{\n\t\treturn x;\n\t}else{\n\t\treturn find(f[x]);\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(n==0&&q==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tans=0;\n\t\tmemset(f,0,sizeof(f));\n\t\tf[1]=1;\n        for(int i=2;i<=n;i++)\n\t\t{\n            scanf(\"%d\",&f[i]);\n        }\n        for(int i=1;i<=q;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tchar pd;\n\t\t\twhile(getchar()!='\\n');\n            scanf(\"%c%d\",&pd,&a);\n            if(pd=='Q')\n\t\t\t{\n                ans+=find(a);\n            }else{\n                f[a]=a;\n\t\t\t}\n        }\n        printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tmap<int,int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(i+2) != roots.end()) continue;\n\t\t\tif(c == 'M') roots[i+2] = v;\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\n\n// #define int long long\n\n#define GET_MACRO(a, b, c, d, NAME, ...) NAME\n#define REP2(i, n) REP3(i, 0, n)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += s)\n#define RREP2(i, n) RREP3(i, 0, n)\n#define RREP3(i, a, b) for (int i = (b) - 1; i >= (int)(a); i--)\n\n#define rep(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)\n#define rrep(...) GET_MACRO(__VA_ARGS__,, RREP3, RREP2)(__VA_ARGS__)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = std::vector<int>;\nusing vvi = std::vector<vi>;\n\ntemplate<typename T>\nusing maxpq = std::priority_queue<T, std::vector<T>, std::less<T>>;\n\ntemplate<typename T>\nusing minpq = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\nusing namespace std;\n\n\n// }}}\n// Union Find {{{\n\nstruct UnionFind {\n\tUnionFind(size_t n = 0): cnt(n), par(n, -1){}\n\t\n\tint root(int x){\n\t\treturn par[x] < 0 ? x : (par[x] = root(par[x]));\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\t\n\tint size(){\n\t\treturn cnt;\n\t}\n\n\tint size(int x){\n\t\treturn -par[root(x)];\n\t}\n\n\tbool unite(int x, int y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\tcnt--;\n\t\treturn true;\n\t}\n\nprivate:\n\tint cnt;\n\tvector<int> par;\n};\n\n// }}}\n\nint n, q;\nint p[100010];\nint t[100010], v[100010];\nint m[100010];\n\nint main()\n{\n\twhile (cin >> n >> q, n){\n\t\trep(i, n) m[i] = 0;\n\t\tm[0] = 1;\n\t\trep(i, 1, n) cin >> p[i], p[i]--;\n\t\trep(i, q){\n\t\t\tstring s;\n\t\t\tcin >> s >> v[i], v[i]--;\n\t\t\tt[i] = s == \"Q\";\n\t\t\tif (!t[i]) m[v[i]]++;\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\trep(i, n){\n\t\t\tif (!m[i]) uf.unite(p[i], i);\n\t\t}\n\n\t\tint s = 0;\n\t\trrep(i, q){\n\t\t\tif (!t[i]){\n\t\t\t\tif (!--m[v[i]]){\n\t\t\t\t\tuf.unite(p[v[i]], v[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse s += uf.root(v[i]) + 1;\n\t\t}\n\n\t\tcout << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  par[1] = 1;\n  for (int i = 1; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (x == 1 || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            if(a==1){continue;}\n            a=P[a-1];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m+1;}\n            }\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; break;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nbool marked[100000];\nint prt[100000];\n\nint gm(int i) {\n  if (marked[i]) return i;\n  return prt[i] = gm(prt[i]);\n}\n\nint main() {\n  while(1) {\n    int n,q;\n    cin>>n>>q;\n    if(!n) break;\n    REP(i,n)marked[i]=false;\n    marked[0] = true;\n    REP(i,n-1) {\n      cin>>prt[i+1];\n      --prt[i+1];\n    }\n    vector<tuple<int,int>> ql;\n    REP(i,q){\n      string c;\n      int v;\n      cin>>c>>v;\n      --v;\n      if (c==\"M\") {\n        if (marked[v]) continue;\n        marked[v] = true;\n      }\n      ql.emplace_back(c==\"Q\", v);\n    }\n    reverse(begin(ql),end(ql));\n    int sum = 0;\n    REP(i,ql.size()){\n      int c,v;\n      tie(c,v) = ql[i];\n      if(c) // Q\n        sum += gm(prt[v]) + 1;\n      else\n        marked[v] = false;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1147483647;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define gchar(i) scanf(\"%c\",&(i))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n\n//#define my_debug\n\nconst int MAX_N = 100005;\nint all[MAX_N];\nbool stu[MAX_N];\n\nint n, q;\n\nvoid solve(){\n\n}\n\nint get_f(int i){\n\tif (stu[i])\n\t\treturn i;\n\tint out = all[i];\n\tif (stu[out])\n\t\treturn out;\n\telse\n\t\treturn get_f(out);\n}\n\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,q) != EOF){\n\t\tll out = 0;\n\t\tif (n == 0 && q == 0)\n\t\t\tbreak;\n\t\tinit(all, 0);\n\t\tinit(stu, 0);\n\t\tstu[1] = true;\n\t\tall[1] = 1;\n\t\trep(i, 2, (n + 1)){\n\t\t\tgint(all[i]);\n\t\t}\n\t\trep(i, 0, q){\n\t\t\tchar c;\n\t\t\tint tmp;\n\t\t\tgchar(c);\n\t\t\tgchar(c);\n\t\t\tgint(tmp);\n\t\t\tif (c == 'Q'){\n\t\t\t\tout += (ll)get_f(tmp);\n\t\t\t}\n\t\t\telse if (c == 'M'){\n\t\t\t\tstu[tmp] = true;\n\t\t\t}\n\t\t}\n\t\t//pint(out);\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100001;\n     \nint N, Q;\nlong long int ans;\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint search(int x) {\n  // int a = par[x];\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n\n// int find(int x) {\n//   if (par[x] == x) return x;\n//   else return par[x] = find(par[x]);\n// }\n\n// void unite(int x, int y) {\n//   par[find(x)] = find(y);\n// }\n\n// bool same(int x, int y) {\n//   return find(x) == find(y);\n// }\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(auto & e : es) addEdge(e >> 32, e & 0xFFFFFFFF);\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        while(1){\n            dump(v);\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(v);\n            for(auto & m : ms){\n                dump(m);\n           }\n            if(it != ms.end()){\n                dump(*it);\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nint solve(){\n    int ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q'){\n            ans += h.query(qv[i]) + 1;\n        } else {\n            h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[i+1].eb(i+1,par);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\n\nstruct UnionFind {\nprivate:\n\tvector< int > data;\n\t\npublic:\n\tUnionFind(int _size) : data(_size, -1) {}\n\t\n\tbool unite(int _x, int _y) {\n\t\t_x = root(_x); _y = root(_y);\n\t\tif (_x != _y) data[_x] += data[_y]; data[_y] = _x;\n\t\treturn _x != _y;\n\t}\n\t\n\tbool same(int _x, int _y) { return root(_x) == root(_y); }\n\t\n\tint root(int _x) { return data[_x] < 0 ? _x : data[_x] = root(data[_x]); }\n\t\n\tint size(int _x) { return -data[root(_x)]; }\n};\n\nint N, Q, p[100010];\nchar q[100010];\nint mark[100010], v[100010];\nlint anc[100010];\n\nvoid solve() {\n\tUnionFind uf(N);\n\t\n\tfor_(i,0,N) if (!mark[i]) uf.unite(p[i], i);\n\t\n\tlint ans = 0;\n\t\n\tfor_rev(i,Q-1,0) {\n\t\tif (q[i] == 'M') {\n\t\t\t--mark[ v[i] ];\n\t\t\tif (!mark[ v[i] ]) uf.unite(p[ v[i] ], v[i]);\n\t\t} else {\n\t\t\tans += uf.root(v[i]) + 1;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tfor_(i,1,N) {\n\t\t\tscanf(\"%d\", &p[i]); --p[i];\n\t\t}\n\t\t\n\t\tminit(mark, 0);\n\t\tmark[0] = 1;\n\t\t\n\t\tfor_(i,0,Q) {\n\t\t\tscanf(\"%s %d\", &q[i], &v[i]); --v[i];\n\t\t\tif (q[i] == 'M') ++mark[ v[i] ];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint p[100000], par[100000], t[100000];\nint find(int x) {\n\tif (x == par[x])return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tpar[find(x)] = find(y);\n}\nchar s[100000][2], m[100000];\nint main() {\n\tint n, q;\n\twhile (scanf(\"%d%d\", &n, &q), n) {\n\t\trep(i, n)par[i] = i;\n\t\trep(i, n - 1)scanf(\"%d\", &p[i + 1]), p[i + 1]--;\n\t\tmemset(m, -1, sizeof(m)); m[0] = -2;\n\t\trep(i, q) {\n\t\t\tscanf(\"%s%d\", s[i], &t[i]); t[i]--;\n\t\t\tif (s[i][0] == 'M') {\n\t\t\t\tif (m[t[i]] == -1)m[t[i]] = i;\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!m[i] == -1)unite(i, p[i]);\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (s[i][0] == 'M') {\n\t\t\t\tif (m[t[i]] == i)unite(t[i], p[t[i]]);\n\t\t\t}\n\t\t\telse ans += find(t[i]) + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n#include <map>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <memory>\n\nusing namespace std;\n\n#if 1\n#define PRINT(x) { cout << #x << \": \" << (x) << endl; }\n#define PRINT_CONTAINER(x)  { cout << #x << \": \";                       \\\n        for (size_t ix = 0; ix < (x).size(); ++ix) cout << (x)[ix] << \", \"; \\\n        cout << endl; }\n#else\n#define PRINT(x)\n#define PRINT_CONTAINER(x)\n#endif\n\n#define MAX_N 100005\nint parent[MAX_N];\nint rank[MAX_N];\nint mark[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\n// find a root of tree\nint find(int x) {\n    // cout << \"f\" << x << endl;\n    if (mark[x]) return x;\n    if (parent[x] == x) return x;\n    if (mark[parent[x]]) return parent[x];\n    return find(parent[x]);\n}\n\n// unite a group which includes x and a group which includes y\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) {\n            ++rank[x];\n        }\n    }\n}\n\n// check if x and y belong to the same group\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n\ntypedef pair<int, int> p;\n\nint n, q;\n\nint main(int argc, char *argv[]) {\n    scanf(\"%d%d\", &n, &q);\n    init(n);\n    for (int i = 0; i < n; ++i) {\n        int par;\n        scanf(\"%d\", &par); --par;\n        parent[i] = par;\n    }\n    char buf[1024];\n    int sum = 0;\n    for (int i = 0; i < q; ++i) {\n        fgets(buf, 1024, stdin);\n        char c;\n        int a;\n        sscanf(buf, \"%c %d\", &c, &a); --a;\n        if (c == 'Q') {\n            int ra = find(a);\n            // cout << ra << endl;\n            sum += ra + 1;\n        } else {\n            mark[a] = 1;\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100003;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init();\n    for(int i = 1 ; i < n ; i++){\n      cin >> c;\n      //c--;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      --num;\n      if(ch == 'Q'){\n\tsum += find(num)+1;\n      }\n      else{\n\tpar[num] = num;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      \n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          // printf(\"%d\", nodeNum);\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n\n     \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n    Node[1] = 1;\n  while(1){\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nclass unionfind {\n    public:\n    int n;\n    vector<int> par;\n    unionfind(int m) {\n        n = m;\n        par.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    int isunion(int x, int y) { return find(x) == find(y); }\n    int tounion(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return 0;\n        par[q] = p;\n        return 1;\n    }\n};\n\nint main() {\n    while (1) {\n        int n, q;\n        cin >> n >> q;\n        if (!n) return 0;\n\n        vector<int> par(n);\n        for (int i = 1; i < n; ++i) {\n            cin >> par[i];\n            --par[i];\n        }\n        vector<pair<char, int>> inp(q);\n        vector<int> con(n, 1);\n        for (int i = q - 1; i >= 0; --i) {\n            cin >> inp[i].first >> inp[i].second;\n            --inp[i].second;\n            if (inp[i].first == 'M')\n                con[inp[i].second] = 0;\n        }\n        unionfind uf(n);\n        for (int i = 1; i < n; ++i)\n            if (con[i])\n                uf.tounion(par[i], i);\n\n        long long sum = 0;\n        for (auto i : inp) {\n            if (i.first == 'M')\n                uf.tounion(par[i.second], i.second);\n            else\n                sum += uf.find(i.second) + 1;\n        }\n        cout << sum << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\nstruct SkewHeap{\n\tSkewHeap *l,*r;\n\tint val;\n};\n\nSkewHeap* meld(SkewHeap* a, SkewHeap* b) {\n    if (a==NULL) return b;\n    if (b==NULL) return a;\n    if (a->val < b->val) swap(a, b);\n    a->r = meld(a->r, b);\n\tstd:: swap(a->l, a->r);\n    return a;\n}\nSkewHeap* insert(SkewHeap* a,int v) {\n    SkewHeap* b=new SkewHeap;\n\tb->l=b->r=NULL;\n\tb->val=v;\n\treturn meld(a,b);\n}\nint getmax(SkewHeap* a){\n\treturn a->val;\n}\nSkewHeap* pop(SkewHeap* a){\n\tSkewHeap* res = meld(a->l,a->r);\n\tdelete a;\n\treturn res;\n}\nvoid del(SkewHeap* a){\n\tif(a->l)del(a->l);\n\tif(a->r)del(a->r);\n\tdelete a;\n}\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nSkewHeap* bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u]=meld(bh[u],bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(bh[u] && t<getmax(bh[u])){\n\t\tans+=u+1;\n\t\tbh[u]=pop(bh[u]);\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)if(bh[i]){\n\t\t\tdel(bh[i]);\n\t\t\tbh[i]=NULL;\n\t\t}\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v]=insert(bh[v],i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct segtree{\n    int n;\n    vector<pii> dat;\n    segtree(int size,pii x){\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,x);\n    }\n    // update k th element\n    void update(int k,pii a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=max(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    // min [a, b)\n    pii query(int a,int b) { return query(a,b,0,0,n); }\n    pii query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return make_pair(-1,-1);\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return max(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    while(true){\n        int n,q;\n        cin >> n >> q;\n        if(n==0 and q==0) break;\n\n        vector<int> parent(n,-1);\n        vector<vector<int>> children(n);\n        vector<bool> is_leaf(n,true);\n        rep(i,1,n){\n            cin >> parent[i];\n            --parent[i];\n            children[parent[i]].emplace_back(i);\n            is_leaf[parent[i]]=false;\n        }\n\n        vector<int> depth(n);\n        vector<vector<int>> belong(n);\n        vector<segtree> segs;\n        function<void(int,int)> calc_depth=[&](const int v,const int d){\n            depth[v]=d;\n            for(const auto& u:children[v]) calc_depth(u,d+1);\n        };\n        calc_depth(0,0);\n        rep(i,0,n) if(is_leaf[i]){\n            segs.emplace_back(segtree(depth[i]+1,make_pair(-1,-1)));\n            segs.back().update(0,make_pair(0,0));\n            int v=i;\n            while(v!=-1){\n                belong[v].emplace_back(segs.size()-1);\n                v=parent[v];\n            }\n        }\n\n        ll ans=0;\n        rep(i,0,q){\n            char ch;\n            int v;\n            cin >> ch >> v;\n            --v;\n            if(ch=='M') for(const int tmp:belong[v]) segs[tmp].update(depth[v],make_pair(depth[v],v));\n            else ans+=segs[belong[v][0]].query(0,depth[v]+1).second+1;\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\tarr[1].isMarked = true;\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tarr[_index].isMarked = true;\n\t\tfor (auto itr : arr[_index].c)arr[itr].nearest_index = _index;\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int MAX_NODE = 100001;\n\nstruct Query {\n\tchar q;\n\tlong long v;\n};\n\nint parent(long long uft[],bool mark[], int c) {\n\tif (mark[c] || uft[c] == c)return c;\n\treturn uft[c] = parent(uft, mark ,uft[c]);\n}\n\nint main() {\n\twhile (true) {\n\t\tint N, Q;\n\t\tlong long ans = 0;\n\t\tlong long uft[MAX_NODE] = { 0 };\n\t\tbool mark[MAX_NODE] = { 0 };\n\t\tQuery query[MAX_NODE];\n\n\t\tuft[1] = 1;\n\t\tmark[1] = true;\n\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tcin >> uft[i + 1];\n\t\t}\n\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> query[i].q >> query[i].v;\n\t\t\tif (query[i].q == 'M') {\n\t\t\t\tmark[query[i].v] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tif (query[i].q == 'M') {\n\t\t\t\tmark[query[i].v] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += parent(uft, mark, query[i].v);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  UnionFind(int n = 0): par(n, -1){}\n  int root(int x){\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return;\n    par[y] = x;\n  }\nprivate:\n  vector<int> par;\n};\n\nint n, q;\nint p[100000];\nstring t[100000];\nint v[100000];\nint m[100000];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  while (cin >> n >> q, n){\n    memset(m, 0, sizeof(m));\n    m[0]++;\n    UnionFind uf(n);\n    for (int i = 1; i < n; i++){\n      cin >> p[i], p[i]--;\n    }\n    for (int i = 0; i < q; i++){\n      cin >> t[i] >> v[i], v[i]--;\n      if (t[i] == \"M\") m[v[i]]++;\n    }\n    for (int i = 0; i < n; i++){\n      if (!m[i]){\n        uf.unite(p[i], i);\n      }\n    }\n    long long s = 0;\n    for (int i = q - 1; i >= 0; i--){\n      if (t[i] == \"M\"){\n        if (!--m[v[i]]){\n          uf.unite(p[v[i]], v[i]);\n        }\n      }\n      else s += uf.root(v[i]) + 1;\n    }\n    cout << s << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint N, Q, t, res;\nint act[100010];\nbool mark[100010];\nstring op;\n\nint main()\n{\n    while(cin >> N >> Q && N)\n    {\n        res = 0;\n        fill_n(mark, 100010, false);\n        mark[1] = true;\n        for(int i = 2; i <= N; ++i)\n        {\n            cin >> t;\n            act[i] = t;\n        }\n        for(int i = 0; i < Q; ++i)\n        {\n            cin >> op >> t;\n            if(op == \"M\")\n                mark[t] = true;\n            if(op == \"Q\")\n            {\n                while(!mark[t])\n                    t = act[t];\n                res += t;\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst int MAX = 1e5;\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvector<int> tr[MAX+1];\nint par[MAX+1],n,q;\nint mark[MAX+1];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    \n    par[y] = x;\n}\n\nbool same(int x,int y){\n    return find(x) == find(y);\n}\n\nint tmp[MAX+1];\nvoid rec(int x,int y,int z){\n    int t = z;\n    tmp[x] = y;\n    if(mark[x]){\n        t = x;\n    }\n    unite(t,x);\n    \n    for(int i = 0 ; i < tr[x].size() ; i++){\n        rec(tr[x][i],x,t);\n    }\n}\n\nint main(){\n    int p,num;\n    char m;\n    while(cin >> n >> q , n + q){\n        ll sum = 0;\n        stack<P> st;\n        init();\n        fill(mark,mark+MAX,0);\n        fill(tmp,tmp+MAX,0);\n        mark[0] = 1;\n        for(int i = 0 ; i < MAX ; i++){\n            tr[i].clear();\n        }\n        for(int i = 1 ; i < n ; i++){\n            cin >> p; --p;\n            tr[p].push_back(i);\n        }\n        for(int i = 0 ; i < q ; i++){\n            cin >> m >> num; --num;\n            st.push(P(m,num));\n            \n            if(m == 'M'){\n                ++mark[num];\n            }\n        }\n        rec(0,0,0);\n        while(q--){\n            P p = st.top(); st.pop();\n            \n            if(p.first == 'Q'){\n                sum += find(p.second);\n            }\n            else{\n                if(!mark[p.second]) {\n                    --mark[p.second];\n                    unite(tmp[p.second],p.second);\n                }\n            }\n        }\n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX ((1ll<<60)-1)\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll mini=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[mini]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tbuf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+1));\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\nint par[100001];\nint rank1[100001];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n);\n\t\trep(i, n-1) {\n\t\t\tcin >> par[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tint marked[100001] = {}; marked[0] = 1;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\tll out = 0;\n\t\trep(i,n+1) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint pre[100005];\nint find_root(int x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    int n, q;\n    while(scanf(\"%d%d\", &n, &q), n || q)\n    {\n        pre[1] = 1;\n        for(int i = 2; i <= n; i++)\n            scanf(\"%d\", &pre[i]);\n        char a;\n        int b;\n        int ans = 0;\n        while(q--)\n        {\n            scanf(\" %c%d\", &a, &b);\n            if(a == 'Q')\n                ans += find_root(b);\n            else\n                pre[b] = b;\n        }\n        printf(\"%dn\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<vector>\n#define oo 0x3f3f3f33f\nusing namespace std;\nint n, m, vis[100010];\nint pre[100010];\nint Quary(int x)\n{\n    if(vis[pre[x]]==1)\n        return pre[x];\n    return Quary(pre[x]);\n}\nint main()\n{\n    int i;\n    while(scanf(\"%d%d\", &n, &m), n+m)\n    {\n        memset(vis, 0, sizeof(vis));\n        char str[6];\n        long long ans = 0;\n        int root, v;\n        vis[1]=1;\n        pre[1]=1;\n        for(i=2; i<=n; i++)\n        {\n            scanf(\"%d\", &root);\n            pre[i]=root;\n        }\n        for(i=0; i<m; i++)\n        {\n            scanf(\"%s%d\", str, &v);\n            if(str[0]=='M')\n                vis[v]=1;\n            else\n                ans+=Quary(v);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define N 123456\n#define REP(i,n) for(int (i) = 0 ; (i) < (n) ; ++(i))\n\nint anc[N];\nint op[N];\nint opv[N];\nint markc[N];\n\nint root(int x)\n{\n  return markc[x]>0?x:anc[x]=root(anc[x]);\n}\n\nint main()\n{\n  int n,q;\n  while(cin >> n >> q,n+q){\n    memset(anc,0,sizeof(anc));\n    memset(op,0,sizeof(op));\n    memset(opv,0,sizeof(opv));\n    memset(markc,0,sizeof(markc));\n\n    markc[0] = 1;\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      anc[i+1]=a-1;\n    }\n   REP(i,q){\n     char c;\n     int a;\n     cin >> c >> a;\n     if(c == 'M'){\n       op[i] = 1;\n       markc[a-1]++;\n     }\n     opv[i] = a-1;\n   }\n   long sum = 0;\n   for(int i = q-1;i>=0;--i){\n     if(op[i]){\n       markc[opv[i]]--;\n     }else{\n       sum += root(opv[i])+1;\n     }\n   }\n   cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int N = 100005;\nint a[2][N];\n\nint sum;\n\nint find_ance(int index) {\n\t\n\tif (a[1][index]==1) {\n\t\treturn index;\n\t}\n\telse {\n\t\treturn find_ance(a[0][index]);\n\t}\n}\n\nint main() {\n\tint n, q;\n\tchar op;\n\tint quest;\n\tsum = 0;\n\tcin >> n >> q;\n\ta[0][1] = 1;\n\ta[1][1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tcin >> a[0][i];\n\t\ta[1][i] = 0;\n\t}\n\n\twhile (true) {\n\t\tcin >> op >> quest;\n\t\tif (op == '0'&&quest == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op == 'M') {\n\t\t\ta[1][quest] = 1;\n\t\t}\n\t\telse {\n\t\t\tsum += find_ance(quest);\n\t\t}\n\t}\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 2e5 + 4;\nint par[maxn];\nint x[1010], y[1010];\nint find(int x){\n\tif(par[x] == x) return x;\n\telse return find(par[x]);\n}\nint main(){\n\tint n, q;\n\twhile(scanf(\"%d%d\", &n, &q)!=EOF){\n\t\tif(n == 0 && q == 0) break;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tint ans = 0;\n\t\twhile(q--){\n\t\t\tchar s[2];\n\t\t\tint x;\n\t\t\tscanf(\"%s\", s);\n\t\t\tif(s[0] == 'Q'){\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tans += find(x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tpar[x] = x;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* vim: set st=2 sts=2 : */\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<char,int> P;\n\nint N,Q;\nbool mark[100000];\nint tree[100000];\nP query[100000];\n\nint get(int i){\n  if(mark[i]) return i;\n  return tree[i]=get(tree[i]);\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    tree[0]=0;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c%d\",&query[i].first,&query[i].second);\n      query[i].second--;\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second]+=1;\n      }\n    }\n\n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      if(query[i].first=='M'){\n        mark[query[i].second]-=1;\n      }else{\n        c+=get(query[i].second)+1;\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    //x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y; // parent of x is y\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    long long int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct UnionFind{\n    vector<int> p, rank, v, mark, d[100000];\n    int n;\n    UnionFind(int siz){\n        n = siz;\n        p.resize(n), rank.resize(n, 0), v.resize(n, 0), mark.resize(n, 0);\n        mark[0]++;\n        for(int i = 0; i < n; i++)  p[i] = i;\n        for(int i = 1; i < n; i++)  cin >> v[i], v[i]--;\n        for(int i = 1; i < n; i++)  d[v[i]].push_back(i);\n        dfs(0, 0);\n    }\n\n    void dfs(int pos, int dep){\n        rank[pos] = dep;\n        for(int next : d[pos])  dfs(next, dep+1);\n    }\n\n    int findSet(int x){\n        if(p[x] != x)   p[x] = findSet(p[x]);\n        return p[x];\n    }\n\n    void unite(int x, int y){\n        x = findSet(x), y = findSet(y);\n        if(x == y)  return;\n        if(rank[x] < rank[y]){\n            p[y] = x;\n        }else{\n            p[x] = y;\n        }\n    }\n\n    void dfs2(int pos){\n        if(pos != 0 && mark[pos] == 0){\n            unite(pos, v[pos]);\n        }\n        for(int next : d[pos]){\n            dfs2(next);\n        }\n    }\n};\n\ntypedef long long ll;\n\nint main(){\n    int n, q;\n    while(cin >> n >> q, n+q){\n        UnionFind uf(n);\n        char op[q];\n        int x[q];\n        for(int i = 0; i < q; i++){\n            cin >> op[i] >> x[i];\n            x[i]--;\n            if(op[i] == 'M')    uf.mark[x[i]]++;\n        }\n        uf.dfs2(0);\n        ll ans = 0;\n        for(int i = q-1; i >= 0; i--){\n            if(op[i] == 'Q'){\n                ans += uf.findSet(x[i])+1;\n            }else{\n                uf.mark[x[i]]--;\n                if(uf.mark[x[i]])   continue;\n                uf.unite(x[i], uf.v[x[i]]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\nusing namespace std;\n\n#define MAX_N 100002\n\n/* union find */\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める(あえて根の張りなおしをしない)\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    if(rank[x] < rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\nint N,Q, marked[MAX_N];\n\nint find_nearest_idx(int index) {\n    if(marked[index]) return index;\n    return find_nearest_idx(par[index]);\n}\n\nmain() {\n    while(1) {\n        scanf(\"%d %d\",&N,&Q);\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        init(N+2);\n        \n        marked[1] = 1; // node 1 is already marked \n        for(int i=2;i<=N;i++) {\n            int d;\n            scanf(\"%d\", &d);\n            par[i] = d; // parent of i is d\n            //unite(i,d);\n        }\n\n        // Question\n        int ans = 0;\n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            //scanf(\"%c %d\", &op, &index);\n            if(op == 'Q')\n                ans += find_nearest_idx(index);\n            else if(op == 'M')\n                marked[index] = 1;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <memory>\n#include <utility>\n\ntemplate <class W> class pairing_heap {\n  using T = typename W::value_type;\n\npublic:\n  using value_type = T;\n\nprivate:\n  class node_type;\n  using node_ptr = std::unique_ptr<node_type>;\n  class node_type {\n  public:\n    T value;\n    node_ptr head;\n    node_ptr next;\n\n    node_type(const T value) : value(value), head(), next() {}\n  };\n\n  static node_ptr merge(node_ptr x, node_ptr y) {\n    if (!x)\n      return y;\n    if (!y)\n      return x;\n    if (!W::compare(x->value, y->value))\n      std::swap(x, y);\n    y->next = std::move(x->head);\n    x->head = std::move(y);\n    return x;\n  }\n  static node_ptr merge_list(node_ptr list) {\n    if (!list || !list->next)\n      return list;\n    node_ptr next = std::move(list->next);\n    node_ptr rem = std::move(next->next);\n    return merge(merge(std::move(list), std::move(next)),\n      merge_list(std::move(rem)));\n  }\n\n  node_ptr root;\n\n  pairing_heap(node_ptr root) : root(std::move(root)) {}\n\npublic:\n  pairing_heap() = default;\n\n  bool empty() const { return !root; }\n  T top() const {\n    assert(!empty());\n    return root->value;\n  }\n\n  void push(const T x) {\n    root = merge(std::move(root), std::make_unique<node_type>(x));\n  }\n  void pop() {\n    assert(!empty());\n    root = merge_list(std::move(root->head));\n  }\n\n  static pairing_heap meld(pairing_heap x, pairing_heap y) {\n    return pairing_heap(merge(std::move(x.root), std::move(y.root)));\n  }\n};\n\ntemplate <class T> class greater_equal_ordered_set {\npublic:\n  using value_type = T;\n  static constexpr bool compare(const T& x, const T& y) noexcept {\n    return x >= y;\n  }\n};\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include<stack>\n\nvoid solve(const int n, const int q) {\n  using heap_type = pairing_heap<greater_equal_ordered_set<int>>;\n\n  std::vector<int> p(n), deg(n, 0);\n  for (int i = 1; i != n; i += 1) {\n    std::cin >> p[i];\n    p[i] -= 1;\n    deg[p[i]] += 1;\n  }\n  std::vector<heap_type> ph(n);\n  std::vector<int> time(n, q);\n  time[0] = -1;\n  for (int i = 0; i != q; i += 1) {\n    char c;\n    std::cin >> c;\n    switch (c) {\n    case 'M': {\n      int v;\n      std::cin >> v;\n      v -= 1;\n      time[v] = std::min(time[v], i);\n    } break;\n    case 'Q': {\n      int v;\n      std::cin >> v;\n      v -= 1;\n      ph[v].push(i);\n    } break;\n    }\n  }\n  std::stack<int> st;\n  for (int i = 0; i != n; i += 1) {\n    if (deg[i] == 0)\n      st.push(i);\n  }\n  long long ans = 0;\n  while (!st.empty()) {\n    const int v = st.top();\n    st.pop();\n    auto& pv = ph[v];\n    while (!pv.empty() && time[v] < pv.top()) {\n      pv.pop();\n      ans += v + 1;\n    }\n    if (v == 0)\n      continue;\n    ph[p[v]] = heap_type::meld(std::move(ph[p[v]]), std::move(pv));\n    deg[p[v]] -= 1;\n    if (deg[p[v]] == 0)\n      st.push(p[v]);\n  }\n  std::cout << ans << std::endl;\n}\n\nint main() {\n  while (true) {\n    int n, q;\n    std::cin >> n >> q;\n    if (n == 0 && q == 0)\n      break;\n    solve(n, q);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100005;\nint p[MAX_N], mark[MAX_N];\n\nint find(int x) {\n    while (!mark[x]) {\n        x = p[x];\n    }\n    return x;\n}\n\nint main() {\n    int n, q;\n    while (cin >> n >> q) {\n        if (n == 0 && q == 0) break;\n        for (int i = 1; i <= n; ++i) mark[i] = 0;\n        mark[1] = 1;\n        p[1] = 1;\n\n        for (int i = 2; i <= n; ++i) cin >> p[i];\n        long long res = 0;\n        char c;\n        int t;\n\n        while (q--) {    \n            cin >> c >> t;\n            if (c == 'M') mark[t] = 1;\n            else res += find(t);\n        }\n        cout << res << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        g.addEdge(s, to);\n        make_dfs(to, g_, g, visited);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        for (int i = 0; i < N - 1; i++) {\n            int to;\n            cin >> to;\n            to--;\n            g_.addEdge(to, i);\n            g_.addEdge(i, to);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        make_dfs(0, g_, g, visited);\n\n        using P = pair<char, int>;\n        vector<P> query(Q);\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = i;\n        }\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            query[q] = make_pair(c, n);\n            if (c == 'M') {\n                marked[n] = true;\n            }\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        int sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n                const int s = q.second;\n                set<int> cand;\n                for (const int to : g_.edge[s]) {\n                    cand.insert(to);\n                }\n                for (const int to : g.edge[s]) {\n                    cand.erase(to);\n                }\n                const int par = *cand.begin();\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n            } else {\n                // cerr << \"comp [\";\n                // for (const int c : comp) {\n                //     cerr << c << \",\";\n                // }\n                // cerr << \"]\" << endl;\n                // cerr << \"uf [\";\n                // for (int i = 0; i < N; i++) {\n                //     cerr << uf.find(i) << \",\";\n                // }\n                // cerr << \"]\" << endl;\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nstruct UnionFind{\n\tint par[100100],rank[100100];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t\treturn;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tpar[y]=x;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nint N,Q;\nchar qtype[100100];\nint qval[100100];\nint par[100100];\nint col[100100];\nvector<int> g[100100];\nbool used[100100];\nvoid dfs(int v,int val){\n\tif(col[v]==-1)col[v]=val;\n\tfor(int i=0;i<g[v].size();i++)dfs(g[v][i],col[v]);\n}\nint solve(){\n\tscanf(\"%d %d\",&N,&Q);\n\tif(N+Q==0)return 1;\n\tuf.init(N+10);\n\tmemset(used,false,sizeof(used));\n\tfor(int i=1;i<=N;i++)g[i].clear();\n\tfor(int i=2;i<=N;i++)scanf(\"%d\",&par[i]);\n\tfor(int i=2;i<=N;i++){\n\t\tg[par[i]].pb(i);\n\t}\n\tcol[1]=1;\n\tfor(int i=2;i<=N;i++)col[i]=-1;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\" %c %d\",&qtype[i],&qval[i]);\n\t\tif(qtype[i]=='M')col[qval[i]]=qval[i];\n\t}\n\tdfs(1,1);\n\t//for(int i=1;i<=N;i++)printf(\"%d:%d\\n\",i,col[i]);\n\tfor(int i=1;i<=N;i++){\n\t\tif(col[i]!=i)uf.unite(col[i],i);\n\t}\n\tfor(int i=0;i<Q;i++){\n\t\tif(qtype[i]=='M'){\n\t\t\tif(used[qval[i]]){\n\t\t\t\tqtype[i]='E';\n\t\t\t}else{\n\t\t\t\tused[qval[i]]=true;\n\t\t\t}\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i=Q-1;i>=0;i--){\n\t\tint val = qval[i];\n\t\tif(qtype[i]=='M'){\n\t\t\tuf.unite(par[val],val);\n\t\t\t//cout << \"Query \" << i << endl; \n\t\t}else if(qtype[i]=='Q'){\n\t\t\tans += (ll)uf.find(val);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long \nusing namespace std;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 30;\n\nstruct BIT{\n    int N;\n    vector<int> dat;\n    BIT() {}\n    BIT(int n) {\n        N = n;\n        dat.resize(N + 1);\n    }\n    // update k th element (0-index)\n    void add(int k, int x){\n        k++;\n        while(k <= N){\n            dat[k] += x;\n            k += k&-k;\n        }\n    }\n    // sum [0, k) (0-index)\n    int sum(int k){\n        int s = 0;\n        while(k > 0){\n            s += dat[k];\n            k -= k&-k;\n        }\n        return s;\n    }\n    // sum [a, b) (0-index)\n    int query(int a, int b){\n        return sum(b) - sum(a);\n    }\n};\n\nint n, q;\nvector<int> G[MAX_V]; \n\nclass Euler_Tour{\npublic:\n    // vector<vector<int> > g;\n    //begin[v],end[v]はそれぞれvがオイラーツアー上で最初と最後に現れるインデックス\n    //[begin[v], end[v])がvを根とする部分木 (半開区間に注意)\n    vector<int> euler_tour, begin, end, dist;\n    Euler_Tour(int n) : /*g(n),*/ begin(2 * n), end(2 * n){};\n    int k = 0, root = 0;\n    void dfs(int curr, int par){\n        begin[curr] = k;\n        euler_tour.push_back(curr);\n        k++;\n        for(auto next : G[curr]){\n            if(next == par) continue;\n            dfs(next, curr);\n            euler_tour.push_back(curr);\n            k++;\n        }\n        end[curr] = k;\n    }\n};\n\nint root = 0;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs2(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs2(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    memset(depth, 0, sizeof(depth));\n    for(int i = 0; i < MAX_LOG_V; i++){\n        for(int j = 0; j < MAX_V; j++){\n            parent[i][j] = 0;\n        }\n    }\n    dfs2(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nint lca(int u, int v){\n    if(depth[u] > depth[v]) swap(u, v);\n    for(int k = 0; k < MAX_LOG_V; k++){\n        if((depth[v] - depth[u]) >> k & 1){\n            v = parent[k][v];\n        }\n    }\n    if(u == v) return u;\n    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n        if(parent[k][u] != parent[k][v]){\n            u = parent[k][u];\n            v = parent[k][v];\n        }\n    }\n    return parent[0][u];    \n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> q;\n        if(n + q == 0) break;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 1, n){\n            int v;\n            cin >> v;\n            v--;\n            G[v].push_back(i);\n            G[i].push_back(v);\n        }\n        vector<bool> marked(n);         \n        Euler_Tour et(n);\n        et.dfs(0, -1);\n        init(n);\n        BIT bt(2 * n);\n        // mark 0\n        marked[0] = true;\n        bt.add(et.begin[0], 1);\n        bt.add(et.end[0] - 1, -1);\n        int ans = 0;\n        rep(i, 0, q){\n            char c; int v;\n            cin >> c >> v;\n            v--;\n            if(c == 'M'){\n                marked[v] = true;\n                bt.add(et.begin[v], 1);\n                bt.add(et.end[v] - 1, -1);\n            }else{\n                int tmp = 0;\n                // check v is marked\n                if(marked[v]){\n                    tmp = v;\n                }else{\n                    int nowv = v;\n                    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n                        int tmpv = parent[k][nowv];\n                        if(tmpv == -1) tmpv = 0;\n                        int val = bt.query(et.begin[tmpv], et.begin[v]);\n                        if(val <= 0){\n                            nowv = tmpv;\n                        }\n                    }\n                    tmp = parent[0][nowv];\n                    if(tmp < 0) tmp = 0;     \n                }\n                ans += (tmp + 1);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    while (1) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        int mark[N+1];\n        mark[1] = 1; \n\n        int tree[N+1];\n        tree[1] = 0;\n        for (int i=2; i<=N; ++i) {\n            cin >> tree[i];\n        } \n\n        int sum = 0;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            if (ope == 'Q') {\n                for (int j=v; j>=1; j=tree[j]) {\n                    if (mark[j] == 1) {\n                        sum += j;\n                        break;\n                    }\n                }\n            } else if (ope == 'M') {\n                mark[v] = 1;\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nstruct Query {\n    char type;\n    int v;\n    Query(){}\n    Query(char _type, int _v) : type(_type), v(_v) {}\n    void print() {\n        cout << type << \" \" << v << endl;\n    }\n};\n\nusing Graph = vector<vector<int>>;\n\nint solve(const Graph& G, vector<Query> queries, vector<int>& lma, vector<bool>& marked) {\n    int n = G.size();\n    int q = queries.size();\n\n    vector<bool> exist(n);\n    exist[0] = true;\n    rep(i, q) {\n        exist[queries[i].v] = true;\n    }\n\n    map<int, vector<int>> H; // Graph\n    std::function<void(int, int, int)> makeTree = [&](int now, int pre, int pre_exist){\n        if (now != 0 && exist[now]) {\n            H[now].emplace_back(pre_exist);\n            H[pre_exist].emplace_back(now);\n            pre_exist = now;\n        }\n        for (auto nxt : G[now]) {\n            if (nxt == pre) continue;\n            makeTree(nxt, now, pre_exist);\n        }\n    };\n    makeTree(0, -1, 0);\n\n    std::function<void(int, int, int)> update = [&](int now, int pre, int pre_marked){\n        lma[now] = pre_marked;\n        if (marked[now]) {\n            pre_marked = now;\n        }\n        for (auto nxt : H[now]) {\n            if (nxt == pre) continue;\n            update(nxt, now, pre_marked);\n        }\n    };\n\n    // solve in H\n    int ans = 0;\n    rep(i, q) {\n        int v = queries[i].v;\n        if (queries[i].type == 'M') {\n            marked[v] = true;\n            update(0, -1, 0);\n        } else {\n            ans += lma[v] + 1;\n        }\n    }\n\n    std::function<void(int, int, int)> down = [&](int now, int pre, int pre_marked) {\n        lma[now] = pre_marked;\n        if (marked[now]) {\n            pre_marked = now;\n        }\n        for (auto nxt : G[now]) {\n            if (nxt == pre) continue;\n            down(nxt, now, pre_marked);\n        }\n    };\n    down(0, -1, 0);\n\n    return ans;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, q;\n    while (cin >> n >> q, n) {\n        Graph G(n);\n        rep(i, n - 1) {\n            int x;\n            cin >> x;\n            x--;\n            G[i + 1].emplace_back(x);\n            G[x].emplace_back(i + 1);\n        }\n        int i = 0;\n        int ans = 0;\n        vector<int> lma(n, 0);\n        vector<bool> marked(n, false);\n        marked[0] = true;\n        while (i < q) {\n            vector<Query> queries;\n            while (i < q && (int)queries.size() <= sqrt(q)) {\n                char type;\n                int v;\n                cin >> type >> v;\n                v--;\n                queries.emplace_back(type, v);\n                i++;\n            }\n            ans += solve(G, queries, lma, marked);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){ // ?????????x?????????????????????????????????????????´??????\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    par[x] += par[y];\n    par[y] = x;\n    if(rank[x]==rank[y]) rank[x]++;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\n\nvector<vector<int> > tree;\nvector<int> par;\nbool marked[100005];\nbool mark_dup[100005];\n\nint main(){\n  int n,q;\n  while(cin>>n>>q, n|q){\n    tree = vector<vector<int> >(n, vector<int>());\n    par = vector<int>(n, 0);\n    repl(i,1,n){\n      int d;\n      scanf(\"%d\", &d);\n      d--;\n      tree[d].pb(i);\n      par[i] = d;\n    }\n\n    vector<char> qc(q); // query char\n    vector<int>  qi(q); // query int\n    rep(i,q) scanf(\" %c %d\", &qc[i], &qi[i]);\n    rep(i,q) qi[i]--;\n\n    // ??¨??????????????¨??¨?????????????????????\n    fill(marked, marked+n, false);\n    fill(mark_dup, mark_dup+q, false);\n    marked[0]=true;\n    rep(i,q) if(qc[i]=='M'){\n      if(marked[qi[i]]) mark_dup[i]=true;\n      else marked[qi[i]] = true;\n    }\n\n    // ??????????????????????????????????????¨?????????UnionFind??????\n    UnionFind uf = UnionFind(n);\n    rep(i,n) for(auto v : tree[i]){\n      if(!marked[v]) uf.unite(i,v);\n    }\n\n    // ?????¨???????????????????????????\n    long ans=0;\n    for(int i=q-1; i>=0; i--){\n      if(qc[i]=='M' && !mark_dup[i]){\n        uf.unite(par[qi[i]], qi[i]);\n      } else if(qc[i]=='Q'){\n        int x = qi[i];\n        //if(uf.find(x) == x) x=par[x]; //??????????????§???????????????????????????\n        ans += (long)uf.find(x)+1;\n      }\n    }\n\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<utility>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 1005;\nint p[100005],ran[100005];\nvoid init(int n)\n{\n    for(int i = 0;i <= n;i++)\n    {\n        ran[i] = 0;\n    }\n    ran[1] = 1;\n}\nint find(int x)\n{\n    if(ran[p[x]])\n        return 1;\n    else\n        return find(p[x]) + 1;\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"C:\\\\Users\\\\巍巍\\\\Desktop\\\\in.txt\",\"r\",stdin);\n\t//freopen(\"C:\\\\Users\\\\巍巍\\\\Desktop\\\\out.txt\",\"w\",stdout);\n\t#endif // LOCAL\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q) != EOF)\n    {\n        if(!n&&!q)break;\n        init(n);\n        for(int i = 1;i < n;i++)\n            scanf(\"%d\",&p[i]);\n        int ans = 0;\n        for(int i = 1;i <= q;i++)\n        {\n            char s[2];\n            int x;\n            scanf(\"%s%d\",s,&x);\n            if(s[0] == 'M')\n                ran[x] = 1;\n            else\n                ans = ans + find(x);\n        }\n        printf(\"%d\\n\",ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nconst int MAX_N=100000+1;\nint a[MAX_N];\nint N,Q;\nint main(){\n   // freopen(\"1.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&N,&Q)!=EOF){\n        if(N==0&&Q==0)break;\n        a[1]=1;\n        for(int i=2;i<=N;i++){\n            scanf(\"%d\",&a[i]);\n        }\n        long long ans=0;\n        while(N--){\n            char c[2];int x;\n            scanf(\"%s%d\",c,&x);\n            if(c[0]=='Q'){\n                while(x!=a[x]){\n                    x=a[x];\n                }\n                ans+=x;\n            }\n            else {\n                a[x]=x;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair<char,int>\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    stack<pair<char,int> > qu;\n    int n;\n    \n    UF(int m):par(2*m),rank(2*m)\n    {\n        n=m;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x=0)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) break;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin>>n>>q;\n    Uf uf(n);\n    for(int i=1;i<n;i++)\n    {\n        int p;\n        cin>>p;\n        (uf.c[p]).push_back(i);\n    }\n    for(int i=0;i<q;i++)\n    {\n        char temp;\n        int v;\n        cin>>temp>>v;\n        (uf.qu).push(P(temp,v-1));\n        if(temp=='M') uf.m[v-1]=true;\n    }\n    int a,b;\n    cin>>a>>b;\n    uf.furiwake(0);\n    \n    ll ans=0;\n    for(int i=0;i<q;i++)\n    {\n        pair<char,int> a=qu.top();\n        qu.pop();\n        if(a.first=='Q')\n        {\n            ans+=uf.score(a.second);\n        }\n        else\n        {\n            uf.delmark(a.second);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int MAX = 110000;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n+2 ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n  bool mark[MAX];\n\n  while(cin >> n >> q ,n + q){\n    stack<P> st;\n    fill(mark,mark+MAX,false);\n    long long sum = 0;\n    init(n);\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'M'){\n\tmark[num] = true;\n      }\n      st.push(P(ch,num));\n    }\n    while(!st.empty()){\n      P p = st.top(); st.pop();\n\n      if(p.first == 'Q'){\n\tsum += find(p.second)+1;\n      }\n      else{\n\tmark[p.second] = false;\n\tunite(par[p.second],p.second);\n      }\n    }\n      cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\tif( root[edge[p][i]] == edge[p][i] ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\troot[ edge[p][i] ] = v;\n\t\t\tupdate(edge[p][i], v);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, q;\n\twhile(cin >> n >> q, n||q) {\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = -1;\n\t\tint sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tmarked[1] = true;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t}\n}\nint getnode(int x){\n\tif(par[x]==x||marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tlong long sum;\n\twhile(cin>>n>>q,n||q){\n\t\tinit(n);\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\tsum +=getnode(k);\n\t\t\t}\n\t\t\tif(op=='M'&&marked[k]==false){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t\tcout <<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass EulerTour{\nprivate:\n    int n;\n    vector<vector<int> > g;\n    vector<vector<int> > ind;//各頂点のインデックス\n\n    void dfs(int now, int par){\n        ind[now].push_back(v.size());\n        v.push_back(now);\n        for(int i = 0; i < g[now].size(); i++){\n            if(g[now][i] != par){\n                dfs(g[now][i],now);\n            }\n        }\n        ind[now].push_back(v.size());\n        v.push_back(now);\n    }\n\npublic:\n    vector<int> v;//オイラーツアーの頂点\n    EulerTour(){}\n    EulerTour(vector<vector<int> > in, int root){\n        g = in;\n        n = g.size();\n        ind = vector<vector<int> > (n);\n        dfs(root, -1);\n    }\n    void show(){\n        rep(i,v.size())cout << \" \" << v[i]; cout << endl;\n    }\n    pii get_ind(int i){\n        if(i >= n)return pii(INF,INF);\n        return pii(ind[i][0], ind[i][1]);\n    }\n\n};\n\nclass LazySegmentTree{\n private:\n     int n;\n     vector<long long> node, lazy;\n     long long node_init = 0; // sum, max, update\n     //long long node_init = LINF; // min\n     //long long lazy_init = 0; // default\n     long long lazy_init = LINF; // min, update (存在しない値)\n\n     long long lazy_update(long long a,long long b){\n         //return a+b; // sum query\n         //return max(a,b); // max query\n         //return min(a,b); // min query\n         return b; // update query\n     }\n\n     long long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n         //return a + b; // min query\n         return b; // update query\n         //return b * (r-l); // sum query\n     }\n\n     long long combine(long long a,long long b){\n         //return a+b; // sum query\n         return max(a,b); // max query\n         //return min(a,b); // min query\n         //return b;\n     }\n\n public:\n     LazySegmentTree(){}\n     LazySegmentTree(vector<long long> in){\n         n = 1;\n         while(n < in.size())n <<= 1;\n         node = vector<long long>(2*n, node_init);\n         lazy = vector<long long>(2*n, lazy_init);\n         for(int i = n-1+in.size()-1; i >= 0; i--){\n             if(n-1 <= i)node[i] = in[i-(n-1)];\n             else node[i] = combine(node[i*2+1], node[i*2+2]);\n         }\n     }\n     void eval(int k, int l, int r){\n         if(lazy[k] != lazy_init){\n             //cout << k << \" \" << l << \" \" << r  << \" \"<< lazy[k] << endl;\n             node[k] = node_update(node[k], lazy[k], l, r);\n             //cout << k << \" \" << node[k] << endl;\n             if(r - l > 1){\n                 lazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n                 lazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n             }\n             lazy[k] = lazy_init;\n         }\n     }\n     void update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n         if(r < 0)r = n;\n         eval(k,l,r);\n         if(b <= l || r <= a)return;\n         if(a <= l && r <= b){\n             lazy[k] = x;\n             eval(k,l,r);\n         }else{\n             update(a,b,x,2*k+1,l,(l+r)/2);\n             update(a,b,x,2*k+2,(l+r)/2,r);\n             node[k] = combine(node[2*k+1], node[2*k+2]);\n         }\n     }\n     long long query(int a, int b, int k = 0, int l = 0, int r = -1){\n         if(r < 0)r = n;\n         //cout << \"!\"<<a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n         eval(k,l,r);\n         if(b <= l || r <= a)return -INF;\n         if(a <= l && r <= b)return node[k];\n         /*\n         if(a <= l)return query(a,b,2*k+1,l,(l+r)/2);\n         else return query(a,b,2*k+2,(l+r)/2,r);\n         */\n         return combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n     }\n     void show(){\n         cout << \"node :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << node[i];\n         }\n         cout << endl;\n         cout << \"node :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << i;\n         }\n         cout << endl;\n         /*\n         cout << \"lazy :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << lazy[i];\n         }\n         cout << endl;\n         */\n     }\n };\n\n\nsigned main(void) {\n    int n,q;\n    while(1){\n        scanf(\"%lld %lld\",&n,&q);\n        if(n == 0)return 0;\n        vector<vi> g(n);\n        loop(i,1,n){\n            int a;\n            scanf(\"%lld\",&a);\n            a--;\n            g[a].push_back(i);\n        }\n        EulerTour et(g,0);\n        LazySegmentTree lst(vi(2*n,0));\n        //et.show();\n        int ans = 0;\n        while(q--){\n            char s[5];\n            scanf(\"%s\",s);\n            int v;\n            scanf(\"%lld\",&v);\n            v--;\n            pii ind = et.get_ind(v);\n            //cout << ind.first << \" \" << ind.second << endl;\n            if(s[0] == 'M'){\n                lst.update(ind.first,ind.second,v);\n            }else{\n                //lst.show();\n                //cout << lst.query(ind.first,ind.second) << endl;\n                ans += lst.query(ind.first,ind.first+1)+1;\n                //lst.show();\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100000\nusing namespace std;\nint n,q,u,t[Q],p[Q],ans;\nchar c[Q];\nbool marked[Q];\n\nint find(int x){\n  if(marked[x]) return x;\n  else return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[100005];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tfa[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')fa[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (fa[a] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint N, Q, t, res;\nint parent[100010];\nbool mark[100010];\nstring op;\n\nint main()\n{\n    while(cin >> N >> Q && N)\n    {\n        res = 0;\n        fill_n(mark, 100010, false);\n        mark[1] = true;\n        for(int i = 2; i <= N; ++i)\n        {\n            cin >> t; parent[i] = t;\n        }\n        for(int i = 0; i < Q; ++i)\n        {\n            cin >> op >> t;\n            if(op == \"M\")\n                mark[t] = true;\n            if(op == \"Q\")\n            {\n                while(!mark[t]) t = parent[t];\n                res += t;\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        // y を x に統合\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(parent[i], i);\n            }\n        }\n\n        ll ans = 0;\n        for(int i=Q-1; i>=0; i--) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else{\n    int a = query(t[v]);\n    t[v] = a;\n    return a;\n  }\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v]++;\n      qs.push_back(make_pair(order,v));\n    }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second]--;\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#define ll long long\n#define ALL(x) (x).begin(),(x).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define vi vector<int>\n#define vvi vector<vector<int>>\nusing namespace std;\n\nclass miniUnionFind {\nprivate:\n\tvector <vector<int>> Graph; // {Value,ParentID, isMarked}\npublic:\n\tvoid push(int x) {\n\t\tGraph.push_back({ x,x,false });\n\t}\n\tint search(int x) {\n\t\tint nextnode =x;\n\t\twhile (Graph[nextnode][1] != nextnode) {\n\t\t\tif (Graph[nextnode][2] == true) break;\n\t\t\tnextnode = Graph[nextnode][1];\n\t\t}\n\n\t\treturn nextnode;\n\t}\n\tvoid setparent(int u, int parent) {\n\t\tGraph[u][1] = parent;\n\t}\n\n\tvoid mark(int u) {\n\t\tGraph[u][2] = true;\n\t}\n};\nvoid subfunc(int N,int Q) {\n\tminiUnionFind muf;\n\tfor (int i = 0; i < N; i++) {\n\t\tmuf.push(i);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tint m; cin >> m; m--;\n\t\tmuf.setparent(i, m);\n\t}\n\tll ans = 0;\n\n\tfor (int times = 0; times < Q; times++) {\n\t\tchar c; cin >> c;\n\t\tint q; cin >> q;\n\t\tif (c == '0' and q == 0) break;\n\t\tq--;\n\t\tif (c == 'Q') {\n\t\t\tans += muf.search(q) + 1;\n\t\t}\n\t\telse {\n\t\t\tmuf.mark(q);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\nint main() {\n\tint N,Q; cin >> N >> Q;\n\twhile (N != 0 or Q != 0) {\n\t\tsubfunc(N, Q);\n\t\tcin >> N >> Q;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string.h>\n#include<algorithm>\n#include<queue>\n#include<list>\n#include<vector>\n#include<stdlib.h>\n#include<map>\n#include<stack>\n#define oo 0x3f3f3f3f\nusing namespace std;\nint n, q, pre[100100], a[100100];\nint query(int x)\n{\n  int  num=0;\n   if(pre[x]!=x)\n    num=1;\n    else\n        return num;\n    while(!a[pre[x]])\n    {\n        x=pre[x];\n      num++;\n    }\n    return num;\n}\nint main()\n{\n    while(scanf(\"%d%d\", &n, &q), n+q)\n    {\n        int ans=0;\n        memset(a, 0, sizeof(a));\n        a[1]=1;\n        for(int i=1; i<n; i++)\n        {\n            int num;\n            scanf(\"%d\", &num);\n            pre[i]=num;\n        }\n        while(q--)\n        {\n            int shu;\n            char str[10];\n            scanf(\"%s%d\", str, &shu);\n            if(str[0]=='M')\n              a[shu]=1;\n            else\n            {\n               ans+=query(shu);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n \nusing namespace std;\n \nlong long int n, q, res;\nint root[105000], parent[105000], marktime[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n \nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    y = root[x];\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n \nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n \nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfill(marktime, marktime + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M'){\n\t\troot[query[i].second] = query[i].second;\n\t\tmarktime[query[i].second]++;\n\t    }\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tif(--marktime[num] == 0)\n\t\t    unite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }       \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n#define MAXM 106\n#define MAXN 100006\n#define INF 2099999999\nusing namespace std;\nint n,m,fa[MAXN],a,caozuo[MAXN],ans;\nstruct node\n{\n\tchar p;\n\tint a;\n}work[MAXN];\nint root(int x)\n{\n\tif(fa[x]==x) return x;\n\tfa[x]=root(fa[x]);\n\treturn fa[x];\n};\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0) return 0;\n\t\tans=0;\n\t\tfa[1]=caozuo[1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&caozuo[i]);\n\t\t\tfa[i]=caozuo[i];\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%c%d\",&work[i].p,&work[i].a);\n\t\t\tif(work[i].p=='M') fa[work[i].a]=work[i].a;\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(work[i].p=='M')\n\t\t\t\tfa[work[i].a]=caozuo[work[i].a];\n\t\t\telse\n\t\t\t\tans+=root(work[i].a);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nint rak[100001],par[100001],p[100001];\n\nbool mark[100001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    }\n  }\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n    }else{\n    return find(par[x]);\n    }\n  }\n\nint findancestor(int x){\n  if(mark[par[x]]){\n    return par[x];\n    }else{\n      return findancestor(par[x]);\n    }\n  }\n  \nvoid unite(int x,int y){\n   x=find(x);\n   y=find(y);\n   if(x==y) return;\n   \n   if(rak[x]<rak[y]){\n     par[y]=x;\n     }else{\n     par[y]=x;         \n     if(rak[x]==rak[y]) rak[x]++;\n     }\n  }\n\nint main() {\n  \n  while(1){\n\n   int N,Q;  scanf(\"%d %d\",&N,&Q);\n   \n   if(N==0&&Q==0) break;\n   \n   memset(mark,0,sizeof(mark));\n   \n   memset(p,0,sizeof(p));\n   \n   init(N);   mark[1]=1;\n   \n   for(int i=1; i<=N-1; i++){\n     int x; cin>>x;\n     p[i+1]=x;\n     }\n     \n   for(int i=N; i>=2; i--){\n     unite(p[i],i);\n     }\n     \n   long long ans=0;\n     \n   for(int i=0; i<Q; i++){\n     \n     char t; cin>>t;\n     \n       if(t=='M'){\n       \n        int v; cin>>v; mark[v]=1;\n       \n       }else if(t=='Q'){\n         \n        int v; cin>>v; \n        ans+=findancestor(v);\n         \n       }\n     \n     }\n               \n              cout<<ans<<endl;\n              \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\nint solve(int x){\n    x = root[x];\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n\nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T, int* OT);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tint OrigT[N+1];\n\t\tT[1] = OrigT[1] = 1;\n\t\tfor(int i=2; i<=N; i++){ cin >> T[i]; OrigT[i] = T[i]; }\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(OrigT[v], T, OrigT); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T, int* OT){\n\tint ans = v;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 2e5 + 5;\n#define bug(x) printf(\"  %s = %d \\n\",#x,x);\n#define mem(arr,x) memset(arr,x,sizeof arr);\nint par[maxn];\n\nint dfs(int pos){\n\tif(par[pos] != pos)\n\t\treturn dfs(par[pos]);\n\telse\n\t \treturn pos;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios_base::sync_with_stdio(0);\n\tint N,Q;\n\twhile(scanf(\"%d%d\",&N,&Q) == 2){\n\t\tif(N == 0 && Q == 0) break;\n\t\tpar[1] = 1;\n\t\tfor(int i = 2; i <=  N; i++){\n\t\t\tscanf(\"%d\",par + i);\n\t\t}\n\t\tchar op;\n\t\tint  pos;\n\t\tlong long  Sum = 0;\n\t\tgetchar();\n\t\tfor(int i = 1; i <= Q;i++){\n\t\t\tscanf(\"%c %d\",&op,&pos);\n//\t\t\tbug(op);\n\t\t\tif(op == 'Q'){\n\t\t\t\tSum += dfs(pos);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[pos] = pos;\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tprintf(\"%lld\\n\",Sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* vim: set st=2 sts=2 : */\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<char,int> P;\n\nint N,Q;\nbool mark[100000];\nint tree[100000];\nP query[100000];\n\nint get(int i){\n  if(mark[i]) return i;\n  return tree[i]=get(tree[i]);\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c %d\",&query[i].first,&query[i].second);\n      query[i].second--;\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second]=1;\n      }\n    }\n\n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      if(query[i].first=='M'){\n        mark[query[i].second]=0;\n      }else{\n        c+=get(query[i].second)+1;\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nint parent[100000];\nbool is_mark[100000], is_root[100000];\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tint input;\n\t\t\tcin >> input;\n\t\t\tparent[i] = --input;\n\t\t}\n\n\t\tstack<int> value;\n\t\tmemset(is_root, false, sizeof(is_root));\n\t\tis_root[0] = true;\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tvalue.push(v);\n\t\t\tif(ope == 'Q')\n\t\t\t\tis_mark[i] = false;\n\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tis_root[v] = true;\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tint ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tint v = value.top();\n\t\t\tvalue.pop();\n\n\t\t\tif(is_mark[i])\n\t\t\t\tuf.unite(v, parent[v]);\n\n\t\t\telse\n\t\t\t\tans += uf.find(v) + 1;\n\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nbool marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, false);\n\tmarked[1] = true;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    marked[query[i].second] = (query[i].first == 'M');\n\t}\n\tfor(int i=q;q--;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second] = false;\n\t    }else{\n\t\tres += r(query[i].second);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(x < y) swap(x, y);\n    par[x] = y, size[y] += size[x];\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  for(int N, Q; cin >> N >> Q && (N|Q);) {\n    vector<int> ps(N);\n    ps[0] = -1;\n    rep(i, N - 1) {\n      int c; scanf(\"%d\\n\", &c); c--;\n      ps[i + 1] = c;\n    }\n\n    set<pair<int, int>> st;\n    vector<pair<char, int>> qs;\n\n    rep(i, Q) {\n      char c; int x;\n      scanf(\"%c%d\\n\", &c, &x); x--;\n      if(c == 'M') {\n        st.insert({x, ps[x]});\n      }\n      qs.push_back({c, x});\n    }\n\n    tree::union_find uf(N);\n\n    REP(i, 1, N) {\n      if(!st.count({i, ps[i]})) {\n        uf(i, ps[i]);\n      }\n    }\n\n    reverse(all(qs));\n\n    ll sum = 0;\n\n    rep(i, Q) {\n      char c; int x; tie(c, x) = qs[i];\n      if(c == 'Q') {\n        sum += uf[x] + 1;\n      }\n      else {\n        uf(x, ps[x]);\n      }\n    }\n\n    printf(\"%lld\\n\", sum);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid read(int &x){\n\tx=0; char c=getchar();\n\tfor (;c<48;c=getchar());\n\tfor (;c>47;c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\n#define M 200005\nint op[M],fa[M],x[M],n,q;\nbool mark[M];\nvoid in(){\n\tint i;\n\tmemset(mark,0,sizeof(mark)); mark[1]=1; fa[1]=1;\n\tfor (i=2;i<=n;i++)read(fa[i]);\n\tfor (i=1;i<=q;i++){read(op[i]); read(x[i]); if(op[i]!=97)mark[x[i]]=1;}\n}\nint getf(int x){\n\tif (mark[x])return x;\n\treturn fa[x]=getf(fa[x]);\n}\nvoid solve(){\n\tint fx,i;\n\tlong long res=0;\n\tfor (i=q;i;i--){\n//\t\tprintf(\"op[%d]=%d %d\\n\",i,op[i],x[i]);\n\t\tif (op[i]==97){\n\t\t\tfx=getf(fa[x[i]]); res=res+fx;\n\t\t}\n\t\telse{\n\t\t\tmark[x[i]]=0;\n\t\t}\t\t\n\t}\n\tprintf(\"%lld\\n\",res);\n}\n\nint main(){\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\tfor (;;){\n\t\tread(n); read(q);\n\t\tif (n==0&&q==0)return 0;\n\t\tin(); solve();\t\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int N, Q;\n    int mark[100001];\n    int tree[100001];\n    while (1) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        mark[1] = 1; \n        tree[1] = 0;\n        for (int i=2; i<=N; ++i) {\n            cin >> tree[i];\n        } \n\n        long long sum = 0;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            if (ope == 'Q') {\n                for (int j=v; j>=1; j=tree[j]) {\n                    if (mark[j] == 1) {\n                        sum += j;\n                        break;\n                    }\n                }\n            } else if (ope == 'M') {\n                mark[v] = 1;\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100005;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n\n     for(int i = 1; i <= n; i++){\n      par[i] = i;\n      rank[i] = mark[i] = 0;\n    }\n\n   }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  long long ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nint par[MAX_N+1];//parents\nint Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint N,Q;\nlong long sum = 0;\nint tree[MAX_N+1];\n\nint nearestAncstr(int num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,int num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nint num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\ttree[0] = 0;\n\tfor(int i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tcin >>symbol >>num;num--;\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(true){\n\t\tif(symbol == '0' && num == 0)break;\n\t\toperate(symbol,num);\n\t\tcin >>symbol >>num;num--;\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\tcin >>N >>Q;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n\nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    y = root[x];\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n\nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n\nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n    r(x);r(y);\n}\n\nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\troot[query[i].second] = query[i].second;\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tunite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }        \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define IO ios::sync_with_stdio(false);cin.tie(0);\n#define INF 0x3f3f3f3f\ntypedef unsigned long long ll;\nusing namespace std;\nint n, q, m, pre[100010];\nchar c;\nint find(int x)\n{\n\twhile(x != pre[x]){\n\t\tx = pre[x];\n\t}\n\treturn x;\n}\nint main()\n{\n\tIO;\n\twhile(cin >> n >> q){ \n\t\tif(!n&&!q) break;\n\t\tll sum=0;\n\t\tpre[1] = 1;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> pre[i];\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c >> m;\n\t\t\tif(c == 'Q') \n\t\t\t\tsum += find(m);\n\t\t\telse {\n\t\t\t\tpre[m] = m;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tbool isMarked = false;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr[1].isMarked = true;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tarr[_index].isMarked = true;\n\t}\n\tint operationQ(int _index)\n\t{\n\t\tif (arr[arr[_index].parent_index].isMarked == true)return arr[_index].parent_index;\n\t\telse\n\t\t{\n\t\t\treturn operationQ(arr[_index].parent_index);\n\t\t}\n\t}\nprivate:\n\tNode arr[1000];\n};\n\nint main()\n{\n\tint N, Q, ans = 0;\n\tTree tree;\n\tcin >> N >> Q;\n\tfor (unsigned int i = 2 ; i < N+1; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\ttree.addNode(i, p);\n\t}\n\tfor (unsigned int i = 0; i < Q; i++)\n\t{\n\t\tchar qes;\n\t\tint index;\n\t\tcin >> qes >> index;\n\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\telse tree.operationM(index);\n\t}\n\tint hoge;\n\tcin >> hoge >> hoge;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n \n// ??¶??\\???????????°????????????\n#define MAX_N 100000 + 16\nint parent[MAX_N];\nint height[MAX_N];\n \nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n// End Of ??¶??\\???\n \n// ????§?????????¨?????\\?????°\nvector<int> children[MAX_N];\nint parent_tree[MAX_N];\nbool marked[MAX_N];\nint ancestor[MAX_N];\n// ?????????????¢?????????? ?????? + ??????\nstack<char> operation;\nstack<int>  target;\n \nvoid bfs(int index, int the_ancestor)\n{\n\tqueue<int> q_index;\n\tqueue<int> q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile (!q_index.empty())\n\t{\n\t\tthe_ancestor = q_ancestor.front(); q_ancestor.pop();\n\t\tindex = q_index.front(); q_index.pop();\n\t\tif (marked[index] == true)\n\t\t{\n\t\t\tthe_ancestor = index;\n\t\t}\n\t\tancestor[index] = the_ancestor;\n\t\tfor (vector<int>::iterator it = children[index].begin(); it != children[index].end(); ++it)\n\t\t{\n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n \n\tint N, Q;\n\twhile (cin >> N, cin >> Q, N)\n\t{\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i] = false;\n\t\t}\n\t\tmarked[0] = true;\n\t\tint p;\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tcin >> p; --p;\n\t\t\tparent_tree[i] = p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i)\n\t\t{\n\t\t\tchar o;\n\t\t\tint t;\n\t\t\tcin >> o >> t; --t;\n\t\t\tif (o == 'M')\n\t\t\t{\n\t\t\t\tif (marked[t])\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmarked[t] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperation.push(o);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(0, 0);\n\t\tinit(N);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tunite(i, ancestor[i]);\n\t\t}\n\t\tunsigned long long result = 0;\n\t\twhile (!operation.empty())\n\t\t{\n\t\t\tchar o = operation.top(); operation.pop();\n\t\t\tint t = target.top(); target.pop();\n\t\t\tif (o == 'Q')\n\t\t\t{\n\t\t\t\tresult += ancestor[find(t)] + 1;\t// ?¢????index???1????§?\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ??§?????????????????????????????????????????????????\\????????????¶??¶??????????\\????\n\t\t\t\tint p = ancestor[find(parent_tree[t])];\n\t\t\t\tunite(t, parent_tree[t]);\n\t\t\t\tancestor[find(t)] = p;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\t\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nconst int MAXN = 100000 + 10;\nint par[MAX];\nint Find(int x){\n\tif (x == par[x])\n\t\treturn par[x];\n\treturn Find(par[x]);\n}\nint main(){\n\tint n, q;\n\tchar ins[10];\n\tint v;\n\n\twhile (~scanf(\"%d%d\", &n, &q) && (n || q)){\n\t\tlong long sum = 0;\n\t\tmemset(par, 0, sizeof(par));\n\t\tpar[1] = 1;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%s%d\", ins, &v);\n\t\t\tif (strcmp(ins, \"M\") == 0){\n\t\t\t\tpar[v] = v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += Find(v);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100000+1109\n\nusing namespace std;\n\nchar ch[30];\nint n,m;\nint fa[MAXN];\nint a[MAXN],Q[MAXN];\nbool Is[MAXN];\nlong long Ans=0;\n\nint find(int x)\n{\n\tif(fa[x]==x) return x;\n\tif(Is[x]==true) return x;\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid read();\nvoid work();\nvoid print();\n\nint main()\n{\n\twhile(~scanf(\"%d%d\",&n,&m);)\n\t{\n\t\tmemset(Is,0,sizeof(Is));\n\t\tAns=0;\n\t\tread();\n\t\twork();\n\t\tprint();\n\t}\n\treturn 0;\n}\n\nvoid read()\n{\n\t\n\tif(n==0&&m==0) exit(0);\n\tfa[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t\tscanf(\"%d\",&fa[i]);\n\tIs[1]=true;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d\",ch,&Q[i]);\n\t\tif(ch[0]=='Q') a[i]=1;\n\t\telse a[i]=2,Is[Q[i]]=true;\n\t}\n}\nvoid work()\n{\n\tfor(int i=m;i;i--)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tif(Q[i]==1) continue;\n\t\t\tif(Is[Q[i]])\n\t\t\t\tAns+=find(fa[Q[i]]);\n\t\t\telse Ans+=find(Q[i]);\n\t\t\t//printf(\"%lld\\n\",Ans);\n\t\t}\n\t\telse Is[Q[i]]=false;\n\t\t/*for(int i=1;i<=n;i++)\n\t\t\tprintf(\"%d \",fa[i]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%d \",Is[i]);\n\t\tprintf(\"\\n\");*/\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nbool marked[100000];\nint prt[100000];\n\nint gm(int i) {\n  if (marked[i]) return i;\n  return prt[i] = gm(prt[i]);\n}\n\nint main() {\n  while(1) {\n    int n,q;\n    cin>>n>>q;\n    if(!n) break;\n    REP(i,n)marked[i]=false;\n    marked[0] = true;\n    REP(i,n-1) {\n      cin>>prt[i+1];\n      --prt[i+1];\n    }\n    vector<tuple<int,int>> ql;\n    REP(i,q){\n      string c;\n      int v;\n      cin>>c>>v;\n      --v;\n      if (c==\"M\") {\n        if (marked[v]) continue;\n        marked[v] = true;\n      }\n      ql.emplace_back(c==\"Q\", v);\n    }\n    reverse(begin(ql),end(ql));\n    int64_t sum = 0;\n    REP(i,ql.size()){\n      int c,v;\n      tie(c,v) = ql[i];\n      if(c) // Q\n        sum += gm(prt[v]) + 1;\n      else\n        marked[v] = false;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nclass union_find{\n\tvector<int> parent;\npublic:\n\tvector<int> marked;\n\tint root(int a){return parent[a]==a||marked[a]?a:(parent[a]=root(parent[a]));}\n\tunion_find(int n):parent(n),marked(n){for(int i=1;i<n;i++)parent[i]=i;}\n\tint same(int a,int b){return root(a)==root(b);}\n\tint unite(int a,int b){\n\t\tint x=root(a),y=root(b);//if(x==y)return 0;\n\t\tparent[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint main(){\n\tint N,M;\n\tfor(;~scanf(\"%d%d\",&N,&M)&&N;){\n\t\tvector<int>parent(N);\n\t\tfor(int i=1;i<N;i++)scanf(\"%d\",&parent[i]),parent[i]--;\n\t\tunion_find uf(N);\n\t\tvector<pair<char,int> >query;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tchar s[2];int n;\n\t\t\tscanf(\"%s%d\",s,&n),n--;\n\t\t\tif(*s=='Q'||!uf.marked[n]){\n\t\t\t\tif(*s=='M')uf.marked[n]=1;\n\t\t\t\tquery.emplace_back(*s,n);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<N;i++)if(!uf.marked[i])uf.unite(i,parent[i]);\n\t\treverse(query.begin(),query.end());\n\t\tlong long R=0;\n\t\tfor(auto &e:query){\n\t\t\tif(e.first=='Q')R+=uf.root(e.second)+1;\n\t\t\telse uf.marked[e.second]=0,uf.unite(e.second,parent[e.second]);\n\t\t}\n\t\tprintf(\"%lld\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n\tcontinue;\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r+3 && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\t//\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(int i=0;i<2*r;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n\n    if (rx < ry) par[ry] = rx;\n    else if (rx > ry) par[rx] = ry;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\nvoid dfs(int idx, int par, vector<vector<int> >& G, vector<bool>& marked, UnionFindTree& tree) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(idx, par);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par, G, marked, tree);\n  }\n}\n\nint solve(int N, int Q, vector<vector<int> >& G, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  vector<bool> marked(N);\n  for (int i = 0; i < queries.size(); i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  UnionFindTree tree(N);\n  dfs(0, -1, G, marked, tree);\n\n  int res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(x, parent[x]);\n    } else {\n      res += tree.find(x) + 1;\n\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    vector<vector<int> > G(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    int ans = solve(N, Q, G, parent, queries);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\ntypedef pair<char,int> P;\nint N,Q;\nint mark[100001];\nint tree[100001];\nP query[100001];\n \nint get(int i){\n  if(mark[i])return i;\n  return tree[i]=get(tree[i]);\n}\n \nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c%d\",&query[i].first,&query[i].second);\n      query[i].second--;\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second]+=1;\n      }\n    }\n \n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      if(query[i].first=='M'){\n        mark[query[i].second]-=1;\n      }else{\n        c+=get(query[i].second)+1;\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100000+1109\n\nusing namespace std;\n\nchar ch[30];\nint n,m;\nint fa[MAXN];\nint a[MAXN],Q[MAXN];\nbool Is[MAXN];\nlong long Ans=0;\n\nint find(int x)\n{\n\tif(fa[x]==x) return x;\n\tif(Is[x]==true) return x;\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid read();\nvoid work();\nvoid print();\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(Is,0,sizeof(Is));\n\t\tAns=0;\n\t\tread();\n\t\twork();\n\t\tprint();\n\t}\n\treturn 0;\n}\n\nvoid read()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0) exit(0);\n\tfa[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t\tscanf(\"%d\",&fa[i]);\n\tIs[1]=true;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d\",ch,&Q[i]);\n\t\tif(ch[0]=='Q') a[i]=1;\n\t\telse a[i]=2,Is[Q[i]]=true;\n\t}\n}\nvoid work()\n{\n\tfor(int i=m;i;i--)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tif(Q[i]==1) continue;\n\t\t\tif(Is[Q[i]])\n\t\t\t\tAns+=find(fa[Q[i]]);\n\t\t\telse Ans+=find(Q[i]);\n\t\t\t//printf(\"%lld\\n\",Ans);\n\t\t}\n\t\telse Is[Q[i]]=false;\n\t\t/*for(int i=1;i<=n;i++)\n\t\t\tprintf(\"%d \",fa[i]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%d \",Is[i]);\n\t\tprintf(\"\\n\");*/\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nll n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][18],ff[100000],ss[100000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint find(vector<int> &par, int k){\n  if(par[k] == k) return k;\n  return par[k] = find(par,par[k]);\n}\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N){\n    vector<int> par(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n    int p[N];\n    p[0] = 0;\n    for(int i = 1; i < N; ++i){\n      cin >> p[i];\n      --p[i];\n      par[i] = p[i];\n    }\n    vector< pair<char,int> > Query;\n    char c;\n    int k, count[N];\n    fill(count,count+N,0);\n    for(int i = 0; i < Q; ++i){\n      cin >> c >> k;\n      --k;\n      if(c == 'M'){\n\tpar[k] = k;\n\t++count[k];\n      }\n      Query.push_back(make_pair(c,k));\n    }\n    reverse(Query.begin(),Query.end());\n    /*\n    for(int i = 0; i < N; ++i){\n      cout << par[i] << \" \";\n    }cout << endl;\n    */\n    int ans = 0;\n    for(int i = 0; i < Q; ++i){\n      c = Query[i].first;\n      k = Query[i].second;\n      if(c == 'Q'){\n\tans += find(par,k)+1;\n      }else{\n\t--count[k];\n\tif(!count[k])\n\t  par[k] = par[p[k]];\n      }\n    }\n    /*\n    for(int i = 0; i < N; ++i){\n      cout << par[i] << \" \";\n    }cout << endl;\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100005][2];\nchar q1[100005];\nint q2[100005];\nvector<vector<int> > vec(1000000);\n//vec = vector < vector <int> >(1000000,vector<int>(100000,0)) ;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); ++it){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n//    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define lint long long\n#define P pair<int, int>\n#define LLP pair<long long, long long>\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define repr(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n\nconst int IINF = 1e9 + 100;\nconst long long LLINF = 2e18 + 129;\nconst long long MOD = 1e9 + 7;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\nstruct unionFind{\n\n    vector<int> par, rank;\n\n    void init(int n){\n        par.resize(n);\n        rank.resize(n, 0);\n        for(int i = 0 ; i < n ; ++i){\n            par[i] = i;\n        }\n        return;\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            par[x] = root(par[x]);\n            return par[x];\n        }\n    }\n\n    bool unite(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry){\n            return false;\n        }\n        par[ry] = rx;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    while(cin >> n >> q, n){\n        vector<int> p(n);\n        REP(i, 1, n){\n            cin >> p[i];\n            --p[i];\n        }\n\n        vector< pair<char, int> > v;\n        vector<bool> marked(n);\n        marked[0] = true;\n        rep(i, q){\n            char c;\n            int k;\n            cin >> c >> k;\n            --k;\n            if(c == 'M'){\n                if(!marked[k]){\n                    v.push_back({c, k});\n                    marked[k] = true;\n                }\n            }else{\n                v.push_back({c, k});\n            }\n        }\n        reverse(v.begin(), v.end());\n\n        unionFind uf;\n        uf.init(n);\n        rep(i, n){\n            if(!marked[i]){\n                uf.unite(p[i], i);\n            }\n        }\n\n        lint ans = 0;\n        rep(i, v.size()){\n            if(v[i].first == 'Q'){\n                ans += (lint)(uf.root(v[i].second) + 1);\n            }else{\n                uf.unite(p[v[i].second], v[i].second);\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<char,int>P;\nint uni[100009],r[100009];\nint find(int a){\n    if(a!=uni[a])a=find(uni[a]);\n    return a;\n}\nbool same(int a,int b){\n    return find(a)==find(b);\n}\nvoid unit(int a,int b){\n    int c=find(a),d=find(b);\n    if(r[c]>r[d])uni[d]=c;\n    else{uni[d]=c;\n        if(r[c]==r[d])r[d]++;\n    }\n}\n \nint M[100007];\nvector<int>v[100007];\n \nvoid dfs(int x,int col){\n  if(M[x]!=-1)col=M[x];\n  uni[x]=col;\n  r(i,v[x].size()){\n    dfs(v[x][i],col);\n  }\n}\nint n,m,x,sum;\nvector<P>query;\nint xx[100009];\n\n\nint main(){\n  while(cin>>n>>m,n){\n    memset(M,-1,sizeof(M));\n    query.clear();\n    r(i,100007)v[i].clear();\n    r(i,n-1){\n      cin>>xx[i+2];\n      v[xx[i+2]].push_back(i+2);\n    }\n    set<P>s;\n    r(i,m){\n      char c;\n      cin>>c>>x;\n      if(c=='M'&&s.count(P(c,x)))continue;\n      if(c=='M')M[x]=x;\n      s.insert(P(c,x));\n      query.push_back(P(c,x));\n    }\n    dfs(1,1);\n    reverse(query.begin(),query.end());\n    r(i,query.size()){\n      if(query[i].first=='Q') sum += find(query[i].second);\n      else{\n        unit(xx[query[i].second],query[i].second);\n      }\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 10005;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n\n    for(int i = 0; i < MAX; i++)\n      mark[i] = 0;\n\n  }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX+5;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  int ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 100000;\nstatic const int MAX_Q = 100000;\n \nint N, Q;\nvector<int> G[MAX_N];\n \nint par[MAX_N];\nint rnk[MAX_N];\n \nvoid init(int N){\n\tfor(int i = 0; i < N; i++){\n\t\tpar[i] = i;\n        rnk[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n \nvoid dfs(int u, int v){\n    unite(u, v);\n    for(int i = 0; i < G[v].size();i++){\n        dfs(u, G[v][i]);\n    }\n    return ;\n}\n \nint main(){\n    for(;;){\n        cin >> N >> Q;\n        if(N == 0 && Q == 0) break;\n        init(N);\n        for(int i = 0; i < N; i++) G[i].clear();\n        for(int i = 1; i < N; i++){\n            int p;\n            cin >> p;\n            p--;\n            G[p].push_back(i);\n        }\n        ll res = 0LL;\n        for(int i = 0; i < Q; i++){\n        \tchar ch;\n            int v;\n            cin >> ch >> v;\n            v--;\n            if(ch == 'M') dfs(v, v);\n            else res += (find(v) == v ? 1 : find(v) + 1);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nstruct Node{\n\tNode(){\n\t\tparent = -1;\n\t\tindex = -1;\n\t\tisMarked = false;\n\t}\n\tvoid init(){\n\t\tparent = -1;\n\t\tindex = -1;\n\t\tisMarked = false;\n\t}\n\tint parent,index;\n\tbool isMarked;\n};\n\nint main(){\n\n\tint N,Q,tmp;\n\tll ans;\n\tchar ch[2];\n\n\tNode* nodes = (Node*)malloc(sizeof(Node)*(100001));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\t\tfor(int i = 1; i <= N; i++)nodes[i].init();\n\n\t\tans = 0;\n\n\t\tnodes[1].parent = -1; //????????????????????§???????????°\n\t\tnodes[1].index = 1;\n\t\tnodes[1].isMarked = true;\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&nodes[i].parent);\n\t\t\tnodes[i].index = i;\n\t\t}\n\n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tscanf(\"%s %d\",ch,&tmp);\n\t\t\tif(ch[0] == 'M'){ //???????????????\n\t\t\t\tnodes[tmp].isMarked = true;\n\t\t\t}else{ //?????¨?????????\n\t\t\t\twhile(nodes[nodes[tmp].parent].isMarked == false)tmp = nodes[tmp].parent;\n\t\t\t\tans += nodes[nodes[tmp].parent].index;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), _groups(n), n(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            // if (data[x] > data[y])\n            //     swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\nint main()\n{\n    fast_io();\n\n    int n, q;\n    while (cin >> n >> q, n)\n    {\n        int par[ten(5) + 100];\n        par[0] = 0;\n        rep(i, n - 1)\n            cin >> par[i + 1], --par[i + 1];\n\n        bool mark[ten(5) + 100];\n        fill_n(mark, n, false);\n        char op[ten(5) + 100];\n        int v[ten(5) + 100];\n        rep(i, q)\n        {\n            cin >> op[i] >> v[i], --v[i];\n            if (op[i] == 'M')\n                mark[v[i]] = true;\n        }\n\n        UnionFind uf(n);\n        rep(i, n)\n            if (!mark[i])\n                uf.unite(par[i], i);\n\n        ll res = 0;\n        revrep(i, q - 1)\n        {\n            if (op[i] == 'Q')\n                res += uf.root(v[i]) + 1;\n            else\n                uf.unite(par[v[i]], v[i]);\n        }\n        \n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nint a[100001];\n\nint find(int m){\n\tif(a[m] == m)\n\t\treturn m;\n\treturn find(a[m]);\n}\n\n\nint main(void){\n\tint n, q, p, v, i, ans;\n\tchar c;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(n == 0 && q == 0)\n\t\t\tbreak;\n\t\tans = 0;\n\t\ta[1] = 1;\n\t\tfor(i = 2;i <= n;i++){\n\t\t\tscanf(\"%d%*c\",&p);\n\t\t\ta[i] = p;\n\t\t}\n\t\tfor(i = 0;i < q;i++){\n\t\t\tscanf(\"%c%d%*c\",&c,&v);\n\t\t\tif(c == 'Q'){\n\t\t\t\tans += find(v);\n\t\t\t}\n\t\t\telse if(c == 'M'){\n\t\t\t\ta[v] = v;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\nint par[100001];\nint rank1[100001];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n);\n\t\trep(i, n-1) {\n\t\t\tcin >> par[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tint marked[100001] = {}; marked[0] = 1;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\tll out = 0;\n\t\trep(i,n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    marked[1]=true;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tif(marked[t[i]]) c[i]='E';\n\tmarked[t[i]]=true;\n      }\n    }\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define SZ(a) (int)(a).size()\n#define FOR(i,a,b) for (int i=(a); i<=(b); ++i)\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define ALL(c) c.begin(), c.end()\n#define CLR(c,n) memset(c, n, sizeof(c))\n#define TR(it, c) for(typeof(c.begin()) it = c.begin();it != c.end(); ++it)\n#define CONTAIN(it, c) (c.find(it) != c.end())\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntemplate <class T> void checkmin(T &a, T b) { if (b<a) a=b; }\ntemplate <class T> void checkmax(T &a, T b) { if (b>a) a=b; }\n\nconst int N = 100 << 10;\nint n, q, p[N], v[N];\nbool mark[N], unused[N];\nchar cmd[N];\n\nint up[N], depth[N], firstmark[N];\n\nint top(int a) {\n  return up[a] ? up[a] = top(up[a]) : a;\n}\n\nvoid merge(int a, int b) {\n  a = top(a);\n  b = top(b);\n  if (a == b) return;\n  if (depth[a] < depth[b]) {\n    up[a] = b;\n  } else {\n    up[b] = a;\n    if (depth[a] == depth[b]) ++depth[a];\n  }\n  return;\n}\n\nint main(int argc, char *argv[]) {\n  while (scanf(\"%d %d\", &n, &q) == 2 && n + q > 0) {\n    FOR(i, 2, n) scanf(\"%d\", &p[i]);\n    REP(i, q) scanf(\" %c %d\", &cmd[i], &v[i]);\n    CLR(up, 0); CLR(depth, 0); CLR(mark, 0); CLR(unused, false);\n    mark[1] = true;\n    REP(i, q) if (cmd[i] == 'M') {\n      if (mark[v[i]]) unused[i] = true;\n      mark[v[i]] = true;\n    }\n    FOR(i, 2, n) if (!mark[i]) {\n      merge(i, p[i]);\n    }\n    FOR(i, 1, n) if (mark[i]) {\n      firstmark[top(i)] = i;\n    }\n\n    long ans = 0;\n    for (int i = q - 1; i >= 0; --i) {\n      if (cmd[i] == 'Q') {\n        ans += firstmark[top(v[i])];\n      } else if (cmd[i] == 'M') {\n        if (unused[i]) continue;\n        int nextmark = firstmark[top(p[v[i]])];\n        merge(v[i], p[v[i]]);\n        firstmark[top(v[i])] = nextmark;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N, Q;\nint p[100010];\nstring T[100010];\nint NUM[100010];\n\nvector<int> G[100010];\nint ans[100010];\nbool used[100010];\n\nvoid dfs(int u, int k) {\n\tif(used[u] || ans[u] == k) return;\n\tans[u] = k;\n\tfor(auto v : G[u]){\n\t\tdfs(v, k);\n\t}\n}\n\nint main(void) {\n\twhile(1){\n\t\tscanf(\"%d %d\", &N, &Q);\n\t\tif(N == 0 && Q == 0) break;\n\t\trep(i, N - 1) scanf(\"%d\", &p[i]);\n\t\trep(i, Q){\n\t\t\tcin >> T[i] >> NUM[i];\n\t\t}\n\t\trep(i, Q) NUM[i]--;\n\n\t\trep(i, 100010) G[i].clear();\n\t\trep(i, 100010) ans[i] = 0;\n\t\trep(i, 100010) used[i] = false;\n\n\t\trep(i, N - 1) G[p[i] - 1].pb(i + 1);\n\n\t\tll ret = 0;\n\t\trep(i, Q) {\n\t\t\tif(T[i] == \"Q\") {\n\t\t\t\t// printf(\"ans %d\\n\", ans[NUM[i]] + 1);\n\t\t\t\tret += ans[NUM[i]] + 1;\n\t\t\t}else{\n\t\t\t\tdfs(NUM[i], NUM[i]);\n\t\t\t\tused[NUM[i]] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        while(1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        map<int,int> marks;\n        marks[0] = 0;\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q') ans += marks.lower_bound(-d)->second + 1;\n            else marks.insert(mp(-d, qv[i]));\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n            h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\nstruct UnionFindTree {\n  vector<int> par, rank;\n  UnionFindTree(int n) {\n    par.reserve(n);\n    rank.reserve(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int i) {\n    if (par[i] == i) {\n      return i;\n    } else {\n      return par[i] = find(par[i]);\n    }\n  }\n\n  void unite(int i, int j) {\n    i = find(i);\n    j = find(j);\n    if (i == j) return;\n\n    if (rank[i] < rank[j]) {\n      par[i] = j;\n    } else {\n      par[j] = i;\n      if (rank[i] == rank[j]) rank[i]++;\n    }\n  }\n\n  bool same(int i, int j) {\n    return find(i) == find(j);\n  }\n};\n\ntypedef long long int lli;\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q and N != 0) {\n    UnionFindTree tree(N + 1);\n    vector<int> parent(N + 1);\n    vector<bool> cut(N + 1);\n    FOR(i, 2, N + 1) { cin >> parent[i]; }\n  \n    vector<pair<char,int>> query(Q);\n    REP(i, Q) {\n      char kind; int v;\n      cin >> kind >> v;\n      if (kind == 'M') { cut[v] = true; }\n      query[i] = make_pair(kind, v);\n    }\n    reverse(ALL(query));\n\n    tree.par[1] = 1;\n    FOR(i, 2, N + 1) {\n      if (not cut[i]) { tree.par[i] = parent[i]; }\n    }\n\n    int ans = 0;\n    for (auto q : query) {\n      int v = q.second;\n      if (q.first == 'Q') {\n        ans += tree.find(v);\n      } else {\n        tree.par[v] = parent[v];\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <utility>\n\nusing namespace std;\n\nint N, Q;\npair<char, int> S[100000];\nint parent[100001];\nint mark[100001];\nint set[100001];\n\nint findRoot(int p) {\n  int root = p;\n  while (set[root] != -1) {\n    root = set[root];\n  }\n  while (p != root) {\n    int t = set[p];\n    set[p] = root;\n    p = t;\n  }\n  return root;\n}\n\nvoid unionSet(int p, int q) {\n  int root1 = findRoot(p);\n  int root2 = findRoot(q);\n  if (root1 != root2) {\n    set[root1] = root2;\n  }\n}\n\nint main() {\n  //freopen(\"MarkedAncestor.in\", \"r\", stdin);\n  //freopen(\"2170-input.txt\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &Q) == 2 && !(N == 0 && Q == 0)) {\n    parent[1] = 1;\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%d\", &parent[i]);\n    }\n    set[1] = -1;\n    for (int i = 2; i <= N; ++i) {\n      set[i] = parent[i];\n    }\n    memset(mark, 0, sizeof(mark));\n    mark[1] = 1;\n    for (int i = 0; i < Q; ++i) {\n      char buf[10];\n      scanf(\"%s%d\", buf, &S[i].second);\n      S[i].first = buf[0];\n      if (S[i].first == 'M') {\n        set[S[i].second] = -1;\n        mark[S[i].second]++;\n      }\n    }\n    long long sum = 0;\n    // From back to front.\n    for (int i = Q - 1; i >= 0; --i) {\n      if (S[i].first == 'M') {\n        if (--mark[S[i].second] == 0) {\n          unionSet(S[i].second, parent[S[i].second]);\n        }\n      } else if (S[i].first == 'Q') {\n        int v = findRoot(S[i].second);\n        //printf(\"findRoot(%d) = %d\\n\", S[i].second, v);\n        sum += v;\n      }\n    }\n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\nconst int max_n = 100000;\nint par[max_n * 2];\nbool marked[max_n * 2];\ntypedef long long ll;\n\nvoid init(int n) {\n    for(int i = 0; i < n; i++) {\n        par[i] = i;\n        marked[i] = false;\n    }\n    marked[0] = true;\n}\n\nint find(int x) {\n    if(marked[x]) return x;\n    else return find(par[x]);\n}\n\n\nint main() {\n    while(true) {\n        int n, q;\n        ll sum = 0;\n        cin >> n >> q;\n        init(n);\n        if(n == 0 && q == 0) break;\n\n        for(int i = 0; i < n - 1; i++) {\n            int x;\n            cin >> x;\n            x--;\n            par[i + 1] = x;\n        }\n\n        for(int i = 0; i < q; i++) {\n            char qt;\n            int x;\n            cin >> qt >> x;\n            x--;\n            if(qt == 'M') {\n                marked[x] = true;\n            } else {\n                sum += find(x);\n                sum++;\n            }\n        }\n\n        cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nint N, Q;\n\nint main(){\n\tfreopen(\"in.txt\", \"r\", stdin);\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(int i=2; i<=N; i++) scanf(\"%d\", &par[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n\t\t\tchar ch; int num;\n        \tscanf(\"%c \", &ch); \n\t\t\tscanf(\"%d \", &num); \n           if(ch=='M'){\n                vis[num]=1;\n            }\n            else if(ch=='Q'){\n                int cur=num;\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y;\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1<<28;\n\nvoid dfs(int p, int now, vec& M, vec& par, mat& T) {\n    if (p != now && M[now] != INF) return ;\n    par[now] = p;\n    for (int i = 0; i < T[now].size(); i++) {\n        dfs(p, T[now][i], M, par, T);\n    }\n}\n\nint Merge(int p, vec& par) {\n    if (p == par[p]) return p;\n    return par[p] = Merge(par[p], par);\n}\n\nint Find(int p, vec& par) {\n    if (p == par[p]) return p;\n    return par[p] = Find(par[p], par);\n}\n\nvoid solve(int N, int Q) {\n    mat T(N+1);\n    vec Tr(N+1);\n    Tr[1] = 1;\n    for (int i = 2; i <= N; i++) {\n        int v; cin >> v;\n        T[v].push_back(i);\n        Tr[i] = v;\n    }\n\n    vec MarkedTime(N+1, INF);\n    vec TimeToMarkedVertex(Q+1);\n    vec QueryTimeToVertex(Q+1);\n    MarkedTime[1] = -1;\n    for (int i = 0; i < Q; i++) {\n        char q;\n        int v;\n        cin >> q >> v;\n        if (q == 'M') MarkedTime[v] = i, TimeToMarkedVertex[i] = v;\n        else QueryTimeToVertex[i] = v;\n    }\n\n    vec par(N+1, 1);\n    for (int i = 1; i <= N; i++) {\n        if (MarkedTime[i] == INF) continue;\n        dfs(i, i, MarkedTime, par, T);\n    }\n\n    int cost = 0;\n    for (int i = Q - 1; i > -1; i--) {\n        if (QueryTimeToVertex[i] > 0) cost += Find(par[QueryTimeToVertex[i]], par);\n        else par[TimeToMarkedVertex[i]] = Merge(Tr[TimeToMarkedVertex[i]], par);\n    }\n\n    cout << cost << endl;\n}\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N || Q) solve(N, Q);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint N,Q;\nint pars[100001];\nbool input(){\n\tscanf(\"%d%d\",&N,&Q);\n\tint par;\n\tif(N == 0 && Q ==0) return false;\n\tfor(int i = 2;i <= N;++i){\n\t\tscanf(\"%d\",&par);\n\t\tpars[i] = par;\n\t}\n\tpars[1] = 1;\n}\n\nint find(int x){\n\tif(x == pars[x]) return x;\n\treturn find(pars[x]);\n}\n\nvoid M(int x){\n\tpars[x] = x;\n}\n\nint main(){\n\twhile(input()){\n\t\tlong long res = 0;\n\t\tchar a;\n\t\tint b;\n\t\tfor(int i = 0;i < Q;++i){\n\t\t\tscanf(\"\\n%c%d\",&a,&b);\n\t\t\tif(a == 'Q') res += find(b);\n\t\t\telse M(b); \n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1147483647;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define gchar(i) scanf(\"%c\",&(i))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n\n//#define my_debug\n\nconst int MAX_N = 100005;\nint all[MAX_N];\nbool stu[MAX_N];\n\nint n, q;\n\nvoid solve(){\n\n}\n\nint get_f(int i){\n\tint out = all[i];\n\tif (stu[out])\n\t\treturn out;\n\telse\n\t\treturn get_f(out);\n}\n\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,q) != EOF){\n\t\tll out = 0;\n\t\tif (n == 0 && q == 0)\n\t\t\tbreak;\n\t\tinit(all, 0);\n\t\tinit(stu, 0);\n\t\tstu[1] = true;\n\t\tall[1] = 1;\n\t\trep(i, 2, (n + 1)){\n\t\t\tgint(all[i]);\n\t\t}\n\t\trep(i, 0, q){\n\t\t\tchar c;\n\t\t\tint tmp;\n\t\t\tgchar(c);\n\t\t\tgchar(c);\n\t\t\tgint(tmp);\n\t\t\tif (c == 'Q'){\n\t\t\t\tout += (ll)get_f(tmp);\n\t\t\t}\n\t\t\telse if (c == 'M'){\n\t\t\t\tstu[tmp] = true;\n\t\t\t}\n\t\t}\n\t\t//pint(out);\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nint dfs(int x){\n\tBEGIN_STACK_EXTEND(64*1024*1024);\n\tfor( int i : M[x] ) near[i] = x;\n\tfor( int i : Q[x] ){\n\t\tint a = (*(--near.lower_bound(i))).second;\n\t\tans += a+1;\n\t}\n\tfor( auto c : ch[x] ) dfs(c);\n\tfor( int i : M[x] ) near.erase(i);\n\tEND_STACK_EXTEND\n\treturn 0;\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear();\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        if(x > y) swap(x, y);\n        // y を x に統合 (数字の小さい方に合わせる)\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(i, parent[i]);\n            }\n        }\n\n        ll ans = 0;\n        for(int i=Q-1; i>=0; i--) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    if(flag[t[n]] == 1)\n\treturn t[n];\n    else\n    {\n\tint fa = find(t[n]);\n\tt[n] = fa;\n\treturn t[n];    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n//#ifndef ONLINE_JUDGE\n//    READ;\n//#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 0;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]] = 1;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M' ) flag[idx[i]] = 0;\n\t    else ret = ret + find(idx[i]);\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par;\n\tUnion_Find_Tree(int n){\n\t\tPar=vi(n);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tPar[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint n,q;\nvi a;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>q;\n\t\tif(!n) break;\n\t\ta=vi(n+1);\n\t\tfor(int i=2;i<=n;i++) cin>>a[i];\n\t\tvp p(n);\n\t\tvi b(n+1);\n\t\tUnion_Find_Tree uft(n+1);\n\t\tll res=0;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin>>c>>v;\n\t\t\tif(c=='Q') p[i]={0,v};\n\t\t\telse{\n\t\t\t\tp[i]={1,v};\n\t\t\t\tb[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=n;i++) if(!b[i]) uft.Unite(i,a[i]);\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tbool B=p[i].first;\n\t\t\tint v=p[i].second;\n\t\t\tif(B){\n\t\t\t\tb[v]--;\n\t\t\t\tif(!b[v]) uft.Unite(v,a[v]);\n\t\t\t}\n\t\t\telse res+=uft.Find_Par(v);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> node;\n    int components;\n    UnionFind(int n) : node(n, -1), components(n) {}\n    void reset() {\n        fill(node.begin(), node.end(), -1);\n        components = node.size();\n    }\n    int find(int x) { return node[x] < 0 ? x : node[x] = find(node[x]); }\n    int size(int x) { return -node[find(x)]; }\n    int size() { return components; }\n\n    // x が必ず親側\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        // if(size(x) > size(y)) swap(x, y);\n        node[x] += node[y];\n        node[y] = x;\n        components--;\n        return true;\n    }\n};\n\nvoid dfs(const vector<vector<int>> &G, int v, const vector<int> &marked, UnionFind &uf){\n    for(auto v_ : G[v]){\n        if(!marked[v_]) uf.unite(v,v_);\n        dfs(G,v_,marked,uf);\n    }\n}\n\nint main() {\n    int n, q;\n    while(cin >> n >> q, n){\n        vector<int> P(n,-1);\n        vector<vector<int>> G(n);\n        for(int i = 1; i < n; ++i){\n            cin >> P[i];\n            --P[i];\n            G[P[i]].push_back(i);\n        }\n        vector<pair<char,int>> Q;\n        vector<int> marked(n,0);\n        marked[0] = 1;\n        for(int i = 0; i < q; ++i){\n            char t;\n            int v;\n            cin >> t >> v;\n            --v;\n            Q.emplace_back(t,v);\n            if(t == 'M') marked[v]++;\n        }\n        UnionFind uf(n);\n        dfs(G,0,marked,uf);\n/*\n        for(int i = 0; i < n; ++i){\n            cerr <<\"! : \" <<  i << \" \" << uf.find(i) << endl;\n        }\n*/\n        long long ans = 0;\n        reverse(Q.begin(),Q.end());\n        for(auto q : Q){\n            int v = q.second;\n            if(q.first == 'M'){\n                if(--marked[v] == 0) {\n                    uf.unite(P[v],v);\n                }\n            }else{\n                //cerr << v << \" \" << uf.find(v) << endl;\n                ans += uf.find(v)+1;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, w, c; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 100;\n\nint f(int v, vector<int>& p, vector<bool>& m) {\n\tif (m[v]) return v;\n\treturn p[v] = f(p[v], p, m);\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (N == 0) break;\n\t\tvector<int> p(N + 1);\n\t\tfor (int i = 2; i <= N; i++)\n\t\t\tcin >> p[i];\n\t\tvector<bool> m(N + 1);\n\t\tm[1] = true;\n\t\tvector<string> q; vector<int> v;\n\t\twhile (Q--) {\n\t\t\tstring s; int x; cin >> s >> x;\n\t\t\tif (s == \"M\") {\n\t\t\t\tif (m[x]) continue;\n\t\t\t\tm[x] = true;\n\t\t\t}\n\t\t\tq.push_back(s);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = q.size() - 1; i >= 0; i--) {\n\t\t\tif (q[i] == \"M\")\n\t\t\t\tm[v[i]] = false;\n\t\t\telse if (q[i] == \"Q\")\n\t\t\t\tsum += f(v[i], p, m);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nclass UnionFind {\n    public:\n    ll n;\n    vector<ll> par;\n\n    UnionFind(ll n) {\n        rep(n) {\n            par.push_back(ll(i));\n        }\n    }\n\n    ll find(ll x) {\n        return ((par[x] == x) ? x : par[x]=find(par[x]));\n    }\n\n    void unite(ll x, ll y) {\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return;\n\n        par[y] = x;\n        return;\n    }\n\n    bool is_same(ll x, ll y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    ll n,q,node;\n    char c;\n    cin >> n >> q;\n    while(n || q){\n        vector<ll> parent(n+1, 1), children[n+1];\n        reppp(i, 2, n+1){\n            cin >> node;\n            parent[i] = node;\n            children[node].push_back(i);\n        }\n\n        vector<Pll> query;\n        vector<bool> marked(n+1, false);\n        rep(q){\n            cin >> c >> node;\n            if(c == 'Q'){\n                query.emplace_back(1, node);\n            }else{\n                if(marked[node]) continue;\n                query.emplace_back(0, node);\n                marked[node] = true;\n            }\n        }\n        q = (ll)query.size();\n\n        UnionFind uf = UnionFind(n+1);\n        reppp(i, 2, n+1){\n            if(marked[i]) continue;\n            uf.unite(parent[i], i);\n        }\n        \n        ll ans = 0;\n        for(int i=q-1;i>=0;--i){\n            if(query[i].first){\n                ans += uf.find(query[i].second);\n            }else{\n                uf.unite(parent[query[i].second], query[i].second);\n            }\n        }\n        cout << ans << endl;\n        cin >> n >> q;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n\nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2, false);\n\tr[1] = true;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(x);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nbool marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tscanf(\"%d\",fa+i);\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;marked[id]=1;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[i+1].emplace_back(p, 1);\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tvector<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tans = min(ans, pii(lca.lca(*u, v), *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.push_back(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, pii>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), pii(*u, -1));\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tconst pii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second.first;\n\t\t\t\t\tconst int p = que.front().second.second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v] < c) continue;\n\t\t\t\t\tFOR(e, g[v])if(e->first!=p){\n\t\t\t\t\t\tif(chmin(res[e->first], pii(c.first+1, c.second)))\n\t\t\t\t\t\t\tque.emplace(pii(c.first+1, c.second), pii(e->first, v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nint ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)&&(q+n)!=0){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = 1;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] = 1;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = 0;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        if(x > y) swap(x, y);\n        // y を x に統合 (数字の小さい方に合わせる)\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(i, parent[i]);\n            }\n        }\n\n        ll ans = 0;\n        for(int i=0; i<Q; i++) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nclass unionfind {\n    public:\n    int n;\n    vector<int> par;\n    unionfind(int m) {\n        n = m;\n        par.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    int isunion(int x, int y) { return find(x) == find(y); }\n    int tounion(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return 0;\n        par[q] = p;\n        return 1;\n    }\n};\n\nint main() {\n    while (1) {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        if (!n) return 0;\n        vector<int> par(n);\n        for (int i = 1; i < n; ++i) {\n            cin >> par[i];\n            --par[i];\n        }\n        vector<pair<char, int>> inp(q);\n        vector<int> cnt(n, 0);\n        for (int i = q - 1; i >= 0; --i) {\n            cin >> inp[i].first >> inp[i].second;\n            --inp[i].second;\n            if (inp[i].first == 'M') ++cnt[inp[i].second];\n        }\n        unionfind uf(n);\n        for (int i = 1; i < n; ++i) if (!cnt[i]) uf.tounion(par[i], i);\n        long long sum = 0;\n        for (auto i : inp) {\n            if (i.first == 'Q') sum += uf.find(i.second) + 1;\n            else if (!--cnt[i.second]) uf.tounion(par[i.second], i.second);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long fa[100005],ans,a;\nint n,q,i;\nbool r[100005];\nchar c;\nlong long find(long long x)\n{\n\tif(r[x]==1)\n\t\treturn x;\n\treturn find(fa[x]);\n}\nint main()\n{\n\tfa[1]=1;\n\tr[1]=1;\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0||q==0)\n\t\t\treturn 0;\n\t\tans=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tr[i]=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tscanf(\"%I64d\",&fa[i]);\n\t\tfor(i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"\\n%c %I64d\",&c,&a);\n\t\t\tif(c=='M')\n\t\t\t\tr[a]=1;\n\t\t\tif(c=='Q')\n\t\t\t\tans=ans+find(a);\n\t\t}\n\t\tprintf(\"%I64d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,a,b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define pb push_back\nconst int inf = 1e9;\nint N, Q;\nvector<int> ch[100010];\nint marked[100010];\n\nvoid dfs(int v, int a){\n    if(marked[v] == v or marked[v] == a) return;\n    marked[v] = a;\n    rep(i,ch[v].size()) dfs(ch[v][i], a);\n}\n\nint solve(){\n    memset(marked, 0, sizeof(marked));\n    int ans = 0;\n    while(Q--){\n        char c; int v;\n        cin >> c >> v;\n        v--;\n        if(c == 'Q') ans += marked[v]+1;\n        else dfs(v, v);\n    }\n    return ans;\n}\n\nbool input(){\n    cin >> N >> Q;\n    if(!N and !Q) return 0;\n    rep(i,N) ch[i].clear();\n    rep(i,N-1) {\n        int a; cin >> a;\n        ch[a-1].pb(i+1);\n    }\n    return 1;\n}\nsigned main(){\n    while(input()) cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>  \n#include<iostream>  \n#define min(a, b) a < b ? a : b \nusing namespace std;  \n  \nconst int INF = 0x7f7f7f7f;  \nconst int MAXN = 1e5 + 111;  \n  \nint p[MAXN];  \nint qt[MAXN], qv[MAXN], mark[MAXN];  \nint t;  \n  \nint find(int x) {  \n    return mark[x] < t ? x : p[x] = find(p[x]); // ?°?????????´?????¨??\\??¢???????????????????¢????  \n}  \n  \nint main()  \n{  \n    int n, q, i;  \n    while (~scanf(\"%d%d\", &n, &q) && (n | q)) {  \n        for (i = 2; i <= n; ++i) {  \n            scanf(\"%d\", p + i);  \n            mark[i] = INF;  \n        }  \n  \n        int cnt = 0, x;  \n        char op[2];  \n        for (i = 1; i <= q; ++i) {  \n            scanf(\"%s%d\", op, &x);  \n            if (op[0] == 'M') mark[x] = min(mark[x], i); // ??°?????????????????¶??´  \n            else {  \n                qt[cnt] = i;  \n                qv[cnt++] = x;  \n            }  \n        }  \n  \n        long long ans = 0;  \n        while (cnt --) {  \n            t = qt[cnt]; // ??\\??¢???????????¶??´  \n            ans += find(qv[cnt]);  \n        }  \n        printf(\"%lld\\n\", ans);  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n, q;\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\tif(p <= 0 || n < p) return;\n\n\troot[p] = v;\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\tif( root[edge[p][i]] == edge[p][i] ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tupdate(edge[p][i], v);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> q, n||q) {\n\t\troot.clear();\n\t\tedge.clear();\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = 1;\n\t\tint sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint N,Q;\nint pa[100000];\npair<char,int> que[100000];\nvector<int> ch[100000];\nbool mark[100000];\nint qpa[100000];\n\nint find(int x){\n  if(x==qpa[x]) return x;\n  return\n    qpa[x]=find(qpa[x]);\n}\n\nvoid solve(){\n  CLR(mark);\n  rep(i,N) ch[i].clear();\n  rep(i,N-1) {\n    cin >> pa[i+1];\n    --pa[i+1];\n    ch[pa[i+1]].pb(i+1);\n  }\n\n  rep(i,Q){\n    cin >> que[i].F >> que[i].S;\n    --que[i].S;\n    if(que[i].F=='M') mark[que[i].S]=1;\n  }\n  \n  reverse(que,que+Q);\n  queue<PI> q;\n  q.push(mp(0,0));\n  while(!q.empty()){\n    int cv=q.front().F;\n    int ma=q.front().S;\n    q.pop();\n    qpa[cv]=ma;\n    FOR(it,ch[cv]) q.push(mp(*it,mark[*it]?*it:ma));\n  }\n  \n  ll ans=0;\n  rep(i,Q){\n    if(que[i].F=='Q'){\n      //cout << find(que[i].S)+1 << endl;\n      ans += find(que[i].S)+1;\n    }else{\n      qpa[que[i].S]=qpa[pa[que[i].S]];\n    }\n  }\n  \n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> Q && N) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tint ancestor[100000] = {}, ismarked[100000] = {};\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tmarked_ancestor[0] = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M')uf.unite(ancestor[outlog[i].second], outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += uf.getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//for (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// uf\nstruct uf {\n  vector<int> par;\n  uf(int n) : par(n) { for (int i = 0; i < n; ++i) par[i] = 1; }\n  \n  int find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  \n  void unite(int x, int y) {\n    par[find(x)] = par[find(y)] = find(x);\n  }\n  \n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N, Q;\nvector<int> es[100004];\n\nvoid update(uf& tree, int tar, int grp) {\n  for (unsigned i = 0; i < es[tar].size(); ++i) {\n    // printf(\"unite %d %d\\n\", es[tar][i], grp);\n    // tree.unite(es[tar][i], grp);\n    tree.unite(grp, es[tar][i]);\n    update(tree, es[tar][i], grp);\n  }\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n  int tmp;\n  for (int i = 0; i < N-1; ++i) {\n    scanf(\"%d\", &tmp);\n    es[tmp].push_back(i+2);\n  }\n\n  uf tree(N+1);\n  char op;\n  int ans = 0;\n  for (int q = 0; q < Q; ++q) {\n    scanf(\" %c%d\", &op, &tmp);\n    if (op == 'Q') {\n      ans += tree.find(tmp);\n    } else if (op == 'M') {\n      tree.par[tmp] = tmp;\n      update(tree, tmp, tmp);\n    } else {\n      assert(false);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q;\nlong long ans;\n// int Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nint search(int x) {\n  int a = par[x];\n  if (marked[a]) return a;\n  else return search(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Tree {\n    vector<int> par;\n    vector<char> mark;\n    Tree(int n) : par(n, -1), mark(n, false) { }\n\n    void unmark(int k) {\n        mark[k] = false;\n    }\n\n    int query(int k) {\n        if(mark[k]) return k;\n        return par[k] = query(par[k]);\n    }\n};\n\nint main() {\n    for(int N, Q; cin >> N >> Q, N + Q > 0; ) {\n        Tree tree(N);\n        tree.mark[0] = true;\n        for(int i = 0; i < N - 1; i++) {\n            int p; cin >> p; p--;\n            tree.par[i + 1] = p;\n        }\n        vector<int> type;\n        vector<int> node;\n        for(int i = 0; i < Q; i++) {\n            char t; int n; cin >> t >> n; n--;\n            type.push_back(t == 'Q');\n            node.push_back(n);\n            if(t == 'M') tree.mark[n] = true;\n        }\n        reverse(type.begin(), type.end());\n        reverse(node.begin(), node.end());\n        lli res = 0;\n        for(int i = 0; i < Q; i++) {\n            if(type[i]) {\n                res += tree.query(node[i]) + 1;\n            }\n            else {\n                tree.unmark(node[i]);\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#define LL long long\nusing namespace std;\nconst int N = 100010;\nvector<int> edge[N];\nvector<int> mark[N], query[N];\nint n, m;\nint L(int x){return x << 1;}\nint R(int x){return x << 1 | 1;}\nstruct Tree{\n\tstruct node{\n\t\tint v;\n\t}tr[N << 2];\n\tvoid build(int a, int b, int x){\n\t\ttr[x].v = 0;\n\t\tif(a < b){\n\t\t\tint mid = a + b >> 1;\n\t\t\tbuild(a, mid, L(x));\n\t\t\tbuild(mid + 1, b, R(x));\n\t\t}\n\t}\n\tvoid update(int x){\n\t\ttr[x].v = max(tr[L(x)].v, tr[R(x)].v);\n\t}\n\tvoid modify(int x, int a, int b, int pos, int ad){\n\t\tif(a == b){\n\t\t\ttr[x].v = ad;\n\t\t\treturn;\n\t\t}\n\t\tint mid = a + b >> 1;\n\t\tif(pos <= mid) modify(L(x), a, mid, pos, ad);\n\t\telse modify(R(x), mid + 1, b, pos, ad);\n\t\tupdate(x);\n\t}\n\tint query(int x, int a, int b, int l, int r){\n\t\tif(l <= a && b <= r) return tr[x].v;\n\t\tint mid = a + b >> 1;\n\t\tif(r <= mid) return query(L(x), a, mid, l, r);\n\t\telse if(l > mid) return query(R(x), mid + 1, b, l, r);\n\t\telse return max(query(L(x), a, mid, l, r), query(R(x), mid + 1, b, l, r));\n\t}\n}sg;\n\nLL ans = 0;\nint list[N];\nvoid dfs(int u, int d){\n\tlist[d] = u;\n\tfor(int i = 0; i < query[u].size(); i ++){\n\t\tint _index = query[u][i];\n\t\tans = ans + list[sg.query(1, 1, m, 1,  _index)];\n\t}\n\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\tint _index = mark[u][i];\n\t\tsg.modify(1, 1, m, _index, d);\n\t}\n\tfor(int i = 0; i < edge[u].size(); i ++){\n\t\tint v = edge[u][i];\n\t\tdfs(v, d + 1);\n\t}\n\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\tint _index = mark[u][i];\n\t\tsg.modify(1, 1, m, _index, 0);\n\t}\n}\nvoid solve(){\n\tans = 0;\n\tfor(int i = 1; i <= n; i ++){\n\t\tedge[i].clear();\n\t\tquery[i].clear();\n\t\tmark[i].clear();\n\t}\n\tmemset(list, 0, sizeof(list));\n\tfor(int i = 2; i <= n; i ++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tedge[x].push_back(i);\n\t}\n\t\n\tmark[1].push_back(1);\n\tm ++;\n\tfor(int i = 2; i <= m; i ++){\n\t\tchar str[2];\n\t\tint v;\n\t\tscanf(\"%s%d\", str, &v);\n\t\tif(str[0] == 'Q') query[v].push_back(i);\n\t\telse mark[v].push_back(i);\n\t}\n\t\n\tsg.build(1, m, 1);\n\tdfs(1, 1);\n\t\n\tprintf(\"%lld\\n\", ans);\n}\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2 && n + m){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n,q;\nlong long par[100005];\nvector<long long> child[100005];\nqueue<P> mna;//marked nearest ancestor\nlong long mark[100005];\nlong long query[100005];\nlong long qquery[100005];\nlong long mnalist[100005];\nstring s;\nlong long ans;\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,100005)\n\t\t{\n\t\t\tmark[i]=0;\n\t\t\tquery[i]=0;\n\t\t\tqquery[i]=0;\n\t\t\tchild[i].clear();\n\t\t\tpar[i]=0;\n\t\t\tmnalist[i]=0;\n\t\t}\n\t\tans=0;\n\t\tcin>>n>>q;\n\t\tif(n==0)break;\n\t\trep(i,n-1)\n\t\t{\n\t\t\tcin>>par[i+1];\n\t\t\tpar[i+1]--;\n\t\t\tchild[par[i+1]].push_back(i+1);\n\t\t}\n\t\tmark[0]=1;\n\t\trep(i,q)\n\t\t{\n\t\t\tcin>>s>>qquery[i];\n\t\t\tqquery[i]--;\n\t\t\tif(s==\"M\")\n\t\t\t{\n\t\t\t\tquery[i]=1;\n\t\t\t\tmark[qquery[i]]=1;\n\t\t\t}\n\t\t}\n\t\tmna.push(P(0,0));\n\t\tmnalist[0]=0;\n\t\twhile(!mna.empty())\n\t\t{\n\t\t\tP p=mna.front();mna.pop();\n\t\t\trep(i,child[p.first].size())\n\t\t\t{\n\t\t\t\tif(mark[child[p.first][i]]==1)\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=child[p.first][i];\n\t\t\t\t\tmna.push(P(child[p.first][i],child[p.first][i]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=p.second;\n\t\t\t\t\tmna.push(P(child[p.first][i],p.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long person;\n\t\tfor(long long kkk=q-1;kkk>=0;kkk--)\n\t\t{\n\t\t\tif(query[kkk]==1)\n\t\t\t{\n\t\t\t\tmnalist[qquery[kkk]]=mnalist[par[qquery[kkk]]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tperson=mnalist[qquery[kkk]];\n\t\t\t\twhile(person!=mnalist[person])\n\t\t\t\t{\n\t\t\t\t\tperson=mnalist[person];\n\t\t\t\t}\n\t\t\t\tans+=(person+1);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst int MAX = 1e5;\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvector<int> tr[MAX+1];\nint par[MAX+1],n,q;\nint mark[MAX+1];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    \n    par[y] = x;\n}\n\nbool same(int x,int y){\n    return find(x) == find(y);\n}\n\nint tmp[MAX+1];\nvoid rec(int x,int y,int z){\n    int t = z;\n    tmp[x] = y;\n    if(mark[x]){\n        t = x;\n    }\n    unite(t,x);\n    \n    for(int i = 0 ; i < tr[x].size() ; i++){\n        rec(tr[x][i],x,t);\n    }\n}\n\nint main(){\n    int p,num;\n    char m;\n    while(cin >> n >> q , n + q){\n        ll sum = 0;\n        stack<P> st;\n        init();\n        fill(mark,mark+MAX,0);\n        fill(tmp,tmp+MAX,0);\n        mark[0] = 1;\n        for(int i = 0 ; i < MAX ; i++){\n            tr[i].clear();\n        }\n        for(int i = 1 ; i < n ; i++){\n            cin >> p; --p;\n            tr[p].push_back(i);\n        }\n        for(int i = 0 ; i < q ; i++){\n            cin >> m >> num; --num;\n            st.push(P(m,num));\n            \n            if(m == 'M'){\n                ++mark[num];\n            }\n        }\n        rec(0,0,0);\n        while(q--){\n            P p = st.top(); st.pop();\n            if(p.first == 'Q'){\n                sum += find(p.second)+1;\n            }\n            else{\n                --mark[p.second];\n                if(!mark[p.second]) {\n                    unite(tmp[p.second],p.second);\n                }\n            }\n        }\n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nAOJ 2170 Marked Ancestor\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nstruct OPER{\n    char s[2];\n    int p;\n    void input(){\n        scanf(\"%s%d\", s, &p);\n    };\n}op[MAXN];\n\nint uset[MAXN];\nint rank[MAXN];\n\nclass UnionSet{\npublic:\n    void Init(int n){\n        for(int i=1; i<=n; ++i){\n            uset[i] = i; rank[i] = 0;\n        }\n    }\n    int Find(int x)\n    {\n        if(x == uset[x]) return x;\n        else {\n            int fx = uset[x];\n            uset[x] = Find(fx);\n            return uset[x];\n        }\n    }\n    bool Union(int x, int y) //x and y are different\n    {\n        int fx = Find(x), fy = Find(y);\n        if(fx == fy) return false;\n        if(rank[fx] > rank[fy])\n            uset[fy] = fx;\n        else{\n            uset[fx] = fy;\n            if(rank[fx] == rank[fy]) rank[fy]++;\n        }\n        return true;\n    }\n\n};\n\nUnionSet us;\nint parent[MAXN];\nint isMarked[MAXN];\nvector<vector<int> >tree;\nint N, Q;\n\nvoid dfs(int r, int pa)\n{\n    for(int i=0; i<tree[r].size(); i++){\n        int x = tree[r][i];\n        if(isMarked[x]) dfs(x, x);\n        else dfs(x, pa);\n    }\n    us.Union(r, pa);\n}\n\n\nbool read()\n{\n    scanf(\"%d%d\", &N, &Q);\n    if(N==0&&Q==0) return false;\n    us.Init(N);\n    memset(isMarked, 0, sizeof(isMarked));\n    tree.clear();\n    tree.resize(N+1);\n    for(int i=2; i<=N; ++i){\n        scanf(\"%d\", &parent[i]);\n        tree[parent[i]].push_back(i);\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int q=0; q<Q; ++q){\n        op[q].input();\n        if(op[q].s[0] == 'M'){\n            int v = op[q].p;\n            isMarked[v] = true;\n        }\n    }\n    dfs(1, 1);\n    long long sum = 0;\n    for(int q=Q-1; q>=0; --q){\n        int v = op[q].p;\n        if(op[q].s[0] == 'M'){\n            us.Union(v, parent[v]);\n        }\n        else {\n            sum += us.Find(parent[v]);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n}\n\nint main()\n{\n    while(read()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+1];\nint rank[MAX+1];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init(n);\n    par[0] = 1;\n    for(int i = 1 ; i < n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      --num;\n      if(ch == 'Q'){\n\tsum += find(num)+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint segtree[262144];\nvoid update(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return ;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]=max(segtree[e],f);\n\t\treturn;\n\t}\n\tupdate(a,(a+b)/2,c,d,e*2,f);\n\tupdate((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint query(int a){\n\ta+=131072;\n\tint ret=0;\n\twhile(a){\n\t\tret=max(ret,segtree[a]);\n\t\ta/=2;\n\t}\n\treturn ret;\n}\nvector<int> g[100000];\nint L[100000];\nint R[100000];\nint Z[100000];\nint val;\nvoid dfs(int a){\n\tL[a]=val++;\n\tfor(int i=0;i<g[a].size();i++)\n\t\tdfs(g[a][i]);\n\tR[a]=val-1;\n}\nchar str[2];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tval=0;\n\t\tfor(int i=0;i<262144;i++)segtree[i]=0;\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tfor(int i=1;i<a;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tc--;\n\t\t\tg[c].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tfor(int i=0;i<a;i++)Z[L[i]]=i;\n\t\tlong long ret=0LL;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint d;\n\t\t\tscanf(\"%s%d\",str,&d);\n\t\t\td--;\n\t\t\tif(str[0]=='M'){\n\t\t\t\tupdate(0,131071,L[d],R[d],1,L[d]);\n\t\t\t}else{\n\t\t\t\tret+=Z[query(L[d])]+1;\n\t\t\t\t//printf(\"%d\\n\",query(L[d]));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  UnionFind(int n = 0): par(n, -1){}\n  int root(int x){\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return;\n    par[y] = x;\n  }\nprivate:\n  vector<int> par;\n};\n\nint n, q;\nint p[100000];\nstring t[100000];\nint v[100000];\nint m[100000];\n\nint main(){\n  while (cin >> n >> q, n){\n    memset(m, 0, sizeof(m));\n    m[0]++;\n    UnionFind uf(n);\n    for (int i = 1; i < n; i++){\n      cin >> p[i], p[i]--;\n    }\n    for (int i = 0; i < q; i++){\n      cin >> t[i] >> v[i], v[i]--;\n      if (t[i] == \"M\") m[v[i]]++;\n    }\n    for (int i = 0; i < n; i++){\n      if (!m[i]) uf.unite(p[i], i);\n    }\n    int s = 0;\n    for (int i = q - 1; i >= 0; i--){\n      for (int j = 0; j < n; j++) cout << uf.root(j) << \" \";\n      cout << endl;\n      if (t[i] == \"M\"){\n        if (!--m[v[i]]){\n          uf.unite(p[v[i]], v[i]);\n        }\n      }\n      else s += uf.root(v[i]) + 1;\n    }\n    cout << s << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) data[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF, mx = 0;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t\tmx = max(mx, res);\n\t}\n\t\n\tranges[v] = pii(mn, mx);\n\t\n\t++d;\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tint ans = 0;\n\t\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i + 2);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll __int64\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,d;\n//#define N 200005\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nvector<int>G[100005];\nint fa[100005];\n//int find(int x){\n//\treturn x==fa[x]?fa[x]:fa[x]=find(fa[x]);\n//}\nvoid Union(int x,int y){\n\tfa[y] = x;\n}\nvoid dfs(int x){\n\tint size = (int)G[x].size();\n\tif(size == 0) return;\n\tfor(int i=0;i<size;i++){\n\t\tint v = G[x][i];\n\t\tif(fa[v] == v) continue;\n\t\tUnion(x,v);\n\t}\n\treturn;\n}\nint main(){\n    while(sfd(n,m)!=EOF && n+m){\n    \tfor(int i=0;i<=n;i++) G[i].clear(),fa[i]=1;\n    \tint x;\n    \tfor(int i=2;i<=n;i++){\n    \t\tsf(x);\n    \t\tG[x].push_back(i);\n    \t}\n    \tint ans=0;\n    \tchar op[5];\n    \tfor(int i=0;i<m;i++){\n    \t\tscanf(\"%s%d\",op,&x);\n    \t\tif(op[0] == 'Q'){\n    \t\t\tans += fa[x];\n//    \t\t\tpf(fa[x]);\n    \t\t}else{\n    \t\t\tfa[x] = x;\n    \t\t\tdfs(x);\n    \t\t}\n    \t}\n    \tpf(ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = int(1e5 + 5);\n\nint par[maxn], book[maxn];\nint n, m, x;\nchar c;\n\nint find(int x){\n\n    if(book[x]) return x;\n    return find(par[x]);\n}\nvoid solve(){\n\n    memset(book, 0, sizeof(book));\n    book[1] = par[1] = 1;\n    int res = 0;\n\n    for(int i = 2; i <= n; i++){\n        cin>>x;\n        par[i] = x;\n    }\n    while(m--){\n        cin>>c>>x;\n        if(c == 'M') book[x] = true;\n        else res += find(x);\n    }\n    cout<<res<<endl;\n}\nint main(){\n\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(cin>>n>>m, n or m) solve();\n\n\n//    system(\"pause\");\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> children[100010];\npriority_queue<int> query[100010];\nint markedAt[100010];\nusing ll = long long;\n\nll pull(int v) {\n    ll res = 0;\n    for (int c : children[v]) {\n        res += pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            query[v].push(query[c].top());\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        res += v + 1;\n        query[v].pop();\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(query, query + n, priority_queue<int>());\n        fill(markedAt, markedAt+n, 1e9);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        cout << pull(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int MAX_N=100001;\nvector<vector<int> >edge(MAX_N);\nvector<vector<int> >id(MAX_N);\nint DFS(int n,int d)\n{\n\tid[n].push_back(d);\n\tfor(int i=0;i<edge[n].size();++i)\n\t{\n\t\td=DFS(edge[n][i],d+1)+1;\n\t\tid[n].push_back(d);\n\t}\n\treturn d;\n}\n\n\nint main()\n{\n\tint N,Q,x,i,t;\n\tchar c;\n\tlong long res;\n\ttypedef map<int,int>M;\n\tM m;\n\tM::iterator ite;\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tm.clear();\n\t\tfor(i=1;i<=N;++i)edge[i].clear();\n\t\tfor(i=2;i<=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tedge[x].push_back(i);\n\t\t}\n\t\tDFS(1,1);\n\t\tm[1]=1;\n\t\tm[N*2+1]=-1;\n\t\tres=0;\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c-'Q')\n\t\t\t{\n\t\t\t\tite=m.lower_bound(id[x][0]);\n\t\t\t\tif(ite->second==x)continue;\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tfor(i=0;i<id[x].size();++i)\n\t\t\t\t\tm[id[x][i]]=x;\n\t\t\t\tm[id[x].back()+1]=t;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tite=m.upper_bound(id[x][0]-1);\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tres+=t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i  = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nstruct UF {\n  int n;\n  vector<int> d;\n  UF(int v) : n(v+1), d(v+1, -1){\n    REP(i, 1, n) d[i] = -i;\n  }\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return false;\n    d[y] = x;\n    return true;\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, q;\n  while(cin >> n >> q) {\n    if(n == 0 && q  == 0) break;\n    vector<int> par(n+1);\n    REP(i, 2, n+1) cin >> par[i];\n    using P = pair<int, int>;\n    vector<P> query(q);\n    vector<int> marked(n+1);\n    marked[1] = 1;\n    rep(i, q) {\n      char c;\n      int t;\n      cin >> c >> t;\n      query[i].first = (c == 'M');\n      query[i].second = t;\n      if(query[i].first) marked[t] = 1;\n    }\n    UF uf(n);\n    REP(i, 1, n+1) {\n      if(!marked[i]) {\n\tuf.unite(par[i], i);\n      }\n    }\n    // REP(i, 1, n+1) {\n    //   cout << i << \" \" << uf.root(i) << endl;\n    // }\n    int ans = 0;\n    for(int i = q-1; i >= 0; --i) {\n      if(query[i].first) {\n\tuf.unite(par[query[i].second], query[i].second);\n      }\n      else {\n\tans += uf.root(query[i].second);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define repi(i,a,b) for(int i = (int)(a); i < (int)(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define pb push_back\nconst int inf = 1e9;\nint N, Q;\nvector<int> ch[100010];\nint marked[100010];\n\nvoid dfs(int v, int a){\n    if(marked[v] == v or marked[v] == a) return;\n    marked[v] = a;\n    rep(i,ch[v].size()) dfs(ch[v][i], a);\n}\n\nint solve(){\n    memset(marked, 0, sizeof(marked));\n    int ans = 0;\n    while(Q--){\n        char c; int v;\n        cin >> c >> v;\n        v--;\n        if(c == 'Q') ans += marked[v]+1;\n        else dfs(v, v);\n    }\n    return ans;\n}\n\nbool input(){\n    cin >> N >> Q;\n    if(!N and !Q) return 0;\n    rep(i,N) ch[i].clear();\n    rep(i,N-1) {\n        int a; cin >> a;\n        ch[a-1].pb(i+1);\n    }\n    return 1;\n}\nsigned main(){\n    while(input()) cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nlong long ans;\nint dfs(int x){\n\tfor( int i : M[x] ) near[i] = x;\n\tfor( int i : Q[x] ){\n\t\tint x = (*(--near.lower_bound(i))).second;\n\t\tans += x+1;\n\t}\n\tfor( auto c : ch[x] ) dfs(c);\n\tfor( int i : M[x] ) near.erase(i);\n\t\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear();\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tmarked[1] = true;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t}\n}\nint getnode(int x){\n\tif(par[x]==x||marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tint sum;\n\twhile(cin>>n>>q,n||q){\n\t\tinit(n);\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\tsum +=getnode(k);\n\t\t\t}\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t\tcout <<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nlong long pre[100005];\nlong long find_root(long long x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    long long n, q;\n    while(scanf(\"%lld%lld\", &n, &q), n || q)\n    {\n        pre[1] = 1;\n        for(long long i = 2; i <= n; i++)\n            scanf(\"%lld\", &pre[i]);\n        char a;\n        long long b;\n        long long ans = 0ll;\n        while(q--)\n        {\n            scanf(\" %c%lld\", &a, &b);\n            if(a == 'Q')\n                ans += find_root(b);\n            else\n                pre[b] = b;\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\ntypedef vector<vector<int>> Graph;\n\nint dfs(const Graph &g, const vector<bool> &bs,int node){\n    if(node==0) return 1;\n    if(bs[node]) return node+1;\n    \n    int par=g[node][0];\n    return dfs(g,bs,par);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,q;\n    while(cin>>n>>q, n||q){\n            Graph g(n);\n        for(int i=1;i<n;i++){\n            int par;cin>>par;par--;\n            g[i].push_back(par);\n        }\n        ll res=0;\n        vector<bool> bs(n,false);\n        bs[0]=true;\n        for(int i=0;i<q;i++){\n            string s;int node;\n            cin>>s>>node; node--;\n            if(s==\"M\") bs[node]=true;\n            else{\n            res+=dfs(g,bs,node);\n            }\n        }\n        cout<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w[2];\n\n\twhile(scanf(\"%d%d\",&n,&q)&&n){\n\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d\",&z);z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\tcout<<\"#\"<<endl;\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tscanf(\"%s%d\",w,&z);z--;\n\n\t\tif(w[0]=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\telse{\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\n\n//&#36755;入\nint N, Q;\n\nint par[MAX_N + 1];\t\t\t\t//父&#32467;点\nbool marked[MAX_N + 1];\t\t\t//&#26631;&#35760;&#32467;点\n\nvoid init(){\n\t//初始化\n\tpar[1] = 1;\n\tmemset(marked, 0, sizeof(marked));\n\tmarked[1] = true;\n\tfor(int i = 2; i <= N; i ++)\n\t\tscanf(\"%d\", &par[i]);\n}\n\nint find(int x){\n\t//找到最近被&#26631;&#35760;的父&#32467;点\n\tif(marked[x])return x;\n\telse return find(par[x]);\n}\n\nvoid solve(){\n\tint ans = 0;\n\tfor(int i = 0; i < Q; i ++){\n\t\tgetchar();\n\t\tchar c;\n\t\tint v;\n\t\tscanf(\"%c %d\", &c, &v);\n\t\tif(c == 'M'){\n\t\t\tmarked[v] = true;\n\t\t}\n\t\telse{\n\t\t\tans += find(par[v]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(int argc, char const *argv[]){\n\n\twhile(scanf(\"%d %d\", &N, &Q)){\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tinit();\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n//#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <array>\n//#include <set>\n\nusing namespace std;\n\nusing ll_t = long long;\n// #define ll_t long long\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170&lang=jp\n\nclass UnionFind {\nprotected:\n    vector<size_t> parent;\n    vector<size_t> rank;\npublic:\n    explicit UnionFind(size_t size) {\n        parent.resize(size);\n        rank.resize(size);\n        for (size_t i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    virtual ~UnionFind() {}\n    void unite(size_t x, size_t y) {\n        size_t px = findParent(x);\n        size_t py = findParent(y);\n        if (px == py) {\n            return;\n        }\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else { // rank[px] == rank[py]\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n    bool isSame(size_t x, size_t y) {\n        return findParent(x) == findParent(y);\n    }\n    size_t findParent(size_t x) {\n        if (parent[x] == x) {\n            return x;\n        } else {\n            parent[x] = findParent(parent[x]);\n            return parent[x];\n        }\n    }\n};\n\nclass MarkedTree {\npublic:\n    vector<size_t> parent;\n    vector<bool> marks;\n    explicit MarkedTree(size_t size) {\n        parent = vector<size_t>(size, 0);\n        marks = vector<bool>(size, false);\n        parent[0] = -1; // root\n        marks[0] = true;\n    }\n    size_t findMarkedParent(size_t node) {\n        if (marks[node]) {\n            return node;\n        } else {\n            size_t ret = findMarkedParent(parent[node]);\n            parent[node] = ret;\n            return ret;\n        }\n    }\n    void unMark(size_t node) {\n        marks[node] = false;\n    }\n    void mark(size_t node) {\n        marks[node] = true;\n    }\n    void setParent(size_t node, size_t parentNode) {\n        parent[node] = parentNode;\n    }\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    MarkedTree tree(N);\n    for (int node = 1; node <= N-1; node++) {\n        int parent;\n        cin >> parent;\n        tree.setParent(node, parent - 1);\n    }\n    vector<pair<char, int>> inputs;\n    inputs.reserve(Q);\n    for (int i = 0; i < Q; i++) {\n        char q;\n        int p;\n        cin >> q >> p;\n        inputs.emplace_back(q,p);\n        if (q == 'M') {\n            tree.mark(p-1);\n        }\n    }\n    int querySum = 0;\n    for (auto input = inputs.rbegin(); input != inputs.rend(); ++input) {\n        if (input->first == 'Q') {\n            querySum += tree.findMarkedParent(input->second - 1) + 1;\n        } else { // Mark\n            tree.unMark(input->second - 1);\n        }\n    }\n    cout << querySum << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) data[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF, mx = 0;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t\tmx = max(mx, res);\n\t}\n\t\n\tranges[v] = pii(mn, mx);\n\t\n\t++d;\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tif (rng.first == iINF) continue;\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i + 2);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cstdio>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\ntemplate <int N>\nstruct UnionFind {\n    int ig[N];\n    int d[N];\n    vector<int> gi[N];\n    int dc;\n    void init(int n = N) {\n        for (int i = 0; i < n; ++i) {\n            ig[i] = d[i] = i;\n            gi[i] = {i};\n        }\n        dc = 0;\n    }\n \n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        dc++;\n        int x = ig[a], y = ig[b];\n        if (gi[x].size() < gi[y].size()) swap(x, y);\n        for (int j: gi[y]) {\n            ig[j] = x;\n        }\n        gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n        gi[y].clear();\n        d[x] = min(d[x], d[y]);\n    }\n \n    bool same(int a, int b) {\n        return ig[a] == ig[b];\n    }\n    int get(int a) {\n        return d[ig[a]];\n    }\n};\n\n\nconst int MN = 100100;\nP q[MN];\nint root[MN];\nbool ism[MN];\nUnionFind<MN> uf;\n\nint main() {\n    while (true) {\n        int n, m;\n        scanf(\"%d %d\\n\", &n, &m);\n        if (!n) break;\n        uf.init(n);\n        fill_n(ism, n, false);\n        ism[0] = true;\n        for (int i = 1; i < n; i++) {\n            int u;\n            scanf(\"%d\\n\", &u); u--;\n            assert(u < i);\n            root[i] = u;\n        }\n        for (int i = 0; i < m; i++) {\n            char c; int d;\n            scanf(\" %c %d\\n\", &c, &d); d--;\n            if (c == 'Q') {\n                q[i] = P(0, d);\n            } else {\n                if (ism[d]) {\n                    q[i] = P(2, d);\n                } else {\n                    ism[d] = true;\n                    q[i] = P(1, d);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (ism[i]) continue;\n            uf.merge(i, root[i]);\n        }\n        ll res = 0;\n        for (int i = m-1; i >= 0; i--) {\n            int a, b;\n            tie(a, b) = q[i];\n            if (a == 2) continue;\n            if (a == 1) {\n                uf.merge(b, root[b]);\n            } else {\n                res += uf.get(b)+1;\n            }\n        }\n        printf(\"%lld\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint par[100000];\nint mark[100000];\nint uf[100000];\nint root(int x){\n  if(uf[x] == x) return x;\n  return uf[x] = root(uf[x]);\n}\nint main(){\n  int N, Q;\n  while(cin>>N>>Q && N){\n    par[0] = 0;\n    uf[0] = 0;\n    mark[0] = 1\n    REP(i, N - 1){\n      cin>>par[i + 1];\n      par[i + 1]--;\n      uf[i + 1] = par[i + 1];\n    }\n    memset(mark, 0, sizeof(mark));\n    char c[100000];\n    int v[100000];\n    REP(i, Q){\n      cin>>c[i]>>v[i];\n      v[i]--;\n      if(c[i] == 'M'){\n        mark[v[i]]++;\n      }\n    }\n    REP(i, N) if(mark[i] > 0){\n      uf[i] = i;\n    }\n    ll ans = 0;\n    for(int i = Q - 1; i >= 0; i--){\n      if(c[i] == 'M'){\n        mark[v[i]]--;\n        if(mark[v[i]] == 0){\n          uf[v[i]] = par[v[i]];\n        }\n      }else{\n        ans += root(v[i]) + 1;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\nconst int inf = 1e9;\n\n//range min\nstruct segmentTree{\n\tvector<int> node;\n\tint n;\n\t\n\tsegmentTree(vector<int> v){\n\t\tint s = v.size();\n\t\tn = 2;\n\t\twhile(n < s) n *= 2;\n\t\tnode = vector<int>(2*n -1, inf);\n\t\tfor(int i=0; i<s; i++){\n\t\t\tnode[i +n-1] = v[i];\n\t\t}\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tnode[i] = min(node[2*i +1], node[2*i +2]);\n\t\t}\n\t}\n\tsegmentTree(){}\n\t\n\tvoid Set(int val, int pos){\n\t\tint idx = n-1 + pos;\n\t\tnode[idx] = val;\n\t\tdo{\n\t\t\tidx = (idx -1)/2;\n\t\t\tnode[idx] = min(node[2*idx +1], node[2*idx +2]);\n\t\t}while(idx != 0);\n\t}\n\tint Get(int l, int r){\n\t\tif(l == r) return inf;\n\t\treturn _get(l, r, 0, 0, n);\n\t}\n\tint _get(int l, int r, int k, int cl, int cr){\n\t\tif(l <= cl && cr <= r){\n\t\t\treturn node[k];\n\t\t}\n\t\tif(r <= cl || cr <= l){\n\t\t\treturn inf;\n\t\t}\n\t\tint m = (cl +cr)/2;\n\t\treturn min(_get(l, r, 2*k+1, cl, m), _get(l, r, 2*k+2, m, cr));\n\t}\n};\n\nvector<vector<int> > tree, query, mark;\nvector<int> dep2idx;\nsegmentTree segtree;\nlong long int solve(int node, int depth){\n\tlong long int ret = 0;\n\tfor(int i=0; i<(int)mark[node].size(); i++){\n\t\tsegtree.Set(-depth, mark[node][i]);\n\t\tdep2idx[depth] = node;\n\t}\n\tfor(int i=0; i<(int)query[node].size(); i++){\n\t\tret += dep2idx[-segtree.Get(0, query[node][i])];\n\t}\n\tfor(int i=0; i<(int)tree[node].size(); i++){\n\t\tret += solve(tree[node][i], depth+1);\n\t}\n\tfor(int i=0; i<(int)mark[node].size(); i++){\n\t\tsegtree.Set(0, mark[node][i]);\n\t\tdep2idx[depth] = 0;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,q;\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > vvi(n+1);\n\t\ttree = query = mark = vvi;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tint par;\n\t\t\tcin >> par;\n\t\t\ttree[par].push_back(i);\n\t\t}\n\t\tmark[1].push_back(0);\n\t\tfor(int i=1; i<=q; i++){\n\t\t\tchar c;\n\t\t\tint node;\n\t\t\tcin >> c >> node;\n\t\t\tif(c=='Q') query[node].push_back(i);\n\t\t\telse mark[node].push_back(i);\n\t\t}\n\t\tsegtree = segmentTree(vector<int>(q+1, inf));\n\t\tdep2idx = vector<int>(n, 0);\n\t\tcout << solve(1, 0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<long long int> data;\n\tUnionFind(long long int size) : data(size, -1) { }\n\tbool unionSet(long long int x, long long int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(long long int x, long long int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tlong long int root(long long int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tlong long int size(long long int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001],mpar[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n  fill(mpar, mpar+N+1, 1);\n  \n  marked[1] = 1;\n  par[1] = 1;\n}\n\nint ans(int v){\n\n  //if(marked[par[v]] == 1) return mpar[v] = par[v];\n  //return mpar[v] = ans(par[v]);\n\n  while(marked[par[v]]==0 && v!=1)\n    v = par[v];\n  \n  return v;\n  \n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=2;i<=N;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Node {\n    int parent;\n    vector<int> children;\n};\n\nstruct HLNode {\n    int parent;\n    int position;   // position in the parent's path.\n    vector<int> children;\n    vector<int> path;\n};\n\n// ??¨??? Heavy-Light Decomposition ????????????\n// Arguments:\n//   tree: ??¨???\n//   root: ?????¨???????????????????????????\n// Returns:\n//   vector<HLNode>: ????´?????????¨???\n//   int: ????´?????????¨????????¨???????????????????????????\npair<vector<HLNode>, int> heavy_light_decomposition(const vector<Node>& tree, int root) {\n    vector<HLNode> decomposed;\n    stack<int> S, loop, max_weight, max_index, total_weight;\n    stack<vector<int>> indices;\n    int index, weight;\n\n    {\n        S.push(root);\nstart:\n        int u = S.top();\n        if (tree[u].children.empty()) {\n            decomposed.push_back((HLNode){-1, -1, vector<int>(), vector<int>(1, u)});\n            weight = 1;\n            index = decomposed.size()-1;\n            S.pop();\n            if (!S.empty()) goto ret;\n        } else {\n            max_weight.push(-1); max_index.push(-1); total_weight.push(0); loop.push(0);\n            indices.push(vector<int>(tree[u].children.size()));\n            while (loop.top() < (int)tree[u].children.size()) {\n                S.push(tree[u].children[loop.top()]);\n                goto start;\nret:\n                u = S.top();\n                indices.top()[loop.top()] = index;\n                total_weight.top() += weight;\n                if (weight > max_index.top()) {\n                    max_weight.top() = weight;\n                    max_index.top() = index;\n                }\n                ++loop.top();\n            }\n            int m = max_index.top();\n            for (int idx : indices.top()) if (idx != m) {\n                decomposed[idx].parent = m;\n                decomposed[idx].position = decomposed[m].path.size();\n                decomposed[m].children.push_back(idx);\n            }\n            decomposed[m].path.push_back(u);\n            weight = total_weight.top()+1;\n            index = m;\n            max_weight.pop(); max_index.pop(); total_weight.pop(); loop.pop(); indices.pop(); S.pop();\n            if (!S.empty()) goto ret;\n        }\n    }\n\n    for (auto& node : decomposed) {\n        reverse(node.path.begin(), node.path.end());\n        if (node.parent != -1)\n            node.position = decomposed[node.parent].path.size() - node.position - 1;\n    }\n    return make_pair(move(decomposed), index);\n}\n\ntemplate <typename Int>\nstruct FenwickTree {\n  vector<Int> data;\n  explicit FenwickTree(int n): data(n, -1) {}\n  void set(int i, Int x) { for (; i < (int)data.size(); i |= i+1) data[i] = max(data[i], x); }\n  Int maximum(int i) const { Int s = -1; for (; i >= 0; i = (i & (i+1)) - 1) s = max(s, data[i]); return s; }\n};\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, Q;\n    while (cin>>N>>Q, N|Q) {\n        vector<Node> tree(N);\n        tree[0].parent = -1;\n        FOR(i, 1, N) {\n            int p; cin >> p; --p;\n            tree[i].parent = p;\n            tree[p].children.push_back(i);\n        }\n\n        auto t = heavy_light_decomposition(tree, 0);\n        auto& decomposed = t.first;\n        int root = t.second;\n\n        vector<int> node_mapping(N);\n        vector<int> position_mapping(N);\n        REP(i, decomposed.size()) {\n            auto& node = decomposed[i];\n            REP(j, node.path.size()) {\n                int v = node.path[j];\n                node_mapping[v] = i;\n                position_mapping[v] = j;\n            }\n        }\n\n        vector<FenwickTree<int>> fenwick_trees;\n        for (auto& node : decomposed)\n            fenwick_trees.emplace_back(node.path.size());\n        fenwick_trees[root].set(0, 0);\n\n        long long sum = 0;\n        REP(query_index, Q) {\n            char q; int v; cin >> q >> v; --v;\n            int u = node_mapping[v], p = position_mapping[v];\n            if (q == 'M') {\n                fenwick_trees[u].set(p, p);\n            } else if (q == 'Q') {\n                int ans = 0;\n                while (u != -1) {\n                    int k = fenwick_trees[u].maximum(p);\n                    if (k != -1) {\n                        ans = decomposed[u].path[k];\n                        break;\n                    }\n                    p = decomposed[u].position;\n                    u = decomposed[u].parent;\n                }\n                sum += ans + 1;\n            } else {\n                assert(false);\n            }\n        }\n        cout << sum << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par, rank;\n\tUF() { rank = vector<int>(um, 0); for (int i = 0; i<um; i++) par.push_back(i); }\n\tint operator[](int x) { return (par[x] == x) ? (x) : (par[x] = operator[](par[x])); }\n\tint operator()(int x, int y) {\n\t\tif ((x = operator[](x)) == (y = operator[](y))) return x;\n\t\tif (rank[x]<rank[y]) return par[x] = y;\n\t\trank[x] += rank[x] == rank[y]; return par[y] = x;\n\t}\n};\n\nint N, Q;\nvector<int> E[101010];\nint P[101010];\n\nchar O[101010];\nint V[101010];\n\nbool marked[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> Q)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) E[i].clear();\n\t\trep(i, 0, N) marked[i] = false;\n\n\t\tP[0] = -1;\n\t\trep(i, 1, N)\n\t\t{\n\t\t\tint p; cin >> p; p--;\n\t\t\tP[i] = p;\n\t\t\tE[i].push_back(p);\n\t\t\tE[p].push_back(i);\n\t\t}\n\n\t\tmarked[0] = true;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> O[i] >> V[i];\n\t\t\tV[i]--;\n\t\t\tif(O[i] == 'M') marked[V[i]] = true;\n\t\t}\n\t\t\n\t\tUF<101010> uf;\n\t\trep(i, 0, Q) if (marked[i])\n\t\t{\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tuf(i, q);\n\n\t\t\t\tfor (int to : E[q]) if (to != P[q]) if (!marked[to])\n\t\t\t\t{\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\n\t\tint ans = 0;\n\t\trrep(i, Q - 1, 0)\n\t\t{\n\t\t\tif (O[i] == 'M')\n\t\t\t{\n\t\t\t\tuf(V[i], P[V[i]]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += uf[V[i]];\n\t\t\t\t//cout << uf[V[i]];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q;\nlong int ans;\n// int Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nint search(int x) {\n  int a = par[x];\n  if (marked[a]) return a;\n  else return search(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%ld\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\ntypedef pair<char,int> P;\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q),n|q){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = true;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N     = 100000;\nconst int UNKNOWN   = -1;\n\nstruct op {\n  char op;\n  int target;\n\n  bool isMark() {\n    return op == 'M';\n  }\n\n  bool isQuery() {\n    return op == 'Q';\n  }\n};\n\nint data[MAX_N + 1];\n\nstruct UnionFind {\n  void init() {\n    for (int i = 0; i <= MAX_N; i++) {\n      data[i] = UNKNOWN;\n    }\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if (x != y) {\n      data[x] = y;\n    }\n  }\n\n  int root(int x) {\n    return data[x] < 0 ? x : root(data[x]);\n  }\n\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nUnionFind uf;\nstack<op> ops;\nint marked[MAX_N + 1];\nint p[MAX_N + 1];\n\nint main()\n{\n  while (true) {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n    if (N == Q && Q == 0) break;\n\n    uf.init();\n\n    memset(marked, false, sizeof marked);\n    p[0] = 0; p[1] = 1;\n    for (int i = 2; i <= N; i++) {\n      scanf(\"%d\", p + i);\n    }\n\n    for (int i = 0; i < Q; i++) {\n      op op;\n      scanf(\" %c%d\", &op.op, &op.target);\n      if (op.isMark() && !marked[op.target]) {\n          marked[op.target] = true;\n          ops.push(op);\n      }\n      else if (op.isQuery()) {\n        ops.push(op);\n      }\n    }\n\n    for (int i = 1; i <= N; i++) {\n      if (!marked[i]) {\n        uf.unite(i, p[i]);\n      }\n    }\n\n    long long ans = 0;\n    while (!ops.empty()) {\n      op op = ops.top(); ops.pop();\n\n      if (op.isMark()) {\n        uf.unite(op.target, p[op.target]);\n      }\n      else {\n        ans += uf.root(op.target);\n      }\n    }\n\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n\nint to[123456];\nchar o[123456];\nint v[123456];\n\nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n\n  bool findset(int x,int y)\n  {\n    return root(x) == root(y);\n  }\n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void sep(int x){\n    data[x] = -1;\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    memset(to,0,sizeof(to));\n    memset(o,0,sizeof(o));\n    memset(v,0,sizeof(v));\n    unionfind uf(n+10);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+2] = a;\n      uf.unionset(i+1,a);\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      if(o[i]=='M'){\n        uf.sep(v[i]);\n      }    \n    }\n    int sum = 0;\n    \n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i]);\n      }else{\n        uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "    #include <cstdio>\n    #include <iostream>\n    #include <vector>\n     \n    using namespace std;\n     \n    const int MAX_N = 100000;\n     \n    int N, Q;\n    char Ope[MAX_N];\n    int Openum[MAX_N], Marked[MAX_N];\n    vector<int> child[MAX_N];\n     \n    void mark(int x, int num) {\n      if(Marked[x] == x || Marked[x] == num) return;\n      Marked[x] = num;\n      for(int i = 0; i < child[x].size(); i++){\n        mark(child[x][i], num);\n      }\n    }\n     \n    void solve() {\n      int ans = 0;\n      for(int i = 0; i < MAX_N; i++) Marked[i] = 1;\n      for(int i = 0; i < Q; i++){\n        char ope = Ope[i];\n        int num = Openum[i];\n        if(ope == 'M') mark(num, num);\n        else if(ope == 'Q') ans += Marked[num];\n      }\n      printf(\"%d\\n\", ans);\n    }\n     \n    int main()\n    {\n      while(1){\n        scanf(\"%d %d\", &N, &Q);\n        if(N == 0 && Q == 0) break;\n        for(int i = 0; i <= N; i++) child[i].clear();\n        for(int i = 2; i <= N; i++){\n          int par;\n          scanf(\"%d\", &par);\n          child[par].push_back(i);\n        }\n        for(int i = 0; i < Q; i++){\n          scanf(\"  %c\", &Ope[i]);\n          scanf(\"%d\", &Openum[i]);\n        }\n        solve();\n      }\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include <string>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <cstdio>\n#define MAXN 100010\n\nusing namespace std;\n\nint rank1[MAXN];\nint par[MAXN];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; ++i) {\n        rank1[i] = 0;\n        par[i] = i;\n    }\n}\n\nint find(int x) {\n    if (par[x] == x)\n        return x;\n    else\n        return find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n        return;\n    if (rank1[x] < rank1[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rank1[y] == rank1[x])\n            rank1[x]++;\n    }\n}\n\nint main() {\n    int n, q;\n    while (~scanf(\"%d%d\", &n, &q)) {\n        if (n == 0 && q == 0)\n            break;\n        init(n);\n        for (int i = 2; i <= n; ++i) {\n            scanf(\"%d\", &par[i]);\n        }\n        long long sum = 0;\n        char s[MAXN];\n        int a;\n        for (int i = 1; i <= q; ++i) {\n            scanf(\"%s %d\", s, &a);\n            if (s[0] == 'M') {\n                par[a] = a;\n            }\n            else {\n                sum += find(a);\n            }\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N][2];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid mark(int x) {\n  for(int i = x+1; i <= N; i++){\n    if(x == Node[i][0]){\n      Node[i][1] = x;\n    }\n    for(int j = i+1; j <= N; j++){\n      if(x == Node[i][0] && i == Node[j][0]){\n        Node[j][1] = x;\n      }\n    }\n  }\n}\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      mark(num);\n    }\n    \n    else if(ope == 'Q'){\n      ans += Node[num][1];\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  Node[1][0] = 1;\n  Node[1][1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i][0]);\n      Node[i][1] = 1;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree{\n\tstatic const int N_MAX=1<<17;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tvoid update_min(int l,int r,int a,int b,int u,T v){\n\t\tif(l<=a && b<=r){ dat[u]=min(dat[u],v); return; }\n\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) update_min(l,r,a,c,2*u,v);\n\t\tif(l<b && c<r) update_min(l,r,c,b,2*u+1,v);\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update_min(int l,int r,T v){ update_min(l,r,0,n,1,v); }\n\n\tT query(int u){\n\t\tu+=n;\n\t\tT res=dat[u];\n\t\tfor(u/=2;u>=1;u/=2) res=min(res,dat[u]);\n\t\treturn res;\n\t}\n};\n\nint n;\nvector<int> T[100000]; // tree\n \nint start[100000],end[100000];\n \nint idx;\nvoid dfs(int u){\n    start[u]=idx++;\n    rep(i,T[u].size()) dfs(T[u][i]);\n    end[u]=idx;\n}\n\nint main(){\n\tfor(int q;scanf(\"%d%d\",&n,&q),n;){\n\t\trep(u,n) T[u].clear();\n\t\trep(i,n-1){\n\t\t\tint u,v=i+1; scanf(\"%d\",&u); u--;\n\t\t\tT[u].push_back(v);\n\t\t}\n\n        idx=0;\n        dfs(0);\n\n\t\tstatic int f[100000]; // f : start[u] -> u\n\t\trep(u,n) f[start[u]]=u;\n\n\t\tstatic segment_tree<int> S;\n\t\tS.build(n,0);\n\n\t\tll ans=0;\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint u; scanf(\" %c%d\",&c,&u); u--;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=f[-S.query(start[u])]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tS.update_min(start[u],end[u],-start[u]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_NODE = 100001;\n\nstruct Query {\n\tchar q;\n\tint v;\n};\n\nint parent(int uft[],bool mark[], int c) {\n\tif (mark[c] || uft[c] == c)return c;\n\treturn uft[c] = parent(uft, mark ,uft[c]);\n}\n\nint main() {\n\twhile (true) {\n\t\tint N, Q;\n\t\tlong long ans = 0;\n\t\tint uft[MAX_NODE] = { 0 };\n\t\tbool mark[MAX_NODE] = { 0 };\n\t\tQuery query[MAX_NODE];\n\n\t\tuft[1] = 1;\n\t\tmark[1] = true;\n\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tcin >> uft[i + 1];\n\t\t}\n\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> query[i].q >> query[i].v;\n\t\t\tif (query[i].q == 'M') {\n\t\t\t\tmark[query[i].v] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tif (query[i].q == 'M') {\n\t\t\t\tmark[query[i].v] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += parent(uft, mark, query[i].v);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\tlong long ans;\n\twhile(~scanf(\"%d%d\",&N,&Q)&&N&&Q)\n\t{\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tmemset(marked,0,sizeof marked);\n\t\tans=0;\n\t\tSet[1]=1;fa[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t{\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=1LL*Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[200000],euler;\nint dbl[200000][30],ff[200000],ss[200000],bit[400001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(v==0){\n\t\t\t\trep(j,100000000) cout << \"aho\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2170: Marked Ancestor\n * ?¢???????\n * ?±?????????¶??\\???+dfs+??????????????????+dfs???\n * ?????????????????????????????¢???????±??????\\????????????????\\?????????????dfs?????°????????????????\\??????????????\\???????????????¨??¶??\\????????????????????????????????????????????????????????????????????¶?°???\\???????????¶????????¨???????????¶????????????????????????dfs?????°?????????????????????????????°?????????????????°??\\??????????????????????????´?????????????????°?????°??????\n */\n\n#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<char, int> pci;\n\nstack<pci> s;\n\nint fa[100010];\nint p[100010];\nint vis[100010];\n\nvector<int> e[100010];\n\nint n;\n\nvoid dfs(int i, int f = 1) {\n  if(vis[i]) {\n    f = i;\n  }\n  fa[i] = f;\n  vector<int> &ei = e[i];\n  for(vector<int>::iterator it = ei.begin(); it != ei.end(); ++it) {\n    dfs(*it, f);\n  }\n}\n\nint find(int x) {\n  if(x == fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\n\nint main() {\n  int i, j, q;\n  long long ans;\n  char op[3];\n  while(scanf(\"%d%d\", &n, &q) != EOF && n > 0) {\n    memset(vis, 0, sizeof(vis));\n    for(i = 1; i <= n; ++i) {\n      e[i].clear();\n    }\n    ans = 0;\n\n    vis[1] = 1;\n    for(i = 2; i <= n; ++i) {\n      scanf(\"%d\", &j);\n      e[j].push_back(i);\n      p[i] = j;\n    }\n    for(i = 0; i < q; ++i) {\n      scanf(\"%s%d\", op, &j);\n      if(op[0] == 'M') {\n        ++vis[j];\n      }\n      s.push(make_pair(op[0], j));\n    }\n    dfs(1);\n\n    while(!s.empty()) {\n      i = s.top().second;\n      if(s.top().first == 'M') {\n        if(--vis[i] == 0) {\n          fa[i] = find(p[i]);\n        }\n      } else {\n        ans += find(i);\n      }\n      s.pop();\n    }\n\n    printf(\"%lld\\n\", ans);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define ll long long\nint q, n, v;\nchar c;\nint p[100005];\n//bool m[100005];\nint main() {\n    while ((~scanf(\"%d %d\", &n, &q)) && q && n) {\n        for (int i = 1; i <= n; ++i) scanf(\"%d\", &p[i]);\n        //memset(m, 0, sizeof m);\n        //m[1] = true;\n        ll ans = 0;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"\\n%c %d\", &c, &v);\n            if (c == 'M')p[v] = v;\n            else {\n                while (p[v] != v) v = p[v];\n                ans += v;\n                //printf(\"%d**\\n\", v);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> p[MAX_N];\nint pp[MAX_N];\nint par[MAX_N];\nchar c[MAX_N];\nint num[MAX_N];\nint a[MAX_N];\nint first[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tpar[y] = x;\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nvoid dfs(int v,int anc)\n{\n\tif(a[v]==1){\n\t\trep(i,p[v].size()){\n\t\t\tdfs(p[v][i],v);\n\t\t}\n\t}else{\n\t\tunite(anc,v);\n\t\trep(i,p[v].size()){\n\t\t\tdfs(p[v][i],anc);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n,q;\n\t\tcin >> n >> q;\n\t\tif(n==0&&q==0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i,n){\n\t\t\tp[i].clear();\n\t\t}\n\t\trep(i,n-1){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tp[x-1].push_back(i+1);\n\t\t\tpp[i+1] = x-1;\n\t\t}\n\t\tinitial(n);\n\t\tfill(a,a+n,0);\n\t\ta[0] = 1;\n\t\trep(i,q){\n\t\t\tscanf(\"%*c%c%d\",&c[i],&num[i]);\n\t\t\tif(c[i]=='M'){\n\t\t\t\tif(a[num[i]-1] == 0){\n\t\t\t\t\ta[num[i]-1] = 1;\n\t\t\t\t\tfirst[num[i]-1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0,0);\n\t\tll ans = 0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tif(c[i] == 'M' && i == first[num[i]-1]){\n\t\t\t\tunite(pp[num[i]-1],num[i]-1);\n\t\t\t}else if(c[i] == 'Q'){\n\t\t\t\tans += find(num[i]-1)+1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\nvoid walk_graph(int v, int mark_p,\n        vector<int>& mark_parent, vector<int>& marked, graph& g) {\n\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p, mark_parent, marked, g);\n    }\n}\n\nint find_mark_parent(int v,\n        vector<int>& mark_parent, vector<int>& marked) {\n    if (marked[v]) return v;\n    mark_parent[v] = find_mark_parent(mark_parent[v], mark_parent, marked);\n    return mark_parent[v];\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    vector<int> mark_parent(N, 0);\n    vector<int> marked(N, 0);\n\n    graph g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            marked[q.second] = 1;\n        }\n    }\n\n    walk_graph(0, -1, mark_parent, marked, g);\n\n    int ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n        if (ch == 'Q') {\n            ret += find_mark_parent(v, mark_parent, marked) + 1;\n        }\n\n        if (ch == 'M') {\n            marked[v] = 0;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nstruct node{\n\tint marked_anc,anc_len,begin,end;\n\tnode *left,*right;\n\tnode():marked_anc(INT_MAX),anc_len(INT_MAX),left(NULL),right(NULL){}\n\tstatic node *init(int n){\n\t\tnode *root=new node();\n\t\tint depth=0;\n\t\tint num=1;\n\t\twhile(num<n){\n\t\t\tdepth++;\n\t\t\tnum*=2;\n\t\t}\n\t\troot->construct(depth,0,num-1);\n\t\treturn root;\n\t}\n\tvoid construct(int depth,int begin,int end){\n\t\tthis->begin=begin;\n\t\tthis->end=end;\n\t\tif(depth){\n\t\t\tleft=new node();\n\t\t\tright=new node();\n\t\t\tint width=(end-begin)/2;\n\t\t\tleft->construct(depth-1,begin,begin+width);\n\t\t\tright->construct(depth-1,begin+width+1,end);\n\t\t}\n\t}\n\tint query(int pos){\n\t\tif(begin<=pos&&pos<=end){\n\t\t\tif(marked_anc!=INT_MAX){\n\t\t\t\treturn marked_anc;\n\t\t\t}\n\t\t\tif(left&&right){\n\t\t\t\tint ret=left->query(pos);\n\t\t\t\tif(ret==INT_MAX){\n\t\t\t\t\tret=right->query(pos);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}else{\n\t\t\t\treturn marked_anc;\n\t\t\t}\n\t\t}else{\n\t\t\treturn INT_MAX;\n\t\t}\n\t}\n\tvoid mark(int begin,int end,int marked_anc){\n\t\tif(this->end < begin || this->begin > end){\n\t\t\treturn;\n\t\t}else if(begin <= this->begin && this->end <= end){\n\t\t\tif(anc_len>end-begin){\n\t\t\t\tthis->marked_anc=marked_anc;\n\t\t\t\tthis->anc_len=end-begin;\n\t\t\t}\n\t\t\t//left->mark(begin,end,marked_anc);\n\t\t\t//right->mark(begin,end,marked_anc);\n\t\t\treturn;\n\t\t}else{\n\t\t\tthis->marked_anc=INT_MAX;\n\t\t\tthis->anc_len=INT_MAX;\n\t\t\tleft->mark(begin,end,marked_anc);\n\t\t\tright->mark(begin,end,marked_anc);\n\t\t\treturn;\n\t\t}\n\t}\n};\n\nstruct treenode{\n\tint index;\n\tvector<treenode*> children;\n\ttreenode(int index):index(index){}\n};\n\nvi eulertour(treenode *n){\n\tvi ret;\n\tret.push_back(n->index);\n\tREP(i,n->children.size()){\n\t\ttreenode* c=n->children[i];\n\t\tvi et=eulertour(c);\n\t\tret.insert(ret.end(),ALL(et));\n\t}\n\tret.push_back(n->index);\n\treturn ret;\n}\n\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tvi a(n);\n\tvector<treenode*> treenodes;\n\ttreenodes.push_back(new treenode(1));\n\tREP(i,n-1){\n\t\tint p;\n\t\tcin>>p;\n\t\ttreenodes.push_back(new treenode(i+2));\n\t\ttreenodes[p-1]->children.push_back(treenodes[treenodes.size()-1]);\n\t}\n\tvi et=eulertour(treenodes[0]);\n\tvector<pii> ends(n+1,make_pair(-1,-1));\n\tREP(i,et.size()){\n\t\tif(ends[et[i]].first==-1){\n\t\t\tends[et[i]].first=i;\n\t\t}else{\n\t\t\tends[et[i]].second=i;\n\t\t}\n\t}\n\n\tnode *root=node::init(et.size());\n\troot->mark(ends[1].first,ends[1].second,1);\n\tint ans=0;\n\tREP(i,q){\n\t\tchar command;\n\t\tint v;\n\t\tcin>>command>>v;\n\t\tif(command=='Q'){\n\t\t\tint marked_anc=root->query(ends[v].first);\n\t\t\tans+=marked_anc;\n\t\t}else{\n\t\t\troot->mark(ends[v].first,ends[v].second,v);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nNode arr[100002];\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr[1].isMarked = true;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tarr[_index].isMarked = true;\n\t\tfor (auto itr : arr[_index].c)arr[itr].nearest_index = _index;\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tbreak;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<cstring>\nusing namespace std;\nint n,q,f[100005]={0,1},ans,mkd[100005];\nstack<char>s1;\nstack<int>s2;\nchar c[3],d;\nint ft(int x)\n{\n\tif(mkd[x]||f[x]==x) return x;\n\treturn f[x]=ft(f[x]);\n}\nint main()\n{\n\tint i,j;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(!n&&!q) break;\n\t\tfor(i=2;i<=n;i++) scanf(\"%d\",&f[i]);\n\t\tmemset(mkd,0,sizeof(mkd));mkd[1]=1;ans=0;\n\t\tfor(i=1;i<=q;i++) \n\t\t{\n\t\t\tscanf(\"%s\",c);scanf(\"%d\",&j);\n\t\t\ts1.push(c[0]);s2.push(j);\n\t\t\tif(c[0]=='M') mkd[j]++;\n\t\t}\n\t\twhile(!s1.empty())\n\t\t{\n\t\t\td=s1.top();s1.pop();i=s2.top();s2.pop();\n\t\t\tif(d=='M') mkd[i]--;\n\t\t\tif(d=='Q') ans+=ft(i);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (sizeOf(x) < sizeOf(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint sizeOf(int x) { return -parent[root(x)]; }\n};\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, Q; cin >> N >> Q&&N;) {\n\t\tvector<int> p(N); rep(i, 1, N) {\n\t\t\tcin >> p[i]; p[i]--;\n\t\t}\n\t\tvector<char> c(Q);\n\t\tvector<int> a(Q);\n\t\tvector<int> mark(N, -1);\n\t\tmark[0] = true;\n\t\trep(i, 0, Q) {\n\t\t\tcin >> c[i] >> a[i];\n\t\t\ta[i]--;\n\t\t\tif (c[i] == 'M'&&mark[a[i]] == -1) {\n\t\t\t\tmark[a[i]] = i;\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(N);\n\t\tvector<int> anc(N);\n\t\tiota(all(anc), 0);\n\t\trep(i, 0, N) {\n\t\t\tif (mark[i] == -1) {\n\t\t\t\tint t = anc[uf.root(p[i])];\n\t\t\t\tuf.unite(i, p[i]);\n\t\t\t\tanc[uf.root(i)] = t;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trrep(i, 0, Q) {\n\t\t\tif (c[i] == 'Q')\n\t\t\t\tans += anc[uf.root(a[i])] + 1;\n\t\t\telse {\n\t\t\t\tif (mark[a[i]] != i)continue;\n\t\t\t\tint t = anc[uf.root(p[a[i]])];\n\t\t\t\tuf.unite(a[i], p[a[i]]);\n\t\t\t\tanc[uf.root(a[i])] = t;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pii;\ntypedef complex<double> xy_t;\nconst lint mod = 1e9 + 7;\n\nint n, q;\nint par[100010], init_par[100010];\nchar c[100010];\nint v[100010], first_marked[100010];\n\nint find(int x){\n    if(par[x] < 0) return -par[x];\n    return par[x] = find(par[x]);\n}\n\nint main(){\n    while(scanf(\"%d%d\", &n, &q) && n){\n        par[1] = init_par[1] = first_marked[1] = -1;\n        rep(i, n-1){\n            int r;\n            scanf(\"%d\", &r);\n            par[i+2] = init_par[i+2] = r;\n\t\t\tfirst_marked[i+2] = -1;\n        }\n        rep(i, q){\n            scanf(\" %c %d\", &c[i], &v[i]);\n            if(c[i] == 'M'){\n\t\t\t\tpar[v[i]] = -v[i];\n\t\t\t\tif(first_marked[v[i]] < 0) first_marked[v[i]] = i;\n\t\t\t}\n        }\n        lint ans = 0;\n        rrep(i, q){\n            if(c[i] == 'Q') ans += (lint)find(v[i]);\n            else if(first_marked[v[i]] == i) par[v[i]] = init_par[v[i]];\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint parents[100010];\nint ranks[100010];\n\n// trees[x] -> y, x?????????y\n// ??\\???????????¨?§?????????±\nint trees[100010]; \n\nvoid initUnionFind() {\n    for (int i=0; i<100010; ++i) {\n        parents[i] = i;\n        ranks[i] = 1;\n    }\n}\nint findParent(int x) {\n    if (x == parents[x]) return x;\n    return parents[x] = findParent(parents[x]);\n}\nvoid unite(int x, int y) {\n    int px = findParent(x);\n    int py = findParent(y);\n    if (px == py) return;\n    if (ranks[px] > ranks[py]) {\n        parents[py] = px;\n    } else {\n        parents[px] = py;\n        if (ranks[px] == ranks[py]) {\n            ranks[py] += 1;\n        }\n    }\n}\n\nint main() {\n    int N,Q;\n\n    while (cin >> N >> Q) {\n        if (N == 0 && Q == 0) break;\n\n        initUnionFind();\n        for (int i=0; i<100010; ++i) trees[i] = i;\n\n        for (int i=0; i<N-1; ++i) {\n            int p; cin >> p;\n            parents[i + 2] = p;\n            trees[i + 2] = p;\n        }\n\n        /*\n        // debug\n        cout << \"before marked\" << endl;\n        for (int i=0; i<=N; ++i) {\n            printf(\"node:%2d\\tparent:%2d\\n\", i, parents[i]);\n        }\n        cout << endl;\n        */\n\n        vector<pair<char, int> > queries;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            // ????????????????????????????????????\n            if (ope == 'M' && parents[v] == v) continue;\n\n            // ???????????????\n            if (ope == 'M') {\n                parents[v] = v;\n            }\n            queries.push_back( make_pair(ope, v) );\n        }\n\n        /*\n        // debug\n        cout << \"after marked\" << endl;\n        for (int i=0; i<=N; ++i) {\n            printf(\"node:%2d\\tparent:%2d\\n\", i, findParent(i));\n        }\n        cout << endl;\n        */\n\n        // ???????????????\n        reverse( queries.begin(), queries.end() );\n        int ans = 0;\n        for (int i=0; i<queries.size(); ++i) {\n            if (queries[i].first == 'M') {\n                // mark??????????????????node??¨??£???\n                unite(queries[i].second, trees[queries[i].second]);\n            } else {\n                // ope = 'Q'\n                ans += findParent(queries[i].second);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v] || v==1) return v;\n  else{\n    int a = query(t[v]);\n    t[v] = a;\n    return a;\n  }\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v] = 1;\n      qs.push_front(make_pair(order,v));\n    }\n\n    // printf(\"asdf %d\\n\",(int)qs.size());\n    // for(int i=0; i<qs.size(); i++){\n    //    printf(\"%c %d\\n\",qs[i].first,qs[i].second);\n    // }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second] = 0;\n    \n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  AOJ 2170 Marked Ancestor\n//\n//  Created by TaoSama on 2015-03-16\n//  Copyright (c) 2015 TaoSama. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <set>\n#include <vector>\n#define CLR(x,y) memset(x, y, sizeof(x))\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint n, q, par[N], rank[N];\n\nvoid init(int n) {\n\tfor(int i = 1; i <= n; ++i) {\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif(par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif(x == y) return;\n\tif(rank[x] < rank[y]) par[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]) ++rank[x];\n\t}\n}\n\n//蜴滓?\nint father[N], ancestor[N];\nvector<int> child[N];\nbool marked[N];\nstack<char> op;\nstack<int> node;\n\nvoid bfs(int s, int anc) {\n\tqueue<pair<int, int> > q;\n\tq.push(make_pair(s, anc));\n\twhile(!q.empty()) {\n\t\tint cur = q.front().first;\n\t\tanc = q.front().second; q.pop();\n\t\tif(marked[cur]) anc = cur;\n\t\tancestor[cur] = anc;\n\t\tfor(int i = 0; i < child[cur].size(); ++i)\n\t\t\tq.push(make_pair(child[cur][i], anc));\n\t}\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\n\twhile(~scanf(\"%d%d\", &n, &q) && n && q) {\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tmarked[i] = false;\n\t\t\tchild[i].clear();\n\t\t}\n\t\tmarked[1] = true;\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tfather[i] = x;\n\t\t\tchild[x].push_back(i);\n\t\t}\n\n\t\tfor(int i = 1; i <= q; ++i) {\n\t\t\tchar c[2]; int x;\n\t\t\tscanf(\"%s%d\", c, &x);\n\t\t\tif(c[0] == 'M') marked[x] = true;\n\t\t\top.push(c[0]); node.push(x);\n\t\t}\n\n\t\tbfs(1, 1);\n\n\t\tinit(n);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tunite(i, ancestor[i]);\n\n\t\tlong long ans = 0;\n\t\twhile(!op.empty()){\n\t\t\tchar o = op.top(); op.pop();\n\t\t\tint t = node.top(); node.pop();\n\t\t\tif(o == 'Q') ans += ancestor[find(t)];\n\t\t\telse{\n\t\t\t\t// 蜿肴?隶ー謫堺ス?\t\t\t\tint p = ancestor[find(father[t])];\n\t\t\t\tunite(t, father[t]);\n\t\t\t\tancestor[find(t)] = p;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<set<pair<int,int>>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        vector<int> hist;\n        int res = -1;\n        while(v != -1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(make_pair(-depth[v],-inf));\n            if(it != ms.end()){\n                res = it->second;\n                break;\n            } else {\n                v = goUp(v);\n            }\n        }\n        return res;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q'){\n                ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            } else {\n                marks.insert(mp(-d, qv[i]));\n            }\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q'){\n                ans += h.query(qv[i]) + 1;\n            } else {\n                h.mark(qv[i]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        // y を x に統合\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(parent[i], i);\n            }\n        }\n\n        ll ans = 0;\n        for(int i=Q-1; i>=0; i--) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,q;\nint tree[100001];\n\nint find(int x){\n  if(tree[x]==x) return x;\n  return tree[x]=find(tree[x]);\n}\n\nint main(){\n\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q)break;\n\n    tree[1]=1;\n    for(int i=2;i<=n;i++)cin>>tree[i];\n    \n    char ch[100001];\n    int num[100001],par[100001];\n    for(int i=0;i<q;i++){\n      cin>>ch[i]>>num[i];\n      if(ch[i]=='M'){\n\tpar[num[i]]=tree[num[i]];\n\ttree[num[i]]=num[i];\n      }\n    }\n\n    int ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(ch[i]=='M') tree[num[i]]=find(par[num[i]]);\n      if(ch[i]=='Q') ans+=find(num[i]);\n    }\n    cout <<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\nstruct node {\n\tint id;\n\tint nearmark;\n\tint dis;\n\tvector<int>edges;\n};\n\n\nvector<node>nodes;\nvoid dfs(const int nowid,const int nowdis,const int mark) {\n\tif (nodes[nowid].dis > nowdis) {\n\t\tnodes[nowid].dis = nowdis;\n\t\tnodes[nowid].nearmark = mark;\n\t\tfor (auto nextid : nodes[nowid].edges) {\n\t\t\tdfs(nextid, nowdis + 1, mark);\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tnodes.push_back( node{0,0,0,vector<int>() });\n\tfor (int i = 1; i < N; ++i) {\n\t\tint a; cin >> a; a--;\n\t\tnode anode{ i,nodes[a].nearmark,nodes[a].dis + 1,vector<int>{a} };\n\t\tnodes.push_back(anode);\n\t\tnodes[a].edges.push_back(i);\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tchar c; cin >> c;\n\t\tint n; cin >> n;\n\t\tn--;\n\t\tif (c == 'Q') {\n\t\t\tans += nodes[n].nearmark+1;\n\t\t}\n\t\telse {\n\t\t\tdfs(n, 0,n);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\nconst int maxn = 1e5+5;\nstd::vector<int> v[maxn];\nint p[maxn], r[maxn];\n\nint find(int x) {\n\treturn p[x] == x ? x : find(p[x]);\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, q;\n\tp[1] = 1;\n\twhile(cin >> n >> q && n){\n\t\tLL ans = 0;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tp[i] = x;\n\t\t}\n\t\twhile(q--){\n\t\t\tchar op[2];\n\t\t\tint x;\n\t\t\tcin >> op >> x;\n\t\t\tif(op[0] == 'M') p[x] = x;\n\t\t\telse ans += find(x); \n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt n,q;\nlnt queri[100000][2];\nbool marked[100000];\nlnt par[100000];\nvoid init(void)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t}\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\t\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tx=find(x);\n\ty=find(y);\n\tpar[x]=y;\n\treturn;\n}\n\nchar str[10];\nlnt anc[100000];\nlnt depth[100000];\nvector<lnt> to[100000];\nlnt m;\n\nvoid defdep(lnt x,lnt y){\n\tdepth[x]=y;\n\tfor(lnt i=0;i<to[x].size();i++) defdep(to[x][i],y+1);\n}\n\nint main()\n{while(1){\n\tlnt ans=0;\n\tscanf(\"%lld%lld\",&n,&q);\n\tif(!n&&!q) return 0;\n\tfor(lnt i=0;i<n;i++) to[i].clear();\n\tmemset(marked,0,sizeof(marked));\n\tfor(lnt i=1;i<n;i++){\n\t\tscanf(\"%lld\",&anc[i]);\n\t\tanc[i]--;\n\t\tto[anc[i]].push_back(i);\n\t}\n\tdefdep(0,0);\n\tmarked[0]=1;\n\tfor(lnt i=0;i<q;i++){\n\t\tscanf(\"%s%lld\",str,&queri[i][1]);\n\t\tqueri[i][1]--;\n\t\tif(*str=='M'){\n\t\t\tqueri[i][0]=1;\n\t\t\tmarked[queri[i][1]]=1;\n\t\t}\n\t\telse queri[i][0]=0;\n\t}\n\tfor(lnt i=0;i<n;i++){\n\t\tm=i;\n\t\twhile(!marked[m]&&!same(m,anc[m])){\n\t\t\tunite(m,anc[m]);\n\t\t\tm=anc[m];\n\t\t}\n\t}\n\tfor(lnt i=q-1;i>=0;i--){\n\t\tif(queri[i][0]){\n\t\t\tunite(queri[i][1],anc[queri[i][1]]);\n\t\t}\n\t\telse{\n\t\t\tm=queri[i][1];\n\t\t\tans+=depth[m]-depth[find(m)];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// ????¶?????????????????????!!!!!!!!!!!!!\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ?????????????????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ??????????????????\n    /**********************/\n\n    // x????\\?????????????????????????op=+, invop=1, T=int, T0=0???????????\n    // i??????????±????????????????????????????s[i]????????????????x[i] = s[i]?????????????????? (??????: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n    // O(log n)\n    T query(int j) {\n        T S = T0;\n        for (j; j >= 0; j = (j & (j + 1)) - 1)  // j????????C->B->7??????????????????????£0????????????C????\\?\\????????????????????????????????????????????????????????????\n            S = op(S, x[j]); \n        return S;\n    }\n    // O(log n)\n    void update(int k, T a) {\n        for (; k < x.size(); k |= k+1) // k????????C->D->F??????????????????????£C????\\?\\?????????????????????????????????????????????????\n            x[k] = op(x[k], a); \n    }\n    // O(1)\n    // ?????????x[i]????\\?????????????????????????????????\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n// ??????????????\n//\n// ????????????O(n): ??????????????????????\\?????????, ??????????, ????????????????\\??????\n//\n// LCA O(log n)\n// ??????????????????????? O(log n)\n// ????????????????¬????????\\?\\????????????????¬???????? O(log n)\nclass Tree {\npublic:\n    static const int MAXLOGV = 25;\n    vector<vector<int> > m_edges; // m_edges[i][j]??????????????: i->j??????????????????????\n    int vn; // ?????????????, vn<2^MAXLOGV\n    int root; // ??????????????????????????????\n\n    vector<vector<int>> parent; // parent[i][j]: j??????i^2??????????????????j=0?????????????????????\n    vector<int> depth; // depth[i]: ????????i???????????????????????????????, ????????????0\n\n    vector<int> euler; // ????????????????????????\\?????????????????\\???????????????????????vn*2\n    vector<int> f; // f[i] = euler??????i??????????????????????1????????????°?????????, ????????vn\n    vector<int> s; // f[i] = euler??????i??????????????????????2????????????°?????????, ????????vn\n\n    /*********/\n    // ????????????\n    /*********/\n    Tree(int vn, int root) : vn(vn), root(root) {\n        parent.resize(MAXLOGV);\n        m_edges.resize(vn);\n        for (int i = 0; i < MAXLOGV; i++) \n            parent[i].resize(vn);\n        depth.resize(vn);\n    }\n\n    // ????????????????????????\n    void unite(int u, int v) {\n        m_edges[u].push_back(v);\n        m_edges[v].push_back(u);\n    }\n\n    // root?????????????????????????????????????§??????\n    // unite????????????????????????????????????????????????????????????????\n    void init() {\n        euler.clear(); euler.reserve(2 * vn);\n        f.clear(); f.resize(vn);\n        s.clear(); s.resize(vn);\n        dfs(root, -1, 0);\n        for (int k = 0; k+1 < MAXLOGV; k++) // 2^k?????????????????????×????\n            for (int v = 0; v < vn; v++) \n                if (parent[k][v] < 0) \n                    parent[k+1][v] = -1; // 2^k??????????????????????????¶??????????????????¢2^(k+1)????????????????????????¬?????¶????????????????????\n                else \n                    parent[k+1][v] = parent[k][parent[k][v]]; // 2^(k+1)???????????????2^k?????????????2^k?????????????\n    }\n\n    // 1??????????????????????\\???????????????????\\?????????????????????\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        f[v]=euler.size();\n        euler.push_back(v);\n        for (int next : m_edges[v]) \n            if (next != p)\n                dfs(next, v, d+1);\n        s[v]=euler.size();\n        euler.push_back(v);\n    }\n\n    /*********/\n    // ??????????????????\n    /*********/\n    // ????????u, v??????????????????????????????????\n    //\n    // O(log n)\n    int lca(int u, int v) const {\n        if (depth[u] > depth[v]) swap(u, v); // u????????????????????????????????????\n        for (int k = 0; k < MAXLOGV; k++)    // v??????u???????±??????????????????????????????????\n            if ((depth[v] - depth[u])>>k & 1) \n                v = parent[k][v];\n        if (u == v) return u;\n        for (int k = MAXLOGV-1; k >= 0; k--) { // ????????????????????????????????\\??????????????????\n            if (parent[k][u] == parent[k][v]) // ??????????????\n                continue; \n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n\n    // u??????v?????????\\???????????????\n    // ???????\\????\\???????\\?????????????????????????????????????????????????????\n    //\n    // O(log n)\n    int dist(int u, int v) const {\n        int p = lca(u, v);\n        return (depth[u]-depth[p]) + (depth[v]-depth[p]);\n    }\n\n    // [root, v]?????????????????f???????????????????????????????¬??????\\?????????????????????\n    // 1??????????????????????????????????????????-1????????????????????\n    //\n    // O(log n)\n    int binary_search(int v, function<bool(int)> f) const {\n        for(int j = MAXLOGV - 1; j >= 0;j--) \n            if(parent[j][v] != -1 && f(parent[j][v]))\n                v = parent[j][v];\n        return f(v) ? v : -1;\n    }\n\n    // ?????????????????????\n    void print_dfs(int v, int p) const {\n        for (int i = 0; i < depth[v]; i++)\n            cout << \" \";\n        cout << v << endl;\n        for (int next : m_edges[v]) if (next != p) \n            print_dfs(next, v);\n    }\n    void print(void) const {\n        print_dfs(root, -1);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, q; \n    while (cin >> n >> q && n && q) {\n        Tree t(n, 0);\n        rep(i, n-1) {\n            ll tmp; cin >> tmp;\n            t.unite(i+1, tmp-1); \n        }\n        t.init();\n\n        fenwick_tree<ll> ft(n*2);\n        ft.update(t.f[0], 1);\n        ft.update(t.s[0], -1);\n\n        ll ret = 0;\n        rep(_, q) {\n            char c; ll v; cin >> c >> v; v--;\n            if (c == 'M') {\n                if (ft.access(t.f[v]))\n                    continue;\n                ft.update(t.f[v], 1);\n                ft.update(t.s[v], -1);\n            } else {\n                ll marked_num = ft.query(t.f[v]);\n                ret += t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1; \n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\tlong long ans;\n\twhile(~scanf(\"%d%d\",&N,&Q)&&N&&Q)\n\t{\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tmemset(marked,0,sizeof marked);\n\t\tans=0;\n\t\tSet[1]=1;fa[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t{\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=1LL*Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// J4180449 三宅亮輔\n// 問題名\n// - Marked Ancestor\n// 問題URL\n// - https://onlinejudge.u-aizu.ac.jp/problems/2170\n// 所要時間\n// - 30分\n// 学んだこと\n//\n//\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll N, Q;\nstring A[100001];\nll B[100001];\nll p[100001];\nll par[100001];\nbool marked[100001];\n\nll root(ll a) {\n    if(a == par[a])\n        return a;\n    return par[a] = root(par[a]);\n}\n\nint main() {\n    while(cin >> N >> Q) {\n        ll ans = 0;\n        if(N == 0 && Q == 0)\n            break;\n        par[1] = 1;\n        p[1] = 1;\n        marked[1] = true;\n        for(ll i = 2; i <= N; i++) {\n            cin >> p[i];\n            par[i] = p[i];\n            marked[i] = false;\n        }\n        for(ll i = 0; i < Q; i++) {\n            cin >> A[i] >> B[i];\n            if(A[i] == \"M\")\n                if(marked[B[i]]) {\n                    B[i] = 0;\n                } else {\n                    par[B[i]] = B[i];\n                    marked[B[i]] = true;\n                }\n        }\n\n        for(ll i = Q - 1; i >= 0; i--) {\n            if(A[i] == \"M\") {\n                par[B[i]] = p[B[i]];\n            } else {\n                ans += root(B[i]);\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst int MAX = 1e5;\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvector<int> tr[MAX+1];\nint par[MAX+1],n,q;\nint mark[MAX+1];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    \n    par[y] = x;\n}\n\nbool same(int x,int y){\n    return find(x) == find(y);\n}\n\nint tmp[MAX+1];\nvoid rec(int x,int y,int z){\n    int t = z;\n    tmp[x] = y;\n    if(mark[x]){\n        t = x;\n    }\n    unite(t,x);\n    \n    for(int i = 0 ; i < tr[x].size() ; i++){\n        rec(tr[x][i],x,t);\n    }\n}\n\nint main(){\n    int p,num;\n    char m;\n    while(cin >> n >> q , n + q){\n        ll sum = 0;\n        stack<P> st;\n        init();\n        fill(mark,mark+MAX,0);\n        fill(tmp,tmp+MAX,0);\n        mark[0] = 1;\n        for(int i = 0 ; i < MAX ; i++){\n            tr[i].clear();\n        }\n        for(int i = 1 ; i < n ; i++){\n            cin >> p; --p;\n            tr[p].push_back(i);\n        }\n        for(int i = 0 ; i < q ; i++){\n            cin >> m >> num; --num;\n            st.push(P(m,num));\n            \n            if(m == 'M'){\n                ++mark[num];\n            }\n        }\n        rec(0,-1,-1);\n        while(q--){\n            P p = st.top(); st.pop();\n            if(p.first == 'Q'){\n                sum += find(p.second);\n            }\n            else{\n                if(!mark[p.second]) {\n                    --mark[p.second];\n                    unite(tmp[p.second],p.second);\n                }\n            }\n        }\n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <ctime>\n#include <assert.h>\n\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define eps 1e-8\n#define M_PI 3.141592653589793\n\ntypedef long long ll;\nconst ll mod=1000000007;\nconst int inf=0x7fffffff;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nusing namespace std;\nint f[100010],n,m;\nvoid init()\n{\n    for(int i=1;i<=n;i++) f[i]=i;\n}\n\nint Find(int x)\n{\n   if(x!=f[x]) return Find(f[x]);\n   else return x;\n}\n\nint main()\n{\n   while(scanf(\"%d%d\",&n,&m)&&n&&m){\n       init();\n       for(int i=2;i<=n;i++){\n          scanf(\"%d\",&f[i]);\n       }\n       int ans=0;\n       for(int i=1;i<=m;i++){\n          char c;int a;\n          scanf(\"\\n%c%d\",&c,&a);\n          getchar();\n          if(c=='Q'){\n            ans+=Find(a);\n          }\n          else if(c=='M'){\n              f[a]=a;\n          }\n       }\n       printf(\"%d\\n\",ans);\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\n\nstruct UnionFind {\nprivate:\n\tvector< int > data;\n\t\npublic:\n\tUnionFind(int _size) : data(_size, -1) {}\n\t\n\tbool unite(int _x, int _y) {\n\t\t_x = root(_x); _y = root(_y);\n\t\tif (_x != _y) data[_x] += data[_y]; data[_y] = _x;\n\t\treturn _x != _y;\n\t}\n\t\n\tbool same(int _x, int _y) { return root(_x) == root(_y); }\n\t\n\tint root(int _x) { return data[_x] < 0 ? _x : data[_x] = root(data[_x]); }\n\t\n\tint size(int _x) { return -data[root(_x)]; }\n};\n\nint N, Q, p[100010];\nchar q[100010];\nint mark[100010], v[100010];\nlint anc[100010];\n\nvoid solve() {\n\tUnionFind uf(N+1);\n\t\n\tfor_(i,1,N+1) if (!mark[i]) uf.unite(p[i], i);\n\t\n\tlint ans = 0;\n\t\n\tfor_rev(i,Q-1,0) {\n\t\tif (q[i] == 'M') {\n\t\t\t--mark[ v[i] ];\n\t\t\tif (!mark[ v[i] ]) uf.unite(p[ v[i] ], v[i]);\n\t\t} else {\n\t\t\tans += uf.root(v[i]);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tfor_(i,2,N+1) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\t\n\t\tminit(mark, 0);\n\t\tmark[1] = 1;\n\t\t\n\t\tfor_(i,0,Q) {\n\t\t\tscanf(\"%s %d\", &q[i], &v[i]);\n\t\t\tif (q[i] == 'M') ++mark[ v[i] ];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stdio.h>\n#define MAX_N 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int ,bool> p;\np fa[MAX_N];\nint main(){\n    int n,q;\n    fa[1].first = 1;\n    fa[1].second = true;\n    while(~scanf(\"%d%d\",&n,&q)&&n>0){\n        ll ans = 0;\n        for(int i = 2;i <= n;i++){\n            scanf(\"%d\",&fa[i].first);\n            fa[i].second = false;\n        }\n        getchar();\n        for(int i = 0;i<q;i++){\n            char ch;int a;\n            scanf(\"%c%d\",&ch,&a);\n            getchar();\n            if(ch =='Q'){\n                while(fa[a].second==false){\n                    a = fa[a].first;\n                }\n                ans += a;\n            }\n            else{\n                fa[a].second = true;\n            }\n\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n\ninline int input(){\n\tchar c;\n\tfor(c = getchar();c<'0' || c>'9';c = getchar());\n\tint res = c - '0';\n\tfor(c = getchar();c>='0' && c<='9';c = getchar()) res = res * 10 + (c - '0');\n\treturn res;\n}\ninline char letter(){\n\tchar c;\n\tfor(c = getchar();c != 'M' && c != 'Q';c = getchar());\n\treturn c;\n}\nint n,q,p[100005],par[100005];\nbool mark[100005];\nchar c[100005];\nint v[100005];\ninline void ini(int x){\n\tfor(int i=1;i<=x;i++){\n\t\tif(mark[i]) par[i] = i;\n\t\telse par[i] = p[i];\n\t}\n}\nint find_(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find_(par[x]);\n}\nint main(){\n//\tios::sync_with_stdio(false);\n\twhile(true){\n\t\tint ans = 0;\n\t\tn = input();\n\t\tq = input();\n\t\tif(n == 0 && q == 0) break;\n\t\tp[1] = 1;\n\t\tmark[1] = true;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tp[i] = input();\n\t\t}\n\t\tfor(int i=1;i<=q;i++){\n\t\t\tc[i] = letter();\n\t\t\tv[i] = input();\n\t\t\tif(c[i] == 'M') mark[v[i]] = true;\n\t\t}\n\t\tini(n);\n\t\tfor(int i=q;i>=1;i--){\n\t\t\tif(c[i] == 'Q') ans += find_(v[i]);\n\t\t\telse{\n\t\t\t\tpar[v[i]] = p[v[i]];\n\t\t\t\tmark[v[i]] = false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 0\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1<<28;\n\n\nint Find(int p, vec& par) {\n    if (p == par[p]) return (p);\n    return (par[p] = Find(par[p], par));\n}\n\nvoid Merge(int x, int y, vec& par) {\n    x = Find(x, par), y = Find(y, par);\n    if (x != y) {\n        par[x] = y;\n    }\n}\n\nvoid dfs(int now, int p, vec& par, mat& T, vec& MarkedTime) {\n    if (MarkedTime[now] != MarkedTime[p] && MarkedTime[now] != INF) return ;\n    par[now] = p;\n    for (int i = 0; i < T[now].size(); i++) {\n        dfs(T[now][i], p, par, T, MarkedTime);\n    }\n}\n\nvoid solve(int N, int Q) {\n    mat T(N+1);\n    vec Tr(N+1);\n    Tr[1] = 1;\n    for (int i = 2; i <= N; i++) {\n        int v; cin >> v;\n        T[v].push_back(i);\n        Tr[i] = v;\n    }\n\n    vec MarkedTime(N+1, INF);\n    vec TimeToMarkedVertex(Q+1);\n    vec QueryTimeToVertex(Q+1);\n    MarkedTime[1] = -1;\n    for (int i = 0; i < Q; i++) {\n        char q;\n        int v;\n        cin >> q >> v;\n        if (q == 'M') MarkedTime[v] = min(MarkedTime[v], i), TimeToMarkedVertex[i] = v;\n        else QueryTimeToVertex[i] = v;\n    }\n\n    vec par(N+1);\n    for (int i = 1; i <= N; i++) par[i] = i;\n    for (int i = 1; i <= N; i++) {\n        if (MarkedTime[i] == INF) continue;\n        dfs(i, i, par, T, MarkedTime);\n    }\n\n    long long int cost = 0LL;\n    for (int i = Q - 1; i > -1; i--) {\n        if (QueryTimeToVertex[i] > 0) cost += Find(par[QueryTimeToVertex[i]], par);\n        else if (i == MarkedTime[TimeToMarkedVertex[i]])\n            Merge(TimeToMarkedVertex[i], Tr[TimeToMarkedVertex[i]], par);\n    }\n\n    cout << cost << endl;\n}\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N || Q) solve(N, Q);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (x == 1 || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nvector<int> V[100005];\nbool vis[100005] = {};//记录是否被标记\nint flag[100005] = {};//记录最近的祖先\n\nvoid add(int ind){\n    if(vis[ind])\n        return ;\n    vis[ind] = 1;\n    queue<int>Q;\n    Q.push(ind);\n    while(!Q.empty()){\n        int t = Q.front();Q.pop();\n        flag[t] = ind;\n        for(int i=V[t].size()-1;i>=0;i--){\n            if(vis[V[t][i]])\n                continue ;\n            Q.push(V[t][i]);\n        }\n    }\n    return ;\n}\nint main(){\n    int N, Q, x;\n    char str[15];\n    \n    while(scanf(\"%d%d\",&N,&Q),N|Q){\n        long long ans = 0;\n        memset(vis,0,sizeof(vis));\n        memset(flag,0,sizeof(flag));\n        for(int i=1;i<100005;i++){\n            V[i].clear();\n        }\n        for(int i=2;i<=N;i++){\n            scanf(\"%d\",&x);\n            V[x].push_back(i);\n        }\n        add(1);\n        for(int i=0;i<Q;i++){\n            scanf(\"%s%d\",str,&x);\n            if(str[0] == 'Q'){\n                ans += flag[x];\n            }else {\n                add(x);\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n/*#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>*/\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct UnionFind\n{\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tUnionFind(int N) :parent(N, 0), rank(N, 0)\n\t{\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif (x == y)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (rank[x] < rank[y])\n\t\t{\n\t\t\tparent[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvector<int> G[100005];\nint anc[100005];\n\nvoid dfs(int nv, int tanc)\n{\n\tif (anc[nv] == tanc || anc[nv] == nv)\n\t{\n\t\treturn;\n\t}\n\tanc[nv] = tanc;\n\tfor (auto n : G[nv])\n\t{\n\t\tdfs(n, tanc);\n\t}\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true)\n\t{\n\t\tint N, Q;\n\t\tcin >> N >> Q;\n\t\tif (N + Q == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tG[i].clear();\n\t\t\tanc[i] = 0;\n\t\t}\n\n\t\tint to;\n\t\trep(i, 0, N - 1)\n\t\t{\n\t\t\tcin >> to;\n\t\t\tG[to - 1].push_back(i + 1);\n\t\t}\n\t\tchar c;\n\t\tint v;\n\t\tll ans = 0;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')\n\t\t\t{\n\t\t\t\tdfs(v - 1, v - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += anc[v - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <limits>\n \ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n \n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n \ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n \ntemplate <typename Weight>\nstruct edge {\n  using value_type = Weight;\n  size_t src, dst;\n  value_type cost;\n \n  edge(size_t src, size_t dst, value_type cost = 1):\n    src(src), dst(dst), cost(cost)\n  {}\n \n  bool operator <(edge<value_type> const& rhs) const {\n    if (cost != rhs.cost) return cost < rhs.cost;\n    if (src != rhs.src) return src < rhs.src;\n    return dst < rhs.dst;\n  }\n};\n \ntemplate <typename Weight>\nstruct graph: public std::vector<std::vector<edge<Weight>>> {\n  using value_type = Weight;\n  graph(size_t n): std::vector<std::vector<edge<value_type>>>(n) {}\n \n  void connect_with(size_t src, size_t dst, value_type cost = 1) {\n    (*this)[src].emplace_back(src, dst, cost);\n    (*this)[dst].emplace_back(dst, src, cost);\n  }\n};\n \ntemplate <typename Tp>\nstd::array<std::vector<size_t>, 2> euler_tour(graph<Tp> const& g, size_t s = 0) {\n  std::array<std::vector<size_t>, 2> res;\n  res[0] = res[1] = std::vector<size_t>(g.size());\n  size_t j = 0;\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    res[0][i] = j++;\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      dfs(e.dst, i);\n    }\n    res[1][i] = j++;\n  })(s, -1);\n  return res;\n}\n \ntemplate <typename Tp>\nstd::vector<size_t> depth(graph<Tp> const& g, size_t s = 0) {\n  std::vector<size_t> res(g.size());\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      res[e.dst] = res[e.src] + 1;\n      dfs(e.dst, e.src);\n    }\n  })(s, -1);\n  return res;\n}\n \ntemplate <\n  typename Monoid,\n  typename Container = std::vector<typename Monoid::first_type>,\n  typename SubContainer = std::vector<typename Monoid::second_type>\n>\nclass segment_tree {\npublic:\n  using first_type = typename Monoid::first_type;\n  using second_type = typename Monoid::second_type;\n  using value_type = first_type;\n  using binary_operation = typename Monoid::binary_operation;\n  using external_binary_operation = typename Monoid::external_binary_operation;\n  using merge_operation = typename Monoid::merge_operation;\n  using container = Container;\n  using sub_container = SubContainer;\n \nprivate:\n  size_t M_base_size;\n  binary_operation M_op1;\n  external_binary_operation M_op2;\n  merge_operation M_op3;\n  container M_c;\n  sub_container M_d;  // deferred\n \n  void M_build(size_t i) {\n    while (i > 1) {\n      i >>= 1;\n      M_c[i] = M_op2(M_op1(M_c[i<<1|0], M_c[i<<1|1]), M_d[i]);\n    }\n  }\n \n  void M_resolve(size_t i) {\n    size_t h = (sizeof(size_t) * CHAR_BIT) - __builtin_clzll(M_base_size*2);\n    for (size_t s = h; s > 0; --s) {\n      size_t p = i >> s;\n      if (M_d[p] != M_op3.identity) {\n        M_apply(p<<1|0, M_d[p]);\n        M_apply(p<<1|1, M_d[p]);\n        M_d[p] = M_op3.identity;\n      }\n    }\n  }\n \n  void M_apply(size_t i, second_type const& x) {\n    M_c[i] = M_op2(M_c[i], x);\n    if (i < M_base_size) M_d[i] = M_op3(M_d[i], x);\n  }\n \npublic:\n  segment_tree() = default;\n  segment_tree(segment_tree const&) = default;\n  segment_tree(segment_tree&&) = default;\n \n  segment_tree(size_t n, first_type const& x = binary_operation().identity):\n    M_base_size(n),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(n+n, x), M_d(n, M_op3.identity)\n  {\n    for (size_t i = n; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n \n  template <typename InputIt>\n  segment_tree(InputIt first, InputIt last):\n    M_base_size(std::distance(first, last)),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(M_base_size*2), M_d(M_base_size, M_op3.identity)\n  {\n    for (size_t i = M_base_size; first != last; ++i)\n      M_c[i] = *first++;\n    for (size_t i = M_base_size; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n \n  segment_tree& operator =(segment_tree const&) = default;\n  segment_tree& operator =(segment_tree&&) = default;\n \n  void modify(size_t l, size_t r, second_type const& x) {\n    l += M_base_size;\n    r += M_base_size;\n    size_t l0 = l;\n    size_t r0 = r;\n    while (l < r) {\n      if (l & 1) M_apply(l++, x);\n      if (r & 1) M_apply(--r, x);\n      l >>= 1;\n      r >>= 1;\n    }\n    M_build(l0);\n    M_build(r0-1);\n  }\n \n  first_type accumulate(size_t l, size_t r) {\n    first_type resl = M_op1.identity;\n    first_type resr = resl;\n    l += M_base_size;\n    r += M_base_size;\n    M_resolve(l);\n    M_resolve(r-1);\n    while (l < r) {\n      if (l & 1) resl = M_op1(resl, M_c[l++]);\n      if (r & 1) resr = M_op1(M_c[--r], resr);\n      l >>= 1;\n      r >>= 1;\n    }\n    return M_op1(resl, resr);\n  }\n \n  first_type operator [](size_t i) {\n    M_resolve(i + M_base_size);\n    return M_c[i];\n  }\n};\n \nnamespace std {\n  template <typename T1, typename T2>\n  struct numeric_limits<std::pair<T1, T2>> {\n    static std::pair<T1, T2> constexpr min() {\n      return std::make_pair(std::numeric_limits<T1>::min(), std::numeric_limits<T2>::min());\n    }\n  };\n}\n \ntemplate <typename Tp>\nstruct range_max_range_max {\n  using first_type = Tp;\n  using second_type = Tp;\n  struct binary_operation {\n    first_type identity = std::numeric_limits<Tp>::min();\n    first_type operator ()(first_type const& x, first_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct external_binary_operation {\n    first_type operator ()(first_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct merge_operation {\n    second_type identity = std::numeric_limits<Tp>::min();\n    second_type operator ()(second_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n};\n \nint testcase_ends() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n  if (n == 0 && q == 0) return 1;\n \n  graph<int> g(n);\n  for (size_t i = 1; i < n; ++i) {\n    size_t p;\n    scanf(\"%zu\", &p);\n    --p;\n    g.connect_with(i, p);\n  }\n \n  auto d = depth(g);\n  auto et = euler_tour(g);\n\n  // {depth, nma}\n  segment_tree<range_max_range_max<std::pair<size_t, size_t>>> st(n+n, std::make_pair(0, 0));\n \n  size_t res = 0;\n  for (size_t i = 0; i < q; ++i) {\n    char t;\n    size_t v;\n    scanf(\" %c %zu\", &t, &v);\n    --v;\n \n    if (t == 'Q') {\n      res += st[et[0][v]].second+1;\n    } else if (t == 'M') {\n      st.modify(et[0][v], et[1][v]+1, std::make_pair(d[v], v));\n    }\n  }\n \n  printf(\"%zu\\n\", res);\n  return 0;\n}\n \nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[1] = true;\n\tfor(int i = 1;i < n;i++){\n\t    cin >> root[i];\n\t    root[i]--;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    marked[--query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q;q--;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second) + 1;\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint edge[100001];\nvector<int> G[100001];\nint par[100001];\nbool flag[100001];\nint fm[100001];\nchar s[100001];\nint v[100001];\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tpar[i]=i;\n\t\tG[i].clear();\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tmemset(fm,-1,sizeof(fm));\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tpar[x]=y;\n\t}\n\n}\n\nvoid unite_dfs(int v,int p){\n\tif(!flag[v])unite(v,p);\n\telse p=v;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tunite_dfs(G[v][i],p);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&edge[i]);\n\t\t\tG[edge[i]].push_back(i);\n\t\t}\n\t\tflag[1]++;\n\t\tfm[1]=-2;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tcin >> s[i] >> v[i];\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]=true;\n\t\t\t\tif(fm[v[i]]==-1)fm[v[i]]=i;\n\t\t\t}\n\t\t}\n\t\tunite_dfs(1,1);\n\t\tlong long res=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(s[i]=='Q'){\n\t\t\t\tres+=(long long)find(v[i]);\n\t\t\t}\n\t\t\tif(s[i]=='M' && fm[v[i]]==i){\n\t\t\t\tunite(v[i],edge[v[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>     //by  @山?叶??     A\n#include<cstdlib>\n#include<cmath>\n#include<string>\n#include<set>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ndouble dinf=99999999.9, mm=1e-8;\nconst int N=100008,inf=0x3f3f3f3f;\nint f[N],vis[N],near[N];\nint getf(int v)  //?找父?点\n{\n    if(f[v]==v)\n        return v;\n    else\n        return f[v]=getf(f[v]);\n}\nint getnear(int v)\n{\n    if(vis[f[v]]==1)\n        return near[v]=f[v];\n    else\n        return near[v]=getnear(f[v]);\n}\n\nint main()\n{\n    int i,q,m,n,k;ll sum;char ch[4];\n    while(scanf(\"%d%d\",&n,&q),n+q)\n    {\n        sum=0;k=0;\n        for(i=1;i<=n;i++)\n        {\n            scanf(\"%d\",&m);f[i]=m;vis[i]=0;near[i]=1;\n        }\n        vis[1]=1;///初始化\n        for(i=1;i<=q;i++)\n        {\n            scanf(\"%s%d\",ch,&m);\n            if(ch[0]=='Q')\n            {\n                if(k==0)\n                    sum+=(ll)near[m];\n                else\n                    sum+=(ll)getnear(m);\n                k=0;\n            }\n            else\n            {\n                vis[m]=1;k=1;\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(long i=0; i<(n); i++)\n#define dmp(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nbool m[1000000];\nlong a[1000000];\nchar com[1000000];\nlong d[1000000];\n\nlong long calc(int n)\n{\n  if(m[n])\n    return n;\n  else\n    return calc(a[n]);\n}\n\nint main()\n{\n  int N,Q;\n  while(scanf(\"%d %d\", &N, &Q),N+Q){\n    for(int i=2;i<N+1;i++){\n      scanf(\"%ld\",a+i);\n    }\n    m[1]=true;\n    rep(i,Q){\n      scanf(\" %c %ld\", com+i,d+i);\n    }\n    \n    long long ret=0;\n    \n    rep(i,Q) switch(com[i]) {\n    case 'M':\n      m[d[i]]=true;\n      break;\n    case 'Q':\n      ret += calc(d[i]);\n      break;\n    }\n    printf(\"%lld\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 100010;\nint par[MAXN], T[MAXN], M[MAXN], vis[MAXN];\nvector<int> Chd[MAXN];\n\nstruct opr{\n\tchar c;\n\tint v;\n} O[MAXN];\n\nint init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tint r = x;\n\twhile(par[r] != r){\n\t\tr = par[r];\n\t}\n\tint i = x, j;\n\twhile(par[i] != r){\n\t\tj = par[i];\n\t\tpar[i] = r;\n\t\ti = j;\n\t}\n\treturn r;\n}\n\nvoid unite(int x, int y){\n\tint nx = find(x), ny = find(y);\n\tif(y == T[x]){\n\t\tpar[nx] = ny;\n\t}else{\n\t\tpar[ny] = nx;\n\t}\n}\n//=======================================\nint N, Q, ans;\n\nvoid dfs(int x){\n\tif(M[T[x]] || vis[x]){\n\t\tvis[x] = 1;\n\t\treturn;\t\n\t}\n\tvis[x] = 1;\n\tdfs(T[x]);\n\tunite(x, T[x]);\n}\n\nint main(){\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\twhile(scanf(\"%d%d\", &N, &Q), N){\n\t\t\n\t\tmemset(M, 0, sizeof(M)); M[0] = 1;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\t\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tscanf(\"%d\", T+i);\n\t\t\tT[i]--;\n\t\t\tChd[T[i]].push_back(i);\n\t\t}\n\t\tinit(N);\n\t\t\n\t\tfor(int i = Q - 1; i >= 0; i--){\n\t\t\tscanf(\" %c%d\", &O[i].c, &O[i].v);\n\t\t\tO[i].v--;\n\t\t\tif(O[i].c == 'M') M[O[i].v] = 1;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tdfs(i);\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tint vv = O[i].v;\n\t\t\tif(O[i].c == 'M'){\n\t\t\t\tfor(int j = 0; j < Chd[vv].size(); j++){\n\t\t\t\t\tunite(vv, Chd[vv][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += T[find(vv)] + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAXN; i++){\n\t\t\tChd[i].clear();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt n,q;\nlnt queri[100000][2];\nbool marked[100000];\nlnt par[100000];\nvoid init(void)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t}\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\t\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tx=find(x);\n\ty=find(y);\n\tpar[x]=y;\n\treturn;\n}\n\nchar str[10];\nlnt anc[100000];\nlnt depth[100000];\nvector<lnt> to[100000];\nlnt m;\n\nvoid defdep(lnt x,lnt y){\n\tdepth[x]=y;\n\tfor(lnt i=0;i<to[x].size();i++) defdep(to[x][i],y+1);\n}\n\nint main()\n{while(1){\n\tlnt ans=0;\n\tscanf(\"%lld%lld\",&n,&q);\n\tif(!n&&!q) return 0;\n\tmemset(marked,0,sizeof(marked));\n\tfor(lnt i=1;i<n;i++){\n\t\tscanf(\"%lld\",&anc[i]);\n\t\tanc[i]--;\n\t\tto[anc[i]].push_back(i);\n\t}\n\tdefdep(0,0);\n\tmarked[0]=1;\n\tfor(lnt i=0;i<q;i++){\n\t\tscanf(\"%s%lld\",str,&queri[i][1]);\n\t\tqueri[i][1]--;\n\t\tif(*str=='M'){\n\t\t\tqueri[i][0]=1;\n\t\t\tmarked[queri[i][1]]=1;\n\t\t}\n\t\telse queri[i][0]=0;\n\t}\n\tfor(lnt i=0;i<n;i++){\n\t\tm=i;\n\t\twhile(!marked[m]&&!same(m,anc[m])){\n\t\t\tunite(m,anc[m]);\n\t\t\tm=anc[m];\n\t\t}\n\t}\n\tfor(lnt i=q-1;i>=0;i--){\n\t\tif(queri[i][0]){\n\t\t\tunite(queri[i][1],anc[queri[i][1]]);\n\t\t}\n\t\telse{\n\t\t\tm=queri[i][1];\n\t\t\tans+=depth[m]-depth[find(m)];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint father[100005];\nint n, q;\n\nint find(int a)\n{\n\t//注意：不能压缩路径\n\t//路径压缩只能在不关注爹的情况下用 \n\t/*if(father[a] == a)\n\t\treturn a;\n\telse\n\t\treturn father[a] = find(father[a]);*/\n\treturn a==father[a]?a:find(father[a]);\n}\n\nint main()\n{\n\twhile(cin>>n>>q and n and q)\n\t{\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tfather[i] = i;\n\t\n\t\tint tx;\n\t\tfor(int i = 2; i <= n; ++i)\n\t\t\tscanf(\"%d\", &father[i]);\t//注意：不需要unite， 因为这不是判断在不在一个集合内 \n\t\n\t\tchar oper;\n\t\tlong long ans = 0;\n\t\tfor(int i = 1; i <= q; ++i)\n\t\t{\n\t\t\tcin>>oper>>tx;\n\t\t\tswitch(oper)\n\t\t\t{\n\t\t\t\tcase 'Q':\n\t\t\t\t\tans += find(tx);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tfather[tx] = tx;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass UnionFindTree {\nprivate:\n  int* par;\npublic:\n  UnionFindTree(int n){\n    par = new int[n]();\n    for(int i=0;i<n;i++){\n      par[i] = i;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] par;\n  }\n\n  int find(int x){\n    if(par[x] == x){\n      return x;\n    } else {\n      return par[x] = find(par[x]);\n    }\n  }\n\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    par[x] = y;\n  }\n\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nvector<int> G[100001];\nint marked_count[100001];\nint prev_parent[100001];\n\nvoid dfs(int current_node,int parent,int last_marked_node,UnionFindTree* uft){\n  if(marked_count[current_node] > 0){\n    last_marked_node = current_node;\n  }\n\n  prev_parent[current_node] = parent;\n  uft->unite(current_node,last_marked_node);\n  for(int to_idx=0;to_idx<G[current_node].size();to_idx++){\n    int to = G[current_node][to_idx];\n    dfs(to,current_node,last_marked_node,uft);\n  }\n}\n\nint main(){\n  int total_nodes;\n  int total_queries;\n  while(~scanf(\"%d %d\",&total_nodes,&total_queries)){\n    if(total_nodes == 0 && total_queries == 0) break;\n\n    for(int i=0;i<=100000;i++) G[i].clear();\n\n    memset(marked_count,0,sizeof(marked_count));\n    for(int node_idx = 2;node_idx-1<total_nodes;node_idx++){\n      int parent;\n      scanf(\"%d\",&parent);\n      G[parent].push_back(node_idx);\n    }\n\n    int queries[100001];\n    for(int query_idx=0;query_idx < total_queries; query_idx++){\n      char operation[2];\n      int target_node;\n      scanf(\"%s %d\",operation,&target_node);\n      if(operation[0] == 'M'){\n\tmarked_count[target_node]++;\n\tqueries[query_idx] = target_node;\n      }\n      else if(operation[0] == 'Q'){\n\tqueries[query_idx] = -target_node;\n      }\n    }\n\n    UnionFindTree uft(total_nodes+1);\n    dfs(1,1,1,&uft);\n\n    ll sum = 0;\n    for(int query_idx=total_queries-1;query_idx>=0;query_idx--){\n      if(queries[query_idx] <= 0){\n\tint target_node = -queries[query_idx];\n\tsum += uft.find(target_node);\n      }\n      else if(queries[query_idx] > 0){\n\tint target_node = queries[query_idx];\n\tmarked_count[target_node]--;\n\tif(marked_count[target_node] <= 0){\n\t  uft.unite(target_node,prev_parent[target_node]);\n\t}\n      }\n    }\n    printf(\"%lld\\n\",sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct node{\n    int id;\n    node* parent;\n    int h;\n    vector<node*> child;\n};\nbool com(node* n1,node* n2){\n    return n1->id<n2->id;\n}\nint main(){\n    //freopen(\"/Users/shitian/Downloads/1.txt\",\"r\",stdin);\n    int n,q,p;\n    while(cin>>n>>q,n){\n        vector<node*>vec;\n        vector<node*>marked;\n        for(int i=0;i<n;i++){\n            node* t=new node;\n            vec.push_back(t);\n        }\n        node* no=vec[0];\n        vec[0]->id=1;\n        vec[0]->parent=no;\n        vec[0]->h=1;\n        marked.push_back(no);\n        for(int i=2;i<=n;i++){\n            cin>>p;\n            node* no=vec[i-1];\n            no->id=i;\n            no->parent=vec[p-1];\n            no->h=no->parent->h+1;\n            vec[p-1]->child.push_back(no);\n        }\n        int ans=0;\n        for(int i=0;i<q;i++){\n            char que;int num;\n            cin>>que>>num;\n            if(que=='M'){\n                marked.push_back(vec[num-1]);\n            }\n            else{\n                node* pa=vec[num-1]->parent;\n                int found=0;\n                while(true){\n                    int ma=0;\n                    sort(marked.begin(),marked.end(),com);\n                    if(binary_search(marked.begin(), marked.end(), pa, com)){\n                        ma=max(ma,pa->id);\n                        found=1;\n                    }\n                    if(found){\n                        ans+=ma;\n                        goto next;\n                    }\n                    if(pa->id==1){\n                        goto next;\n                    }\n                    pa=vec[pa->id]->parent;\n                }\n                \n            next:;\n            }\n        }\n        cout<<ans<<endl;;\n        vec.clear();\n        marked.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001],mpar[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n  fill(mpar, mpar+N+1, 1);\n  \n  marked[1] = 1; marked[0] = 1;\n  par[1] = 0; mpar[1] = 0;\n}\n\nint ans(int v){\n\n  if(marked[par[v]] == 1 ) return par[v];\n  return mpar[v] = ans(par[v]);\n\n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=2;i<=N;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint ancestor[100000];\nint n, q;\nint marked_ancestor[100000];\nbool ismarked[100000];//false = unmarked\nP outlog[100000];\n\nvoid create_UF(int size) {\n\tfor (int i = 0; i < size; i++) {\n\t\tmarked_ancestor[i] = i;\n\t}\n}\n\nint getroot(int a) {\n\tif (a == marked_ancestor[a])return a;\n\treturn marked_ancestor[a] = getroot(marked_ancestor[a]);\n}\n\nbool is_same_unit(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\t//parent kid\n\tif (is_same_unit(a, b))return;\n\tmarked_ancestor[b] = a;\n}\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tcreate_UF(n);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tunite(getroot(ancestor[i]), i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tmarked_ancestor[0] = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M')unite(getroot(ancestor[outlog[i].second]), outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint tree[100010];\nint Find(int x)\n{\n    if(tree[x]==x)return x;\n    return Find(tree[x]);\n}\n/*\nvoid Merge(int x,int y)\n{\n    int t1=Find(x),t2=Find(y);\n    if(t1!=t2)\n        f[t1]=t2;\n}*/\nint main()\n{\n   // freopen(\"input.txt\", \"r\", stdin);\n   ios::sync_with_stdio(false);\n   int n,q,y;\n   char x;\n    while(cin>>n>>q)\n    {\n        if(n==0 && q==0)return 0;\n       // cout<<n<<' '<<q<<endl;\n        int ans=0;\n        memset(tree,0,sizeof(tree));\n        tree[1]=1;\n        for(int i=1;i<n;i++)\n            cin>>tree[i];\n       getchar();\n        for(int i=1;i<=q;i++)\n        {\n            cin>>x>>y;\n            //cout<<x<<' '<<y<<endl;\n            //getchar;\n            if(x=='M')\n              tree[y]=y;\n            else\n                {\n                    ans+=Find(y);\n                    //cout<<ans<<endl;\n                }\n        }\n        printf(\"%d\\n\",ans);\n\n\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst int qmax=100010;\n\nvi trees[nmax];\nint p[nmax];\nint last[nmax];\n\nvoid add_edge(int a,int b){\n\ttrees[a].pb(b);\n\ttrees[b].pb(a);\n}\n\nint uf[nmax];\nint find(int i){\n\tif(uf[i]==i)\n\t\treturn i;\n\treturn uf[i]=find(uf[i]);\n}\n\nvoid unite(int p,int c){\n\tuf[c]=p;\n\treturn;\n}\n\n\nvoid dfs(int v,int p){\n\tif(last[v]==-1)\n\t\tunite(p,v);\n\tfor(auto &e:trees[v]){\n\t\tif(e!=p)\n\t\t\tdfs(e,v);\n\t}\n}\n\n\nchar type[qmax];\nint num[qmax];\n\nint main(void){\n\tint n,q;\n\twhile(cin >> n >> q){\n\t\tfor(int i=1;i<=n;++i){\n\t\t\ttrees[i].clear();\n\t\t\tuf[i]=i;\n\t\t\tlast[i]=-1;\n\t\t}\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tcin >> p[i];\n\t\t\tadd_edge(p[i],i);\n\t\t}\n\t\tlast[1]=-2;\n\t\trep(i,q){\n\t\t\tcin >> type[i] >> num[i];\n\t\t\tif(type[i]=='M'&&last[num[i]]==-1)\n\t\t\t\tlast[num[i]]=i;\n\t\t}\n\t\tdfs(1,-1);\n\t\tll ans=0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tdump(i)\n\t\t\tdump(ans)\n\t\t\tif(type[i]=='Q')\n\t\t\t\tans+=find(num[i]);\n\t\t\telse{\n\t\t\t\tif(last[num[i]]==i)\n\t\t\t\t\tunite(p[num[i]],num[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100001\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    p[0]=0;\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nAOJ 2170 Marked Ancestor\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nstruct OPER{\n    char s[2];\n    int p;\n    void input(){\n        scanf(\"%s%d\", s, &p);\n    };\n}op[MAXN];\n\nint uset[MAXN];\nint rank[MAXN];\n\nclass UnionSet{\npublic:\n    void Init(int n){\n        for(int i=1; i<=n; ++i){\n            uset[i] = i; rank[i] = 0;\n        }\n    }\n    int Find(int x)\n    {\n        if(x == uset[x]) return x;\n        else {\n            int fx = uset[x];\n            uset[x] = Find(fx);\n            return uset[x];\n        }\n    }\n    bool Union(int x, int y) //x and y are different\n    {\n        int fx = Find(x), fy = Find(y);\n        if(fx == fy) return false;\n        if(rank[fx] > rank[fy])\n            uset[fy] = fx;\n        else{\n            uset[fx] = fy;\n            if(rank[fx] == rank[fy]) rank[fy]++;\n        }\n        return true;\n    }\n\n};\n\nUnionSet us;\nint parent[MAXN];\nint isMarked[MAXN];\nvector<vector<int> >tree;\nint N, Q;\n\nvoid dfs(int r, int pa)\n{\n    for(int i=0; i<tree[r].size(); i++){\n        int x = tree[r][i];\n        if(isMarked[x]) dfs(x, x);\n        else dfs(x, pa);\n    }\n    us.Union(r, pa);\n}\n\n\nbool read()\n{\n    scanf(\"%d%d\", &N, &Q);\n    if(N==0&&Q==0) return false;\n    us.Init(N);\n    memset(isMarked, 0, sizeof(isMarked));\n    tree.clear();\n    tree.resize(N+1);\n    for(int i=2; i<=N; ++i){\n        scanf(\"%d\", &parent[i]);\n        tree[parent[i]].push_back(i);\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int q=0; q<Q; ++q){\n        op[q].input();\n        if(op[q].s[0] == 'M'){\n            int v = op[q].p;\n            isMarked[v] = true;\n        }\n    }\n    dfs(1, 1);\n    long long sum = 0;\n    for(int q=Q-1; q>=0; --q){\n        int v = op[q].p;\n        if(op[q].s[0] == 'M')\n            us.Union(v, parent[v]);\n        else {\n            sum += us.Find(v);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n}\n\nint main()\n{\n    while(read()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#define INF 1000000000\n#define M 100005\n#define LL long long\nusing namespace std;\nstruct node{\n    int x,y;\n}A[M],Q[M];\nint fa[M];\nbool mark[M];\nint edge[M];\nint get(int x){\n    if(fa[x]==x) return x;\n    else return fa[x]=get(fa[x]);\n}\nint get_ans(int x){\n    x=get(x);\n    while(!mark[x]){\n        fa[x]=get(edge[x]);\n        x=get(x);\n    }\n    return x;\n}\nint readin(){\n    int res=0;\n    char a;\n    while(a=getchar(),!isdigit(a));\n    do{\n        res=(res<<3)+(res<<1)+(a^48);\n    }while(a=getchar(),isdigit(a));\n    return res;\n}\nint main(){\n    int n,q,j,k;\n    while(scanf(\"%d%d\",&n,&q)!=EOF){\n        if(n==0&&q==0) break;\n        memset(mark,0,sizeof(mark));\n        memset(fa,0,sizeof(fa));\n        memset(edge,0,sizeof(edge));\n        mark[1]=1;edge[1]=1;\n        for(j=1;j<=n;j++) fa[j]=j;\n        for(j=2;j<=n;j++){\n            int a;\n            scanf(\"%d\",&a);\n            edge[j]=a;\n        }\n        char s[2];\n        for(j=1;j<=q;j++){\n            scanf(\"%s%d\",s,&Q[j].y);\n            if(s[0]=='Q') Q[j].x=0;\n            else{\n                mark[Q[j].y]=1;\n                Q[j].x=1;\n            }\n        }\n        long long ans=0;\n        for(j=1;j<=n;j++) get_ans(j);\n        for(j=q;j>=1;j--){\n            if(Q[j].x==0){\n                ans+=get(Q[j].y);\n            }\n            else if(mark[Q[j].y]){\n                mark[Q[j].y]=0;\n                fa[Q[j].y]=get(edge[Q[j].y]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nconst int MAX_N=100010;\nint par[MAX_N];\nint myrank[MAX_N];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tmyrank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return;\n\n\t//if(myrank[x]<myrank[y]){\n\t//\tpar[x]=y;\n\t//}else{\n\t\tpar[y]=x;\n\t\t//if(myrank[x]==myrank[y])myrank[x]++;\n\t//}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(){\n\tint n,q;\n\twhile(cin>>n>>q,n|q){\n\t\tvi a(n);\n\t\tvi parents(n,-1);\n\t\tREP(i,n-1){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tparents[i+1]=p-1;\n\t\t}\n\n\t\tinit(n);\n\t\tvi marked(n);\n\n\t\tvector<pair<char,int> > queries;\n\t\tREP(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin>>c>>v;\n\t\t\tbool add=true;\n\t\t\tif(c=='M'){\n\t\t\t\tif(marked[v-1]){\n\t\t\t\t\tadd=false;\n\t\t\t\t}else{\n\t\t\t\t\tmarked[v-1]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(add){\n\t\t\t\tqueries.push_back(make_pair(c,v-1));\n\t\t\t}\n\t\t}\n\n\t\tREP(i,n){\n\t\t\tif(!marked[i]&&parents[i]!=-1){\n\t\t\t\tunite(parents[i],i);\n\t\t\t}\n\t\t}\n\n\t\tll ans=0;\n\t\tREP(i,queries.size()){\n\t\t\tchar c=queries[queries.size()-i-1].first;\n\t\t\tint v=queries[queries.size()-i-1].second;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=find(v)+1;\t\n\t\t\t}else if(v!=0){\n\t\t\t\tunite(parents[v],v);\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define ll long long\nint q, n, v;\nchar c;\nint p[100005];\nint main() {\n    while ((~scanf(\"%d %d\", &n, &q)) && q && n) {\n        for (int i = 2; i <= n; ++i) scanf(\"%d\", &p[i]);\n        p[1] = 1;\n        ll ans = 0;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"\\n%c %d\", &c, &v);\n            if (c == 'M') p[v] = v;\n            else {\n                while (p[v] != v) v = p[v];\n                ans += v;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nchar Ope[MAX_N];\nint Openum[MAX_N], Marked[MAX_N];\nvector<int> child[MAX_N];\n\nvoid mark(int x, int num) {\n  if(Marked[x] == x || Marked[x] == num) return;\n  Marked[x] = num;\n  for(int i = 0; i < child[x].size(); i++){\n    mark(child[x][i], num);\n  }\n}\n\nvoid solve() {\n  int ans = 0;\n  fill(Marked, Marked+N, 1);\n  for(int i = 0; i < Q; i++){\n    char ope = Ope[i];\n    int num = Openum[i];\n    if(ope == 'M') mark(num, num);\n    else if(ope == 'Q') ans += Marked[num];\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 0; i <= N; i++) child[i].clear();\n    for(int i = 2; i <= N; i++){\n      int par;\n      scanf(\"%d\", &par);\n      child[par].push_back(i);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nint par[MAX_N+1];//parents\nint rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n//find root\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint N,Q,sum = 0;//sumのみ0で初期化\nint tree[MAX_N+1];\n\nint nearestAncstr(int num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,int num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nint num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\tfor(int i = 1;i < N;i++){scanf(\"%d\",&tree[i]);tree[i]--;}//0-indexed\n\tsymbol = getchar();scanf(\"%d\",&num);\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(!(symbol == '0' && num == 0)){\n\t\toperate(symbol,num);\n\t\tsymbol = getchar();scanf(\"%d\",&num);\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%d\\n\",sum);\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&Q);\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi col,in;\nint dfs(int a){\n\tif(col[a])return a;\n\telse return dfs(in[a]);\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tcol=vi(n);\n\t\tcol[0]=1;\n\t\tin=vi(n);\n\t\trep(i,n-1){\n\t\t\tint a;cin>>a;\n\t\t\tin[i+1]=a-1;\n\t\t}\n\t\tll out=0;\n\t\trep(i,m){\n\t\t\tchar c;int a;\n\t\t\tcin>>c>>a;\n\t\t\tif(c=='M')col[a-1]=true;\n\t\t\telse{\n\t\t\t\tout+=1+dfs(in[a-1]);\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\tint t;\n\t\trep(i, n-1) {\n\t\t\tcin >> t; t--;\n\t\t\tpar0[i + 1] = t;\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long n,m,x,sum,flg;\nstring str;\nint t[100001],u[100001];\nint dfs(int x){\n  if(u[x]==1)return x;\n  return dfs(t[x]);\n}\nint main(){\n  while(cin>>n>>m,n){\n    for(int i=0;i<100001;i++)u[i]=0;\n    t[1]=u[1]=1;\n    sum=0;\n    for(int i=0;i<n-1;i++)cin>>t[i+2];\n    for(int i=0;i<m;i++){\n      cin>>str>>x;\n      if(str==\"Q\"){\n    sum+=dfs(x);\n      }else{\n    u[x]=1;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n//#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,Q,par[100010],par2[100010],mark[100010],q[100010],first[100010];\nchar c[100010];\n\nint f(int v){\n    if(mark[v]) return v;\n    return par2[v]=f(par[v]);\n}\n\nint main(){\n\twhile(cin>>N>>Q && N){\n        fill(mark,mark+N+1,0);\n        fill(first,first+Q,0);\n        mark[1]=1;\n        \n        rep2(i,2,N+1) cin>>par[i];\n        \n        rep(i,Q){\n            cin>>c[i]>>q[i];\n            if(c[i]=='M' && mark[q[i]]==0){\n                first[i]=1;\n                mark[q[i]]=1;\n            }\n        }\n        \n        rep2(i,1,N+1) par2[i]=f(i);\n        \n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            if(c[i]=='M'){\n                if(first[i]){\n                    mark[q[i]]=0;\n                    par2[q[i]]=f(q[i]);\n                }\n            }else{\n                ans+=f(q[i]);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n\nusing namespace std;\nconst int MAX_N=100001;\nvector<int>edge[MAX_N];\nvector<int>id[MAX_N];\nint vi[MAX_N*2];\nint DFS(int n,int d)\n{\n\tvi[d]=n;\n\tid[n].push_back(d);\n\tfor(int i=0;i<edge[n].size();++i)\n\t{\n\t\td=DFS(edge[n][i],d+1)+1;\n\t\tvi[d]=n;\n\t\tid[n].push_back(d);\n\t}\n\treturn d;\n}\n\n\nint main()\n{\n\tedge.resize(MAX_N);\n\tid.resize(MAX_N);\n\tint N,Q,x,i,t;\n\tchar c;\n\tlong long res;\n\ttypedef map<int,int>M;\n\tM m;\n\tM::iterator ite;\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tm.clear();\n\t\tfor(i=1;i<=N;++i)edge[i].clear();\n\t\tfor(i=2;i<=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tedge[x].push_back(i);\n\t\t}\n\t\tDFS(1,1);\n\t\tm[1]=1;\n\t\tm[N*2]=-1;\n\t\tres=0;\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c-'Q')\n\t\t\t{\n\t\t\t\tite=m.lower_bound(x);\n\t\t\t\tif(ite->second==x)continue;\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tfor(i=0;i<id[x].size();++i)\n\t\t\t\t{\n\t\t\t\t\tm[id[x][i]]=x;\n\t\t\t\t}\n\t\t\t\tm[id[x].back()+1]=t;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tite=m.upper_bound(id[x][0]);\n\t\t\t\tres+=(--ite)->second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 10000000\nusing namespace std;\nint par[MAX];\nint N,Q;\n\nvoid init()\n{\n  rep(i,MAX)par[i] = i;\n}\n\nint find(int x)\n{\n  if(x == par[x])return x;\n  return find(par[x]);\n}\n\nbool unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x != y)par[y] = x;\n}\n\nbool same(int x,int y)\n{\n  return find(x) == find(y);\n}\n\nint main()\n{\n  while(cin >> N >> Q,N|Q)\n    {\n      init();\n      REP(i,1,N)\n\t{\n\t  int variable;\n\t  cin >> variable;\n\t  variable--;\n\t  par[i] = variable;\n\t}\n\n      long long cost = 0;\n      rep(i,Q)\n\t{\n\t  char Query;\n\t  int v;\n\t  cin >> Query >> v;\n\t  v--;\n\t  if(Query == 'Q')\n\t    {\n\t      cost += find(v)+1;\n\t    }\n\t  else \n\t    {\n\t      par[v] = v;\n\t    }\n\t}\n      cout << cost << endl;\n    }\n  return 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(x);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nbool marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tscanf(\"%d\",fa+i);\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;marked[id]=1;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint N, O; // O: number of operations\n\nstruct Node {\n\tint index;\n\tint r, l;\n\tint p;\n\tbool marked;\n\tNode() {\n\t\tr = l = 0;\n\t\tp = 0;\n\t\tmarked = false;\n\t}\n};\n\nint Q(Node *tree, int index) {\n\twhile (!tree[index].marked) {\n\t\tindex = tree[index].p;\n\t}\n\treturn index;\n}\n\nvoid M(Node *tree, int index) {\n\ttree[index].marked = true;\n}\n\nint main() {\n\twhile (cin >> N >> O) {\n\t\tif (N == 0 && O == 0) break;\n\t\tNode tree[N+1];\n\t\ttree[1].index = 1;\n\t\ttree[1].marked = true;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tint parent; cin >> parent;\n\t\t\ttree[i].index = i;\n\t\t\ttree[i].p = parent;\n\t\t}\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < O; i++) {\n\t\t\tchar op; int index;\n\t\t\tcin >> op >> index;\n\t\t\tif (op == 'Q') {\n\t\t\t\tsum += Q(tree, index);\n\t\t\t} else {\n\t\t\t\tM(tree, index);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[100005];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tfa[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')fa[a] = a;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (fa[a] != a)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nll sum;\nint find(int x,int flag){\n    if(flag)    return 0;\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                if(vis[t])  sum+=t;\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct UF\n{\n\tvector<int> par; // ???\n\t// ?????????\n\tUF(int n):par(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t// ??¨??????????±???????\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// x??¨y????±??????????????????????\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\t// ??¨??????????????????????????£??¨??????????????????\n\t\tpar[x] = y;\n\t}\n\t// x??¨y?????????????????????true\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct node\n{\n\tint par;\n\tvector<int> chi;\n};\n\nbool me[100100];\n\nint main()\n{\n\tint n,q;\n\twhile(cin >> n >> q,n|q)\n\t{\n\t\n\tUF uf(n+1);\n\t\n\tvector<node> v(n+1);\n\tv[1].par = 1;me[1] = true;\n\t\n\t\n\tREP(i,n-1)\n\t{\n\t\tint tmp;cin >> tmp;\n\t\tv[tmp].chi.PB(i+2);\n\t\tv[i+1].par = tmp;\n\t}\n\t\n\tvector<pair<char,int> > p;\n\t\n\tREP(i,q)\n\t{\n\t\tchar c;int num;\n\t\tcin >> c >> num;\n\t\tif(c == 'M')\n\t\t{\n\t\t\tif(me[num])continue;\n\t\t\tme[num] = true;\n\t\t}\n\t\tp.PB(MP(c,num));\n\t}\n\t\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tif(me[i])\n\t\t{\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(i);\n\t\t\twhile(!Q.empty())\n\t\t\t{\n\t\t\t\tint tmp = Q.front();Q.pop();\n\t\t\t\t\n\t\t\t\tREP(j,v[tmp].chi.size())\n\t\t\t\t{\n\t\t\t\t\tif(me[v[tmp].chi[j]])continue;\n\t\t\t\t\tuf.unite(v[tmp].chi[j],i);\n\t\t\t\t\tQ.push(v[tmp].chi[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\tREP(i,n)\n\t{\n\t\tcout << uf.find(i+1) << ' ';\n\t}cout << endl;\n\t*/\n\t\n\tll ans = 0;\n\t\n\tfor(int i = p.size()-1;i >= 0;--i)\n\t{\n\t\tif(p[i].FI == 'Q')\n\t\t{\n\t\t\tans += uf.find(p[i].SE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuf.unite(p[i].SE,v[p[i].SE].par);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<long long int> par;\n\t// sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n\tvector<long long int> sizes;\n\t\n\tUnionFind(long long int n) : par(n), sizes(n, 1) {\n\t// ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n\trep(i,n) par[i] = i;\n\t}\n\t\n\t// ?????????x????±?????????¨???????????????\n\tlong long int find(long long int x) {\n\tif (x == par[x]) return x;\n\treturn par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n\t}\n\t\n\t// 2???????????????x, y????±?????????¨??????????????????\n\tvoid unite(long long int x, long long int y) {\n\tx = find(x);\n\ty = find(y);\n\t\n\tif (x == y) return;\n\t\n\tpar[y] = x;\n\tsizes[x] += sizes[y];\n\t}\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\ta[1] = 1;\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<bool> roots(n);\n\t\troots[1] = true;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots[v]) continue;\n\t\t\tif(c == 'M') roots[v] = true;\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(!roots[i]){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unite(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unite(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.find(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\nconst int MAX_V = 100010;\nint n, q;\nvector<int> G[MAX_V]; \n\nstruct BIT{\n    int N;\n    vector<int> dat;\n    BIT() {}\n    BIT(int n) {\n        N = n;\n        dat.resize(N + 1);\n    }\n    // update k th element (0-index)\n    void add(int k, int x){\n        k++;\n        while(k <= N){\n            dat[k] += x;\n            k += k&-k;\n        }\n    }\n    // sum [0, k) (0-index)\n    int sum(int k){\n        int s = 0;\n        while(k > 0){\n            s += dat[k];\n            k -= k&-k;\n        }\n        return s;\n    }\n    // sum [a, b) (0-index)\n    int query(int a, int b){\n        return sum(b) - sum(a);\n    }\n};\n\nclass Euler_Tour{\npublic:\n    // vector<vector<int> > g;\n    //begin[v],end[v]はそれぞれvがオイラーツアー上で最初と最後に現れるインデックス\n    //[begin[v], end[v])がvを根とする部分木 (半開区間に注意)\n    vector<int> euler_tour, begin, end, dist;\n    Euler_Tour(int n) : /*g(n),*/ begin(2 * n), end(2 * n){};\n    int k = 0, root = 0;\n    void dfs(int curr, int par){\n        begin[curr] = k;\n        euler_tour.push_back(curr);\n        k++;\n        for(auto next : G[curr]){\n            if(next == par) continue;\n            dfs(next, curr);\n            euler_tour.push_back(curr);\n            k++;\n        }\n        end[curr] = k;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> q;\n        if(n + q == 0) break;\n        rep(i, 1, n){\n            int v;\n            cin >> v;\n            v--;\n            G[v].push_back(i);\n            G[i].push_back(v);\n        }\n        Euler_Tour et(n);\n        et.dfs(0, -1);\n        q++;\n        vector<pair<char, int> > qr(q);\n        qr[0] = {'M', 0};\n        rep(i, 1, q){\n            cin >> qr[i].first >> qr[i].second;\n            qr[i].second--;\n        } \n        BIT bt(2 * n), bt2(2 * n);\n        vector<bool> use(q); \n        rep(i, 0, q){\n            if(qr[i].first == 'Q') continue;\n            int v = qr[i].second;\n            int tmp = bt.query(et.begin[v], et.end[v]);\n            if(tmp == 0) use[i] = true;\n            bt.add(et.begin[v], 1);\n        }\n        int ans = 0;\n        for(int i = q - 1; i >= 0; i--){\n            int v = qr[i].second;\n            if(qr[i].first == 'Q'){\n                bt2.add(et.begin[v], 1);\n            }else{\n                if(use[i] == false) continue;\n                int tmp = bt2.query(et.begin[v], et.end[v]);\n                // cout << i << ' ' << tmp << \" \" << v << endl;\n                bt2.add(et.begin[v], -tmp);\n                ans += tmp * (v + 1);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    //if(n == 0)\n//\tint m = 1;\n    if(flag[n] != 0)\n    {\n\treturn n;\t    \n    }\n\n    else\n    {\t\n\treturn t[n] = find(t[n]);    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n//#ifndef ONLINE_JUDGE\n//    READ;\n//#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint ii = 0;\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 1;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tii = ii + 1;\n\tif(ii == 5)\n\t    int m = 0;\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]]++;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M') flag[idx[i]]--;\n\t    else ret = ret + find(idx[i]);\n\t    //std::cout<<idx[i]<<std::endl;\n\t    //if(idx[i] == 0)\n\t    //int m = 1;\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct segment_tree{\n    static const int SEG=1<<17;\n    vector<int>dat;\n    segment_tree():dat(SEG*2){}\n    void update(int a,int b,int x,int k=0,int l=0,int r=SEG){\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            dat[k]=max(dat[k],x);\n            return;\n        }\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n    int query(int k){\n        k+=SEG-1;\n        int ret=dat[k];\n        while(k){\n            k=(k-1)/2;\n            ret=max(ret,dat[k]);\n        }\n        return ret;\n    }\n};\n\nconst int SIZE=100000;\n\nint N,Q;\nvector<int>G[SIZE];\n\nint tt,tin[SIZE],tout[SIZE];\nint par[20][SIZE],dep[SIZE];\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    tin[v]=tt++;\n    for(auto u:G[v])dfs(u,v,d+1);\n    tout[v]=tt;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&N,&Q),N||Q){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=1;i<N;i++){\n            int p;scanf(\"%d\",&p);p--;\n            G[p].push_back(i);\n        }\n        tt=0;\n        dfs(0,-1,0);\n\n        for(int i=0;i<19;i++){\n            for(int j=0;j<N;j++){\n                if(par[i][j]==-1)par[i+1][j]=-1;\n                else par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n\n        segment_tree seg;\n        long long ans=0;\n        while(Q--){\n            char c;\n            int v;\n            scanf(\" %c%d\",&c,&v);\n            v--;\n            if(c=='M'){\n                seg.update(tin[v],tout[v],dep[v]);\n            }\n            else{\n                int d=seg.query(v);\n                for(int i=19;i>=0;i--)if((dep[v]-d)>>i&1)v=par[i][v];\n                ans+=v+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nbool flag[MAX_N];\nint ran[MAX_N];\nvoid init(int n) {\n\tfor(int i=2; i<=n; i++) {\t\t\n\t\tflag[i] = false;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif(flag[x])\n\t\treturn x;\n\telse\n\t\tfind(par[x]);\n}\n\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tlong long sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tpar[1]= 1;\n\t\tflag[1] = true;\n\t\tinit(n);\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(par[p]);\n\t\t\t}else{\n\t\t\t\tflag[p] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\n//int orig[NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\n//bool marked[NN];\nvoid setLevel(int i, int n)\n{\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tif (!scanf(\"%d%d\",&N,&Q))\n\t{\n\t\texit(0);\n\t}\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t\tchild[1][i].clear();\n\t\tparent[0][i]=0;\n\t\tparent[1][i]=0;\n\t\tlevel[i]=0;\n\t\tnearest[i]=P(0,0);\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\t//orig[i]=p;\n\t\t//marked[i]=false;\n\t\tchild[0][p].push_back(i);\n\t}\n\t//marked[1]=true;\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\n\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n//*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif((level[i]%step)==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step){\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}//*/\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}//*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tLL sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\t//cout << \"zzz \" << endl;\n\t\t//int ov=v;\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\t/*\n\t\t\tint vv=v;\n\t\t\twhile(!marked[vv]){\n\t\t\t\tvv=orig[vv];\n\t\t\t}*/\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\t//assert(vv==nearest[v].second);\n\t\t\t/*\n\t\t\tif(vv!=nearest[v].second)\n\t\t\t{\n\t\t\t\tcout << endl;\n\t\t\t\tcout << i << \", \" << vv << \", \" << nearest[v].second << \", \" << ov << endl;\n\t\t\t\twhile (!marked[ov]){\n\t\t\t\t\tcout << ov << \", \" << level[ov] << endl;\n\t\t\t\t\tov=orig[ov];\n\t\t\t\t}\n\t\t\t\tcout << ov << level[ov] << endl;\n\t\t\t\treturn;\n\t\t\t}*/\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//marked[v]=true;\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        if(x!=0) return root(x)-n+1;\n        else     return 1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nclass UnionFind\n{\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n)\n  {\n    par.resize(n);\n    rank.resize(n);\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x)\n  {\n    if (par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main()\n{\n  while (cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for (int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for (int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    for (int i = 0; i < Q; ++i)\n      if (op[i] == 'M') M[v[i]] = true;\n\n    UnionFind uf(N);\n    vector<int> nearest(N);\n    for (int st = 0; st < N; ++st) {\n      if (!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while (que.size()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if (M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    lli res = 0;\n    for (int i = 0; i < Q; ++i) {\n      if (op[i] == 'Q') {\n        res += nearest[uf.find(v[i])] + 1;\n      } else {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout<< res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX -((1ll<<30)-1)\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return RMQ_MAX;\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tif(maxi>=0&&maxi<(ll)idx_rev.size())ret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N=2*1e5;\nconstexpr int Log=log2(MAX_N)+10;\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\tnex=rootpar[v];\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(;;){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int MAX = 110000;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n+2 ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n  bool mark[MAX];\n\n  while(cin >> n >> q ,n + q){\n    stack<P> st;\n    fill(mark,mark+MAX,false);\n    mark[1] = true;\n    long long sum = 0;\n    init(n);\n    rank[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      rank[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'M'){\n\tmark[num] = true;\n      }\n      st.push(P(ch,num));\n    }\n    for(int i = 2 ; i <= n ; i++){\n      if(!mark[i]) unite(rank[i],i);\n    }\n\n    while(!st.empty()){\n      P p = st.top(); st.pop();\n\n      if(p.first == 'Q'){\n\tsum += find(p.second)+1;\n      }\n      else{\n\tmark[p.second] = false;\n\tunite(par[p.second],p.second);\n      }\n    }\n      cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PII pair<int,int>\nusing namespace std;\nconst int MAXN = 100000;\nconst int INF = 1e9 + 5;\n\nstruct DSU {\n\tint pa[MAXN+5];\n\tint find_root(int x) {\n\t\treturn pa[x] == x ? x : pa[x] = find_root(pa[x]);\n\t}\n\tvoid merge(int x, int y) {\n\t\tx = find_root(x);\n\t\ty = find_root(y);\n\t\tif (x == y) return;\n\t\tpa[y] = x;\n\t}\n} dsu;\n\nint pa[MAXN+5], first[MAXN+5];\nvector<pair<char, int>> qs;\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint N, Q;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfirst[i] = 1e9;\n\t\t}\n\t\t\n\t\tdsu.pa[1] = pa[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tcin >> pa[i];\n\t\t\tdsu.pa[i] = pa[i];\n\t\t}\n\t\t\n\t\tqs.resize(Q);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tint v;\n\t\t\tchar c;\n\t\t\tcin >> c >> v;\n\t\t\tqs[i] = {c, v};\n\t\t\tif (c == 'M') {\n\t\t\t\tdsu.pa[v] = v;\n\t\t\t\tfirst[v] = min(first[v], i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long ans = 0;\n\t\tfor (int q = Q - 1; q >= 0; q--) {\n\t\t\tchar c = qs[q].first;\n\t\t\tint v = qs[q].second;\n\t\t\tif (c == 'Q') {\n\t\t\t\tans += dsu.find_root(v);\n\t\t\t}\n\t\t\telse if (q == first[v]) {\n\t\t\t\tdsu.merge(pa[v], v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << \"\\n\";\n\t}\n\t\n\t/**** Note MAXN ****/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nint par[100001], e[100001], v[100000];\nchar op[100000];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    par[find(x)] = find(y);\n}\n\nint main(void) {\n    int i, n, q;\n    for (;;) {\n        scanf(\"%d%d\",&n,&q);\n        if (n == 0 && q == 0) return 0;\n        e[1] = 1;\n        REP (i,2,n) scanf(\"%d\\n\",&e[i]);\n        REP (i,1,n) par[i] = e[i];\n        REP (i,q) {\n            scanf(\"%c%d\\n\",&op[i],&v[i]);\n            if (op[i] == 'M') par[v[i]] = v[i];\n        }\n        ll ans = 0;\n        RREP (i,q) {\n            if (op[i] == 'M')\n                unite(v[i],e[v[i]]);\n            else\n                ans += find(v[i]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\nvector <ll> par;\nvector <bool> ism;\n\n//find marked root (keiroasshuku at the same time)\nint root(int x){\n\tif (ism[x]) return x;\n\telse return par[x] = root(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += root(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    while (1) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        int mark[N+1];\n        mark[1] = 1; \n\n        int tree[N+1];\n        tree[1] = 0;\n        for (int i=2; i<=N; ++i) {\n            cin >> tree[i];\n        } \n\n        long long sum = 0;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            if (ope == 'Q') {\n                for (int j=v; j>=1; j=tree[j]) {\n                    if (mark[j] == 1) {\n                        sum += j;\n                        break;\n                    }\n                }\n            } else if (ope == 'M') {\n                mark[v] = 1;\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\nint query(int i)\n{\n\tint par = tree[i];\n\twhile(!ar[par])\n\t\tpar = tree[par];\n\treturn par;\n}\nint main()\n{\n\tint n,q,par;\n\twhile(scanf(\"%d%d\",&n,&q)==2&&(n+q)!=0)\n\t{\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&par);\n\t\t\ttree[i] = par;\n\t\t}\n\t\tgetchar();\n\t\tchar cmd;\n\t\tint a;\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t{\n\t\t\tscanf(\"%c%d\",&cmd,&a);getchar();\n\t\t\tif(cmd=='M')ar[a] = true;\n\t\t\tif(cmd=='Q')sum += query(a);\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint segtree[262144];\nvoid update(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return ;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]=max(segtree[e],f);\n\t\treturn;\n\t}\n\tupdate(a,(a+b)/2,c,d,e*2,f);\n\tupdate((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint query(int a){\n\ta+=131072;\n\tint ret=0;\n\twhile(a){\n\t\tret=max(ret,segtree[a]);\n\t\ta/=2;\n\t}\n\treturn ret;\n}\nvector<int> g[100000];\nint L[100000];\nint R[100000];\nint Z[100000];\nint val;\nvoid dfs(int a){\n\tL[a]=val++;\n\tfor(int i=0;i<g[a].size();i++)\n\t\tdfs(g[a][i]);\n\tR[a]=val-1;\n}\nchar str[2];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tval=0;\n\t\tfor(int i=0;i<262144;i++)segtree[i]=1;\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tfor(int i=1;i<a;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tc--;\n\t\t\tg[c].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tfor(int i=0;i<a;i++)Z[L[i]]=i;\n\t\tlong long ret=0LL;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint d;\n\t\t\tscanf(\"%s%d\",str,&d);\n\t\t\td--;\n\t\t\tif(str[0]=='M'){\n\t\t\t\tupdate(0,131071,L[d],R[d],1,d);\n\t\t\t}else{\n\t\t\t\tret+=Z[query(L[d])];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\n#define maxn 100000\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[maxn+5];\nint node[maxn + 5];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemset(node, 0, sizeof(node));\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tnode[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')node[a] = a;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (node[a] != a)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100000][2];\nchar q1[100000];\nint q2[100000];\n\nint queue(int x){\n//    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      res+=queue(q2[i]);\n    }else{\n      mark(q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=0;\n    }\n//    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n     // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w[2];\n\n\twhile(cin>>n>>q&&n){\n\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d\",&z);z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tscanf(\"%s%d\",w,&z);z--;\n\n\t\tif(w[0]=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\telse{\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        if(x!=0) return root(x)-n+1;\n        else     return 0;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\nint dat[2*MAX_SEG];\n\nclass segment{\npublic:\n    int n;\n    void init(int n_){\n        for(int i=0;i<2*MAX_SEG-1;++i)dat[i]=0;\n\n    }\n    void update(int a,int b,int x,int k=0,int l=0,int r=MAX_SEG){\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            dat[k]=max(dat[k],x);\n            return;\n        }\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n    int query(int k){\n        k+=MAX_SEG-1;\n        int ret=dat[k];\n        while(k){\n            k=(k-1)/2;\n            ret=max(ret,dat[k]);\n        }\n        return ret;\n    }\n};\n\nint N,M;\nvector<int> g[MAX_N+5];\nint depth[MAX_N+5];\nint par[20][MAX_N];\nint tin[2*MAX_N+5],tout[2*MAX_N+5];\nint k=0;\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    tin[v]=k++;\n    for(int u=0;u<g[v].size();++u){\n        dfs(g[v][u],v,d+1);\n        k++;\n    }\n    tout[v]=k;\n}\n\nvoid fill_table(){\n    for(int i=0;i<19;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        int ans=0;\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        for(int i=0;i<N;++i)g[i].clear();\n        memset(par,0,sizeof(par));\n        for(int i=1;i<N;++i){\n            int p;\n            cin>>p;\n            p--;\n            g[p].PB(i);\n        }\n        k=0;\n        dfs(0,-1,0);\n        fill_table();\n        segment seg;\n        seg.init(N);\n        for(int t=0;t<M;++t){\n            char que;\n            int v;\n            cin>>que;\n            cin>>v;\n            v--;\n            //cout<<tin[v]<<\" \"<<tout[v]<<\" \"<<depth[v]<<endl;\n            if(que=='M'){\n                seg.update(tin[v],tout[v],depth[v]);\n            }\n            else{\n                int q=seg.query(tout[v]);\n                for(int i=19;i>=0;--i){\n                    if((depth[v]-q)>>i&1)v=par[i][v];\n                }\n                ans+=v+1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> children[100010];\npriority_queue<int> query[100010];\nint markedAt[100010];\nusing ll = long long;\n\nll pull(int v) {\n    ll res = 0;\n    for (int c : children[v]) {\n        res += pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            int u = query[c].top();\n            if (u > markedAt[v]) {\n                res += u + 1;\n                query[v].push(u);\n            }\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        res += v + 1;\n        query[v].pop();\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(markedAt, markedAt + n, 1e9);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        cout << pull(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tint OrigT[N+1];\n\t\tT[1] = OrigT[1] = 1;\n\t\tfor(int i=2; i<=N; i++){ cin >> T[i]; OrigT[i] = T[i]; }\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(OrigT[v], T); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T){\n\tif(v==1) return 0;\n\tint ans = v;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\ntypedef pair<char,int> P;\nP query[maxn];\nint get(int i)\n{\n\tint par = tree[i];\n\twhile(!ar[par])\n\t\tpar = tree[par];\n\treturn par;\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)==2&&(n+q)!=0)\n\t{\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = true;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nchar ch[MAX_Q+1];\nint num[MAX_Q+1];\nint N, Q;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(int i=1; i<=N; i++) scanf(\"%d\", &par[i]);\n        for(int i=1; i<=Q; i++) scanf(\" %c %d\", &ch[i], &num[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n            if(ch[i]=='M'){\n                vis[num[i]]=1;\n            }\n            else if(ch[i]=='Q'){\n                int cur=num[i];\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<bool, int> bi;\nint T[100000];\nbool marked[100000];\nint N;\nint dfs(int v){\n    int p = T[v];\n    if(marked[p])\n      return p;\n    else\n      return dfs(p);\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int Q, _t;\n    char _c;\n    while(cin >> N >> Q && N){\n        vector<bi> query;\n        memset(marked, 0, sizeof(marked));\n        REP(i, 1, N){\n            cin >> _t; _t--;\n            T[i] = _t;\n        }\n        marked[0] = true;\n        int sum = 0;\n        rep(i, Q){\n            cin >> _c >> _t; _t--;\n            if(_c == 'Q')\n              sum += dfs(_t) + 1;\n            else\n              marked[_t] = true;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\n\nstruct UnionFind {\nprivate:\n\tvector< int > data;\n\t\npublic:\n\tUnionFind(int _size) : data(_size, -1) {}\n\t\n\tbool unite(int _x, int _y) {\n\t\t_x = root(_x); _y = root(_y);\n\t\tif (_x != _y) data[_x] += data[_y]; data[_y] = _x;\n\t\treturn _x != _y;\n\t}\n\t\n\tbool same(int _x, int _y) { return root(_x) == root(_y); }\n\t\n\tint root(int _x) { return data[_x] < 0 ? _x : data[_x] = root(data[_x]); }\n\t\n\tint size(int _x) { return -data[root(_x)]; }\n};\n\nint N, Q, p[100010];\nchar q[100010];\nint mark[100010], v[100010];\nlint anc[100010];\n\nvoid solve() {\n\tUnionFind uf(N+1);\n\t\n\tfor_(i,0,N) if (!mark[i]) uf.unite(p[i], i);\n\t\n\tlint ans = 0;\n\t\n\tfor_rev(i,Q-1,0) {\n\t\tif (q[i] == 'M') {\n\t\t\t--mark[ v[i] ];\n\t\t\tif (!mark[ v[i] ]) uf.unite(p[ v[i] ], v[i]);\n\t\t} else {\n\t\t\tans += uf.root(v[i]);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tfor_(i,2,N+1) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\t\n\t\tminit(mark, 0);\n\t\tmark[1] = 1;\n\t\t\n\t\tfor_(i,0,Q) {\n\t\t\tscanf(\"%s %d\", &q[i], &v[i]);\n\t\t\tif (q[i] == 'M') ++mark[ v[i] ];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1<<28;\n\n\nint Find(int p, vec& par) {\n    if (p == par[p]) return (p);\n    return (par[p] = Find(par[p], par));\n}\n\nvoid Merge(int x, int y, vec& par) {\n    x = Find(x, par), y = Find(y, par);\n    if (x != y) {\n        par[x] = y;\n    }\n}\n\nvoid dfs(int now, int p, vec& par, mat& T, vec& MarkedTime) {\n    if (MarkedTime[now] != MarkedTime[p] && MarkedTime[now] != INF) return ;\n    par[now] = p;\n    for (int i = 0; i < T[now].size(); i++) {\n        dfs(T[now][i], p, par, T, MarkedTime);\n    }\n}\n\nvoid solve(int N, int Q) {\n    mat T(N+1);\n    vec Tr(N+1);\n    Tr[1] = 1;\n    for (int i = 2; i <= N; i++) {\n        int v; cin >> v;\n        T[v].push_back(i);\n        Tr[i] = v;\n    }\n\n    vec MarkedTime(N+1, INF);\n    vec TimeToMarkedVertex(Q+1);\n    vec QueryTimeToVertex(Q+1);\n    MarkedTime[1] = -1;\n    for (int i = 0; i < Q; i++) {\n        char q;\n        int v;\n        cin >> q >> v;\n        if (q == 'M') MarkedTime[v] = min(MarkedTime[v], i), TimeToMarkedVertex[i] = v;\n        else QueryTimeToVertex[i] = v;\n    }\n\n    vec par(N+1);\n    for (int i = 1; i <= N; i++) par[i] = i;\n    for (int i = 1; i <= N; i++) {\n        if (MarkedTime[i] == INF) continue;\n        dfs(i, i, par, T, MarkedTime);\n    }\n\n    long long int cost = 0LL;\n    for (int i = Q - 1; i > -1; i--) {\n        if (QueryTimeToVertex[i] > 0) cost += Find(par[QueryTimeToVertex[i]], par);\n        else Merge(TimeToMarkedVertex[i], Tr[TimeToMarkedVertex[i]], par);\n    }\n\n    cout << cost << endl;\n}\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N || Q) solve(N, Q);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define M 100005\nint n,q;\nbool mark[M];\nstruct node {\n\tint tp,u;\n} Q[M];\nlong long ans;\nstruct together {\n\tint fa,sum;\n} A[M];\nint Find(int x) {\n\tif(mark[A[x].sum])return A[x].fa;\n\tint f=A[x].fa;\n\tA[x].fa=Find(f);\n\tA[x].sum=A[f].sum;\n\treturn A[x].fa;\n}\nint main() {\n\tint x,u;\n\tchar op[5];/*\n\twhile(scanf(\"%d %d\",&n,&q),n||q) {\n\t\tA[1].fa=1,A[1].sum=1;\n\t\tmark[1]=1;\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tscanf(\"%d\",&x);\n\t\t\tA[i].fa=x;\n\t\t\tA[i].sum=0;\n\t\t\tmark[i]=0;\n\t\t}\n\t\tfor(int i=1; i<=q; i++) {\n\t\t\tscanf(\"%s %d\",op,&Q[i].u);\n\t\t\tif(op[0]=='M') {\n\t\t\t\tQ[i].tp=1;\n\t\t\t\tmark[Q[i].u]=1;\n\t\t\t\tA[Q[i].u].sum=Q[i].u;\n\t\t\t} else Q[i].tp=2;\n\t\t}\n\t\tans=0;\n\t\tfor(int i=q; i>=1; i--) {\n\t\t\t//printf(\"id=%d\\n\",i);\n\t\t\tif(Q[i].tp==1) {\n\t\t\t\tmark[Q[i].u]=0;\n\t\t\t\tmark[1]=1;\n\t\t\t} else {\n\t\t\t\tFind(Q[i].u);\n\t\t\t\tans+=A[Q[i].u].sum;\n\t\t\t\t//printf(\"sum=%d\\n\",A[Q[i].u].sum);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nclass UnionFind\n{\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n)\n  {\n    par.resize(n);\n    rank.resize(n);\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x)\n  {\n    if (par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main()\n{\n  while (cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for (int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for (int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    M[0] = 1;\n    for (int i = 0; i < Q; ++i)\n      if (op[i] == 'M') M[v[i]] = true;\n\n    UnionFind uf(N);\n    vector<int> nearest(N);\n    for (int st = 0; st < N; ++st) {\n      if (!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while (que.size()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if (M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    lli res = 0;\n    for (int i = 0; i < Q; ++i) {\n      if (op[i] == 'Q') {\n        res += nearest[uf.find(v[i])] + 1;\n      } else {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout<< res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\toperationM(1);\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tif (arr[_index].isMarked == true)return;\n\t\tarr[_index].isMarked = true;\n\t\tarr[_index].nearest_index = _index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tif (arr[itr].isMarked == false)updateNearest(itr, _index);\n\t\t}\n\t}\n\tvoid updateNearest(int _index,int _nearest_index)\n\t{\n\t\tarr[_index].nearest_index = _nearest_index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tif (arr[itr].isMarked == false)updateNearest(itr, _nearest_index);\n\t\t}\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.resize(N), ism.resize(N), nma.resize(N);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear(), nma.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n) {\n    par.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main() {\n  while(cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for(int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for(int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    for(int i = 0; i < Q; ++i) {\n      if(op[i] != 'M') continue;\n      M[v[i]] = true;\n    }\n\n    UnionFind uf(N);\n    vector<int> nearest(N);\n    for(int st = 0; st < N; ++st) {\n      if(!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while(que.size()) {\n        int v = que.front();\n        que.pop();\n        for(int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if(M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    int res = 0;\n    for(int i = 0; i < Q; ++i) {\n      if(op[i] == 'Q') {\n        res += nearest[uf.find(v[i])] + 1;\n      } else {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, q;\nll ans = 0;\nint par[100000];\n\nint init(int x){\n\trep(i,n){\n\t\tpar[i] = i;\n\t}\n}\n\nvoid find(int x){\n\tif(x == par[x]){\n\t\tans += x+1;\n\t\treturn;\n\t}\n\tfind(par[x]);\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &q);\n\t\tif(n == 0 && q == 0) break;\n\t\tinit(n);\n\t\tans = 0;\n\t\tchar a; int b;\n\t\trep(i,n-1){\n\t\t\tint temp; scanf(\"%d\", &temp);\n\t\t\tpar[i+1] = temp-1;\n\t\t}\n\t\trep(i,q){\n\t\t\tscanf(\" %c%d\", &a, &b);\n\t\t\tb--;\n\t\t\tif(a == 'M'){\n\t\t\t\tpar[b] = b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfind(b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nconst int MAXN = 100000 + 10;\nint par[MAXN], rank[MAXN], near[MAXN];\nbool mark[MAXN];\nint Find(int x){\n\tif (x == par[x])\n\t\treturn 1;\n\telse if (mark[par[x]])\n\t\treturn par[x];\n\telse\n\t\treturn Find(par[x]);\n}\nint main(){\n\tint n, q;\n\tint sum = 0;\n\tchar ins[10];\n\tint v, x;\n\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 1; i <= n; i++){\n\t\tpar[i] = 1;\n\t}\n\tmark[1] = 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &x);\n\t\tpar[i] = x;\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%s%d\", ins, &v);\n\t\tif (strcmp(ins, \"0\") == 0 && v == 0)\n\t\t\tbreak;\n\t\tif (strcmp(ins, \"M\") == 0){\n\t\t\tmark[v] = 1;\n\t\t}\n\t\telse{\n\t\t\tsum += Find(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tint OrigT[N+1];\n\t\tT[1] = OrigT[1] = 1;\n\t\tfor(int i=2; i<=N; i++){ cin >> T[i]; OrigT[i] = T[i]; }\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(OrigT[v], T); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T){\n\tif(!v) return 0;\n\tint ans = v;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    //if(n == 0)\n//\tint m = 1;\n    \n    if(flag[t[n]] == 1)\n    {\n\treturn t[n];\t    \n    }\n\n    else\n    {\t\n\treturn t[n] = find(t[n]);    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n#ifndef ONLINE_JUDGE\n    READ;\n#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 1;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]] = 1;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M' ) flag[idx[i]] = 0;\n\t    else ret = ret + find(idx[i]);\n\t    //std::cout<<idx[i]<<std::endl;\n\t    //if(idx[i] == 0)\n\t    //int m = 1;\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n\n    if (rx < ry) par[ry] = rx;\n    else if (rx > ry) par[rx] = ry;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nvoid dfs(int idx, int par) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(idx, par);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par);\n  }\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  marked = vector<bool>(N);\n  marked[0] = true;\n  for (int i = 0; i < queries.size(); i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  tree = UnionFindTree(N);\n  dfs(0, -1);\n\n  int res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(x, parent[x]);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    int ans = solve(N, Q, parent, queries);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n#include<iostream>\n#include<cmath>\n\nint main() {\n\twhile(true){\n\t\tint n, q; std::cin >> n >> q; if (n == 0 && q == 0) break;\n\t\tstd::vector<std::vector<int>> children(n);\n\t\tstd::vector<int> parent(n, -1), marked_ancestor(n, 0);\n\t\tfor (auto i = 1; i < n; ++i) {\n\t\t\tint a; std::cin >> a;\n\t\t\tparent[i] = marked_ancestor[i] = --a;\n\t\t\tchildren[a].push_back(i);\n\t\t}\n\t\tstd::vector<std::pair<bool, int>> queries;\n\t\tfor (auto i = 0; i < q; ++i) {\n\t\t\tint node;\n\t\t\tstd::string str; std::cin >> str >> node; --node;\n\t\t\tif (str == \"M\") {\n\t\t\t\tif (marked_ancestor[node] != node && node != 0) {\n\t\t\t\t\tmarked_ancestor[node] = node;\n\t\t\t\t\tqueries.emplace_back(false, node);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueries.emplace_back(true, node);\n\t\t\t}\n\t\t}\n\t\tstd::reverse(queries.begin(), queries.end());\n\t\tlong long int result = 0;\n\t\tfor (const auto p : queries) {\n\t\t\tif (p.first) {\n\t\t\t\tint current = p.second;\n\t\t\t\twhile (marked_ancestor[current] != current) {\n\t\t\t\t\tcurrent = marked_ancestor[current];\n\t\t\t\t}\n\t\t\t\tconst auto root = current;\n\t\t\t\tcurrent = p.second;\n\t\t\t\twhile (current != root) {\n\t\t\t\t\tauto temp = current;\n\t\t\t\t\tcurrent = marked_ancestor[current];\n\t\t\t\t\tmarked_ancestor[temp] = root;\n\t\t\t\t}\n\t\t\t\tresult += root + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmarked_ancestor[p.second] = parent[p.second];\n\t\t\t}\n\t\t}\n\t\tstd::cout << result << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX_N = 1 << 18;\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=0,dat[i].second=0;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n    dat[k]=max(dat[k],p);\n  }else{\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  }\n}\n\nvector<int> G[MAX_N];\nint st[MAX_N],en[MAX_N],de[MAX_N],po[MAX_N];\nint pos;\nvoid dfs(int v,int p=-1,int d=0){\n  de[v]=d;\n  po[v]=pos;\n  st[v]=pos++;\n  for(auto i:G[v]) if(i!=p) dfs(i,v,d+1);\n  en[v]=pos;\n}\n\nvoid update(int k,P p){\n  update(st[k],en[k],p);\n}\n\nsigned main(){\n  int _n,q;\n  while(cin>>_n>>q,_n||q){\n    for(int i=0;i<MAX_N;i++) G[i].clear();\n    init(_n+1);\n    for(int i=1;i<_n;i++) {\n      int p;\n      cin>>p;\n      p--;\n      G[p].push_back(i);\n      G[i].push_back(p);\n    }\n    pos=0;dfs(0);\n    int ans=0;\n    for(int i=0;i<q;i++){\n      char c;\n      int u;\n      cin>>c>>u;\n      u--;\n      if(c=='M') update(u,P(de[u],u));\n      else ans+=query(po[u])+1;\n      //for(int j=0;j<_n;j++) cout<<query(po[j])<<\" \\n\"[j==_n-1];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int maxn =100000+10;\nint n,q;\nint par[maxn];\nbool mark[maxn];\n\nint find(int x){\n    if(mark[x]){\n        return x;\n    }\n    else{\n        return find(par[x]);\n    }\n}\n\nint main(){\n    while(scanf(\"%d%d\",&n,&q)!=EOF){\n        if(n==0&&q==0) break;\n        for(int i=2;i<=n;i++){\n            int p;\n            scanf(\"%d\",&p);\n            par[i]=p;\n        }\n\n        memset(mark,0,sizeof(mark));\n        mark[1]=1;\n\n        LL sum=0;\n        for(int i=0;i<q;i++){\n            char op;\n            int v;\n            cin>>op>>v;\n            if(op=='M'){\n                mark[v]=1;\n            }\n            else{\n                sum+=find(v);\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tset<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tif(lca.getDepth(v) - lca.getDepth(*u) == d)\n\t\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.insert(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, int>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), *u);\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tpii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v] < c) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tc.first ++;\n\t\t\t\t\tFOR(e, g[v]){\n\t\t\t\t\t\tif(chmin(res[e->first], c))\n\t\t\t\t\t\t\tque.emplace(c, e->first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint N,Q;\nint pa[100000];\npair<char,int> que[100000];\nvector<int> ch[100000];\nbool mark[100000];\nint qpa[100000];\n\nint find(int x){\n  if(mark[x]) return x;\n  return\n    qpa[x]=find(qpa[x]);\n}\n\nvoid solve(){\n  CLR(mark);\n  rep(i,N) ch[i].clear();\n  rep(i,N-1) {\n    cin >> pa[i+1];\n    --pa[i+1];\n    ch[pa[i+1]].pb(i+1);\n  }\n\n  rep(i,Q){\n    cin >> que[i].F >> que[i].S;\n    --que[i].S;\n    if(que[i].F=='M') mark[que[i].S]=1;\n  }\n  mark[0]=1;\n  reverse(que,que+Q);\n  queue<PI> q;\n  q.push(mp(0,0));\n  while(!q.empty()){\n    int cv=q.front().F;\n    int ma=q.front().S;\n    q.pop();\n    qpa[cv]=ma;\n    cout << cv << ' ' << ma << endl;\n    FOR(it,ch[cv]) q.push(mp(*it,mark[cv]?cv:ma));\n  }\n  \n  ll ans=0;\n  rep(i,Q){\n    if(que[i].F=='Q'){\n      //cout << find(pa[que[i].S])+1 << endl;\n      ans += find(pa[que[i].S])+1;\n    }else{\n      mark[que[i].S]=0;\n      //qpa[que[i].S]=qpa[pa[que[i].S]];\n    }\n  }\n  \n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> Q && N) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\nclass unionfind {\n    public:\n    int n;\n    vector<int> par;\n    unionfind(int m) {\n        n = m;\n        par.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int find(int x) { return par[x] == x ? x : (par[x] = find(par[x])); }\n    int isunion(int x, int y) { return find(x) == find(y); }\n    int tounion(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return 0;\n        par[q] = p;\n        return 1;\n    }\n};\n\nint main() {\n    while (1) {\n        int n, q;\n        cin >> n >> q;\n        if (!n) return 0;\n\n        vector<int> par(n);\n        for (int i = 1; i < n; ++i) {\n            cin >> par[i];\n            --par[i];\n        }\n        vector<pair<char, int>> inp(q);\n        vector<int> cnt(n, 0);\n        for (int i = q - 1; i >= 0; --i) {\n            cin >> inp[i].first >> inp[i].second;\n            --inp[i].second;\n            if (inp[i].first == 'M')\n                ++cnt[inp[i].second];\n        }\n        unionfind uf(n);\n        for (int i = 1; i < n; ++i)\n            if (!cnt[i])\n                uf.tounion(par[i], i);\n\n        long long sum = 0;\n        for (auto i : inp) {\n            if (i.first == 'M' && !--cnt[i.second])\n                uf.tounion(par[i.second], i.second);\n            else if (i.first == 'Q')\n                sum += uf.find(i.second) + 1;\n        }\n        cout << sum << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\nusing namespace std;\n#define scai(x) scanf(\"%d\", &x)\n#define scac(x) scanf(\"%c\", &x)\n#define sca2i(x, y) scanf(\"%d %d\", &x, &y)\n#define sca2f(x, y) scanf(\"%lf %lf\", &x, &y)\n#define pri(x) printf(\"%d\", x)\n#define prc(x) printf(\"%c\", x)\n#define pri2(x,y) printf(\"%d %d\", x, y);\n#define prif(x) printf(\"%lf\", x)\n#define prif2(x, y) printf(\"%lf %lf\", x, y)\n#define mset(x, y) memset(x, y, sizeof(x))\n#define fori(i, x, y) for(int i = x; i < y; i++)\n#define pii pair<int, int>\n#define pic pair<int, char>\n#define pdd pair<double, double>\ntypedef long long ll;\n#define INF 0x3f3f3f3f\n\nconst int MAX_N = 1e5 + 10;\nint N, Q;\n\n\nint par[MAX_N];\nbool Marked[MAX_N];\n\nll Find(int x)\n{\n    if(Marked[x])\n        return x;\n    return Find(par[x]);\n}\nvoid init()\n{\n    for (int i = 1; i <= N; i++)\n    {\n        par[i] = i;\n        Marked[i] = false;\n    }\n    Marked[1] = true;\n    return ;\n}\n\nvoid solve()\n{\n    while(sca2i(N, Q), N|Q){\n    init();\n\n    for(int i = 2; i <= N; i++)\n    {\n        scai(par[i]);\n    }\n    char op;\n    int n;\n    getchar();\n    ll sum = 0;\n    while(Q--)\n    {\n\n        scanf(\"%c %d\", &op, &n);\n        getchar();\n        if(op == '0') break;\n\n        /*cout << \"op n : \";\n        cout << op << \" \" << n << endl;*/\n        if(op == 'M')\n        {\n            Marked[n] = true;\n        }\n        else if(op == 'Q')\n        {\n            sum += Find(n);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n    }\n    //system(\"pause\");\n    return ;\n}\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    for(int j = 0;j <= 4;j++){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\tr[0] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct UF {\n    int *par;\n    UF(int n) {\n        par=new int[n];\n        for(int i=0;i<n;i++) {\n            par[i]=i;\n        }\n    }\n    int find(int x) {\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void unite(int x,int y) {\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        par[x]=y;\n    }\n    bool same(int x,int y) {\n        return find(x)==find(y);\n    }\n};\nbool marked[100000];\nchar op[100000][2];\nint v[100000];\nint par[100000];\nint main() {\n    int N,Q;\n    while(scanf(\"%d %d\",&N,&Q),N) {\n        par[0]=-1;\n        for(int i=1;i<N;i++) {\n            scanf(\"%d\",&par[i]);par[i]--;\n        }\n        fill(marked,marked+100000,0);\n        marked[0]=1;\n        for(int i=0;i<Q;i++) {\n            scanf(\"%s %d\",op[i],&v[i]);v[i]--;\n            if(op[i][0]=='M') marked[v[i]]=1;\n        }\n        UF u(N);\n        for(int i=0;i<N;i++) {\n            if(!marked[i]) u.unite(i,par[i]);\n        }\n        long long ans=0;\n        for(int i=Q-1;i>=0;i--) {\n            if(op[i][0]=='M') {\n                if(v[i]!=0&&marked[v[i]]) {\n                    u.unite(v[i],par[v[i]]);\n                    marked[v[i]]=0;\n                }\n            }else {\n                ans+=u.find(v[i])+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int maxn = 100005;\nint par[maxn];\n\nint find(int x) {\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main() {\n\tfreopen(\"aoj2170.txt\", \"r\", stdin);\n\twhile (1) {\n\t\tint n, q;\n\t\tscanf(\"%d%d\", &n, &q);\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tpar[i+1] = t;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tchar c;\n\t\t\tint t;\n\t\t\tscanf(\"%c%d%*c\", &c, &t);\n\t\t\tif ('Q' == c) {\n\t\t\t\tres += find(t);\n\t\t\t} else {\n\t\t\t\tpar[t] = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int maxn=100010;\ntypedef struct p\n{\n\tint par,vis;\n}p;\np s[maxn];\nvoid init(int n){\n\tfor(int i=1;i<=n;i++){\n\t\ts[i].par=i;\n\t\ts[i].vis=0;\n\t}\n}\nint main()\n{\n    int n,q;\n\tcin>>n>>q;\n\tinit(n);\n\ts[1].vis=1;\n\tfor(int i=2;i<=n;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ts[i].par=x;\n\t}\n\tgetchar();\n\tint sum=0;\n\twhile(q--){\n\t\tchar sh;\n\t\tint a;\n\t\tscanf(\"%c%d%*c\",&sh,&a);\n\t\tif(sh=='M'){\n\t\t\ts[a].vis=1;\n\t\t}else{\n\t\t\twhile(true){\n\t\t\t\tif(s[a].vis==1){\n\t\t\t\t\tsum+=a;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\ta=s[a].par;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint w,y;\n\tscanf(\"%d%d\",&w,&y);\n\tcout<<sum<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define val first\n#define idx second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vp;\n\n//Segment Tree\nclass SegmentTree{\n  int n;\n  vp node;\npublic:\n  SegmentTree(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    node = vp(2*n, pii(0,0));\n  }\n\n  void update_range(int a,int b,pii v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return;\n    if(a<=l && r<=b){\n      if(node[k]<v)node[k] = v;\n      return;\n    }\n    update_range(a,b,v,2*k+1,l,(l+r)/2);\n    update_range(a,b,v,2*k+2,(l+r)/2,r);\n  }\n\n  pii is_val(int k){\n    k += n-1;\n    pii res = node[k];\n    while(k>0){\n      k = (k-1)/2;\n      res = max(res,node[k]);\n    }\n    return res;\n  }\n};\n\nvoid dfs(int v, int d, vi &level, vi &tour, vp &interval,\n\t const vector<vi> &tree){\n  interval[v].first = tour.size();\n  tour.push_back(v);\n  level[v] = d;\n\n  for(int child : tree[v]){\n    dfs(child, d+1, level, tour, interval, tree);\n  }\n\n  tour.push_back(v);\n  interval[v].second = tour.size();\n}\n\nint main(){\n  int n,q,v;\n  char qtype;\n\n  while(scanf(\"%d%d\",&n,&q),n){\n    vector<vi> tree(n,vi());\n\n    rep(i,n-1){\n      scanf(\"%d\",&v); v--;\n      tree[v].push_back(i+1);\n    }\n\n    vi level(n,0), tour;\n    vp interval(n);\n    dfs(0,0,level,tour,interval,tree);\n\n    SegmentTree st(tour.size());\n    st.update_range(0,2*n,pii(0,0));\n\n    long long ans = 0;\n    rep(i,q){\n      cin >> qtype >> v; v--;\n      if(qtype == 'M'){\n\tst.update_range(interval[v].first, interval[v].second, pii(level[v], v));\n      }else{\n\tans += st.is_val(interval[v].first).second + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _GLIBCXX_DEBUG\n\nint n, q;\nvector<int> P;\nvector<pair<char, int>> O;\nvector<int> go_to;\nvector<int> marked;\n\nvoid delete_mark(int v) {\n  marked[v]--;\n  if (!marked[v]) {\n    go_to[v] = go_to[P[v]];\n  }\n}\nint search_mark(int v) {\n  if (go_to[v] == v) {\n    return v;\n  }\n  return (go_to[v] = search_mark(go_to[v]));\n}\n\nint main() {\n  while (cin >> n >> q) {\n    if (!n && !q)\n      break;\n\n    P = vector<int>(n + 1);\n    go_to = vector<int>(n + 1);\n    marked = vector<int>(n + 1, 0);\n    O.clear();\n    P[1] = 1;\n    go_to[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      cin >> P[i];\n      go_to[i] = P[i];\n    }\n    for (int i = 0; i < q; i++) {\n      char ope;\n      int v;\n      cin >> ope >> v;\n      O.push_back(make_pair(ope, v));\n      if (ope == 'M') {\n        go_to[v] = v;\n        marked[v]++;\n      }\n    }\n\n    long long ans = 0;\n    for (int i = q - 1; i >= 0; i--) {\n      if (O[i].first == 'M') {\n        delete_mark(O[i].second);\n      } else {\n        ans += search_mark(O[i].second);\n      }\n    }\n\n    // bug:二回マークされているときを考えていなかった->markedに回数を保存\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (x == 1 || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<vector>\n#include<cstdio>\n#define MAXN 2555\n#define INF 0x3f3f3f3f\n#define v first\n#define b second\nusing namespace std;\nint p[100005];\nbool vis[100005];\nint sum;\nint Find(int x)\n{\n   if(p[x]==x)\n      return x;\n   else return p[x]=Find(p[x]);\n}\nvoid Find2(int x)\n{\n   if(vis[x])\n   {\n      sum+=x;\n      return ;\n   }\n   if(p[x]==x)\n      return ;\n   else Find2(p[x]);\n}\nvoid init(int n)\n{\n   memset(vis,false,sizeof(vis));\n   for(int i=1;i<=n;i++)\n      p[i]=i;\n}\nint main()\n{\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m)==2)\n   {\n      if(n==m&&n==0)\n         break;\n      init(n);\n      vis[1]=true;\n      for(int i=2;i<=n;i++)\n      {\n         int a;\n         scanf(\"%d\",&a);\n         int x=Find(i);\n         p[x]=a;\n      }\n      sum=0;\n      for(int i=0;i<m;i++)\n      {\n         char a[5];int b;\n         scanf(\"%s %d\",a,&b);\n         if(a[0]=='M') vis[b]=true;\n         if(a[0]=='Q')\n         Find2(b);\n      }\n      cout<<sum<<endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int MAX_N = 100005;\nint fa[MAX_N],n,q,t;\nvector<int> son[MAX_N];\nbool marked[MAX_N];\nvoid init()\n{\n\tmemset(marked, false, sizeof marked);\n\tfor(int i = 1; i <= n; i++)\n\t\tfa[i] = 1, son[i].clear();\n}\nvoid solve()\n{\n\tlong long ans = 0;\n\tchar op[2];\n\tmarked[1] = true;\n\t\n\twhile(q--)\n\t{\n\t\tscanf(\"%s %d\", op, &t);\n\t\tif(op[0] == 'Q') ans += (long long)fa[t];\n\t\telse\n\t\t{\n\t\t\tmarked[t] = true;\n\t\t\tqueue<int> q;\n\t\t\t\n\t\t\tint l = son[t].size();\n\t\t\tfor(int i = 0; i < l; i++)\n\t\t\t\tq.push(son[t][i]);\n\t\t\t\t\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tint k = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfa[k] = t;\n\t\t\t\t\n\t\t\t\tint l = son[k].size();\n\t\t\t\tfor(int i = 0; i < l; i++)\n\t\t\t\tif(!marked[k]) q.push(son[k][i]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%I64d\\n\", ans);\n}\nint main()\n{\n\twhile(~scanf(\"%d %d\", &n, &q) && (n || q))\n\t{\n\t\tinit();\n\t\tfor(int i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &t);\n\t\t\tson[t].push_back(i);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nint main(){\n  while(1){\n    vector<node> T;\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    T.push_back((node){true,0,1});\n    for(int i=2;i<=n;i++){\n      int parent;\n      cin >> parent;\n      T.push_back((node){false,parent-1,i});\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }else{\n        node n = T[v-1];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint pars[20][100000];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q;\n  cin >> N >> Q;\n\n  pars[0][0] = 0;\n  REP(i,N-1){\n\tint p;\n\tcin >> p;\n\t--p;\n\tpars[0][i+1] = p;\n  }\n\n  for(int i=1;i<20;++i)\n\tREP(u,N)\n\t  pars[i][u] = pars[i-1][pars[i-1][u]];\n  vector<bool> marked(N);\n  marked[0] = true;\n\n  LL ans = 0;\n  REP(q,Q){\n\tchar c;\n\tint pyon;\n\tcin >> c >> pyon;\n\t--pyon;\n\tif(c == 'M'){\n\t  while(!marked[pyon]){\n\t\tmarked[pyon] = true;\n\t\tpyon = pars[0][pyon];\n\t  }\n\t}\n\telse{\n\t  for(int i=19;i>=0;--i){\n\t\tif(!marked[pars[i][pyon]])\n\t\t  pyon = pars[i][pyon];\n\t  }\n\t  pyon = pars[0][pyon];\n\t  ans += pyon+1;\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<char,int> P;\n\nint N,Q;\nbool mark[100000];\nint tree[100000];\nP query[100000];\n\nint get(int i){\n  if(mark[i]) return i;\n  return tree[i]=get(tree[i]);\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c %d\",&query[i].first,&query[i].second);\n      query[i].second--;\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second]=1;\n      }\n    }\n\n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      if(query[i].first=='M'){\n        mark[query[i].second]=0;\n      }else{\n        c+=get(query[i].second)+1;\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n \nusing namespace std;\n \nint n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n \nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    else\n\tswap(y, root[x]);\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n \nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n \nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\troot[query[i].second] = query[i].second;\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\t\tfor(int i = 0;i < child[num].size();i++){\n\t\t\t\tunite(child[num][i], num);\n\t\t\t}\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }       \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nconst int MAXN = 100000 + 10;\nint par[MAXN];\nint Find(int x){\n\tif (x == par[x])\n\t\treturn par[x];\n\treturn Find(par[x]);\n}\nint main(){\n\tint n, q;\n\tchar ins[10];\n\tint v;\n\n\twhile (~scanf(\"%d%d\", &n, &q) && n && q){\n\t\tlong long sum = 0;\n\t\tpar[1] = 1;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%s%d\", ins, &v);\n\t\t\tif (strcmp(ins, \"M\") == 0){\n\t\t\t\tpar[v] = v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += Find(v);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tint ancestor[100000] = {}, ismarked[100000] = {};\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M' && !uf.issame(ancestor[outlog[i].second], outlog[i].second))uf.unite(ancestor[outlog[i].second], outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += uf.getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//for (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N=2*1e5;\nconstexpr int Log=log2(MAX_N)+10;\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r+3 && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(;;){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\nstruct Node {\n    int par;\n    vi cs;\n    Node(int p, vi const& cs) : par(p), cs(cs) {}\n    Node(){}\n};\n\nvi ansester;\nvi marked;\n\nvoid update(vector<Node> & g, int v, int a){\n    ansester[v] = a;\n    for(int c : g[v].cs){\n        if(!marked[c]) update(g,c,a);\n    }\n}\n\nint solve(vector<Node> g, vector<pair<char,int>> query){\n    ansester.assign(g.size()+1, 1);\n    marked.assign(g.size()+1, 0);\n    int ans = 0;\n    rep(i,query.size()){\n        char q; int v;\n        tie(q,v) = query[i];\n        if(q=='M'){\n            update(g,v,v);\n            marked[v] = true;\n        } else {\n            ans += ansester[v];\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    int N, Q;\n    while(cin>>N>>Q && N){\n        vector<Node> g(N+1);\n        rep(i,N-1){\n            int x; cin>>x;\n            g[i+2].par = x;\n            g[x].cs.eb(i+2);\n        }\n        vi ignore(N+1);\n        vector<pair<char,int>> query;\n        rep(i,Q){\n            char c; int v;\n            cin>>c>>v;\n            if(c=='M'){\n                if(!ignore[v]){\n                    query.eb(c,v);\n                    ignore[v] = true;\n                }\n            } else {\n                query.eb(c,v);\n            }\n        }\n        cout << solve(g,query) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nusing ll = long long ;\nusing P = pair<int,int> ;\nusing pll = pair<long long,long long>;\nconstexpr int INF = 1e9;\nconstexpr long long LINF = 1e17;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\n\n\nstruct Unionfind{\n    vector<int> parents;\n    int n;\n    Unionfind(int n):n(n),parents(n,-1){ }\n\n    int find(int x){\n        if(parents[x] < 0) return x;\n        else return parents[x] = find(parents[x]);\n    }\n\n    void unite(int x,int y){\n        x = find(x);\n        y = find(y);\n\n        if(x==y) return;\n        //if(parents[x] > parents[y]) swap(x,y);\n        parents[x] += parents[y];\n        parents[y] = x;\n    }  \n\n   int size(int x){\n       return -parents[find(x)];\n   }\n\n   bool same(int x,int y){\n       return find(x) == find(y);\n   }\n\n   vector<int> members(int x){\n       int root = find(x);\n       vector<int> member;\n       for(int i=0;i<n;i++){\n           if(find(i)==root){\n               member.push_back(i);\n           }\n       }\n      return member;\n  }\n\n  int group_cnt(){\n      int c = 0;\n      rep(i,n){\n          if(parents[i] < 0) ++c;\n      }\n      return c;\n  }\n};\n\n\nint main(){\n    while(1){\n        int n,q;\n        cin >> n >> q;\n        if(n == 0 && q == 0) break;\n        Unionfind uf(n);\n        vector<vector<int>> tree(n);\n        vector<int> p(n);\n        vector<int> mark(n);\n\n        for(int i=1;i<n;i++){\n            int a;\n            cin >> a;\n            --a;\n            tree[a].push_back(i);\n            tree[i].push_back(a);\n            p[i] = a;\n        }\n\n        vector<pair<char,int>> query(q);\n        rep(i,q){\n            cin >> query[i].first >> query[i].second;\n            --query[i].second;\n            if(query[i].first == 'M') mark[query[i].second] ++;\n        }\n        stack<int> before;\n\n        function<void(int,int,int)> dfs = [&](int i,int par,int m){\n\n            if(mark[i] > 0){\n                before.push(m);\n                m = i;\n            }else{\n                uf.unite(m,i);\n            }\n\n            for(int c:tree[i]){\n                if(c == par) continue;\n                dfs(c,i,m);\n            }\n\n            if(mark[i] > 0){\n                m = before.top();\n                before.pop();\n            }\n        };\n\n        /*\n        rep(i,n) cout << p[i] << \" \" ;\n        cout << endl;\n        */\n\n        dfs(0,-1,0);\n\n        ll ans = 0LL;\n\n        for(int i=q-1;i>=0;i--){\n            if(query[i].first == 'M'){\n                mark[query[i].second] --;\n                if(mark[query[i].second]==0) uf.unite(p[query[i].second],query[i].second);\n                //cout << query[i].second << \" \" << p[query[i].second] << endl;\n            }else{\n                ans += (ll)(uf.find(query[i].second) + 1);\n                //cout << uf.find(query[i].second) << endl;\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)K[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]] = 1;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M' && K[i] != 1)UF.unite(a[K[i]], K[i]);\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\tsum += D; break;\n\t\t\t\t\t}\n\t\t\t\t\tD = a[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)&&(q+n)!=0){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] = true;;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = false;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\", ans);\n}\n  \nint main()\n{\n    Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <cassert>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\n//int orig[NN];\nvector<int> child[20][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\n//bool marked[NN];\nvoid setLevel(int i, int n)\n{\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tif (!scanf(\"%d%d\",&N,&Q))\n\t{\n\t\texit(0);\n\t}\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t\tchild[1][i].clear();\n\t\tparent[0][i]=0;\n\t\tparent[1][i]=0;\n\t\tlevel[i]=0;\n\t\tnearest[i]=P(0,0);\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\t//orig[i]=p;\n\t\t//marked[i]=false;\n\t\tchild[0][p].push_back(i);\n\t}\n\t//marked[1]=true;\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\n\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n//*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif((level[i]%step)==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step){\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}//*/\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}//*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tLL sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\t//cout << \"zzz \" << endl;\n\t\t//int ov=v;\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\t/*\n\t\t\tint vv=v;\n\t\t\twhile(!marked[vv]){\n\t\t\t\tvv=orig[vv];\n\t\t\t}*/\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\t//assert(vv==nearest[v].second);\n\t\t\t/*\n\t\t\tif(vv!=nearest[v].second)\n\t\t\t{\n\t\t\t\tcout << endl;\n\t\t\t\tcout << i << \", \" << vv << \", \" << nearest[v].second << \", \" << ov << endl;\n\t\t\t\twhile (!marked[ov]){\n\t\t\t\t\tcout << ov << \", \" << level[ov] << endl;\n\t\t\t\t\tov=orig[ov];\n\t\t\t\t}\n\t\t\t\tcout << ov << level[ov] << endl;\n\t\t\t\treturn;\n\t\t\t}*/\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//marked[v]=true;\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\nconst int B = 450;\n\nint N, Q;\nstd::vector<int> G[100100];\nint start[100100], friends[100100];\nint buckets[450], parts[200200];\nint doubling[17][100100];\n\nvoid makeDoubling(){\n    for(int i=0;i+1<=16;++i){\n        for(int j=1;j<=N;++j){\n            if(doubling[i][j] == -1){\n                doubling[i+1][j] = -1;\n            }else{\n                doubling[i+1][j] = doubling[i][doubling[i][j]];\n            }\n        }\n    }\n}\n\nvoid dfs(int v, int& n){\n    start[v] = n++;\n    \n    for(int u : G[v]){\n        dfs(u, n);\n    }\n\n    friends[v] = n++;\n}\n\nvoid update(int l, int r){\n    while(l % B > 0){\n        ++parts[l];\n        ++l;\n    }\n\n    while(r % B > 0){\n        --r;\n        ++parts[r];\n    }\n\n    l /= B;\n    r /= B;\n\n    while(l < r){\n        ++buckets[l];\n        ++l;\n    }\n}\n\ninline int query2(int v){\n    return buckets[start[v] / B] + parts[start[v]];\n}\n\nint query(int v){\n    int lb = 0, ub = 100100, res = v;\n\n    while(std::abs(ub - lb) > 1){\n        int mid = (lb + ub) / 2;\n        int x = v, y = mid, z = 0;\n\n        while(y > 0){\n            if(x != -1 && y % 2 == 1){\n                x = doubling[z][x];\n            }\n            ++z;\n            y >>= 1;\n        }\n        \n        if(x != -1 && query2(x) == query2(v)){\n            lb = mid;\n            res = x;\n        }else{\n            ub = mid;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> N >> Q;\n        if(N == 0){return 0;}\n\n        memset(doubling[0], -1, sizeof(doubling[0]));\n\n        for(int i=1;i<=N;++i){\n            G[i].clear();\n        }\n        \n        for(int i=0;i<N-1;++i){\n            int p;\n            std::cin >> p;\n\n            G[p].emplace_back(i+2);\n            doubling[0][i+2] = p;\n        }\n\n        makeDoubling();\n\n        // for(int i=0;i<16;++i){\n        //     printf(\"# %d\\n\", i);\n        //     for(int j=1;j<=N;++j){\n        //         printf(\"%d\\n\", doubling[i][j]);            \n        //     }\n        // }\n    \n        int ET_N = 0;\n        dfs(1, ET_N);\n\n        memset(buckets, 0, sizeof(buckets));\n        memset(parts, 0, sizeof(parts));\n        \n        update(start[1], friends[1]);\n    \n        // {\n        // int v = 3;\n        // update(start[v], friends[v]);\n        // }    \n        // for(int v = 1;v<=N;++v){\n        //     int q = query(v);\n        //     printf(\"%d\\n\", q);\n        // }\n        // exit(0);\n\n        ll sum = 0;\n        for(int i=0;i<Q;++i){\n            std::string q;\n            int v;\n            std::cin >> q >> v;\n\n            if(q[0] == 'M'){\n                update(start[v], friends[v]);\n            }else{\n                sum += query(v);\n                // printf(\"%d\\n\", query(v));\n            }\n        }\n\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// ?????????????????????????!!!!!!!!!!!!!\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ?????????????????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ????????????I?????????\n    /**********************/\n\n    // x?????f???[???^???\\?????????Bop=+, invop=1, T=int, T0=0????????\n    // i???????????E???Y?????????????????????????????s[i]?????????????Ax[i] = s[i]???????????a (??????: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n    // O(log n)\n    T query(int j) {\n        T S = T0;\n        for (j; j >= 0; j = (j & (j + 1)) - 1)  // j?????AC->B->7?????J??????????????B0????????????C??????J???o???[????????????????????????????????????Y?????????????????\n            S = op(S, x[j]); \n        return S;\n    }\n    // O(log n)\n    void update(int k, T a) {\n        for (; k < x.size(); k |= k+1) // k?????AC->D->F?????J??????????????BC??????J???o???[????????????????????????S?????????????\n            x[k] = op(x[k], a); \n    }\n    // O(1)\n    // ????????????x[i]?????A???N???Z???X????????????\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n// ?????I??????\n//\n// ???\\???zO(n): ???I???C?????????[???c???A???[, ????????????????, ???c??????_???u???????????????O\n//\n// LCA O(log n)\n// ?????????_?????????????????? O(log n)\n// ?????????_?????????????????????p???X?????????T?????? O(log n)\nclass Tree {\npublic:\n    static const int MAXLOGV = 25;\n    vector<vector<int> > m_edges; // m_edges[i][j]??????????????????: i->j??????????????????????\n    int vn; // ?????????_????????, vn<2^MAXLOGV\n    int root; // ?????????m???[???h??????????\n\n    vector<vector<int>> parent; // parent[i][j]: j??????i^2?????????e???Bj=0???????????????e???B\n    vector<int> depth; // depth[i]: ?????????_i??????????????????????[??????, ????????????0\n\n    vector<int> euler; // ??????????????????n????????I???C?????????[???c???A???[???A????????????vn*2\n    vector<int> f; // f[i] = euler??????i?????????o??????????????1????????????u, ????????????vn\n    vector<int> s; // f[i] = euler??????i?????????o??????????????2????????????u, ????????????vn\n\n    /*********/\n    // ???\\???z\n    /*********/\n    Tree(int vn, int root) : vn(vn), root(root) {\n        parent.resize(MAXLOGV);\n        m_edges.resize(vn);\n        for (int i = 0; i < MAXLOGV; i++) \n            parent[i].resize(vn);\n        depth.resize(vn);\n    }\n\n    // ????????????????\\???z\n    void unite(int u, int v) {\n        m_edges[u].push_back(v);\n        m_edges[v].push_back(u);\n    }\n\n    // root??????????????[???????????e??????m???F???B\n    // unite?????????I??????????????????????????????????????????????????B\n    void init() {\n        euler.clear(); euler.reserve(2 * vn);\n        f.clear(); f.resize(vn);\n        s.clear(); s.resize(vn);\n        dfs(root, -1, 0);\n        for (int k = 0; k+1 < MAXLOGV; k++) // 2^k??????c?????????v???Z\n            for (int v = 0; v < vn; v++) \n                if (parent[k][v] < 0) \n                    parent[k+1][v] = -1; // 2^k????????e?????????????????´?????????????????A2^(k+1)????????e?????????????????????´??????????????????\n                else \n                    parent[k+1][v] = parent[k][parent[k][v]]; // 2^(k+1)????????e?????A2^k????????e??????2^k????????e???B\n    }\n\n    // 1?????e?????[???????????I???C?????????[???c???A???[??????\\???z\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        f[v]=euler.size();\n        euler.push_back(v);\n        for (int next : m_edges[v]) \n            if (next != p)\n                dfs(next, v, d+1);\n        s[v]=euler.size();\n        euler.push_back(v);\n    }\n\n    /*********/\n    // ???N???G??????\n    /*********/\n    // ?????????_u, v????????????????????????c\n    //\n    // O(log n)\n    int lca(int u, int v) const {\n        if (depth[u] > depth[v]) swap(u, v); // u?????????????????????????????????????\n        for (int k = 0; k < MAXLOGV; k++)    // v??????u?????????????????[?????????????k??????\n            if ((depth[v] - depth[u])>>k & 1) \n                v = parent[k][v];\n        if (u == v) return u;\n        for (int k = MAXLOGV-1; k >= 0; k--) { // ???s?????????????????????????M?????????M???????????k??????\n            if (parent[k][u] == parent[k][v]) // ???s??????????????\n                continue; \n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n\n    // u??????v?????????????????????????\n    // ?????????????????G???b???W?????d?????????????????A???J??????????????`\n    //\n    // O(log n)\n    int dist(int u, int v) const {\n        int p = lca(u, v);\n        return (depth[u]-depth[p]) + (depth[v]-depth[p]);\n    }\n\n    // [root, v]?????????????????Af???????????????????????????????????m???[???h???????????\n    // 1????????????????????????????????????-1??????????????B\n    //\n    // O(log n)\n    int binary_search(int v, function<bool(int)> f) const {\n        for(int j = MAXLOGV - 1; j >= 0;j--) \n            if(parent[j][v] != -1 && f(parent[j][v]))\n                v = parent[j][v];\n        return f(v) ? v : -1;\n    }\n\n    // ???????\\?????????`??????\n    void print_dfs(int v, int p) const {\n        for (int i = 0; i < depth[v]; i++)\n            cout << \" \";\n        cout << v << endl;\n        for (int next : m_edges[v]) if (next != p) \n            print_dfs(next, v);\n    }\n    void print(void) const {\n        print_dfs(root, -1);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, q; \n    while (cin >> n >> q && n && q) {\n        Tree t(n, 0);\n        rep(i, n-1) {\n            ll tmp; cin >> tmp;\n            t.unite(i+1, tmp-1); \n        }\n        t.init();\n\n        fenwick_tree<ll> ft(n*2);\n        ft.update(t.f[0], 1);\n        ft.update(t.s[0], -1);\n\n        ll ret = 0;\n        rep(_, q) {\n            char c; ll v; cin >> c >> v; v--;\n            if (c == 'M') {\n                if (ft.access(t.f[v]))\n                    continue;\n                ft.update(t.f[v], 1);\n                ft.update(t.s[v], -1);\n            } else {\n                ll marked_num = ft.query(t.f[v]);\n                ret += t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1; \n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100016\n\nusing namespace std;\n\nint par[maxN], rank[maxN];\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, j, x;\n\tlong long sum;\n\tchar c;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tfor (i = 2; i <= n; i++)\n\t\t\tscanf(\"%d\", &par[i]);\n\t\tgetchar();\n\t\tfor (i = sum = 0; i < t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'Q')\n\t\t\t\tsum += find(x);\n\t\t\telse\n\t\t\t\tpar[x] = x;\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint pre[100005];\nint find_root(int x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    pre[1] = 1;\n    for(int i = 2;i <= n;i++)\n        scanf(\"%d\", &pre[i]);\n    char a;\n    int b;\n    long long ans = 0ll;\n    while(scanf(\" %c%d\", &a, &b), a != '0')\n    {\n        if(a == 'Q')\n            ans += find_root(b);\n        else\n            pre[b] = b;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=(int)queries.size()-1;i>=0;i--){\n\t\t\tcout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\tlong long ans;\n\twhile(~scanf(\"%d%d\",&N,&Q)&&N&&Q)\n\t{\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tmemset(marked,0,sizeof marked);\n\t\tans=0;\n\t\tSet[1]=1;fa[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t{\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=1LL*Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            a=P[a-1];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m+1;}\n            }\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; break;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint mark[MAX_N];\nint used[MAX_N];\nint par[MAX_N];\nint root;\nmap<int,vector<int> > child;\nvoid dfs(int start){\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++){\n        if(used[child[start][i]]==0) dfs(child[start][i]);\n    }\n}\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if(a=='0' and b==0)break;\n        if (a=='Q') {\n            //cout<<\"as\"<<mark[b-1]<<endl;\n            ans+=mark[b-1];\n            ans++;\n        }\n        else {\n            root=b-1;\n            dfs(b-1);\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+1];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init(n);\n    par[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tunite(par[num],num);\n\tsum += par[num]+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MAX_N = 1000000;\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) par[i] = i;\n}\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\nint find_marked(int x) {\n    if (marked[x] || par[x] == x) {\n        return x;\n    } else {\n        return find_marked(par[x]);\n    }\n}\n//順序固定、yをxにくっつける\nvoid unite(int x, int y){\n    if (x == y) return;\n    par[y] = x;\n}\n\nint N, Q;\n\nint main() {\n    while (cin>>N>>Q) {\n    if (N == 0 && Q == 0) break;\n    init(N);\n    fill(marked,marked+N,false);\n    marked[0] = true;\n    int tmp;\n    char q;\n\n    for (int i = 1; i < N; i++) {\n        cin >> tmp;\n        unite(tmp-1, i);\n    }\n    \n    long long res = 0;\n    for (int i = 0; i < Q; i++) {\n        cin >> q; cin >> tmp;\n        if (q == 'Q') {\n            res += (long long) (find_marked(tmp-1) + 1);\n        }\n        else if (q == 'M') {\n            marked[tmp-1] = true;\n        }\n    }\n    cout << res << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/* UnionFindの練習問題の項にあったのでそれっぽくやってみた\n * ぶっちゃけ愚直に実装したほうがいい\n */\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long Long;\n\n#define MN 100000\n#define MQ 100000\nint N, Q;\nint parent[MN + 1];\nbool marked[MN + 1];\npair<int, int> queries[MQ];\nint group[MN + 1];\n\nint root(int x) {\n    if (marked[x]) return x;\n    return parent[x] = root(parent[x]);\n}\nvoid merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return;\n    parent[x] = y;\n}\n\nbool input() {\n    scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) return false;\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        parent[i] = p;\n    }\n    memset(marked, false, N + 1);\n    marked[1] = true;\n    for (int i = 0; i < Q; i++) {\n        char t; int n;\n        scanf(\"%*[ \\t\\r\\n]%c %d\", &t, &n);\n        if (t == 'M') {\n            if (marked[n]) {\n                queries[i] = make_pair('X', 0);\n                continue;\n            }\n            marked[n] = true;\n        }\n        queries[i] = make_pair(t, n);\n    }\n    return true;\n}\n\nvoid solve() {\n    Long ans = 0;\n    for (int q = Q - 1; q >= 0; q--) {\n        pair<int, int> query = queries[q];\n        if (query.first == 'Q') {\n            ans += root(query.second);\n        } else if (query.first == 'M') {\n            marked[query.second] = false;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    while (input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 1e-10;\n\nll find(ll node, vector<ll> parent, vector<bool> marked){\n    return (marked[node]?node:find(parent[node], parent, marked));\n}\n\nint main() {\n    ll n,q,node;\n    char c;\n    cin >> n >> q;\n    while(n || q){\n        vector<ll> children[n+1], parent(n+1, 1);\n        vector<bool> marked(n+1, false);\n        ll ans = 0;\n        reppp(i, 2, n+1){\n            cin >> node;\n            children[node].push_back(i);\n            parent[i] = node;\n        }\n\n        marked[1] = true;\n        rep(q){\n            cin >> c >> node;\n            if(c == 'Q'){\n                ans += find(node, parent, marked);\n            }else{\n                marked[node] = true;\n            }\n        }\n        cout << ans << endl;\n        cin >> n >> q;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int MAX = 110000;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n+2 ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n  bool mark[MAX];\n\n  while(cin >> n >> q ,n + q){\n    stack<P> st;\n    fill(mark,mark+MAX,false);\n    mark[1] = true;\n    long long sum = 0;\n    init(n);\n    rank[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      rank[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'M'){\n\tmark[num] = true;\n      }\n      st.push(P(ch,num));\n    }\n    for(int i = 2 ; i <= n ; i++){\n      if(!mark[i]) unite(rank[i],i);\n    }\n\n    while(!st.empty()){\n      P p = st.top(); st.pop();\n\n      if(p.first == 'Q'){\n\tsum += find(p.second);\n      }\n      else{\n\tmark[p.second] = false;\n\tunite(rank[p.second],p.second);\n      }\n    }\n      cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <fstream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-8;\nint INF = INT_MAX / 2;\n\nint main() {\n\tfor (;;) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (N == 0 && M == 0) break;\n\t\tvector<int> p(N);\n\t\tp[0] = -1;\n\t\tfor (int u = 1; u < N; u++) {\n\t\t\tcin >> p[u];\n\t\t\tp[u]--;\n\t\t}\n\t\tvector<char> c(M);\n\t\tvector<int> v(M);\n\t\tvector<int> t(N);\n\t\tt[0] = 1;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring s; cin >> s >> v[i];\n\t\t\tc[i] = s[0];\n\t\t\tv[i]--;\n\t\t\tif (c[i] == 'M') t[v[i]]++;\n\t\t}\n\t\tvector<int> a(N);\n\t\tfor (int u = 0; u < N; u++)\n\t\t\ta[u] = (t[u] ? u : p[u]);\n\t\tll ans = 0;\n\t\tfor (int i = M - 1; i >= 0; i--) {\n\t\t\tif (c[i] == 'M') {\n\t\t\t\tt[v[i]]--;\n\t\t\t\tif (t[v[i]] == 0)\n\t\t\t\t\ta[v[i]] = p[v[i]];\n\t\t\t}\n\t\t\tif (c[i] == 'Q') {\n\t\t\t\tint& u = a[v[i]];\n\t\t\t\tfor (; a[u] != u; u = a[u]);\n\t\t\t\tans += u + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint n, q;\nint p[100005];\nvector<int> G[100005];\nchar c[100005]; int v[100005];\nbool mark[100005];\nUnionFind uf(100005);\n\nvoid dfs(int v)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!mark[G[v][i]]) uf.unite(G[v][i], v);\n\t\tdfs(G[v][i]);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> q;\n\t\tif(n == 0 && q == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> p[i];\n\t\t\tG[p[i]].push_back(i);\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c[i] >> v[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) mark[i] = false;\n\t\tmark[1] = true;\n\t\t\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'M'){\n\t\t\t\tif(mark[v[i]]) c[i] = 'X';\n\t\t\t\telse mark[v[i]] = true;\n\t\t\t}\n\t\t} \n\t\tuf.init();\n\t\tdfs(1);\n\t\t\n\t\treverse(c, c+q);\n\t\treverse(v, v+q);\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'Q') ans += uf.root(v[i]);\n\t\t\telse if(c[i] == 'M' && v[i] != 1) uf.unite(v[i], p[v[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(void){\n  int n=0;\n  int q=0;\n  scanf(\"%d%d\",&n,&q);\n  while(n!=0){\n    int tree[100005][2]={0};\n    tree[1][1]=1;\n    int ans=0;\n    int i=0;\n    for(i=2;i<=n;i++){\n      scanf(\"%d\",&(tree[i][0]));\n    }\n\n    char zi=0;\n    int no=0;\n    for(i=0;i<q;i++){\n      scanf(\"%s%d\",&zi,&no);\n      if(zi=='M'){\n\ttree[no][1]=1;\n      }\n      else if(zi=='Q'){\n\twhile(tree[no][1]==0){\n\t  no=tree[no][0];\n\t}\n\tans+=no;\n\tno=0;\n      }\n    }\n \n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&q);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n \n// 并?集相?数据与算法\n#define MAX_N 100000 + 16\nint parent[MAX_N];\nint height[MAX_N];\n \nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n// End Of 并?集\n \n// 原始的?用它来描述\nvector<int> children[MAX_N];\nint parent_tree[MAX_N];\nbool marked[MAX_N];\nint ancestor[MAX_N];\n// ?条指令被拆分? 操作 + 目?\nstack<char> operation;\nstack<int>  target;\n \nvoid bfs(int index, int the_ancestor)\n{\n\tqueue<int> q_index;\n\tqueue<int> q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile (!q_index.empty())\n\t{\n\t\tthe_ancestor = q_ancestor.front(); q_ancestor.pop();\n\t\tindex = q_index.front(); q_index.pop();\n\t\tif (marked[index] == true)\n\t\t{\n\t\t\tthe_ancestor = index;\n\t\t}\n\t\tancestor[index] = the_ancestor;\n\t\tfor (vector<int>::iterator it = children[index].begin(); it != children[index].end(); ++it)\n\t\t{\n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n \n\tint N, Q;\n\twhile (cin >> N, cin >> Q, N)\n\t{\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i] = false;\n\t\t}\n\t\tmarked[0] = true;\n\t\tint p;\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tcin >> p; --p;\n\t\t\tparent_tree[i] = p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i)\n\t\t{\n\t\t\tchar o;\n\t\t\tint t;\n\t\t\tcin >> o >> t; --t;\n\t\t\tif (o == 'M')\n\t\t\t{\n\t\t\t\tif (marked[t])\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmarked[t] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperation.push(o);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(0, 0);\n\t\tinit(N);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tunite(i, ancestor[i]);\n\t\t}\n\t\tunsigned long long result = 0;\n\t\twhile (!operation.empty())\n\t\t{\n\t\t\tchar o = operation.top(); operation.pop();\n\t\t\tint t = target.top(); target.pop();\n\t\t\tif (o == 'Q')\n\t\t\t{\n\t\t\t\tresult += ancestor[find(t)] + 1;\t// ?目index从1?始\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ?行“反染色”操作，之后?个?点的祖先??其父?点的祖先\n\t\t\t\tint p = ancestor[find(parent_tree[t])];\n\t\t\t\tunite(t, parent_tree[t]);\n\t\t\t\tancestor[find(t)] = p;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\t\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int B = 300;\n\nconst int maxn = 100010;\nint par[maxn];\nvector<int> ch[maxn];\n\nint   V[maxn];\nchar QT[maxn];\nint ancester[maxn];\nbool use[maxn];\nbool marked[maxn];\n\nvoid compress(int l, int r){\n  vector<int> vs;\n  \n  memcpy(use, marked, sizeof(marked));\n  REP2(i, l, r) use[V[i]] = true;\n  \n  queue<P> que;\n  que.push(P(1, 0));\n  ancester[1] = 0;\n  \n  while(!que.empty()){\n    int v = que.front().first;\n    int a = que.front().second;\n    que.pop();\n    if(use[v] || marked[v]) a = v;\n    REP(i, ch[v].size()){\n      int to = ch[v][i];\n      ancester[to] = a;\n      que.push(P(to, a));\n    }\n  }\n}\n\nvoid mark(int v){\n  marked[v] = true;\n}\n\nint calc(int v){\n  v = par[v];\n  while(!marked[v]) v = ancester[v];\n  return v;\n}\n\nint main(){\n  int N, Q;\n\n  while(cin >> N >> Q && N + Q){\n    memset(par, 0, sizeof(par));\n    REP(i, maxn) ch[i].clear();\n\n    marked[1] = true;\n    \n    REP(i, N - 1){\n      cin >> par[i+2];\n      ch[par[i+2]].push_back(i+2);\n    }\n  \n    REP(i, Q){\n      cin >> QT[i] >> V[i];\n    }\n  \n    ll s = 0;\n    for(int l = 0; l < Q; l += B){\n      int r = min(l + B, Q);\n      compress(l, r);\n      REP2(i, l, r){\n        if(QT[i] == 'M') mark(V[i]);\n        if(QT[i] == 'Q') s += calc(V[i]);\n      }\n    }\n    cout << s << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, Q; cin >> N >> Q;\n\tvector<int> p(N); p[0] = -1; rep(i, 1, N) { cin >> p[i]; p[i]--; }\n\tvector<bool> m(N); m[0] = true;\n\tvector<char> q1(Q);\n\tvector<int> q2(Q);\n\trep(i, 0, Q) {\n\t\tcin >> q1[i] >> q2[i];\n\t\tq2[i]--;\n\t\tif (q1[i] == 'M')m[q2[i]] = true;\n\t}\n\tUnionFind UF(N);\n\tint ans = 0;\n\trrep(i, 0, Q) {\n\t\tif (q1[i] == 'Q') {\n\t\t\tint root = UF.root(q2[i]);\n\t\t\twhile (!m[root]) {\n\t\t\t\tUF.unite(root, p[root]);\n\t\t\t\troot = p[root];\n\t\t\t\tif (m[root]) {\n\t\t\t\t\tans += (root + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tm[q2[i]] = false;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\n\nint used[MAX_N];\nint mark[MAX_N];\nmap<int,vector<int> > child;\n\nvoid dfs(int start,int root){\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        int mark[MAX_N];\n        \n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n        \n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        int ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nint par[100001], e[100001], v[100000];\nchar op[100000];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    par[find(x)] = find(y);\n}\n\nint main(void) {\n    int i, n, q;\n    scanf(\"%d%d\",&n,&q);\n    e[1] = 1;\n    REP (i,2,n) scanf(\"%d\\n\",&e[i]);\n    REP (i,1,n) par[i] = e[i];\n    REP (i,q) {\n        scanf(\"%c%d\\n\",&op[i],&v[i]);\n        if (op[i] == 'M') par[v[i]] = v[i];\n    }\n    ll ans = 0;\n    RREP (i,q) {\n        if (op[i] == 'M')\n            unite(v[i],e[v[i]]);\n        else\n            ans += find(v[i]);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100000][2];\nchar q1[100000];\nint q2[100000];\nvector<vector<int> > vec(100000);\n//vec = vector < vector <int> >(1000000,vector<int>(100000,0)) ;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); it++){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<string.h>\n//aoj 2170\nusing namespace std;\nint n,q;\nlong long ans;\nint f[100003];\nint find(int x)\n{\n\tif(f[x]==x)\n\t{\n\t\treturn x;\n\t}else{\n\t\treturn find(f[x]);\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(n==0&&q==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tans=0;\n\t\tmemset(f,0,sizeof(f));\n\t\tf[1]=1;\n        for(int i=2;i<=n;i++)\n\t\t{\n            scanf(\"%d\",&f[i]);\n        }\n        for(int i=1;i<=q;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tchar pd;\n\t\t\twhile(getchar()!='\\n');\n            scanf(\"%c%d\",&pd,&a);\n            if(pd=='Q')\n\t\t\t{\n                ans+=(long long)find(a);\n            }else{\n                f[a]=a;\n\t\t\t}\n        }\n        printf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\tint t;\n\t\trep(i, n-1) {\n\t\t\tcin >> t; t--;\n\t\t\tpar0[i + 1] = t;\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] += 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (marked[i]==0) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tmarked[p[i].second]--;\n\t\t\t\tif (marked[p[i].second] == 0) {\n\t\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)(find(p[i].second)+1);\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n//< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy += max(seg[2 * k+1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl , vr);\n}\n\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root),cnum(V),place(V),id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v]+=dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v]+1;\n\t}\n\n\tvoid getid(const int v, const int p,int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tupdate(1, N, 0);\n\t\tvector<int>nums;\n\t\tnums.push_back(0);\n\t\tTree t(N,0);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tt.unite(a, i+1);\n\t\t}\n\t\tt.init();\n\t\tlong long int asum = 0;\n\t\twhile (Q--) {\n\t\t\tchar c;int  n;\n\t\t\tcin >> c >> n;\n\t\t\tconst int aplace = t.place[n-1];\n\t\t\tif (c == 'M') {\n\t\t\t\tupdate(aplace+1, aplace + t.cnum[n-1]+1, n-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans = get(aplace+1, aplace+1);\n\t\t\t\tasum += ans+1;\n\t\t\t}\n\t\t}\n\t\tcout << asum << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int pn){\n  if(!m[v]){\n    p[v]=pn;\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],pn);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    int s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tdfs(v,v);\n\tm[v]=true;\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n \n//思路：并?集 + ? + ?列 （??取出方式） \n\nint parent[100016];\nint height[100016];\n\n//并?集 \nvoid init(int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(int x)\n{\n\tif(parent[x] == x)  return x;\n\telse  return parent[x] = find(parent[x]);\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)  return;\n\tif(height[x] < height[y])  parent[x] = y;\n\telse{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])  height[x]++;\n\t}\n}\n \n//用来描述原始? \nvector<int> children[100016];\nint parent_tree[100016];\nbool marked[100016];\nint ancestor[100016];\n// ?条指令被拆分? 操作 + 目?\nstack<char> operation;\nstack<int>  target;\n \nvoid bfs(int index, int the_ancestor)\n{\n\tqueue<int> q_index;\n\tqueue<int> q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile (!q_index.empty())\n\t{\n\t\tthe_ancestor = q_ancestor.front(); \n\t\tq_ancestor.pop();\n\t\tindex = q_index.front(); \n\t\tq_index.pop();\n\t\tif(marked[index] == true)  the_ancestor = index;  //如果?点自身被??，?它的染色祖先是自己，它的自己不??的儿子的最近染色祖先是它\n\t\tancestor[index] = the_ancestor;  //??index的最近染色祖先 \n\t\tfor(vector<int>::iterator it = children[index].begin(); it != children[index].end(); it++){  //将index的儿子加入?列 \n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n \nint main()\n{\n \n\tint N, Q;\n\twhile(scanf(\"%d %d\", &N, &Q) && (N || Q)){\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i] = false;\n\t\t}\n\t\tmarked[1] = true;\n\t\tparent_tree[1] = 1;\n\t\tint p;\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\", &p);\n\t\t\tparent_tree[i] = p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tgetchar(); \n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tchar ch;\n\t\t\tint t;\n\t\t\tscanf(\"%c %d\", &ch, &t);\n\t\t\tgetchar();\n\t\t\tif(ch == 'M'){\n\t\t\t\tif(marked[t])  continue;  //不?存重?的 \"M v\"，防止之后重?反染色 \n\t\t\t\telse  marked[t] = true;\n\t\t\t}\n\t\t\toperation.push(ch);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(1, 1);\n\t\tinit(N);\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tunite(i, ancestor[i]);\n\t\t}\n\t\tunsigned long long result = 0;\n\t\twhile(!operation.empty()){  //从后往前取出操作\n\t\t\tchar ch = operation.top(); \n\t\t\toperation.pop();\n\t\t\tint t = target.top(); \n\t\t\ttarget.pop();\n\t\t\tif(ch == 'Q')  result += ancestor[find(t)];  //?目index从1?始\n\t\t\telse{  //??点t反染色（取消染色），t的祖先??其父?点的祖先\n\t\t\t\tint p = ancestor[find(parent_tree[t])];\n\t\t\t\tunite(t, parent_tree[t]);\n\t\t\t\tancestor[find(t)] = p;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iostream>\n#include <string>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tstd::vector<int> data_array;\n\tconst int root(int id) {\n\t\tif (data_array[id] >= 0)\n\t\t\treturn data_array[id] = root(data_array[id]);\n\t\telse\n\t\t\treturn id;\n\t}\npublic:\n\tUnionFind(size_t size) : data_array(size, -1) {}\n\t// union???????´????\n\tbool union_(int lhs, int rhs) {\n\t\tlhs = root(lhs);\n\t\trhs = root(rhs);\n\t\tbool is_union = (lhs != rhs);\n\t\tif (is_union) {\n\t\t\tif (data_array[lhs] > data_array[rhs]) { std::swap(lhs, rhs); }\n\t\t\tdata_array[lhs] += data_array[rhs];\n\t\t\tdata_array[rhs] = lhs;\n\t\t}\n\t\treturn is_union;\n\t}\n\tbool find(int lhs, int rhs) {\n\t\treturn (root(lhs) == root(rhs));\n\t}\n};\nint anc[100008];\nbool mark[100007];\nint root(int n) {\n\tif (mark[n] == true)return n;\n\telse root(anc[n]);\n}\nint main()\n{\n\tint n, q;\n\twhile (cin >> n >> q, n != 0) {\n\t\tfor (int i = 0; i < 100005; i++) {\n\t\t\tanc[i] = mark[i] = 0;\n\t\t}\n\t\tmark[0] = true;\n\t\tint tmp;\n\t\tchar c;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &tmp);\n\t\t\tanc[i] = tmp - 1;\n\t\t}long long ans = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> c >> tmp;\n\t\t\tif (c == 'Q')ans += root(tmp-1)+1;\n\t\t\telse mark[tmp - 1] = true;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint par[100010],o[100010];\n\nint find(int pos){\n  if(o[pos]) return pos;\n  return find(par[pos]);\n}\n\nint main(){\n  while(1){\n    int n,q;\n    cin>>n>>q;\n    if(!n&&!q)break;\n    for(int i=0;i<=n;i++) o[i]=0;\n    for(int i=2;i<=n;i++) cin>>par[i];\n    \n    o[1]=1;\n    long long ans=0;\n    while(q--){\n      char ch;int idx;\n      cin>>ch>>idx;\n      if(ch=='M') o[idx]=1;\n      if(ch=='Q')ans+=find(idx);\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) data[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF, mx = 0;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t\tmx = max(mx, res);\n\t}\n\t\n\tranges[v] = pii(mn, mx);\n\t\n\t++d;\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tif (rng.first == 0) continue;\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i + 2);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\n// 集合にデータを入れたい時\ntemplate <class T> \nstruct UnionFind {\n  vector<int> data;\n  vector<T> val;\n  UnionFind(int size) : data(size, -1), val(size) {\n    REP(i,size) {\n      val[i] = i;\n    }\n  }\n  bool unionSet(int x, int y, T v) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n      val[x] = v;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  T &value(int x) {\n    return val[root(x)];\n  }\n};\n\nint p[100000];\nchar c[100000];int a[100000];\nbool v[100000];\n\nint main() {\n  int n,q;\n  while(cin>>n>>q,n||q) {\n    p[0] = -1;\n    REP(i,n-1) {\n      cin >> p[i+1];\n      p[i+1]--;\n    }\n    memset(v,0,sizeof(v));\n    v[0] = 1;\n    REP(i,q) {\n      cin >> c[i] >> a[i];\n      a[i]--;\n      if (c[i] == 'M') {\n        if (v[a[i]]) c[i] = '.';\n        else v[a[i]] = 1;\n      }\n    }\n    UnionFind<int> uf(n);\n    REP(i,n) {\n      if (!v[i]) {\n        uf.unionSet(i,p[i],uf.value(p[i]));\n      }\n    }\n    // REP(i,n) {\n    //   cout << uf.value(i) << endl;\n    // }\n    ll ans = 0;\n    for (int i=q-1; i>=0; --i) {\n      if (c[i] == 'Q') {\n        ans += uf.value(a[i])+1;\n      } else if (c[i] == 'M') {\n        uf.unionSet(a[i],p[a[i]],uf.value(p[a[i]]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n    vector <int> par;\n    UnionFind(int N) : par(N, -1){}\n    void unite(int x, int y){\n        x = root(x); y = root(y);\n        if(x != y){\n            par[x] += par[y];\n            par[y] = x;\n        }\n    }\n    int root(int x){ return par[x] < 0 ? x : par[x] = root(par[x]);}\n    bool same(int x, int y){ return root(x) == root(y);}\n};\n\ntypedef pair<bool, int> pbt;;\nbool marked[100000];\nint p[100000];\nint main(){\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, Q, _t;\n    char _c;\n    while(ifs >> N >> Q && N){\n        memset(marked, 0, sizeof(marked));\n        marked[0] = true;\n        UnionFind uf(N);\n        vector<pbt> query;\n        \n        REP(i, 1, N){\n            ifs >> p[i]; --p[i];\n        }\n        rep(i, Q){\n            ifs >> _c >>_t; --_t;\n            if(_c == 'Q')\n              query.push_back(pbt(1, _t));\n            else if(!marked[_t]){\n                query.push_back(pbt(0, _t));\n                marked[_t] = true;\n            }\n        }\n        rep(i, N)\n          if(!marked[i])\n            uf.unite(p[i], i);\n        ll sum = 0LL;\n        for(int i = query.size() - 1; i >= 0; --i){\n            int v = query[i].second;\n            if(query[i].first)\n              sum += uf.root(v) + 1;\n            else\n              uf.unite(p[v], v);\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint root;\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start,int root){\n            if(mark[start]==root or mark[start]==start) return ;\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n        }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        int par;\n        scanf(\"%d\",&par);\n        par--;\n        tmp.child[par].push_back(i+1);\n    }\n    int ans=0;\n    tmp.used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        b--;\n        if (a=='Q') {\n            //cout<<\"as\"<<tmp.mark[b-1]<<endl;\n            ans+=(tmp.mark[b]+1);\n        }\n        else {\n            root=b;\n            tmp.dfs(b,root);\n            tmp.used[b]=1;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int B = 400;\n\nconst int maxn = 100010;\nint par[maxn];\nvector<int> ch[maxn];\n\nint   V[maxn];\nchar QT[maxn];\nint ancester[maxn];\nbool use[maxn];\nbool marked[maxn];\n\nvoid compress(int l, int r){\n  vector<int> vs;\n  \n  memcpy(use, marked, sizeof(marked));\n  REP2(i, l, r) use[V[i]] = true;\n  \n  queue<P> que;\n  que.push(P(1, 0));\n  ancester[1] = 0;\n  \n  while(!que.empty()){\n    int v = que.front().first;\n    int a = que.front().second;\n    que.pop();\n    if(use[v] || marked[v]) a = v;\n    REP(i, ch[v].size()){\n      int to = ch[v][i];\n      ancester[to] = a;\n      que.push(P(to, a));\n    }\n  }\n}\n\nvoid mark(int v){\n  marked[v] = true;\n}\n\nint calc(int v){\n  while(!marked[v]) v = ancester[v];\n  return v;\n}\n\nint main(){\n  int N, Q;\n\n  while(cin >> N >> Q && N + Q){\n    memset(par, 0, sizeof(par));\n    memset(marked, false, sizeof(marked));\n    \n    REP(i, maxn) ch[i].clear();\n\n    marked[1] = true;\n    \n    REP(i, N - 1){\n      cin >> par[i+2];\n      ch[par[i+2]].push_back(i+2);\n    }\n    \n    REP(i, Q){\n      cin >> QT[i] >> V[i];\n    }\n  \n    ll s = 0;\n    for(int l = 0; l < Q; l += B){\n      int r = min(l + B, Q);\n      compress(l, r);\n      REP2(i, l, r){\n        if(QT[i] == 'M') mark(V[i]);\n        if(QT[i] == 'Q') s += calc(V[i]);\n      }\n    }\n    cout << s << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 1e5 + 10;\n\nstruct UnionFind{\n\tvector<int> par;\n\n\tUnionFind(int n){\n\t\tpar = vector<int>(n);\n\t\trep(i, n) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tpar[find(x)] = find(y);\n\t}\n};\n\nint p[N], qv[N];\nchar qc[N];\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n){\n\t\tFOR(i, 1, n) cin >> p[i], --p[i];\n\t\tset<int> ok;\n\t\trep(i, q){\n\t\t\tcin >> qc[i] >> qv[i], --qv[i];\n\t\t\tif (qc[i] == 'M'){\n\t\t\t\tif (ok.count(qv[i])) qv[i] = -1;\n\t\t\t\telse ok.insert(qv[i]);\n\t\t\t}\n\t\t}\n\n\t\tUnionFind uf(n);\n\n\t\trep(i, n) if (!ok.count(i)) uf.unite(i, p[i]);\n\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; --i){\n\t\t\tif (qv[i] < 0) continue;\n\t\t\tif (qc[i] == 'M'){\n\t\t\t\tuf.unite(qv[i], p[qv[i]]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += uf.find(qv[i]) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\n\nint used[MAX_N];\nint mark[MAX_N];\nvector<int> child[100010];\nvoid dfs(int start,int root){\n    //cout<<used[start]<<start<<endl;\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        //map<int,vector<int> > child;\n        //int used[MAX_N];\n        //int mark[MAX_N];\n        \n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n        \n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        int ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\ntemplate <typename T>\nclass SegmentTree{\nprivate:\n    int n;\n    vector<T> dat;\n    T init_value;\npublic:\n    void init(int n_, T init_value_){\n        n = 1;\n        init_value = init_value_;\n        while(n < n_) n *= 2;\n        dat.assign(2*n-1, init_value);\n    }\n    // k: index(0-indexed), a: value\n    void update(int k, T a){\n        k += n-1;\n        dat[k] = a;\n        while(k>0){\n            k = (k-1)/2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    // query(a, b) =>  minimum in [a,b]\n    T query(int a, int b){\n        return _query(a, b, 0, 0, n-1);\n    }\n    // dat[k] is minimum in [l,r]\n    T _query(int a, int b, int k, int l, int r){\n        if(r<a || b<l) return init_value;\n        if(a<=l&&r<=b){\n            return dat[k];\n        }else{\n            T vl = _query(a, b, k*2+1, l, (l+r)/2);\n            T vr = _query(a, b, k*2+2, (l+r)/2+1, r);\n            return max(vl, vr);\n        }\n    }\n    // k: index(0-indexed)\n    T get(int k){\n        return dat[k+n-1];\n    }\n};\n\nSegmentTree<P> seg;\nvector<vector<int>> children;\nvector<int> mark;\nvector<vector<int>> queries;\n\nll dfs(int v, int depth){\n    if(mark[v] != -1) seg.update(mark[v], P(depth, v));\n    ll ret = 0;\n    for(int t : queries[v]){\n        P p = seg.query(0, t);\n        ret += p.second + 1;\n    }\n    for(int child : children[v]){\n        ret += dfs(child, depth + 1);\n    }\n    if(mark[v] != -1) seg.update(mark[v], P(-1, -1));\n    return ret;\n}\n\nint main(){\n    while(true){\n        int N, Q;\n        cin >> N >> Q;\n        if(N == 0) break;\n\n        children.assign(N, {});\n        for(int i=1;i<N;i++){\n            int par;\n            cin >> par;\n            children[par-1].push_back(i);\n        }\n\n        mark.assign(N, -1);\n        mark[0] = 0;\n        queries.assign(N, {});\n        for(int i=1;i<=Q;i++){\n            char c;\n            int v;\n            cin >> c >> v;\n            v--;\n            if(c == 'M'){\n                if(mark[v] == -1) mark[v] = i;\n            }else{\n                queries[v].push_back(i);\n            }\n        }\n\n        seg.init(Q+1, P(-1, -1));\n        cout << dfs(0, 0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n    int num;\n    vector<int> par,rank;\n    UnionFind(int n):num(n),par(n),rank(n,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        return (par[x]==x?x:par[x]=root(par[x]));\n    }\n    bool merge(int x, int y){\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        // if (rank[x]<rank[y]) swap(x,y);\n        par[y]=x;\n        rank[x]+=rank[y];\n        --num;\n        return true;\n    }\n    bool same(int x, int y){return root(x)==root(y);}\n    int size(int x){return rank[root(x)];}\n    int count(){return num;}\n};\n\nconst int MAX_N=1e5+10,MAX_Q=1e5+10;\n\nint N,Q;\nvector<int> G[MAX_N];\nint p[MAX_N],V[MAX_N],Mark[MAX_N],par[MAX_N];\nchar c[MAX_Q];\n\nvoid dfs(int v,int p,int D){\n    par[v]=D;\n    for (int u:G[v]){\n        if (u==p) continue;\n        dfs(u,v,(Mark[u]?u:D));\n    }\n}\n\nvoid solve(){\n    for (int i=0;i<N;++i) G[i].clear(),Mark[i]=0;\n    for (int i=1;i<N;++i) G[p[i]].emplace_back(i);\n    for (int i=0;i<Q;++i) if (c[i]=='M'){\n        ++Mark[V[i]];\n    }\n    dfs(0,-1,0);\n    UnionFind uf(N);\n    for (int i=1;i<N;++i) uf.merge(par[i],i);\n    long long ans=0;\n    for (int i=Q-1;i>=0;--i){\n        if (c[i]=='M'){\n            if (--Mark[V[i]]==0) uf.merge(p[V[i]],V[i]);\n        } else ans+=uf.root(V[i])+1;\n    }\n    cout << ans << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N >> Q,N,Q){\n        for (int i=1;i<N;++i) cin >> p[i],--p[i];\n        for (int i=0;i<Q;++i) cin >> c[i] >> V[i],--V[i];\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstdio>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define maxSize 100001\nusing namespace std;\n\nbool mark[maxSize];\nint p[maxSize] , f[maxSize];\nvector<int> v[maxSize];\nqueue<int> que;\npair<char, int> query[maxSize];\nstack<int> ans ;\n\nvoid init()\n{\n\tfor (int i = 0; i <= maxSize; ++i)\n\t{\n\t\t p[i] = i;\n\t}\n}\n \nint parent(int i)\n{\n\tif(p[i] == i) return i;\n\treturn p[i] = parent(p[i]);\n }\n\nvoid u(int a, int b) \n{\n\tp[parent(a)] =  parent(b);\n\treturn ;\n}\n\nvoid Bfs() \n{\n\tque.push (1);\n\tp[1] = 1;\n\twhile(!que.empty())\n\t{\n\t\tint cur  = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < v[cur].size(); ++i)\n\t\t{\n\t\t\tif(mark[v[cur][i]] == true) {p[v[cur][i]] = v[cur][i];}\n\t\t\telse  p[v[cur][i]] = p[cur];\t\t \n\t\t\tque.push(v[cur][i]);\n\t\t}\t\n\t}\n\treturn ;\n}\n\nint main( )\n{\n\tint  a, N, Q;\t\n\twhile ( cin >>  N >> Q  && N && Q) {\n\t\tmemset(mark,0,sizeof(mark));\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\t if(i == 1) { f[1] = 1; continue;}\n\t\t\t cin >> a;\n\t\t\t v[a].push_back(i);\n\t\t\t f[i] = a;\n\t\t}\n\t\tmark[1] = true;\n\t\tfor (int i = 1; i <= Q; ++i)\n\t\t{\n\t\t\t  cin >> query[i].first  >> query[i].second ;\n\t\t\t  if(query[i].first == 'M') mark[query[i].second] = true;\n\t\t}\n\t\t \n\t\tBfs();\n\t\t \n\t\tfor (int i = Q; i >= 1; --i)\n\t\t{\n\t\t\t if(query[i].first == 'Q') { ans.push(parent(query[i].second)) ; continue;}\n\t\t\t mark[query[i].second] = false;\n\t\t\t p[query[i].second] =  parent(f[query[i].second] );\n\t\t}\n\t\tint num =0;\n\t\twhile(!ans.empty()) {\n\t \t\tnum += ans.top();\n\t \t    \tans.pop();\n\t\t}\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// TODO ????????????????????????\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ????£???????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ????£??????????\n    /**********************/\n    // x?????????????§???????op=+, invop=1, T=int, T0=0?????´???\n    // i????????????????????°?????????s[i]??¨?????????x[i] = s[i]????????? (???: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n    // O(log n)\n    T query(int j) {\n        T S = T0;\n        for (j; j >= 0; j = (j & (j + 1)) - 1) { // j??????C->B->7??¨????§??????????0??????C?????????????????????????????°???????????????????£???¶\n            S = op(S, x[j]); \n        }\n        return S;\n    }\n    // O(log n)\n    void update(int k, T a) {\n        for (; k < x.size(); k |= k+1) x[k] = op(x[k], a); // k??????C->D->F??¨????§??????????C????????????????????°????????¨???????£???¶\n    }\n    // O(1)\n    // ??????x[i]?????¢???????????????\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n// ????????¨\nclass Tree {\npublic:\n    static const int MAXLOGV = 25;\n    vector<vector<int> > m_edges; // m_edges[i][j]????????¨: i->j??????????????¨\n    int vn; // ???????????°, vn<2^MAXLOGV\n    int root; // ?????????????????????\n\n    vector<vector<int>> parent; // parent[i][j]: j???i^2???????????????j=0??§??´????????????\n    vector<int> depth; // depth[i]: ??????i?????????????????±???, ??????0\n\n    vector<int> euler; // ??????????§????????????????????????¢???\n    vector<int> f; // f[i] = euler??§i???????????????1???????????????\n    vector<int> s; // f[i] = euler??§i???????????????2???????????????\n\n    /*********/\n    // ?§????\n    /*********/\n    Tree(int vn, int root) : vn(vn), root(root) {\n        parent.resize(MAXLOGV);\n        m_edges.resize(vn);\n        for (int i = 0; i < MAXLOGV; i++) parent[i].resize(vn);\n        depth.resize(vn);\n    }\n    // ?????????????§????\n    // TODO parent?????\\?????´??°??????????????????????????????????????????????????????????????????\n    void unite(int u, int v) {\n        m_edges[u].push_back(v);\n        m_edges[v].push_back(u);\n    }\n    // root???????????±?????¨???????¢???????\n    // unite???????????£??????????????????????????¶?????¨???\n    void init() {\n        euler.clear(); euler.reserve(2 * vn);\n        f.clear(); f.resize(vn);\n        s.clear(); s.resize(vn);\n        dfs(root, -1, 0);\n        for (int k = 0; k+1 < MAXLOGV; k++) { // 2^k??£?\\????????¨????\n            for (int v = 0; v < vn; v++) {\n                if (parent[k][v] < 0) parent[k+1][v] = -1; // 2^k??£????????????????¶???????????????????2^(k+1)??£????????????????????????????¶?????????????\n                else parent[k+1][v] = parent[k][parent[k][v]]; // 2^(k+1)??£????????????2^k??£?????????2^k??£?????????\n            }\n        }\n    }\n    // ?????£????????¨??±???????¢????????????????\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        f[v]=euler.size();\n        euler.push_back(v);\n        for (int next : m_edges[v]) {\n            if (next != p) dfs(next, v, d+1);\n        }\n        s[v]=euler.size();\n        euler.push_back(v);\n    }\n\n    /*********/\n    // ?????¨???\n    /*********/\n    // ??????u, v???????°???±???????\\?\n    //\n    // O(log n)\n    int lca(int u, int v) const {\n        if (depth[u] > depth[v]) swap(u, v); // u?????????????????????????????????\n        for (int k = 0; k < MAXLOGV; k++)    // v???u??¨????????±????????§??????\n            if ((depth[v] - depth[u])>>k & 1) \n                v = parent[k][v];\n        if (u == v) return u;\n        for (int k = MAXLOGV-1; k >= 0; k--) { // ????????????????????????????????§??????\n            if (parent[k][u] == parent[k][v]) // ????????????\n                continue; \n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n    // u??¨v????????¢????±???????\n    // ?????¢?????¨?????????????????§????????????????§??????°??§??????\n    //\n    // O(log n)\n    int dist(int u, int v) const {\n        int p = lca(u, v);\n        return (depth[u]-depth[p]) + (depth[v]-depth[p]);\n    }\n    // [root, v]????????????f???????????????????????´?????????????????????\n    //\n    // O(log n)\n    // 1???????????????????????????-1????????????\n    int binary_search(int v, function<bool(int)> f) {\n        for(int j = MAXLOGV - 1; j >= 0;j--) \n            if(parent[j][v] != -1) {\n                if (f(parent[j][v])) {\n//                    cout << j << \" \" << v << \"#hit\" << endl;\n                    v = parent[j][v];\n                } else {\n//                    cout << j << \" \" << v << \"#not hit\" << endl;\n                }\n            }\n        return (f(v) ? v : -1);\n    }\n    // ??¨????§??????????\n    void print_dfs(int v, int p) {\n        for (int i = 0; i < depth[v]; i++)\n            cout << \" \";\n        cout << v << endl;\n        for (int next : m_edges[v]) if (next != p) \n            print_dfs(next, v);\n    }\n    void print(void) {\n        print_dfs(root, -1);\n    }\n\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, q; \n    while (cin >> n >> q && n && q) {\n        Tree t(n, 0);\n        rep(i, n-1) {\n            ll tmp; cin >> tmp;\n            t.unite(i+1, tmp-1); \n        }\n        t.init();\n\n        fenwick_tree<ll> ft(n*2);\n        ft.update(t.f[0], 1);\n        ft.update(t.s[0], -1);\n\n        ll ret = 0;\n        rep(_, q) {\n            char c; ll v; cin >> c >> v; v--;\n            if (c == 'M') {\n                if (ft.access(t.f[v]))\n                    continue;\n                ft.update(t.f[v], 1);\n                ft.update(t.s[v], -1);\n            } else {\n                ll marked_num = ft.query(t.f[v]);\n                ret += t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1; \n//                cout << t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1 << endl;\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\n//再利用する場合はMAX_Nの値を設定し直すことを忘れない！！！\n//Union-Find木を少し改造\n\nconst int MAX_N = 100005;\n\nint Par[MAX_N+1];\nbool Marked[MAX_N+1];\n//int Rank[MAX_N];\n\nvoid init(int n){  //1~nまで初期化\n    for (int i = 1; i <= n; i++) {\n        Par[i] = i;\n        //Rank[i] = 0;\n    }\n}\n\nint find(int x) {  //xの根を返す\n    if (Marked[x]) return x;\n    else {\n        return find(Par[x]);\n    }\n}\n\nvoid unite(int x, int y) {  //xとyを併合.ただし、yをxに繋げる\n    Par[y] = x;\n}\n\nint N;  //Nodeの数\nint Q;  //Operationの数\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) break;\n        init(N);  //1~Nまで\n        fill(Marked, Marked+N+1, false);\n        Marked[1] = true;\n        for (int i = 2; i <= N; i++) {  //2~Nまで\n            int p;  //iの親\n            scanf(\"%d\", &p);\n            unite(p,i);  //iをpに繋げる\n        }\n        long long ret = 0;\n        for (int i = 0; i < Q; i++) {\n            char c;\n            int v;\n            scanf(\" %c %d\", &c, &v);\n            if (c == 'Q') {  //Markの付いた最近の祖先を調べる\n                ret += find(Par[v]);  //自分にMarkが入っている時に、自分をカウントしないようにする\n            } else if (c == 'M') {  //印をつける\n                Marked[v] = true;\n            }\n        }\n        printf(\"%lld\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n\n  UnionFind(int sz_) : par(sz_)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    if (par[x] == x)\n      return x;\n\n    return par[x] = root(par[x]);\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x != y)\n    {\n      par[y] = x;\n    }\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n};\nint N, Q;\nvector<vector<int>> g(100010);\nbool marked[100010];\nint pp[100010];\n\nvoid dfs(int v, int p, int m, UnionFind &uf)\n{\n  int nm = m;\n  if (marked[v])\n    nm = v;\n\n  pp[v] = p;\n  uf.merge(nm, v);\n\n  for (int i = 0; i < g[v].size(); i++)\n  {\n    dfs(g[v][i], v, nm, uf);\n  }\n}\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(4);\n  while (cin >> N >> Q)\n  {\n    if (N == 0 && Q == 0)\n      break;\n\n    for (int i = 0; i < N; i++)\n      g[i].clear();\n\n    for (int i = 1; i < N; i++)\n    {\n      int a;\n      cin >> a;\n      a--;\n      g[a].push_back(i);\n    }\n\n    UnionFind uf(N);\n    memset(marked, false, sizeof(marked));\n\n    marked[0] = true;\n    vector<pair<char, int>> vp;\n    for (int i = 0; i < Q; i++)\n    {\n      char c;\n      int v;\n      cin >> c >> v;\n      v--;\n      if (c == 'M')\n      {\n        if (marked[v])\n          continue;\n\n        marked[v] = true;\n        vp.push_back(make_pair(c, v));\n      }\n      else\n      {\n        vp.push_back(make_pair(c, v));\n      }\n    }\n\n    dfs(0, -1, -1, uf);\n\n    ll ans = 0;\n    reverse(all(vp));\n    for (int i = 0; i < vp.size(); i++)\n    {\n      if (vp[i].first == 'Q')\n      {\n        ans += uf.root(vp[i].second) + 1;\n        //cout << uf.root(vp[i].second) + 1 << endl;\n      }\n      else\n      {\n        marked[vp[i].second] = false;\n\n        uf.merge(pp[vp[i].second], vp[i].second);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint parent[100001];\nint ans[100001];\n\nvoid Init(int n){\n\n    for(int i=1;i<=n;++i)\n        ans[i] = parent[i];\n\n}\n\nint Find(int x){\n\n    return x==ans[x]?x:(ans[x]=Find(ans[x]));\n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    int N,Q;\n\n    cin >> N >> Q;\n\n    parent[1] = 1;\n\n    for(int i=2;i<=N;++i){\n\n        int x;\n\n        cin >> x;\n\n        parent[i] = x;\n\n    }\n\n    Init(N);\n\n    long long sum = 0;\n    vector<pair<char,int> > query(Q);\n\n    for(int i=0;i<Q;++i){\n\n        string str;\n        int x;\n\n        cin >> str >> x;\n\n        query[i] = make_pair(str[0],x);\n\n        if(str==\"M\") ans[x] = x;\n\n    }\n\n    for(int i=Q-1;i>=0;--i){\n\n        pair<char,int> p = query[i];\n\n        if(p.first == 'Q'){\n\n            sum += Find(p.second);\n\n        } else {\n\n            ans[p.second] = parent[p.second];\n\n        }\n\n    }\n\n    cout << sum << endl;\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef tuple<int,int> P;\ntypedef vector<int> V;\ntypedef vector<V> Graph;\n#define PB push_back\n\nstruct INIT{INIT(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto &it:v)\nvoid make_tree(int v,Graph& G,V& Par,V& D, Graph& C){\n    range(e,G[v]){\n\tif(e!=Par[v]){\n\t    C[v].PB(e);\n\t    D[e]=D[v]+1;\n\t    Par[e]=v;\n\t    make_tree(e,G,Par,D,C);\n\t}\n    }\n}\n\nvoid euler_tour(int v,Graph &C,vector<P>& seg,int &cnt){\n    int l=cnt++;\n    range(e,C[v])\n\teuler_tour(e,C,seg,cnt);\n    int r=cnt++;\n    seg[v]=P(l,r);\n}\n\n#define SIZE 1000000\n#define L(v) (v*2+1)\n#define R(v) (v*2+2)\n#define SET 0\n#define ADD 1\n#define GET 2\ntypedef P val;\nstruct node{\n    int bg,ed;\n    val v;\n    inline val getval(){\n\treturn v;\n    }\n    inline void init(int b,int e){\n\tbg =b,ed=e;\n\tv=val(-1,-1);\n    }\n    bool isleaf(){return bg==ed;}\n}mem[SIZE];\ninline val comb(val l,val r){\n\treturn max(l,r);\n    }\nclass segTree{\nprivate:node *t;\n    void make_tree(int bg,int ed,int v=0){\n\tnode *p=t+v;\n\tp->init(bg,ed);\n\tif(!p->isleaf()){\n\t    int m=(bg+ed)/2;\n\t    make_tree(bg,m,L(v));\n\t    make_tree(m+1,ed,R(v));\n\t}\n    }\npublic:\n    segTree(int bg,int ed):t(mem){make_tree(bg,ed);}\n    inline void lazy_update(int v){\n\tnode *p=t+v,*l=t+L(v),*r=t+R(v);\n\tif(p->isleaf())return;\n\tl->v=comb(p->v,l->v);\n\tr->v=comb(p->v,r->v);\n    }\n    val treat(int type,int bg,int ed,val x,int v=0){\n\tnode *p=t+v,*l=t+L(v),*r=t+R(v);\n\tlazy_update(v);\n\tif(P(bg,ed)==P(p->bg,p->ed)){\n\t    if(type==ADD)p->v=comb(p->v,x);\n\t    return p->v;\n\t}\n\tint m;\n\tval res=P(-1,-1);\n\tif(bg<=(m=min(ed,l->ed)))\n\t    res=comb(res,treat(type,bg,m,x,L(v)));\n\tif((m=max(bg,r->bg))<=ed)\n\t    res=comb(res,treat(type,m,ed,x,R(v)));\n\treturn res;\n    }\n    val get(int bg,int ed){\n\treturn treat(GET,bg,ed,val());\n    }\n    void add(int bg,int ed,val x){\n\ttreat(ADD,bg,ed,x);\n    }\n};\n\nconst int root=1;\nint main(){\n    for(int N,Q;cin>>N>>Q,N+Q;){\n\tGraph g(N+1),child(N+1);\n\tV depth(N+1,0),par(N+1,0);\n\tvector<P> seg(N+1);\n\tfor(int i=2;i<=N;i++){\n\t    int j;\n\t    cin>>j;\n\t    g[i].PB(j);\n\t    g[j].PB(i);\n\t}\n\tmake_tree(root,g,par,depth,child);\n\tint sz=0;\n\teuler_tour(root,child,seg,sz);\n\tsegTree tree(0,sz);\n\ttree.add(0,sz,P(0,root));\n\tlong long res=0;\n\twhile(Q--){\n\t    string op;int v;\n\t    cin>>op>>v;\n\t    int l,r;\n\t    tie(l,r)=seg[v];\n\t    if(op==\"M\"){\n\t\t    tree.add(l,r,P(depth[v],v));\n\t    }\n\t    else{\n\t\tint d,p;\n\t\ttie(d,p)=tree.get(l,l);\n\t\tcout<<p<<endl;\n\t\tres+=p;\n\t    }\n\t}\n\tcout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst long long int inf = 1e18;\n\n//range min\nstruct segmentTree{\n\tvector<long long int> node;\n\tint n;\n\t\n\tsegmentTree(vector<long long int> v){\n\t\tint s = v.size();\n\t\tn = 2;\n\t\twhile(n < s) n *= 2;\n\t\tnode = vector<long long int>(2*n -1, inf);\n\t\tfor(int i=0; i<s; i++){\n\t\t\tnode[i +n-1] = v[i];\n\t\t}\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tnode[i] = min(node[2*i +1], node[2*i +2]);\n\t\t}\n\t}\n\t\n\tvoid Set(long long int val, int pos){\n\t\tint idx = n-1 + pos;\n\t\tnode[idx] = val;\n\t\tdo{\n\t\t\tidx = (idx -1)/2;\n\t\t\tnode[idx] = min(node[2*idx +1], node[2*idx +2]);\n\t\t}while(idx != 0);\n\t}\n\tlong long int Get(int l, int r){\n\t\treturn _get(l, r, 0, 0, n);\n\t}\n\tlong long int _get(int l, int r, int k, int cl, int cr){\n\t\tif(l <= cl && cr <= r){\n\t\t\treturn node[k];\n\t\t}\n\t\tif(r <= cl || cr <= l){\n\t\t\treturn inf;\n\t\t}\n\t\tint m = (cl +cr)/2;\n\t\treturn min(_get(l, r, 2*k+1, cl, m), _get(l, r, 2*k+2, m, cr));\n\t}\n};\n\nlong long int solve(int node, int depth, vector<vector<int> > &tree, vector<vector<int> > &mark, vector<vector<int> > &query, segmentTree &segtree, vector<int> &tl){\n\tlong long int ret = 0;\n\tfor(int i=0; i<(int)query[node].size(); i++){\n\t\tret += tl[-segtree.Get(0, query[node][i])];\n\t}\n\tfor(int i=0; i<(int)mark[node].size(); i++){\n\t\tsegtree.Set(-depth, mark[node][i]);\n\t\ttl[depth] = node;\n\t}\n\tfor(int i=0; i<(int)tree[node].size(); i++){\n\t\tret += solve(tree[node][i], depth+1, tree, mark, query, segtree, tl);\n\t}\n\tfor(int i=0; i<(int)mark[node].size(); i++){\n\t\tsegtree.Set(0, mark[node][i]);\n\t\ttl[depth] = 0;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,q;\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > tree(n+1);\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tint par;\n\t\t\tcin >> par;\n\t\t\ttree[par].push_back(i);\n\t\t}\n\t\tvector<vector<int> > query(n+1), mark(n+1);\n\t\tmark[1].push_back(0);\n\t\tfor(int i=1; i<=q; i++){\n\t\t\tchar c;\n\t\t\tint node;\n\t\t\tcin >> c >> node;\n\t\t\tif(c=='Q') query[node].push_back(i);\n\t\t\telse mark[node].push_back(i);\n\t\t}\n\t\tsegmentTree segtree(vector<long long int>(n+1, inf));\n\t\tvector<int> timeline(n, 0);\n\t\tcout << solve(1, 0, tree, mark, query, segtree, timeline) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tll ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].count--;\n\t\t\t\tif (e[v[i]].count == 0) {\n\t\t\t\t\ttb[e[v[i]].m] = e[e[v[i]].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += tb[e[v[i]].m] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        map<int,int> marks;\n        marks.insert(make_pair(0,0));\n        marks.insert(make_pair(inf,inf));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q') ans += marks.lower_bound(-d)->second + 1;\n            else marks[-d] = qv[i];\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n            else h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+1];\nint n;\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init();\n    par[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tunite(par[num],num);\n\tsum += par[num]+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint find(vector<int> par, int k){\n  if(par[k] == k) return k;\n  return par[k] = find(par,par[k]);\n}\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N){\n    vector<int> par(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n    int p[N];\n    p[0] = 0;\n    for(int i = 1; i < N; ++i){\n      cin >> p[i];\n      par[i] = p[i]-1;\n    }\n    vector< pair<char,int> > Query;\n    char c;\n    int k;\n    for(int i = 0; i < Q; ++i){\n      cin >> c >> k;\n      --k;\n      if(c == 'M') par[k] = k;\n      Query.push_back(make_pair(c,k));\n    }\n    reverse(Query.begin(),Query.end());\n    int ans = 0;\n    for(int i = 0; i < Q; ++i){\n      c = Query[i].first;\n      k = Query[i].second;\n      if(c == 'Q'){\n\tans += find(par,k)+1;\n      }else{\n\tpar[find(par,k)] = par[p[par[find(par,k)]-1]];\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX_N 100002\n\n/* union find */\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める(あえて根の張りなおしをしない)\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    if(rank[x] < rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\nint N,Q, marked[MAX_N];\n\nint find_nearest_idx(int index) {\n    if(marked[index]) return index;\n    return find_nearest_idx(par[index]);\n}\n\nmain() {\n    while(1) {\n        scanf(\"%d %d\",&N,&Q);\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        init(N+2);\n        \n        marked[1] = 1; // node 1 is already marked \n        for(int i=2;i<=N;i++) {\n            int d;\n            scanf(\"%d\", &d);\n            par[i] = d; // parent of i is d\n            //unite(i,d);\n        }\n\n        // Question\n        int ans = 0;\n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            //scanf(\"%c %d\", &op, &index);\n            if(op == 'Q')\n                ans += find_nearest_idx(index);\n            else if(op == 'M')\n                marked[index] = 1;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nconst int p2=262144;\nint in[100000],out[100000],n,q;\nint seg[p2*2-1];\nvoid dfs(int v){\n\tin[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tout[v]=euler.size();\n\teuler.push_back(v);\n}\nbool anc(int x,int y){\n\treturn in[x]<in[y]&&out[x]>out[y];\n}\nvoid change(int a,int b,int c,int l,int r,int k){\n\tif(b<=l||r<=a) return;\n\tif(a<=l&&r<=b){\n\t\tif(seg[k]==-1||anc(seg[k],c) ) seg[k]=c;\n\t\treturn;\n\t}\n\tchange(a,b,c,l,(l+r)/2,k*2+1);\n\tchange(a,b,c,(l+r)/2,r,k*2+2);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,p2*2-1) seg[i]=-1;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t}\n\t\tdfs(0);\n\t\tlong long ans=0;\n\t\tchange(in[0],out[0]+1,0,0,p2,0);\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tchange(in[v],out[v]+1,v,0,p2,0);\n\t\t\t}else{\n\t\t\t\tint x=p2-1+in[v],ret=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(seg[x]!=-1 && anc(ret,seg[x])) ret=seg[x];\n\t\t\t\t\tif(x==0) break;\n\t\t\t\t\tx=(x-1)/2;\n\t\t\t\t}\n\t\t\t\tans+=(ret+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n//unionfind??????????????\\??????????????????????????´???\nstruct UnionFind {\n\tvector<int> to;\n\tvector<int> data;\n\tUnionFind(int size) : to(size, -1),data(size, -1) { }\n\t\n\t//??????x?????????y????¶????????????????(data[root(x | y)] = data[root(x)]???????????????)\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tint rootData = data[root(x)];\n\t\tif (x != y) {\n\t\t\tif (to[y] < to[x]) swap(x, y);\n\t\t\tto[x] += to[y]; to[y] = x;\n\t\t}\n\t\tsetData(x, rootData);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn to[x] < 0 ? x : to[x] = root(to[x]);\n\t}\n\tint size(int x) {\n\t\treturn -to[root(x)];\n\t}\n\n\tint findData(int x) {\n\t\treturn data[root(x)];\n\t}\n\tvoid setData(int x, int d) {\n\t\tdata[root(x)] = d;\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i]; v[i]--;\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a, int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tuf.unionSet(e[e[j].p].m, e[j].m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findData(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\n// lazy evaluate segment tree\ntypedef int data_type;\nconst data_type dINF = iINF;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\t//update_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\t//update_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn min(mn, d);\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d);\n\t\n\tlint ans = 0;\n\tfor_(i,1,N+1) cout << stl.query(i, i + 1) << \" \" << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q; int v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t\t\n\t\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x] ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tchk[x] = true;\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\t//for( auto i : memo ) cout << i << endl;\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_NODE = 100001;\n\nstruct Query {\n\tchar q;\n\tint v;\n};\n\nint parent(int uft[],bool mark[], int c) {\n\tif (mark[c] || uft[c] == c)return c;\n\treturn uft[c] = parent(uft, mark ,uft[c]);\n}\n\nint main() {\n\tint N, Q;\n\tint ans = 0;\n\tint uft[MAX_NODE] = { 0 };\n\tbool mark[MAX_NODE] = { 0 };\n\tQuery query[MAX_NODE];\n\n\tuft[1] = 1;\n\tmark[1] = true;\n\n\tcin >> N >> Q;\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> uft[i + 1];\n\t}\n\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> query[i].q >> query[i].v;\n\t\tif (query[i].q == 'M') {\n\t\t\tmark[query[i].v] = true;\n\t\t}\n\t}\n\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (query[i].q == 'M') {\n\t\t\tmark[query[i].v] = false;\n\t\t}\n\t\telse {\n\t\t\tans += parent(uft,mark, query[i].v);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100002\nusing namespace std;\n\nint n,q;\nvector<int> v[MAX];\nint marked[MAX]={};\n\nvoid dfs(int now,int a){\n  if(marked[now]==a || marked[now]==now)return;\n  marked[now]=a;\n  for(int i=0;i<v[now].size();i++){\n    dfs(v[now][i],a);\n  }\n}\n\nint main()\n{\n  char c;\n  int a;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<MAX;i++){\n      marked[i]=0;\n      v[i].clear();\n    }\n    for(int i=1;i<n;i++){\n      cin>>a;\n      v[a-1].push_back(i);\n    }\n    int ans=0;\n    for(int i=0;i<q;i++){\n      cin>>c>>a;\n      if(c=='Q'){\n\tans+=marked[a-1]+1;\n      }\n      else {\n\tdfs(a-1,a-1);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* Desciption:  union find\t\n* Created:    2016-02-21\n* Author:      JIngwei Xu [mail:xu_jingwei@outlook.com]\n*\n*/\n#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nchar s[5];\nconst int maxn=100000+7;\nint n,q,v;\nlong ans;\nint f[maxn];\nvoid init(){\n\tfor (int i = 1; i < n+7; i += 1)f[i]=i;\n\tans=0;\n}\nint find(int x){\n\tint r=x;\n\twhile (f[r]!=r)r=f[r];\n\treturn r;\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nint main()\n{\n\twhile (scanf(\"%d%d\",&n,&q)&&n)\n\t{\n\t\tinit();\n\t\tfor (int i = 2; i <=n; i += 1)scanf(\"%d\",&f[i]);\n\t\twhile (q--)\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\tscanf(\"%d\",&v);\n\t\t\tif(s[0]=='M')f[v]=v;\n\t\t\tif(s[0]=='Q')ans+=find(v);\n\t\t}\n\t\tprintf(\"%ld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nint n,q,f[100005],ans;\nbool mkd[100005];\nchar c[5],d;\nint main()\n{\n\tint i,a;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(!n) break;\n\t\tmemset(mkd,0,sizeof(mkd));ans=0;\n\t\tmkd[1]=true;\n\t\tfor(i=2;i<=n;i++) scanf(\"%d\",&f[i]);\n\t\tfor(i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"%s\",c);d=c[0];\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(d=='M') mkd[a]=true;\n\t\t\tif(d=='Q')\n\t\t\t{\n\t\t\t\tfor(;!mkd[a];a=f[a]);\n\t\t\t\tans+=a;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tmemset(r, false, sizeof(r));\n//\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX -((1ll<<30)-1)\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return RMQ_MAX;\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tif(maxi>=0&&maxi<(ll)idx_rev.size())ret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct uni {\n  int p[111111];\n  uni(){memset(p,-1,sizeof(p));}\n  int root(int a){return p[a]<0?a:(p[a]=root(p[a]));}\n  bool find(int a,int b){return root(a)==root(b);}\n  // aをbの親に\n  void merge(int a,int b){if(!find(a,b))p[root(b)]=root(a);}\n};\n\nint p[111111];\nint m[111111];\nint Q[111111];\nint Qm[111111];\nint Qi[111111];\nint Qc,Qmc;\nint main(void)\n{\n  int n,q;\n  long long res;\n  for(;;) {\n    scanf(\"%d%d\",&n,&q); if(n+q==0)return 0;\n    uni u;\n    memset(m,-1,sizeof(m));\n    res = 0;\n    Qc = 0;\n    Qmc = 0;\n    m[0] = 0;\n    for(int i = 0; i < n-1; i++) {\n      int a; scanf(\"%d\",&a);\n      p[i+1] = a-1;\n    }\n    for(int i = 0; i < q; i++) {\n      char c;int a; scanf(\" %c%d\",&c,&a);\n      --a;\n      Qi[Qc] = i;\n      if(c=='Q')Q[Qc++] = a;\n      else {\n        if(m[a] < 0) {\n          m[a] = i;\n          Qm[Qmc++] = i;\n        }\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      if(m[i]<0) u.merge(p[i],i);\n    }\n    while(Qmc--) {\n      while( Qc && Qi[Qc-1] > Qm[Qmc] ) {\n        Qc--;\n        res += u.root(Q[Qc])+1;\n      }\n      u.merge(p[Qm[Qmc]],Qm[Qmc]);\n    }\n    \n    res += Qc;\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n\nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    else\n\ty = root[x];\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n\nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n\nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n\nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\troot[query[i].second] = query[i].second;\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tunite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }        \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct unionfind{\n  vector<int> p;\n  unionfind(int n){\n    p = vector<int>(n, -1);\n  }\n  int root(int x){\n    if (p[x] == -1){\n      return x;\n    } else {\n      p[x] = root(p[x]);\n      return p[x];\n    }\n  }\n  void unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    p[x] = y;\n  }\n};\nint main(){\n  while (1){\n    int N, Q;\n    cin >> N >> Q;\n    if (N == 0 && Q == 0){\n      break;\n    }\n    vector<int> p(N, -1);\n    for (int i = 1; i < N; i++){\n      cin >> p[i];\n      p[i]--;\n    }\n    vector<pair<char, int>> query(Q);\n    vector<int> m(N, 0);\n    m[0]++;\n    for (int i = 0; i < Q; i++){\n      char c;\n      int v;\n      cin >> c >> v;\n      v--;\n      query[i] = make_pair(c, v);\n      if (c == 'M'){\n        m[v]++;\n      }\n    }\n    unionfind UF(N);\n    for (int i = 1; i < N; i++){\n      if (m[i] == 0){\n        UF.unite(i, p[i]);\n      }\n    }\n    long long ans = 0;\n    for (int i = Q - 1; i >= 0; i--){\n      char c = query[i].first;\n      int v = query[i].second;\n      if (c == 'Q'){\n        ans += UF.root(v) + 1;\n      } else {\n        m[v]--;\n        if (m[v] == 0){\n          UF.unite(v, p[v]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nvector<node> T;\nint main(){\n  while(1){\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    node root;\n    root.marked = true;\n    root.parent = 0;\n    root.num = 1;\n    T.push_back(root);\n    for(int i=2;i<n+1;i++){\n      int parent;\n      cin >> parent;\n      node child;\n      T.push_back(child);\n      T[i-1].marked = false;\n      T[i-1].num = i;\n      T[i-1].parent = parent-1;\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }\n      if(q=='Q'){\n        node n = T[v-1];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  par[1] = 1;\n  marked[1] = true;\n  for (int i = 2; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define maxn 100005\nusing namespace std;\n\nint pre[maxn],rank[maxn],vis[maxn];\n\nvoid init(int n)\n{\n    int i;\n    for(i=1;i<=n;i++)\n    {\n        pre[i]=i;\n        rank[i]=1;\n    }\n}\n\nint find(int x)\n{\n\n    while(!vis[x])\n        x=pre[x];\n    return x;\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF && (n||m))\n    {\n        memset(vis,0,sizeof(vis));\n        init(n);\n\n        for(int i=2;i<=n;i++)\n        {\n            int fat;\n            scanf(\"%d\",&fat);\n            pre[i]=fat;\n        }\n\n        int ans=0;\n        vis[1]=1;\n        while(m--)\n        {\n            char str[10];\n            int x;\n            scanf(\"%s%d\",str,&x);\n            if(str[0]=='Q')\n            ans+=find(pre[x]);\n            else vis[x]=1;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint find(vector<int> par, int k){\n  if(par[k] == k) return k;\n  return par[k] = find(par,par[k]);\n}\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N){\n    vector<int> par(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n    int p[N];\n    p[0] = 0;\n    for(int i = 1; i < N; ++i){\n      cin >> p[i];\n      --p[i];\n      par[i] = p[i];\n    }\n    vector< pair<char,int> > Query;\n    char c;\n    int k, count[N];\n    fill(count,count+N,0);\n    for(int i = 0; i < Q; ++i){\n      cin >> c >> k;\n      --k;\n      if(c == 'M'){\n\tpar[k] = k;\n\t++count[k];\n      }\n      Query.push_back(make_pair(c,k));\n    }\n    reverse(Query.begin(),Query.end());\n    int ans = 0;\n    for(int i = 0; i < Q; ++i){\n      c = Query[i].first;\n      k = Query[i].second;\n      if(c == 'Q'){\n\tans += find(par,k)+1;\n      }else{\n\t--count[k];\n\tif(!count[k])\n\t  par[k] = par[p[k]];\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define val first\n#define idx second\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vp;\n\n//Segment Tree\nclass SegmentTree{\n  int n;\n  vp node;\npublic:\n  SegmentTree(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    node = vp(2*n, pii(0,0));\n  }\n\n  void update_range(int a,int b,pii v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return;\n    if(a<=l && r<=b){\n      if(node[k]<v)node[k] = v;\n      return;\n    }\n    update_range(a,b,v,2*k+1,l,(l+r)/2);\n    update_range(a,b,v,2*k+2,(l+r)/2,r);\n  }\n\n  pii is_val(int k){\n    k += n-1;\n    pii res = node[k];\n    while(k>0){\n      k = (k-1)/2;\n      res = max(res,node[k]);\n    }\n    return res;\n  }\n};\n\nvoid dfs(int v, int d, vi &level, vi &tour, vp &interval,\n\t const vector<vi> &tree){\n  interval[v].first = tour.size();\n  tour.push_back(v);\n  level[v] = d;\n\n  for(int child : tree[v]){\n    dfs(child, d+1, level, tour, interval, tree);\n  }\n\n  tour.push_back(v);\n  interval[v].second = tour.size();\n}\n\nint main(){\n  int n,q,v;\n  char qtype;\n\n  while(scanf(\"%d%d\",&n,&q),n){\n    vector<vi> tree(n,vi());\n\n    rep(i,n-1){\n      scanf(\"%d\",&v); v--;\n      tree[v].push_back(i+1);\n    }\n\n    vi level(n,0), tour;\n    vp interval(n);\n    dfs(0,0,level,tour,interval,tree);\n\n    SegmentTree st(tour.size());\n    st.update_range(0,2*n,pii(0,0));\n\n    long long ans = 0;\n    rep(i,q){\n      cin >> qtype >> v; v--;\n      if(qtype == 'M'){\n\tst.update_range(interval[v].first, interval[v].second, pii(level[v], v));\n      }else{\n\tans += st.is_val(interval[v].first).second + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint parent[100001];\nint ans[100001];\n\nvoid Init(int n){\n\n    for(int i=1;i<=n;++i)\n        ans[i] = parent[i];\n\n}\n\nint Find(int x){\n\n    return x==ans[x]?x:(ans[x]=Find(ans[x]));\n\n}\n\nvoid Union(int x, int y){\n\n    ans[Find(x)] = Find(y);\n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    int N,Q;\n\n    cin >> N >> Q;\n\n    parent[1] = 1;\n\n    for(int i=2;i<=N;++i){\n\n        int x;\n\n        cin >> x;\n\n        parent[i] = x;\n\n    }\n\n    Init(N);\n\n    long long sum = 0;\n    vector<pair<char,int> > query(Q);\n\n    for(int i=0;i<Q;++i){\n\n        string str;\n        int x;\n\n        cin >> str >> x;\n\n        query[i] = make_pair(str[0],x);\n\n        if(str==\"M\")\n            ans[x] = x;\n\n    }\n\n    for(int i=Q-1;i>=0;--i){\n\n        pair<char,int> p = query[i];\n\n        if(p.first == 'Q'){\n\n            sum += Find(p.second);\n\n        } else {\n\n            Union(p.second,parent[p.second]);\n\n        }\n\n    }\n\n    cout << sum << endl;\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n  vector<bool> mark;\n  \n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    mark.resize(size,false);\n    for(int i=0;i<size;i++)makeSet(i);\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n\n  void unite(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n\n  void link(int x,int y){\n    if(rank[x]>rank[y]){\n      p[y]=x;\n    }\n    else {\n      p[x]=y;\n      if(rank[x]==rank[y]){\n\trank[y]++;\n      }\n    }\n  }\n\n  int findSet(int x){\n    if(x!=p[x]){\n      p[x]=findSet(p[x]);\n    }\n    return p[x];\n  }\n\n  void MarkNode(int x){\n    mark[x]=true;\n  }\n\n  int findmark(int x){\n    if(mark[x])return x+1;\n    return findmark(p[x]);\n  }\n};\n\nint main()\n{\n  int n,q,a,ans=0;\n  char Q;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n\n    DisjointSet ds=DisjointSet(n);\n\n    ds.MarkNode(0);\n\n    for(int i=1;i<n;i++){\n      cin>>a;\n      ds.link(i,a-1);\n    }\n    for(int i=0;i<q;i++){\n      cin>>Q>>a;\n      if(Q=='Q')ans+=ds.findmark(a-1);\n      else {\n\tds.MarkNode(a-1);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            if(a==1){ans++; continue;}\n            a=P[a-1];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m+1;}\n            }\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; break;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\t//h.clear();\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\n/*\n\n6 3\n1\n1\n2\n3\n3\nQ 5\nM 3\nQ 5\n\n10 3\n1\n1\n2\n3\n5\n5\n8\n9\n4\nQ 1\nM 3\nQ 2\n0 0\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y; // parent of x is y\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    long long int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, q, p[16][100000];\nbool m[100000];\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &q), n){\n\t\tp[0][0] = 0;\n\t\tmemset(m, 0, sizeof(m));\n\t\trep(i, n - 1) scanf(\"%d\", p[0] + i + 1), p[0][i + 1]--;\n\t\trep(i, 15) rep(j, n) p[i + 1][j] = p[i][p[i][j]];\n\t\tll ans = 0;\n\t\trep(it, q){\n\t\t\tchar c; int v;\n\t\t\tscanf(\" %c%d\", &c, &v);\n\t\t\tv--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tfor(int i = 15; i >= 0; i--) if(!m[p[i][v]]) v = p[i][v];\n\t\t\t\tif(!m[v]) v = p[0][v];\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tm[v] = 1;\n\t\t\t\tv = p[0][v];\n\t\t\t\twhile(!m[v]){\n\t\t\t\t\tm[v] = 1;\n\t\t\t\t\tv = p[0][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q;\nlong long int ans;\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\n// int find(int x) {\n//   if (par[x] == x) return x;\n//   else return par[x] = find(par[x]);\n// }\n\nint search(int x) {\n  // int a = par[x];\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n\n// void unite(int x, int y) {\n//   par[find(x)] = find(y);\n// }\n\n// bool same(int x, int y) {\n//   return find(x) == find(y);\n// }\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int N = 100005;\nint a[2][N];\nint temp;\nint sum;\n\nint find_ance(int index) {\n\t\n\tif (/*index == a[0][index]||*/a[1][index]==1) {\n\t\treturn index;\n\t}\n\telse {\n\t\treturn find_ance(a[0][index]);\n\t}\n}\n\nint main() {\n\tint n, q;\n\tchar op;\n\tint quest;\n\tsum = 0;\n\tcin >> n >> q;\n\ta[0][1] = 1;\n\ta[1][1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tcin >> a[0][i];\n\t\ta[1][i] = 0;\n\t}\n\n\twhile (true) {\n\t\tcin >> op >> quest;\n\t\ttemp = 0;\n\t\tif (op == '0'&&quest == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op == 'M') {\n\t\t\ta[1][quest] = 1;\n\t\t}\n\t\telse {\n\t\t\tsum += find_ance(quest);\n\n\t\t}\n\t}\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass EulerTour{\nprivate:\n    int n;\n    vector<vector<int> > g;\n    vector<vector<int> > ind;//各頂点のインデックス\n\n    void dfs(int now, int par){\n        ind[now].push_back(v.size());\n        v.push_back(now);\n        for(int i = 0; i < g[now].size(); i++){\n            if(g[now][i] != par){\n                dfs(g[now][i],now);\n            }\n        }\n        ind[now].push_back(v.size());\n        v.push_back(now);\n    }\n\npublic:\n    vector<int> v;//オイラーツアーの頂点\n    EulerTour(){}\n    EulerTour(vector<vector<int> > in, int root){\n        g = in;\n        n = g.size();\n        ind = vector<vector<int> > (n);\n        dfs(root, -1);\n    }\n    void show(){\n        rep(i,v.size())cout << \" \" << v[i]; cout << endl;\n    }\n    pii get_ind(int i){\n        if(i >= n)return pii(INF,INF);\n        return pii(ind[i][0], ind[i][1]);\n    }\n\n};\n\nclass LazySegmentTree{\n private:\n     int n;\n     vector<long long> node, lazy;\n     long long node_init = 0; // sum, max, update\n     //long long node_init = LINF; // min\n     //long long lazy_init = 0; // default\n     long long lazy_init = LINF; // min, update (存在しない値)\n\n     long long lazy_update(long long a,long long b){\n         //return a+b; // sum query\n         //return max(a,b); // max query\n         //return min(a,b); // min query\n         return b; // update query\n     }\n\n     long long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n         //return a + b; // min query\n         return b; // update query\n         //return b * (r-l); // sum query\n     }\n\n     long long combine(long long a,long long b){\n         //return a+b; // sum query\n         return max(a,b); // max query\n         //return min(a,b); // min query\n         //return b;\n     }\n\n public:\n     LazySegmentTree(){}\n     LazySegmentTree(vector<long long> in){\n         n = 1;\n         while(n < in.size())n <<= 1;\n         node = vector<long long>(2*n, node_init);\n         lazy = vector<long long>(2*n, lazy_init);\n         for(int i = n-1+in.size()-1; i >= 0; i--){\n             if(n-1 <= i)node[i] = in[i-(n-1)];\n             else node[i] = combine(node[i*2+1], node[i*2+2]);\n         }\n     }\n     void eval(int k, int l, int r){\n         if(lazy[k] != lazy_init){\n             //cout << k << \" \" << l << \" \" << r  << \" \"<< lazy[k] << endl;\n             node[k] = node_update(node[k], lazy[k], l, r);\n             //cout << k << \" \" << node[k] << endl;\n             if(r - l > 1){\n                 lazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n                 lazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n             }\n             lazy[k] = lazy_init;\n         }\n     }\n     void update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n         if(r < 0)r = n;\n         eval(k,l,r);\n         if(b <= l || r <= a)return;\n         if(a <= l && r <= b){\n             lazy[k] = x;\n             eval(k,l,r);\n         }else{\n             update(a,b,x,2*k+1,l,(l+r)/2);\n             update(a,b,x,2*k+2,(l+r)/2,r);\n             node[k] = combine(node[2*k+1], node[2*k+2]);\n         }\n     }\n     long long query(int a, int b, int k = 0, int l = 0, int r = -1){\n         if(r < 0)r = n;\n         //cout << \"!\"<<a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n         eval(k,l,r);\n         if(b <= l || r <= a)return node[k];\n         if(a <= l && r <= b)return node[k];\n         if(a <= l)return query(a,b,2*k+1,l,(l+r)/2);\n         else return query(a,b,2*k+2,(l+r)/2,r);\n         //return combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n     }\n     void show(){\n         cout << \"node :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << node[i];\n         }\n         cout << endl;\n         cout << \"node :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << i;\n         }\n         cout << endl;\n         /*\n         cout << \"lazy :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << lazy[i];\n         }\n         cout << endl;\n         */\n     }\n };\n\n\nsigned main(void) {\n    int n,q;\n    while(1){\n        scanf(\"%lld %lld\",&n,&q);\n        if(n == 0)return 0;\n        vector<vi> g(n);\n        loop(i,1,n){\n            int a;\n            scanf(\"%lld\",&a);\n            a--;\n            g[a].push_back(i);\n        }\n        EulerTour et(g,0);\n        LazySegmentTree lst(vi(2*n,0));\n        //et.show();\n        int ans = 0;\n        while(q--){\n            char s[5];\n            scanf(\"%s\",s);\n            int v;\n            scanf(\"%lld\",&v);\n            v--;\n            pii ind = et.get_ind(v);\n            //cout << ind.first << \" \" << ind.second << endl;\n            if(s[0] == 'M'){\n                lst.update(ind.first,ind.second,v);\n            }else{\n                //lst.show();\n                //cout << lst.query(ind.first,ind.second) << endl;\n                ans += lst.query(ind.first,ind.first+1)+1;\n                //lst.show();\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][18],ff[100000],ss[100000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,3){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\nstruct node {\n\tint id;\n\tint nearmark;\n\tint dis;\n\tvector<int>edges;\n};\nstruct aa{\n\tint id;\n\tint dis;\n};\n\n\nvector<node>nodes;\nvector<aa>aas;\nvoid dfs(const int nowid,const int nowdis,const int mark) {\n\tif (nodes[nowid].dis > nowdis) {\n\t\tnodes[nowid].dis = nowdis;\n\t\tnodes[nowid].nearmark = mark;\n\t\tfor (auto nextid : nodes[nowid].edges) {\n\t\t\t//dfs(nextid, nowdis + 1, mark);\n\t\t\taas.push_back(aa{ nextid,nowdis + 1 });\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tnodes.push_back( node{0,0,0,vector<int>() });\n\tfor (int i = 1; i < N; ++i) {\n\t\tint a; cin >> a; a--;\n\t\tnode anode{ i,nodes[a].nearmark,nodes[a].dis + 1,vector<int>{a} };\n\t\tnodes.push_back(anode);\n\t\tnodes[a].edges.push_back(i);\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tchar c; cin >> c;\n\t\tint n; cin >> n;\n\t\tn--;\n\t\tif (c == 'Q') {\n\t\t\tans += nodes[n].nearmark+1;\n\t\t}\n\t\telse {\n\t\t\tdfs(n, 0,n);\n\t\t\twhile (aas.size()) {\n\t\t\t\taa a(aas.back());\n\t\t\t\taas.pop_back();\n\t\t\t\tdfs(a.id, a.dis, n);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tint a, bb; cin >> a >> bb;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-INF;\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -INF;\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) {\n        buf.update((int)marked[pos],idx[pos]);\n    }\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) {\n        buf.update((int)marked[pos],-INF);\n    }\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\n\nstruct UnionFind {\nprivate:\n\tvector< int > data;\n\t\npublic:\n\tUnionFind(int _size) : data(_size, -1) {}\n\t\n\tbool unite(int _x, int _y) {\n\t\t_x = root(_x); _y = root(_y);\n\t\tif (_x != _y) {\n\t\t\tif (data[_y] < data[_x]) swap(_x, _y);\n\t\t\tdata[_x] += data[_y]; data[_y] = _x;\n\t\t}\n\t\treturn _x != _y;\n\t}\n\t\n\tbool same(int _x, int _y) { return root(_x) == root(_y); }\n\t\n\tint root(int _x) { return data[_x] < 0 ? _x : data[_x] = root(data[_x]); }\n\t\n\tint size(int _x) { return -data[root(_x)]; }\n};\n\nint N, Q, p[100010];\nchar q[100010];\nint mark[100010], v[100010];\nlint anc[100010];\n\nvoid solve() {\n\tUnionFind uf(N);\n\t\n\tfor_(i,0,N) if (!mark[i]) uf.unite(i, p[i]);\n\tfor_(i,0,N) if (mark[i]) anc[ uf.root(i) ] = i + 1;\n\t\n\tlint ans = 0;\n\t\n\tfor_rev(i,Q-1,0) {\n\t\tif (q[i] == 'M') {\n\t\t\t--mark[ v[i] ];\n\t\t\tif (!mark[ v[i] ]) {\n\t\t\t\tint tmp = anc[ uf.root(p[ v[i] ]) ];\n\t\t\t\tuf.unite(v[i], p[ v[i] ]);\n\t\t\t\tanc[ uf.root(v[i]) ] = tmp;\n\t\t\t}\n\t\t} else {\n\t\t\tans += anc[ uf.root(v[i]) ];\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tfor_(i,1,N) {\n\t\t\tscanf(\"%d\", &p[i]); --p[i];\n\t\t}\n\t\t\n\t\tminit(mark, 0);\n\t\tmark[0] = 1;\n\t\t\n\t\tfor_(i,0,Q) {\n\t\t\tscanf(\"%s %d\", &q[i], &v[i]); --v[i];\n\t\t\tif (q[i] == 'M') ++mark[ v[i] ];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long ll;\nstruct node{\n    ll id;\n    node* parent;\n    node* marked_parent;\n    ll h;\n    vector<node*> child;\n};\nint main(){\n   // freopen(\"/Users/shitian/Downloads/1.txt\",\"r\",stdin);\n    int n,q,p;\n    while(cin>>n>>q,n){\n        vector<node*>vec;\n        vector<int>marked(n,0);\n        for(int i=0;i<n;i++){\n            node* t=new node;\n            vec.push_back(t);\n        }\n        node* no=vec[0];\n        no->id=1;\n        no->parent=no;\n        no->h=1;\n        no->marked_parent=vec[0];\n        marked[0]=1;\n        for(int i=2;i<=n;i++){\n            cin>>p;\n            node* no=vec[i-1];\n            no->id=i;\n            no->parent=vec[p-1];\n            no->h=no->parent->h+1;\n            no->marked_parent=vec[0];\n            vec[p-1]->child.push_back(no);\n        }\n        ll ans=0;\n        for(int i=0;i<q;i++){\n            \n            char que;int num;\n            cin>>que>>num;\n            if(que=='M'){\n                marked[num-1]=1;\n                node* mp=vec[num-1];\n                queue<node*>que;\n                que.push(mp);\n                while(!que.empty()){\n                    node* now=que.front();\n                    que.pop();\n                   // cout<<\"now->id-1       \"<<now->id-1<<endl;\n                    if(marked[now->id-1]==1&&now->id!=num){\n                        continue;\n                    }\n                    now->marked_parent=mp;\n                   // cout<<\"now-id: \"<<now->id<<\"     mp->id: \"<<mp->id<<endl;\n                    for(int i=0;i<now->child.size();i++){\n                        que.push(now->child[i]);\n                    }\n                }\n            }\n            else{\n                ans+=vec[num-1]->marked_parent->id;\n            }\n        }\n        cout<<ans<<endl;;\n        vec.clear();\n        marked.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define int long long\ntypedef pair<char,int>P;\nint uni[100009],r[100009];\nint find(int a){\n    if(a!=uni[a])a=find(uni[a]);\n    return a;\n}\nbool same(int a,int b){\n    return find(a)==find(b);\n}\nvoid unit(int a,int b){\n    int c=find(a),d=find(b);\n    if(c==0||d==0)exit(1);\n    uni[d]=c;\n}\n \nint M[100007];\nvector<int>v[100007];\n \nvoid dfs(int x,int col){\n  if(M[x]!=-1)col=x;\n  uni[x]=col;\n  r(i,v[x].size()){\n    dfs(v[x][i],col);\n  }\n}\nint n,m,x,sum;\nvector<P>query;\nint xx[100009];\n\n\nmain(){\n  while(cin>>n>>m,n){\n    sum=0;\n    memset(uni,0,sizeof(uni));\n    memset(r,0,sizeof(r));\n    memset(M,-1,sizeof(M));\n    query.clear();\n    r(i,100007)v[i].clear();\n    r(i,n-1){\n      cin>>xx[i+2];\n      v[xx[i+2]].push_back(i+2);\n    }\n    xx[1]=1;\n    set<P>s;\n    r(i,m){\n      char c;\n      cin>>c>>x;\n      if(c=='M'&&s.count(P(c,x)))continue;\n      if(c=='M')M[x]=x;\n      s.insert(P(c,x));\n      query.push_back(P(c,x));\n    }\n    dfs(1,1);\n    reverse(query.begin(),query.end());\n    r(i,query.size()){\n      if(query[i].first=='Q') sum += find(query[i].second);\n      else{\n        unit(xx[query[i].second],query[i].second);\n      }\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n//< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy += max(seg[2 * k+1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl , vr);\n}\n\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root),cnum(V),place(V),id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v]+=dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v]+1;\n\t}\n\n\tvoid getid(const int v, const int p,int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tupdate(1, N, 0);\n\t\tvector<int>nums;\n\t\tnums.push_back(0);\n\t\tTree t(N,0);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tt.unite(a, i+1);\n\t\t}\n\t\tt.init();\n\t\tlong long int asum = 0;\n\t\twhile (Q--) {\n\t\t\tchar c;int  n;\n\t\t\tcin >> c >> n;\n\t\t\tconst int aplace = t.place[n];\n\t\t\tif (c == 'M') {\n\t\t\t\tupdate(aplace+1, aplace + t.cnum[n-1]+1, n-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans = get(aplace, aplace);\n\t\t\t\tasum += ans+1;\n\t\t\t}\n\t\t}\n\t\tcout << asum << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <memory.h>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nint N;\nint Q;\nbool marked[MAX_N + 4];\nint par[MAX_N + 4];\n\nint find(int x) {\n    if (marked[par[x]]) {\n        return par[x];\n    }\n    return find(par[x]);\n}\n\nint main() {\n    while (scanf(\"%d %d\", &N, &Q) != EOD && N > 0 && Q > 0) {\n        memset(marked, 0, sizeof(marked));\n        marked[1] = 1;\n        int res = 0;\n        int x;\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", &par[i]);\n        }\n        cin.ignore();\n        char operation;\n        int node;\n        for (int i = 0; i < Q; i++) {\n            scanf(\"%c %d\", &operation, &node);\n            if (operation == 'Q') {\n                res += find(node);\n            }\n            else {\n                marked[node] = 1;\n            }\n            cin.ignore();\n        }\n        printf(\"%d\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> par, rank;\n\n    UnionFind(int n) {\n        rep(n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    int find(int x) {\n        return ((par[x] == x) ? x : par[x] = find(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n        return;\n    }\n\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nvoid dfs(ll node, ll marked_par, UnionFind uf, vector<bool> marked, vector<ll> children[]){\n    if(marked[node]) marked_par = node;\n    else uf.unite(marked_par, node);\n    for(ll child: children[node]){\n        dfs(child, marked_par, uf, marked, children);\n    }\n}\n\nint main() {\n    ll n,q,node;\n    char c;\n    cin >> n >> q;\n    while(n || q){\n        vector<ll> children[n+1], parent(n+1, 1);\n        ll ans = 0;\n        reppp(i, 2, n+1){\n            cin >> node;\n            children[node].push_back(i);\n            parent[i] = node;\n        }\n\n        vector<Pll> query(q);\n        vector<bool> marked(n+1, false);\n        rep(q){\n            cin >> c >> query[i].second;\n            query[i].first = (c=='Q'?1:0);\n            if(c == 'M') marked[node] = true;\n        }\n        UnionFind uf = UnionFind(n+1);\n        dfs(1, 1, uf, marked, children);\n        for(int i=q-1;i>=0;--i){\n            if(query[i].first){\n                ans += uf.find(node);\n            }else{\n                uf.unite(parent[node], node);\n            }\n        }\n        cout << ans << endl;\n        cin >> n >> q;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt n,q;\nlnt queri[100000][2];\nbool marked[100000];\nlnt par[100000];\nvoid init(void)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t}\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\t\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tx=find(x);\n\ty=find(y);\n\tpar[x]=y;\n\treturn;\n}\n\nchar str[10];\nlnt anc[100000];\nlnt m;\nint main()\n{while(1){\n\tlnt ans=0;\n\tscanf(\"%lld%lld\",&n,&q);\n\tif(!n&&!q) return 0;\n\tmemset(marked,0,sizeof(marked));\n\tfor(lnt i=1;i<n;i++){\n\t\tscanf(\"%lld\",&anc[i]);\n\t\tanc[i]--;\n\t}\n\tmarked[0]=1;\n\tfor(lnt i=0;i<q;i++){\n\t\tscanf(\"%s%lld\",str,&queri[i][1]);\n\t\tqueri[i][1]--;\n\t\tif(*str=='M'){\n\t\t\tqueri[i][0]=1;\n\t\t\tmarked[queri[i][1]]=1;\n\t\t}\n\t\telse queri[i][0]=0;\n\t}\n\tfor(lnt i=0;i<n;i++){\n\t\tm=i;\n\t\twhile(!marked[m]&&!same(m,anc[m])){\n\t\t\tunite(m,anc[m]);\n\t\t\tm=anc[m];\n\t\t}\n\t}\n\tfor(lnt i=q-1;i>=0;i--){\n\t\tif(queri[i][0]){\n\t\t\tunite(queri[i][1],anc[queri[i][1]]);\n\t\t}\n\t\telse{\n\t\t\tm=queri[i][1];\n\t\t\twhile(m!=find(m)){\n\t\t\t\tm=anc[m];\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nint ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tint par = tree[i];\n\twhile(!ar[par])\n\t{\n\t\tpar = tree[par];\n\t}\n\treturn par;\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)&&(q+n)!=0){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tprintf(\" %c  %d\",query[i].first,query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t{\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] = 1;\n\t\t\telse \n\t\t\t\tsum += get(query[i].second);\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n#define MAXM 106\n#define MAXN 100006\n#define INF 2099999999\nusing namespace std;\nint n,m,fa[MAXN],a,caozuo[MAXN],ans;\nstruct node\n{\n\tchar p;\n\tint a;\n}work[MAXN];\nint root(int x)\n{\n\tif(fa[x]==x) return x;\n\tfa[x]=root(fa[x]);\n\treturn fa[x];\n};\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0&&m==0) return 0;\n\t\tans=0;\n\t\tfa[1]=caozuo[1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&caozuo[i]);\n\t\t\tfa[i]=caozuo[i];\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%c%d\",&work[i].p,&work[i].a);\n\t\t\tif(work[i].p=='M') fa[work[i].a]=work[i].a;\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(work[i].p=='M')\n\t\t\t\tfa[work[i].a]=caozuo[work[i].a];\n\t\t\telse\n\t\t\t\tans+=root(work[i].a);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll mini=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[mini]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001],mpar[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n  fill(mpar, mpar+N+1, 1);\n  \n  marked[1] = 1;\n  par[1] = 1;\n}\n\nint ans(int v){\n\n  //if(marked[par[v]] == 1) return mpar[v] = par[v];\n  //return mpar[v] = ans(par[v]);\n\n  while(marked[par[v]]==0)\n    v = par[v];\n  \n  return v;\n  \n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=2;i<=N;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<long long int> data;\n\tUnionFind(long long int size) : data(size, -1) { }\n\tbool unionSet(long long int x, long long int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(long long int x, long long int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tlong long int root(long long int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tlong long int size(long long int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tlong long int a[100002];\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nchar Ope[MAX_N];\nint Openum[MAX_N], Marked[MAX_N];\nvector<int> child[MAX_N];\n\nvoid mark(int x, int num) {\n  if(Marked[x] == x || Marked[x] == num) return;\n  Marked[x] = num;\n  for(int i = 0; i < child[x].size(); i++){\n    mark(child[x][i], num);\n  }\n}\n\nvoid solve() {\n  int ans = 0;\n  memset(Marked, 0, sizeof(Marked))\n  for(int i = 0; i < Q; i++){\n    char ope = Ope[i];\n    int num = Openum[i];\n    if(ope == 'M') mark(num, num);\n    else if(ope == 'Q') ans += Marked[num]+1;\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 0; i < N; i++) child[i].clear();\n    for(int i = 1; i < N; i++){\n      int par;\n      scanf(\"%d\", &par);\n      child[par].push_back(i);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nclass segment{\npublic:\n    int n;\n    int dat[MAX_SEG*2];\n    void init(int n_){\n        for(int i=0;i<2*MAX_SEG-1;++i)dat[i]=0;\n\n    }\n    void update(int a,int b,int x,int k=0,int l=0,int r=MAX_SEG){\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            dat[k]=max(dat[k],x);\n            return;\n        }\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n    int query(int k){\n        k+=MAX_SEG-1;\n        int ret=dat[k];\n        while(k){\n            k=(k-1)/2;\n            ret=max(ret,dat[k]);\n        }\n        return ret;\n    }\n};\n\nint N,M;\nvector<int> g[MAX_N+5];\nint depth[MAX_N+5];\nint par[20][MAX_N];\nint tin[2*MAX_N+5],tout[2*MAX_N+5];\nint k=0;\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    tin[v]=k++;\n    for(int u=0;u<g[v].size();++u)dfs(g[v][u],v,d+1);\n    tout[v]=k;\n}\nvoid fill_table(){\n    for(int i=0;i<19;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        int ans=0;\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        for(int i=0;i<N;++i)g[i].clear();\n        memset(par,0,sizeof(par));\n        for(int i=1;i<N;++i){\n            int p;\n            cin>>p;\n            p--;\n            g[p].PB(i);\n        }\n        k=0;\n        dfs(0,-1,0);\n        fill_table();\n        segment seg;\n        seg.init(N);\n        for(int t=0;t<M;++t){\n            char que;\n            int v;\n            cin>>que;\n            cin>>v;\n            v--;\n            if(que=='M'){\n                seg.update(tin[v],tout[v],depth[v]);\n            }\n            else{\n                int q=seg.query(tin[v]);\n                for(int i=19;i>=0;--i){\n                    if((depth[v]-q)>>i&1)v=par[i][v];\n                }\n                ans+=v+1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    HeavyLightDecomposition(int n_ = 0) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            const auto &ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\nint n,q;\nchar qt[100010];\nint qv[100010];\nHeavyLightDecomposition h;\n\nlong long solve(){\n    long long ans = 0;\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(cin >> n >> q, n){\n        h = HeavyLightDecomposition(n);\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            h.addEdge(par-1,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nint lank[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    par[i] = i;\n  }\n}\n\nint find(int x) {\n  if (par[x] == x || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(p.second);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tmarked[1] = true;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t\tmarked[i]= false;\n\t}\n}\nint getnode(int x){\n\tif(marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tlong long sum;\n\twhile(cin>>n>>q,n||q){\n\t\tinit(n);\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\tsum +=getnode(par[k]);\n\t\t\t}\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t\tcout <<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, q, p[17][100000];\nbool m[100000];\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &q), n){\n\t\tmemset(m, 0, sizeof(m));\n\t\trep(i, n - 1) scanf(\"%d\", p[0] + i + 1), p[0][i + 1]--;\n\t\trep(i, 16) rep(j, n) p[i + 1][j] = p[i][p[i][j]];\n\t\t\n\t\tll ans = 0;\n\t\trep(it, q){\n\t\t\tchar c; int v;\n\t\t\tscanf(\" %c%d\", &c, &v);\n\t\t\tv--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tfor(int i = 16; i >= 0; i--) if(!m[p[i][v]]) v = p[i][v];\n\t\t\t\tif(!m[v]) v = p[0][v];\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tm[v] = 1;\n\t\t\t\tv = p[0][v];\n\t\t\t\twhile(!m[v]){\n\t\t\t\t\tm[v] = 1;\n\t\t\t\t\tv = p[0][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint tpar[100000],par[100000];\nbool mark[100000];\nint search(int a){\n    if(mark[a]) return a;\n    else return search(tpar[a]);\n}\nint find(int a){\n    if(par[a]==a) return a;\n    else return par[a]=find(par[a]);\n}\nvoid unite(int a,int b){\n    par[find(a)]=find(b);\n}\nint main(){\n    int N,Q;\n    for(;;){\n        scanf(\"%d %d\\n\",&N,&Q);\n        if(N==0 && Q==0) break;\n        tpar[0]=0;\n        int p;\n        for(int i=1;i<N;i++){\n            scanf(\"%d\\n\",&p);\n            tpar[i]=p-1;\n        }\n        fill(mark,mark+N,false);\n        mark[0]=true;\n        char q;\n        int a;\n        vector<pair<char,int>> query;\n        for(int i=0;i<Q;i++){\n            scanf(\"%c %d\\n\",&q,&a);\n            a--;\n            query.PB(MP(q,a));\n            if(q=='M') mark[a]=true;\n        }\n        for(int i=0;i<N;i++){\n            par[i]=search(i);\n        }\n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            int now=query[i].second;\n            if(query[i].first=='Q') ans+=find(now)+1;\n            else unite(find(now),tpar[find(now)]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define N 100010\n\nint a[N];\n\nlong long Find(int x){\n\treturn a[x]==x? a[x]:Find(a[x]);\n}\n\nint main(){\n\twhile(true){\n\t\tint n,q;\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(!(n||q))\n\t\t\tbreak;\n\t\ta[1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tscanf(\"%d\",a+i);\n\t\tlong long ans=0ll;\n\t\twhile(q--){\n\t\t\tchar tmp[10]={};\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\",tmp,&x);\n\t\t\tif(*tmp=='Q')\n\t\t\t\tans+=Find(x);\n\t\t\telse\n\t\t\t\ta[x]=x;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nstruct UF\n{\n\tvector<int> par; // ???\n\t// ?????????\n\tUF(int n):par(n) {\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t// ??¨??????????±???????\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// x??¨y????±??????????????????????\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\t// ??¨??????????????????????????£??¨??????????????????\n\t\tpar[x] = y;\n\t}\n\t// x??¨y?????????????????????true\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\nstruct node\n{\n\tint par;\n\tvector<int> chi;\n};\n\nbool me[100100];\n\nint main()\n{\n\tint n,q;\n\tcin >> n >> q;\n\t\n\tUF uf(n+1);\n\t\n\tvector<node> v(n+1);\n\tv[1].par = 1;me[1] = true;\n\t\n\t\n\tREP(i,n-1)\n\t{\n\t\tint tmp;cin >> tmp;\n\t\tv[tmp].chi.PB(i+2);\n\t\tv[i+1].par = tmp;\n\t}\n\t\n\tvector<pair<char,int> > p;\n\t\n\tREP(i,q)\n\t{\n\t\tchar c;int num;\n\t\tcin >> c >> num;\n\t\tif(c == 'M')\n\t\t{\n\t\t\tif(me[num])continue;\n\t\t\tme[num] = true;\n\t\t}\n\t\tp.PB(MP(c,num));\n\t}\n\t\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tif(me[i])\n\t\t{\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(i);\n\t\t\twhile(!Q.empty())\n\t\t\t{\n\t\t\t\tint tmp = Q.front();Q.pop();\n\t\t\t\t\n\t\t\t\tREP(j,v[tmp].chi.size())\n\t\t\t\t{\n\t\t\t\t\tif(me[v[tmp].chi[j]])continue;\n\t\t\t\t\tuf.unite(v[tmp].chi[j],i);\n\t\t\t\t\tQ.push(v[tmp].chi[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\tREP(i,n)\n\t{\n\t\tcout << uf.find(i+1) << ' ';\n\t}cout << endl;\n\t*/\n\t\n\tll ans = 0;\n\t\n\tfor(int i = p.size()-1;i >= 0;--i)\n\t{\n\t\tif(p[i].FI == 'Q')\n\t\t{\n\t\t\tans += uf.find(p[i].SE);\n\t\t\tcout << uf.find(p[i].SE) << endl;;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuf.unite(p[i].SE,v[p[i].SE].par);\t\t\t\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(k),rank(k)\n    {\n        n=k;\n        for(int i=0;i<n;i++) par[i]=i;\n        for(int i=0;i<n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n      //  for(int i=0;i<c[x].size();i++)\n        {\n           // if(m[c[x][i]]) par[c[x][i]]=c[x][i];\n           // else           par[c[x][i]]=x;\n    //        furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Marked Ancestor: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170\n// ????????????: 60???~\n// ?§£???: ?????¨???????????????????????´????????????????????¨??????????????????????????????????????£???????????£??????\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct RecentMarkedTree {\n  vector<int> parents;\n  vector<int> checkers;\n\n  RecentMarkedTree(int n) : parents(n, 0), checkers(n, 0) { }\n\n  void mark(const vector<bool>& marked) {\n    vector<vector<int>> children(parents.size());\n\n    for(int i = 1; i < parents.size(); i++) {\n      children[parents[i]].push_back(i);\n    }\n\n    queue<pair<int, int>> que;\n    for(que.push(make_pair(0, 0)); !que.empty(); que.pop()) {\n      int p = que.front().first, c = que.front().second;\n\n      if(marked[p]) {\n        c = p;\n      }\n\n      checkers[p] = c;\n\n      for(auto child : children[p]) {\n        que.push(make_pair(child, c));\n      }\n    }\n  }\n\n  void unmark(int p) {\n    while(true) {\n      if(checkers[p] == p) {\n        checkers[p] = checkers[parents[p]];\n        break;\n      } else {\n        p = checkers[p];\n      }\n    }\n  }\n};\n\nint main() {\n  for(int N, M; cin >> N >> M && N; ) {\n    RecentMarkedTree tree(N);\n\n    for(int i = 0; i < N - 1; i++) {\n      cin >> tree.parents[i];\n      tree.parents[i] -= 1;\n    }\n\n    vector<bool> marked(N, false);\n    vector<pair<char, int>> MQ;\n\n    for(int i = 0; i < M; i++) {\n      char c;\n      int num;\n\n      cin >> c >> num;\n\n      if(c == 'M') {\n        marked[num - 1] = true;\n      }\n\n      MQ.push_back(make_pair(c, num - 1));\n    }\n\n    tree.mark(marked);\n\n    reverse(MQ.begin(), MQ.end());\n\n    int answer = 0;\n\n    for(auto mq : MQ) {\n      if(mq.first == 'Q') {\n        answer += tree.checkers[mq.second];\n      } else {\n        tree.unmark(mq.second);\n      }\n    }\n\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(void){\n  int n=0;\n  int q=0;\n  scanf(\"%d%d\",&n,&q);\n  while(n!=0){\n    int tree[100005][2]={0};\n    tree[1][1]=1;\n    int ans=0;\n    int i=0;\n    for(i=2;i<=n;i++){\n      scanf(\"%d\",&(tree[i][0]));\n    }\n\n    char zi=0;\n    int no=0;\n    for(i=0;i<q;i++){\n      scanf(\"%s%d\",&zi,&no);\n      if(zi=='M'){\n\ttree[no][1]=1;\n      }\n      else if(zi=='Q'){\n\twhile(tree[no][1]==0){\n\t  \n\t  no=tree[no][0];\n\t   }\n\tans+=no;\n\tno=0;\n      }\n    }\n    /*for(i=1;i<=n;i++){\n      printf(\"%d%d\\n\",tree[i][0],tree[i][1]);\n      }*/\n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&q);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int np,bool f){\n  p[v]=np;\n  if(!f){\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],np,!m[v]);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    long long s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tm[v]=true;\n\tfor(int i=0;i<t[v].size();i++){\n\t  dfs(t[v][i],v,true);\n\t}\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\nstruct SkewHeap{\n\tSkewHeap *l,*r;\n\tint val;\n};\n\nSkewHeap* meld(SkewHeap* a, SkewHeap* b) {\n    if (a==NULL) return b;\n    if (b==NULL) return a;\n    if (a->val < b->val) swap(a, b);\n    a->r = meld(a->r, b);\n\tstd:: swap(a->l, a->r);\n    return a;\n}\nSkewHeap* insert(SkewHeap* a,int v) {\n    SkewHeap* b=new SkewHeap;\n\tb->l=b->r=NULL;\n\tb->val=v;\n\treturn meld(a,b);\n}\nint getmax(SkewHeap* a){\n\treturn a->val;\n}\nSkewHeap* pop(SkewHeap* a){\n\tSkewHeap* res = meld(a->l,a->r);\n\tdelete a;\n\treturn res;\n}\nvoid del(SkewHeap* a){\n\tif(a->l)del(a->l);\n\tif(a->r)del(a->r);\n\tdelete a;\n}\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nSkewHeap* bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u]=meld(bh[u],bh[edge[u][i]]);\n\t\tbh[edge[u][i]]=NULL;\n\t}\n\tint t=marked[u];\n\twhile(bh[u] && t<getmax(bh[u])){\n\t\tans+=u+1;\n\t\tbh[u]=pop(bh[u]);\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)if(bh[i]){\n\t\t\tdel(bh[i]);\n\t\t\tbh[i]=NULL;\n\t\t}\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v]=insert(bh[v],i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool vis[100000], marked[100000];\nint qtype[100000], vertex[100000];\n\nint par[100000], pp[100000];\n\nvoid init()\n{\n\tfor (int i = 0; i < 100000; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return (x);\n\treturn (par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x != y){\n\t\tpar[y] = x;\n\t}\n}\n\nvoid dfs(int v, int p, int m)\n{\n\tint nm = m;\n\tif (marked[v]) nm = v;\n\tpp[v] = p;\n\t\n\tmerge(nm, v);\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tdfs(G[v][i], v, nm);\n\t}\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\twhile (scanf(\"%d %d\", &N, &Q) && N){\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\t\n\t\tfor (int i = 1; i < N; i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tG[--v].push_back(i);\n\t\t}\n\t\t\n\t\tinit();\n\t\t\n\t\tmemset(marked, 0, sizeof(marked));\n\t\tmarked[0] = true;\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tchar t[10];\n\t\t\tscanf(\"%s %d\", t, vertex + i);\n\t\t\tqtype[i] = (t[0] == 'Q');\n\t\t\t--vertex[i];\n\t\t\tif (!qtype[i]) marked[vertex[i]] = true;\n\t\t}\n\t\t\n\t\tdfs(0, -1, -1);\n\t\t\n\t\tlong long int ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--){\n\t\t\tif (qtype[i]){\n\t\t\t\tans += find(vertex[i]) + 1;\n\t\t\t}\n\t\t\telse merge(pp[vertex[i]], vertex[i]);\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint pa[100000+10];\n\nint find(int v)\n{\n    if(pa[v]==v)\n    return v;\n    return find(pa[v]);\n}\n\nint main()\n{\n    int n,q,a,b;\n    while(~scanf(\"%d%d\",&n,&q))\n    {\n        if(n==0&&q==0)\n        break;\n        for(int i=2;i<=n;i++)\n        scanf(\"%d\",&pa[i]);\n        pa[1]=1;\n        long long sum=0;\n        char s[5];\n        while(q--)\n        {\n            scanf(\"%s%d\",s,&b);\n            if(s[0]=='Q')\n            sum=sum+find(b);\n            else\n            pa[b]=b;\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<ll> uft;\n\nll parent(ll a){\n    if(uft[a]==a){return a;}\n    return uft[a]=parent(uft[a]);\n}\n\n\n\n\nint main(){\n    ll n,q;\n    while(cin>>n>>q){\n        if(n==0){break;}\n    uft.resize(n);\n    for(int i=0;i<n;i++){uft[i]=i;}\n    vector<ll> color(n,0);\n    vector<ll> P(n,0);\n    for(int i=1;i<n;i++){cin>>P[i]; P[i]--;}\n    color[0]=1;\n    vector<pll> com(q);\n    for(auto &i:com){\n        char c;\n        cin>>c>>i.S;\n        i.F=(c=='M'?1:0);\n        i.S--;\n        if(c=='M'){color[i.S]++;}\n    }\n    reverse(com.begin(),com.end());\n    for(ll i=n-1;i>0;i--){\n        if(color[i]==0){uft[parent(i)]=parent(P[i]);}\n    }\n    ll ans=0;\n    for(auto &i:com){\n        if(i.F==1){\n            color[i.S]--;\n            if(color[i.S]==0){uft[parent(i.S)]=parent(P[i.S]);}\n        }\n        else{\n            ans+=parent(i.S)+1;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(long long i=0; i<(n); i++)\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\n\nint main(){\n    while(true){\n        ll n, q; cin >> n >> q;\n        if(n == 0 && q == 0) break;\n        vector<ll> tree(n+1, -1);\n        map<ll,ll> ismarked;\n        tree[1] = 0;\n        rep(i, n-1){\n            ll p; cin >> p;\n            tree[i+2] = p;\n        }\n        ismarked[1] = 1;\n        ll res = 0;\n        rep(i, q){\n            char id; cin>>id;\n            ll v; cin >> v;\n            if(id == 'M'){\n                ismarked[v] = 1;\n            }else{\n                if(ismarked[v] > 0){\n                    res += v;\n                    continue;\n                }\n                ll w = tree[v];\n                while(ismarked[w] == 0){\n                    w = tree[w];\n                }\n                res += w;\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\nvoid setLevel(int i, int n)\n{\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\t//cout << \"nearest \" << p << \", \" << n.second << endl;\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t\tchild[1][i].clear();\n\t\tparent[0][i]=0;\n\t\tparent[1][i]=0;\n\t\tlevel[i]=0;\n\t\tnearest[i]=P(0,0);\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\tchild[0][p].push_back(i);\n\t}\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\nfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}//*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tLL sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss,*height,*boss;\n\nstruct Info{\n\tvector<int> Children;\n};\n\nInfo*info;\n\nint get_boss(int id){\n\n\n\n}\n\n//new_boss_id??¨????????????????????????new_boss_id?????¨?§????????????????????????°???????????????new_boss?????????\nvoid update(int new_marked_boss_id){\n\n\tint current_boss_id = marked_boss[new_marked_boss_id],id;\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < info[new_marked_boss_id].Children.size();i++){\n\t\t//if(marked_boss[info[new_marked_boss_id].Children[i]] == current_boss_id){ //????????????????????????????????¨??????????????????????????????????????????????????????????????????\n\t\t\tmarked_boss[info[new_marked_boss_id].Children[i]] = new_marked_boss_id;\n\t\t\tQ.push(info[new_marked_boss_id].Children[i]);\n\t\t//}\n\t}\n\n\twhile(!Q.empty()){\n\t\tid = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i < info[id].Children.size();i++){\n\t\t\t//if(marked_boss[info[id].Children[i]] == current_boss_id){ //????????????????????????????????¨??????????????????????????????????????????????????????????????????\n\t\t\t\tmarked_boss[info[id].Children[i]] = new_marked_boss_id;\n\t\t\t\tQ.push(info[id].Children[i]);\n\t\t\t//}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint Q,value;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\tboss = new int[100001];\n\theight = new int[100001];\n\tinfo = (Info*)malloc(sizeof(Info)*(100001));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tmarked_boss[i] = 1;\n\t\t\tboss[i] = i;\n\t\t\theight[i] = 0;\n\t\t\tinfo[i].Children.clear();\n\t\t}\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tboss[i] = value;\n\t\t\tinfo[value].Children.push_back(i); //value?????????i???????????????\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < Q; i++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){ //?????¨???\n\t\t\t\tans += marked_boss[value];\n\t\t\t}else{ //???????????????\n\t\t\t\tupdate(value);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint p[100000], par[100000], t[100000];\nint find(int x) {\n\tif (x == par[x])return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tpar[find(x)] = find(y);\n}\nchar s[100000][2], m[100000];\nint main() {\n\tint n, q;\n\twhile (scanf(\"%d%d\", &n, &q), n) {\n\t\trep(i, n)par[i] = i;\n\t\trep(i, n - 1)scanf(\"%d\", &p[i + 1]), p[i + 1]--;\n\t\tmemset(m, -1, sizeof(m)); m[0] = -2;\n\t\trep(i, q) {\n\t\t\tscanf(\"%s%d\", s[i], &t[i]); t[i]--;\n\t\t\tif (s[i][0] == 'M') {\n\t\t\t\tif (m[t[i]] == -1)m[t[i]] = i;\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (m[i] == -1)unite(i, p[i]);\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (s[i][0] == 'M') {\n\t\t\t\tif (m[t[i]] == i)unite(t[i], p[t[i]]);\n\t\t\t}\n\t\t\telse ans += find(t[i]) + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ndouble zero(double d) {\n    return d < EPS ? 0.0 : d;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    return os << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    rep(i, a.size()) os << (i ? \" \" : \"\") << a[i];\n    return os << ']';\n}\n\n// to avoid error on mingw\nstring toString(int i) {\n    stringstream ss;\n    ss << i;\n    return ss.str();\n}\n\nconst int M = 1000000007;\n// a^k\nll fpow(ll a, ll k, int M) {\n    ll res = 1ll;\n    ll x = a;\n    while (k != 0) {\n        if ((k & 1) == 1)\n            res = (res * x) % M;\n        x = (x * x) % M;\n        k >>= 1;\n    }\n    return res;\n}\n\nclass UnionFind {\nprivate:\n    vi rank;\n\npublic:\n\n    int find(int x) {\n        if(par[x] == x)\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\n    vi par;\n\n    UnionFind(int n) {\n        rep(i,n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    // ??????x????????????????????????????????????\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n\n        par[y] = x;\n        if(rank[x] == rank[y])\n            rank[x]++;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(8);\n    ios_base::sync_with_stdio(false);\n\n    int N, Q;\n    while(cin >> N >> Q, (N|Q)) {\n        vi parents(N-1);\n        rep(i, N-1) {\n            int t;\n            cin >> t;\n            parents[i] = (--t);\n        }\n\n        vector< pair<char, int> > queries;\n        vector<bool> marked(N-1, false);\n        marked[0] = true;\n        rep(i, Q) {\n            char c;\n            int t;\n            cin >> c >> t;\n            t--;\n            if(c == 'M') {\n                if(! marked[t])\n                    queries.push_back(mp(c,t));\n                marked[t] = true;\n            }\n            else {\n                queries.push_back((mp(c,t)));\n            }\n        }\n\n        // ?????????????????????????????????????????¨????????????\n        // ?¬¬????????°??????????????????????????????????????????\n        UnionFind uf(N-1);\n        rep(i, N-1) {\n            if(! marked[i])\n                uf.unite(parents[i], i);\n        }\n\n        // ?????¨???????????????\n        reverse(all(queries));\n\n        int res = 0;\n        tr(it, queries) {\n            char c = it->first;\n            int t = it->second;\n\n            // ??????????????????\n            if(c=='M') {\n                // ?????¨unite????¬¬????????°??????????????????????????????????????????\n                uf.unite(parents[t], t);\n            }\n            else {\n                int ans = uf.find(t);\n                res += ans + 1;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w[2];\n\n\twhile(cin>>n>>q&&n){\n\n\tfor(int i=1;i<n;i++){\n\t\tscanf_s(\"%d\",&z);z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\tcout<<\"#\"<<endl;\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tscanf_s(\"%s%d\",w,&z);z--;\n\n\t\tif(w[0]=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\telse{\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void print() {\n    for (int i = 0; i < par.size(); i++) cerr << find(i) << \" \";\n    cerr << endl;\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nvoid dfs(int idx, int par) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(par, idx);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par);\n  }\n}\n\nLL solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  marked = vector<bool>(N);\n  marked[0] = true;\n  for (int i = 0; i < Q; i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  tree = UnionFindTree(N);\n  dfs(0, -1);\n\n  //tree.print();\n\n  LL res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  //tree.print();\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    LL ans = solve(N, Q, parent, queries);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree{\n\tstatic const int N_MAX=1<<17;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tvoid update_min(int l,int r,int a,int b,int u,T v){\n\t\tif(l<=a && b<=r){ dat[u]=min(dat[u],v); return; }\n\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) update_min(l,r,a,c,2*u,v);\n\t\tif(l<b && c<r) update_min(l,r,c,b,2*u+1,v);\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update_min(int l,int r,T v){ update_min(l,r,0,n,1,v); }\n\n\tT query(int u){\n\t\tu+=n;\n\t\tT res=dat[u];\n\t\tfor(u/=2;u>=1;u/=2) res=min(res,dat[u]);\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tfor(int n,q;scanf(\"%d%d\",&n,&q),n;){\n\t\tstatic vector<int> T[100000]; // tree\n\t\trep(u,n) T[u].clear();\n\t\trep(i,n-1){\n\t\t\tint u,v=i+1; scanf(\"%d\",&u); u--;\n\t\t\tT[u].push_back(v);\n\t\t}\n\n\t\t// euler tour technique\n\t\tstatic int start[100000],end[100000];\n\t\tint idx=0;\n\t\tstack< pair<int,int> > D; D.push(make_pair(0,0));\n\t\twhile(!D.empty()){\n\t\t\tint u=D.top().first,type=D.top().second; D.pop();\n\t\t\tif(type==0){ // in\n\t\t\t\tstart[u]=idx++;\n\t\t\t\tD.push(make_pair(u,1));\n\t\t\t\trep(i,T[u].size()) D.push(make_pair(T[u][i],0));\n\t\t\t}\n\t\t\telse{ // out\n\t\t\t\tend[u]=idx;\n\t\t\t}\n\t\t}\n\n\t\tstatic int f[100000]; // f : start[u] -> u\n\t\trep(u,n) f[start[u]]=u;\n\n\t\tstatic segment_tree<int> S;\n\t\tS.build(n,0);\n\n\t\tll ans=0;\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint u; scanf(\" %c%d\",&c,&u); u--;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=f[-S.query(start[u])]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tS.update_min(start[u],end[u],-start[u]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fi first\n#define Se second\n#define bug(x) cerr<<#x<<'='<<x<<' '\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define FOR(a,b,c) for(int a=(b),a##_end=(c);a<=a##_end;++a)\n#define ROF(a,b,c) for(int a=(b),a##_end=(c);a>=a##_end;--a)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int INF=0x3f3f3f3f,N=1e5+10;\ntemplate<class T>inline bool chkmin(T& A,T B){return B<A?A=B,1:0;}\ntemplate<class T>inline bool chkmax(T& A,T B){return A<B?A=B,1:0;}\nint n,m,op[N],u[N],fa[N],vis[N];\nint par[N];\nint Find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=Find(par[x]);\n}\nint main(){\n\tchar s[10];\n\twhile(scanf(\"%d%d\",&n,&m),n||m){\n\t\tll ans=0;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(par,0,sizeof(par));\n\t\tfa[1]=1;\n\t\tFOR(i,2,n)scanf(\"%d\",&fa[i]);\n\t\tFOR(i,1,m){\n\t\t\tscanf(\"%s%d\",s+1,&u[i]);\n\t\t\tif(s[1]=='M')op[i]=1,par[u[i]]=u[i],++vis[u[i]];\n\t\t\telse op[i]=2;\n\t\t}\n\t\tFOR(i,1,n)if(!par[i])par[i]=fa[i];\n\t\tROF(i,m,1)\n\t\t\tif(op[i]==1){\n\t\t\t\tif(!(--vis[u[i]]))par[u[i]]=Find(fa[u[i]]);\n\t\t\t}\n\t\t\telse ans+=Find(u[i]);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\t//dfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000,MAX_Q=100000;\n\nint N,Q;\nint p[MAX_N];\nchar q[MAX_Q+1];\nint v[MAX_Q];\n\nint colored[MAX_N];\t//?????????????????°\n\nvector<int> out;\n\nint find(int i){\n\t//?????????i?????????????????????????????????????????????\n\tif (colored[i]){\n\t\treturn i;\n\t}\n\treturn p[i]=find(p[i]);\n}\n\nint solve(){\n\t//?????¨?????????????????????\n\tfill(colored,colored+N,0);\n\tcolored[0]=1;\t//????????????????????????????????????\n\tfor (int i=0;i<Q;i++){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]++;\n\t\t}\n\t}\n\tint sum=0;\n\tfor (int i=Q-1;i>=0;i--){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]--;\n\t\t}\n\t\telse{\n\t\t\tsum+=(p[v[i]]=find(p[v[i]]))+1;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif (N || Q){\n\t\t\tp[0]=0;\n\t\t\tfor (int i=0;i<N-1;i++){\n\t\t\t\tscanf(\"%d\",&p[i+1]);\n\t\t\t\tp[i+1]--;\n\t\t\t}\n\t\t\tfor (int i=0;i<Q;i++){\n\t\t\t\tscanf(\" %c %d\",&q[i],&v[i]);\n\t\t\t\tv[i]--;\n\t\t\t}\n\t\t\tfprintf(stderr,\"debug\\n\");\n\t\t\tout.push_back(solve());\n\t\t}\n\t}while(N || Q);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%d\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(x);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nbool marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tscanf(\"%d\",fa+i);\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;marked[id]=1;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nconst int MAX_N = 100000;\n\nint _par[MAX_N];\n\nint ancestor(vector<int>& parents, vector<bool>& marked, int u){\n    int& p = parents[u];\n    if(marked[p])\n        return _par[u] = p;\n    return _par[u] = ancestor(parents, marked, p);\n}\n\nvoid init(vector<int>& parents, vector<bool>& marked){\n    int n = marked.size();\n    for(int i=0; i<n; i++)\n        _par[i] = i;\n    \n    for(int i=1; i<n; i++){\n        if(!marked[i] && _par[i]==i)\n            ancestor(parents, marked, i);\n    }\n}\n\nint root(int u){\n    if(_par[u] == u)\n        return u;\n    return _par[u] = root(_par[u]);\n}\n\nint main(){\n    int N, Q;\n    while(cin >> N >> Q, N|Q){\n        vector<int> parents(N);\n        parents[0] = -1;\n        for(int i=1; i<N; i++){\n            cin >> parents[i];\n            parents[i]--;\n        }\n        \n        vector<pair<string, int>> operations(Q);\n        for(int i=0; i<Q; i++){\n            cin >> operations[i].first >> operations[i].second;\n            operations[i].second--;\n        }\n        \n        vector<bool> marked(N);\n        marked[0] = true;\n        for(auto& o : operations){\n            if(o.first == \"M\")\n                marked[o.second] = true;\n        }\n        \n        init(parents, marked);\n        \n        int ans = 0;\n        for(int i=N-1; i>=0; i--){\n            auto& o = operations[i];\n            int& u = o.second;\n            if(o.first == \"M\"){\n                marked[u] = false;\n                _par[u] = parents[_par[u]];\n            }else if(o.first == \"Q\"){\n                ans += root(u) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            const int root = uf.find(s);\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[root];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        vector<int> parent(N, 0);\n        for (int i = 1; i < N; i++) {\n            int from;\n            cin >> from;\n            from--;\n            parent[i] = from;\n            g.addEdge(from, i);\n        }\n\n        vector<bool> visited(N, false);\n\n        using P = pair<char, int>;\n        vector<P> query;\n        vector<int> comp(N, 0);\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            if (c == 'M') {\n                if (marked[n]) {\n                    continue;\n                }\n                comp[n] = n;\n                marked[n] = true;\n            }\n            query.push_back(make_pair(c, n));\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        long long sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n                const int s = q.second;\n                const int par = parent[s];\n                const int root = uf.find(par);\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[root];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n\ninline int input(){\n\tchar c;\n\tfor(c = getchar();c<'0' || c>'9';c = getchar());\n\tint res = c - '0';\n\tfor(c = getchar();c>='0' && c<='9';c = getchar()) res = res * 10 + (c - '0');\n\treturn res;\n}\ninline char letter(){\n\tchar c;\n\tfor(c = getchar();c != 'M' && c != 'Q';c = getchar());\n\treturn c;\n}\nint n,q,p[100005],par[100005];\nbool mark[100005];\nchar c[100005];\nint v[100005];\ninline void ini(int x){\n\tfor(int i=1;i<=x;i++){\n\t\tif(mark[i]) par[i] = i;\n\t\telse par[i] = p[i];\n\t}\n}\nint find_(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find_(par[x]);\n}\nint main(){\n//\tios::sync_with_stdio(false);\n\twhile(true){\n\t\tint ans = 0;\n\t\tn = input();\n\t\tq = input();\n\t\tif(n == 0 && q == 0) break;\n\t\tp[1] = 1;\n\t\tmark[1] = true;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tp[i] = input();\n\t\t}\n\t\tfor(int i=1;i<=q;i++){\n\t\t\tc[i] = letter();\n\t\t\tv[i] = input();\n\t\t\tif(c[i] == 'M') mark[v[i]] = true;\n\t\t}\n\t\tini(n);\n\t\tfor(int i=q;i>=1;i--){\n\t\t\tif(c[i] == 'Q') ans += find_(p[v[i]]);\n\t\t\telse{\n\t\t\t\tpar[v[i]] = p[v[i]];\n\t\t\t\tmark[v[i]] = false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nchar Ope[MAX_N];\nint Openum[MAX_N], Marked[MAX_N];\nvector<int> child[MAX_N];\n\nvoid mark(int x, int num) {\n  if(Marked[x] == x || Marked[x] == num) return;\n  Marked[x] = num;\n  for(int i = 0; i < child[x].size(); i++){\n    mark(child[x][i], num);\n  }\n}\n\nvoid solve() {\n  int ans = 0;\n  for(int i = 0; i < MAX_N; i++) Marked[i] = 1;\n  for(int i = 0; i < Q; i++){\n    char ope = Ope[i];\n    int num = Openum[i];\n    if(ope == 'M') mark(num, num);\n    else if(ope == 'Q') ans += Marked[num];\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 0; i <= N; i++) child[i].clear();\n    for(int i = 2; i <= N; i++){\n      int par;\n      scanf(\"%d\", &par);\n      child[par].push_back(i);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct uni {\n  int p[111111];\n  uni(){memset(p,-1,sizeof(p));}\n  int root(int a){return p[a]<0?a:(p[a]=root(p[a]));}\n  bool find(int a,int b){return root(a)==root(b);}\n  // aをbの親に\n  void merge(int a,int b){if(!find(a,b))p[root(b)]=root(a);}\n};\n\nint p[111111];\nint m[111111];\nint Q[111111];\nint Qm[111111];\nint Qi[111111];\nint Qc,Qmc;\nint main(void)\n{\n  int n,q;\n  long long res;\n  for(;;) {\n    scanf(\"%d%d\",&n,&q); if(n+q==0)return 0;\n    uni u;\n    memset(m,-1,sizeof(m));\n    res = 0;\n    Qc = 0;\n    Qmc = 0;\n    m[0] = 0;\n    for(int i = 0; i < n-1; i++) {\n      int a; scanf(\"%d\",&a);\n      p[i+1] = a-1;\n    }\n    for(int i = 0; i < q; i++) {\n      char c;int a; scanf(\" %c%d\",&c,&a);\n      --a;\n      Qi[Qc] = i;\n      if(c=='Q')Q[Qc++] = a;\n      else {\n        if(m[a] < 0) {\n          m[a] = i;\n          Qm[Qmc++] = i;\n        }\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      if(m[i]<0) u.merge(p[i],i);\n    }\n    printf(\"%d %d\\n\",Qmc,Qc);\n    while(Qmc--) {\n      while( Qc && Qi[Qc-1] > Qm[Qmc] ) {\n        Qc--;\n        res += u.root(Q[Qc])+1;\n      }\n      u.merge(p[Qm[Qmc]],Qm[Qmc]);\n    }\n    \n    res += Qc;\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\tint t;\n\t\trep(i, n-1) {\n\t\t\tcin >> t; t--;\n\t\t\tpar0[i + 1] = t;\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (marked[i]==0) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)(find(p[i].second)+1);\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\ntypedef pair<int,int> pii;\n\nint N,M;\nint res;\nint ans;\nvector<int> V[MAX_N+5];\nbool Mark[MAX_N+5];\n\nvoid dfs(int n){\n    if(res!=inf)return ;\n    if(Mark[n]==true)res=n;\n    else{\n        for(int i=0;i<V[n].size();++i){\n            dfs(V[n][i]);\n        }\n    }\n}\n\n\nsigned main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        for(int i=0;i<=N;++i)V[i].clear();\n        memset(Mark,0,sizeof(Mark));\n        Mark[1]=true;\n        for(int i=2;i<=N;++i){\n            int v;\n            cin>>v;\n            V[i].PB(v);\n        }\n        ans=0;\n        for(int i=0;i<M;++i){\n            char que;\n            int k;\n            cin>>que;\n            cin>>k;\n            if(que =='M')Mark[k]=true;\n            else{\n                res=inf;\n                dfs(k);\n                if(res!=inf)ans+=res;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init(MAX);\n    par[0] = 1;\n    for(int i = 1 ; i < n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      --num;\n      if(ch == 'Q'){\n\tsum += find(num)+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100000];\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tmap<int,int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M') roots[i+2] = v;\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n);\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tif(roots.find(i+2) == roots.end()){\n\t\t\t\tuf.unionSet(i+2,roots[i+2]);\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(i+2,queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int INF=0x3f3f3f3f;\n#define N 200005\n\nint p[N],m[N];\n\nint find(int x){\n\tif(m[p[x]]!=0)return p[x];\n\telse return p[x]=find(p[x]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,q;\n\twhile(cin>>n>>q){\n\t\tif(n==0&&q==0)break;\n\t\tmemset(p,0,sizeof(p));\n\t\tmemset(m,0,sizeof(m));\n\t\tp[1]=1;\n\t\tm[1]=-1;\n\t\tfor (int i = 0; i < n-1; i++){\n\t\t\tcin>>p[i+2];\n\t\t}\n\t\tvector<pair<char,int>> st;\n\t\twhile(q--){\n\t\t\tchar t;\n\t\t\tint x;\n\t\t\tcin>>t>>x;\n\t\t\tst.push_back({t,x});\n\t\t\tif(t=='M'&&m[x]==0){\n\t\t\t\tm[x]=st.size();\n\t\t\t}\n\t\t}\n\t\tif(n==1){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tll sum=0;\n\t\tfor(int i=st.size()-1;i>=0;i--){\n\t\t\tif(st[i].fi=='M'){\n\t\t\t\tif(m[st[i].se]==i+1)m[st[i].se]=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum+=find(st[i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 2000000\nusing namespace std;\nint par[MAX];\nint N,Q;\n\nvoid init()\n{\n  rep(i,MAX)par[i] = i;\n}\n\nint find(int x)\n{\n  if(x == par[x])return x;\n  return find(par[x]);\n}\n\nbool unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x != y)par[y] = x;\n}\n\nbool same(int x,int y)\n{\n  return find(x) == find(y);\n}\n\nint main()\n{\n  while(cin >> N >> Q,N|Q)\n    {\n      init();\n      REP(i,1,N)\n\t{\n\t  int variable;\n\t  cin >> variable;\n\t  variable--;\n\t  par[i] = variable;\n\t}\n\n      long long cost = 0;\n      rep(i,Q)\n\t{\n\t  char Query;\n\t  int v;\n\t  cin >> Query >> v;\n\t  v--;\n\t  if(Query == 'Q')\n\t    {\n\t      cost += find(v)+1;\n\t    }\n\t  else \n\t    {\n\t      par[v] = v;\n\t    }\n\t}\n      cout << cost << endl;\n    }\n  return 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 1e6;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  par[1] = 1;\n  marked[1] = true;\n  for (int i = 2; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    if (N > 1) {\n      for (int i = 2; i <= N; i++) {\n        cin >> par[i];\n      }\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      if (c == 'M' && !marked[node]) {\n        marked[node] = true;\n        s.push(make_pair(true, node));\n      } else if (c == 'Q') {\n        s.push(make_pair(false, node));\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            //a=P[a-1];\n            a--;\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m+1;}\n            }\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; break;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tbool isMarked = false;\n};\n\nNode arr[100002];\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr[1].isMarked = true;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tarr[_index].isMarked = true;\n\t}\n\tint operationQ(int _index)\n\t{\n\t\tif (arr[arr[_index].parent_index].isMarked == true)return arr[_index].parent_index;\n\t\telse\n\t\t{\n\t\t\treturn operationQ(arr[_index].parent_index);\n\t\t}\n\t}\n};\n\nint main()\n{\n\tint N, Q, ans = 0;\n\tTree tree;\n\tcin >> N >> Q;\n\tfor (unsigned int i = 2 ; i < N+1; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\ttree.addNode(i, p);\n\t}\n\tfor (unsigned int i = 0; i < Q; i++)\n\t{\n\t\tchar qes;\n\t\tint index;\n\t\tcin >> qes >> index;\n\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\telse tree.operationM(index);\n\t}\n\tint hoge;\n\tcin >> hoge >> hoge;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass EulerTour{\nprivate:\n    int n;\n    vector<vector<int> > g;\n    vector<vector<int> > ind;//各頂点のインデックス\n\n    void dfs(int now, int par){\n        ind[now].push_back(v.size());\n        v.push_back(now);\n        for(int i = 0; i < g[now].size(); i++){\n            if(g[now][i] != par){\n                dfs(g[now][i],now);\n            }\n        }\n        ind[now].push_back(v.size());\n        v.push_back(now);\n    }\n\npublic:\n    vector<int> v;//オイラーツアーの頂点\n    EulerTour(){}\n    EulerTour(vector<vector<int> > in, int root){\n        g = in;\n        n = g.size();\n        ind = vector<vector<int> > (n);\n        dfs(root, -1);\n    }\n    void show(){\n        rep(i,v.size())cout << \" \" << v[i]; cout << endl;\n    }\n    pii get_ind(int i){\n        if(i >= n)return pii(INF,INF);\n        return pii(ind[i][0], ind[i][1]);\n    }\n\n};\n\nclass LazySegmentTree{\n private:\n     int n;\n     vector<long long> node, lazy;\n     long long node_init = 0; // sum, max, update\n     //long long node_init = LINF; // min\n     //long long lazy_init = 0; // default\n     long long lazy_init = LINF; // min, update (存在しない値)\n\n     long long lazy_update(long long a,long long b){\n         //return a+b; // sum query\n         //return max(a,b); // max query\n         //return min(a,b); // min query\n         return b; // update query\n     }\n\n     long long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n         //return a + b; // min query\n         return b; // update query\n         //return b * (r-l); // sum query\n     }\n\n     long long combine(long long a,long long b){\n         //return a+b; // sum query\n         return max(a,b); // max query\n         //return min(a,b); // min query\n         //return b;\n     }\n\n public:\n     LazySegmentTree(){}\n     LazySegmentTree(vector<long long> in){\n         n = 1;\n         while(n < in.size())n <<= 1;\n         node = vector<long long>(2*n, node_init);\n         lazy = vector<long long>(2*n, lazy_init);\n         for(int i = n-1+in.size()-1; i >= 0; i--){\n             if(n-1 <= i)node[i] = in[i-(n-1)];\n             else node[i] = combine(node[i*2+1], node[i*2+2]);\n         }\n     }\n     void eval(int k, int l, int r){\n         if(lazy[k] != lazy_init){\n             //cout << k << \" \" << l << \" \" << r  << \" \"<< lazy[k] << endl;\n             node[k] = node_update(node[k], lazy[k], l, r);\n             //cout << k << \" \" << node[k] << endl;\n             if(r - l > 1){\n                 lazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n                 lazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n             }\n             lazy[k] = lazy_init;\n         }\n     }\n     void update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n         if(r < 0)r = n;\n         eval(k,l,r);\n         if(b <= l || r <= a)return;\n         if(a <= l && r <= b){\n             lazy[k] = x;\n             eval(k,l,r);\n         }else{\n             update(a,b,x,2*k+1,l,(l+r)/2);\n             update(a,b,x,2*k+2,(l+r)/2,r);\n             node[k] = combine(node[2*k+1], node[2*k+2]);\n         }\n     }\n     long long query(int a, int b, int k = 0, int l = 0, int r = -1){\n         if(r < 0)r = n;\n         //cout << \"!\"<<a << \" \" << b << \" \" << k << \" \" << l << \" \" << r << endl;\n         eval(k,l,r);\n         if(b <= l || r <= a)return node[k];\n         if(a <= l && r <= b)return node[k];\n         if(a <= l)return query(a,b,2*k+1,l,(l+r)/2);\n         else return query(a,b,2*k+2,(l+r)/2,r);\n         //return combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n     }\n     void show(){\n         cout << \"node :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << node[i];\n         }\n         cout << endl;\n         cout << \"node :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << i;\n         }\n         cout << endl;\n         /*\n         cout << \"lazy :\";\n         for(int i = 0; i < 2*n-1; i++){\n             if(i == n-1)cout << \"     \";\n             cout << \" \" << lazy[i];\n         }\n         cout << endl;\n         */\n     }\n };\n\n\nsigned main(void) {\n    int n,q;\n    while(1){\n        scanf(\"%lld %lld\",&n,&q);\n        if(n == 0)return 0;\n        vector<vi> g(n);\n        loop(i,1,n){\n            int a;\n            scanf(\"%lld\",&a);\n            a--;\n            g[a].push_back(i);\n        }\n        EulerTour et(g,0);\n        LazySegmentTree lst(vi(et.v.size()));\n        //et.show();\n        int ans = 0;\n        while(q--){\n            char s[5];\n            scanf(\"%s\",s);\n            int v;\n            scanf(\"%lld\",&v);\n            v--;\n            pii ind = et.get_ind(v);\n            //cout << ind.first << \" \" << ind.second << endl;\n            if(s[0] == 'M'){\n                lst.update(ind.first,ind.second,v);\n            }else{\n                //lst.show();\n                //cout << lst.query(ind.first,ind.second) << endl;\n                ans += lst.query(ind.first,ind.first+1)+1;\n                //lst.show();\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint s[100001];\nint N, Q;\nint p[100001];\nint operation[100001];\n\nint find_root(int i);\n\nint find_p_root(int i)\n{\n\tif (s[i]==0) {\n\t\ts[i] = find_p_root(p[i]);\n\t\treturn s[i];\n\t}\n\telse if (s[i]!=-i) {\n\t\ts[i] = find_root(s[i]);\n\t\treturn s[i];\n\t}\n\telse\n\t\treturn i;\n\n}\n\nint find_root(int i)\n{\n\tif (s[i]!=-i) {\n\t\ts[i] = find_root(s[i]);\n\t\treturn s[i];\n\t}\n\telse\n\t\treturn i;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &Q)==2) {\n\t\tif (N==0 && Q==0) break;\n\t\tint i;\n\t\tp[1] = 1;\n\t\tfor (i=2; i<=N; i++) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tchar c;\n\t\tfor (i=0; i<Q; i++) {\n\t\t\tdo { c = getchar();\n\t\t\t} while (c!='M' && c!='Q');\n\t\t\tscanf(\"%d\", &operation[i]);\n\t\t\tif (c=='Q')\n\t\t\t\toperation[i] = -operation[i];\n\t\t}\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\ts[i] = 0;\n\t\t}\n\t\ts[1] = -1;\n\t\tfor (i=0; i<Q; i++) {\n\t\t\tif (operation[i]>0) {\n\t\t\t\ts[operation[i]] = -operation[i];\n\t\t\t}\n\t\t}\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (s[i]==0) {\n\t\t\t\tint root = find_p_root(i);\n\t\t\t\ts[i] = root;\n\t\t\t}\n\t\t}\n\n\t\tlong long sum = 0;\n\t\tfor (i=Q-1; i>=0; i--) {\n\t\t\tif (operation[i]<0) {\n\t\t\t\tint root = find_root(-operation[i]);\n\t\t\t\tsum += root;\n\t\t\t}\n\t\t\telse if (operation[i]>0) {\n\t\t\t\tint parent = p[operation[i]];\n\t\t\t\ts[operation[i]] = parent;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n//< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy += max(seg[2 * k+1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl , vr);\n}\n\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root),cnum(V),place(V),id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v]+=dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v]+1;\n\t}\n\n\tvoid getid(const int v, const int p,int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tupdate(1, N, 0);\n\t\tvector<int>nums;\n\t\tnums.push_back(0);\n\t\tTree t(N,0);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tt.unite(a, i+1);\n\t\t}\n\t\tt.init();\n\t\tint asum = 0;\n\t\twhile (Q--) {\n\t\t\tchar c;int  n;\n\t\t\tcin >> c >> n;\n\t\t\tconst int aplace = t.place[n];\n\t\t\tif (c == 'M') {\n\t\t\t\tupdate(aplace+1, aplace + t.cnum[n-1]+1, n-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans = get(aplace, aplace);\n\t\t\t\tasum += ans+1;\n\t\t\t}\n\t\t}\n\t\tcout << asum << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n    Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N]; //i(i = 0,1,2,...,n)?????????node???????????\\????????????\nchar Ope[MAX_N]; //operations?????\\????????????\nint Openum[MAX_N]; //operation??¨??????????????°????????\\????????????\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1, num);\n    }\n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          printf(\"%d\", nodeNum);\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n\n     \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  Node[1] = 1;\n  for(int i = 2; i <= N; i++){\n    scanf(\"%d\", &Node[i]);\n  }\n  for(int i = 0;;i++){\n    scanf(\"  %c\", &Ope[i]);\n    scanf(\"%d\", &Openum[i]);\n    if(Openum[i] == 0) break;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n//#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5+5;\nint pa[maxn];\nint Mrk[maxn];\n\nint qt[maxn],qv[maxn];\nint Qt;\nint fdst(int x)\n{\n    return Mrk[x] < Qt ? x :pa[x] = fdst(pa[x]);\n}\n\n//#define LOCAL\nint main()\n{\n#ifdef LOCAL\n    freopen(\"in.txt\",\"r\",stdin);\n#endif\n    int N, Q;\n    while(scanf(\"%d%d\",&N,&Q),N){\n        for(int i = 2; i <= N; i++){\n            scanf(\"%d\",pa+i);\n            Mrk[i] = Q+1;\n        }\n        int c = 0;\n        for(int i = 1; i <= Q; i++){\n            char op[2];\n            int v;\n            scanf(\"%s%d\",op,&v);\n            if(*op == 'Q'){\n                qt[c] = i;\n                qv[c++] = v;\n            }else {\n                Mrk[v] = min(Mrk[v],i);//取最早生效的??\n            }\n        }\n        long long ans = 0;\n        while(c--){\n            Qt = qt[c];\n            ans += fdst(qv[c]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nlong long ans;\nint dfs(int x){\n\tfor( int i : M[x] ) near[i] = x;\n\tfor( int i : Q[x] ){\n\t\tint x = (*(--near.lower_bound(i))).second;\n\t\tans += x+1;\n\t}\n\tfor( auto c : ch[x] ) dfs(c);\n\tfor( int i : M[x] ) near.erase(i);\n\t\n}\nint main(){\n\tint N,Qq;\n\tcin >> N >> Qq;\n\trep(i,N-1){\n\t\tint x;\n\t\tcin >> x;\n\t\tch[--x].push_back(i+1);\n\t}\n\tM[0].push_back(-1);\n\trep(i,Qq){\n\t\tchar c;\n\t\tint v;\n\t\t\n\t\tcin >> c >> v;\n\t\t--v;\n\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\tif( c == 'M' ) M[v].push_back(i);\n\t}\n\tdfs(0);\n\tcout << ans << endl;\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint pre[100005];\nint find_root(int x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    int n, q;\n    while(scanf(\"%d%d\", &n, &q), n || q)\n    {\n        pre[1] = 1;\n        for(int i = 2; i <= n; i++)\n            scanf(\"%d\", &pre[i]);\n        char a;\n        int b;\n        long long ans = 0ll;\n        while(q--)\n        {\n            scanf(\" %c%d\", &a, &b);\n            if(a == 'Q')\n                ans += find_root(b);\n            else\n                pre[b] = b;\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n\nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    y = root[x];\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n\nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n\nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n    r(x);r(y);\n}\n\nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 3, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\troot[query[i].second] = query[i].second;\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tunite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }        \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  par[1] = 1;\n  marked[1] = true;\n  for (int i = 2; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    if (N > 1) {\n      for (int i = 2; i <= N; i++) {\n        cin >> par[i];\n      }\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  UnionFind(int n = 0): par(n, -1){}\n  int root(int x){\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return;\n    if (par[x] > par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n  }\nprivate:\n  vector<int> par;\n};\n\nint n, q;\nint p[100000];\nstring t[100000];\nint v[100000];\nint m[100000];\nint a[100000];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  while (cin >> n >> q, n){\n    memset(m, 0, sizeof(m));\n    m[0]++;\n    UnionFind uf(n);\n    iota(a, a + n, 0);\n    for (int i = 1; i < n; i++){\n      cin >> p[i], p[i]--;\n    }\n    for (int i = 0; i < q; i++){\n      cin >> t[i] >> v[i], v[i]--;\n      if (t[i] == \"M\") m[v[i]]++;\n    }\n    for (int i = 0; i < n; i++){\n      if (!m[i]){\n        int x = a[uf.root(p[i])];\n        uf.unite(p[i], i);\n        a[uf.root(p[i])] = x;\n      }\n    }\n    int s = 0;\n    for (int i = q - 1; i >= 0; i--){\n      if (t[i] == \"M\"){\n        if (!--m[v[i]]){\n          int x = a[uf.root(p[v[i]])];\n          uf.unite(p[v[i]], v[i]);\n          a[uf.root(p[v[i]])] = x;\n        }\n      }\n      else s += a[uf.root(v[i])] + 1;\n    }\n    cout << s << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint fa[100005];\nint marked[100005];\n\nint find(int x){\n\tif (marked[x]) return x;\n\telse return find(fa[x]);\n\t\n}\n\nint main(){\n\tint n, q;\n\twhile (scanf(\"%d%d\", &n, &q)==2){\n\t\tif (n == 0&&q == 0) break;\n\n\t\tfor (int i = 1; i <=n; i++) {\n\t\t\tfa[i] = i;\n\t\t\tmarked[i] = 0;\n\t\t}\n\t\tmarked[1] = 1;\n\n         int x;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfa[i] = x;\n\t\t}\n\n\t\tchar ch;\n\t\tint dex;\n\t\tscanf(\"%c\", &ch);\n\t\tlong long ans = 0;\n\t\tint t;\n\t\tfor (int i = 0; i < q;i++){\n\t\t\tscanf(\"%c%d\", &ch, &dex);\n\t\t\t\n         if (ch == 'Q'){\n\t\t\t t = find(dex); \n\t\t\t\tans += t;\n\t\t\t}\n\t\telse marked[dex] = 1;\n\t\tscanf(\"%c\", &ch);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nNode arr[100002];\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr[1].isMarked = true;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tarr[_index].isMarked = true;\n\t\tfor (auto itr : arr[_index].c)arr[itr].nearest_index = _index;\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n};\n\nint main()\n{\n\tint N, Q, ans = 0;\n\tTree tree;\n\tcin >> N >> Q;\n\tfor (unsigned int i = 2 ; i < N+1; i++)\n\t{\n\t\tint p;\n\t\tcin >> p;\n\t\ttree.addNode(i, p);\n\t}\n\tfor (unsigned int i = 0; i < Q; i++)\n\t{\n\t\tchar qes;\n\t\tint index;\n\t\tcin >> qes >> index;\n\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\telse tree.operationM(index);\n\t}\n\tint hoge;\n\tcin >> hoge >> hoge;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\n#define MAX_N 200000\n\nint par[MAX_N];\nint rnk[MAX_N];\n\n// 初期化\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t}\n}\n\n// x の親を返す\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}\n\treturn par[x] = find(par[x]);\n}\n\n// x と y を併合する\nvoid unite(int x, int y){\n\tint x_par = find(x);\n\tint y_par = find(y);\n\tif(x_par == y_par){\n\t\treturn;\n\t}\n\t\n\tpar[x_par] = y_par;\n}\n\n// x, y が同じグループか判定\nbool same(int x, int y){\n\treturn (find(x) == find(y));\n}\n\nint p[MAX_N];\nbool flag[MAX_N];\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tint N, Q;\n\t\t\n\t\tcin >> N >> Q;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\tflag[0] = true;\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tcin >> p[i];\n\t\t\tp[i]--;\n\t\t\tflag[i] = false;\n\t\t}\n\t\tvector<P> v;\n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tP p;\n\t\t\tcin >> p.first >> p.second;\n\t\t\tp.second--;\n\t\t\tif(p.first == \"M\"){\n\t\t\t\tif(flag[p.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tflag[p.second] = true;\n\t\t\t}\n\t\t\tv.push_back(p);\n\t\t}\n\t\tinit(N);\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tunite(i, p[i]);\n\t\t\t}\n\t\t}\n\t\treverse(v.begin(), v.end());\n\t\tlong long int ans = 0;\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++){\n\t\t\tif(v[i].first == \"M\"){\n\t\t\t\tunite(v[i].second, p[v[i].second]);\n\t\t\t}else{\n\t\t\t\tans += find(v[i].second) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i  = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nstruct UF {\n  int n;\n  vector<int> d;\n  UF(int v) : n(v+1), d(v+1, -1){\n    REP(i, 1, n) d[i] = -i;\n  }\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return false;\n    d[y] = x;\n    return true;\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, q;\n  while(cin >> n >> q) {\n    if(n == 0 && q  == 0) break;\n    vector<int> par(n+1);\n    REP(i, 2, n+1) cin >> par[i];\n    using P = pair<int, int>;\n    vector<P> query(q);\n    vector<int> marked(n+1);\n    marked[1] = 1;\n    rep(i, q) {\n      char c;\n      int t;\n      cin >> c >> t;\n      query[i].first = (c == 'M');\n      query[i].second = t;\n      if(query[i].first) marked[t]++;\n    }\n    UF uf(n);\n    REP(i, 1, n+1) {\n      if(!marked[i]) {\n\tuf.unite(par[i], i);\n      }\n    }\n    // REP(i, 1, n+1) {\n    //   cout << i << \" \" << uf.root(i) << endl;\n    // }\n    int ans = 0;\n    for(int i = q-1; i >= 0; --i) {\n      if(query[i].first) {\n\tint v = query[i].second;\n\tmarked[v]--;\n\tif(marked[v] == 0) uf.unite(par[query[i].second], query[i].second);\n      }\n      else {\n\tans += uf.root(query[i].second);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\nvoid walk_graph(int v, int mark_p,\n        vector<int>& mark_parent, vector<int>& marked, graph& g) {\n\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p, mark_parent, marked, g);\n    }\n}\n\nint find_mark_parent(int v,\n        vector<int>& mark_parent, vector<int>& marked) {\n    if (marked[v]) return v;\n    return find_mark_parent(mark_parent[v], mark_parent, marked);\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    vector<int> mark_parent(N, 0);\n    vector<int> marked(N, 0);\n\n    graph g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            marked[q.second] = 1;\n        }\n    }\n\n    walk_graph(0, -1, mark_parent, marked, g);\n\n    int ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n        if (ch == 'Q') {\n            ret += find_mark_parent(v, mark_parent, marked)+1;\n        }\n        if (ch == 'M') {\n            marked[v] = 0;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            a--;\n            if(a==0){ans++; continue;}\n            a=P[a];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m;}\n            }\n            bool done=false;\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; done=true; break;}\n            }\n            if(!done){ans++;}\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct Timer {\n    clock_t p;\n    Timer(){ reset(); }\n    void reset(){ p = clock(); }\n    double get(){ return (double)(clock()-p)/CLOCKS_PER_SEC; }\n};\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<set<pair<int,int>>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        vector<int> hist;\n        int res = -1;\n        Timer t;\n        while(v != -1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(make_pair(-depth[v],-inf));\n            //dump(ms.size());\n            if(it != ms.end()){\n                res = it->second;\n                break;\n            } else {\n                v = goUp(v);\n            }\n        }\n        //dump(t.get());\n        assert(res != -1);\n        return res;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q'){\n                ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            } else {\n                marks.emplace(-d, qv[i]);\n            }\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        double Qt = 0, Mt = 0;\n        rep(i,q){\n            if(qt[i] == 'Q'){\n                Timer t;\n                ans += h.query(qv[i]) + 1;\n                Qt += t.get();\n            } else {\n                Timer t;\n                h.mark(qv[i]);\n                Mt += t.get();\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n            g[i+1].eb(i+1,par);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\t// if (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t}\n\t}\n\tint size(int x) { return -v[find(x)]; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\nint par[100001], a[100001];\nchar c[100000]; int v[100000];\n\nint main() {\n\tfor (;;) {\n\t\tint N, Q;\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)\n\t\t\tbreak;\n\t\tfor (int _v = 2; _v <= N; _v++)\n\t\t\tscanf(\"%d\", &par[_v]);\n\t\tfill(a, a + 100001, 0);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tchar s[2]; int _v;\n\t\t\tscanf(\"%s%d\", s, &_v);\n\t\t\tc[i] = s[0];\n\t\t\tv[i] = _v;\n\t\t\tif (s[0] == 'M')\n\t\t\t\ta[_v]++;\n\t\t}\n\t\tUnionFind uf(N + 1);\n\t\tfor (int _v = 2; _v <= N; _v++)\n\t\t\tif (a[_v] == 0)\n\t\t\t\tuf.unite(par[_v], _v);\n\t\tlong long ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tint _v = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\tif (--a[_v] == 0 && _v != 1)\n\t\t\t\t\tuf.unite(par[_v], _v);\n\t\t\t}\n\t\t\telse if (c[i] == 'Q')\n\t\t\t\tans += uf.find(_v);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100001\nusing namespace std;\nint n,q,u,t[Q],p[Q],ans;\nchar c[Q];\nbool marked[Q];\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) data[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\tif (_a == iINF) return _b;\n\t\tif (_b == iINF) return _a;\n\t\treturn iINF;\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF, mx = 0;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t\tmx = max(mx, res);\n\t}\n\t\n\tranges[v] = pii(mn, mx + 1);\n\t\n\t++d;\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tif (rng.first == iINF) {\n\t\t\t\tint nn = node_number[v];\n\t\t\t\tstl.update(nn, nn + 1, v);\n\t\t\t} else {\n\t\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair<char,int>\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    stack<pair<char,int> > qu;\n    int n;\n    \n    UF(int m):par(2*m),rank(2*m)\n    {\n        n=m;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x=0)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) break;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin>>n>>q;\n    Uf uf(n);\n    for(int i=1;i<n;i++)\n    {\n        int p;\n        cin>>p;\n        (uf.c[p]).push_back(i);\n    }\n    for(int i=0;i<q;i++)\n    {\n        char temp;\n        int v;\n        cin>>temp>>v;\n        (uf.qu).push(P(temp,v-1));\n        if(temp=='M') uf.m[v-1]=true;\n    }\n    int a,b;\n    cin>>a>>b;\n    uf.furiwake(0);\n    \n    ll ans=0;\n    for(int i=0;i<q;i++)\n    {\n        pair<char,int> a=(uf.qu).top();\n        (uf.qu).pop();\n        if(a.first=='Q')\n        {\n            ans+=uf.score(a.second);\n        }\n        else\n        {\n            uf.delmark(a.second);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint main()\n{\n\tchar op[3];\n\tint id,ans;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tans=0;\n\t\tSet[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=Root(Que[i][1]);\n\t\t\telse\n\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, q, p[100000];\nint m[100000], v[100000];\nchar type[100000];\nvector<vi> e;\n\nint pa[100000];\nint root(int x){\n\tif(x == pa[x]) return x;\n\treturn pa[x] = root(pa[x]);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &q), n){\n\t\te.clear(); e.resize(n);\n\t\tmemset(m, 0, sizeof(m));\n\t\t\n\t\trep(i, n - 1){\n\t\t\tscanf(\"%d\", p + i + 1), p[i + 1]--;\n\t\t\te[i + 1].pb(p[i + 1]);\n\t\t\te[p[i + 1]].pb(i + 1);\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\" %c%d\", type + i, v + i);\n\t\t\tv[i]--;\n\t\t\tif(type[i] == 'M') m[v[i]]++;\n\t\t}\n\t\tm[0] = 1;\n\t\t\n\t\tqueue<pi> Q;\n\t\trep(i, n){\n\t\t\tpa[i] = i;\n\t\t\tif(m[i]) Q.push(mp(i, i));\n\t\t}\n\t\t\n\t\twhile(!Q.empty()){\n\t\t\tint c = Q.front().first, r = Q.front().second;\n\t\t\tQ.pop();\n\t\t\trep(i, e[c].size()) if(e[c][i] != p[c] && !m[e[c][i]]){\n\t\t\t\tpa[e[c][i]] = r;\n\t\t\t\tQ.push(mp(e[c][i], r));\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i = q - 1; i >= 0; i--){\n\t\t\tif(type[i] == 'M'){\n\t\t\t\tif(--m[v[i]] == 0) pa[v[i]] = root(p[v[i]]);\n\t\t\t}\n\t\t\telse ans += root(v[i]) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tmap<int,int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M') roots[i+2] = v;\n\t\t\tif(c == 'M' && find(queries.begin(),queries.end(),make_pair(c,v)) != queries.end()) continue;\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Fenwick {\n  int N;\n  vector<int> p;\n  Fenwick(int N):N(N),p(N) {}\n  void add(int i, int x) {\n    for(i++; i<=N; i+=i&-i) p[i]+=x;\n  }\n  int sum(int i) {\n    int s = 0;\n    for(; i > 0; i-=i&-i) s+=p[i];\n    return s;\n  }\n};\nint N,Q;\nstatic int sibling[100000],child[100000],parentN[17][100000];\nstatic int dfsStart[100000],dfsEnd[100000],cur;\n\nvoid dfs(int v) {\n  dfsStart[v]=cur++;\n  for(int w = child[v]; w != -1; w=sibling[w]) {\n    dfs(w);\n  }\n  dfsEnd[v]=cur;\n  // printf(\"%d: [%d,%d)\\n\", v, dfsStart[v], dfsEnd[v]);\n}\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    scanf(\"%d%d\", &N, &Q); if(N==0) break;\n    fill(child,child+N,-1);\n    for(int j = 0; j < 17; j++) fill(parentN[j], parentN[j]+N, -1);\n    for(int i = 1; i < N; i++) {\n      scanf(\"%d\", parentN[0]+i); parentN[0][i]--;\n      sibling[i]=child[parentN[0][i]];\n      child[parentN[0][i]]=i;\n    }\n    for(int i = 0; i < N; i++) {\n      for(int j = 1; j < 17; j++) {\n        if(parentN[j-1][i]==-1) break;\n        parentN[j][i] = parentN[j-1][parentN[j-1][i]];\n      }\n    }\n    dfs(0);\n    Fenwick fw(N+1);\n    int anssum = 0;\n    for(int q = 0; q < Q; q++) {\n      //printf(\"(\"); for(int i = 0; i <= N; i++) printf(\"%d, \", fw.sum(i+1)-fw.sum(i)); printf(\")\\n\");\n      // for(int i = 0; i < N; i++) printf(\"fw[%d] = %d\\n\", i, fw.sum(dfsStart[i]+1));\n      char qt; int v; scanf(\" %c%d\", &qt, &v); v--;\n      if(qt=='M') {\n        fw.add(dfsStart[v], 1);\n        fw.add(dfsEnd[v], -1);\n      } else {\n        int mc1 = fw.sum(dfsStart[v]+1);\n        int w = v;\n        for(int i = 16; i >= 0; i--) {\n          if(parentN[i][w]==-1) continue;\n          int mc2 = fw.sum(dfsStart[parentN[i][w]]+1);\n          if(mc2==mc1) w = parentN[i][w];\n        }\n        // printf(\"w = %d\\n\", w);\n        anssum += w+1;\n      }\n    }\n    printf(\"%d\\n\", anssum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100010;\nconst int MAXM = 100010;\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nint N, Q;\nint father[MAXN];\nbool vis[MAXN];\n\nvoid Init() {\n\tfor (int i = 0; i < MAXN; ++i) {\n\t\tfather[i] = i;\n\t}\n}\nint Find(int x) {\n\tif (father[x] == x)\n\t\treturn x;\n\treturn Find(father[x]);\n}\n\nint main(int argc, char const *argv[]) {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &N, &Q) != EOF && !(N == 0 && Q == 0)) {\n\t\tint a, b;\n\t\tLL res = 0;\n\t\tchar opt[5];\n\t\tInit();\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tscanf(\"%d\", &father[i]);\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tscanf(\"%s %d\", opt, &b);\n\t\t\tif (opt[0] == 'Q') {\n\t\t\t\tres += Find(b);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfather[b] = b;\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M;\nint par [100001];\nint root [100001];\n\nint find(int x)\n{\n\tif(root [x] == x) return x;\n\treturn root [x] = find(root [x]);\n}\n\nvoid unite(int x,int y)\n{\n\tx = find(x); y = find(y);\n\troot [y] = x;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&M) && N){\n\t\tFOR(i,2,N + 1){\n\t\t\tint u;\n\t\t\tscanf(\"%d\",&u);\n\t\t\tpar [i] = u;\n\t\t}\n\t\tvector< pair<int,int> > qy(M);\n\t\tdeque<bool> d(N + 1);\n\t\tFOR(i,0,M){\n\t\t\tchar str [20];\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\",str,&x);\n\t\t\tif(str [0] == 'M'){\n\t\t\t\td [x] = true;\n\t\t\t}\n\t\t\tqy [i] = make_pair(x,str [0] == 'Q');\n\t\t}\n\t\tFOR(i,2,N + 1) if(d [i] == false){\n\t\t\tqy.push_back(make_pair(i,0));\n\t\t}\n\t\treverse(qy.begin(),qy.end());\n\t\tll ans = 0;\n\t\tfor(int i = 1;i <= N;i++){\n\t\t\troot [i] = i;\n\t\t}\n\t\tFOR(i,0,qy.size()){\n\t\t\tif(qy [i].second == 0){\n\t\t\t\tunite(par [qy [i].first],qy [i].first);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += find(qy [i].first);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int MAX_N=100001;\nvector<vector<int> >edge(MAX_N);\nvector<vector<int> >id(MAX_N);\nstruct S{int n,i;S(int n,int i):n(n),i(i){}};\n\nint main()\n{\n\tint N,Q,x,i,t;\n\tchar c;\n\tlong long res;\n\ttypedef map<int,int>M;\n\tM m;\n\tM::iterator ite;\n\tvector<S>v;\n\tv.reserve(MAX_N*2);\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tm.clear();\n\t\tfor(i=1;i<=N;++i)edge[i].clear(),id[i].clear();\n\t\tfor(i=2;i<=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tedge[x].push_back(i);\n\t\t}\n\t\tv.push_back(S(1,0));\n\t\tfor(t=1;!v.empty();)\n\t\t{\n\t\t\tS&s(v.back());\n\t\t\tid[s.n].push_back(t++);\n\t\t\tif(s.i<edge[s.n].size())\n\t\t\t\tv.push_back(S(edge[s.n][s.i++],0));\n\t\t\telse\n\t\t\t\tv.pop_back();\n\t\t}\n\t\tm[1]=1;\n\t\tm[N*2]=-1;\n\t\tres=0;\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c-'Q')\n\t\t\t{\n\t\t\t\tite=m.lower_bound(id[x][0]);\n\t\t\t\tif(ite->second==x)continue;\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tfor(i=0;i<id[x].size();++i)\n\t\t\t\t\tm[id[x][i]]=x;\n\t\t\t\tm[id[x].back()+1]=t;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tite=m.upper_bound(id[x][0]);\n\t\t\t\tres+=(--ite)->second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n\nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    y = root[x];\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n\nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n\nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n\nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\troot[query[i].second] = query[i].second;\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tunite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }        \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(INF, 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tsum += res[v].second+1;\n\t\t\t}else{\n\t\t\t\tqueue<pair<pii, int>> que;\n\t\t\t\tque.emplace(pii(0, v), v);\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tpii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v] < c) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tc.first ++;\n\t\t\t\t\tFOR(e, g[v]){\n\t\t\t\t\t\tif(chmin(res[e->first], c))\n\t\t\t\t\t\t\tque.emplace(c, e->first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n\t> File Name: aoj2170.cpp\n\t> Author: BMan\n\t> Mail: luo-kai-jia@163.com\n\t> Created Time: Tue 23 Oct 2018 08:16:34 PM CST\n ************************************************************************/\n\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <limits.h>\n#include <queue>\n#include <math.h>\n#include <iostream>\n\n#define FOR(i, x, y) for (int i = x; i <= y; i++)\n#define REPEAT(_N) for (int _i = 0; _i < _N; _i++)\n\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\ninline bool Read(int &a) { return scanf(\"%d\", &a) != EOF; }\ninline bool Read(int &a, int &b) { return scanf(\"%d%d\", &a, &b) != EOF; }\ninline bool Read(int &a, int &b, int &c) { return scanf(\"%d%d%d\", &a, &b, &c) != EOF; }\n\nconst int INF = 0x3f3f3f3f;\n\n#define lson idx << 1, l, mid\n#define rson idx << 1 | 1, mid + 1, r\n\nconst int maxn = 1e5 + 10;\n\nint value[maxn << 2];\nvoid Init(int n) {\n    memset(value, 0, sizeof(value));\n    value[1] = 1;\n}\n\nint level[maxn];\nint node2id[maxn];\nint num[maxn];\n\nvoid Set(int idx, int newvalue)\n{\n    if (value[idx] == 0) {\n        value[idx] = newvalue;\n    } else {\n        int cur_lv = level[node2id[value[idx]]];\n        int new_lv = level[node2id[newvalue]];\n        if (new_lv > cur_lv) {\n            value[idx] = newvalue;\n        }\n    }\n}\n\nvoid PushDown(int idx)\n{\n    if (value[idx]) {\n        Set(idx << 1, value[idx]);\n        Set(idx << 1 | 1, value[idx]);\n        value[idx] = 0;\n    }\n}\n\nvoid Update(int idx, int l, int r, int lt, int rt, int newvalue)\n{\n    if (lt <= l && rt >= r) {\n        Set(idx, newvalue);\n    } else {\n        PushDown(idx);\n        int mid = (l + r) / 2;\n        if (lt <= mid) {\n            Update(lson, lt, rt, newvalue);\n        }\n        if (rt > mid) {\n            Update(rson, lt, rt, newvalue);\n        }\n    }\n}\n\nint Query(int idx, int l, int r, int pos)\n{\n    if (l == r) {\n        return value[idx];\n    } else {\n        PushDown(idx);\n        int mid = (l + r) / 2;\n        if (pos <= mid) return Query(lson, pos);\n        else return Query(rson, pos);\n    }\n}\n\nvector<int> g[maxn];\nint n, q;\n\n\nvoid Tree2Array(int u, int &cur_id, int lv)\n{\n    int id = ++cur_id;\n    node2id[u] = id;\n    num[id] = 1;\n    level[id] = lv;\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        Tree2Array(v, cur_id, lv + 1);\n        num[id] += num[node2id[v]];\n    }\n}\n\nchar ReadOP() {\n    char s[10];\n    scanf(\"%s\", s);\n    return s[0];\n}\n\nint Process() {\n    while(Read(n, q) && n) {\n        FOR(i, 1, n) g[i].clear();\n        FOR(i, 2, n) {\n            int x;\n            Read(x);\n            g[x].push_back(i);\n        }\n        int cur_id = 0;\n        Tree2Array(1, cur_id, 1);\n        Init(n);\n\n        LL ans = 0;\n        REPEAT(q) {\n            char op = ReadOP();\n            int u;\n            Read(u);\n            int id = node2id[u];\n            if (op == 'Q') {\n                //printf(\"%d\\n\", Query(1, 1, n, id));\n                ans += Query(1, 1, n, id);\n            } else {\n                Update(1, 1, n, id, id + num[id] - 1, u);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    return Process();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n//------- Union-Find木 ---------\nvector<int> par; // 親\n// 初期化\nvoid init(int n) {\n  par = vector<int>(n);\n  par[0] = 0;\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  par[x] = y;\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n//-------------------\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // ifstream cin (\"../test.txt\");\n  int N, Q;\n  while (1) {\n    cin >> N >> Q;\n    if (!(N | Q)) break;\n    init(N);\n    int a, i;\n    for (i = 1; i < N; i++) {\n      cin >> a;\n      par[i] = a - 1;\n    }\n    vector<pair<char, int> > query(Q);\n    char q;\n    for (i = 0; i < Q; i++) {\n      cin >> q >> a;\n      query[i] = make_pair(q, a);\n    }\n\n    // 先にマークする。つまり木を分離する。親となるノードを覚えておく。\n    vector<int> ori_par(N);\n    for (i = 0; i < Q; i++) {\n      if (query[i].first == 'M') {\n        a = query[i].second - 1;\n        ori_par[a] = par[a];\n        par[a] = a;\n      }\n    }\n\n    // クエリを後ろから処理する\n    int sum = 0;\n    reverse(query.begin(), query.end());\n    for (i = 0; i < Q; i++) {\n      a = query[i].second - 1;\n      if (query[i].first == 'Q') {\n        sum += find(a);\n      } else if (query[i].second == 'M') {\n        unite(a, ori_par[a]);\n      }\n    }\n\n    // 出力\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n \nint to[123456];\nchar o[123456];\nint v[123456];\n \nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n \n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (y < x) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void sep(int x){\n    data[x] = -1;\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    memset(to,0,sizeof(to));\n    memset(o,0,sizeof(o));\n    memset(v,0,sizeof(v));\n    unionfind uf(n+10);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+2] = a;\n    }\n    for(int i = n;i > 1;--i){\n        uf.unionset(to[i],i);\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      if(o[i]=='M'){\n        uf.sep(v[i]);\n      }    \n    }\n\n    int sum = 0;\n     \n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i]);\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\tarr[1].isMarked = true;\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tif (arr[_index].isMarked == false)return;\n\t\tarr[_index].isMarked = true;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tupdateNearest(itr,_index);\n\t\t}\n\t}\n\tvoid updateNearest(int _index,int _parent_index)\n\t{\n\t\tarr[_index].nearest_index = _parent_index;\n\t\tif (arr[_index].isMarked == false)\n\t\t{\n\t\t\tfor (auto itr : arr[_index].c)\n\t\t\t{\n\t\t\t\tupdateNearest(itr, _parent_index);\n\t\t\t}\n\t\t}\n\t}\n\tint operationQ(int _index)\n\t{\n\t\tif (arr[_index].parent_index == -1)return 0;\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string>\nusing namespace std;\nconst int MAX_N=100005;\nbool mark[MAX_N];\nint par[MAX_N];//父亲数组\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        par[i]=i;\n    }\n}\n\n\nint find(int x)//查询最近的已标记的祖先节点\n{\n    if(x==1)return 1;\n    if(mark[par[x]])\n    {\n        return par[x];\n    }\n    else\n    {\n        return find(par[x]);//递归查找\n    }\n}\n\n\nvoid unite(int x,int y)//记x为y的子节点\n{\n    par[x]=y;\n}\n\nint main()\n{\n    //freopen(\"c://Users/kkk/Destop/acm.txt\",\"r\",stdin);\n    int N,M;\n    while(1)\n    {\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    int parent;\n    init(N+1);\n    for(int i=2;i<=N;i++)\n    {\n        cin>>parent;\n        unite(i,parent);\n    }\n    long long ans=0;\n    while(M--)\n    {\n        string c;int t;\n        cin>>c;\n        cin>>t;\n        if(c==\"Q\")\n        {\n            ans+=find(t);\n        }\n        else if(c==\"M\")\n        {\n            mark[t]=1;\n        }\n    }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nint parent[100010];\nint marked[100010];\nint uf[100010];\nint get(int x){\n\treturn marked[x] ? x : parent[x] = get(parent[x]);\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tmemset(marked,0,sizeof(marked));\n\t\tvector< pair<int,int> > Q;\n\t\tfor(int i = 1 ; i < N ; i++){\n\t\t\tcin >> parent[i];\n\t\t\tparent[i]--;\n\t\t}\n\t\tmarked[0] = true; \n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'M' ){\n\t\t\t\tif( marked[v] ) continue;\n\t\t\t\tmarked[v] = true;\n\t\t\t}\n\t\t\tQ.push_back({c=='M',v});\n\t\t}\n\t\treverse(Q.begin(),Q.end());\n\t\tlong long ans = 0;\n\t\tfor( auto q : Q ){\n\t\t\tif( q.first ){\n\t\t\t\tmarked[q.second] = false;\n\t\t\t}else{\n\t\t\t\tans += get(q.second)+1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nchar s[10];\n\nint u,n,q,mark[100005],query[100005],id[100005],a[100005],tot,fa[100005];\n\nint fin(int cur,int id)\n{\n\treturn mark[cur]<id?cur:(fa[cur]=fin(fa[cur],id));\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d\",&n,&q)&&n){\n        memset(mark,0x3f,sizeof(mark));\n\t\tfor(int i=2;i<=n;i++) scanf(\"%d\",&fa[i]);\n\t\tfa[1]=1;mark[1]=0;tot=0;\n\n\t\tfor(int i=1;i<=q;i++) {\n\t\t\tscanf(\"%s%d\",s+1,&u);\n\t\t\tif(s[1]=='M') mark[u]=i;\n\t\t\telse query[++tot]=u,id[tot]=i;\n\t\t}\n\t\tlong long ans=0;\n\t\tfor(int i=tot;i>=1;i--){\n\t\t\tans+=fin(query[i],id[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct BIT{\n\tvector<ll> dat;\n\tint n;\n\n\tBIT(int _n){\n\t\tdat = vector<ll>(n = _n);\n\t}\n\n\tvoid add(int x, ll val){\n\t\tfor (int i = x; i < n; i += i&-i) dat[i] += val;\n\t}\n\tint sum(int x){\n\t\tll s = 0;\n\t\tfor (int i = x; i > 0; i -= i&-i) s += dat[i];\n\t\treturn s;\n\t}\n};\n\nconst int N = 1e5 + 10;\n\nvector<int> G[N];\n\nint idx[N][2];\n\nvoid dfs(){\n\tint i = 1;\n\tstack<int> st;\n\tst.push(0);\n\twhile (!st.empty()){\n\t\tint v = st.top();\n\t\tif (idx[v][0] < 0){\n\t\t\tidx[v][0] = i++;\n\t\t\tfor (auto nxt : G[v]){\n\t\t\t\tst.push(nxt);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tidx[v][1] = i++;\n\t\t\tst.pop();\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n){\n\t\trep(i, N) G[i].clear();\n\t\tFOR(i, 1, n){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p - 1].push_back(i);\n\t\t}\n\t\tMEMSET(idx, -1);\n\t\tdfs();\n\n\t\tBIT bit(n * 2 + 10);\n\n\t\tll ans = 0;\n\t\twhile (q--){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif (c == 'Q'){\n\t\t\t\t++ans;\n\t\t\t\tans += bit.sum(idx[v][0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// [idx[v][0], idx[v][1]] => v\n\t\t\t\tint x = bit.sum(idx[v][0]);\n\t\t\t\tbit.add(idx[v][0], -x + v);\n\t\t\t\tbit.add(idx[v][1] + 1, x - v);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, q, p[100000];\nint m[100000], v[100000];\nchar type[100000];\nvector<vi> e;\n\nint pa[100000];\nint root(int x){\n\tif(x == pa[x]) return x;\n\treturn pa[x] = root(pa[x]);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &q), n){\n\t\te.clear(); e.resize(n);\n\t\tmemset(m, 0, sizeof(m));\n\t\t\n\t\trep(i, n - 1){\n\t\t\tscanf(\"%d\", p + i + 1), p[i + 1]--;\n\t\t\te[i].pb(p[i + 1]);\n\t\t\te[p[i + 1]].pb(i);\n\t\t}\n\t\trep(i, q){\n\t\t\tscanf(\" %c%d\", type + i, v + i);\n\t\t\tv[i]--;\n\t\t\tif(type[i] == 'M') m[v[i]]++;\n\t\t}\n\t\tm[0] = 1;\n\t\t\n\t\tqueue<pi> Q;\n\t\trep(i, n){\n\t\t\tpa[i] = i;\n\t\t\tif(m[i]) Q.push(mp(i, i));\n\t\t}\n\t\twhile(!Q.empty()){\n\t\t\tint c = Q.front().first, r = Q.front().second;\n\t\t\tQ.pop();\n\t\t\trep(i, e[c].size()) if(!m[e[c][i]]){\n\t\t\t\tpa[e[c][i]] = r;\n\t\t\t\tQ.push(mp(e[c][i], r));\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i = q - 1; i >= 0; i--){\n\t\t\tif(type[i] == 'M'){\n\t\t\t\tif(--m[v[i]] == 0) pa[v[i]] = root(p[v[i]]);\n\t\t\t}\n\t\t\telse ans += root(v[i]) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n/*#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>*/\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct UnionFind\n{\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tUnionFind(int N) :parent(N, 0), rank(N, 0)\n\t{\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif (x == y)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (rank[x] < rank[y])\n\t\t{\n\t\t\tparent[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvector<int> G[100005];\nint anc[100005];\n\nvoid dfs(int nv, int tanc)\n{\n\tanc[nv] = tanc;\n\tfor (auto n : G[nv])\n\t{\n\t\tdfs(n, tanc);\n\t}\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true)\n\t{\n\t\tint N, Q;\n\t\tcin >> N >> Q;\n\t\tif (N + Q == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint to;\n\t\trep(i, 0, N - 1)\n\t\t{\n\t\t\tcin >> to;\n\t\t\tG[to - 1].push_back(i + 1);\n\t\t}\n\t\tchar c;\n\t\tint v;\n\t\tll ans = 0;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')\n\t\t\t{\n\t\t\t\tdfs(v - 1, v - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += anc[v - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nint main(){\n  while(1){\n    vector<node> T;\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    node root;\n    root.marked = true;\n    root.parent = 0;\n    root.num = 1;\n    T.push_back(root);\n    for(int i=2;i<=n;i++){\n      int parent;\n      cin >> parent;\n      T.push_back((child){false,i,parent-1});\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }else{\n        node n = T[v-1];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q') ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            else marks.insert(mp(-d, qv[i]));\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n            else h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tset<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tif(lca.getDepth(v) - lca.getDepth(*u) == d)\n\t\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.insert(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, int>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), *u);\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tpii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v] < c) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tc.first ++;\n\t\t\t\t\tFOR(e, g[v]){\n\t\t\t\t\t\tif(chmin(res[e->first], c))\n\t\t\t\t\t\t\tque.emplace(c, e->first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nint parent[100000];\nbool is_mark[100000], is_root[100000];\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tint input;\n\t\t\tcin >> input;\n\t\t\tparent[i] = --input;\n\t\t}\n\n\t\tstack<int> value;\n\t\tmemset(is_root, false, sizeof(is_root));\n\t\tis_root[0] = true;\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tvalue.push(v);\n\t\t\tif(ope == 'Q')\n\t\t\t\tis_mark[i] = false;\n\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tis_root[v] = true;\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tint ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tint v = value.top();\n\t\t\tvalue.pop();\n\n\t\t\tif(is_mark[i])\n\t\t\t\tuf.unite(v, parent[v]);\n\n\t\t\telse\n\t\t\t\tans += uf.find(v) + 1;\n\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\t//bh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst int qmax=100010;\n\nvi trees[nmax];\nint p[nmax];\nint last[nmax];\n\nvoid add_edge(int a,int b){\n\ttrees[a].pb(b);\n\ttrees[b].pb(a);\n}\n\nint uf[nmax];\nint find(int i){\n\tif(uf[i]==i)\n\t\treturn i;\n\treturn uf[i]=find(uf[i]);\n}\n\nvoid unite(int p,int c){\n\tuf[c]=p;\n\treturn;\n}\n\n\nvoid dfs(int v,int p){\n\tif(last[v]==-1)\n\t\tunite(p,v);\n\tfor(auto &e:trees[v]){\n\t\tif(e!=p)\n\t\t\tdfs(e,v);\n\t}\n}\n\n\nchar type[qmax];\nint num[qmax];\n\nint main(void){\n\tint n,q;\n\twhile(cin >> n >> q){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\ttrees[i].clear();\n\t\t\tuf[i]=i;\n\t\t\tlast[i]=-1;\n\t\t}\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tcin >> p[i];\n\t\t\tadd_edge(p[i],i);\n\t\t}\n\t\tlast[1]=-2;\n\t\trep(i,q){\n\t\t\tcin >> type[i] >> num[i];\n\t\t\tif(type[i]=='M'&&last[num[i]]==-1)\n\t\t\t\tlast[num[i]]=i;\n\t\t}\n\t\tdfs(1,-1);\n\t\tll ans=0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tdump(i)\n\t\t\tdump(ans)\n\t\t\tif(type[i]=='Q')\n\t\t\t\tans+=find(num[i]);\n\t\t\telse{\n\t\t\t\tif(last[num[i]]==i)\n\t\t\t\t\tunite(p[num[i]],num[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void print() {\n    for (int i = 0; i < par.size(); i++) cerr << find(i) << \" \";\n    cerr << endl;\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nvoid dfs(int idx, int par) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(par, idx);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par);\n  }\n}\n\nLL solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  marked = vector<bool>(N);\n  marked[0] = true;\n  for (int i = 0; i < Q; i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  tree = UnionFindTree(N);\n  //dfs(0, -1);\n  for (int i = 0; i < N; i++) {\n    if (!marked[i]) tree.unite(parent[i], i);\n  }\n\n  tree.print();\n\n  LL res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n  tree.print();\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    LL ans = solve(N, Q, parent, queries);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T, int* OT);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tint OrigT[N+1];\n\t\tT[1] = OrigT[1] = 1;\n\t\tfor(int i=2; i<=N; i++){ cin >> T[i]; OrigT[i] = T[i]; }\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(v, T, OrigT); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T, int* OT){\n\tint ans = OT[v];;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef tuple<int,int> P;\ntypedef vector<int> V;\ntypedef vector<V> Graph;\n#define PB push_back\n\nstruct INIT{INIT(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto &it:v)\nvoid make_tree(int v,Graph& G,V& P,V& D, Graph& C){\n    range(e,G[v]){\n\tif(e!=P[v]){\n\t    C[v].PB(e);\n\t    D[e]=D[v]+1;\n\t    P[e]=v;\n\t    make_tree(e,G,P,D,C);\n\t}\n    }\n}\n\nvoid euler_tour(int v,Graph &C,vector<P>& seg,int &cnt){\n    int l=cnt++;\n    range(e,C[v])\n\teuler_tour(e,C,seg,cnt);\n    int r=cnt++;\n    seg[v]=P(l,r);\n}\n\n#define SIZE 1000000\n#define L(v) (v*2+1)\n#define R(v) (v*2+2)\n#define SET 0\n#define ADD 1\n#define GET 2\ntypedef P val;\nstruct node{\n    int bg,ed;\n    val v;\n    inline val getval(){\n\treturn v;\n    }\n    inline void init(int b,int e){\n\tbg =b,ed=e;\n\tv=val(-1,-1);\n    }\n    bool isleaf(){return bg==ed;}\n}mem[SIZE];\ninline val comb(val l,val r){\n\treturn max(l,r);\n    }\nclass segTree{\nprivate:node *t;\n    void make_tree(int bg,int ed,int v=0){\n\tnode *p=t+v;\n\tp->init(bg,ed);\n\tif(!p->isleaf()){\n\t    int m=(bg+ed)/2;\n\t    make_tree(bg,m,L(v));\n\t    make_tree(m+1,ed,R(v));\n\t}\n    }\npublic:\n    segTree(int bg,int ed):t(mem){make_tree(bg,ed);}\n    inline void lazy_update(int v){\n\tnode *p=t+v,*l=t+L(v),*r=t+R(v);\n\tif(p->isleaf())return;\n\tl->v=comb(p->v,l->v);\n\tr->v=comb(p->v,r->v);\n    }\n    val treat(int type,int bg,int ed,val x,int v=0){\n\tnode *p=t+v,*l=t+L(v),*r=t+R(v);\n\tlazy_update(v);\n\tif(P(bg,ed)==P(p->bg,p->ed)){\n\t    if(type==ADD)p->v=comb(p->v,x);\n\t    return p->v;\n\t}\n\tint m;\n\tval res=P(-1,-1);\n\tif(bg<=(m=min(ed,l->ed)))\n\t    res=comb(res,treat(type,bg,m,x,L(v)));\n\tif((m=max(bg,r->bg))<=ed)\n\t    res=comb(res,treat(type,m,ed,x,R(v)));\n\treturn res;\n    }\n    val get(int bg,int ed){\n\treturn treat(GET,bg,ed,val());\n    }\n    void add(int bg,int ed,val x){\n\ttreat(ADD,bg,ed,x);\n    }\n};\n\nconst int root=1;\nint main(){\n    for(int N,Q;cin>>N>>Q,N+Q;){\n\tGraph g(N+1),child(N+1);\n\tV depth(N+1,0),par(N+1,0);\n\tvector<P> seg(N+1);\n\tfor(int i=2;i<=N;i++){\n\t    int j;\n\t    cin>>j;\n\t    g[i].PB(j);\n\t    g[j].PB(i);\n\t}\n\tmake_tree(root,g,par,depth,child);\n\tint sz=0;\n\teuler_tour(root,child,seg,sz);\n\tsegTree tree(0,sz);\n\ttree.add(1,sz-2,P(0,1));\n\tlong long res=0;\n\twhile(Q--){\n\t    string op;int v;\n\t    cin>>op>>v;\n\t    int l,r;\n\t    tie(l,r)=seg[v];\n\t    if(op==\"M\"){\n\t\tif(l+1<=r-1)\n\t\t    tree.add(l+1,r-1,P(depth[v],v));\n\t    }\n\t    else{\n\t\tint d,p;\n\t\ttie(d,p)=tree.get(l,l);\n\t\tres+=p;\n\t    }\n\t}\n\tcout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX=100000;\n\nbool marked[MAX];\nint node[MAX];\nint parent[MAX];\n\nint find(int s)\n{\n\tint i=s;\n\twhile(!marked[i])i=parent[i];\n\treturn i;\n}\n\nint main()\n{\n\tint n,q;cin>>n>>q;\n\tint a;char c;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tcin>>a;a--;\n\t\tparent[i]=a;\n\t}\n\tparent[0]=0;\n\tmarked[0]=true;\n\tint sum=0;\n\tfor(int i=0;i<=q;i++)\n\t{\n\t\tcin>>c>>a;a--;\n\t\tif(c=='Q')\n\t\t{\n\t\t\tsum+=find(a)+1;\n\t\t}\n\t\telse if(c=='M')\n\t\t{\n\t\t\tmarked[a]=true;\n\t\t}\n\t\telse break;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  while(1) {\n    int k = 0;\n    for(int i = 0; i < 1000000000; ++i) k += i;\n    cout << 0 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nMarked Ancestor(https://onlinejudge.u-aizu.ac.jp/#/problems/2170)\n*/\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma, ism;\nvector <query> q;\n\n//find nearest marked ancestor (経路圧縮 at the same time)\nll find_nma(ll x){\n\tif (nma[x] == x) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd]++;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd]--;\n\t\t\t\tif (!ism[q[i].snd]) nma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nconst int INF=1000000000;\n\nclass UnionFindTree{\npublic:\n  // index&#65533;&#784;&#65533;&#65533;&#784;e&#65533;m&#65533;[&#65533;h(&#65533;&#65533;&#65533;&#65533;W&#65533;&#65533;&#65533;&#784;e&#65533;&#65533;&#130;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#386;&#65533;&#65533;&#834;&#65533;&#65533;&#65533;&#65533;&#77584;&#1678;Q&#65533;&#386;&#65533;&#65533;&#65533;&#65533;Afind&#65533;&#65533;g&#65533;&#65533;)\n  vector<int> par;\n  // index&#65533;&#65533;&#386;&#65533;&#65533;&#65533;&#1538;&#771;&#65533;&#65533;&#65533;&#65533;N\n  vector<int> rank;\n  // &#65533;&#65533;&#65533;&#65533;W&#65533;&#65533;&#65533;&#785;&#65533;\\&#65533;l\n  vector<int> val;\n  // &#65533;&#1538;&#781;&#337;&#65533;l\n  int treeSize;\npublic:\n  UnionFindTree(int initTreeSize = 1000){\n    // &#65533;&#65533;&#343;^&#65533;&#65533;&#65533;&#65533;&#41149;&#65533;l&#65533;&#65533;&#337;&#65533;i&#65533;[&#65533;&#65533;&#65533;&#386;&#65533;&#65533;&#65533;UnionFindTree&#65533;&#781;&#50220;\n    treeSize = initTreeSize;\n    init();\n  }\n  void init(){\n    for(int i = 0; i < treeSize; i++){\n      par.push_back(i);\n      rank.push_back(0);\n      val.push_back(-1);\n    }\n  }\n  // &#65533;^&#65533;&#65533;&#65533;&#65533;&#41149;&#65533;&#65533;&#65533;&#65533;&#65533;i&#65533;[&#65533;&#65533;&#65533;&#65533;&#258;&#65533;&#65533;&#65533;&#1538;&#771;&#65533;&#65533;[&#65533;g&#65533;&#65533;T&#65533;&#65533;\n  int find(int x){  \n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  // &#65533;a&#65533;W&#65533;&#65533;&#65533;&#65533;&#386;&#65533;B&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#322;&#842;e&#65533;W&#65533;&#65533;&#65533;&#784;e&#65533;&#789;t&#65533;&#65533;&#65533;&#1410;&#65533;&#65533;&#843;N&#65533;&#65533;&#65533;&#65533;&#514;&#65533;\n  void unite(int x,int y,int a){\n    x = find(x);\n    y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y])par[x] = y;\n    else{\n      par[y] = x;\n      if(rank[y] == rank[x])rank[x]++;\n    }\n    // val&#65533;&#783;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;\n    val[find(x)]=a;\n  }\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n    \n};\n\ntypedef pair<char,int>  pci;\nconst int MAX_V=100001;\nvector<int> G[MAX_V];\npci ods[MAX_V];\nint N,Q;\nbool mark[MAX_V];\nint firstMark[MAX_V];\nint pars[MAX_V];\n\n// curMark&#65533;&#844;&#65533;&#65533;&#1858;&#771;m&#65533;[&#65533;h&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;&#65533;e&#65533;m&#65533;[&#65533;h\nvoid dfs(int s,int curMark,UnionFindTree &uft){\n  if(mark[s]){\n    for(int i=0;i<G[s].size();i++){\n      int to=G[s][i];\n      dfs(to,s,uft);\n    }\n    int idx=uft.find(s);\n    uft.val[idx]=s;\n  }\n  else{\n    uft.unite(s,curMark,-1);\n    for(int i=0;i<G[s].size();i++){\n      int to=G[s][i];\n      dfs(to,curMark,uft);\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N>>Q&&(N|Q)){\n    memset(mark,0,sizeof(mark));\n    memset(firstMark,0,sizeof(firstMark));\n    UnionFindTree uft(N);\n    for(int i=0;i<N;i++)G[i].clear();\n    for(int i=1;i<N;i++){\n      int par;\n      cin>>par;\n      par--;\n      G[par].push_back(i);\n      pars[i]=par;\n    }\n    mark[0]=true;\n    firstMark[0]++;\n    // &#65533;}&#65533;[&#65533;N&#65533;&#65533;&#130;&#65533;&#65533;&#258;&#65533;&#65533;&#65533;\n    for(int i=0;i<Q;i++){\n      cin>>ods[i].first>>ods[i].second;\n      ods[i].second--;\n      if(ods[i].first=='M'){\n\tfirstMark[ods[i].second]++;\n\tmark[ods[i].second]=true;\n      }\n    }\n    // &#65533;&#267;A&#65533;&#65533;&#65533;&#65533;&#65533;&#578;&#65533;&#65533;A&#65533;e&#65533;W&#65533;&#65533;&#65533;&#88714;&#65533;&#65533;&#65533;&#65533;&#65533;\n    dfs(0,-1,uft);\n    int res=0;\n    // &#65533;&#65533;&#65533;&#65533;&#65533;&#65533;A&#65533;N&#65533;G&#65533;&#65533;&#65533;&#65533;&#65533;&#45225;&#65533;àÛ&#65533;&#65533;&#65533;&#65533;&#65533;&#258;&#65533;&#65533;&#65533;\n    for(int i=Q-1;i>=0;i--){\n      if(ods[i].first=='Q'){\n\tint a=uft.find(ods[i].second);\n\tint b=uft.val[a];\n\tres+=b+1;\n      }\n      else{\n\tfirstMark[ods[i].second]--;\n\tif(firstMark[ods[i].second]>0)continue;\n\t// &#65533;e&#65533;m&#65533;[&#65533;h&#65533;&#785;&#65533;&#65533;&#65533;&#65533;&#65533;&#1538;&#396;&#65533;&#65533;&#65533;\n\tint a=uft.val[uft.find(pars[ods[i].second])];\n\tuft.unite(ods[i].second,pars[ods[i].second],a);\n      }\n    }\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<long long int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<long long int> sizes;\n\n  UnionFind(long long int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    rep(i,n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  long long int find(long long int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(long long int x, long long int y) {\n    x = find(x);\n    y = find(y);\n\n    if (x == y) return;\n\n    if (x > y) swap(x, y);\n\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n\n  bool same(long long int x, long long int y) {\n    return find(x) == find(y);\n  }\n\n  int size(long long int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\ta[1] = 1;\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\troots.insert(1);\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unite(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unite(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.find(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nconst int MAXN = 100000 + 10;\nint par[MAXN];\nint Find(int x){\n\tif (x == par[x])\n\t\treturn par[x];\n\treturn Find(par[x]);\n}\nint main(){\n\tint n, q;\n\tchar ins[10];\n\tint v;\n\n\twhile (~scanf(\"%d%d\", &n, &q) && (n || q)){\n\t\tlong long sum = 0;\n\t\tmemset(par, 0, sizeof(par));\n\t\tpar[1] = 1;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%s%d\", ins, &v);\n\t\t\tif (strcmp(ins, \"M\") == 0){\n\t\t\t\tpar[v] = v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += Find(v);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 100000;\n\nint n, p;\nint pre[N+1];\n\nint find(int x)\n{\n    while (x != pre[x])\n        x = pre[x];\n    return x;\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &n, &p) != EOF) {\n        if (!n && !p) break;\n        pre[1] = 1;\n        for (int i = 2; i <= n; i ++)\n            scanf(\"%d\", &pre[i]);\n        long long sum = 0;\n        for (int i = 1; i <= p; i ++) {\n            char s[2];\n            int x;\n            scanf(\"%s%d\", s, &x);\n            if (s[0] == 'M')\n                pre[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int maxn=100010;\ntypedef struct p\n{\n\tint par,vis;\n}p;\np s[maxn];\n\nvoid init(int n){\n\tfor(int i=1;i<=n;i++){\n\t\ts[i].par=i;\n\t\ts[i].vis=0;\n\t}\n}\nint main()\n{\n\tint n,q;\n\twhile(cin>>n>>q)\n\t{\n\t\tif(n+q==0)  break;\n\t\tinit(n);\n\t\ts[1].vis=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\ts[i].par=x;\n\t\t}\n\t\tgetchar();\n\t\tlong long sum=0;\n\t\twhile(q--){\n\t\t\tchar sh;\n\t\t\tint a;\n\t\t\tscanf(\"%c%d%*c\",&sh,&a);\n\t\t\tif(sh=='M'){\n\t\t\t\ts[a].vis=1;\n\t\t\t}else{\n\t\t\t\tif(s[a].vis==1){\n\t\t\t\t\tsum+=a;\n\t\t\t\t}else{\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(s[a].vis==1){\n\t\t\t\t\t\t\tsum+=a;  break;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ta=s[a].par;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\ntypedef pair<char,int> cp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint n,m;\n\nvector<int> vs[100005];\nint uni[100010];\nint ma[100005];\nint marked[100005];\n\nvoid dfs(int no,int p){\n\tma[no] = p;\n\tif(marked[no]>=1)p = no;\n\telse uni[no] = p;\n\t\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i],p);\n\t}\n}\n\nint find(int p){\n\tif(uni[p] == p)return p;\n\tuni[p] = find(uni[p]);\n\treturn uni[p];\n}\n\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\treg(i,1,n){\n\t\t\tvs[i].clear();\n\t\t\tuni[i] = i;\n\t\t}\n\t\tmemset(marked,0,sizeof(marked));\n\t\t\n\t\treg(i,2,n){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[a].push_back(i);\n\t\t}\n\t\t\n\t\tvector<cp> qs;\n\t\trep(i,m){\n\t\t\tint a;\n\t\t\tchar s[5];\n\t\t\tscanf(\"%s%d\",s,&a);\n\t\t\tif(s[0]=='M')marked[a]++;\n\t\t\tqs.push_back(cp(s[0],a));\n\t\t}\n\t\t\n\t\tmarked[1] = 1;\n\t\tdfs(1,1);\n\t\t\n\t\tlli ans = 0;\n\t\tirep(i,qs.size()){\n\t\t\tint a = qs[i].sec;\n\t\t\tif(qs[i].fir == 'Q'){\n\t\t\t\tlli na = find(a);\n\t\t\t\tans += na;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmarked[a]--;\n\t\t\t\tif(marked[a]>0)continue;\n\t\t\t\t//if(find(a) == find(ma[a]))continue;\n\t\t\t\tuni[a] = find(ma[a]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tll ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\ttb[e[j].m] = e[e[j].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\tint last = to;\n\t\t\t\tto = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\ttb[to] = last;\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\tans += tb[to] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = -1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\tarr[1].isMarked = true;\n\t\tarr[1].nearest_index = 1;\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tif (arr[_index].isMarked == true)return;\n\t\tarr[_index].isMarked = true;\n\t\tarr[_index].nearest_index = _index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\toperationM(itr);\n\t\t}\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tset<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tif(lca.getDepth(v) - lca.getDepth(*u) == d)\n\t\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.insert(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, int>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), *u);\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tpii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v] < c) continue;\n\t\t\t\t\tc.first ++;\n\t\t\t\t\tFOR(e, g[v]){\n\t\t\t\t\t\tif(chmin(res[e->first], c))\n\t\t\t\t\t\t\tque.emplace(c, e->first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    int node = n;\n    while(flag[t[node]] != 1 )\n\t{\n\t    node = t[node];\n\t}\n    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n//#ifndef ONLINE_JUDGE\n//    READ;\n//#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 0;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    if(ch == 'M')\n\t\tflag[tmp] = 1;\n\t    if(ch == 'Q')\n\t\tret = ret + find(tmp);\n\t}\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\n/**\n * @brief an extended structure of union-find tree\n * @note this is for the problem \"Spaceships\", JOI Sprint Training Camp (http://imoz.jp/data/joi/2013-sp-d4-spaceships.pdf)\n * @note in each splay tree, nodes are sorted from bottom to top. the rightmost node of the root splay tree of the auxiliary tree is the root of represented tree.\n */\nclass link_cut_tree {\n    std::vector<int> parent, left, right;  // of the auxiliary tree\n\n    /**\n     * @description returns whether `a` and `parent[a]` is in the same splay tree\n     */\n    int get_parent_edge_type(int a) const {\n        if (parent[a] != -1 and left[parent[a]] == a) {\n            return -1;  // heavy (left)\n        } else if (parent[a] != -1 and right[parent[a]] == a) {\n            return +1;  // heavy (right)\n        } else {\n            return 0;  // light\n        }\n    }\n\n    /**\n     * @description make `a` the parent of the current parent of `a`\n     */\n    void rotate(int a) {\n        int b = parent[a];\n        switch (get_parent_edge_type(b)) {\n            case -1:  // left\n                left[parent[b]] = a;\n                break;\n            case 1:  // right\n                right[parent[b]] = a;\n                break;\n        }\n        switch (get_parent_edge_type(a)) {\n            case -1:  // left\n                parent[a] = std::exchange(parent[b], a);\n                left[b] = std::exchange(right[a], b);\n                if (left[b] != -1) parent[left[b]] = b;\n                break;\n            case 1:  // right\n                parent[a] = std::exchange(parent[b], a);\n                right[b] = std::exchange(left[a], b);\n                if (right[b] != -1) parent[right[b]] = b;\n                break;\n            default:  // root\n                assert (false);\n        }\n    }\n\n    /**\n     * @description make `a` the root of the beloging splay tree\n     */\n    void splay(int a) {\n        while (get_parent_edge_type(a)) {\n            // a is not the root of the splay tree\n            if (not get_parent_edge_type(parent[a])) {\n                // zig step: parent[a] is the root of the splay tree\n                rotate(a);\n            } else if (get_parent_edge_type(a) == get_parent_edge_type(parent[a])) {\n                // zig-zig step\n                rotate(parent[a]);\n                rotate(a);\n            } else {\n                // zig-zag step\n                rotate(a);\n                rotate(a);\n            }\n        }\n    }\n\n    /**\n     * @description make `a` belongs the root of the auxiliary tree\n     * @note doen't splay\n     * @note `a` must not be a terminal of the heavy path\n     */\n    void expose(int a) {\n        // make a light path from `a` to the root\n        for (int b = a; b != -1; b = parent[b]) {\n            splay(b);\n        }\n        // make the path heavy\n        for (int b = a; parent[b] != -1; b = parent[b]) {\n            left[parent[b]] = b;\n        }\n    }\n\n    void access(int a) {\n        expose(a);\n        splay(a);\n        assert (parent[a] == -1);\n    }\n\npublic:\n    link_cut_tree(int size)\n            : parent(size, -1), left(size, -1), right(size, -1) {\n    }\n\n    /**\n     * @description make a direct edge from `a` to `b`\n     * @note `a` must be a root\n     * @note `b` must not be a descendant of `a`\n     */\n    void link(int a, int b) {\n        access(b);  // for the time complexity\n        access(a);  // to make a the root\n        assert (right[a] == -1);  // a must be a root\n        parent[a] = b;\n    }\n\n    /**\n     * @description remove the direct edge from `a`\n     */\n    void cut(int a) {\n        access(a);  // to make a the root\n        if (right[a] == -1) return;  // there is no parent on the represented tree\n        parent[right[a]] = -1;\n        right[a] = -1;\n    }\n\n    /**\n     * @note -1 is returned when `a` and `b` are not in the same tree\n     */\n    int get_lowest_common_ancestor(int a, int b) {\n        access(b);  // for the time complexity\n        access(a);  // to make `a` the root\n        left[a] = -1;  // make `a` and `b` belong different splay trees if `b` is a descendant of `a`\n        int result = b;\n        int c = b;\n        for (; c != a and c != -1; c = parent[c]) {\n            if (parent[c] != -1 and not get_parent_edge_type(c)) {  // when it enters another splay tree\n                result = parent[c];\n            }\n        }\n        return c == a ? result : -1;\n    }\n\n    bool is_same_tree(int a, int b) {\n        return get_lowest_common_ancestor(a, b) != -1;\n    }\n\n    /**\n     * @note in represented tree\n     */\n    int get_parent(int a) {\n        splay(a);\n        return parent[a];\n    }\n\n    int get_root(int a) {\n        access(a);\n        while (right[a] != -1) {\n            a = right[a];\n        }\n        return a;\n    }\n\n    std::string to_graphviz() const {\n        using namespace std;\n        ostringstream oss;\n        oss << \"digraph G {\" << endl;\n        oss << \"    graph [ rankdir = BT, bgcolor = \\\"#00000000\\\" ]\" << endl;\n        oss << \"    node [ shape = circle, style = filled, fillcolor = \\\"#ffffffff\\\" ]\" << endl;\n        function <void (int)> go = [&](int a) {\n            if (parent[a] != -1 and not get_parent_edge_type(a)) {\n                oss << \"    \" << a << \" -> \" << parent[a] << \" [ style = dashed ]\" << endl;\n            }\n            if (left[a] != -1 or right[a] != -1) {\n                string l = (left[a] != -1 ? to_string(left[a]) : \"l\" + to_string(a));\n                string r = (right[a] != -1 ? to_string(right[a]) : \"r\" + to_string(a));\n                oss << \"    \" << l << \" -> \" << a << endl;\n                oss << \"    \" << l << \" -> \" << r << \" [ style = invis ]\" << endl;\n                oss << \"    \" << r << \" -> \" << a << endl;\n                oss << \"    { rank = same; \" << l << \"; \" << r << \"; }\" << endl;\n                if (left[a] == -1) oss << \"    \" << l << \" [ style = invis ]\" << endl;\n                if (right[a] == -1) oss << \"    \" << r << \" [ style = invis ]\" << endl;\n            }\n            if (left[a] != -1) go(left[a]);\n            if (right[a] != -1) go(right[a]);\n        };\n        REP (a, parent.size()) if (not get_parent_edge_type(a)) {\n            go(a);\n        }\n        oss << \"}\";\n        return oss.str();\n    }\n};\n\n\nint main() {\n    while (true) {\n        int n, q; cin >> n >> q;\n        if (n == 0 and q == 0) break;\n\n        link_cut_tree lct(n);\n        REP3 (i, 1, n) {\n            int parent; cin >> parent;\n            -- parent;\n            lct.link(i, parent);\n        }\n\n        long long sum = 0;\n        while (q --) {\n            char c; int v; cin >> c >> v;\n            -- v;\n            if (c == 'M') {\n                lct.cut(v);\n            } else if (c == 'Q') {\n                sum += lct.get_root(v) + 1;\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\ntypedef struct {\n    bool L, R;\n} p_t;\n\nInt n, q;\nvector<Int> G[100001];\nbool marked[100001];\n\nInt dfs(Int x) {\n    if (marked[x]) return x;\n    for (Int i = 0; i < (Int)G[x].size(); i++) {\n        //cout << x << \" to \" << G[x][i] << endl;\n        return dfs(G[x][i]);\n    }\n}\n\nint main() {\n    vector<Int> res;\n    Int cnt = 0;\n    while (cin >> n >> q and n) {\n        // if (cnt == 0) {\n        //     cnt++;\n        //     continue;\n        // }\n        for (Int i = 0; i <= 100000; i++) {\n            while (not G[i].empty()) G[i].pop_back();\n            marked[i] = false;\n        }\n        for (Int i = 2; i <= n; i++) {\n            Int x;\n            cin >> x;\n            G[i].push_back(x);\n        }\n        marked[1] = true;\n        Int sum = 0;\n        for (Int i = 0; i < q; i++) {\n            char com;\n            Int x;\n            cin >> com >> x;\n            if (com == 'Q') {\n                sum += dfs(x);\n            }\n            if (com == 'M') {\n                marked[x] = true;\n            }\n        }\n        //dump(sum);\n        res.push_back(sum);\n    }\n    for (int i = 0; i < (int)res.size(); i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tint ancestor[100000] = {}, ismarked[100000] = {};\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint tmp = outlog[i].second;\n\t\t\tif (outlog[i].first == 'M' )uf.unite(ancestor[tmp], tmp);\n\t\t\telse {\n\t\t\t\tans += uf.getroot(tmp) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//for (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\nvector<int> par,Rank,mark;\nvoid init(int n){\n\tpar.resize(n,0);\n\tRank.resize(n,0);\n\tmark.resize(n,0);\n\tmark[0] = 1;\n\tREP(i,n)par[i] = i;\n}\n\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\n\nint mark_find(int x){\n\tif(mark[x])return x;\n\telse return mark_find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\tif(Rank[x] > Rank[y])par[y] = x;\n\telse{\n\t\tpar[x] = y;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x,int y){return find(x) == find(y);}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n||m){\n\t\tinit(n);\n\t\tREP(i,n-1){cin >> par[i];par[i]--;}\n\t\tint ans = 0;\n\t\tREP(i,m){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M'){\n\t\t\t\tmark[v-1] = 1;\n\t\t\t}else if(c == 'Q'){\n\t\t\t\tans += mark_find(v-1) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint un[100000];\nint find(int x){\n  if(x==un[x]) return x;\n  return un[x]=find(un[x]);\n}\n\nvoid unit(int a,int b){\n  un[find(a)]=find(b);\n}\n\nint pa[100000];\n\nint main(){\n  int n,q;\n  while(cin >> n >> q && n){\n    rep(i,n-1){\n      cin >> pa[i+1];\n      --pa[i+1];\n      un[i+1]=pa[i+1];\n    }\n  \n    vector<PI> que;\n    ll ans=0;\n    rep(i,q){\n      char ch;\n      int a;\n      cin >> ch >> a;\n      --a;\n      que.pb(mp(ch,a));\n      if(ch=='M') un[a]=a;\n    }\n\n    reverse(ALL(que));\n    FOR(it,que){\n      if(it->F=='M') unit(it->S,pa[it->S]);\n      else ans+=find(it->S)+1;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nint par[MAX_N+1];//parents\nint Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint N,Q;\nlong long sum = 0;\nint tree[MAX_N+1];\n\nint nearestAncstr(int num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,int num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nint num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\tfor(int i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tcin >>symbol >>num;num--;\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(true){\n\t\tif(symbol == '0' && num == 0)break;\n\t\toperate(symbol,num);\n\t\tcin >>symbol >>num;num--;\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\tcin >>N >>Q;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1e5+10;\n\nint n,p;\nint pa[N+1];\n\n// int find(int x){\n//     while(x != pa[x])\n//         x = pa[x];\n//     return x;\n// }\nint find(int x){\n    if(x==pa[x]) return x;\n    return find(pa[x]);\n}\n\n\nint main(){\n    while(scanf(\"%d%d\",&n,&p) == 2){\n        if(!n && !p) break;\n        pa[1] = 1;\n        for(int i=2; i<=n; i++)\n            scanf(\"%d\",&pa[i]);\n\n        long long sum = 0;\n        for(int i=1; i<=p; i++){\n            char s[2];\n            int x;\n            scanf(\"%s%d\",s,&x);\n            if(s[0] == 'M')\n                pa[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\",sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nclass NODE\n{\npublic:\n\tvector<int> anc;\n\tbool marked;\n};\n\nNODE tr[100001];\n\nint main()\n{\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\twhile (n || q)\n\t{\n\t\ttr[1].marked=true;\n\t\tfor (int i=2;i<=n;++i)\n\t\t{\n\t\t\tint pi;\n\t\t\tscanf(\"%d\",&pi);\n\t\t\tif (!tr[pi].anc.empty())\n\t\t\t\ttr[i].anc=tr[pi].anc;\n\t\t\ttr[i].anc.push_back(pi);\n\t\t\ttr[i].marked=false;\n\t\t}\n\t\tint sum=0;\n\t\tfor (int i=0;i<q;++i)\n\t\t{\n\t\t\tchar command;\n\t\t\tint v;\n\t\t\tcin>>command>>v;\n\t\t\tif (command=='M')\n\t\t\t\ttr[v].marked=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int j=tr[v].anc.size()-1;j>=0;--j)\n\t\t\t\t\tif (tr[tr[v].anc[j]].marked)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum+=tr[v].anc[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t\tscanf(\"%d%d\",&n,&q);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100005;\nint pre[maxn],vis[maxn];\nint find(int x)\n{\n\tint r=x;\n\twhile(!vis[r]&&r!=pre[r])\n\t{\n\t\tr=pre[r];\n\t}\n\treturn r;\n}\nint main()\n{\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n|m)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tpre[1]=1;\n\t\tfor(int i=2;i<=n;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&pre[i]);\n\t\t}\n\t\tll ans=0;\n\t\twhile(m--)\n\t\t{\n\t\t\tchar s[10];int x;\n\t\t\tscanf(\"%s%d\",s,&x);\n\t\t\tif(s[0]=='Q')\n\t\t\t{\n\t\t\t\tans+=find(x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvis[x]=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint find(vector<int> &par, int k){\n  if(par[k] == k) return k;\n  return par[k] = find(par,par[k]);\n}\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N){\n    vector<int> par(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n    int p[N];\n    p[0] = 0;\n    for(int i = 1; i < N; ++i){\n      cin >> p[i];\n      --p[i];\n      par[i] = p[i];\n    }\n    vector< pair<char,int> > Query;\n    char c;\n    int k, count[N];\n    fill(count,count+N,0);\n    for(int i = 0; i < Q; ++i){\n      cin >> c >> k;\n      --k;\n      if(c == 'M'){\n\tpar[k] = k;\n\t++count[k];\n      }\n      Query.push_back(make_pair(c,k));\n    }\n    reverse(Query.begin(),Query.end());\n    /*\n    for(int i = 0; i < N; ++i){\n      cout << par[i] << \" \";\n    }cout << endl;\n    */\n    long long int ans = 0;\n    for(int i = 0; i < Q; ++i){\n      c = Query[i].first;\n      k = Query[i].second;\n      if(c == 'Q'){\n\tans += (long long int)find(par,k)+1;\n      }else{\n\t--count[k];\n\tif(!count[k])\n\t  par[k] = par[p[k]];\n      }\n    }\n    /*\n    for(int i = 0; i < N; ++i){\n      cout << par[i] << \" \";\n    }cout << endl;\n    */\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[10500];\nlong long res;\nbool marked[10500];\npair<char, int> query[10500];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, false);\n\tmarked[1] = true;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    marked[query[i].second] = (query[i].first == 'M');\n\t}\n\tfor(int i=Q-1;i>=0;i--){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second] = false;\n\t    }else{\n\t\tres += r(query[i].second);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nusing namespace std;\n\nvector<int> djset;\n\nint root(int x)\n{\n    int v = djset[x];\n    while (v != djset[v]) v = djset[v];\n    return v;\n}\n\nint main(void)\n{\n    int N, Q;\n    char c;\n    int v;\n    while (true)\n    {\n        cin >> N >> Q;\n        if (!N) break;\n        djset.resize(N + 1);\n        djset[1] = 1;\n        for (int i = 2; i <= N; i++)\n        {\n            cin >> djset[i];\n            djset[i];\n        }\n        long long ans = 0;\n        while(Q)\n        {\n            cin >> c >> v;\n            if (c == 'Q') ans += root(v);\n            else djset[v] = v;\n            Q--;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, (n))\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nint parents[100005];\nbool marked[100005];\n\nint dfs(int node) { return marked[node]? node:dfs(parents[node]); }\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, q, node; char c;\n    while(cin>>n>>q, n+q) {\n        REP(i, 2, n+1) cin >> parents[i];\n        memset(marked, false, sizeof(marked));\n        marked[1] = true;\n        long long ans = 0;\n        rep(i, q) {\n            cin >> c >> node;\n            if(c == 'M') marked[node] = true;\n            else ans += dfs(node);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nint parent[101010];\nint t[101010];\n\nint get_parent(int x) {\n        if (parent[x] == -1) return x;\n        return parent[x] = get_parent(parent[x]);\n}\n\nint main() {\n        int n, q;\n        while (cin >> n >> q && n) {\n                memset(parent, -1, sizeof(parent));\n                memset(t, -1, sizeof(t));\n                for (int i = 1; i < n; i ++) {\n                        int p;\n                        cin >> p;\n                        p --;\n                        parent[i] = p;\n                        t[i] = p;\n                }\n                vector<char> s(q);\n                vector<int> node(q);\n                int cnt[101010] = { 0 };\n                rep(i, q) {\n                        cin >> s[i] >> node[i];\n                        node[i] --;\n                        if (s[i] == 'M') {\n                                cnt[node[i]] ++;\n                                parent[node[i]] = -1;\n                        }\n                }\n                long long ans = 0;\n                for (int i = q - 1; i >= 0; i --) {\n                        if (s[i] == 'Q') {\n                                ans += get_parent(node[i]) + 1;\n                        } else {\n                                if (cnt[node[i]] > 1) {\n                                        cnt[node[i]] --;\n                                        continue;\n                                }\n                                parent[node[i]] = t[node[i]];\n                        }\n                        //cout << \"====================\" << endl;\n                        //rep(i, n) cout << parent[i] << endl;\n                }\n                cout << ans << endl;\n        }\n}\n\n//bool mark[101010];\n//int g[101010];\n//\n//int dfs(int s) {\n//        return mark[s] ? s : dfs(g[s]);\n//}\n//\n//int main() {\n//        int n, q;\n//        while (cin >> n >> q && n) {\n//                memset(mark, 0, sizeof(mark));\n//                for (int i = 1; i < n; i ++) {\n//                        int p;\n//                        cin >> p;\n//                        p --;\n//                        g[i] = p;\n//                }\n//                mark[0] = true;\n//                long long ans = 0;\n//                rep(i, q) {\n//                        char s;\n//                        int v;\n//                        cin >> s >> v;\n//                        v --;\n//                        if (s == 'M') mark[v] = true;\n//                        else ans += dfs(v) + 1;\n//                }\n//                cout << ans << endl;\n//        }\n//}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(x);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nbool marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tscanf(\"%d\",fa+i);\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;marked[id]=1;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nvector<node> T;\nint main(){\n  while(1){\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    node root;\n    root.marked = true;\n    root.parent = 0;\n    root.num = 1;\n    T.push_back(root);\n    for(int i=2;i<n+1;i++){\n      int parent;\n      cin >> parent;\n      node child;\n      T.push_back(child);\n      T[i-1].marked = false;\n      T[i-1].num = i;\n      T[i-1].parent = parent-1;\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = !T[v-1].marked;\n      }\n      if(q=='Q'){\n        node n = T[v-1];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\n\nint mark[MAX_N+5];\n\nint N;\nint Q;\n\n// union-fold tree\nint par[MAX_N+5];\nint union_rank[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < n; i++) {\n        par[i] = i;\n        union_rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if(par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(union_rank[x] < union_rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if(union_rank[x] == union_rank[y]) union_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint main() {\n    int p;\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        init(N);\n        map<int, vector<int> > child;\n        for(int i = 0; i < N; i++) {\n            mark[i] = 0;\n        }\n\n        for(int i = 0; i < N-1; i++) {\n            cin >> p;\n            p--;\n            if(child.find(p) == child.end()) {\n                vector<int> v;\n                v.push_back(i+1);\n                child[p] = v;\n            } else {\n                child[p].push_back(i+1);\n            }\n        }\n        char q;\n        int o;\n        int ans = 0;\n        for(int i = 0; i < Q; i++) {\n            cin >> q >> o;\n            o--;\n            if(q == 'Q') {\n                ans += mark[find(o)] + 1;\n            } else {\n                if(child.find(o) == child.end()) {\n                    mark[o] = o;\n                } else {\n                    stack<vector<int> > s;\n                    vector<int> c;\n                    c = child[o];\n                    s.push(c);\n                    while(s.size()) {\n                        c = s.top(); s.pop();\n                        for(int j = 0; j < c.size(); j++) {\n                            unite(o, c[j]);\n                            if(child.find(c[j]) != child.end()) {\n                                s.push(child[c[j]]);\n                            }\n                        }\n                    }\n                    mark[find(o)] = o;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss;\n\nstruct Node{\n\tbool isMarked;\n\tint marked_time; //????????????????????????\n};\n\nstruct Query{\n\tQuery(int arg_query_time,int arg_value){\n\t\tquery_time = arg_query_time;\n\t\tvalue = arg_value;\n\t}\n\tint query_time,value;\n};\n\nNode*info;\n\n//???????????????????????????????±????????????????????????§?????????\nint get_marked_boss(int id,int query_time){\n\tif(info[id].isMarked == true && info[id].marked_time < query_time){ //?????¨??????????????????????????????????????????????????????????????£?????´???\n\t\treturn id;\n\t}else{\n\t\treturn marked_boss[id] = get_marked_boss(marked_boss[id],query_time);\n\t}\n}\n\n\nint main(){\n\n\tint Q,value;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\tinfo = (Node*)malloc(sizeof(Node)*(100001));\n\n\tstack<Query> S;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tinfo[i].isMarked = false;\n\t\t}\n\n\t\tmarked_boss[1] = 1;\n\t\tinfo[1].isMarked = true;\n\t\tinfo[1].marked_time = 0;\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tmarked_boss[i] = value;\n\t\t}\n\n\t\tfor(int time = 1; time <= Q; time++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){\n\t\t\t\tS.push(Query(time,value));\n\t\t\t}else{\n\t\t\t\tinfo[value].isMarked = true;\n\t\t\t\tinfo[value].marked_time = time;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\n\t\twhile(!S.empty()){\n\t\t\tans += get_marked_boss(S.top().value,S.top().query_time);\n\t\t\tS.pop();\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        if(x!=0) return root(x)-n+1;\n        else{while(1){}}\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a),i##_end___=(b);i<i##_end___;i++)\n#define DFOR(i,a,b) for(int i=(a)-1,i##_end___=(b);i>=i##_end___;i--)\ntypedef long long LL;\ntypedef double DB;\nconst int V=1e5+5;\n\nint n,m;\nint Fa[V];\nint Mark[V];\n\nstruct Ask{\n\tchar op[4];\n\tint v;\n}Que[V];\n\nint dfs(int v,int tim){return Mark[v]<tim?v:Fa[v]=dfs(Fa[v],tim);}\n\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m)){\n\t\tif(!n&&!m)break;\n\t\t\n\t\tFOR(i,2,n+1)Mark[i]=1e9,scanf(\"%d\",&Fa[i]);\n\t\tFOR(i,1,m+1){\n\t\t\tscanf(\"%s%d\",Que[i].op,&Que[i].v);\n\t\t\tif(Que[i].op[0]=='M')Mark[Que[i].v]=min(Mark[Que[i].v],i);\n\t\t}\n\t\t\n\t\tLL ans=0;\n\t\t\n\t\tDFOR(i,m+1,1)if(Que[i].op[0]=='Q')ans+=dfs(Que[i].v,i);\n\t\t\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss,*height;\n\nstruct Info{\n\tvector<int> Children;\n};\n\nInfo*info;\n\n//new_boss_id??¨????????????????????????new_boss_id?????¨?§????????????????????????°???????????????new_boss?????????\nvoid update(int new_marked_boss_id){\n\n\tint current_boss_id = marked_boss[new_marked_boss_id],id;\n\tqueue<int> Q;\n\n\tfor(int i = 0; i < info[new_marked_boss_id].Children.size();i++){\n\t\tif(marked_boss[info[new_marked_boss_id].Children[i]] == current_boss_id){ //????????????????????????????????¨??????????????????????????????????????????????????????????????????\n\t\t\tmarked_boss[info[new_marked_boss_id].Children[i]] = new_marked_boss_id;\n\t\t\tQ.push(info[new_marked_boss_id].Children[i]);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\tid = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i < info[id].Children.size();i++){\n\t\t\tif(marked_boss[info[id].Children[i]] == current_boss_id){ //????????????????????????????????¨??????????????????????????????????????????????????????????????????\n\t\t\t\tmarked_boss[info[id].Children[i]] = new_marked_boss_id;\n\t\t\t\tQ.push(info[id].Children[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint Q,value;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\theight = new int[100001];\n\tinfo = (Info*)malloc(sizeof(Info)*(100001));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tmarked_boss[i] = 1;\n\t\t\theight[i] = 0;\n\t\t\tinfo[i].Children.clear();\n\t\t}\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tinfo[value].Children.push_back(i); //value?????????i???????????????\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < Q; i++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){ //?????¨???\n\t\t\t\tans += marked_boss[value];\n\t\t\t}else{ //???????????????\n\t\t\t\tupdate(value);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+2];\nint n;\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init();\n    par[0] = 1;\n    for(int i = 1 ; i < n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tunite(num,par[num]);\n\tsum += par[num]+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    bool mark[100001];\n    int tree[100001];\n    while (1) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        memset(mark, false, sizeof(mark));\n        mark[1] = true; \n        tree[1] = 0;\n        for (int i=2; i<=N; ++i) {\n            cin >> tree[i];\n        } \n\n        long long sum = 0;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            if (ope == 'Q') {\n                for (int j=v; j>=1; j=tree[j]) {\n                    if (mark[j] == true) {\n                        sum += j;\n                        break;\n                    }\n                }\n            } else if (ope == 'M') {\n                mark[v] = true;\n            }\n        }\n        cout << sum << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/STACK:102400000,102400000\")\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst int N=1e5+5;\nconst int M=1e5+5;\nconst int inf=0x3f3f3f3f;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n\nint n,m;\nint f[N];\nchar s[N][2];\nint p[N];\nint fa[N];\nvector<int> edge[N];\n\nvoid dfs(int u,int t) {\n    f[u]=t;\n   // printf(\"EE %d %d\\n\",u,t);\n    for(int i=0;i<edge[u].size();i++) {\n        int v=edge[u][i];\n        if(f[v]==v) dfs(v,v);\n        else dfs(v,t);\n    }\n}\nvoid init() {\n    for(int i=1;i<=n;i++ ) edge[i].clear();\n}\nint Find(int x) {\n    return f[x]=f[x]==x?x:Find(f[x]);\n}\nint main() {\n    while(scanf(\"%d%d\",&n,&m),n!=0 && m!=0) {\n        init();\n        fa[1]=1;\n        for(int i=2;i<=n;i++) scanf(\"%d\",fa+i),f[i]=1,edge[fa[i]].push_back(i);\n        for(int i=0;i<m;i++) {\n            scanf(\"%s%d\",s+i,p+i);\n            if(s[i][0]=='M') f[p[i]]=p[i];\n        }\n        dfs(1,1);\n        ll ans=0;\n        for(int i=m-1;i>=0;i--) {\n            if(s[i][0]=='Q') ans+=Find(p[i]);\n            else f[p[i]]=fa[p[i]];\n           // printf(\"WW %d %d\\n\",p[i],f[p[i]]);\n        }\n        printf(\"%I64d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) p[i]=i,marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\nbool marked[MAX_N+5];\n\nstack<P> s;\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n        marked[i] = false;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nvoid show_par() {\n    for(int i = 1; i <= N; i++) {\n        cout << i << \": \" << par[i] << \", \";\n    }\n    cout << endl;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par2[i] = p;\n        }\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                if(marked[t]) continue;\n                marked[t] = true;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            s.push(q);\n        }\n\n        // solve\n        for(int i = 1; i <= N; i++) {\n            if(!marked[i]) unite(par2[i], i);\n        }\n        long long int ans = 0;\n        // show_par();\n        while(!s.empty()) {\n            P q = s.top(); s.pop();\n            if(q.first == 'M') {\n                unite(par2[q.second], q.second);\n            } else {\n                ans += find(q.second);\n            }\n            // cout << v[i].first << \" \" << v[i].second << endl;\n            // show_par();\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> par, rank;\n\n    UnionFind(int n) {\n        rep(n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    int find(int x) {\n        return ((par[x] == x) ? x : par[x] = find(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n        return;\n    }\n\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    ll n,q,node;\n    char c;\n    cin >> n >> q;\n    while(n || q){\n        vector<ll> parent(n+1, 1);\n        ll ans = 0;\n        reppp(i, 2, n+1){\n            cin >> node;\n            parent[i] = node;\n        }\n\n        vector<Pll> query(q);\n        vector<bool> marked(n+1, false);\n        rep(q){\n            cin >> c >> query[i].second;\n            query[i].first = (c=='Q'?1:0);\n            if(c == 'M') marked[node] = true;\n        }\n        UnionFind uf = UnionFind(n+1);\n        reppp(i, 2, n+1){\n            if(marked[i]) continue;\n            uf.unite(parent[i], i);\n        }\n        for(int i=q-1;i>=0;--i){\n            if(query[i].first){\n                ans += uf.find(node);\n            }else{\n                uf.unite(parent[node], node);\n            }\n        }\n        cout << ans << endl;\n        cin >> n >> q;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\n\nint used[MAX_N];\nint mark[MAX_N];\nmap<int,vector<int> > child;\n\nvoid dfs(int start,int root){\n    //cout<<used[start]<<start<<endl;\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        //map<int,vector<int> > child;\n        //int used[MAX_N];\n        //int mark[MAX_N];\n        \n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n        \n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        int ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint n, q;\nint p[100005];\nvector<int> G[100005];\nchar c[100005]; int v[100005];\nbool mark[100005];\nUnionFind uf(100005);\n\nvoid dfs(int v)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!mark[G[v][i]]) uf.unite(G[v][i], v);\n\t\tdfs(G[v][i]);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> q;\n\t\tif(n == 0 && q == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> p[i];\n\t\t\tG[p[i]].push_back(i);\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c[i] >> v[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) mark[i] = false;\n\t\tmark[1] = true;\n\t\t\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'M') mark[v[i]] = true;\n\t\t}\n\t\tuf.init();\n\t\tdfs(1);\n\t\t\n\t\treverse(c, c+q);\n\t\treverse(v, v+q);\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'Q') ans += uf.root(v[i]);\n\t\t\telse if(v[i] != 1) uf.unite(v[i], p[v[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tvi T(n);\n\t\tvi m(n);\n\t\tvi mv(n);\n\t\tiota(ALL(mv), 0);\n\t\tm[0] = 1;\n\t\trep1(i, n - 1)cin >> T[i], T[i]--;\n\t\tvpii a(q);\n\t\tunionfind uf(n);\n\t\tll ans = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')m[v - 1] = 1;\n\t\t\ta[i] = { c,v };\n\t\t}\n\t\trrep(i, q) {\n\t\t\tif (a[i].first == 'M')m[a[i].second - 1] = 0;\n\t\t\telse {\n\t\t\t\tint v = a[i].second - 1;\n\t\t\t\twhile (!m[v = mv[uf.find(v)]]) {\n\t\t\t\t\tint u = uf.find(T[v]);\n\t\t\t\t\tuf.unite(v, T[v]), mv[uf.find(v)] = mv[u];\n\t\t\t\t}\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\t/*if(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tif(carry)trees.push_back(carry);\n\t\th.clear();\n\t\t//h.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\n/*\n\n6 3\n1\n1\n2\n3\n3\nQ 5\nM 3\nQ 5\n\n10 3\n1\n1\n2\n3\n5\n5\n8\n9\n4\nQ 1\nM 3\nQ 2\n0 0\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],pa[MAXN],n,m,used[MAXN];\nlong long ans;\nchar c;\npair<int,int> a[MAXN];\nint get_fa(int x){\n    if(fa[x]==0)\n        return x;\n    fa[x]=get_fa(fa[x]);\n    return fa[x];\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    while(n*m!=0){\n        for(int i=2;i<=n;i++)\n            SF(\"%d\",&pa[i]);\n        int x;\n        for(int i=1;i<=m;i++){\n            SF(\"\\n\");\n            SF(\"%c\",&c);\n            SF(\"%d\",&x);\n            if(c=='M'){\n                a[i].first=0;\n                a[i].second=x;\n                used[x]=1;\n            }\n            else{\n                a[i].first=1;\n                a[i].second=x;\n            }\n        }\n        for(int i=2;i<=n;i++)\n            if(used[i]==0)\n                fa[i]=get_fa(pa[i]);\n        for(int i=m;i>=1;i--){\n            if(a[i].first==0)\n                fa[i]=get_fa(pa[i]);\n            else\n                ans+=get_fa(i);\n        }\n        PF(\"%lld\\n\",ans);\n        SF(\"%d%d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint edge[200001];\nvector<int> G[200000];\nint par[200001];\nbool flag[200001];\nchar s[200001];\nint v[200001],fm[200001];\n\nvoid init(){\n\tfor(int i=0;i<=n;i++){\n\t\tpar[i]=i;\n\t\tG[i].clear();\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tmemset(fm,-1,sizeof(fm));\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tpar[x]=y;\n\t}\n\n}\n\nvoid unite_dfs(int v,int p){\n\tif(!flag[v])unite(v,p);\n\telse p=v;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tunite_dfs(G[v][i],p);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&edge[i]);\n\t\t\tG[edge[i]].push_back(i);\n\t\t}\n\t\tflag[1]=true;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tcin >> s[i] >> v[i];\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]=true;\n\t\t\t\tif(fm[v[i]]==-1)fm[v[i]]=i;\n\t\t\t}\n\t\t}\n\t\tunite_dfs(1,1);\n\n\t\tlong long res=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(s[i]=='Q'){\n\t\t\t\tres+=find(v[i]);\n\t\t\t}\n\t\t\tif(s[i]=='M' && fm[v[i]]==i){\n\t\t\t\tunite(v[i],edge[v[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\nvector<int> mark_parent;\nvector<int> marked;\n\nvoid walk_graph(int v, int mark_p, graph& g) {\n\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p, g);\n    }\n}\n\nint find_mark_parent(int v) {\n    if (marked[v]){\n        // cout << endl;\n        return v;\n    }\n    // cout << v << \"->\";\n    mark_parent[v] = find_mark_parent(mark_parent[v]);\n    return mark_parent[v];\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    mark_parent = vector<int>(N, 0);\n    marked = vector<int>(N, 0);\n\n    graph g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            ++marked[q.second];\n        }\n    }\n\n    walk_graph(0, -1, g);\n    \n    // cout << \"####walk_graph####\" << endl;\n\n    long long ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n        // cout << \"####\" << j << \" \" << queries[j].first << \" \" << queries[j].second << \"####\" << endl;\n\n        if (ch == 'Q') {\n            ret += find_mark_parent(v) + 1;\n        }\n\n        if (ch == 'M') {\n            --marked[v];\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        // cout << N << \" \" << Q << endl;\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <ctime>\n#include <assert.h>\n\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define eps 1e-8\n#define M_PI 3.141592653589793\n\ntypedef long long ll;\nconst ll mod=1000000007;\nconst int inf=0x7fffffff;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nusing namespace std;\nint f[100010],n,m;\nvoid init()\n{\n    for(int i=1;i<=n;i++) f[i]=i;\n}\n\nint Find(int x)\n{\n   if(x!=f[x]) return Find(f[x]);\n   else return x;\n}\n\nint main()\n{\n   while(scanf(\"%d%d\",&n,&m)&&n&&m){\n       init();\n       for(int i=2;i<=n;i++){\n          scanf(\"%d\",&f[i]);\n       }\n       ll ans=0;\n       for(int i=1;i<=m;i++){\n          char c;int a;\n          scanf(\"\\n%c%d\",&c,&a);\n          getchar();\n          if(c=='Q'){\n            ans+=Find(a);\n          }\n          else if(c=='M'){\n              f[a]=a;\n          }\n       }\n       printf(\"%lld\\n\",ans);\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct Timer {\n    clock_t p;\n    Timer(){ reset(); }\n    void reset(){ p = clock(); }\n    double get(){ return (double)(clock()-p)/CLOCKS_PER_SEC; }\n};\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<set<pair<int,int>>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        vector<int> hist;\n        int res = -1;\n        Timer t;\n        while(v != -1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(make_pair(-depth[v],-inf));\n            //dump(ms.size());\n            if(it != ms.end()){\n                res = it->second;\n                break;\n            } else {\n                v = goUp(v);\n            }\n        }\n        //dump(t.get());\n        assert(res != -1);\n        return res;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q'){\n                ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            } else {\n                marks.insert(mp(-d, qv[i]));\n            }\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        double Qt = 0, Mt = 0;\n        rep(i,q){\n            if(qt[i] == 'Q'){\n                Timer t;\n                ans += h.query(qv[i]) + 1;\n                Qt += t.get();\n            } else {\n                Timer t;\n                h.mark(qv[i]);\n                Mt += t.get();\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n            g[i+1].eb(i+1,par);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  AOJ 2170 Marked Ancestor\n//\n//  Created by TaoSama on 2015-03-16\n//  Copyright (c) 2015 TaoSama. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n#define CLR(x,y) memset(x, y, sizeof(x))\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint n, q, par[N];\n\nint find(int x) {\n\tif(par[x] == x) return x;\n\treturn find(par[x]);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\n\twhile(~scanf(\"%d%d\", &n, &q) && n && q) {\n\t\tpar[1] = 1;\n\t\tfor(int i = 2; i <= n; ++i) scanf(\"%d\", &par[i]);\n\n\t\tlong long ans = 0;\n\t\tfor(int i = 1; i <= q; ++i) {\n\t\t\tchar op[2]; int x;\n\t\t\tscanf(\"%s%d\", op, &x);\n\t\t\tif(op[0] == 'Q') ans += find(x);\n\t\t\telse par[x] = x;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint N, Q, t;\nlong long res;\nint parent[100010];\nbool mark[100010];\nstring op;\n\nint main()\n{\n    while(cin >> N >> Q && N)\n    {\n        res = 0;\n        fill_n(mark, 100010, false);\n        mark[1] = true;\n        for(int i = 2; i <= N; ++i)\n        {\n            cin >> t; parent[i] = t;\n        }\n        for(int i = 0; i < Q; ++i)\n        {\n            cin >> op >> t;\n            if(op == \"M\")\n                mark[t] = true;\n            if(op == \"Q\")\n            {\n                while(!mark[t]) t = parent[t];\n                res += t;\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\nvoid walk_graph(int v, int mark_p,\n        vector<int>& mark_parent, vector<int>& marked, graph& g) {\n\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p, mark_parent, marked, g);\n    }\n}\n\nint find_mark_parent(int v,\n        vector<int>& mark_parent, vector<int>& marked) {\n    if (marked[v]) return v;\n    return mark_parent[v] = find_mark_parent(mark_parent[v], mark_parent, marked);\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    vector<int> mark_parent(N, 0);\n    vector<int> marked(N, 0);\n\n    graph g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            marked[q.second] = 1;\n        }\n    }\n\n    walk_graph(0, -1, mark_parent, marked, g);\n\n    int ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n        if (ch == 'Q') {\n            ret += find_mark_parent(v, mark_parent, marked)+1;\n        }\n        if (ch == 'M') {\n            marked[v] = 0;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] =  find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y; // parent of x is y\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    long long int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') {\n                marked[index] = true;\n                s.insert(index);\n            }\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-INF;\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -INF;\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) {\n        buf.update((int)marked[pos],idx[pos]);\n    }\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) {\n        buf.update((int)marked[pos],-INF);\n    }\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* \n author:hdsdogge \n begin: \n end: \n cost: \n */\n#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<bitset>\n#include<cstdlib>\n#include<list>\n#include <sstream>\n#include<ctype.h>\nusing namespace std;\nconst int maxn=1000000+10;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst double PI = acos(-1.0);\nconst double eps = 1e-6;\nconst int INF = 1000000000;\nint T,n,m;\nint par[maxn];\nint vis[maxn];\nint main() {\n   // freopen(\"test\",\"r\",stdin);\n   // freopen(\"out\",\"w\",stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    while(cin>>n>>m&&(n+m)){\n        memset(vis,0, sizeof(vis));\n        par[1]=1;\n        vis[1]=1;\n        ll ans=0;\n        for(int i=2;i<=n;i++){\n            int x;\n            cin>>x;\n            par[i]=x;\n        }\n        for(int i=0;i<m;i++){\n            char c;\n            int x;\n            cin>>c>>x;\n            if(c=='Q'){\n                while(vis[x]==0){\n                    x=par[x];\n                }\n                ans+=x;\n            }\n            else if(c=='M'){\n               vis[x]=1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n} \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<char,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nvector<int> vs[100005];\nlli ps[100005];\nint ic[100005];\n\nstruct unifo{\n\tint un;\n\tlli uni[100005];\n\tvoid init(int n){\n\t\trep(i,n)uni[i]=i;\n\t\tun=n;\n\t}\n\tlli find(int p){\n\t\tif(uni[p]==p)return p;\n\t\telse return (uni[p]=find(uni[p]));\n\t}\n\tvoid mer(int p,int q){\n\t\tuni[find(p)]=find(q);\n\t}\n\tbool same(int p,int q){\n\t\treturn find(p)==find(q);\n\t}\n};\n\nunifo uni;\n\nvoid dfs(int no,int p){\n\tps[no]=p;\n\t//printf(\"%d %d\\n\",no,p);\n\tif(ic[no]==1)p=no;\n\telse uni.mer(no,p);\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i],p);\n\t}\n}\n\nint n,m;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tuni.init(n+3);\n\t\t\n\t\trep(i,n){\n\t\t\tvs[i].clear();\n\t\t\tps[i]=0;\n\t\t}\n\t\t\n\t\trep(i,n-1){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a); \n\t\t\tvs[a].push_back(i+2);\n\t\t}\n\t\t\n\t\tvector<mp> qs;\n\t\trep(i,m){\n\t\t\tint a;\n\t\t\tchar c;\n\t\t\tscanf(\"%s%d\",&c,&a); \n\t\t\tif(c=='M')ic[a]=1;\n\t\t\tqs.push_back(mp(c,a));\n\t\t}\n\t\t\n\t\tdfs(1,1);\n\t\t\n\t\tlli ans=0;\n\t\tirep(i,qs.size()){\n\t\t\tint a = qs[i].sec;\n\t\t\tif(qs[i].fir=='Q'){\n\t\t\t\tans += uni.find(ps[a]);\n\t\t\t\t//printf(\"%lld\\n\",uni.find(ps[a]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tuni.mer(uni.find(a),uni.find(ps[a]));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nconst int INF = (1<<26);\nconst int segN=(1<<20);\n\nstruct data{\n  P value;\n  data* ch[2];\n\n  void clear(){\n    for(int i=0;i<2;i++){\n      if(ch[i]->ch[0]!=NULL)ch[i]->clear();\n      free(ch[i]);\n    }\n  }\n  \n  void init(){\n    value=P(-INF,-1);\n    ch[0]=(data*)malloc(sizeof(data));\n    ch[1]=(data*)malloc(sizeof(data));\n    ch[0]->ch[0]=NULL;\n    ch[1]->ch[0]=NULL;\n  }\n  \n  void set(int a,int b,P x,int l,int r){\n    int m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    \n    if(b<=l || r<=a)return; \n    else if(a<=l && r<=b){\n      value=(x>value?x:value);\n    }else{\n      ch[0]->set(a,b,x,l,m);\n      ch[1]->set(a,b,x,m,r);\n    }\n  }\n   \n  void set(int a,int b,P x){\n    set(a,b,x,0,segN);\n  }\n  \n  P max(int i,int l,int r){\n    \n    int m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    if(i<l || r<=i)return P(-INF,-1);\n   \n    if(r-l==1){\n      return value;\n    }\n    \n    P res=value;\n    P lc=ch[0]->max(i,l,m);\n    res=(lc>res?lc:res);\n    P rc=ch[1]->max(i,m,r);\n    res=(rc>res?rc:res);\n    return res;\n  }\n \n  P max(int i){\n    return max(i,0,segN);\n  }\n};\n\n#define MAX 100005\nint n,m,a;\nchar str[2];\nvector<int> vec;\nvector<int> G[MAX];\nint l[MAX],r[MAX],depth[MAX];\ndata T;\n\nvoid init(){\n  T.init();\n  vec.clear();\n  for(int i=0;i<n;i++){\n    depth[i]=0;\n    l[i]=INF;\n    r[i]=0;\n    G[i].clear();\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    init();\n    for(int i=1;i<n;i++){\n      scanf(\"%d\",&a);\n      a--;\n      G[a].push_back(i);\n    }\n\n    stack<int> st;\n    st.push(0);\n    while(!st.empty()){\n      int pos=st.top();st.pop();\n      l[pos]=min(l[pos],(int)vec.size());\n      r[pos]=max(r[pos],(int)vec.size());\n      vec.push_back(pos);\n      if(G[pos].empty())continue;\n      st.push(pos);\n      st.push(G[pos].back());\n      depth[G[pos].back()]=depth[pos]+1;\n      G[pos].pop_back();\n    }\n\n    /*\n    for(int i=0;i<(int)vec.size();i++)\n      cout<<vec[i]<<' ';cout<<endl;\n\n    for(int i=0;i<n;i++){\n      cout<<i<<' '<<l[i]<<' '<<r[i]<<' '<<depth[i]<<endl;\n    }\n    */\n    T.set(l[0],r[0]+1,P(0,0));\n    \n    long long sum=0;\n    for(int i=0;i<m;i++){\n      scanf(\"%s %d\",str,&a);\n      a--;\n      if(str[0]=='Q'){\n        sum+=(T.max(l[a]).second+1LL);\n      }else{\n        T.set(l[a],r[a]+1,P(depth[a],a));\n      }\n    }\n    cout<<sum<<endl;\n    T.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct UF {\n    int *par;\n    UF(int n) {\n        par=new int[n];\n        for(int i=0;i<n;i++) {\n            par[i]=i;\n        }\n    }\n    int find(int x) {\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void unite(int x,int y) {\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        par[x]=y;\n    }\n    bool same(int x,int y) {\n        return find(x)==find(y);\n    }\n};\nint marked[100000];\nchar op[100000][2];\nint v[100000];\nint par[100000];\nint main() {\n    int N,Q;\n    while(scanf(\"%d %d\",&N,&Q),N) {\n        par[0]=-1;\n        for(int i=1;i<N;i++) {\n            scanf(\"%d\",&par[i]);par[i]--;\n        }\n        fill(marked,marked+100000,0);\n        marked[0]=1;\n        for(int i=0;i<Q;i++) {\n            scanf(\"%s %d\",op[i],&v[i]);v[i]--;\n            if(op[i][0]=='M') marked[v[i]]++;\n        }\n        UF u(N);\n        for(int i=0;i<N;i++) {\n            if(marked[i]>0) u.unite(i,par[i]);\n        }\n        long long ans=0;\n        for(int i=Q-1;i>=0;i--) {\n            if(op[i][0]=='M') {\n                if(marked[v[i]]>0) {\n                    marked[v[i]]--;\n                    if(marked[v[i]]==0) u.unite(v[i],par[v[i]]);\n                }\n            }else {\n                ans+=u.find(v[i])+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <deque>\n#include <climits>\nusing namespace std;\n\n#define _gp(l) const auto gcu{getchar##l}; const auto pcu{putchar##l}\n#ifdef __linux\n_gp(_unlocked);\n#else\n_gp();\n#endif\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;for(char c;c=gcu(),c!=' '&&c!='\\n';)s+=c;return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;if((c=gcu())=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n\t_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n\t_HT _OUT(H &&h, T... t){out(h);out(t...);}\n\ttemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n\tstruct range{\n\t\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\t\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\nstruct T {\n\tstruct N {\n\t\tint p, m;\n\t};\n\tvector<N> t;\n\tT (int n) {\n\t\tt.resize(n);\n\t\tt[0] = {0, 0};\n\t\tfor (int i: range(1, n))\n\t\t\tt[i] = {(int) in - 1, INT_MAX};\n\t}\n\tint Q (int v, int i) {\n\t\tif (t[v].m < i)\n\t\t\treturn v;\n\t\telse\n\t\t\treturn t[v].p = Q(t[v].p, i);\n\t}\n\tvoid M (int v, int i) {\n\t\tif (t[v].m == INT_MAX)\n\t\t\tt[v].m = i;\n\t}\n};\n\n\nstruct Q {\n\tint v, i;\n};\n\nint main() {\n\tfor (int N, M; N = in, M = in;) {\n\t\tT t(N);\n\t\tdeque<Q> q;\n\t\tfor(int i: range(1, M + 1)) {\n\t\t\tchar c {in};\n\t\t\tint v {in};\n\t\t\tif (c == 'Q')\n\t\t\t\tq.push_front({v - 1, i});\n\t\t\telse\n\t\t\t\tt.M(v - 1, i);\n\t\t}\n\t\tlong r {};\n\t\tfor (auto i: q)\n\t\t\tr += t.Q(i.v, i.i) + 1;\n\t\toutl(r);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_NODE = 100001;\n\nstruct Query {\n\tchar q;\n\tint v;\n};\n\nint parent(int uft[],bool mark[], int c) {\n\tif (mark[c] || uft[c] == c)return c;\n\treturn uft[c] = parent(uft, mark ,uft[c]);\n}\n\nint main() {\n\twhile (true) {\n\t\tint N, Q;\n\t\tint ans = 0;\n\t\tint uft[MAX_NODE] = { 0 };\n\t\tbool mark[MAX_NODE] = { 0 };\n\t\tQuery query[MAX_NODE];\n\n\t\tuft[1] = 1;\n\t\tmark[1] = true;\n\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tcin >> uft[i + 1];\n\t\t}\n\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tcin >> query[i].q >> query[i].v;\n\t\t\tif (query[i].q == 'M') {\n\t\t\t\tmark[query[i].v] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tif (query[i].q == 'M') {\n\t\t\t\tmark[query[i].v] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += parent(uft, mark, query[i].v);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n\nint to[123456];\nchar o[123456];\nint v[123456];\n\nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n\n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (y < x) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void sep(int x){\n    data[x] = -1;\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    memset(to,0,sizeof(to));\n    memset(o,0,sizeof(o));\n    memset(v,0,sizeof(v));\n    unionfind uf(n+10);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+2] = a;\n    }\n    for(int i = n;i > 1;--i){\n    \tuf.unionset(to[i],i);\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      if(o[i]=='M'){\n        uf.sep(v[i]);\n      }    \n    }\n    REP(i,n){\n    \tcout << uf.root(i+1)<<endl;\n    }\n    int sum = 0;\n    \n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i]);\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][18],ff[100000],ss[100000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <limits>\n \ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n \n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n \ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n \ntemplate <typename Weight>\nstruct edge {\n  using value_type = Weight;\n  size_t src, dst;\n  value_type cost;\n \n  edge(size_t src, size_t dst, value_type cost = 1):\n    src(src), dst(dst), cost(cost)\n  {}\n \n  bool operator <(edge<value_type> const& rhs) const {\n    if (cost != rhs.cost) return cost < rhs.cost;\n    if (src != rhs.src) return src < rhs.src;\n    return dst < rhs.dst;\n  }\n};\n \ntemplate <typename Weight>\nstruct graph: public std::vector<std::vector<edge<Weight>>> {\n  using value_type = Weight;\n  graph(size_t n): std::vector<std::vector<edge<value_type>>>(n) {}\n \n  void connect_with(size_t src, size_t dst, value_type cost = 1) {\n    (*this)[src].emplace_back(src, dst, cost);\n    (*this)[dst].emplace_back(dst, src, cost);\n  }\n};\n \ntemplate <typename Tp>\nstd::array<std::vector<size_t>, 2> euler_tour(graph<Tp> const& g, size_t s = 0) {\n  std::array<std::vector<size_t>, 2> res;\n  res[0] = res[1] = std::vector<size_t>(g.size());\n  size_t j = 0;\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    res[0][i] = j++;\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      dfs(e.dst, i);\n    }\n    res[1][i] = j++;\n  })(s, -1);\n  return res;\n}\n \ntemplate <typename Tp>\nstd::vector<size_t> depth(graph<Tp> const& g, size_t s = 0) {\n  std::vector<size_t> res(g.size());\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      res[e.dst] = res[e.src] + 1;\n      dfs(e.dst, e.src);\n    }\n  })(s, -1);\n  return res;\n}\n \ntemplate <\n  typename Monoid,\n  typename Container = std::vector<typename Monoid::first_type>,\n  typename SubContainer = std::vector<typename Monoid::second_type>\n>\nclass segment_tree {\npublic:\n  using first_type = typename Monoid::first_type;\n  using second_type = typename Monoid::second_type;\n  using value_type = first_type;\n  using binary_operation = typename Monoid::binary_operation;\n  using external_binary_operation = typename Monoid::external_binary_operation;\n  using merge_operation = typename Monoid::merge_operation;\n  using container = Container;\n  using sub_container = SubContainer;\n \nprivate:\n  size_t M_base_size;\n  binary_operation M_op1;\n  external_binary_operation M_op2;\n  merge_operation M_op3;\n  container M_c;\n  sub_container M_d;  // deferred\n \n  void M_build(size_t i) {\n    while (i > 1) {\n      i >>= 1;\n      M_c[i] = M_op2(M_op1(M_c[i<<1|0], M_c[i<<1|1]), M_d[i]);\n    }\n  }\n \n  void M_resolve(size_t i) {\n    size_t h = (sizeof(size_t) * CHAR_BIT) - __builtin_clzll(M_base_size*2);\n    for (size_t s = h; s > 0; --s) {\n      size_t p = i >> s;\n      if (M_d[p] != M_op3.identity) {\n        M_apply(p<<1|0, M_d[p]);\n        M_apply(p<<1|1, M_d[p]);\n        M_d[p] = M_op3.identity;\n      }\n    }\n  }\n \n  void M_apply(size_t i, second_type const& x) {\n    M_c[i] = M_op2(M_c[i], x);\n    if (i < M_base_size) M_d[i] = M_op3(M_d[i], x);\n  }\n \npublic:\n  segment_tree() = default;\n  segment_tree(segment_tree const&) = default;\n  segment_tree(segment_tree&&) = default;\n \n  segment_tree(size_t n, first_type const& x = binary_operation().identity):\n    M_base_size(n),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(n+n, x), M_d(n, M_op3.identity)\n  {\n    for (size_t i = n; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n \n  template <typename InputIt>\n  segment_tree(InputIt first, InputIt last):\n    M_base_size(std::distance(first, last)),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(M_base_size*2), M_d(M_base_size, M_op3.identity)\n  {\n    for (size_t i = M_base_size; first != last; ++i)\n      M_c[i] = *first++;\n    for (size_t i = M_base_size; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n \n  segment_tree& operator =(segment_tree const&) = default;\n  segment_tree& operator =(segment_tree&&) = default;\n \n  void modify(size_t l, size_t r, second_type const& x) {\n    l += M_base_size;\n    r += M_base_size;\n    size_t l0 = l;\n    size_t r0 = r;\n    while (l < r) {\n      if (l & 1) M_apply(l++, x);\n      if (r & 1) M_apply(--r, x);\n      l >>= 1;\n      r >>= 1;\n    }\n    M_build(l0);\n    M_build(r0-1);\n  }\n \n  first_type accumulate(size_t l, size_t r) {\n    first_type resl = M_op1.identity;\n    first_type resr = resl;\n    l += M_base_size;\n    r += M_base_size;\n    M_resolve(l);\n    M_resolve(r-1);\n    while (l < r) {\n      if (l & 1) resl = M_op1(resl, M_c[l++]);\n      if (r & 1) resr = M_op1(M_c[--r], resr);\n      l >>= 1;\n      r >>= 1;\n    }\n    return M_op1(resl, resr);\n  }\n \n  first_type operator [](size_t i) {\n    i += M_base_size;\n    M_resolve(i);\n    return M_c[i];\n  }\n};\n \nnamespace std {\n  template <typename T1, typename T2>\n  struct numeric_limits<std::pair<T1, T2>> {\n    static std::pair<T1, T2> constexpr min() {\n      return std::make_pair(std::numeric_limits<T1>::min(), std::numeric_limits<T2>::min());\n    }\n  };\n}\n \ntemplate <typename Tp>\nstruct range_max_range_max {\n  using first_type = Tp;\n  using second_type = Tp;\n  struct binary_operation {\n    first_type identity = std::numeric_limits<Tp>::min();\n    first_type operator ()(first_type const& x, first_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct external_binary_operation {\n    first_type operator ()(first_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct merge_operation {\n    second_type identity = std::numeric_limits<Tp>::min();\n    second_type operator ()(second_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n};\n \nint testcase_ends() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n  if (n == 0 && q == 0) return 1;\n \n  graph<int> g(n);\n  for (size_t i = 1; i < n; ++i) {\n    size_t p;\n    scanf(\"%zu\", &p);\n    --p;\n    g.connect_with(i, p);\n  }\n \n  auto d = depth(g);\n  auto et = euler_tour(g);\n\n  // {depth, nma}\n  segment_tree<range_max_range_max<std::pair<size_t, size_t>>> st(n+n, std::make_pair(0, 0));\n \n  size_t res = 0;\n  for (size_t i = 0; i < q; ++i) {\n    char t;\n    size_t v;\n    scanf(\" %c %zu\", &t, &v);\n    --v;\n \n    if (t == 'Q') {\n      res += st[et[0][v]].second+1;\n    } else if (t == 'M') {\n      st.modify(et[0][v], et[1][v]+1, std::make_pair(d[v], v));\n    }\n  }\n \n  printf(\"%zu\\n\", res);\n  return 0;\n}\n \nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int MAX_N=100001;\nvector<int>edge[MAX_N];\nvector<int>id[MAX_N];\nint vi[MAX_N*2];\nint DFS(int n,int d)\n{\n\tvi[d]=n;\n\tid[n].push_back(d);\n\tfor(int i=0;i<edge[n].size();++i)\n\t{\n\t\td=DFS(edge[n][i],d+1)+1;\n\t\tvi[d]=n;\n\t\tid[n].push_back(d);\n\t}\n\treturn d;\n}\n\n\nint main()\n{\n\tint N,Q,x,i,t;\n\tchar c;\n\tlong long res;\n\ttypedef map<int,int>M;\n\tM m;\n\tM::iterator ite;\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tm.clear();\n\t\tfor(i=1;i<=N;++i)edge[i].clear();\n\t\tfor(i=2;i<=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tedge[x].push_back(i);\n\t\t}\n\t\tDFS(1,1);\n\t\tm[1]=1;\n\t\tm[N*2]=-1;\n\t\tres=0;\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c-'Q')\n\t\t\t{\n\t\t\t\tite=m.lower_bound(x);\n\t\t\t\tif(ite->second==x)continue;\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tfor(i=0;i<id[x].size();++i)\n\t\t\t\t{\n\t\t\t\t\tm[id[x][i]]=x;\n\t\t\t\t}\n\t\t\t\tm[id[x].back()+1]=t;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tite=m.lower_bound(id[x][0]-1);\n\t\t\t\tres+=(--ite)->second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\t// if (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t}\n\t}\n\tint size(int x) { return -v[find(x)]; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\nint par[100001], a[100001];\nchar c[100000]; int v[100000];\n\nint main() {\n\tfor (;;) {\n\t\tint N, Q;\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)\n\t\t\tbreak;\n\t\tfor (int _v = 2; _v <= N; _v++)\n\t\t\tscanf(\"%d\", &par[_v]);\n\t\tfill(a, a + 100001, 0);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tchar s[2]; int _v;\n\t\t\tscanf(\"%s%d\", s, &_v);\n\t\t\tc[i] = s[0];\n\t\t\tv[i] = _v;\n\t\t\tif (s[0] == 'M')\n\t\t\t\ta[_v]++;\n\t\t}\n\t\tUnionFind uf(N + 1);\n\t\tfor (int _v = 2; _v <= N; _v++)\n\t\t\tif (a[_v] == 0)\n\t\t\t\tuf.unite(par[_v], _v);\n\t\tlong long ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\tint _v = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\tif (--a[_v] == 0)\n\t\t\t\t\tuf.unite(par[_v], _v);\n\t\t\t}\n\t\t\telse if (c[i] == 'Q')\n\t\t\t\tans += uf.find(_v);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt n,q;\nlnt queri[100000][2];\nbool marked[100000];\nlnt par[100000];\nvoid init(void)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t}\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\t\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tx=find(x);\n\ty=find(y);\n\tpar[x]=y;\n\treturn;\n}\n\nchar str[10];\nlnt anc[100000];\nlnt m;\n\nint main()\n{while(1){\n\tlnt ans=0;\n\tscanf(\"%lld%lld\",&n,&q);\n\tinit();\n\tif(!n&&!q) return 0;\n\tmemset(marked,0,sizeof(marked));\n\tfor(lnt i=1;i<n;i++){\n\t\tscanf(\"%lld\",&anc[i]);\n\t\tanc[i]--;\n\t}\n\tmarked[0]=1;\n\tfor(lnt i=0;i<q;i++){\n\t\tscanf(\"%s%lld\",str,&queri[i][1]);\n\t\tqueri[i][1]--;\n\t\tif(*str=='M'){\n\t\t\tqueri[i][0]=1;\n\t\t\tif(!marked[queri[i][1]]) queri[i][0]=2;\n\t\t\tmarked[queri[i][1]]=1;\n\t\t}\n\t\telse queri[i][0]=0;\n\t}\n\tfor(lnt i=0;i<n;i++){\n\t\tm=i;\n\t\twhile(!marked[m]&&!same(m,anc[m])){\n\t\t\tunite(m,anc[m]);\n\t\t\tm=anc[m];\n\t\t}\n\t}\n\tfor(lnt i=q-1;i>=0;i--){\n\t\tif(queri[i][0]){\n\t\t\tif(queri[i][0]==2) unite(queri[i][1],anc[queri[i][1]]);\n\t\t}\n\t\telse{\n\t\t\tm=queri[i][1];\n\t\t\tans+=(find(m)+1);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n//\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2*k+1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nvoid dfs(const int now, vector<pair<int, int>>&ps,vector<int>&ids,int&id,const vector<vector<int>>&edges) {\n\tids[now] = id;\n\tid++;\n\tps[now].first = id;\n\tfor (auto e : edges[now]) {\n\t\tdfs(e, ps, ids, id, edges);\n\t}\n\tps[now].second = id - 1;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tedges[a - 1].push_back(i + 1);\n\t\t}\n\t\tvector<pair<int, int>>ps(N);\n\t\tvector<int>ids(N);\n\t\tint id = 0;\n\t\tdfs(0, ps, ids, id, edges);\n\t\tlong long int sum = 0;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'Q') {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tint ans = get(a-1, a-1);\n\t\t\t\tsum += ans+1;\n\t\t\t\t//cout << ans+1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tupdate(ps[a - 1].first, ps[a - 1].second,a-1);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100005;\ntypedef pair<char, int> P;\n\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n    for(int i = 1; i <= n; i++){\n      par[i] = i;\n      rank[i] = mark[i] = 0;\n    }\n  }\n  \n  int find(int x){\n    if(mark[x] > 0) return x;\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<P> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    V.push_back(P(c,in));\n  }\n}\n\nvoid solve(){\n  long long ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    if(V[i].first == 'M') T.mark[V[i].second]--;\n    else ans += T.find(V[i].second);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <stack>\n#include <map>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nconst int maxn = 1e5+100;\nconst int INF = 0x3f3f3f3f;\n#define pr(x)      // cout << #x << \" = \" << x << \" \";\n#define prln(x)    // cout << #x << \" = \" << x <<endl;\n#define ll long long\nint head[maxn], nxt[maxn], to[maxn], dfsn, cnt, id[maxn], l[maxn], r[maxn], p[maxn], _n, sum[maxn<<2], dep[maxn];\nvoid addedge(int u, int v) {\n\tnxt[cnt] = head[u];\n\thead[u] = cnt;\n\tto[cnt++] = v;\n}\nvoid init(int n) {\n\tcnt = dfsn = 0;\n\t_n = 1;\n\twhile(_n < n) _n = _n*2;\n\tint _nn = _n*2;\n\tfor(int i = 0; i <= _nn; ++i) sum[i] = -1;\n\tfor(int i = 0; i <= n;++i) {\n\t\thead[i] =-1;\n\t\tdep[i] = 0;\n\t}\n}\n\nvoid dfstree(int fa,int u) {\n\tid[u] = ++dfsn;\n\tdep[u] = dep[fa]+1;\n\tfor(int i = head[u]; ~i; i = nxt[i]){\n\t\tdfstree(u,to[i]);\n\t}\n\tl[u] = id[u]; r[u] = dfsn;\n\tpr(fa);pr(u);pr(dep[fa]);prln(dep[u]);\n}\ninline void getans(int& ans, const int& v2){\n\tif(ans == -1 || dep[ans] < dep[v2]) ans = v2;\n}\nvoid pushdown(int rt) {\n\tif(sum[rt] != -1) {\n\t\tgetans(sum[rt<<1], sum[rt]);\n\t\tgetans(sum[rt<<1|1],sum[rt]);\n\t}\n}\nvoid update(int rt, int l, int r, int ql, int qr, int v) {\n\tif(ql <= l && r <= qr) {\n\t\tgetans(sum[rt], v);\n\t\tpr(sum[rt]);pr(dep[sum[rt]]);pr(v);prln(dep[v]);\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tint m = l + r >> 1;\n\tif(m >= ql) update(rt<<1, l, m, ql, qr, v);\n\tif(m < qr) update(rt<<1|1, m+1, r, ql, qr, v);\n}\nint query(int rt) {\n\trt += _n-1;\n\tint ans, depth = -1;\n\twhile(rt>=1) {\n\t\tif(sum[rt] != -1) {\n\t\t\tif(dep[sum[rt]] > depth) {\n\t\t\t\tdepth = dep[sum[rt]];\n\t\t\t\tans = sum[rt];\n\t\t\t}\n\t\t}\n\t\trt = rt>>1;\n\t}\n\treturn ans;\n}\nint main(){\n#ifdef LOCAL\n    freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\",\"r\",stdin);\n  //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\out.txt\",\"w\",stdout);\n #endif\n    int n, m, u, x, test= 0;\n    char op[10];\n    while(cin >> n >> m && (n||m)) {\n    \tll ans = 0;\n    \tinit(n);\n    \tfor(int i = 2; i <= n; ++i) {\n    \t\tscanf(\"%d\", &u);\n    \t\taddedge(u,i);\n    \t}\n    \t//prln(test++);\n    \tdep[0] = 0;\n    \tdfstree(0,1);\n    \tpr(id[1]);prln(dfsn);\n    \tupdate(1, 1, _n, l[1], r[1], 1);\n    \tprln(query(id[1]));\n    \t//prln(test++);\n    \tfor(int i = 1; i <= n; ++i) {\n    \t\tpr(i);pr(dep[i]);prln(id[i]);\n    \t}\n    \tfor(int i = 0; i < m; ++i) {\n    \t\tscanf(\"%s%d\", op, &x);\n    \t\tif(op[0] == 'M') {\n    \t\t\tpr(x);pr(id[x]);prln(r[x]);\n    \t\t\t//sum[id[x]+_n-1] = x;\n    \t\t\tupdate(1, 1, _n, id[x], r[x], x);\n    \t\t\tprln(test++);\n    \t\t} else {\n    \t\t\tans += query(id[x]);\n    \t\t\tpr(x);pr(id[x]);prln(query(id[x]));\n    \t\t\tprln(ans);\n    \t\t\t//prln(test++);\n    \t\t}\n    \t}\n    \tprln(test++);\n    \tprintf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nchar ch[MAX_Q+1];\nint num[MAX_Q+1];\nint N, Q;\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(int i=1; i<=N; i++) scanf(\"%d\", &par[i]);\n        getchar();\n        for(int i=1; i<=Q; i++) {scanf(\"%c \", &ch[i]); scanf(\"%d\", &num[i]); getchar();}\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n            if(ch[i]=='M'){\n                vis[num[i]]=1;\n            }\n            else if(ch[i]=='Q'){\n                int cur=num[i];\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100000][2];\nchar q1[100000];\nint q2[100000];\nvector < vector <int> > vec;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); it++){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n,q;\nint tree[100050];\n\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&q)==2)\n    {\n        if(n==0&&q==0)\n            break;\n        tree[1]=1;\n        for(int i=2;i<=n;i++)\n            scanf(\"%d\",&tree[i]);\n        getchar();\n        long long ans=0;\n        for(int i=1;i<=q;i++)\n        {\n            int temp;\n            char s[100];\n            gets(s);\n            sscanf(&s[2],\"%d\",&temp);\n            if(s[0]=='M')\n                tree[temp]=temp;\n            else if(s[0]=='Q')\n                ans+=Find(temp);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 10e5+8;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  for (int i = 1; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (x == 1 || marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    for (int i = 2; i <= N; i++) {\n      cin >> par[i];\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      s.push(make_pair((c == 'M'), node));\n      if (c == 'M') {\n        marked[node] = true;\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(p.second);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000], R[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)K[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint D = i;\n\t\t\tfor (int j = 0; j < 50; j++) D = a[i];\n\t\t\tR[i] = D;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M' && K[i] != 1)UF.unite(a[K[i]], K[i]);\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\tbool flag = true;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\tsum += D; flag = false; break;\n\t\t\t\t\t}\n\t\t\t\t\tD = a[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n\nint const M = 1000100;\n\nint N,Q;\nint par[M];\nvector<int> ch[M];\nchar q[M];\nint v[M];\nbool use[M];\nbool flg[M];\nint g[M];\nbool marked[M];\nint top[M]; // グループ→グループの根\n\n// markを外すときにunionしていく。\n// その際、グループ→グループの根の表を更新する\n\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nvoid rec(int v, UnionFind& uf){\n    for(int c : ch[v]){\n        if(marked[c]){\n            g[c] = c;\n        } else {\n            g[c] = g[v];\n            uf.unionSet(c,v);\n        }\n        rec(c, uf);\n    }\n}\n\nint solve(){\n    rep(i,N+1) flg[i] = false;\n    rep(i,Q)if(q[i]=='M'){\n        if(flg[v[i]]) use[i] = false;\n        else {\n            use[i] = true;\n            flg[v[i]] = true;\n        }\n    }\n    marked[1] = true;\n    per(i,Q)if(use[i]){\n        marked[v[i]] = true;\n    }\n\n    UnionFind uf(N+1);\n    par[1] = 1;\n    g[1] = 1;\n    rec(1, uf);\n\n    rep(i,N+1)if(i){\n        top[uf.root(i)] = g[i];\n    }\n\n    int ans = 0;\n    per(i,Q)if(use[i] || q[i]=='Q'){\n        if(q[i]=='M'){\n            top[uf.root(v[i])] = top[uf.root(par[v[i]])];\n            uf.unionSet(v[i], par[v[i]]);\n        } else {\n            ans += top[uf.root(v[i])];\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>Q && N){\n        par[0] = 0;\n        rep(i,N-1){\n            int v; cin>>v;\n            par[i+2] = v;\n            ch[v].push_back(i+2);\n        }\n        rep(i,Q){\n            cin >> q[i] >> v[i];\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <set>\nusing namespace  std;\nconst int maxn = 1e5 + 5;\ntypedef long long ll;\n#define mid (l + r) / 2\n#define lc (rt << 1)\n#define rc (rt << 1 | 1)\n\nvector<int> mp[maxn];\nint f[maxn];//f[1] = 0\nint in[maxn],out[maxn];\nint te = 0;\nstruct tr{\n    struct node{\n        int v,set;\n    }seg[maxn << 2];//就是不知道怎?pushup\n    void init(int l,int r,int rt)\n    {\n        if(l == r) {seg[rt].v = 1;seg[rt].set = 0;return;}\n        init(l, mid, lc);\n        init(mid + 1, r, rc);\n        seg[rt].v = 1;seg[rt].set = 0;//反正?点??。。。?不重要?？？？\n    }\n    int ql,qr;\n    int query(int pos,int l,int r,int rt)//?点??\n    {\n        if(l == r) {return seg[rt].v;}\n        if(pos <= mid) return query(pos, l, mid, lc);\n        else return query(pos, mid + 1, r, rc);\n    }\n    void pushdown(int l,int r,int rt)\n    {\n        if(seg[rt].set)\n        {\n            seg[lc].set = seg[rt].set;\n            seg[rc].set = seg[rt].set;\n            seg[lc].v = seg[rc].v = seg[rt].set;\n            seg[rt].set = 0;\n        }\n    }\n    void update(int l,int r,int rt,int val)//区?修改//当?点是叶子的?候，他不??修改rt的v，\n    {\n        if(ql > qr) return;\n        if(ql <= l && r <= qr){\n            seg[rt].set = seg[rt].v = val;\n            return;\n        }\n        pushdown(l,r,rt);\n        if(ql <= mid) update(l, mid, lc, val);\n        if(mid < qr) update(mid + 1, r, rc, val);\n        seg[rt].v = seg[lc].v;\n        //no pushup?\n    }\n}tree;\nvoid init(int n)\n{\n    for (int i = 1; i <= n; i ++) {\n        mp[i].clear();\n    }\n    memset(in, 0, sizeof(int) * (n + 1));\n    memset(out, 0, sizeof(int) * (n + 1));\n}\nvoid dfs(int u)\n{\n    in[u] = ++te;\n    for (int i = 0; i < mp[u].size(); i ++) {\n            dfs(mp[u][i]);\n    }\n    out[u] = te;\n}\nint main()\n{\n    int n,q;\n    while (scanf(\"%d%d\",&n,&q) != EOF) {\n        if(n == 0 && q == 0) break;\n        init(n);\n        int tmp;\n        for (int i = 2; i <= n; i ++) {\n            scanf(\"%d\",&tmp);\n            mp[tmp].push_back(i);\n            f[i] = tmp;\n        }\n        getchar();\n        dfs(1);\n        tree.init(1, n, 1);\n        tree.seg[1].v = 0;//make query(1) = 0\n\n        char op;\n        int v;\n        ll sum = 0;\n        for (int i = 0; i < q; i ++) {\n            scanf(\"%c%d%*c\",&op,&v);\n            if(op == 'M')\n            {\n                tree.ql = in[v] + 1;\n                tree.qr = out[v];\n                tree.update(1, maxn, 1, v);\n            }else{\n                sum += tree.query(in[v],1,maxn,1);\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100000+1109\n\nusing namespace std;\n\nchar ch[30];\nlong long n,m;\nlong long fa[MAXN];\nlong long a[MAXN],Q[MAXN];\nbool Is[MAXN];\nlong long Ans=0;\nlong long Mark[MAXN];\n\nlong long find(long long x)\n{\n\tif(fa[x]==x) return x;\n\tif(Is[x]==true) return x;\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid read();\nvoid work();\nvoid print();\n\nint main()\n{\n\tbool flag=false;\n\twhile(~scanf(\"%lld%lld\",&n,&m))\n\t{\n\t\tmemset(Is,0,sizeof(Is));\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(Q,0,sizeof(Q));\n\t\tif(n==0&&m==0) return 0;\n\t\tif(flag) printf(\"\\n\");\n\t\tflag=true;\n\t\tAns=0;\n\t\tread();\n\t\twork();\n\t\tprint();\n\t}\n\treturn 0;\n}\n\nvoid read()\n{\n\t\n\tif(n==0&&m==0) exit(0);\n\tfa[1]=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tscanf(\"%lld\",&fa[i]);\n\tIs[1]=true;\n\tfor(long long i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%lld\",ch,&Q[i]);\n\t\tif(ch[0]=='Q') a[i]=1;\n\t\telse\n\t\t{\n\t\t\ta[i]=2,Is[Q[i]]=true;\n\t\t\tif(Mark[Q[i]]) continue;\n\t\t\tMark[Q[i]]=i;\n\t\t}\n\t}\n}\nvoid work()\n{\n\tfor(long long i=m;i;i--)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tif(Q[i]==1) continue;\n\t\t\tif(Is[Q[i]])\n\t\t\t\tAns+=find(fa[Q[i]]);\n\t\t\telse Ans+=find(Q[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Mark[Q[i]]!=i) continue;\n\t\t\tIs[Q[i]]=false;\n\t\t}\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n        \n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\t//nma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tbreak;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define int_ int64_t\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=100010;\nint n,q,v;\nchar buf[4];\nvector<int> g[N];\nint p[N],dsu[N];\nbool marked[N];\n\nint fi(int x) {\n    return dsu[x]==x?x:(dsu[x]=fi(dsu[x]));\n}\n\nvoid dfs(int x,int ma) {\n    if (marked[x]) {\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],x);\n        }\n    } else {\n        dsu[x]=ma;\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],ma);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&q);\n        if (n==0&&q==0) break;\n        memset(p,0,sizeof(p));\n        memset(marked,0,sizeof(marked));\n        for (int i=1;i<=n;i++) {\n            dsu[i]=i;\n            g[i].clear();\n        }\n        for (int i=2;i<=n;i++) {\n            scanf(\"%d\",&v);\n            p[i]=v;\n            g[v].pb(i);\n        }\n        vector<PII> op;\n        for (int i=1;i<=q;i++) {\n            scanf(\"%s%d\",buf,&v);\n            if (buf[0]=='M') {\n                if (!marked[v]) {\n                    marked[v]=1;\n                    op.pb(mp(0,v));\n                }\n            } else {\n                op.pb(mp(1,v));\n            }\n        }\n        marked[1]=1;\n        dfs(1,1);\n        ll ans=0;\n        for (int i=op.size()-1;i>=0;i--) {\n            if (op[i].first) {\n                ans+=fi(op[i].second);\n            } else {\n                int r=fi(p[op[i].second]);\n                dsu[op[i].second]=r;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nAOJ 2170 Marked Ancestor\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\nstruct OPER{\n    char s[2];\n    int p;\n    void input(){\n        scanf(\"%s%d\", s, &p);\n    };\n}op[MAXN];\n\nint uset[MAXN];\nint rank[MAXN];\n\nclass UnionSet{\npublic:\n    void Init(int n){\n        for(int i=1; i<=n; ++i){\n            uset[i] = i; rank[i] = 0;\n        }\n    }\n    int Find(int x)\n    {\n        if(x == uset[x]) return x;\n        else {\n            int fx = uset[x];\n            uset[x] = Find(fx);\n            return uset[x];\n        }\n    }\n    bool Union(int x, int y) //x and y are different\n    {\n        int fx = Find(x), fy = Find(y);\n        if(fx == fy) return false;\n        if(rank[fx] > rank[fy])\n            uset[fy] = fx;\n        else{\n            uset[fx] = fy;\n            if(rank[fx] == rank[fy]) rank[fy]++;\n        }\n        return true;\n    }\n\n};\n\nUnionSet us;\nint parent[MAXN];\nint isMarked[MAXN];\nvector<vector<int> >tree;\nint N, Q;\n\nvoid dfs(int r, int pa)\n{\n    for(int i=0; i<tree[r].size(); i++){\n        int x = tree[r][i];\n        if(isMarked[x]) dfs(x, x);\n        else dfs(x, pa);\n    }\n    us.Union(r, pa);\n}\n\n\nbool read()\n{\n    scanf(\"%d%d\", &N, &Q);\n    if(N==0&&Q==0) return false;\n    us.Init(N);\n    memset(isMarked, 0, sizeof(isMarked));\n    tree.clear();\n    tree.resize(N+1);\n    parent[1] = 1;\n    for(int i=2; i<=N; ++i){\n        scanf(\"%d\", &parent[i]);\n        tree[parent[i]].push_back(i);\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int q=0; q<Q; ++q){\n        op[q].input();\n        if(op[q].s[0] == 'M'){\n            int v = op[q].p;\n            isMarked[v] = true;\n        }\n    }\n    dfs(1, 1);\n    long long sum = 0;\n    for(int q=Q-1; q>=0; --q){\n        int v = op[q].p;\n        if(op[q].s[0] == 'M'){\n            us.Union(v, parent[v]);\n        }\n        else {\n            sum += us.Find(v);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n}\n\nint main()\n{\n    while(read()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* \n author:hdsdogge \n begin: \n end: \n cost: \n */\n#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<bitset>\n#include<cstdlib>\n#include<list>\n#include <sstream>\n#include<ctype.h>\nusing namespace std;\nconst int maxn=1000000+10;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst double PI = acos(-1.0);\nconst double eps = 1e-6;\nconst int INF = 1000000000;\nint T,n,m;\nint par[maxn];\nint vis[maxn];\nint main() {\n    //freopen(\"test\",\"r\",stdin);\n    //freopen(\"out\",\"w\",stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    while(cin>>n>>m&&(n+m)){\n        memset(par,0,sizeof(par));\n        memset(vis,0, sizeof(vis));\n        par[1]=1;\n        vis[1]=1;\n        ll ans=0;\n        for(int i=2;i<=n;i++){\n            int x;\n            cin>>x;\n            par[i]=x;\n        }\n        for(int i=0;i<m;i++){\n            char c;\n            int x;\n            cin>>c>>x;\n            if(c=='Q'){\n                x=par[x];\n                while(vis[x]==0){\n                    x=par[x];\n                }\n                ans+=x;\n            }\n            else if(c=='M'){\n               vis[x]=1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n} \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#define ll long long\n#define maxn 100005\nusing namespace std;\n\npair<char, int> query[maxn];\n\nint par[maxn], flag[maxn], n, q;\n\nint getfa(int x) {\n    if (flag[x])\n        return x;\n    else {\n        par[x] = getfa(par[x]);\n        return par[x];\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &q) == 2 && n && q) {\n        memset(flag, 0, sizeof flag);\n        flag[0] = 1; par[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int p; scanf(\"%d\", &p);\n            par[i] = p - 1;\n        }\n        for (int i = 0; i < q; i++) {\n            scanf(\" %c %d\", &query[i].first, &query[i].second);\n            query[i].second--;\n            if (query[i].first == 'M')\n                flag[query[i].second]++;\n        }\n        ll ans = 0;\n        for (int i = q - 1; ~i; i--)\n            if (query[i].first == 'M')\n                flag[query[i].second]--;\n            else\n                ans += getfa(query[i].second) + 1;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//支持分?操作的并?集\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N=1e5+10;\nint par[MAX_N];\nint find(int x){\n  int tmp=x;\n  while(par[tmp]!=tmp){\n    tmp=par[tmp];\n  }\n  return tmp;\n}\nint main(){\n  //freopen(\"in\", \"r\", stdin);\n  char op[2];\n  int N, Q, x;\n  ll ans;\n  par[1]=1;\n  while(scanf(\"%d%d\", &N, &Q), N){\n    ans=0;\n    for(int i=2; i<=N; i++){\n      scanf(\"%d\", par+i);\n    }\n    while(Q--){\n      scanf(\"%s%d\", op, &x);\n      if(*op=='M'){\n        par[x]=x;\n      }\n      else ans+=(ll)find(x);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nint rak[100001],par[100001],p[100001];\n\nbool mark[100001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    }\n  }\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n    }else{\n    return find(par[x]);\n    }\n  }\n\nint findancestor(int x){\n  if(mark[par[x]]){\n    return par[x];\n    }else{\n      return findancestor(par[x]);\n    }\n  }\n  \nvoid unite(int x,int y){\n   x=find(x);\n   y=find(y);\n   if(x==y) return;\n   \n   if(rak[x]<rak[y]){\n     par[y]=x;\n     }else{\n     par[y]=x;         \n     if(rak[x]==rak[y]) rak[x]++;\n     }\n  }\n\nint main() {\n  \n  while(1){\n\n   int N,Q;  scanf(\"%d %d\",&N,&Q);\n   \n   if(N==0&&Q==0) break;\n   \n   memset(mark,0,sizeof(mark));\n   \n   init(N);   mark[1]=1;\n   \n   for(int i=1; i<=N-1; i++){\n     int x; cin>>x;\n     p[i+1]=x;\n     }\n     \n   for(int i=N; i>=2; i--){\n     unite(p[i],i);\n     }\n     \n   int ans=0;\n     \n   for(int i=0; i<Q; i++){\n     \n     char t; cin>>t;\n     \n       if(t=='M'){\n       \n        int v; cin>>v; mark[v]=1;\n       \n       }else if(t=='Q'){\n         \n        int v; cin>>v; \n        ans+=findancestor(v);\n         \n       }\n     \n     }\n               \n              cout<<ans<<endl;\n              \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define M 100005\nint n,q;\nbool mark[M];\nstruct node {\n\tint type,u;\n} Q[M];\nlong long ans;\nstruct together {\n\tint fa,sum;\n} A[M];\nint Find(int x) {\n\tif(mark[A[x].sum])return A[x].fa;\n\tint f=A[x].fa;\n\tA[x].fa=Find(f);\n\tA[x].sum=A[f].sum;\n\treturn A[x].fa;\n}\nint main() {\n\tint x,u;\n\tchar op[5];\n\twhile(scanf(\"%d %d\",&n,&q),n||q) {\n\t\tans=0;\n\t\tA[1].fa=1,A[1].sum=1;\n\t\tmark[1]=1;\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tscanf(\"%d\",&x);\n\t\t\tA[i].fa=x;\n\t\t\tA[i].sum=0;\n\t\t\tmark[i]=0;\n\t\t}\n\t\tfor(int i=1; i<=q; i++) {\n\t\t\tscanf(\"%s %d\",op,&Q[i].u);\n\t\t\tif(op[0]=='M') {\n\t\t\t\tQ[i].type=1;\n\t\t\t\tmark[Q[i].u]=1;\n\t\t\t\tA[Q[i].u].sum=Q[i].u;\n\t\t\t} else Q[i].type=2;\n\t\t}\n\t\tfor(int i=q; i>=1; i--) {\n\t\t\t//printf(\"id=%d\\n\",i);\n\t\t\tif(Q[i].type==1) {\n\t\t\t\tmark[Q[i].u]=0;\n\t\t\t\tmark[1]=1;\n\t\t\t} else {\n\t\t\t\tFind(Q[i].u);\n\t\t\t\tans+=A[Q[i].u].sum;\n\t\t\t\t//printf(\"sum=%d\\n\",A[Q[i].u].sum);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1<<28;\n\nvoid dfs(int p, int now, vec& M, vec& par, mat& T) {\n    if (p != now && M[now] != INF) return ;\n    par[now] = p;\n    for (int i = 0; i < T[now].size(); i++) {\n        dfs(p, T[now][i], M, par, T);\n    }\n}\n\nint Find(int p, vec& par) {\n    if (p == par[p]) return p;\n    return par[p] = Find(par[p], par);\n}\n\nvoid Merge(int x, int y, vec& par) {\n    x = Find(x, par), y = Find(y, par);\n    if (x != y) {\n        par[x] = y;\n    }\n}\n\nvoid solve(int N, int Q) {\n    mat T(N+1);\n    vec Tr(N+1);\n    Tr[1] = 1;\n    for (int i = 2; i <= N; i++) {\n        int v; cin >> v;\n        T[v].push_back(i);\n        Tr[i] = v;\n    }\n\n    vec MarkedTime(N+1, INF);\n    vec TimeToMarkedVertex(Q+1);\n    vec QueryTimeToVertex(Q+1);\n    MarkedTime[1] = -1;\n    for (int i = 0; i < Q; i++) {\n        char q;\n        int v;\n        cin >> q >> v;\n        if (q == 'M') MarkedTime[v] = i, TimeToMarkedVertex[i] = v;\n        else QueryTimeToVertex[i] = v;\n    }\n\n    vec par(N+1, 1);\n    for (int i = 1; i <= N; i++) {\n        if (MarkedTime[i] == INF) continue;\n        dfs(i, i, MarkedTime, par, T);\n    }\n\n    int cost = 0;\n    for (int i = Q - 1; i > -1; i--) {\n        if (QueryTimeToVertex[i] > 0) cost += Find(par[QueryTimeToVertex[i]], par);\n        else Merge(TimeToMarkedVertex[i], Tr[TimeToMarkedVertex[i]], par);\n    }\n\n    cout << cost << endl;\n}\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N || Q) solve(N, Q);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<long long int> data;\n\tUnionFind(long long int size) : data(size, -1) { }\n\tbool unionSet(long long int x, long long int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(long long int x, long long int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tlong long int root(long long int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tlong long int size(long long int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=(int)queries.size()-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else{\n    int a = query(t[v]);\n    t[v] = a;\n    return a;\n  }\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    long long int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v]++;\n      qs.push_front(make_pair(order,v));\n    }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second]--;\n\n    printf(\"%lld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint tpar[100000],par[100000];\nbool mark[100000];\nint search(int a){\n    if(mark[a]) return a;\n    else return search(tpar[a]);\n}\nint find(int a){\n    if(par[a]==a) return a;\n    else return par[a]=find(par[a]);\n}\nvoid unite(int a,int b){\n    par[find(a)]=find(b);\n}\nint main(){\n    int N,Q;\n    for(;;){\n        scanf(\"%d %d\\n\",&N,&Q);\n        if(N==0 && Q==0) break;\n        tpar[0]=0;\n        int p;\n        for(int i=1;i<N;i++){\n            scanf(\"%d\\n\",&p);\n            tpar[i]=p-1;\n        }\n        fill(mark,mark+N,false);\n        mark[0]=true;\n        char q;\n        int a;\n        vector<pair<char,int>> query;\n        for(int i=0;i<Q;i++){\n            scanf(\"%c %d\\n\",&q,&a);\n            a--;\n            query.PB(MP(q,a));\n            if(q=='M') mark[a]=true;\n        }\n        for(int i=0;i<N;i++){\n            par[i]=search(i);\n        }\n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            int now=query[i].second;\n            if(query[i].first=='Q') ans+=find(now)+1;\n            else unite(now,tpar[now]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint par[100000];\nint mark[100000];\nint uf[100000];\nint root(int x){\n  if(uf[x] == x) return x;\n  return uf[x] = root(uf[x]);\n}\nint main(){\n  int N, Q;\n  while(cin>>N>>Q && N){\n    par[0] = -1;\n    uf[0] = 0;\n    REP(i, N - 1){\n      cin>>par[i + 1];\n      par[i + 1]--;\n      uf[i + 1] = par[i + 1];\n    }\n    memset(mark, 0, sizeof(mark));\n    char c[100000];\n    int v[100000];\n    REP(i, Q){\n      cin>>c[i]>>v[i];\n      v[i]--;\n      if(c[i] == 'M'){\n        mark[v[i]]++;\n      }\n    }\n    REP(i, N) if(mark[i] > 0){\n      uf[i] = i;\n    }\n    ll ans = 0;\n    for(int i = Q - 1; i >= 0; i--){\n      if(c[i] == 'M'){\n        mark[v[i]]--;\n        if(mark[v[i]] == 0){\n          uf[v[i]] = par[v[i]];\n        }\n      }else{\n        ans += root(v[i]) + 1;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tmarked[1] = true;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t\tmarked[i]= false;\n\t}\n}\nint getnode(int x){\n\tif(marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tlong long sum;\n\twhile(cin>>n>>q,n||q){\n\t\tinit(n);\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\twhile(!marked[k]) k =par[k];\n\t\t\t\tsum +=k;\n\t\t\t}\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t\tcout <<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// range max, point assign\npii dat[1<<19];\nint N;\nvoid init(int n){\n  N = 1;\n  while(N<n)N<<=1;\n  REP(i,2*N-1)dat[i] = pii(-1,-1);\n}\nvoid add(int l,int r,pii val,int a,int b,int k){\n  if(r<=a || b<=l)return;\n  if(l<=a && b<=r){\n    dat[k] = max(dat[k],val);\n    return;\n  }\n  add(l,r,val,a,(a+b)/2,2*k+1);\n  add(l,r,val,(a+b)/2,b,2*k+2);\n}\nvoid add(int l,int r,pii val){\n  if(r<=l)return;\n  add(l,r,val,0,N,0);\n}\npii get(int x,int a,int b,int k){\n  pii ret = dat[k];\n  if(a+1==b && a==x)return ret;\n  int mid = (a+b)/2;\n  if(x<mid){\n    return max(ret,get(x,a,mid,2*k+1));\n  }else{\n    return max(ret,get(x,mid,b,2*k+2));\n  }\n}\npii get(int x){\n  return get(x,0,N,0);\n}\n\nvi g[125252];\nbool used[125252];\nint lft[125252],rig[125252];\nint height[125252];\n\nvoid dfs(int p,int &iter,int h){\n  used[p] = true;\n  height[p] = h;\n  lft[p] = iter;\n  iter++;\n  REP(i,g[p].size()){\n    int to = g[p][i];\n    if(used[to])continue;\n    dfs(to,iter,h+1);\n  }\n  used[p] = false;\n  rig[p] = iter;\n  iter++;\n}\nint main(){\n  while(true){\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0 && q==0)break;\n    REP(i,n){\n      g[i].clear();\n      used[i] = false;\n      lft[i] = n+1;\n      rig[i] = -1;\n    }\n    REP(i,n-1){\n      int src = i+1;\n      int to;\n      scanf(\"%d\",&to);--to;\n      g[src].push_back(to);\n      g[to].push_back(src);\n    }\n    init(2*n);\n    int iter = 0;\n    dfs(0,iter,0);\n    add(lft[0],rig[0],pii(height[0],0));\n    ll ans = 0;\n    while(q--){\n      char s[5];\n      int x;\n      scanf(\"%s%d\",s,&x);\n      --x;\n      if(s[0]=='M'){\n        add(lft[x],rig[x],pii(height[x],x));\n      }else{\n        pii val = get(lft[x]);\n        ans += val.second+1;\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct UF {\n    int *par;\n    UF(int n) {\n        par=new int[n];\n        for(int i=0;i<n;i++) {\n            par[i]=i;\n        }\n    }\n    int find(int x) {\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void unite(int x,int y) {\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        par[x]=y;\n    }\n    bool same(int x,int y) {\n        return find(x)==find(y);\n    }\n};\nint marked[100000];\nchar op[100000][2];\nint v[100000];\nint par[100000];\nint main() {\n    int N,Q;\n    while(scanf(\"%d %d\",&N,&Q),N) {\n        par[0]=-1;\n        for(int i=1;i<N;i++) {\n            scanf(\"%d\",&par[i]);par[i]--;\n        }\n        fill(marked,marked+100000,0);\n        marked[0]=1;\n        for(int i=0;i<Q;i++) {\n            scanf(\"%s %d\",op[i],&v[i]);v[i]--;\n            if(op[i][0]=='M') marked[v[i]]++;\n        }\n        UF u(N);\n        for(int i=1;i<N;i++) {\n            if(marked[i]>0) u.unite(i,par[i]);\n        }\n        long long ans=0;\n        for(int i=Q-1;i>=0;i--) {\n            if(op[i][0]=='M') {\n                if(marked[v[i]]>0) {\n                    marked[v[i]]--;\n                    if(marked[v[i]]==0) u.unite(v[i],par[v[i]]);\n                }\n            }else {\n                ans+=u.find(v[i])+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N), nma.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear(), nma.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int INF=0x3f3f3f3f;\n#define N 200005\n\nint p[N],m[N];\n\nint find(int x){\n\tif(m[p[x]]!=0)return p[x];\n\telse return p[x]=find(p[x]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,q;\n\twhile(cin>>n>>q){\n\t\tif(n==0&&q==0)break;\n\t\tmemset(p,0,sizeof(p));\n\t\tmemset(m,0,sizeof(m));\n\t\tp[1]=1;\n\t\tm[1]=-1;\n\t\tfor (int i = 0; i < n-1; i++){\n\t\t\tcin>>p[i+2];\n\t\t}\n\t\tvector<pair<char,int>> st;\n\t\twhile(q--){\n\t\t\tchar t;\n\t\t\tint x;\n\t\t\tcin>>t>>x;\n\t\t\tst.push_back({t,x});\n\t\t\tif(t=='M'&&m[x]==0){\n\t\t\t\tm[x]=st.size();\n\t\t\t}\n\t\t}\n\t\tll sum=0;\n\t\tfor(int i=st.size()-1;i>=0;i--){\n\t\t\tif(st[i].fi=='M'){\n\t\t\t\tif(m[st[i].se]==i+1)m[st[i].se]=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum+=find(st[i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll mini=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[mini]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10));\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define RG register int\n#define rep(i,a,b)\tfor(RG i=a;i<=b;++i)\n#define per(i,a,b)\tfor(RG i=a;i>=b;--i)\n#define ll long long\n#define inf (1<<29)\n#define maxn 100005\nusing namespace std;\nint n,T,x,cnt,tim,ans;\nint fa[maxn],tag[maxn],qa[maxn],qb[maxn];\ninline int read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nint find(int x)\n{\n\treturn tag[x]<tim?x:fa[x]=find(fa[x]);\n}\n\nint main()\n{\n\tn=read(),T=read();\n\trep(i,2,n)\tfa[i]=read(),tag[i]=i+n;\n\tchar s[5];\n\trep(i,1,T)\n\t{\n\t\tscanf(\"%s\",s);x=read();\n\t\tif(s[0]=='M')\n\t\t\ttag[x]=min(tag[x],i);\n\t\telse\n\t\t\tqa[++cnt]=x,qb[cnt]=i;\n\t}\n\tper(i,cnt,1)\n\t{\n\t\ttim=qb[i];\n\t\tans+=find(qa[i]);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define TEST 0\nint par[100001];\nbool marked[100001];\nint find_marked(int id)\n{\n    if(marked[id])return id;\n    return find_marked(par[id]);\n}\nint main(void)\n{\n    int n,q;\n    while(scanf(\"%d%d\",&n,&q)==2 && (n!=0 || q != 0))\n    {\n        par[1]=0;\n        marked[1]=true;\n        long long int sum=0;\n        for(int i=0;i<n-1;i++)\n        {\n            scanf(\"%d\",par + i+2);\n            marked[i+2]=false;\n        }\n        for(int j=0;j<q;j++)\n        {\n            char str[8];\n            int num;\n            scanf(\"\\n%[QM]%d\",str,&num);\n#if TEST\n            printf(\"%c:%d\\n\",str[0],num);\n#endif\n            switch(str[0])\n            {\n            case 'Q':\n                    sum+=find_marked(num);\n                    break;\n            case 'M':\n                    marked[num]=true;\n                    break;\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n        init(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nvector<int> G[100000];\nbool isMarked[100000];\nint parent[100000];\nusing P = pair<char,int>;\n\nvoid dfs1(int v, int pre, union_find &UF){\n    if(!isMarked[v]) UF.unite(pre,v);\n    for(auto to:G[v]){\n        if(to!=pre) dfs1(to,v,UF);\n    }\n    return;\n}\n\nint main(){\n    int N,Q;\n    while(cin>>N>>Q,N){\n        for(auto &g:G) g.clear();\n        fill(isMarked,isMarked+100000,false);\n        fill(parent,parent+100000,-1);\n        parent[0]=-1;\n        for(int i=1;i<N;i++){\n            int p;\n            cin>>p; p--;\n            parent[i]=p;\n            G[p].push_back(i);\n            G[i].push_back(p);\n        }\n        isMarked[0]=true;\n        vector<P> V;\n        for(int i=0;i<Q;i++){\n            char C;\n            int v;\n            cin>>C>>v; v--;\n            if(C=='M') isMarked[v]=true;\n            V.emplace_back(C,v);\n        }\n        reverse(V.begin(), V.end());\n        union_find UF(N);\n        dfs1(0,-1,UF);\n        int ans = 0;\n        for(auto p:V){\n            char C; int v;\n            tie(C,v)=p;\n            if(C=='Q'){\n                ans+=UF.find(v);\n            }else{\n                UF.unite(v,parent[v]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nint N, Q;\nint p[MAX_N+5];\nbool M[MAX_N+5];\nint uf_par[MAX_N+5];\nint uf_rank[MAX_N+5];\nint mark[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < N; i++) {\n        uf_par[i] = i;\n        uf_rank[i] = 0;\n        mark[i] = i;\n        p[i] = 0;\n        M[i] = false;\n    }\n}\n\nint find(int x) {\n    if (uf_par[x] == x) {\n        return x;\n    } else {\n        return uf_par[x] = find(uf_par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(uf_rank[x] < uf_rank[y]) {\n        uf_par[x] = y;\n        mark[y] = mark[x];\n    } else {\n        uf_par[y] = x;\n        if(uf_rank[x] == uf_rank[y]) uf_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid debug() {\n    for(int i = 0; i < N; i++) {\n        cout << i << \": \" << mark[i] << \": \" << find(i) << \": \" << mark[find(i)] << endl;\n    }\n}\n\nint main() {\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        init(N);\n        for(int i = 1; i < N; i++) {\n            cin >> p[i];\n            p[i]--;\n        }\n        vector<P> query;\n        char qm;\n        int num;\n        for(int i = 0; i < Q; i++) {\n            cin >> qm >> num;\n            num--;\n            if(qm == 'M') {\n                M[num] = true;\n            }\n            query.push_back(P(qm, num));\n        }\n\n        for(int i = 0; i < N; i++) {\n            if(!M[i]) {\n                // cout << \"unite \" << p[i] << \": \" << i << endl;\n                // cout << M[i] << endl;\n                unite(p[i], i);\n                // debug();\n            }\n        }\n\n        // cout << \"====\" << endl;\n        long long int count = 0;\n        for(int i = query.size()-1; i >= 0; i--) {\n            int n = query[i].second;\n            if(query[i].first == 'M') {\n                // cout << \"unite \" << p[n] << \": \" << n << endl;\n                unite(p[n], n);\n                // debug();\n            } else {\n                count += mark[find(n)] + 1;\n                // cout << \"n: \" << n << \" count += \" << mark[find(n)] << endl;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint par[100010],o[100010];\n\nint find(int pos){\n  if(o[pos]) return pos;\n  return find(par[pos]);\n}\n\nint main(){\n  while(1){\n    int n,q;\n    cin>>n>>q;\n    if(!n&&!q)break;\n    for(int i=0;i<=n;i++) o[i]=0;\n    for(int i=2;i<=n;i++) cin>>par[i];\n    \n    o[1]=1;\n    long long ans=0;\n    while(q--){\n      char ch;int idx;\n      cin>>ch>>idx;\n      if(ch=='M') o[idx]=1;\n      if(ch=='Q')ans+=find(idx);\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w;\n\n\twhile(cin>>n>>q&&n){\n\n\tfor(int i=1;i<n;i++){\n\t\tcin>>z;z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tcin>>w>>z;z--;\n\n\t\tif(w=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\tif(w=='Q'){\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+1];\nint rank[MAX+1];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init(MAX);\n    par[0] = 1;\n    for(int i = 1 ; i < n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      --num;\n      if(ch == 'Q'){\n\tsum += find(num)+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\nint anc[100008];\nbool mark[100007];\nint root(int n) {\n\tif (mark[n] == true)return n;\n\telse root(anc[n]);\n}\nint main()\n{\n\tint n, q;\n\twhile (cin >> n >> q, n != 0) {\n\t\tfor (int i = 0; i < 100005; i++) {\n\t\t\tanc[i] = mark[i] = 0;\n\t\t}\n\t\tmark[0] = true;\n\t\tint tmp;\n\t\tchar c;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &tmp);\n\t\t\tanc[i] = tmp - 1;\n\t\t}long long ans = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> c >> tmp;\n\t\t\tif (c == 'Q')ans += root(tmp-1)+1;\n\t\t\telse mark[tmp - 1] = true;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 0\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tret[max(checked[pos][i]-1,0ll)]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\nvoid setLevel(int i, int n)\n{\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\t//cout << \"nearest \" << p << \", \" << n.second << endl;\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t\tchild[1][i].clear();\n\t\tparent[0][i]=0;\n\t\tparent[1][i]=0;\n\t\tlevel[i]=0;\n\t\tnearest[i]=P(0,0);\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\tchild[0][p].push_back(i);\n\t}\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\nfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tstep*=2;\n\t}\n\n\t//*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << parent[cur][i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}//*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tLL sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint N, Q;\nint par[100001];\nVI chd[100001];\nVI node(100001, 1);\nVI mkd(100001, 0);\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nvoid init(int i, int p, UnionFind& uf){\n  if(mkd[i]){\n\tfor(int c: chd[i]){\n\t  init(c, i, uf);\n\t}\n  }\n  else{\n\tnode[i] = node[p];\n\tuf.unite(p, i);\n\tfor(int c: chd[i]){\n\t  init(c, p, uf);\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> N >> Q, N){\n\tREP(i,100001) chd[i].clear();\n\tUnionFind uf(N+1);\n\tREP(i,N-1){\n\t  cin >> par[i+2];\n\t  chd[par[i+2]].PB(i+2);\n\t}\t\n\t\n\tvector<PII> q;\n\tfor(int i=1;i<=N;++i)\n\t  node[i] = i;\n\tfill(ALL(mkd), false);\n\tmkd[1] = true;\n\tREP(i,Q){\n\t  char ch; int x;\n\t  cin >> ch >> x;\n\t  if(ch == 'M')\n\t\tq.PB(MP(0,x)), mkd[x]++;\n\t  else\n\t\tq.PB(MP(1,x));\n\t}\n\n\tinit(1, 1, uf);\n\t\n\tLL ans = 0;\n\tfor(int i=Q-1;i>=0;--i){\n\t  if(q[i].first == 0){\n\t\tint idx = q[i].second;\n\t\t--mkd[idx];\n\t\tif(!mkd[idx]){\n\t\t  node[uf.find(idx)] = node[uf.find(par[idx])];\n\t\t  uf.unite(idx, par[idx]);\n\t\t}\n\t  }\n\t  else{\n\t\tans += node[uf.find(q[i].second)];\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\n    vector<int> par;\npublic:\n    UnionFind(int size = 0) {\n        for (int i = 0; i < size; i++) par.push_back(i);\n    }\n\n    void set_root(int v, int root) {\n        par[find(v)] = find(root);\n    }\n\n    int find(int v) {\n        if (par[v] == v) return v;\n        return par[v] = find(par[v]);\n    }\n};\n\nUnionFind UF;\nvector<vector<int>> G;\nvector<int> marked;\n\nvoid dfs(int u, int p) {\n    if (marked[u]) p = u;\n    UF.set_root(u, p);\n    for (int v : G[u]) {\n        dfs(v, p);\n    }\n}\n\nint main()\n{\n    while (1) {\n        int n, q; cin >> n >> q;\n        if (!n) break;\n        UF = UnionFind(n);\n        G = vector<vector<int>>(n);\n        vector<int> par(n);\n        loop (n-1, i) {\n            int p; cin >> p;\n            p--;\n            par[i+1] = p;\n            G[p].push_back(i+1);\n        }\n\n        marked = vector<int>(n);\n        vector<char> type(q);\n        vector<int> val(q);\n        loop (q, i) {\n            cin >> type[i] >> val[i];\n            val[i]--;\n            if (type[i] == 'M') marked[val[i]] = 1;\n        }\n\n        dfs(0, 0);\n\n        ll ans = 0;\n        loop (q, i) {\n            int j = q - 1 - i;\n            if (type[j] == 'Q') {\n                ans += UF.find(val[j])+1;\n            }\n            if (type[j] == 'M') {\n                UF.set_root(val[j], par[val[j]]);\n                for (int v : G[val[j]]) {\n                    UF.set_root(v, val[j]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+1];\nint rank[MAX+1];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } \n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init(n);\n    par[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tsum += find(num)+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define MAXN 100000\nusing namespace std;\nint par[MAXN+1];\nbool mark[MAXN+1];\nvoid init(int n)\n{\n    for(int i=1;i<n;i++)\n    {\n        par[i]=1;\n        mark[i]=false;\n    }\n    mark[1]=true;\n}\nint findpar(int x)\n{\n    if(mark[x]) return x;\n    else return findpar(par[x]);\n}\nint main()\n{\n    int n,q,x,ans;\n    char c;\n    scanf(\"%d %d\",&n,&q);\n    while(n!=0||q!=0)\n    {\n    ans=0;\n    init(n);\n    for(int i=2;i<=n;i++)\n        scanf(\"%d\",&par[i]);\n    for(int i=0;i<q;i++)\n    {\n        cin>>c>>x;\n        if(c=='M') mark[x]=true;\n        else ans+=findpar(x);\n    }\n    printf(\"%lld\\n\",ans);\n    scanf(\"%d %d\",&n,&q);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi col,in;\nint dfs(int a){\n\tif(col[a])return a;\n\telse return dfs(in[a]);\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tcol=vi(n);\n\t\tcol[0]=1;\n\t\tin=vi(n);\n\t\trep(i,n-1){\n\t\t\tint a;cin>>a;\n\t\t\tin[i+1]=a-1;\n\t\t}\n\t\tint out=0;\n\t\trep(i,m){\n\t\t\tchar c;int a;\n\t\t\tcin>>c>>a;\n\t\t\tif(c=='M')col[a-1]=true;\n\t\t\telse{\n\t\t\t\tout+=1+dfs(a-1);\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n ━━━━━?\n ┓┏┓┏┓┃μ'sic foever!!\n ┛┗┛┗┛┃＼○／\n ┓┏┓┏┓┃ /\n ┛┗┛┗┛┃ノ)\n ┓┏┓┏┓┃\n ┛┗┛┗┛┃\n ┓┏┓┏┓┃\n ┛┗┛┗┛┃\n ┓┏┓┏┓┃\n ┛┗┛┗┛┃\n ┓┏┓┏┓┃\n ┃┃┃┃┃┃\n ┻┻┻┻┻┻\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst int maxn=1e5+10;\nbool vis[maxn];\nint pre[maxn];\nlong long res;\nbool flag;\nint find(int x){\n    int r = x;\n    while(pre[r]!=r){\n        if(!flag&&vis[pre[r]]){\n            res += pre[r];\n            flag = true;\n            return -1;\n        }\n        r = pre[r];\n    }\n    return r;\n}\nvoid join(int a,int b){\n    pre[b]=a;\n}\nint main(){\n    int n,q,i,j,a,b;\n    char op;\n    while(~scanf(\"%d%d\",&n,&q)&&n&&q){\n        res = 0;\n        memset(vis, false, sizeof(vis));\n        for(i=1;i<=n;i++){\n            pre[i] = i;\n        }\n        for(i=2;i<=n;i++){\n            scanf(\"%d\",&a);\n            join(a,i);\n        }\n        getchar();\n        for(i=1;i<=q;i++){\n            scanf(\"%c %d\",&op,&a);\n            if(op=='Q'){\n                if(!vis[a]){\n                    flag = false;\n                    if(find(a)==-1){\n                        \n                    }else{\n                        res += 1;\n                    }\n                }else{\n                    res += a;\n                }\n            }else{\n                vis[a] = true;\n            }\n            getchar();\n        }\n        printf(\"%lld\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define int_ int64_t\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=100010;\nint n,q,v;\nchar buf[4];\nvector<int> g[N];\nint p[N],dsu[N];\nbool marked[N];\n\nint fi(int x) {\n    return dsu[x]==x?x:(dsu[x]=fi(dsu[x]));\n}\n\nvoid dfs(int x,int ma) {\n    if (marked[x]) {\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],x);\n        }\n    } else {\n        dsu[x]=ma;\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],ma);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&q);\n        if (n==0&&q==0) break;\n        memset(p,0,sizeof(p));\n        memset(marked,0,sizeof(marked));\n        for (int i=1;i<=n;i++) {\n            dsu[i]=i;\n            g[i].clear();\n        }\n        for (int i=2;i<=n;i++) {\n            scanf(\"%d\",&v);\n            p[i]=v;\n            g[v].pb(i);\n        }\n        vector<PII> op;\n        for (int i=1;i<=q;i++) {\n            scanf(\"%s%d\",buf,&v);\n            if (buf[0]=='M') {\n                if (!marked[v]) {\n                    marked[v]=1;\n                    op.pb(mp(0,v));\n                }\n            } else {\n                op.pb(mp(1,v));\n            }\n        }\n        marked[1]=1;\n        dfs(1,1);\n        ll ans=0;\n        for (int i=q-1;i>=0;i--) {\n            if (op[i].first) {\n                ans+=fi(op[i].second);\n            } else {\n                int r=fi(p[op[i].second]);\n                dsu[op[i].second]=r;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x] ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t\tchk[x] = true;\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\tnear[-1] = -1;\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\t//for( auto i : memo ) cout << i << endl;\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint par[100002];\nint root(int x){\n\tif(par[x]==x)return x;\n\treturn root(par[x]);\n}\nint main(){\n\tint N,Q,v;\n\tchar X;\n\tpar[1] = 1;\n\twhile(cin>>N>>Q,N){\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcin>>par[i];\n\t\t}\n\t\tll ans = 0;\n\t\tfor(int i=0;i<Q;++i){\n\t\t\tcin >> X >> v;\n\t\t\tif(X=='M'){\n\t\t\t\tpar[v] = v;\n\t\t\t}else{\n\t\t\t\tans += root(v);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100005;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n    for(int i = 1; i <= n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n\n    for(int i = 0; i < MAX; i++)\n      mark[i] = 0;\n\n  }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  int ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (ll i = 0; i < (ll)n; i++)\n#define PI 3.14159265358979323846\n#define vll vector<long long>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nclass UnionFind {\nprivate:\n  ll n;\n  vll P;\n  void setN(ll N);\n  void init();\n\npublic:\n  UnionFind(ll N);\n  ll root(ll x);\n  void unite(ll x, ll y);\n  bool same(ll x, ll y);\n};\n\n// コンストラクタ\nUnionFind::UnionFind(ll N) {\n  setN(N);\n  init();\n}\n\n// nを変更\nvoid UnionFind::setN(ll N) { n = N; }\n\n// Union-Find Treeを初期化する\nvoid UnionFind::init() {\n  P.clear();\n  rep(i, n) { P.push_back(i); }\n}\n\n// 根の値を返す\nll UnionFind::root(ll x) {\n  if (P[x] == x) { return x; }\n  return (P[x] = root(P[x])); // パス圧縮しつつ返す\n}\n\n// 木を結合する（rankはとりあえず無視）\nvoid UnionFind::unite(ll x, ll y) { P[root(x)] = root(y); }\n\n// xとyが同じ集合にあるか判別\nbool UnionFind::same(ll x, ll y) {\n  if (root(x) == root(y)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// ----本問について----\n// 問題：Marked Ancestor\n// 問題文URL：https://onlinejudge.u-aizu.ac.jp/problems/2170\n// 所要時間：\n// 学んだこと：\n// ------------------\n\n// ----ここから本問のソースコード----\n\n// グローバル変数（入力）\nll n, q, P[100010];\nvector<pair<char, ll>> ope;\n\n// 入力\nvoid input() {\n  for (ll i = 1; i < n; i++) {\n    ll p;\n    cin >> p;\n    P[i] = p - 1; // 親を入力\n  }\n  ope.clear();\n  rep(i, q) {\n    char c;\n    cin >> c;\n    ll v;\n    cin >> v;\n    ope.push_back(make_pair(c, v - 1)); // 操作を入力\n  }\n}\n\nvoid solve() {\n  // isPaintedを初期化\n  vll isPainted(n);\n  isPainted[0] = 1;\n  rep(i, n - 1) { isPainted[i] = 0; }\n\n  // とりあえず塗る\n  rep(i, ope.size()) {\n    char c = ope[i].first;\n    ll v = ope[i].second;\n    if (c == 'M') {\n      if (isPainted[v] == 0) {\n        isPainted[v] = 1;\n      } else {\n        ope.erase(ope.begin()+i); // 複数の同じ「M v」は最初の以外除外しておく．\n        i--;\n      }\n    }\n  }\n  q = ope.size();\n\n  // UnionFind登場、塗られてるやつを根としてグループを形成する．\n  UnionFind u(n);\n  rep(i, n) {\n    if (isPainted[i] == 0) {\n      u.unite(i, P[i]); // 塗られてない奴は親と結合する\n    }\n  }\n\n  // opeを後ろから処理する\n  reverse(ope.begin(), ope.end());\n  ll ans = 0;\n  rep(i, q) {\n    ll v = ope[i].second;\n    if (ope[i].first == 'Q') {\n      ans += u.root(v) + 1; // グループの長がmarked ancestor\n    } else {\n      u.unite(v, P[v]); // グループ統合\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n  while (cin >> n >> q && n > 0) {\n    input();\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n//      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector<vi> g(n);\n\t\tvi par(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].push_back(i+1);\n\t\t\tpar[i+1] = p;\n\t\t}\n\t\tll sum = 0;\n\t\tvector<pii> query;\n\t\tvi marked(n);\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tquery.emplace_back(1, v);\n\t\t\t}else{\n\t\t\t\tif(marked[v] == 0){\n\t\t\t\t\tmarked[v] = i+1;\n\t\t\t\t\tquery.emplace_back(0, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(n);\n\t\tqueue<int> que;\n\t\tque.push(0);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tif(marked[v] == 0) uf.unionSet(par[v], v);\n\t\t\tFOR(u, g[v]) que.push(*u);\n\t\t}\n\t\tRREP(i, query.size()){\n\t\t\tint v = query[i].second;\n\t\t\tif(query[i].first) sum += 1 + uf.root(v);\n\t\t\telse uf.unionSet(par[v], v);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n//unionfind??????????????\\??????????????????????????´???\nstruct UnionFind {\n\tvector<int> to;\n\tvector<int> data;\n\tUnionFind(int size) : to(size, -1),data(size, -1) { }\n\t\n\t//??????x?????????y????¶????????????????(data[root(x | y)] = data[root(x)]???????????????)\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tint rootData = data[root(x)];\n\t\tif (x != y) {\n\t\t\tif (to[y] < to[x]) swap(x, y);\n\t\t\tto[x] += to[y]; to[y] = x;\n\t\t}\n\t\tsetData(x, rootData);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn to[x] < 0 ? x : to[x] = root(to[x]);\n\t}\n\tint size(int x) {\n\t\treturn -to[root(x)];\n\t}\n\n\tint findData(int x) {\n\t\treturn data[root(x)];\n\t}\n\tvoid setData(int x, int d) {\n\t\tdata[root(x)] = d;\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i]; v[i]--;\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a, int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\t\trep(i, n) {\n\t\t\tuf.setData(i, i);\n\t\t}\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tuf.unionSet(e[e[j].p].m, e[j].m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findData(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[1] = 1;\n\tfor(int i = 1;i < n;i++){\n\t    cin >> root[i];\n\t    root[i]--;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    marked[--query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q-1;i>=0;i--){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second) + 1;\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,0)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tparent[b]=a;\n\t\treturn true;\n\t}\n};\nint n,t;\nvector<int>G[1<<17];\nbool mark[1<<17];\nint parent[1<<17];\nvoid dfs(int u,int p,int U,UF&uf)\n{\n\tif(mark[u])U=u;\n\telse uf.unite(U,u);\n\tfor(int i=0;i<G[u].size();i++)\n\t{\n\t\tif(G[u][i]==p)continue;\n\t\tdfs(G[u][i],u,U,uf);\n\t}\n}\nmain()\n{\n\twhile(cin>>n>>t,n)\n\t{\n\t\tfor(int i=0;i<n;i++)mark[i]=0,G[i].clear();\n\t\tUF uf(n);\n\t\tint ap[1<<17]={};\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint a;cin>>a;\n\t\t\tparent[i]=a-1;\n\t\t\tG[a-1].push_back(i);\n\t\t}\n\t\tvector<pair<bool,int> >q;\n\t\tfor(int i=0;i<t;i++)\n\t\t{\n\t\t\tchar c;int a;cin>>c>>a;\n\t\t\tif(c!='M'||!ap[a-1]++)q.push_back(make_pair(c=='M',a-1));\n\t\t\tif(c=='M')mark[a-1]=1;\n\t\t}\n\t\tmark[0]=1;\n\t\tdfs(0,-1,0,uf);\n\t\tlong ans=0;\n\t\tfor(int i=q.size();i--;)\n\t\t{\n\t\t\tif(q[i].first)\n\t\t\t{\n\t\t\t\tuf.unite(parent[q[i].second],q[i].second);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=uf.find(q[i].second)+1;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100010;\nconst int MAXM = 100010;\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair<char, int> P;\n\nint N, Q;\nint father[MAXN]; // 并查集中的父节点\nint parent[MAXN]; // 树中的父节点\nint vis[MAXN]; // 结点标记次数\nvector<int> e[MAXN]; // 记录边，即树的结构e[i][j]表示i的第j+1孩子\nstack<P> st; // 存储操作\n\nvoid dfs(int i, int f = 1) {\n\tif (vis[i])\n\t\tf = i;\n\tfather[i] = f;\n\tvector<int> &ei = e[i];\n\tfor (vector<int>::iterator it = ei.begin(); it != ei.end(); ++it) {\n\t\tdfs(*it, f);\n\t}\n}\n\n//void Init() {\n//\tfor (int i = 0; i < MAXN; ++i) {\n//\t\tfather[i] = i;\n//\t}\n//}\nint Find(int x) {\n\tif (father[x] == x)\n\t\treturn x;\n\treturn father[x] = Find(father[x]);\n}\n\nint main(int argc, char const *argv[]) {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &N, &Q) != EOF && !(N == 0 && Q == 0)) {\n\t\tint i, j, q;\n\t\tLL res = 0;\n\t\tchar opt[5];\n\t\tfor (i = 1; i <= N; ++i) {\n\t\t\te[i].clear();\n\t\t}\n\t\tfill(vis, vis + MAXN, 0);\n\t\tvis[1] = 1;\n\t\tfor (i = 2; i <= N; ++i) {\n\t\t\tscanf(\"%d\", &j);\n\t\t\te[j].push_back(i);// 结点j的孩子i,用于dfs\n\t\t\tparent[i] = j; // 结点i的父亲j\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tscanf(\"%s %d\", opt, &j);\n\t\t\tif (opt[0] == 'M') {\n\t\t\t\t++vis[j];// 结点j标记次数\n\t\t\t}\n\t\t\tst.push(P(opt[0], j));// 将操作入栈，操作名和结点\n\t\t}\n\t\tdfs(1); // 寻找最近染色祖先\n\t\t// 逆序处理操作\n\t\twhile (!st.empty()) {\n\t\t\ti = st.top().second; // 被操作结点\n\t\t\tif (st.top().first == 'M') { \n\t\t\t\tif (--vis[i] == 0) // 直到多余标记结束\n\t\t\t\t\tfather[i] = Find(parent[i]); // 取消染色\n\t\t\t} else {\n\t\t\t\tres += Find(i); // 查询操作，返回最近染色祖先\n\t\t\t}\n\t\t\tst.pop(); // 处理下一操作\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else{\n    int a = query(t[v]);\n    t[v] = a;\n    return a;\n  }\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v]++;\n      qs.push_front(make_pair(order,v));\n    }\n\n    // printf(\"asdf %d\\n\",(int)qs.size());\n    // for(int i=0; i<qs.size(); i++){\n    //    printf(\"%c %d\\n\",qs[i].first,qs[i].second);\n    // }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second]--;\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tvi T(n);\n\t\tvi m(n);\n\t\tvi mv(n);\n\t\tiota(ALL(mv), 0);\n\t\tm[0] = 1;\n\t\trep1(i, n - 1)cin >> T[i], T[i]--;\n\t\tvpii a(q);\n\t\tunionfind uf(n);\n\t\tll ans = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')m[v - 1] = 1;\n\t\t\ta[i] = { c,v };\n\t\t}\n\t\trrep(i, q) {\n\t\t\tif (a[i].first == 'M')m[a[i].second - 1] = 0;\n\t\t\telse {\n\t\t\t\tint v = a[i].second - 1;\n\t\t\t\twhile (!m[v = mv[uf.find(v)]])uf.unite(v, T[v]), mv[uf.find(v)] = mv[uf.find(T[v])];\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n\n// 并?集相?数据与算法\n#define MAX_N 100000 + 16\nint parent[MAX_N];\nint height[MAX_N];\n\nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n\n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n\nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n// End Of 并?集\n\n// 原始的?用它来描述\nvector<int> children[MAX_N];\nint parent_tree[MAX_N];\nbool marked[MAX_N];\nint ancestor[MAX_N];\n// ?条指令被拆分? 操作 + 目?\nstack<char> operation;\nstack<int>  target;\n\nvoid bfs(int index, int the_ancestor)\n{\n\tqueue<int> q_index;\n\tqueue<int> q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile (!q_index.empty())\n\t{\n\t\tthe_ancestor = q_ancestor.front(); q_ancestor.pop();\n\t\tindex = q_index.front(); q_index.pop();\n\t\tif (marked[index] == true)\n\t\t{\n\t\t\tthe_ancestor = index;\n\t\t}\n\t\tancestor[index] = the_ancestor;\n\t\tfor (vector<int>::iterator it = children[index].begin(); it != children[index].end(); ++it)\n\t\t{\n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\n\tint N, Q;\n\twhile (cin >> N, cin >> Q, N)\n\t{\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i] = false;\n\t\t}\n\t\tmarked[0] = true;\n\t\tint p;\n\t\tfor (int i = 1; i < N; ++i)\n\t\t{\n\t\t\tcin >> p; --p;\n\t\t\tparent_tree[i] = p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i)\n\t\t{\n\t\t\tchar o;\n\t\t\tint t;\n\t\t\tcin >> o >> t; --t;\n\t\t\tif (o == 'M')\n\t\t\t{\n\t\t\t\tif (marked[t])\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmarked[t] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperation.push(o);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(0, 0);\n\t\tinit(N);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tunite(i, ancestor[i]);\n\t\t}\n\t\tunsigned long long result = 0;\n\t\twhile (!operation.empty())\n\t\t{\n\t\t\tchar o = operation.top(); operation.pop();\n\t\t\tint t = target.top(); target.pop();\n\t\t\tif (o == 'Q')\n\t\t\t{\n\t\t\t\tresult += ancestor[find(t)] + 1;\t// ?目index从1?始\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// ?行“反染色”操作，之后?个?点的祖先??其父?点的祖先\n\t\t\t\tint p = ancestor[find(parent_tree[t])];\n\t\t\t\tunite(t, parent_tree[t]);\n\t\t\t\tancestor[find(t)] = p;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    HeavyLightDecomposition(int n_ = 0) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\nint n,q;\nchar qt[100010];\nint qv[100010];\nHeavyLightDecomposition h;\n\nlong long solve(){\n    long long ans = 0;\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&n,&q) , n){\n        h = HeavyLightDecomposition(n);\n        rep(i,n-1){\n            int par;\n            scanf(\"%d\", &par);\n            h.addEdge(par-1,i+1);\n        }\n        rep(i,q){\n            scanf(\"%s%d\", qt+i, qv+i);\n            qv[i]--;\n        }\n        cout << solve() << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//?????¨????????????, UnionFind, ?????????. [Q v?????????]??§???????????°???????????????????????¨, ?????°????????????marked???1????????¨???????????¨?????????.\n#include <iostream>\n#define int long long\nusing namespace std;\n\nclass UF {\n\tint par[100001];\npublic:\n\tvoid init(int n) { for (int i = 0; i < n; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid marge(int x, int y) { par[x] = y; }\n};\n\nint n, q;\nint parent[100000];\npair<char, int> query[100000];\nbool is_marked[100000];\nUF uf;\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) { is_marked[i] = false; }\n\tuf.init(n);\n}\n\nsigned main() {\n\tint i;\n\t\n\twhile (cin >> n >> q) {\n\t\tif (!n) break;\n\t\tinit(n);\n\t\t\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tcin >> parent[i];\n\t\t\tparent[i]--;\n\t\t}\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tcin >> query[i].first >> query[i].second;\n\t\t\tquery[i].second--;\n\t\t\tif (query[i].first == 'M') {\n\t\t\t\tis_marked[query[i].second] = true;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tif (!is_marked[i]) {\n\t\t\t\tuf.marge(i, parent[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (i = q - 1; i >= 0; i--) {\n\t\t\tint v = query[i].second;\n\t\t\tif (query[i].first == 'M') {\n\t\t\t\tuf.marge(v, parent[v]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.root(v) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <ctime>\n#include <assert.h>\n\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define eps 1e-8\n#define M_PI 3.141592653589793\n\ntypedef long long ll;\nconst ll mod=1000000007;\nconst int inf=0x7fffffff;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nusing namespace std;\nint f[100010],v[100010],n,m;\nvoid init()\n{\n    memset(v,0,sizeof(v));\n    v[1]=1;\n    for(int i=1;i<=n;i++) f[i]=i;\n}\nint Fnd(int x)\n{\n    if(!v[x]) x=Fnd(f[x]);\n    else return x;\n}\n\nint Find(int x)\n{\n   return Fnd(f[x]);\n}\nvoid Merge(int x,int y)\n{\n    f[y]=x;\n}\n\nint main()\n{\n   while(scanf(\"%d%d\",&n,&m)&&n&&m){\n       init();\n       for(int i=2;i<=n;i++){\n          int x;scanf(\"%d\",&x);\n          Merge(x,i);\n       }\n       int ans=0;\n       for(int i=1;i<=m;i++){\n          char c;int a;\n          scanf(\"\\n%c%d\",&c,&a);\n          getchar();\n          if(c=='Q'){\n            ans+=Find(a);\n          }\n          else if(c=='M'){\n              v[a]=1;\n          }\n       }\n       printf(\"%d\\n\",ans);\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nstruct query{\n    char type;\n    int p , flag;\n};\nint par[100001];\nvoid init(int n){\n    par[1] = 1;\n    for(int i = 2;i <= n;i++){\n        std::cin >> par[i];\n    }\n}\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\nvoid unite(int x , int y){\n    par[x] = y;\n}\nint main(){\n    int n , q;\n    while(std::cin >> n >> q){\n        if(n == 0 && q == 0){\n            break;\n        }\n        init(n);\n\n        std::vector<query> vec;\n        for(int i = 0;i < q;i++){\n            query q1;\n            std::cin >> q1.type >> q1.p;\n            if(q1.type == 'M'){\n                q1.flag = par[q1.p];\n                par[q1.p] = q1.p;\n            }\n            vec.push_back(q1);\n        }\n\n        long long int sum = 0;\n        for(int i = q - 1;i >= 0;i--){\n            if(vec[i].type == 'Q'){\n                sum += (long long int)find(vec[i].p);\n            }else{\n                unite(vec[i].p , vec[i].flag);\n            }\n        }\n        std::cout << sum << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(long i=0; i<(n); i++)\n#define dmp(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nbool m[100000];\nlong a[100000];\nchar com[100000];\nlong d[100000];\n\nlong long calc(int n)\n{\n  if(m[n])\n    return n;\n  else\n    return calc(a[n]);\n}\n\nint main()\n{\n  int N,Q;\n  while(scanf(\"%d %d\", &N, &Q),N+Q){\n    for(int i=2;i<N+1;i++){\n      scanf(\"%ld\",a+i);\n    }\n    m[1]=true;\n    rep(i,Q){\n    scanf(\" %c %ld\", com+i,d+i);\n    }\n    \n    long long ret=0;\n    \n    rep(i,Q) switch(com[i]) {\n    case 'M':\n      m[d[i]]=true;\n      break;\n    case 'Q':\n      ret += calc(d[i]);\n    }\n    printf(\"%lld\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nbool marked[100000];\nint prt[100000];\n\nint gm(int i) {\n  if (marked[i]) return i;\n  return prt[i] = gm(prt[i]);\n}\n\nint main() {\n  while(1) {\n    int n,q;\n    cin>>n>>q;\n    if(!n) break;\n    REP(i,n)marked[i]=false;\n    marked[0] = true;\n    REP(i,n-1) {\n      cin>>prt[i+1];\n      --prt[i+1];\n    }\n    vector<tuple<int,int>> ql;\n    REP(i,q){\n      string c;\n      int v;\n      cin>>c>>v;\n      --v;\n      if (c==\"M\") {\n        if (marked[v]) continue;\n        marked[v] = true;\n      }\n      ql.emplace_back(c==\"Q\"?1:0, v);\n    }\n    reverse(begin(ql),end(ql));\n    int64_t sum = 0;\n    REP(i,ql.size()){\n      int c,v;\n      tie(c,v) = ql[i];\n      if(c)\n        sum += gm(v) + 1;\n      else\n        marked[v] = false;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nint mark[100010], parent[100010];\n\nint nma[100010];\nint find(int x){\n\tif(nma[x] == x)return x;\n\treturn nma[x] = find(nma[x]);\n}\n// x >= y\nvoid unite(int x, int y){\n\tnma[y] = find(x);\n}\n\nchar type[100010];\nint v[100010];\n\nint main(){\n\tint N, Q;\n\twhile(cin >> N >> Q, N | Q){\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcin >> parent[i];\n\t\t}\n\n\t\tmemset(mark, 0, sizeof(mark));\n\t\tmark[1] = 1;\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tcin >> type[i] >> v[i];\n\t\t\tif(type[i] == 'M'){\n\t\t\t\t++mark[v[i]];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tnma[i] = i;\n\t\t}\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(mark[i] == 0){\n\t\t\t\tunite(parent[i], i);\n\t\t\t}\n\t\t}\n\n\t\tll res = 0;\n\t\tfor(int i=Q-1;i>=0;i--){\n\t\t\tif(type[i] == 'M'){\n\t\t\t\t--mark[v[i]];\n\t\t\t\tif(mark[v[i]] == 0){\n\t\t\t\t\tunite(parent[v[i]], v[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres += find(v[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << res << endl;\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint pre[100001], n, q;\nbool book[100001];\n\nint find(int x){\n\twhile (!book[pre[x]]) x = pre[x];\n\treturn pre[x];\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%d\", &n, &q)){\n\t\tif (!n && !q)return 0;\n\t\tlong long sum = 0;\n\t\tmemset(book, 0, sizeof book);\n\t\tbook[1] = true;\n\t\tfor (int i = 2; i <= n; ++i)scanf(\"%d\", &pre[i]);\n\t\twhile (q--){\n\t\t\tchar ch;\n\t\t\tint num;\n\t\t\tcin >> ch;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tif (ch == 'Q'){\n\t\t\t\tif (book[num])sum += num;\n\t\t\t\telse sum += find(num);\n\t\t\t}\n\t\t\telse book[num] = true;\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nclass UF{\n\tvector<int> par, rank;\npublic:\n\tUF(int n): par(n + 1), rank(n + 1) {\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn x != par[x] ? par[x] = find(par[x]) : x;\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y){\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\t++rank[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint par[100001], root[100001], qv[100001];\nchar qc[100001], con[100001];\n\nint main(){\n\tint n, q;\n\twhile(scanf(\"%d%d\", &n, &q), n){\n\t\tmemset(con, 1, sizeof con);\n\n\t\tfor(int i = 2; i <= n; ++i){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\troot[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\" %c%d\", &qc[i], &qv[i]);\n\t\t\tif(qc[i] == 'M'){\n\t\t\t\tcon[qv[i]] = 0;\n\t\t\t}\n\t\t}\n\n\t\tUF u(n);\n\t\tfor(int i = 2; i <= n; ++i){\n\t\t\tif(con[i]){\n\t\t\t\troot[u.find(i)] = root[u.find(par[i])];\n\t\t\t\tu.unite(i, par[i]);\n\t\t\t}\n\t\t}\n\n\t\tlong long ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i){\n\t\t\tif(qc[i] == 'M'){\n\t\t\t\troot[u.find(qv[i])] = root[u.find(par[qv[i]])];\n\t\t\t\tu.unite(qv[i], par[qv[i]]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += root[u.find(qv[i])];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool markd[100010];\nvoid init(int v){\n\tfor(int i = 1;i <=n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t\tmarkd[i] = false;\n\t}\n\tmarkd[1] = true;\n}\n\nint find(int x){\n\tif(markd[x]){\n\t\treturn x;\n\t}\n\tif(par[x]==x){\n\t\treturn x;\n\t}\n\treturn par[x] = find(par[x]);\n}\nvoid unit(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x!=y){\n\t\tpar[y] = x;\n\t}\n\treturn;\n}\n\nint main(){\n\twhile(cin>>n>>q,n||q){\n\t\tinit(n);\n\t\tint sum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] = a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='M'){\n\t\t\t\tmarkd[k] = true;\n\t\t\t}else{\n\t\t\t\tsum +=find(par[k]);\n\t\t\t}\n\t\t}\n\t\tcout <<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\tint t;\n\t\trep(i, n-1) {\n\t\t\tcin >> t; t--;\n\t\t\tpar0[i + 1] = t;\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\nstruct Node {\n    int par;\n    vi cs;\n    Node(int p, vi const& cs) : par(p), cs(cs) {}\n    Node(){}\n};\n\nvi ansester;\nvi marked;\n\nvoid update(vector<Node> & g, int v, int a){\n    ansester[v] = a;\n    for(int c : g[v].cs) if(!marked[c]) update(g,c,a);\n}\n\nint solve(vector<Node> & g, vector<pair<char,int>> & query){\n    ansester.assign(g.size()+1, 1);\n    marked.assign(g.size()+1, 0);\n    int ans = 0;\n    for(auto & p : query){\n        char q; int v;\n        tie(q,v) = p;\n        if(q=='M'){\n            update(g,v,v);\n            marked[v] = true;\n        } else {\n            ans += ansester[v];\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    int N, Q;\n    while(cin>>N>>Q && N){\n        vector<Node> g(N+1);\n        rep(i,N-1){\n            int x; cin>>x;\n            g[i+2].par = x;\n            g[x].cs.eb(i+2);\n        }\n        vector<pair<char,int>> query(Q);\n        rep(i,Q){\n            char c; int v;\n            cin >> c >> v;\n            query[i] = mp(c,v);\n        }\n        cout << solve(g,query) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n);\n\t\trep(i, n-1) {\n\t\t\tcin >> par[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tint marked[100001] = {}; marked[0] = 1;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\tll out = 0;\n\t\trep(i,n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>  \n#include<iostream>  \n#define min(a, b) a < b ? a : b \nusing namespace std;  \n  \nconst int INF = 0x7f7f7f7f;  \nconst int MAXN = 1e5 + 111;  \n  \nint p[MAXN];  \nint qt[MAXN], qv[MAXN], mark[MAXN];  \nint t;  \n  \nint find(int x) {  \n    return mark[x] < t ? x : p[x] = find(p[x]); // ?°?????????´?????¨??\\??¢???????????????????¢????  \n}  \n  \nint main()  \n{  \n    int n, q, i;  \n    while (~scanf(\"%d%d\", &n, &q) && (n | q)) {  \n        for (i = 2; i <= n; ++i) {  \n            scanf(\"%d\", p + i);  \n            mark[i] = INF;  \n        }  \n  \n        int cnt = 0, x;  \n        char op[2];  \n        for (i = 1; i <= q; ++i) {  \n            scanf(\"%s%d\", op, &x);  \n            if (op[0] == 'M') mark[x] = min(mark[x], i); // ??°?????????????????¶??´  \n            else {  \n                qt[cnt] = i;  \n                qv[cnt++] = x;  \n            }  \n        }  \n  \n        long long ans = 0;  \n        while (cnt --) {  \n            t = qt[cnt]; // ??\\??¢???????????¶??´  \n            ans += find(qv[cnt]);  \n        }  \n        printf(\"%lld\\n\", ans);  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 0\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tif(maxi>=0&&maxi<(ll)idx_rev.size()) ret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\nconst int maxn = 5e5+5;\nint n,m;\nint far[maxn];\nint Rank[maxn];\nint find(int x){\n\tif(far[x] == x)return x;\n\telse return find(far[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\t\n\tif(Rank[x] < Rank[y]) far[x] = y;\n\telse\n\t{\n\t\tfar[y] = x;\n\t\tif(Rank[x] == Rank[y]) Rank[x]++;\n\t}\n}\nbool check(int x,int y){\n\treturn find(x) == find(y);\n}\nvoid init(int n){\n\tfor(int i = 0;i <= n;i++)\n\t{\n\t\tfar[i] = i;\n\t\t//Rank[i] = 0;\n\t}\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d\",&n,&m) &&(m||n))\n\t{\n\t\tinit(n);\n\t\tint a;\n\t\tlong long ans = 0;\n\t\tfor(int i = 2;i <= n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&far[i]);\n\t\t}\n\t\tchar c[3];\n\t\tfor(int i = 0;i <m;i++)\n\t\t{\n\t\t\tscanf(\"%s %d\",c,&a);\n\t\t\tif(c[0] == 'M') far[a] = a;\n\t\t\telse  \n\t\t\t{\n\t\t\t\tans += find(a);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nAOJ 2170 Marked Ancestor\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\nint isMarked[MAXN];\nvector<vector<int> >tree;\nint N, Q;\n\nstruct OPER{\n    char s[2];\n    int p;\n    bool input(){\n        scanf(\"%s%d\", s, &p);\n        if(s[0] == 'M'){\n            if(isMarked[p]) return false;\n            else {isMarked[p] = true ; return true;}\n        }\n        else return true;\n    };\n}op[MAXN];\n\n\n\nint uset[MAXN];\nint rank[MAXN];\n\nclass UnionSet{\npublic:\n    void Init(int n){\n        for(int i=1; i<=n; ++i){\n            uset[i] = i; rank[i] = 0;\n        }\n    }\n    int Find(int x)\n    {\n        if(x == uset[x]) return x;\n        else {\n            int fx = uset[x];\n            uset[x] = Find(fx);\n            return uset[x];\n        }\n    }\n    bool Union(int x, int y) //x and y are different\n    {\n        int fx = Find(x), fy = Find(y);\n        if(fx == fy) return false;\n        if(rank[fx] > rank[fy])\n            uset[fy] = fx;\n        else{\n            uset[fx] = fy;\n            if(rank[fx] == rank[fy]) rank[fy]++;\n        }\n        return true;\n    }\n\n};\n\nUnionSet us;\n\n\nvoid dfs(int r, int pa)\n{\n    for(int i=0; i<tree[r].size(); i++){\n        int x = tree[r][i];\n        if(isMarked[x]) dfs(x, x);\n        else dfs(x, pa);\n    }\n    us.Union(r, pa);\n}\n\n\nbool read()\n{\n    scanf(\"%d%d\", &N, &Q);\n    if(N==0&&Q==0) return false;\n    us.Init(N);\n    memset(isMarked, 0, sizeof(isMarked));\n    tree.clear();\n    tree.resize(N+1);\n    parent[1] = 1;\n    for(int i=2; i<=N; ++i){\n        scanf(\"%d\", &parent[i]);\n        tree[parent[i]].push_back(i);\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int q=0; q<Q; ++q){\n        bool f = op[q].input();\n        if(!f) --q, --Q;\n    }\n    dfs(1, 1);\n    long long sum = 0;\n    for(int q=Q-1; q>=0; --q){\n        int v = op[q].p;\n        if(op[q].s[0] == 'M'){\n            us.Union(v, parent[v]);\n        }\n        else {\n            sum += us.Find(v);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n}\n\nint main()\n{\n    while(read()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvector<int> vertexs[200000];\nint back[200000];\nvoid dfs(int now) {\n    for (auto x : vertexs[now]) {\n        back[x] = now;\n        dfs(x);\n    }\n}\nint color[200000];\nint union_tree[200000];\nint union_find(int a) {\n    if (union_tree[a] == a) return a;\n    return union_tree[a] = union_find(union_tree[a]);\n}\nvoid solve(){\n    while (true) {\n        int n, query;\n        cin >> n >> query;\n        if (n == 0) return;\n        REP(i, n + 1) {\n            vertexs[i].clear();\n            color[i] = 1e9;\n        }\n        REP(i, n - 1) {\n            int a;\n            cin >> a;\n            a--;\n            vertexs[a].push_back(i + 1);\n        }\n        dfs(0);\n        vector<pair<int, int>>inputs;\n        REP(i, query) {\n            string a;\n            int b;\n            cin >> a >> b;\n            b--;\n            if (a == \"Q\") {\n                inputs.push_back(mp(0, b));\n            }\n            else {\n                color[b] = min(color[b], i);\n                inputs.push_back(mp(1, b));\n            }\n        }\n        REP(i, n) {\n            union_tree[i] = i;\n            if (color[i] == 1e9) {\n                union_tree[i] = back[i];\n            }\n        }\n        int ans = 0;\n        for (int q = query - 1; q >= 0; --q) {\n            if (inputs[q].first == 1) {\n                if (color[inputs[q].second] == q) {\n                    color[inputs[q].second] = 1e9;\n                    union_tree[inputs[q].second] = back[inputs[q].second];\n                }\n            }\n            else {\n                ans += union_find(inputs[q].second) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1<<29)\n\nstruct SegmetTree {\n    int n, dat[2*MAX-1];    \n    \n    SegmetTree(int n_, vector<int> &d)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = 1;\n        }\n    }\n\n    void update(int k, int a)\n    {\n        k += n - 1;\n        dat[k] = max(dat[k], a);\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    \n    int get_max(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return -INF;\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            int vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n            int vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }    \n};\n\nint child[MAX];\nvector<int> G[MAX], vec;\n\nvoid init(int N)\n{\n    vec.clear();\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n        child[i] = 0;\n    }\n}\n\nint dfs(int v)\n{\n    int c = 0;\n    vec.push_back(v);\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        c += dfs(G[v][i]) + 1;\n    }\n    return (child[v] = c);\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0);\n\n        vector<int> num(N);\n        for (int i = 0; i < (int)vec.size(); i++) {\n            num[vec[i]] = i;\n        }\n        \n        SegmetTree st(N, vec);\n        \n        char m;\n        int v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.update(num[v], v + 1);\n                for (int i = num[v] + 1; i <= num[v] + child[v]; i++) {\n                    st.dat[i+st.n-1] = max(st.dat[i+st.n-1], v+1);\n                }\n            } else {\n                int n = num[v];\n                res += st.get_max(n, n + child[v] + 1, 0, 0, st.n);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<limits.h>\n#include<algorithm>\n#include<cstring>\n#include<math.h>\n#include<set>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stdlib.h>\n#include<time.h>\nusing namespace std;\ntypedef long long ll;\n#define inf\t1000000\ntypedef pair<int,int>\tP;\nconst int N=100010;\nint parent[N];\nbool marked[N];\nll sum;\nvoid init(int n){\n\tfor(int i=1;i<=n;i++){\n\t\tparent[i]=i;\n\t}\n\tmemset(marked,false,sizeof(marked));\n\tmarked[1]=true;\n}\n\nint find(int x){\n\tif(marked[x]){\n\t\treturn x;\n\t}else{\n\t\treturn find(parent[x]);\n\t}\n}\n\n\n\nint main() {\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)!=EOF){\n\t\tsum=0;\n\t\tif(n==0&&q==0){\n\t\t\tbreak;\n\t\t}\n\t\tinit(n);\n\t\tint x;\n\t\tchar str[2];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&parent[i]);\n\t\t}\n\t\twhile(q--){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='M'){\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tmarked[x]=true;\t\n\t\t\t}else if(str[0]=='Q'){\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tsum+=find(x);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par;\n\tUF() { par = vector<int>(um, 0); rep(i, 0, um) par[i] = i; }\n\tint operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n\tvoid operator()(int x, int y)\n\t{\n\t\tx = operator[](x); y = operator[](y);\n\t\tif (x > y)\n\t\t\tpar[x] = y;\n\t\telse\n\t\t\tpar[y] = x;\n\t}\n};\n\nint N, Q;\nvector<int> E[101010];\nint P[101010];\n\nchar O[101010];\nint V[101010];\n\nint marked[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> Q)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) E[i].clear();\n\t\trep(i, 0, N) marked[i] = 0;\n\n\t\tP[0] = -1;\n\t\trep(i, 1, N)\n\t\t{\n\t\t\tint p; cin >> p; p--;\n\t\t\tP[i] = p;\n\t\t\tE[i].push_back(p);\n\t\t\tE[p].push_back(i);\n\t\t}\n\n\t\tmarked[0] = 1;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> O[i] >> V[i];\n\t\t\tV[i]--;\n\t\t\tif(O[i] == 'M') marked[V[i]]++;\n\t\t}\n\t\t\n\t\tUF<101010> uf;\n\t\trep(i, 0, Q) if (marked[i])\n\t\t{\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tuf(q, i);\n\n\t\t\t\tfor (int to : E[q]) if (to != P[q]) if (!marked[to])\n\t\t\t\t{\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\n\t\tll ans = 0;\n\t\trrep(i, Q - 1, 0)\n\t\t{\n\t\t\tint v = V[i];\n\t\t\tif (O[i] == 'M')\n\t\t\t{\n\t\t\t\tmarked[v]--;\n\t\t\t\tif (marked[v] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (P[v] < 0) continue;\n\t\t\t\t\t//printf(\"[%d, %d]\\n\", P[v], v);\n\n\t\t\t\t\tint _min = min(uf[v], uf[P[v]]);\n\n\t\t\t\t\tuf(v, P[v]);\n\n\t\t\t\t\tif (_min != uf[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (ll)uf[V[i]] + 1;\n\t\t\t\t//cout << uf[V[i]] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nint main(){\n  while(1){\n    vector<node> T;\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    T.push_back((node){true,0,1});\n    for(int i=2;i<=n;i++){\n      int parent;\n      cin >> parent;\n      T.push_back((node){false,parent-1,i});\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }else{\n        node n = T[T[v-1].parent];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<long long int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<long long int> sizes;\n\n  UnionFind(long long int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    rep(i,n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  long long int find(long long int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(long long int x, long long int y) {\n    x = find(x);\n    y = find(y);\n\n    if (x == y) return;\n\n    par[y] = x;\n    sizes[x] += sizes[y];\n  }\n\n  bool same(long long int x, long long int y) {\n    return find(x) == find(y);\n  }\n\n  int size(long long int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\ta[1] = 1;\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\troots.insert(1);\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unite(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unite(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.find(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100016\n\nusing namespace std;\n\nint par[maxN], rank[maxN];\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, j, x;\n\t__int64 sum;\n\tchar c;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tfor (i = 2; i <= n; i++)\n\t\t\tscanf(\"%d\", &par[i]);\n\t\tgetchar();\n\t\tfor (i = sum = 0; i < t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'Q')\n\t\t\t\tsum += find(x);\n\t\t\telse\n\t\t\t\tpar[x] = x;\n\t\t}\n\t\tprintf(\"%I64d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @authors Bowen Chen (chenbowen9612@gmail.com)\n * @date    2016-11-04\n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <ctime>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <climits>\n#include <set>\n#include <stack>\n#include <queue>\n#include <sstream>\n#include <functional>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef map<string, int> MSI;\ntypedef map<int, int> MII;\ntypedef pair<int, int> PII;\ntypedef set<int> SI;\ntypedef long long LL;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-8;\n#define bitcount                    __builtin_popcount\n#define gcd                         __gcd\n#define F(i,n)                      for(int i=0;i<(n);++i)\n#define FOR(i,x,y)                  for(int i=(x);i<=(y);++i)\n#define FD(i,n)                     for(int i=(n-1);i>=0;--i)\n#define FORD(i,y,x)                 for(int i=(y);i>=(x);--i)\n#define MEM(x,i)                    memset(x,i,sizeof(x))\n#define mp                          make_pair\n#define db(a)                       cout<<(a)<<endl\n#define whatis(a)                   cout<<#a<<\" is \"<<a<<endl\n#define bug                         printf(\"\\nhere!!!\\n\")\n#define fi                          first\n#define se                          second\n#define pb                          push_back\n#define sz(a)                       ((int)(a.size()))\n#define SI(n)                       scanf(\"%d\",&(n))\n#define SII(a,b)                    scanf(\"%d%d\",&(a),&(b))\n#define SIII(a,b,c)                 scanf(\"%d%d%d\",&(a),&(b),&(c))\n#define SC(n)                       scanf(\"%c\",&(n))\n#define SF(n)                       scanf(\"%lf\",&(n))\n#define SFF(a,b)                    scanf(\"%lf%lf\",&(a),&(b))\n#define SS(n)                       scanf(\"%s\",(n))\n#define PI(n)                       printf(\"%d\\n\",(n))\n#ifdef LOCAL\n#define LLD                         \"%lld\"\n#else\n#define LLD                         \"%I64d\"\n#endif\n#define sl(n)                       scanf(LLD,&(n))\nconst int N = 100002;\nint n, m, par[N];\nbool marked[N];\n\nint main() {\n#ifdef LOCAL\n    freopen(\"in\", \"r\", stdin);\n    // freopen(\"out\", \"w\", stdout);\n#endif\n\twhile(SII(n, m) == 2 && n && m) {\n\t\tLL ans = 0;\n\t\tMEM(marked, 0);\n\t\tmarked[1] = true;\n\t\tpar[1] = 1;\n\t\tF(i, n) SI(par[i+2]);\n\t\tchar cmd; int x;\n\t\tF(i, m) {\n\t\t\tgetchar();\n\t\t\tSC(cmd); SI(x);\n\t\t\tif(cmd == 'M') marked[x] = true;\n\t\t\telse {\n\t\t\t\tif(marked[x]) ans += x;\n\t\t\t\telse {\n\t\t\t\t\twhile(!marked[par[x]]) x = par[x];\n\t\t\t\t\tans += par[x];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint p[100000], par[100000], t[100000];\nint find(int x) {\n\tif (x == par[x])return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tpar[find(x)] = find(y);\n}\nchar s[100000][2];\nint m[100000];\nint main() {\n\tint n, q;\n\twhile (scanf(\"%d%d\", &n, &q), n) {\n\t\trep(i, n)par[i] = i;\n\t\trep(i, n - 1)scanf(\"%d\", &p[i + 1]), p[i + 1]--;\n\t\tmemset(m, -1, sizeof(m)); m[0] = 0;\n\t\trep(i, q) {\n\t\t\tscanf(\"%s%d\", s[i], &t[i]); t[i]--;\n\t\t\tif (s[i][0] == 'M') {\n\t\t\t\tif (m[t[i]] == -1)m[t[i]] = i;\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (m[i] == -1)unite(i, p[i]);\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (m[t[i]] == i)unite(t[i], p[t[i]]);\n\t\t\tif (s[i][0] == 'Q')ans += find(t[i]) + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    marked[1]=true;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tif(marked[t[i]]) c[i]='E';\n\tmarked[t[i]]=true;\n      }\n    }\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M'&&t[i]!=1) marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n};\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nlong long solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  for (int i = 0; i < Q; i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n\n  tree = UnionFindTree(N);\n  for (int i = 0; i < N; i++) {\n    if (!marked[i]) tree.unite(parent[i], i);\n  }\n\n  long long res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n\n    marked = vector<bool>(N);\n    marked[0] = true;\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    int qnum = 0;\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (buf[0] == 'Q') {\n        queries[qnum++] = make_pair(true, n);\n      } else if (!marked[n-1]) {\n        marked[n-1] = true;\n        queries[qnum++] = make_pair(false, n);\n      }\n    }\n    Q = qnum;\n    queries.resize(Q);\n    long long ans = solve(N, Q, parent, queries);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nstruct node{\n    int id;\n    node* parent;\n    int h;\n    vector<node*> child;\n};\nbool com(node* n1,node* n2){\n    return n1->id<n2->id;\n}\nint main(){\n    int n,q,p;\n    while(cin>>n>>q,n){\n        vector<node*>vec;\n        vector<node*>marked;\n        node* no=new node;\n        no->id=1;\n        no->parent=no;\n        no->h=1;\n        vec.push_back(no);\n        marked.push_back(no);\n        for(int i=2;i<=n;i++){\n            cin>>p;\n            node* no=new node;\n            no->id=i;\n            no->parent=vec[p-1];\n            no->h=no->parent->h+1;\n            vec[p-1]->child.push_back(no);\n            vec.push_back(no);\n        }\n        int ans=0;\n        for(int i=0;i<q;i++){\n            char que;int num;\n            cin>>que>>num;\n            if(que=='M'){\n                marked.push_back(vec[num-1]);\n            }\n            else{\n                node* pa=vec[num-1]->parent;\n                int found=0;\n                while(true){\n                    int ma=0;\n                    sort(marked.begin(),marked.end(),com);\n                    if(binary_search(marked.begin(), marked.end(), pa, com)){\n                        ma=max(ma,pa->id);\n                        found=1;\n                    }\n                    if(found){\n                        ans+=ma;\n                        goto next;\n                    }\n                    if(pa->id==1){\n                        goto next;\n                    }\n                    pa=vec[pa->id]->parent;\n                }\n                \n            next:;\n            }\n        }\n        cout<<ans<<endl;;\n        vec.clear();\n        marked.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* vim: set st=2 sts=2 : */\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<char,int> P;\n\nint N,Q;\nint mark[100001];\nint tree[100001];\nP query[100001];\n\nint get(int i){\n  if(mark[i])return i;\n  return tree[i]=get(tree[i]);\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c%d\",&query[i].first,&query[i].second);\n      query[i].second--;\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second]+=1;\n      }\n    }\n\n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      if(query[i].first=='M'){\n        mark[query[i].second]-=1;\n      }else{\n        c+=get(query[i].second)+1;\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\n\n#include <cstdio>\n \nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nint parent[100010];\nbool marked[100010];\n\n// sky58\nstruct unionf{\n\tvector <int> data;\n\tunionf(int size):data(size,-1){}\n\tbool unions(int x,int y){\n\t\tx=root(x);y=root(y);\n\t\tif(x!=y){\n\t\t\tif(data[y]<data[x]){int d=x;x=y;y=d;}\n\t\t\tdata[x]+=data[y];data[y]=x;\n\t\t}\n\t\treturn x!=y;\n\t}\n\tbool finds(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tint root(int x){\n\t\treturn data[x]<0?x:data[x]=root(data[x]);\n\t}\n\tint find(int x){\n\t\treturn -data[x];\n\t}\n};\n\nint main(void) {\n\twhile(true) {\n\t\tint N, Q;\n\t\tscanf(\"%d\", &N);\n\t\tscanf(\"%d\", &Q);\n\t\t\n\t\tif ( N==0 ) { break; }\n\t\t\n\t\tmarked[1] = true;\n\t\tREP(i, N-1) {\n\t\t\tscanf(\"%d\", &parent[i+2]);\n\t\t\tmarked[i+2] = false;\n\t\t}\n\t\t\n\t\tlong long ret = 0;\n\t\tREP(i, Q) {\n\t\t\tchar met[256];\n\t\t\tint id;\n\t\t\tscanf(\"%s\", met);\n\t\t\tscanf(\"%d\", &id);\n\t\t\t\n\t\t\tif ( met[0] == 'Q' ) {\n\t\t\t\tint node = id;\n\t\t\t\twhile ( !marked[node] ) {\n\t\t\t\t\tnode = parent[node];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tret += node;\n\t\t\t} else {\n\t\t\t\tmarked[id] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <utility>\n\nusing namespace std;\n\nint N, Q;\npair<char, int> S[100000];\nint parent[100001];\nint set[100001];\n\nint findRoot(int p) {\n  int root = p;\n  while (set[root] != -1) {\n    root = set[root];\n  }\n  while (p != root) {\n    int t = set[p];\n    set[p] = root;\n    p = t;\n  }\n  return root;\n}\n\nvoid unionSet(int p, int q) {\n  int root1 = findRoot(p);\n  int root2 = findRoot(q);\n  if (root1 != root2) {\n    set[root1] = root2;\n  }\n}\n\nint main() {\n  //freopen(\"MarkedAncestor.in\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &Q) == 2 && !(N == 0 && Q == 0)) {\n    for (int i = 2; i <= N; ++i) {\n      scanf(\"%d\", &parent[i]);\n    }\n    set[1] = -1;\n    for (int i = 2; i <= N; ++i) {\n      set[i] = parent[i];\n    }\n    for (int i = 0; i < Q; ++i) {\n      char buf[10];\n      scanf(\"%s%d\", buf, &S[i].second);\n      S[i].first = buf[0];\n      if (S[i].first == 'M') {\n        set[S[i].second] = -1;\n      }\n    }\n    long long sum = 0;\n    // From back to front.\n    for (int i = Q - 1; i >= 0; --i) {\n      if (S[i].first == 'M') {\n        unionSet(S[i].second, parent[S[i].second]);\n      } else if (S[i].first == 'Q') {\n        int v = findRoot(S[i].second);\n        //printf(\"findRoot(%d) = %d\\n\", S[i].second, v);\n        sum += v;\n      }\n    }\n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//?????¨????????????, UnionFind, ?????????. [Q v?????????]??§???????????°???????????????????????¨, ?????°????????????marked???1????????¨???????????¨?????????.\n#include <iostream>\n#define int long long\nusing namespace std;\n\nclass UF {\n\tint par[100001];\npublic:\n\tvoid init(int n) { for (int i = 0; i < n; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid marge(int x, int y) { x = root(x); y = root(y); par[x] = y; }\t//x???????????????y???????????????\n};\n\nint n, q;\nint parent[100000];\npair<char, int> query[100000];\nbool is_marked[100000];\nUF uf;\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) { is_marked[i] = false; }\n\tuf.init(n);\n}\n\nsigned main() {\n\tint i;\n\t\n\twhile (cin >> n >> q) {\n\t\tif (!n) break;\n\t\tinit(n);\n\t\t\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tcin >> parent[i];\n\t\t\tparent[i]--;\n\t\t}\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tcin >> query[i].first >> query[i].second;\n\t\t\tquery[i].second--;\n\t\t\tif (query[i].first == 'M') {\n\t\t\t\tis_marked[query[i].second] = true;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tif (!is_marked[i]) {\n\t\t\t\tuf.marge(i, parent[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (i = q - 1; i >= 0; i--) {\n\t\t\tint v = query[i].second;\n\t\t\tif (query[i].first == 'M') {\n\t\t\t\tuf.marge(v, parent[v]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.root(v) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint par[MAX_N];\nint root;\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start){\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++){\n            if(used[child[start][i]]==0) dfs(child[start][i]);\n        }\n    }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        tmp.child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    tmp.used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if(a=='0' and b==0)break;\n        if (a=='Q') {\n            //cout<<\"as\"<<mark[b-1]<<endl;\n            ans+=tmp.mark[b-1];\n            ans++;\n        }\n        else {\n            root=b-1;\n            tmp.used[b-1]=1;\n            tmp.dfs(b-1);\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N), nma.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear(), nma.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass IN{\npublic:\n  char c;\n  int a;\n  IN(char c, int a):c(c),a(a){}\n};\n\nclass UF{\npublic:\n  vector<int> per;\n  void init(int n){\n    per = vector<int>(n+1);\n    rep(i,per.size())per[i]=i;\n\n  }\n  int find(int a){\n    if(per[a]==a)return a;\n    return per[a] = find(per[a]);\n  }\n  void uni(int a, int b){\n\n    a = find(a);\n    b = find(b);\n\n\n    if(a==b)return;\n    per[b] = a;\n  }\n  bool same(int a,int b){\n    return find(a)==find(b);\n  }\n  void print(){\n    reps(i,1,per.size())printf(\"%d \",per[i]);puts(\"\");\n  }\n  void fprint(){\n    reps(i,1,per.size())printf(\"%d \",find(i));puts(\"\");\n  }\n};\n\nint n,m;\nvector<int> tree;\nvector<IN> in;\n\nbool input(){\n  cin>>n>>m;\n  if(n==0)return false;\n  tree = vector<int>(n+1);\n  tree[1] = -1;\n\n  rep(i,n-1){\n    cin>>tree[i+2];\n  }\n  in.clear();\n\n  vector<int> check(n+1,0);\n  check[1]=1;\n  in.push_back(IN('M',1));\n  rep(i,m){\n    char c;\n    int a;\n    cin>>c>>a;\n    if(c=='M' && check[a]==1)continue;\n    check[a]=1;\n    in.push_back(IN(c,a));\n  }\n  return true;\n}\n\n\nUF uf;\n\nint solve(){\n  vector<IN> rev = in;\n  reverse(rev.begin(),rev.end());\n  uf.init(n);\n  vector<int> check(n+1,0);\n  rep(i,in.size()){\n    if(in[i].c=='M')check[in[i].a]=1;\n  }\n\n  reps(i,1,n+1){\n    if(check[i]==0)uf.uni(tree[i], i);\n  }\n  \n  int ret = 0;\n  rep(i,rev.size()){\n\n    if(rev[i].c=='Q'){\n      ret += uf.find(rev[i].a);\n    }else{\n      uf.uni(tree[rev[i].a], rev[i].a);\n    }\n    //uf.fprint();\n  }\n  return ret;\n}\n\nint main(){\n  while(input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int maxn = 100000 + 5;\ntypedef long long ll;\n\nint par[maxn], n, q;\nbool marked[maxn];\n\nint ancestor(int x)\n{\n\twhile(par[x] != x && !marked[x])\tx = par[x];\n\treturn x;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d\", &n, &q))\n\t{\n\t\tif(n == 0 && q == 0)\tbreak;\n\t\tmemset(marked, 0, sizeof(marked));\n\t\tfor(int i = 1; i <= n; i++)\tpar[i] = i;\n\n\t\tint p;\tmarked[1] = true;\n\t\tfor(int i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &p);\n\t\t\tpar[i] = p;\n\t\t}\n\n\t\tchar op;\tint x;\n\t\tll ans = 0;\n\t\twhile(q--)\n\t\t{\n\t\t\tscanf(\"\\n%c%d\", &op, &x);\n\t\t\tif(op == 'M')\tmarked[x] = true;\n\t\t\telse\t\t\tans += ancestor(x);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int N=100010;\nint n,Q;\nint Mark[N],fa[N];\nint ans;\nstruct node{\n\tint fir,sec;\n};\nnode Opt[N];\nint Find(int x){\n\tif(fa[x]==x||Mark[x]) return x;\n\tfa[x]=Find(fa[x]);\n\treturn fa[x];\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&Q);\n\t\tif(!n&&!Q) break;\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(Mark,0,sizeof(Mark));\n\t\tfa[1]=1;\n\t\tMark[1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&fa[i]);\n\t\t}\n\t\tfor(int i=1;i<=Q;i++){\n\t\t\tchar ID[10];\n\t\t\tint x;\n\t\t\tscanf(\"%s %d\",ID,&x);\n\t\t\tif(ID[0]=='Q') Opt[i]=(node){2,x};\n\t\t\telse{\n\t\t\t\tOpt[i]=(node){1,x};\n\t\t\t\tMark[x]++;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(int i=Q;i>=1;i--){\n\t\t\tif(Opt[i].fir==2) ans+=Find(Opt[i].sec);\n\t\t\telse Mark[Opt[i].sec]--;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Marked Ancestor????§£????????????????????????????????????????????????????????¨????????¨??¨??????????????§?????????????????????????????§??????????????????\n?????°???????????????????????????:1???????????????*/\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n,q;\nlong long par[100005];\nvector<long long> child[100005];\nqueue<P> mna;//marked nearest ancestor\nlong long mark[100005];\nlong long query[100005];\nlong long qquery[100005];\nlong long mnalist[100005];\nstring s;\nlong long ans;\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,100005)\n\t\t{\n\t\t\tmark[i]=0;\n\t\t\tquery[i]=0;\n\t\t\tqquery[i]=0;\n\t\t\tchild[i].clear();\n\t\t\tpar[i]=0;\n\t\t\tmnalist[i]=0;\n\t\t}\n\t\tans=0;\n\t\tcin>>n>>q;\n\t\tif(n==0)break;\n\t\trep(i,n-1)\n\t\t{\n\t\t\tcin>>par[i+1];\n\t\t\tpar[i+1]--;\n\t\t\tchild[par[i+1]].push_back(i+1);\n\t\t}\n\t\tmark[0]=1;\n\t\trep(i,q)\n\t\t{\n\t\t\tcin>>s>>qquery[i];\n\t\t\tqquery[i]--;\n\t\t\tif(s==\"M\")\n\t\t\t{\n\t\t\t\tquery[i]=1;\n\t\t\t\tmark[qquery[i]]++;\n\t\t\t}\n\t\t}\n\t\tmna.push(P(0,0));\n\t\tmnalist[0]=0;\n\t\twhile(!mna.empty())\n\t\t{\n\t\t\tP p=mna.front();mna.pop();\n\t\t\trep(i,child[p.first].size())\n\t\t\t{\n\t\t\t\tif(mark[child[p.first][i]]==1)\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=child[p.first][i];\n\t\t\t\t\tmna.push(P(child[p.first][i],child[p.first][i]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=p.second;\n\t\t\t\t\tmna.push(P(child[p.first][i],p.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long person;\n\t\tfor(long long kkk=q-1;kkk>=0;kkk--)\n\t\t{\n\t\t\tif(query[kkk]==1)\n\t\t\t{\n\t\t\t\tmark[qquery[kkk]]--;\n\t\t\t\tif(mark[qquery[kkk]]==0)mnalist[qquery[kkk]]=mnalist[par[qquery[kkk]]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tperson=mnalist[qquery[kkk]];\n\t\t\t\twhile(person!=mnalist[person])\n\t\t\t\t{\n\t\t\t\t\tperson=mnalist[person];\n\t\t\t\t}\n\t\t\t\tans+=(person+1);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n, q;\n\twhile (cin >> n >> q, n)\n\t{\n\t\tGraph g(n);\n\t\tREP(i, n-1)\n\t\t{\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\ta--;\n\t\t\tg[a].push_back(edge{ i + 1, 0 });\n\t\t}\n\t\tvi ans(n), mark(n);\n\t\tmark[0] = true;\n\t\tint sum = 0;\n\t\tREP(i, q)\n\t\t{\n\t\t\tchar c; int v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif (c == 'Q') sum += ans[v]+1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (mark[v]) continue;\n\t\t\t\tmark[v] = true;\n\t\t\t\tqueue<int> que;\n\t\t\t\tque.push(v);\n\t\t\t\twhile (que.size())\n\t\t\t\t{\n\t\t\t\t\tint t = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tans[t] = v;\n\t\t\t\t\tREP(j, g[t].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mark[g[t][j].to] == 1) continue;\n\t\t\t\t\t\tque.push(g[t][j].to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100016\n\nusing namespace std;\n\nint par[maxN], rank[maxN];\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, j, x;\n\tlong long sum;\n\tchar c;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tfor (i = 2; i <= n; i++)\n\t\t\tscanf(\"%d\", par + i);\n\t\tgetchar();\n\t\tfor (i = sum = 0; i < t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'Q')\n\t\t\t\tsum += find(x);\n\t\t\telse\n\t\t\t\tpar[x] = x;\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\nstatic const int N_MAX = 100010;\n//DEFINE UNION FIND\n\nint N;\nint parent[N_MAX];\nint Rank[N_MAX];\n\nvoid init()\n{\n    for(int i=0;i<N;i++)\n    {\n        parent[i] = i;\n        Rank[i] = 0;\n    }\n}\n\nint find(int x)\n{\n    if( parent[x] != x ) return find(parent[x]);\n    else return x;\n}\n\nvoid unite(int x, int y)\n{\n    int x_p = find(x);\n    int y_p = find(y);\n    if(x_p == y_p) return;\n    if( Rank[x_p] < Rank[y_p] )\n    {\n        parent[x_p] = y_p;\n    }\n    else\n    {\n        parent[y_p] = x_p;\n        if( Rank[x_p] == Rank[y_p] )\n        {\n            Rank[x_p]++;\n        }\n    }\n}\n\nbool same(int x, int y)\n{\n    return find(x) == find(y);\n}\n\n//END UNION_FIND\n\nint tree_parent[N_MAX];\nvector<int> tree_children[N_MAX];\nint tree_ancestor[N_MAX];\nbool tree_marked[N_MAX];\n\nvoid bfs(int r)\n{\n    int theAncestor = r;\n    int theIndex = r;\n\n    queue<int> trav_index;\n    queue<int> trav_ancestor;\n    trav_ancestor.push(theAncestor); trav_index.push(r);\n\n    while(!trav_index.empty())\n    {\n        theAncestor = trav_ancestor.front(); trav_ancestor.pop();\n        theIndex = trav_index.front(); trav_index.pop();\n\n        if(tree_marked[theIndex] == true)\n        {\n            theAncestor = theIndex;\n        }\n\n        tree_ancestor[theIndex] = theAncestor; //update\n        //染色?点的祖先就是它本身\n\n        //make its children follow its ancestor\n        for(auto i = tree_children[theIndex].begin();i!=tree_children[theIndex].end();i++)\n        {\n            trav_index.push(*i); trav_ancestor.push(theAncestor); //先??个祖先\n        }\n    }\n}\n\nvoid solve()\n{\n    int queryNums;\n    cin>>N>>queryNums;\n    init();\n\n    int p;\n    for(int i=2;i<=N;i++)\n    {\n        cin>>p;\n        tree_parent[i] = p;\n        tree_children[p].push_back(i);\n    }\n\n    stack<char> stackQueryChar; stack<int> stackQueryNum;\n    //先?行染色操作，其他的先不管，到最后在一次性来个BFS，避免TLE\n    char queryChar; int queryNum;\n    for(int i=0;i<queryNums;i++)\n    {\n        cin>>queryChar>>queryNum;\n        stackQueryChar.push(queryChar); stackQueryNum.push(queryNum);\n        if(queryChar == 'M')\n        {\n            tree_marked[queryNum] = true;\n        }\n    }\n\n    bfs(1);\n\n    for(int i=1;i<=N;i++)\n    {\n        unite(i,tree_ancestor[i]); //????着祖先\n    }\n    //之后?个并?集的老大是决定性因素了，它的祖先就是?并?集所有元素的祖先\n\n    //逆回来?理\n    int ans = 0;\n    while(!stackQueryChar.empty())\n    {\n        queryChar = stackQueryChar.top(); stackQueryChar.pop();\n        queryNum = stackQueryNum.top(); stackQueryNum.pop();\n        if(queryChar=='Q')\n        {\n            ans += tree_ancestor[find(queryNum)]; //加上那一?的老大的祖先\n        }\n        else //queryNum == 'M'\n        {\n            //?行逆向操作\n            //去掉染色的?点之后的祖先是它父?点的祖先，从而再更新那一?并?集所有元素的祖先\n            int newAncestor = tree_ancestor[tree_parent[queryNum]];\n            unite(queryNum,tree_parent[queryNum]); //合并??并?集\n            tree_ancestor[find(queryNum)] = newAncestor;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<vector<int> > parent;\nvector<bool> isgrandsonmarked;\n\nint main()\n{\n\twhile(1){\n\t\tint n, q;\n\t\tcin >> n >> q;\n\t\tif(n == 0) break;\n\t\tparent = vector<vector<int> >(n, vector<int>(20));\n\t\tparent[0][0] = 0;\n\t\tisgrandsonmarked = vector<bool>(n, false);\n\t\tisgrandsonmarked[0] = true;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\ttmp--;\n\t\t\tparent[i][0] = tmp;\n\t\t}\n\t\tfor(int i = 1; i < 20; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tparent[j][i] = parent[parent[j][i - 1]][i - 1];\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c == 'M'){\n\t\t\t\tint node = parent[v][0];\n\t\t\t\twhile(!isgrandsonmarked[node]){\n\t\t\t\t\tisgrandsonmarked[node] = true;\n\t\t\t\t\tnode = parent[node][0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint node = v;\n\t\t\t\tfor(int j = 19; j >= 0; j--){\n\t\t\t\t\tif(!isgrandsonmarked[parent[node][j]]){\n\t\t\t\t\t\tsum += (1 << j);\n\t\t\t\t\t\tnode = parent[node][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 100110;\ntypedef long long ll;\n\nstruct Node{\n    ll value = 1;\n    bool mark = 0;\n    int par = 1;\n}node[MAXN];\n\nll find(int v)\n{\n    return node[v].mark == 1 ? node[v].value : node[v].value = find(node[v].par);\n}\n\nint main() {\n    int n, q;\n    while(scanf(\"%d%d\", &n, &q) && n && q)\n    {\n        node[1].mark = 1;\n        for (int i = 2; i <= n; ++i)\n        {\n            int p;\n            scanf(\"%d\", &p);\n            node[i].par = p;\n        }\n        ll ans = 0;\n        for (int i = 0; i < q; ++i)\n        {\n            char op[2];\n            ll v;\n            scanf(\"%s %lld\",op, &v);\n            if (op[0] == 'Q')\n                ans += find(node[v].par);\n            else {\n                node[v].mark = 1;\n                node[v].value = v;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct node {int parent, mark;};\nnode N[100001];\n\nint find(int v) {\n\twhile(!N[v].mark) {\n\t\tv = N[v].parent;\n\t}\n\treturn v;\n}\n\nint main() {\n\tint n, q; ll ans;\n\tchar ope; int v;\n\twhile(1) {\n\t\tcin >> n >> q;\n\t\tif(!n&&!q) break;\n\t\tN[1].parent = 0; N[1].mark = 1;\n\t\tfor(int i=2; i<=n; ++i) {\n\t\t\tcin >> N[i].parent;\n\t\t\tN[i].mark = 0;\n\t\t}\n\t\tans = 0;\n\t\tfor(int i=0; i<q; ++i) {\n\t\t\tcin >> ope >> v;\n\t\t\tif(ope=='M') N[v].mark = 1;\n\t\t\tif(ope=='Q') ans += find(v);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> par, rank;\n\n    UnionFind(int n) {\n        rep(n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    int find(int x) {\n        return ((par[x] == x) ? x : par[x] = find(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n        return;\n    }\n\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nvoid dfs(ll node, ll marked_par, UnionFind uf, vector<bool> marked, vector<ll> children[]){\n    if(marked[node]) marked_par = node;\n    else uf.par[node] = marked_par;\n    for(ll child: children[node]){\n        dfs(child, marked_par, uf, marked, children);\n    }\n}\n\nint main() {\n    ll n,q,node;\n    char c;\n    cin >> n >> q;\n    while(n || q){\n        vector<ll> children[n+1], parent(n+1, 1);\n        ll ans = 0;\n        reppp(i, 2, n+1){\n            cin >> node;\n            children[node].push_back(i);\n            parent[i] = node;\n        }\n\n        vector<Pll> query(q);\n        vector<bool> marked(n+1, false);\n        rep(q){\n            cin >> c >> query[i].second;\n            query[i].first = (c=='Q'?1:0);\n            if(c == 'M') marked[node] = true;\n        }\n        UnionFind uf = UnionFind(n+1);\n        dfs(1, 1, uf, marked, children);\n        for(int i=q-1;i>=0;--i){\n            if(query[i].first){\n                ans += uf.find(node);\n            }else{\n                uf.unite(parent[node], node);\n            }\n        }\n        cout << ans << endl;\n        cin >> n >> q;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <fstream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-8;\nint INF = INT_MAX / 2;\n\nint main() {\n\tfor (;;) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (N == 0 && M == 0) break;\n\t\tvector<int> p(N);\n\t\tp[0] = -1;\n\t\tfor (int u = 1; u < N; u++) {\n\t\t\tcin >> p[u];\n\t\t\tp[u]--;\n\t\t}\n\t\tvector<char> c(M);\n\t\tvector<int> v(M);\n\t\tvector<int> t(N);\n\t\tt[0] = 1;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tstring s; cin >> s >> v[i];\n\t\t\tc[i] = s[0];\n\t\t\tv[i]--;\n\t\t\tif (c[i] == 'M') t[v[i]]++;\n\t\t}\n\t\tvector<int> a(N);\n\t\tfor (int u = 0; u < N; u++)\n\t\t\ta[u] = (t[u] ? u : p[u]);\n\t\tll ans = 0;\n\t\tfor (int i = M - 1; i >= 0; i--) {\n\t\t\tif (c[i] == 'M') {\n\t\t\t\tt[v[i]]--;\n\t\t\t\tif (t[v[i]] == 0)\n\t\t\t\t\ta[v[i]] = p[v[i]];\n\t\t\t}\n\t\t\tif (c[i] == 'Q') {\n\t\t\t\tint& u = a[v[i]];\n\t\t\t\tfor (; a[u] != u; u = a[u]);\n\t\t\t\tans += u + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\nint par[100001];\nint rank1[100001];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n);\n\t\trep(i, n-1) {\n\t\t\tcin >> par[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tint marked[100001] = {}; marked[0] = 1;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\tll out = 0;\n\t\trep(i,n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nvector<int> G[100001];\nint node_vals[100001];\n\nint dfs(int cur,int root){\n  for(int i=0;i<G[cur].size();i++){\n    int to = G[cur][i];\n    node_vals[to] = root;\n    dfs(to,root);\n  }\n}\n\nint main(){\n  int total_nodes;\n  int total_queries;\n  while(~scanf(\"%d %d\",&total_nodes,&total_queries)){\n    if(total_nodes == 0 && total_queries == 0) break;\n\n    fill(node_vals,node_vals+100001,1);\n\n    for(int node_idx = 2;node_idx-1<total_nodes;node_idx++){\n      int parent;\n      scanf(\"%d\",&parent);\n      G[parent].push_back(node_idx);\n    }\n    int sum = 0;\n    for(int query_idx=0;query_idx < total_queries; query_idx++){\n      char operation[2];\n      int node_val;\n      scanf(\"%s %d\",operation,&node_val);\n      if(operation[0] == 'M'){\n\tdfs(node_val,node_val);\n      }\n      else if(operation[0] == 'Q'){\n\tsum += node_vals[node_val];\n      }\n    }\n\n    printf(\"%d\\n\",sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nlong long pre[100005];\nlong long find_root(long long x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    long long n, q;\n    scanf(\"%lld%lld\", &n, &q);\n    pre[1] = 1;\n    for(long long i = 2;i <= n;i++)\n        scanf(\"%lld\", &pre[i]);\n    char a;\n    long long b;\n    long long ans = 0ll;\n    while(scanf(\" %c%lld\", &a, &b), a != '0')\n    {\n        if(a == 'Q')\n            ans += find_root(b);\n        else\n            pre[b] = b;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX_N 200000\nint par[MAX_N];\nint rank[MAX_N];\nint original_par[MAX_N];\nint query_list[MAX_N][2];\n\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    memset(marked_list,0,sizeof(int)*N);\n    //for(i=0;i<N;i++){ marked_list[i]=0; }\n    marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n        if(marked_list[query_list[i][1]]==1){\n          query_list[i][0]='N';\n        }\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nint anc[100000];\nint dpt[100000];\nint lnd[100000];\nint nea[100000];\nint chn[100000];\nint han[100000];\nint n;\nint nn;\n\nvector<vector<int> > decend;\n\nvoid calc(int pos, int depth, int land){\n  dpt[pos] = depth;\n  lnd[pos] = land;\n  if(depth % nn == 0) land = pos;\n  REP(i, decend[pos].size())\n    calc(decend[pos][i], depth + 1, land);\n}\n\nint dfs(int pos, int land){\n  // printf(\"dfs: %d %d\\n\", pos, land);\n  han[pos] = chn[land];\n  if(pos == land || nea[pos] == pos)\n    return pos;\n  return nea[pos] = dfs(anc[pos], land);\n}\n\nint query(int pos, int qid){\n  int land = lnd[pos];\n  int ans  = nea[pos];\n\n  // printf(\"query: %d %d (land = %d)\\n\", pos, qid, land);\n  // printf(\" han[pos] = %d, chn[land] = %d\\n\", han[pos], chn[land]);\n\n  if(han[pos] < chn[land]){\n    // update\n    int next = dfs(pos, land);\n    if(nea[next] == next){\n      return next;\n    }else{\n      return query(next, qid);\n    }\n  }\n\n  if(dpt[land] <= dpt[ans])\n    return ans;\n\n  return query(land, qid);\n}\n\nint main(){\n  int q;\n\n  while(scanf(\"%d%d\", &n, &q), n + q){\n    decend = vector<vector<int> >(n);\n\n    chn[0] = -1;\n    REP(i,n - 1){\n      scanf(\"%d\", &anc[i + 1]);\n      anc[i + 1]--;\n      nea[i] = 0;\n      decend[anc[i + 1]].push_back(i + 1);\n      chn[i] = -1;\n      han[i] = -1;\n    }\n\n    nn = (int)sqrt(n);\n    calc(0, 0, 0);\n\n    ll sum = 0;\n\n    REP(qq, q){\n      char buff[2];\n      int m;\n      scanf(\"%s%d\", buff, &m);\n      m--;\n\n      if(buff[0] == 'Q'){\n        // query\n        int ans = query(m, qq) + 1;\n        // printf(\"%d\\n\", ans);\n        sum += ans;\n      }else{\n        // marked\n        nea[m] = m;\n        chn[lnd[m]] = qq;\n      }\n    }\n\n    printf(\"%lld\\n\", sum);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\n// 集合にデータを入れたい時\ntemplate <class T> \nstruct UnionFind {\n  vector<int> data;\n  vector<T> val;\n  UnionFind(int size) : data(size, -1), val(size) {}\n  bool unionSet(int x, int y, T v) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n      val[x] = v;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  T &value(int x) {\n    return val[root(x)];\n  }\n};\n\nint p[100000];\nchar c[100000];int a[100000];\nbool v[100000];\n\nint main() {\n  int n,q;\n  while(cin>>n>>q,n||q) {\n    p[0] = -1;\n    REP(i,n-1) {\n      cin >> p[i+1];\n      p[i+1]--;\n    }\n    memset(v,0,sizeof(v));\n    v[0] = 1;\n    REP(i,q) {\n      cin >> c[i] >> a[i];\n      a[i]--;\n      if (c[i] == 'M') {\n        if (v[a[i]]) c[i] == '.';\n        else v[a[i]] = 1;\n      }\n    }\n    UnionFind<int> uf(n);\n    REP(i,n) {\n      if (!v[i]) {\n        uf.unionSet(i,p[i],p[i]);\n      }\n    }\n    ll ans = 0;\n    for (int i=q-1; i>=0; --i) {\n      if (c[i] == 'Q') {\n        ans += uf.value(a[i])+1;\n      } else if (c[i] == 'M') {\n        uf.unionSet(a[i],p[a[i]],uf.value(p[a[i]]));\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x]++ ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2017/12/27  Problem: AOJ 2170 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\t//if (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tLL root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n\n};\n// UnionFind uf(n); uf.unionSet(i,j); if(uf.same(x,y))\n\n\nLL N;\n\nLL ans = 0LL;\n\n\n\nint main() {\n\n\tint Q;\n\twhile (scanf(\"%d%d\", &N, &Q), N) {\n\n\t\tVI pre(N, 0);\n\t\tFOR(i, 0, N - 1) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\tv--;\n\t\t\tpre[i + 1] = v;\n\t\t}\n\t\tUnionFind uf(N);\n\t\tVI mark(N, 0);\n\t\tmark[0] = 1;\n\t\tvector<PII> qu;\n\t\tFOR(i, 0, Q) {\n\t\t\tchar c[3]; int v; scanf(\"%s%d\", c, &v);\n\t\t\tPII q;\n\t\t\tq.first = (c[0] == 'Q');\n\t\t\tv--;\n\t\t\tq.second = v;\n\t\t\tif (q.first == 0 && mark[v] == 0)mark[v] = 1,qu.push_back(q);\n\t\t\telse if (q.first == 1)qu.push_back(q);\n\t\t}\n\t\tFOR(i, 0, N) {\n\t\t\tif (mark[i] == 0)uf.unionSet(pre[i], i);\n\t\t\t//debug(uf.root(i));\n\t\t}\n\n\t\tans = 0;\n\t\tQ = SZ(qu);\n\t\tFORR(i, Q - 1, 0 - 1) {\n\t\t\tint v = qu[i].second;\n\t\t\tif (qu[i].first == 0) { // delete mark\n\t\t\t\tuf.unionSet(pre[v], v);\n\t\t\t\t//debug(uf.root(v));\n\t\t\t}\n\t\t\telse { // sum\n\t\t\t\tans += uf.root(v) + 1LL;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nbool flag[MAX_N];\nint ran[MAX_N];\nvoid init(int n) {\n\tfor(int i=2; i<=n; i++) {\t\t\n\t\tflag[i] = false;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif(flag[x])\n\t\treturn x;\n\telse\n\t\tfind(par[x]);\n}\n\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tlong long sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n//\t\tpar[1]= 1;\n\t\tflag[1] = true;\n\t\tinit(n);\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(par[p]);\n\t\t\t}else{\n\t\t\t\tflag[p] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n\n    if (rx < ry) par[ry] = rx;\n    else if (rx > ry) par[rx] = ry;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nvoid dfs(int idx, int par) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(par, idx);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par);\n  }\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  marked = vector<bool>(N);\n  marked[0] = true;\n  for (int i = 0; i < queries.size(); i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  tree = UnionFindTree(N);\n  dfs(0, -1);\n\n  int res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    int ans = solve(N, Q, parent, queries);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n\n    if (rx < ry) par[ry] = rx;\n    else if (rx > ry) par[rx] = ry;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\nvoid dfs(int idx, int par, vector<vector<int> >& G, vector<bool>& marked, UnionFindTree& tree) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(idx, par);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par, G, marked, tree);\n  }\n}\n\nint solve(int N, int Q, vector<vector<int> >& G, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  vector<bool> marked(N);\n  for (int i = 0; i < queries.size(); i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  UnionFindTree tree(N);\n  dfs(0, -1, G, marked, tree);\n\n  int res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(x, parent[x]);\n    } else {\n      res += tree.find(x) + 1;\n\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    vector<vector<int> > G(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    int ans = solve(N, Q, G, parent, queries);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par, rank;\n\tUF() { rank = vector<int>(um, 0); for (int i = 0; i<um; i++) par.push_back(i); }\n\tint operator[](int x) { return (par[x] == x) ? (x) : (par[x] = operator[](par[x])); }\n\tint operator()(int x, int y) {\n\t\tif ((x = operator[](x)) == (y = operator[](y))) return x;\n\t\tif (rank[x]<rank[y]) return par[x] = y;\n\t\trank[x] += rank[x] == rank[y]; return par[y] = x;\n\t}\n};\n\nint N, Q;\nvector<int> E[101010];\nint P[101010];\n\nchar O[101010];\nint V[101010];\n\nbool marked[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> Q)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) E[i].clear();\n\t\trep(i, 0, N) marked[i] = false;\n\n\t\tP[0] = -1;\n\t\trep(i, 1, N)\n\t\t{\n\t\t\tint p; cin >> p; p--;\n\t\t\tP[i] = p;\n\t\t\tE[i].push_back(p);\n\t\t\tE[p].push_back(i);\n\t\t}\n\n\t\tmarked[0] = true;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> O[i] >> V[i];\n\t\t\tV[i]--;\n\t\t\tif(O[i] == 'M') marked[V[i]] = true;\n\t\t}\n\t\t\n\t\tUF<101010> uf;\n\t\trep(i, 0, Q) if (marked[i])\n\t\t{\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tuf(i, q);\n\n\t\t\t\tfor (int to : E[q]) if (to != P[q]) if (!marked[to])\n\t\t\t\t{\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\n\t\tll ans = 0;\n\t\trrep(i, Q - 1, 0)\n\t\t{\n\t\t\tint v = V[i];\n\t\t\tif (O[i] == 'M')\n\t\t\t{\n\t\t\t\tif (P[v] < 0) continue;\n\t\t\t\tuf(v, P[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += uf[V[i]];\n\t\t\t\t//cout << uf[V[i]];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100005][2];\nchar q1[100005];\nint q2[100005];\nvector<int> vec[1000000];\n//vector<vector<int> > vec(1000000);\n//vec = vector < vector <int> >(1000000,vector<int>(100000,0)) ;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); ++it){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n//    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1<<29)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nstruct SegmetTree {\n    int n;\n    P dat[2*MAX-1];    \n    \n    SegmetTree(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = P(0, 1);\n        }\n    }\n\n    ll get_nearest_marked_node(int k)\n    {\n        k += n - 1;\n        P p = dat[k];\n        while (k > 0) {\n            k = (k - 1) / 2;\n            p = max(p, max(dat[k*2+1], dat[k*2+2]));\n        }\n        return p.second;\n    }\n        \n    void mark(int a, int b, int k, int l, int r, P x)\n    {\n        if (r <= a || b <= l) return;\n\n        if (a <= l && r <= b) {\n            dat[k] = max(dat[k], x);\n        } else {\n            mark(a, b, k * 2 + 1, l, (l + r) / 2, x);\n            mark(a, b, k * 2 + 2, (l + r) / 2, r, x);\n        }\n    }    \n};\n\nint L[MAX], R[MAX], D[MAX], p;\nvector<int> G[MAX];\n\nvoid init(int N)\n{\n    p = 0;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();        \n    }\n}\n\nvoid dfs(int v, int depth)\n{\n    L[v] = p++;\n    D[v] = depth;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        dfs(G[v][i], depth + 1);\n    }\n    R[v] = p;\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0, 0);\n\n        SegmetTree st(N);\n        \n        char m;\n        ll v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.mark(L[v], R[v], 0, 0, st.n, P(D[v], v+1));\n            } else {\n                res += st.get_nearest_marked_node(v);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n//      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector<vi> g(n);\n\t\tvi par(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].push_back(i+1);\n\t\t\tpar[i+1] = p;\n\t\t}\n\t\tll sum = 0;\n\t\tvector<pii> query;\n\t\tvi marked(n);\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tquery.emplace_back(1, v);\n\t\t\t}else{\n\t\t\t\tif(marked[v] == 0){\n\t\t\t\t\tmarked[v] = i+1;\n\t\t\t\t\tquery.emplace_back(0, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(n);\n\t\tqueue<int> que;\n\t\tque.push(0);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tif(marked[v] == 0) uf.unionSet(par[v], v);\n\t\t\tFOR(u, g[v]) que.push(*u);\n\t\t}\n\t\tRREP(i, query.size()){\n\t\t\tint v = query[i].second;\n\t\t\tif(query[i].first) sum += 1 + uf.root(v);\n\t\t\telse uf.unionSet(par[v], v);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  UnionFind(int n = 0): par(n, -1){}\n  int root(int x){\n    return par[x] < 0 ? x : par[x] = root(par[x]);\n  }\n  void unite(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return;\n    par[y] = x;\n  }\nprivate:\n  vector<int> par;\n};\n\nint n, q;\nint p[100000];\nstring t[100000];\nint v[100000];\nint m[100000];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  while (cin >> n >> q, n){\n    memset(m, 0, sizeof(m));\n    m[0]++;\n    UnionFind uf(n);\n    for (int i = 1; i < n; i++){\n      cin >> p[i], p[i]--;\n    }\n    for (int i = 0; i < q; i++){\n      cin >> t[i] >> v[i], v[i]--;\n      if (t[i] == \"M\") m[v[i]]++;\n    }\n    for (int i = 0; i < n; i++){\n      if (!m[i]) uf.unite(p[i], i);\n    }\n    int s = 0;\n    for (int i = q - 1; i >= 0; i--){\n      for (int j = 0; j < n; j++) cout << uf.root(j) << \" \";\n      cout << endl;\n      if (t[i] == \"M\"){\n        if (!--m[v[i]]){\n          uf.unite(p[v[i]], v[i]);\n        }\n      }\n      else s += uf.root(v[i]) + 1;\n    }\n    cout << s << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 0;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tset<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tll sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tif(lca.getDepth(v) - lca.getDepth(*u) == d)\n\t\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.insert(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, int>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), *u);\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tpii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v] < c) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tc.first ++;\n\t\t\t\t\tFOR(e, g[v]){\n\t\t\t\t\t\tif(chmin(res[e->first], c))\n\t\t\t\t\t\t\tque.emplace(c, e->first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){ // ?????????x?????????????????????????????????????????´??????\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    par[x] += par[y];\n    par[y] = x;\n    if(rank[x]==rank[y]) rank[x]++;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\n\nvector<vector<int> > tree;\nvector<int> par;\nbool marked[100005];\nbool mark_dup[100005];\n\nint main(){\n  int n,q;\n  while(cin>>n>>q, n|q){\n    tree = vector<vector<int> >(n, vector<int>());\n    par = vector<int>(n, 0);\n    repl(i,1,n){\n      int d;\n      scanf(\"%d\", &d);\n      d--;\n      tree[d].pb(i);\n      par[i] = d;\n    }\n\n    vector<char> qc(q); // query char\n    vector<int>  qi(q); // query int\n    rep(i,q) scanf(\" %c %d\", &qc[i], &qi[i]);\n    rep(i,q) qi[i]--;\n\n    // ??¨??????????????¨??¨?????????????????????\n    fill(marked, marked+n, false);\n    fill(mark_dup, mark_dup+q, false);\n    marked[0]=true;\n    rep(i,q) if(qc[i]=='M'){\n      if(marked[qi[i]]) mark_dup[i]=true;\n      else marked[qi[i]] = true;\n    }\n\n    // ??????????????????????????????????????¨?????????UnionFind??????\n    UnionFind uf = UnionFind(n);\n    rep(i,n) for(auto v : tree[i]){\n      if(!marked[v]) uf.unite(i,v);\n    }\n\n    // ?????¨???????????????????????????\n    long ans=0;\n    for(int i=q-1; i>=0; i--){\n      if(qc[i]=='M' && !mark_dup[i]){\n        uf.unite(par[qi[i]], qi[i]);\n      } else if(qc[i]=='Q'){\n        int x = qi[i];\n        if(uf.find(x) == x) x=par[x]; //??????????????§???????????????????????????\n        ans += (long)uf.find(x)+1;\n      }\n    }\n\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nlong long par[MAX_N+1];//parents\nlong long Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(long long n){\n\tfor(long long i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nlong long find(long long x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(long long x,long long y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(long long x, long long y){\n\treturn find(x) == find(y);\n}\n\nlong long N,Q;\nlong long sum = 0;\nlong long tree[MAX_N+1];\n\nlong long nearestAncstr(long long num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,long long num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nlong long num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\ttree[0] = 0;\n\tfor(long long i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tcin >>symbol >>num;num--;\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(true){\n\t\tif(symbol == '0' && num == 0)break;\n\t\toperate(symbol,num);\n\t\tcin >>symbol >>num;num--;\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\tcin >>N >>Q;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n      printf(\"4\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c;\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t\tmark[i] = maxN;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = nn = 1; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'M')\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i = nn - 1, sum = 0; i >= 1; i--)\n\t\t{\n\t\t\ttt = qt[i];\n\t\t\tsum += find(qx[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w[2];\n\n\twhile(cin>>n>>q&&n){\n\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d\",&z);z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\tcout<<\"#\"<<endl;\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tscanf(\"%s%d\",w,&z);z--;\n\n\t\tif(w[0]=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\telse{\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MAXN 110000\nint n,q,pa[MAXN],vis[MAXN];\nint main()\n{\n    pa[1]=1;\n    while (~scanf(\"%d%d\",&n,&q)&&(n||q))\n    {\n        for (int i=2;i<=n;i++) scanf(\"%d\",&pa[i]);\n        char s[3];\n        int id;\n        long long ans=0;\n        memset(vis,0,sizeof(vis));\n        vis[1]=1;\n        while (q--)\n        {\n            scanf(\"%s%d\",s,&id);\n            if (s[0]=='Q')\n            {\n                id=pa[id];\n                while (!vis[id]) id=pa[id];\n                ans+=id;\n            }\n            else vis[id]=1;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      //      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#define LL long long\nusing namespace std;\nconst int N = 100010;\nvector<int> edge[N];\nvector<int> mark[N], query[N];\nint n, m;\nint L(int x){return x << 1;}\nint R(int x){return x << 1 | 1;}\nstruct Tree{\n\tstruct node{\n\t\tint v;\n\t}tr[N << 2];\n\tvoid build(int a, int b, int x){\n\t\ttr[x].v = 0;\n\t\tif(a < b){\n\t\t\tint mid = a + b >> 1;\n\t\t\tbuild(a, mid, L(x));\n\t\t\tbuild(mid + 1, b, R(x));\n\t\t}\n\t}\n\tvoid update(int x){\n\t\ttr[x].v = max(tr[L(x)].v, tr[R(x)].v);\n\t}\n\tvoid modify(int x, int a, int b, int pos, int ad){\n\t\tif(a == b){\n\t\t\ttr[x].v = ad;\n\t\t\treturn;\n\t\t}\n\t\tint mid = a + b >> 1;\n\t\tif(pos <= mid) modify(L(x), a, mid, pos, ad);\n\t\telse modify(R(x), mid + 1, b, pos, ad);\n\t\tupdate(x);\n\t}\n\tint query(int x, int a, int b, int l, int r){\n\t\tif(l <= a && b <= r) return tr[x].v;\n\t\tint mid = a + b >> 1;\n\t\tif(r <= mid) return query(L(x), a, mid, l, r);\n\t\telse if(l > mid) return query(R(x), mid + 1, b, l, r);\n\t\telse return max(query(L(x), a, mid, l, r), query(R(x), mid + 1, b, l, r));\n\t}\n}sg;\n\nLL ans = 0;\nint list[N];\nvoid dfs(int u, int d){\n\tlist[d] = u;\n\t//for(int i = 0; i < query[u].size(); i ++){\n\t\tint _index = min(m, 50);\n\t\tans = ans + list[sg.query(1, 1, m, 1,  _index)];\n\t//}\n\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\tint _index = mark[u][i];\n\t\tsg.modify(1, 1, m, _index, d);\n\t}\n\tfor(int i = 0; i < edge[u].size(); i ++){\n\t\tint v = edge[u][i];\n\t\tdfs(v, d + 1);\n\t}\n\t//for(int i = 0; i < mark[u].size(); i ++){\n\t\tint _index = min(m, 50);\n\t\tsg.modify(1, 1, m, _index, 0);\n\t//}\n}\nvoid solve(){\n\tans = 0;\n\tfor(int i = 1; i <= n; i ++){\n\t\tedge[i].clear();\n\t\tquery[i].clear();\n\t\tmark[i].clear();\n\t}\n\tmemset(list, 0, sizeof(list));\n\tfor(int i = 2; i <= n; i ++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tedge[x].push_back(i);\n\t}\n\t\n\tmark[1].push_back(1);\n\tm ++;\n\tfor(int i = 2; i <= m; i ++){\n\t\tchar str[2];\n\t\tint v;\n\t\tscanf(\"%s%d\", str, &v);\n\t\tif(str[0] == 'Q') query[v].push_back(i);\n\t\telse mark[v].push_back(i);\n\t}\n\t\n\tsg.build(1, m, 1);\n\tdfs(1, 1);\n\t\n\tprintf(\"%lld\\n\", ans);\n}\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2 && n + m){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n//------- Union-Find木 ---------\nvector<int> par; // 親\n// 初期化\nvoid init(int n) {\n  par = vector<int>(n);\n  par[0] = 0;\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  par[x] = y;\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n//-------------------\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // ifstream cin (\"../test.txt\");\n  int N, Q;\n  while (1) {\n    cin >> N >> Q;\n    if (!(N | Q)) break;\n    init(N);\n    int a, i;\n    for (i = 1; i < N; i++) {\n      cin >> a;\n      par[i] = a - 1;\n    }\n    vector<pair<char, int> > query(Q);\n    char q;\n    for (i = 0; i < Q; i++) {\n      cin >> q >> a;\n      query[i] = make_pair(q, a);\n    }\n\n    // 先にマークする。つまり木を分離する。親となるノードを覚えておく。\n    // 同じノードに2回以上マークしている場合も考慮する。\n    map<int, int> ori_par;\n    map<int, int> ori_par_cnt;\n    for (i = 0; i < Q; i++) {\n      if (query[i].first == 'M') {\n        a = query[i].second - 1;\n        if (!ori_par_cnt.count(a)) {\n          ori_par[a] = par[a];\n          ori_par_cnt[a] = 1;\n          par[a] = a;\n        } else {\n          ori_par_cnt[a]++;\n        }\n      }\n    }\n\n    // クエリを後ろから処理する\n    int sum = 0;\n    reverse(query.begin(), query.end());\n    for (i = 0; i < Q; i++) {\n      a = query[i].second - 1;\n      if (query[i].first == 'Q') {\n        sum += find(a);\n      } else if (query[i].second == 'M') {\n        if (ori_par_cnt[a] == 1) {\n          unite(a, ori_par[a]);\n        } else {\n          ori_par_cnt[a]--;\n        }\n      }\n    }\n\n    // 出力\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else{\n    int a = query(t[v]);\n    t[v] = a;\n    return a;\n  }\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v]++;\n      qs.push_front(make_pair(order,v));\n    }\n\n    // printf(\"asdf %d\\n\",(int)qs.size());\n    // for(int i=0; i<qs.size(); i++){\n    //    printf(\"%c %d\\n\",qs[i].first,qs[i].second);\n    // }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second]--;\n    \n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\nset<int> s;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tmarked[t[i]]=true;\n\tif(s.find(t[i])==s.end()) s.insert(t[i]);\n\telse c[i]='E';\n      }\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M'&&t[i]!=1) marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100000+1109\n\nusing namespace std;\n\nchar ch[30];\nlong long n,m;\nlong long fa[MAXN];\nlong long a[MAXN],Q[MAXN];\nbool Is[MAXN];\nlong long Ans=0;\nlong long Mark[MAXN];\n\nlong long find(long long x)\n{\n\tif(fa[x]==x) return x;\n\tif(Is[x]==true) return x;\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid read();\nvoid work();\nvoid print();\n\nint main()\n\twhile(~scanf(\"%lld%lld\",&n,&m))\n\t{\n\t\tmemset(Is,0,sizeof(Is));\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(Mark,0,sizeof(Mark));\n\t\tAns=0;\n\t\tread();\n\t\twork();\n\t\tprint();\n\t}\n\treturn 0;\n}\n\nvoid read()\n{\n\t\n\tif(n==0&&m==0) exit(0);\n\tfa[1]=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tscanf(\"%lld\",&fa[i]);\n\tIs[1]=true;\n\tfor(long long i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%lld\",ch,&Q[i]);\n\t\tif(ch[0]=='Q') a[i]=1;\n\t\telse\n\t\t{\n\t\t\ta[i]=2,Is[Q[i]]=true;\n\t\t\tif(Mark[Q[i]]) continue;\n\t\t\tMark[Q[i]]=i;\n\t\t}\n\t}\n}\nvoid work()\n{\n\tfor(long long i=m;i;i--)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tif(Q[i]==1) continue;\n\t\t\tAns+=find(Q[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Mark[Q[i]]!=i) continue;\n\t\t\tIs[Q[i]]=false;\n\t\t}\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstruct union_find {\n    vector<int> data;\n    union_find(int size) : data(size, -1) {}\n    // merge x to y\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            data[y] += data[x];\n            data[x] = y;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : (data[x] = root(data[x]));\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nsigned main() {\n    while (1) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) break;\n\n        vector<vector<int>> ch(N);\n        vector<int> p(N);\n        REPF(i, 1, N) {\n            int v;\n            cin >> v;\n            v--;\n            p[i] = v;\n            ch[v].push_back(i);\n        }\n        vector<pair<char, int>> query(Q);\n        REP(i, Q) {\n            cin >> query[i].first >> query[i].second;\n            query[i].second--;\n        }\n        \n        union_find uf(N);\n        vector<bool> marked(N);\n        marked[0] = true;\n        REP(i, Q) {\n            if (query[i].first == 'M') marked[query[i].second] = true;\n        }\n\n        auto construct = [&](auto f, int v) -> void {\n            FORE(w, ch[v]) f(f, w);\n            if (!marked[v]) uf.unite(v, p[v]);\n        };\n        construct(construct, 0);\n\n        int ans = 0;\n        REPR(i, Q - 1) {\n            int v = query[i].second;\n            if (query[i].first == 'M') {\n                uf.unite(v, p[v]);\n            } else {\n                ans += uf.root(v) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n \nconst long INF = (1l << 30);\nconst long LINF = (1l << 60);\n\nlong p[100005];\nlong anc[100005];\nlong n, q, ans;\nlong query[100005][2];\nstd::set<long> st;\n\nlong root(long a){\n\tif(anc[a] == a){\n\t\treturn a;\n\t}else{\n\t\tlong ret = root(anc[a]);\n\t\tanc[a] = ret;\n\t\treturn ret;\n\t}\n}\n\nvoid solve(){\n\tans = 0;\n\tanc[1] = p[1] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tscanf(\"%ld\", p+i);\n\t\tanc[i] = p[i];\n\t}\n\tlong vis = 0;\n\tfor(int i = 0; i < q; i++){\n\t\tstd::string s;\n\t\tlong a;\n\t\tstd::cin >> s >> a;\n\t\tif(s == \"M\"){\n\t\t\tif(!st.count(a)){\n\t\t\t\tquery[vis][0] = 0;\n\t\t\t\tanc[a] = a;\n\t\t\t\tquery[vis][1] = a;\n\t\t\t\tvis++;\n\t\t\t\tst.insert(a);\n\t\t\t}\n\t\t}else{\n\t\t\tquery[vis][0] = 1;\n\t\t\tquery[vis][1] = a;\n\t\t\tvis++;\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < q; i++){\n\t\tprintf(\"%ld %ld\\n\", query[i][0], query[i][1]);\n\t}\n\t//*/\n\tstd::deque<long> deq;\n\tfor(int i = vis-1; i >= 0; i--){\n\t\tif(query[i][0] == 0){\n\t\t\tanc[query[i][1]] = p[query[i][1]];\n\t\t}else{\n\t\t\tans += root(query[i][1]);\n\t\t\tdeq.push_front(root(query[i][1]));\n\t\t}\n\t}\n\t\n/*\n\tfor(auto it = deq.begin(); it != deq.end(); it++){\n\t\tprintf(\"%ld\\n\", *it);\n\t}\n\t//*/\n\tprintf(\"%ld\\n\", ans);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%ld%ld\", &n, &q);\n\t\tif(n == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tst.clear();\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\nconst int B = 450;\n\nint N, Q;\nstd::vector<int> G[100100];\nint start[100100], friends[100100];\nint buckets[450], parts[200200];\nint doubling[17][100100];\nbool marked[100100];\n\nvoid makeDoubling(){\n    for(int i=0;i+1<=16;++i){\n        for(int j=1;j<=N;++j){\n            if(doubling[i][j] == -1){\n                doubling[i+1][j] = -1;\n            }else{\n                doubling[i+1][j] = doubling[i][doubling[i][j]];\n            }\n        }\n    }\n}\n\nvoid dfs(int v, int& n){\n    start[v] = n++;\n    \n    for(int u : G[v]){\n        dfs(u, n);\n    }\n\n    friends[v] = n++;\n}\n\nvoid update(int l, int r){\n    while(l % B > 0){\n        ++parts[l];\n        ++l;\n    }\n\n    while(r % B > 0){\n        --r;\n        ++parts[r];\n    }\n\n    l /= B;\n    r /= B;\n\n    while(l < r){\n        ++buckets[l];\n        ++l;\n    }\n}\n\ninline int query2(int v){\n    return buckets[start[v] / B] + parts[start[v]];\n}\n\nint query(int v){\n    int lb = 0, ub = 100100, res;\n    int target = marked[v] ? query2(v) - 1 : query2(v);\n    \n    while(std::abs(ub - lb) > 1){\n        int mid = (lb + ub) / 2;\n        int x = v, y = mid, z = 0;\n\n        while(y > 0){\n            if(x != -1 && y % 2 == 1){\n                x = doubling[z][x];\n            }\n            ++z;\n            y >>= 1;\n        }\n        \n        if(x != -1 && query2(x) >= target){\n            lb = mid;\n            res = x;\n        }else{\n            ub = mid;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> N >> Q;\n        if(N == 0){return 0;}\n\n        memset(doubling[0], -1, sizeof(doubling[0]));\n\n        for(int i=1;i<=N;++i){\n            G[i].clear();\n        }\n        \n        for(int i=0;i<N-1;++i){\n            int p;\n            std::cin >> p;\n\n            G[p].emplace_back(i+2);\n            doubling[0][i+2] = p;\n        }\n\n        makeDoubling();\n\n        // for(int i=0;i<16;++i){\n        //     printf(\"# %d\\n\", i);\n        //     for(int j=1;j<=N;++j){\n        //         printf(\"%d\\n\", doubling[i][j]);            \n        //     }\n        // }\n    \n        int ET_N = 0;\n        dfs(1, ET_N);\n\n        memset(buckets, 0, sizeof(buckets));\n        memset(parts, 0, sizeof(parts));\n        \n        update(start[1], friends[1]);\n    \n        // {\n        // int v = 3;\n        // update(start[v], friends[v]);\n        // }    \n        // for(int v = 1;v<=N;++v){\n        //     int q = query(v);\n        //     printf(\"%d\\n\", q);\n        // }\n        // exit(0);\n\n        memset(marked, 0, sizeof(marked));\n        marked[1] = true;\n        \n        ll sum = 0;\n        for(int i=0;i<Q;++i){\n            std::string q;\n            int v;\n            std::cin >> q >> v;\n\n            if(q[0] == 'M'){\n                update(start[v], friends[v]);\n                marked[v] = true;\n            }else{\n                sum += query(v);\n                // printf(\"%d\\n\", query(v));\n            }\n        }\n\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint T[MAX_N+1], vs[MAX_Q];\nchar is[MAX_Q];\nbool ms[MAX_N+1];\n\nint rec(int v) {\n  if (ms[v])\n    return v;\n  return T[v] = rec(T[v]);\n}\n\nint main() {\n  for (;;) {\n    int N, Q;\n    cin >> N >> Q;\n    if (!N && !Q) return 0;\n    fill(ms, ms+N+1, false);\n    ms[1] = true;\n    for (int i = 2; i <= N; i++)\n      cin >> T[i];\n    for (int i = 0; i < Q; i++) {\n      cin >> is[i] >> vs[i];\n      if (is[i] == 'M')\n        ms[vs[i]] = true;\n    }\n    int sum = 0;\n    for (int i = Q-1; i >= 0; i--)\n      if (is[i] == 'M')\n        ms[vs[i]] = false;\n      else\n        sum += rec(vs[i]);\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nAOJ 2170 Marked Ancestor\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\nint isMarked[MAXN];\nvector<vector<int> >tree;\nint N, Q;\n\nstruct OPER{\n    char s[2];\n    int p;\n    bool input(){\n        scanf(\"%s%d\", s, &p);\n        if(s[0] == 'M' && isMarked[p]) return false;\n        else {isMarked[p] = true ; return true;}\n    };\n}op[MAXN];\n\n\n\nint uset[MAXN];\nint rank[MAXN];\n\nclass UnionSet{\npublic:\n    void Init(int n){\n        for(int i=1; i<=n; ++i){\n            uset[i] = i; rank[i] = 0;\n        }\n    }\n    int Find(int x)\n    {\n        if(x == uset[x]) return x;\n        else {\n            int fx = uset[x];\n            uset[x] = Find(fx);\n            return uset[x];\n        }\n    }\n    bool Union(int x, int y) //x and y are different\n    {\n        int fx = Find(x), fy = Find(y);\n        if(fx == fy) return false;\n        if(rank[fx] > rank[fy])\n            uset[fy] = fx;\n        else{\n            uset[fx] = fy;\n            if(rank[fx] == rank[fy]) rank[fy]++;\n        }\n        return true;\n    }\n\n};\n\nUnionSet us;\n\n\nvoid dfs(int r, int pa)\n{\n    for(int i=0; i<tree[r].size(); i++){\n        int x = tree[r][i];\n        if(isMarked[x]) dfs(x, x);\n        else dfs(x, pa);\n    }\n    us.Union(r, pa);\n}\n\n\nbool read()\n{\n    scanf(\"%d%d\", &N, &Q);\n    if(N==0&&Q==0) return false;\n    us.Init(N);\n    memset(isMarked, 0, sizeof(isMarked));\n    tree.clear();\n    tree.resize(N+1);\n    parent[1] = 1;\n    for(int i=2; i<=N; ++i){\n        scanf(\"%d\", &parent[i]);\n        tree[parent[i]].push_back(i);\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int q=0; q<Q; ++q){\n        bool f = op[q].input();\n        if(!f) --q, --Q;\n    }\n    dfs(1, 1);\n    long long sum = 0;\n    for(int q=Q-1; q>=0; --q){\n        int v = op[q].p;\n        if(op[q].s[0] == 'M'){\n            us.Union(v, parent[v]);\n        }\n        else {\n            sum += us.Find(v);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n}\n\nint main()\n{\n    while(read()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 100000;\n\nint n, p;\nint pre[N+1];\n\nint find(int x)\n{\n    while (x != pre[x])\n        x = pre[x];\n    return x;\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &n, &p) != EOF) {\n        if (!n && !p) break;\n        pre[1] = 1;\n        for (int i = 2; i <= n; i ++)\n            scanf(\"%d\", &pre[i]);\n        long long sum = 0;\n        for (int i = 1; i <= p; i ++) {\n            char s[2];\n            int x;\n            scanf(\"%s%d\", s, &x);\n            if (s[0] == 'M')\n                pre[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// ?????????????????§??¨???!!!!!!!!!!!!!\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ????£???????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ????£??????????\n    /**********************/\n\n    // x?????????????§???????op=+, invop=1, T=int, T0=0?????´???\n    // i????????????????????°?????????s[i]??¨?????????x[i] = s[i]????????? (???: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n    // O(log n)\n    T query(int j) {\n        T S = T0;\n        for (j; j >= 0; j = (j & (j + 1)) - 1)  // j??????C->B->7??¨????§??????????0??????C?????????????????????????????°???????????????????£???¶\n            S = op(S, x[j]); \n        return S;\n    }\n    // O(log n)\n    void update(int k, T a) {\n        for (; k < x.size(); k |= k+1) // k??????C->D->F??¨????§??????????C????????????????????°????????¨???????£???¶\n            x[k] = op(x[k], a); \n    }\n    // O(1)\n    // ??????x[i]?????¢???????????????\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n// ????????¨\n//\n// ?§????O(n): ?????????????????¢???, ??¨?????????, ?\\??????????????????°\n//\n// LCA O(log n)\n// ?????????????°??????° O(log n)\n// ????????????????????§????????????????????¢?´¢ O(log n)\nclass Tree {\npublic:\n    static const int MAXLOGV = 25;\n    vector<vector<int> > m_edges; // m_edges[i][j]????????¨: i->j??????????????¨\n    int vn; // ???????????°, vn<2^MAXLOGV\n    int root; // ?????????????????????\n\n    vector<vector<int>> parent; // parent[i][j]: j???i^2???????????????j=0??§??´????????????\n    vector<int> depth; // depth[i]: ??????i?????????????????±???, ??????0\n\n    vector<int> euler; // ??????????§????????????????????????¢????????????vn*2\n    vector<int> f; // f[i] = euler??§i???????????????1???????????????, ??????vn\n    vector<int> s; // f[i] = euler??§i???????????????2???????????????, ??????vn\n\n    /*********/\n    // ?§????\n    /*********/\n    Tree(int vn, int root) : vn(vn), root(root) {\n        parent.resize(MAXLOGV);\n        m_edges.resize(vn);\n        for (int i = 0; i < MAXLOGV; i++) \n            parent[i].resize(vn);\n        depth.resize(vn);\n    }\n\n    // ?????????????§????\n    void unite(int u, int v) {\n        m_edges[u].push_back(v);\n        m_edges[v].push_back(u);\n    }\n\n    // root???????????±?????¨???????¢???????\n    // unite???????????£??????????????????????????¶?????¨???\n    void init() {\n        euler.clear(); euler.reserve(2 * vn);\n        f.clear(); f.resize(vn);\n        s.clear(); s.resize(vn);\n        dfs(root, -1, 0);\n        for (int k = 0; k+1 < MAXLOGV; k++) // 2^k??£?\\????????¨????\n            for (int v = 0; v < vn; v++) \n                if (parent[k][v] < 0) \n                    parent[k+1][v] = -1; // 2^k??£????????????????¶???????????????????2^(k+1)??£????????????????????????????¶?????????????\n                else \n                    parent[k+1][v] = parent[k][parent[k][v]]; // 2^(k+1)??£????????????2^k??£?????????2^k??£?????????\n    }\n\n    // 1????????¨??±?????¨?????????????????¢???????§????\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        f[v]=euler.size();\n        euler.push_back(v);\n        for (int next : m_edges[v]) \n            if (next != p)\n                dfs(next, v, d+1);\n        s[v]=euler.size();\n        euler.push_back(v);\n    }\n\n    /*********/\n    // ?????¨???\n    /*********/\n    // ??????u, v???????°???±???????\\?\n    //\n    // O(log n)\n    int lca(int u, int v) const {\n        if (depth[u] > depth[v]) swap(u, v); // u?????????????????????????????????\n        for (int k = 0; k < MAXLOGV; k++)    // v???u??¨????????±????????§??????\n            if ((depth[v] - depth[u])>>k & 1) \n                v = parent[k][v];\n        if (u == v) return u;\n        for (int k = MAXLOGV-1; k >= 0; k--) { // ????????????????????????????????§??????\n            if (parent[k][u] == parent[k][v]) // ????????????\n                continue; \n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n\n    // u??¨v????????¢????±???????\n    // ?????¢?????¨?????????????????§????????????????§??????°??§??????\n    //\n    // O(log n)\n    int dist(int u, int v) const {\n        int p = lca(u, v);\n        return (depth[u]-depth[p]) + (depth[v]-depth[p]);\n    }\n\n    // [root, v]????????????f???????????????????????´?????????????????????\n    // 1???????????????????????????-1????????????\n    //\n    // O(log n)\n    int binary_search(int v, function<bool(int)> f) const {\n        for(int j = MAXLOGV - 1; j >= 0;j--) \n            if(parent[j][v] != -1 && f(parent[j][v]))\n                v = parent[j][v];\n        return f(v) ? v : -1;\n    }\n\n    // ??¨????§??????????\n    void print_dfs(int v, int p) const {\n        for (int i = 0; i < depth[v]; i++)\n            cout << \" \";\n        cout << v << endl;\n        for (int next : m_edges[v]) if (next != p) \n            print_dfs(next, v);\n    }\n    void print(void) const {\n        print_dfs(root, -1);\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, q; \n    while (cin >> n >> q && n && q) {\n        Tree t(n, 0);\n        rep(i, n-1) {\n            ll tmp; cin >> tmp;\n            t.unite(i+1, tmp-1); \n        }\n        t.init();\n\n        fenwick_tree<ll> ft(n*2);\n        ft.update(t.f[0], 1);\n        ft.update(t.s[0], -1);\n\n        ll ret = 0;\n        rep(_, q) {\n            char c; ll v; cin >> c >> v; v--;\n            if (c == 'M') {\n                if (ft.access(t.f[v]))\n                    continue;\n                ft.update(t.f[v], 1);\n                ft.update(t.s[v], -1);\n            } else {\n                ll marked_num = ft.query(t.f[v]);\n                ret += t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1; \n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  AOJ 2170 Marked Ancestor\n//\n//  Created by TaoSama on 2015-03-16\n//  Copyright (c) 2015 TaoSama. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n#define CLR(x,y) memset(x, y, sizeof(x))\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint n, q, par[N];\n\nint find(int x) {\n\tif(par[x] == x) return x;\n\treturn find(par[x]);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\n\twhile(~scanf(\"%d%d\", &n, &q) && n && q) {\n\t\tpar[1] = 1;\n\t\tfor(int i = 2; i <= n; ++i) scanf(\"%d\", &par[i]);\n\n\t\tlong long ans = 0;\n\t\tfor(int i = 1; i <= q; ++i) {\n\t\t\tchar op[2]; int x;\n\t\t\tscanf(\"%s%d\", op, &x);\n\t\t\tif(op[0] == 'Q') ans += find(x);\n\t\t\telse par[x] = x;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<stack>\nusing namespace std;\n\nstatic int N, M, val;\nstatic char oper;\nstatic int ancestor[100010];\nstatic bool vis[100010];\nint main()\n{\n\twhile (scanf(\"%d%d\", &N, &M) != EOF)\n\t{\n\t\tif (N == 0 && M == 0) break;\n\t\tfill(ancestor, ancestor + N + 1, 0);\n\t\tancestor[1] = 1;\n\t\tfor (int i = 2; i <= N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &ancestor[i]);\n\t\t}\n\t\tscanf(\"%*c\");\n\t\tint sum = 0;\n\t\tfill(vis, vis + N + 1, 0);\n\t\tvis[1] = 1;\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &oper, &val);\n\t\t\tif (oper == 'Q')\n\t\t\t{\n\t\t\t\tint t = val;\n\t\t\t\twhile (vis[t] == 0)\n\t\t\t\t{\n\t\t\t\t\tt = ancestor[t];\n\t\t\t\t}\n\t\t\t\tsum += t;\n\t\t\t}\n\t\t\telse if (oper == 'M')\n\t\t\t{\n\t\t\t\tvis[val] = 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tint ancestor[100000] = {}, ismarked[100000] = {};\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M')uf.unite(ancestor[outlog[i].second], outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += uf.getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//for (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\nint dat[2*MAX_SEG];\n\nclass segment{\npublic:\n    int n;\n    void init(int n_){\n        for(int i=0;i<2*MAX_SEG-1;++i)dat[i]=0;\n\n    }\n    void update(int a,int b,int x,int k=0,int l=0,int r=MAX_SEG){\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            dat[k]=max(dat[k],x);\n            return;\n        }\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n    int query(int k){\n        k+=MAX_SEG-1;\n        int ret=dat[k];\n        while(k){\n            k=(k-1)/2;\n            ret=max(ret,dat[k]);\n        }\n        return ret;\n    }\n};\n\nint N,M;\nvector<int> g[MAX_N+5];\nint depth[MAX_N+5];\nint par[20][MAX_N];\nint tin[2*MAX_N+5],tout[2*MAX_N+5];\nint k=0;\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    tin[v]=k++;\n    for(int u=0;u<g[v].size();++u){\n        dfs(g[v][u],v,d+1);\n        //k++;\n    }\n    tout[v]=k;\n}\n\nvoid fill_table(){\n    for(int i=0;i<19;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        int ans=0;\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        for(int i=0;i<N;++i)g[i].clear();\n        memset(par,0,sizeof(par));\n        for(int i=1;i<N;++i){\n            int p;\n            cin>>p;\n            p--;\n            g[p].PB(i);\n        }\n        k=0;\n        dfs(0,-1,0);\n        fill_table();\n        segment seg;\n        seg.init(N);\n        for(int t=0;t<M;++t){\n            char que;\n            int v;\n            cin>>que;\n            cin>>v;\n            v--;\n            //cout<<tin[v]<<\" \"<<tout[v]<<\" \"<<depth[v]<<endl;\n            if(que=='M'){\n                seg.update(tin[v],tout[v],depth[v]);\n            }\n            else{\n                int q=seg.query(tin[v]);\n                for(int i=19;i>=0;--i){\n                    if((depth[v]-q)>>i&1)v=par[i][v];\n                }\n                ans+=v+1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint mark[MAX_N];\nclass union_find{\n    \n    public:\n        int par[MAX_N];\n        int rank[MAX_N];\n        /*\n        void init(int n){\n            for(int i=0;i<n;i++){\n                par[i]=i;\n            }\n        }\n        */\n        int find(int x){\n            //cout<<\"a\"<<par[x]<<mark[x]<<endl;\n            if(mark[x]==1) return x;\n            return find(par[x]);\n            \n        }\n        bool same(int x,int y){\n            return find(x)==find(y);\n        }\n};\n\n\n\n\nint main(){\n    union_find tree;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&tree.par[i+1]);\n        tree.par[i+1]--;\n    }\n    int ans=0;\n    mark[0]=1;\n    while(1){\n        //cout<<\"a\"<<endl;\n        char a;\n        int b;\n        cin>>a>>b;\n        //cout<<a<<b<<endl;\n        if(a=='0' and b==0)break;\n        if (a=='Q') {\n            //cout<<tree.par[b-1];\n            //cout<<tree.find(b-1)<<endl;\n            ans+=tree.find(b-1)+1;\n\n        }\n        else {\n            //cout<<\"b\"<<b<<endl;\n            mark[b-1]=1;\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1<<29)\n\nstruct SegmetTree {\n    int n, dat[2*MAX-1];    \n    \n    SegmetTree(int n_, vector<int> &d)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = 1;\n        }\n    }\n\n    void update(int k, int a)\n    {\n        k += n - 1;\n        dat[k] = max(dat[k], a);\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    \n    int get_max(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return -INF;\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            int vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n            int vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }    \n};\n\nint child[MAX];\nvector<int> G[MAX], vec;\n\nvoid init(int N)\n{\n    vec.clear();\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n        child[i] = 0;\n    }\n}\n\nint dfs(int v)\n{\n    int c = 0;\n    vec.push_back(v);\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        c += dfs(G[v][i]) + 1;\n    }\n    return (child[v] = c);\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0);\n\n        vector<int> num(N);\n        for (int i = 0; i < (int)vec.size(); i++) {\n            num[vec[i]] = i;\n        }\n        \n        SegmetTree st(N, vec);\n        \n        char m;\n        int v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                for (int i = num[v]; i <= num[v] + child[v]; i++) {\n                    st.update(i, v + 1);\n                }\n            } else {\n                int n = num[v];\n                res += st.get_max(n, n + child[v] + 1, 0, 0, st.n);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    rep(i,n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(int x, int y) {\n    // ?????????????????????????????????\n    x = find(x);\n    y = find(y);\n\n    // ??¢???????????¨????±?????????????????????????????????????\n    if (x == y) return;\n\n    // x?????¨???y?????¨????????§???????????????????????????\n    if (x > y) swap(x, y);\n\n    // x???y??????????????????????????£?????????\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]????????????????????¨???????????§0?????\\????????????????????????\n  }\n\n  // 2???????????????x, y????±?????????¨???????????????true?????????\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // ?????????x?????????????????¨?????§???????????????\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unite(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unite(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.find(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nstruct UnionFind\n{\nprivate:\n  vi data;\n  int cnt;\n\npublic:\n  UnionFind(const int size) : data(size, -1), cnt(size) {}\n  bool unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x != y){\n      data[x] += data[y];\n      data[y] = x;\n      cnt -= 1;\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return root(x) == root(y); }\n  int root(int x){ return data[x] < 0 ? x : data[x] = root(data[x]); }\n  int size(int x){ return -data[root(x)]; }\n  int group(){ return cnt; }\n};\n\nconst int MAX_Q = 111111;\nconst int MAX_N = 111111;\nint N, Q;\nint q[MAX_Q];\nint p[MAX_N];\npair<char, int> query[MAX_N];\nbool flag[MAX_N];\n\nint main()\n{\n  while(cin >> N >> Q, Q){\n    rep(i, N) flag[i] = false;\n\n    UnionFind uf(N);\n    p[0] = 0;\n    rep(i, N - 1) cin >> p[i + 1],  p[i + 1] -= 1;\n    rep(i, Q) cin >> query[i].first >> query[i].second, query[i].second -= 1;\n\n    rep(i, Q) if(query[i].first == 'M') if(flag[query[i].second]) query[i].first = 'a'; else flag[query[i].second] = true;\n    rep(i, N) if(!flag[i]) uf.unite(p[i], i);\n    int res = 0;\n    rev(i, Q){\n      if(query[i].first == 'M') uf.unite(p[query[i].second], query[i].second);\n      if(query[i].first == 'Q') res += uf.root(query[i].second) + 1;\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n};\n\nint N, Q;\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\nvector<int> parent;\nvector<pair<bool, int> > queries;\n\nlong long solve() {\n  tree = UnionFindTree(N);\n  for (int i = 0; i < N; i++) {\n    if (!marked[i]) tree.unite(parent[i], i);\n  }\n\n  long long res = 0;\n  for (int i = queries.size() - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    parent = vector<int>(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n\n    marked = vector<bool>(N);\n    marked[0] = true;\n    queries = vector<pair<bool, int> >(Q);\n    char buf[2];\n    int qnum = 0;\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (buf[0] == 'Q') {\n        queries[qnum++] = make_pair(true, n);\n      } else if (!marked[n-1]) {\n        marked[n-1] = true;\n        queries[qnum++] = make_pair(false, n);\n      }\n    }\n    Q = qnum;\n    queries.resize(Q);\n    long long ans = solve();\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> p[MAX_N];\nint pp[MAX_N];\nint par[MAX_N];\nchar c[MAX_N];\nint num[MAX_N];\nint a[MAX_N];\nint first[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tpar[y] = x;\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nvoid dfs(int v,int anc)\n{\n\tif(a[v]==1){\n\t\trep(i,p[v].size()){\n\t\t\tdfs(p[v][i],v);\n\t\t}\n\t}else{\n\t\tunite(anc,v);\n\t\trep(i,p[v].size()){\n\t\t\tdfs(p[v][i],anc);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n,q;\n\t\tcin >> n >> q;\n\t\tif(n==0&&q==0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i,n){\n\t\t\tp[i].clear();\n\t\t}\n\t\trep(i,n-1){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tp[x-1].push_back(i+1);\n\t\t\tpp[i+1] = x-1;\n\t\t}\n\t\tinitial(n);\n\t\tfill(a,a+n,0);\n\t\ta[0] = 1;\n\t\trep(i,q){\n\t\t\tcin >> c[i] >> num[i];\n\t\t\tif(c[i]=='M'){\n\t\t\t\tif(a[num[i]-1] == 0){\n\t\t\t\t\ta[num[i]-1] = 1;\n\t\t\t\t\tfirst[num[i]-1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0,0);\n\t\tll ans = 0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tif(c[i] == 'M' && i == first[num[i]-1]){\n\t\t\t\tunite(pp[num[i]-1],num[i]-1);\n\t\t\t}else if(c[i] == 'Q'){\n\t\t\t\tans += find(num[i]-1)+1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\n\nint mark[MAX_N+5];\n\nint N;\nint Q;\n\n// union-fold tree\nint par[MAX_N+5];\nint union_rank[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < n; i++) {\n        par[i] = i;\n        union_rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if(par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(union_rank[x] < union_rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if(union_rank[x] == union_rank[y]) union_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nint main() {\n    int p;\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        init(N);\n        map<int, vector<int> > child;\n        for(int i = 0; i < N; i++) {\n            mark[i] = 0;\n        }\n\n        for(int i = 0; i < N-1; i++) {\n            cin >> p;\n            p--;\n            if(child.find(p) == child.end()) {\n                vector<int> v;\n                v.push_back(i+1);\n                child[p] = v;\n            } else {\n                child[p].push_back(i+1);\n            }\n        }\n        char q;\n        int o;\n        int ans = 0;\n        for(int i = 0; i < Q; i++) {\n            cin >> q >> o;\n            o--;\n            if(q == 'Q') {\n                ans += mark[find(o)] + 1;\n            } else {\n                if(child.find(o) == child.end()) {\n                    mark[o] = o;\n                } else {\n                    vector<int> c;\n                    c = child[o];\n                    for(int j = 0; j < c.size(); j++) {\n                        unite(o, c[j]);\n                    }\n                    mark[find(o)] = o;\n                }\n            }\n        }\n        // debug\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){ // aの根をa∪bの根にする\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\t//if(-data[ra]<-data[rb])\n\t\t\t//\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int n,q;cin>>n>>q,n|q;){\n\t\tvi par(n); par[0]=-1;\n\t\trepi(i,1,n) cin>>par[i],par[i]--;\n\t\t\n\t\tvector<pair<char,int>> qs;\n\t\tvi mark(n); mark[0]=1;\n\t\trep(i,q){\n\t\t\tchar t; int x; cin>>t>>x; x--;\n\t\t\tif(t=='Q')\n\t\t\t\tqs.emplace_back(t,x);\n\t\t\telse if(!mark[x]){\n\t\t\t\tmark[x]=1;\n\t\t\t\tqs.emplace_back(t,x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\trep(i,n) if(!mark[i]) uf.Unite(par[i],i);\n\t\t\n\t\tll res=0;\n\t\tper(i,qs.size())\n\t\t\tif(qs[i].first=='Q')\n\t\t\t\tres+=uf.Find(qs[i].second)+1;\n\t\t\telse{\n\t\t\t\tint x=qs[i].second;\n\t\t\t\tuf.Unite(par[x],x);\n\t\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> to;\n\tUnionFind(int size) : data(size, -1), to(size,-1) {\n\t\trep(i, size)to[i] = i;\n\t}\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tvoid setTo(int x, int to) {\n\t\tthis->to[root(x)] = to;\n\t}\n\tint findTo(int x) {\n\t\treturn to[root(x)];\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a, int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tint root = uf.findTo(e[e[j].p].m);\n\t\t\t\t\tuf.unionSet(e[j].m, e[e[j].p].m);\n\t\t\t\t\tuf.setTo(e[j].m, root);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findTo(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef long long int lli;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\nint N,Q;\nvector<int> children[100000];\nint parent[100000];\nchar marked[100000],s[2];\nint stack[100000],stc,a,b,init[100000];\nchar stack2[100000];\nclass UnionFind{\nprivate:\n\tvector<int> par;vector<int> rank;\npublic:\n\tUnionFind(int n){\n\t\tpar=vector<int>(n);rank=vector<int>(n,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x]=y;\n\t\t} else{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tinline bool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\nvoid bfs(int k,int value=0){\n\tqueue<int> k_,value_;\n\tk_.push(k);value_.push(value);\n\twhile(k_.empty()==false){\n\t\tvalue=value_.front();value_.pop();\n\t\tk=k_.front();k_.pop();\n\n\t\tif(marked[k]==true)value=k;\n\t\tinit[k]=value;\n\t\tREP(i,children[k].size()){\n\t\t\tk_.push(children[k][i]);\n\t\t\tvalue_.push(value);\n\t\t}\n\t}\n}\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&N,&Q);stc=0;\n\t\tif(N==0)break;\n\t\tREP(i,N){\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i]=false;\n\t\t}\n\t\tREP(i,N-1){\n\t\t\tscanf(\"%d\",&b);\n\t\t\tchildren[--b].push_back(i+1);\n\t\t\tparent[i+1]=b;\n\t\t}\n\t\tmarked[0]=true;\n\t\tREP(i,Q){\n\t\t\tscanf(\"%s%d\",s,&a);\n\t\t\t--a;\n\t\t\tif(s[0]=='M'&&marked[a])continue;\n\t\t\tif(s[0]=='M'){\n\t\t\t\tmarked[a]=1;\n\t\t\t}\n\t\t\tstack2[stc]=s[0];\n\t\t\tstack[stc++]=a;\n\t\t}\n\t\tbfs(0,0);\n\t\tUnionFind uf(N);\n\t\tinit[0]=0;\n\t\tREP(i,N){\n\t\t\tuf.unite(i,init[i]);\n\t\t}\n\t\tlong long int ans=0;\n\t\tfor(int i=--stc;i>=0;i--){\n\t\t\tif(stack2[i]=='Q'){\n\t\t\t\tans+=init[uf.find(stack[i])]+1;\n\t\t\t}else{\n\t\t\t\tint v=init[uf.find(parent[stack[i]])];\n\t\t\t\tuf.unite(stack[i],parent[stack[i]]);\n\t\t\t\tinit[uf.find(stack[i])]=v;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (nma[x] == x) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint N, Q, t, res;\nint act[100010];\nbool mark[100010];\nstring op;\n\nint main()\n{\n    while(cin >> N >> Q && N)\n    {\n        res = 0;\n        fill_n(mark, 100010, false);\n        mark[1] = true;\n        for(int i = 2; i <= N; ++i)\n        {\n            cin >> t; act[i] = t;\n        }\n        for(int i = 0; i < Q; ++i)\n        {\n            cin >> op >> t;\n            if(op == \"M\")\n                mark[t] = true;\n            if(op == \"Q\")\n            {\n                while(!mark[t]) t = act[t];\n                res += t;\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nconst int MAX_N = 100000;\n\nint _par[MAX_N];\n\nint ancestor(vector<int>& parents, vector<int>& marked, int u){\n    int& p = parents[u];\n    if(marked[p])\n        return _par[u] = p;\n    return _par[u] = ancestor(parents, marked, p);\n}\n\nvoid init(vector<int>& parents, vector<int>& marked){\n    int n = marked.size();\n    for(int i=0; i<n; i++)\n        _par[i] = i;\n    \n    for(int i=1; i<n; i++){\n        if(marked[i]==0 && _par[i]==i)\n            ancestor(parents, marked, i);\n    }\n}\n\nint root(int u){\n    if(_par[u] == u)\n        return u;\n    return _par[u] = root(_par[u]);\n}\n\nint main(){\n    int N, Q;\n    while(cin >> N >> Q, N|Q){\n        vector<int> parents(N);\n        parents[0] = 0;\n        for(int i=1; i<N; i++){\n            cin >> parents[i];\n            parents[i]--;\n        }\n        \n        vector<pair<string, int>> operations(Q);\n        for(int i=0; i<Q; i++){\n            cin >> operations[i].first >> operations[i].second;\n            operations[i].second--;\n        }\n        \n        vector<int> marked(N);\n        marked[0] = 1;\n        for(auto& o : operations){\n            if(o.first == \"M\")\n                marked[o.second]++;\n        }\n        \n        init(parents, marked);\n        \n        int ans = 0;\n        for(int i=Q-1; i>=0; i--){\n            auto& o = operations[i];\n            int& u = o.second;\n            if(o.first == \"M\"){\n                if(--marked[u] == 0)\n                    _par[u] = parents[_par[u]];\n            }else if(o.first == \"Q\"){\n                ans += root(u) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n    \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nint N, Q;\nint p[MAX_N+5];\nbool M[MAX_N+5];\nint uf_par[MAX_N+5];\nint uf_rank[MAX_N+5];\nint mark[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < N; i++) {\n        uf_par[i] = i;\n        uf_rank[i] = 0;\n        mark[i] = i;\n    }\n}\n\nint find(int x) {\n    if (uf_pair[x] == x) {\n        return x;\n    } else {\n        return uf_par[x] = find(uf_par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    \n    if(uf_rank[x] < uf_rank[y]) {\n        uf_par[x] = y;\n        mark[y] = mark[x];\n    } else { \n        uf_par[y] = x;\n        if(uf_rank[x] == uf_rank[y]) uf_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return uf_find(x) == uf_find(y);\n}\n\nint main() {\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        for(int i = 1; i < N; i++) {\n            cin >> p[i-1];\n            p[i-1]--;\n        }\n        vector<P> query;\n        char qm;\n        int num;\n        for(int i = 0; i < Q; i++) {\n            cin >> qm >> num;\n            if(num == 'M') {\n                M[num-1] = true;\n            }\n            query.push_back(P(qm, num));\n        }\n        \n        for(int i = 0; i < N; i++) {\n            if(!M[i]) {\n                unite(p[i], i);\n            }            \n        }\n        \n        int count = 0;\n        for(int i = query.size()-1; i >= 0; i++) {\n            int n = query[i].second;\n            if(query[i].first == 'M') {\n                unite(p[n], n);\n            } else {\n                count += mark[find(n)];\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<bool, int> bi;\nint T[100000];\nbool marked[100000];\nint N;\nint dfs(int v){\n    if(marked[v])\n      return v;\n    else\n      return dfs(T[v]);\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ifstream ifs(\"2170_input.txt\");\n    int Q, _t;\n    char _c;\n    while(cin >> N >> Q && N){\n        vector<bi> query;\n        memset(marked, 0, sizeof(marked));\n        REP(i, 1, N){\n            cin >> _t; _t--;\n            T[i] = _t;\n        }\n        marked[0] = true;\n        ll sum = 0;\n        rep(i, Q){\n            cin >> _c >> _t; _t--;\n            if(_c == 'Q')\n                sum += dfs(_t) + 1;\n            else\n              marked[_t] = true;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,q;\nvector<int>edge[100005];\nstruct segtree{\n\tint seg[(1<<18)],lazy[(1<<18)];\n\tvoid init(){ memset(seg,0,sizeof(seg)); memset(lazy,0,sizeof(lazy));}\n\tint update(int a,int b,int k,int l,int r,int x){\n\t\tif(r<a || b<l) return seg[k];\n\t\telse if(a<=l && r<=b){\n\t\t\tseg[k] = max(seg[k],x);\n\t\t\tlazy[k] = max(lazy[k],x);\n\t\t\treturn seg[k];\n\t\t}\n\t\tif(lazy[k]){\n\t\t\tfor(int q=1;q<=2;q++){\n\t\t\t\tseg[k*2+q] = max(seg[k*2+q],lazy[k]);\n\t\t\t\tlazy[k*2+q] = max(lazy[k*2+q],lazy[k]);\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t\tseg[k] = max(update(a,b,k*2+1,l,(l+r)/2,x),update(a,b,k*2+2,(l+r)/2+1,r,x));\n\t}\n\tint query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return -1;\n\t\telse if(a<=l && r<=b){\n\t\t\treturn seg[k];\n\t\t}\n\t\tif(lazy[k]){\n\t\t\tfor(int q=1;q<=2;q++){\n\t\t\t\tseg[k*2+q] = max(seg[k*2+q],lazy[k]);\n\t\t\t\tlazy[k*2+q] = max(lazy[k*2+q],lazy[k]);\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t\treturn max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2+1,r));\n\t}\n}seg;\n\nint beg[100005],en[100005],id,vv[100005];\nvoid dfs(int v,int u){\n\tvv[id] = v;\n\tbeg[v] = id++;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tdfs(edge[v][i],v);\n\t}\n\ten[v] = id-1;\n}\nint main(){\n\twhile(1){\n\t    id = 0;\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(n == 0) return 0;\n\t\tll ans = 0;\n\t\tfor(int i=1;i<=n;i++) edge[i].clear();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tint a; scanf(\"%d\",&a);\n\t\t\tedge[a].push_back(i);\n\t\t}\n\t\tseg.init();\n\t\tdfs(1,-1);\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar ch; int v; scanf(\" %c %d\",&ch,&v);\n\t\t\tif(ch == 'Q'){\n\t\t\t\tint val = seg.query(beg[v],beg[v],0,0,(1<<17)-1);\n\t\t\t\tans += vv[val];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tseg.update(beg[v],en[v],0,0,(1<<17)-1,beg[v]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nvi d;\nvector<vi> g;\n\nvoid dfs(int now, int a){\n    d[now] = a;\n    rep(i,g[now].size())dfs(g[now][i],a);\n}\n\nsigned main(void) {\n    int n,q;\n    while(cin >> n >> q,n){\n        g = vector<vi>(n);\n        loop(i,1,n){\n            int a;\n            cin >> a;\n            a--;\n            g[a].push_back(i);\n        }\n        d = vi(n,1);\n        int ans = 0;\n        while(q--){\n            string s;\n            cin >> s;\n            int v;\n            cin >> v;\n            v--;\n            if(s == \"M\"){\n                dfs(v,v+1);\n            }else{\n                ans += d[v];\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> to;\n\tUnionFind(int size) : data(size, -1), to(size,-1) {\n\t\trep(i, size)to[i] = i;\n\t}\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tto[y] = to[x];\n\t\t}\n\t\treturn x != y;\n\t}\n\tvoid setTo(int x, int to) {\n\t\tthis->to[root(x)] = to;\n\t}\n\tint findTo(int x) {\n\t\treturn this->to[root(x)];\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tuf.unionSet(e[j].m, e[e[j].p].m);\n\t\t\t\t\tuf.setTo(e[j].m, e[e[j].p].m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findTo(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n//#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <array>\n//#include <set>\n\nusing namespace std;\n\nusing ll_t = long long;\n// #define ll_t long long\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170&lang=jp\n\nclass MarkedTree {\npublic:\n    vector<size_t> parent;\n    vector<bool> marks;\n    explicit MarkedTree(size_t size) {\n        parent = vector<size_t>(size, 0);\n        marks = vector<bool>(size, false);\n        parent[0] = -1; // root\n        marks[0] = true;\n    }\n    size_t findMarkedParent(size_t node) {\n        if (marks[node]) {\n            return node;\n        } else {\n            size_t ret = findMarkedParent(parent[node]);\n            parent[node] = ret;\n            return ret;\n        }\n    }\n    void unMark(size_t node) {\n        marks[node] = false;\n    }\n    void mark(size_t node) {\n        marks[node] = true;\n    }\n    void setParent(size_t node, size_t parentNode) {\n        parent[node] = parentNode;\n    }\n};\n\nint main() {\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            return 0;\n        }\n        MarkedTree tree(N);\n        for (int node = 1; node <= N-1; node++) {\n            int parent;\n            cin >> parent;\n            tree.setParent(node, parent - 1);\n        }\n        vector<pair<char, int>> inputs;\n        inputs.reserve(Q);\n        for (int i = 0; i < Q; i++) {\n            string q;\n            int p;\n            cin >> q >> p;\n            if (q[0] == 'M') {\n                if (!tree.marks[p-1]) {\n                    inputs.emplace_back(q[0],p);\n                }\n                tree.mark(p-1);\n            } else if (q[0] == 'Q') {\n                inputs.emplace_back(q[0],p);\n            }\n        }\n        int querySum = 0;\n        for (int i = (int)inputs.size() - 1; i >= 0; i--) {\n            char q = inputs[i].first;\n            int node = inputs[i].second;\n            if (q == 'Q') {\n                querySum += tree.findMarkedParent(node - 1) + 1;\n            } else { // M\n                tree.unMark(node - 1);\n            }\n        }\n        cout << querySum << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100001\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tT[1] = 1;\n\t\tfor(int i=2; i<=N; i++) cin >> T[i];\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(v, T); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T){\n\tint ans = v;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nconst int MAX_N=100000+16;\nint a[MAX_N*2];\nbool mark[MAX_N*2];\nint N,Q;\nint main(){\n    //freopen(\"1.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&N,&Q)!=EOF){\n        if(N==0&&Q==0)break;\n        memset(mark,false,sizeof(bool)*(N+10));\n        a[1]=0;\n        mark[1]=1;\n        for(int i=2;i<=N;i++){\n            scanf(\"%d\",&a[i]);\n        }\n        int ans=0;\n        while(Q--){\n            char c[2];\n            int x;\n            scanf(\"%s %d\",c,&x);\n            if(c[0]=='Q'){\n                while(!mark[x]){\n                    x=a[x];\n                }\n                ans+=x;\n            }\n            else {\n                mark[x]=true;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MAXN 110000\nint n,q,pa[MAXN],vis[MAXN];\nint main()\n{\n    pa[1]=1;\n    while (~scanf(\"%d%d\",&n,&q)&&(n||q))\n    {\n        for (int i=2;i<=n;i++) scanf(\"%d\",&pa[i]);\n        char s[3];\n        int id;\n        long long ans=0;\n        memset(vis,0,sizeof(vis));\n        vis[1]=1;\n        while (q--)\n        {\n            scanf(\"%s%d\",s,&id);\n            if (s[0]=='Q')\n            {\n                while (!vis[id]) id=pa[id];\n                ans+=id;\n            }\n            else vis[id]=1;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint parent[100001];\nint ans[100001];\npair<char,int> query[100001];\n\nvoid Init(int n){\n\n    for(int i=1;i<=n;++i)\n        ans[i] = parent[i];\n\n}\n\nint Find(int x){\n\n    return x==ans[x]?x:(ans[x]=Find(ans[x]));\n\n}\n\nvoid Union(int x, int y){\n\n    ans[Find(x)] = Find(y);\n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    while(1){\n\n        int N,Q;\n        cin >> N >> Q;\n\n        if(N==0 && Q==0)break;\n\n        parent[1] = 1;\n\n        for(int i=2;i<=N;++i){\n\n            int x;\n\n            cin >> x;\n\n            parent[i] = x;\n\n        }\n\n        Init(N);\n\n        for(int i=0;i<Q;++i){\n\n            string str;\n            int x;\n\n            cin >> str >> x;\n\n            query[i].first  = str[0];\n            query[i].second = x;\n\n            if(str[0]=='M') ans[x] = x;\n\n        }\n\n        long long sum = 0;\n\n        for(int i=Q-1;i>=0;--i){\n\n            pair<char,int> p = query[i];\n\n            if(p.first == 'Q'){\n\n                if(p.second>1) sum += Find(parent[p.second]);\n\n            } else {\n\n                Union(p.second,parent[p.second]);\n\n            }\n\n        }\n       \n        cout << sum << endl;\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX=100000;\n\nbool marked[MAX];\nint parent[MAX];\n\nint find(int s)\n{\n\tint i=s;\n\twhile(!marked[i])i=parent[i];\n\treturn i;\n}\n\nint main()\n{\n\tint n,q;\n\twhile(cin>>n>>q,n)\n\t{\n\t\tint a;char c;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tcin>>a;a--;\n\t\t\tparent[i]=a;\n\t\t\tmarked[i]=false;\n\t\t}\n\t\tparent[0]=0;\n\t\tmarked[0]=true;\n\t\tlong long int sum=0;\n\t\tfor(int i=0;i<q;i++)\n\t\t{\n\t\t\tcin>>c>>a;a--;\n\t\t\tif(c=='Q')\n\t\t\t{\n\t\t\t\tsum+=(long long int)find(a)+1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[a]=true;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1e5+10;\n\nint n,p;\nint pa[N+1];\n\nint find(int x){\n    if(x==pa[x]) return x;\n    else {\n        x = pa[x];\n        return pa[x];\n    }\n}\n\n\nint main(){\n    while(scanf(\"%d%d\",&n,&p) == 2){\n        if(!n && !p) break;\n        pa[1] = 1;\n        for(int i=2; i<=n; i++)\n            scanf(\"%d\",&pa[i]);\n\n        long long sum = 0;\n        for(int i=1; i<=p; i++){\n            char s[2];\n            int x;\n            scanf(\"%s%d\",s,&x);\n            if(s[0] == 'M')\n                pa[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\",sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<math.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {\n\tcww() { CIN_ONLY{ ios::sync_with_stdio(false); cin.tie(0); } }\n}star;\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\nnamespace _DSU {\n\tconst int BUF = 212345 * 2;\n\tint ptr = 0;\n\tint mem[BUF];\n\tint* get(int size) {\n\t\tptr += size;\n\t\treturn mem + ptr - size;\n\t}\n\tvoid reset() {\n\t\tptr = 0;\n\t}\n}\nclass UF {\npublic:\n\tint *par, *rank;\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tUF(int n) :par(_DSU::get(n + 10)), rank(_DSU::get(n + 10)) {\n\t\tREP(i, n)par[i] = i, rank[i] = 0;\n\t}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y)return false;\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint N, Q;\ntypedef vector<int> V;\ntypedef vector<V> VV;\nVV g;\nint query[112345][2];\nint m[112345];\nint p[112345];\nconst int MARK = 0;\nconst int QUERY = 1;\nvoid dfs(int v,int near,UF &uf) {\n\tif (m[v])near = v;\n\tuf.unite(near, v);\n\tm[v] = near;\n\tint ch = g[v].size();\n\tREP(i, ch)dfs(g[v][i], near, uf);\n}\nvoid solve() {\n\t_DSU::reset();\n\tg=VV(N);\n\tFOR(i, 1, N) {\n\t\tcin >> p[i]; p[i]--;\n\t\tg[p[i]].push_back(i);\n\t\tm[i] = 0;\n\t}\n\tm[0] = 1;\n\tREP(i, Q) {\n\t\tchar s[2]; int v;\n\t\tcin >> s >> v;\n\t\tif (s[0] == 'Q')query[i][0] = QUERY;\n\t\telse {\n\t\t\tquery[i][0] = MARK;\n\t\t\tm[v - 1] = 1;\n\t\t}\n\t\tquery[i][1] = v - 1;\n\t}\n\tUF uf(N);\n\tdfs(0, 0, uf);\n\n\tLL ret = 0;\n\tfor (int i = Q - 1; i >= 0; i--) {\n\t\tif (query[i][0] == MARK) {\n\t\t\tint v = query[i][1];\n\t\t\tint u = p[uf.find(v)];\n\t\t\tuf.unite(u, v);\n\t\t}\n\t\telse {\n\t\t\tint v = query[i][1];\n\t\t\tret+= m[uf.find(v)]+1;\n\t\t\t//cout << m[uf.find(v)]+1;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\twhile (cin >> N >> Q, N + Q)solve();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvector<int> a;\n\nint find(int m){\n\tif(a[m] == m)\n\t\treturn m;\n\treturn find(a[m]);\n}\n\n\nint main(void){\n\tint n, q, p, v, i, ans;\n\tchar c;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(n == 0 && q == 0)\n\t\t\tbreak;\n\t\tans = 0;\n\t\ta.push_back(0);\n\t\ta.push_back(1);\n\t\tfor(i = 2;i <= n;i++){\n\t\t\tscanf(\"%d%*c\",&p);\n\t\t\ta.push_back(p);\n\t\t}\n\t\tfor(i = 0;i < q;i++){\n\t\t\tscanf(\"%c%d%*c\",&c,&v);\n\t\t\tif(c == 'Q'){\n\t\t\t\tans += find(v);\n\t\t\t}\n\t\t\telse if(c == 'M'){\n\t\t\t\ta[v] = v;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\ta.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, w, c; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 100;\n\nint f(int v, vector<int>& p, vector<bool>& m) {\n\tif (m[v]) return v;\n\treturn p[v] = f(p[v], p, m);\n}\n\nint main() {\n\tfor (;;) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (N == 0) break;\n\t\tvector<int> p(N + 1);\n\t\tfor (int i = 2; i <= N; i++)\n\t\t\tcin >> p[i];\n\t\tvector<bool> m(N + 1);\n\t\tm[1] = true;\n\t\tvector<string> q; vector<int> v;\n\t\twhile (Q--) {\n\t\t\tstring s; int x; cin >> s >> x;\n\t\t\tif (s == \"M\") {\n\t\t\t\tif (m[x]) continue;\n\t\t\t\tm[x] = true;\n\t\t\t}\n\t\t\tq.push_back(s);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tll sum = 0;\n\t\tfor (int i = q.size() - 1; i >= 0; i--) {\n\t\t\tif (q[i] == \"M\")\n\t\t\t\tm[v[i]] = false;\n\t\t\telse if (q[i] == \"Q\")\n\t\t\t\tsum += f(v[i], p, m);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=2;i<=n;i++) cin>>p[i];\n    marked[1]=true;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tif(marked[t[i]]) c[i]='E';\n\tmarked[t[i]]=true;\n      }\n    }\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll mini=buf.query(0,(int)checked[pos][i]);\n\t\tret[checked[pos][i]-1]=idx_rev[mini]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+1));\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nint ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q),n|q){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] += 1;\n\t\tlong long sum = 0;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] -= 1;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par;\n\tUF() { par = vector<int>(um, 0); rep(i, 0, um) par[i] = i; }\n\tint operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n\tvoid operator()(int x, int y)\n\t{\n\t\tx = operator[](x); y = operator[](y);\n\t\tif (x != y) par[x] = y;\n\t}\n};\n\nint N, Q;\nvector<int> E[101010];\nint P[101010];\n\nchar O[101010];\nint V[101010];\n\nint marked[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> Q)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) E[i].clear();\n\t\trep(i, 0, N) marked[i] = 0;\n\n\t\tP[0] = -1;\n\t\trep(i, 1, N)\n\t\t{\n\t\t\tint p; cin >> p; p--;\n\t\t\tP[i] = p;\n\t\t\tE[i].push_back(p);\n\t\t\tE[p].push_back(i);\n\t\t}\n\n\t\tmarked[0] = 1;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> O[i] >> V[i];\n\t\t\tV[i]--;\n\t\t\tif(O[i] == 'M') marked[V[i]]++;\n\t\t}\n\t\t\n\t\tUF<101010> uf;\n\t\trep(i, 0, N) if (marked[i] == 0) uf(i, P[i]);\n\n\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\n\t\tll ans = 0;\n\t\trrep(i, Q - 1, 0)\n\t\t{\n\t\t\tint v = V[i];\n\t\t\tif (O[i] == 'M')\n\t\t\t{\n\t\t\t\tmarked[v]--;\n\t\t\t\tif (marked[v] == 0) uf(v, P[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (ll)uf[v] + 1LL;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\n \n//思路：并?集 + ? + ?列 （??取出方式） \n\nint parent[100016];\nint height[100016];\n\n//并?集 \nvoid init(int n)\n{\n\tfor(int i = 1; i <= n; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(int x)\n{\n\tif(parent[x] == x)  return x;\n\telse  return parent[x] = find(parent[x]);\n}\n \n//用来描述原始? \nvector<int> children[100016];\nint parent_tree[100016];\nbool marked[100016];\nint ancestor[100016];\n// ?条指令被拆分? 操作 + 目?\nstack<char> operation;\nstack<int>  target;\n \nvoid bfs(int index, int the_ancestor)\n{\n\tqueue<int> q_index;\n\tqueue<int> q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile (!q_index.empty())\n\t{\n\t\tthe_ancestor = q_ancestor.front(); \n\t\tq_ancestor.pop();\n\t\tindex = q_index.front(); \n\t\tq_index.pop();\n\t\tif(marked[index] == true)  the_ancestor = index;  //如果?点自身被??，?它的染色祖先是自己，它的自己不??的儿子的最近染色祖先是它\n\t\tancestor[index] = the_ancestor;  //??index的最近染色祖先 \n\t\tfor(vector<int>::iterator it = children[index].begin(); it != children[index].end(); it++){  //将index的儿子加入?列 \n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n \nint main()\n{\n \n\tint N, Q;\n\twhile(scanf(\"%d %d\", &N, &Q) && (N || Q)){\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i] = false;\n\t\t}\n\t\tmarked[1] = true;\n\t\tparent_tree[1] = 1;\n\t\tint p;\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\", &p);\n\t\t\tparent_tree[i] = p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tgetchar(); \n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tchar ch;\n\t\t\tint t;\n\t\t\tscanf(\"%c %d\", &ch, &t);\n\t\t\tgetchar();\n\t\t\tif(ch == 'M'){\n\t\t\t\tif(marked[t])  continue;  //不?存重?的 \"M v\"，防止之后重?反染色 \n\t\t\t\telse  marked[t] = true;\n\t\t\t}\n\t\t\toperation.push(ch);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(1, 1);\n\t\tinit(N);\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tparent[i] = ancestor[i];\n\t\t}\n\t\tunsigned long long result = 0;\n\t\twhile(!operation.empty()){  //从后往前取出操作\n\t\t\tchar ch = operation.top(); \n\t\t\toperation.pop();\n\t\t\tint t = target.top(); \n\t\t\ttarget.pop();\n\t\t\tif(ch == 'Q')  result += find(t);  //?目index从1?始\n\t\t\telse{  //??点t反染色（取消染色），t的祖先??其父?点的祖先\n\t\t\t\tparent[t] = find(parent_tree[t]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<char, int>;\n\nint root(int x, vector<int>& par, vector<int> const& cnt) {\n    if(cnt[x] > 0) {\n        return x;\n    }\n    return par[x] = root(par[x], par, cnt);\n}\n\nint main() {\n    int N, Q;\n    while(cin >> N >> Q, N) {\n        vector<int> parent(N);\n        for(int i=1; i<N; ++i) {\n            int p;\n            cin >> p;\n            p--;\n            parent[i] = p;\n        }\n        vector<P> query(Q);\n        vector<int> m_cnt(N);\n        m_cnt[0] = 1;\n        for(int i=0; i<Q; ++i) {\n            cin >> query[i].first >> query[i].second;\n            query[i].second--;\n            if(query[i].first == 'M') {\n                m_cnt[query[i].second]++;\n            }\n        }\n        reverse(query.begin(), query.end());\n        long long res = 0;\n        for(auto& q : query) {\n            if(q.first == 'Q') {\n                res += root(q.second, parent, m_cnt) + 1;\n            } else {\n                m_cnt[q.second]--;\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n// Unite可能会用上\nconst int maxn = 100000+5;\nint father[maxn];\nbool idx[maxn];\nint sum,flag;\n\nint find(int a)\n{\n    if(!flag&&idx[a])\n    {sum+=a;flag=1;}\n\n    if(a==father[a])\n        return a;// 好像最后??是返回根->1\n    return find(father[a]);\n}\n\n\nint main()\n{\n    int N,Q;\n    while(scanf(\"%d%d\",&N,&Q)!=EOF&&N&&Q)\n    {\n        memset(father,0,sizeof(father));\n        memset(idx,false,sizeof(idx));\n        sum=0;\n        father[1]=1;\n        idx[1]=true;\n\n        for(int i=2;i<=N;++i)\n        {\n            int a;\n            scanf(\"%d\",&a);\n            father[i]=a;\n        }\n        for(int i=1;i<=Q;++i)\n        {\n            char ch;\n            int a;\n            getchar();\n            scanf(\"%c%d\",&ch,&a);\n            if(ch=='Q')\n            {\n                flag=0;\n                int temp=find(a);// 在向根?点靠近的同??找最近的被??的?点\n//                cout<<\"root == \"<<temp<<endl;\n            }\n            else if(ch=='M')\n            {\n                idx[a]=true;\n            }\n        }\n        printf(\"%d\\n\",sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tconst int N;\n\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tint groups_;\n\tstd::vector< int > sizes;\n\npublic:\n\tUnionFind( int n ) : N( n ), parent( N ), rank( N, 0 ), groups_( N ), sizes( N, 1 )\n\t{\n\t\tstd::iota( parent.begin(), parent.end(), 0 );\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tbool unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t\tsizes[y] += sizes[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tsizes[x] += sizes[y];\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\t++rank[x];\n\t\t\t}\n\t\t}\n\n\t\t--groups_;\n\t\treturn true;\n\t}\n\n\tint groups() const\n\t{\n\t\treturn groups_;\n\t}\n\n\tint groupSize( const int x )\n\t{\n\t\treturn sizes[ find( x ) ];\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n// groups()\n// groupSize( x )\n\nvoid dfs( const VVI &G, const VI &marked, VI &answers, UnionFind &uf, const int u = 0, const int p = 0, const int t = 0 )\n{\n\tconst int nt = marked[u] ? u : t;\n\tanswers[u] = nt + 1;\n\n\tif ( nt == t )\n\t{\n\t\tuf.unite( u, p );\n\t}\n\n\tFOR( v, G[u] )\n\t{\n\t\tdfs( G, marked, answers, uf, v, u, nt );\n\t}\n\n\treturn;\n}\n\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, Q; scanf( \"%d%d\", &N, &Q ) && ( N | Q ); )\n\t{\n\t\tVI parents( N, -1 );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tscanf( \"%d\", &parents[i] );\n\t\t\t--parents[i];\n\t\t}\n\t\tVT( char ) types( Q );\n\t\tVI vs( Q );\n\t\tREP( i, Q )\n\t\t{\n\t\t\tscanf( \" %c%d\", &types[i], &vs[i] );\n\t\t\t--vs[i];\n\t\t}\n\t\t// end of input\n\n\n\t\tVVI G( N );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tG[ parents[i] ].PB( i );\n\t\t}\n\t\t\n\t\tVI marked( N );\n\t\tmarked[0] = 1;\n\t\tREP( i, Q )\n\t\t{\n\t\t\tif ( types[i] == 'M' )\n\t\t\t{\n\t\t\t\tmarked[ vs[i] ] = 1;\n\t\t\t}\n\t\t}\n\n\t\tVI answers( N );\n\t\tUnionFind uf( N );\n\t\tdfs( G, marked, answers, uf );\n\n\t\tLL res = 0;\n\t\tfor ( int i = Q - 1; 0 <= i; --i )\n\t\t{\n\t\t\tconst char T = types[i];\n\t\t\tconst int v = vs[i];\n\n\t\t\tif ( T == 'M' )\n\t\t\t{\n\t\t\t\tconst int na = answers[ parents[v] ];\n\t\t\t\tuf.unite( v, parents[v] );\n\t\t\t\tanswers[ uf.find( v ) ] = na;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += answers[ uf.find( v ) ];\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%I64d\\n\", res );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, Graph& revg, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        g.addEdge(s, to);\n        revg.addEdge(to, s);\n        make_dfs(to, g_, g, revg, visited);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        for (int i = 0; i < N - 1; i++) {\n            int to;\n            cin >> to;\n            to--;\n            g_.addEdge(to, i);\n            g_.addEdge(i, to);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        Graph revg(N);\n        make_dfs(0, g_, g, revg, visited);\n\n        using P = pair<char, int>;\n        vector<P> query(Q);\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = 0;\n        }\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            query[q] = make_pair(c, n);\n            if (c == 'M') {\n                comp[n] = n;\n                marked[n] = true;\n            }\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        int sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n                const int s = q.second;\n                const int par = revg.edge[s][0];\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n                comp[s] = comp[uf.find(s)];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nconst int gmax_n = 1000005;\n\nint par[gmax_n]; //???\nint dps[gmax_n];//??¨?????±???\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        dps[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == 0){\n        return x;\n    }\n    //show(x)\n    if(par[x] == x){\n        return x;\n    }else {\n        return find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    //x = find(x);\n    //y = find(y);\n    if(x == y) return;\n    par[y] = x;\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        init(n + 2);\n        unite(0, 1);\n        range(i,2,n + 1){\n            int inp;\n            cin >> inp;\n            unite(inp, i);\n        //rep(i, n + 2){ cout << dps[i] << ' '; }cout << endl;\n        }\n\n        int ans = 0;\n        rep(i,m){\n            char c;\n            int inp;\n            cin >> c >> inp;\n            if(c == 'M'){\n                unite(0, inp);\n            }else{\n                ans+= find(inp);\n            }\n        //rep(i, n + 2){ cout << dps[i] << ' '; }cout << endl;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint N, Q;\nint p[100010];\nchar q[100010];\nint v[100010];\nint mark[100010];\nvector<int> ch[100010];\n\nint par[100010];\nint find(int x) {\n  return par[x] == x ? x : par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n  x = find(x); y = find(y);\n  if (x == y) return;\n  if (mark[y]) swap(x, y);\n  assert(mark[y] == 0);\n  par[y] = x;\n}\n\nvoid init() {\n  for (int i = 0; i < 100010; i++) {\n    ch[i].clear();\n    mark[i] = 0;\n    par[i] = i;\n  }\n  p[0] = -1;\n  mark[0] = 1;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N >> Q, N) {\n    init();\n    for (int i = 1; i < N; i++) {\n      cin >> p[i];\n      p[i]--;\n      ch[p[i]].emplace_back(i);\n    }\n    for (int i = 0; i < Q; i++) {\n      cin >> q[i] >> v[i];\n      v[i]--;\n      if (q[i] == 'M') mark[v[i]]++;\n    }\n    stack<int> st;\n    st.emplace(0);\n    while (!st.empty()) {\n      int v = st.top();\n      st.pop();\n      for (int nv : ch[v]) {\n        st.emplace(nv);\n      }\n      if (mark[v]) continue;\n      if (p[v] >= 0) unite(p[v], v);\n    }\n\n    ll ans = 0;\n    for (int i = Q-1; i >= 0; i--) {\n      if (q[i] == 'M') {\n        mark[v[i]]--;\n        if (mark[v[i]] == 0) unite(p[v[i]], v[i]);\n      } else {\n        ans += find(v[i]) + 1;\n      }\n    }\n    cout << ans << endl;\n  }  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nclass UF{\n\tvector<int> par, rank;\npublic:\n\tUF(int n): par(n + 1), rank(n + 1) {\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn x != par[x] ? par[x] = find(par[x]) : x;\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y){\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\t++rank[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint par[100001], root[100001], qv[100001];\nchar qc[100001], con[100001];\n\nint main(){\n\tint n, q;\n\twhile(scanf(\"%d%d\", &n, &q), n){\n\t\tmemset(con, 1, sizeof con);\n\n\t\tfor(int i = 2; i <= n; ++i){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\troot[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tscanf(\" %c%d\", &qc[i], &qv[i]);\n\t\t\tif(qc[i] == 'M'){\n\t\t\t\tif(con[qv[i]]){\n\t\t\t\t\tcon[qv[i]] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tqv[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tUF u(n);\n\t\tfor(int i = 2; i <= n; ++i){\n\t\t\tif(con[i]){\n\t\t\t\troot[u.find(i)] = root[u.find(par[i])];\n\t\t\t\tu.unite(i, par[i]);\n\t\t\t}\n\t\t}\n\n\t\tlong long ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i){\n\t\t\tif(qc[i] == 'Q'){\n\t\t\t\tans += root[u.find(qv[i])];\n\t\t\t}\n\t\t\telse if(qv[i] > 0){\n\t\t\t\troot[u.find(qv[i])] = root[u.find(par[qv[i]])];\n\t\t\t\tu.unite(qv[i], par[qv[i]]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), _groups(n), n(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            // if (data[x] > data[y])\n            //     swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\nint main()\n{\n    fast_io();\n\n    int n, q;\n    while (cin >> n >> q, n)\n    {\n        int par[ten(5) + 100];\n        par[0] = 0;\n        rep(i, n - 1)\n            cin >> par[i + 1], --par[i + 1];\n\n        bool mark[ten(5) + 100];\n        fill_n(mark, n, false);\n        char op[ten(5) + 100];\n        int v[ten(5) + 100];\n        rep(i, q)\n        {\n            cin >> op[i] >> v[i], --v[i];\n            if (op[i] == 'M')\n            {\n                if (mark[v[i]])\n                    op[i] = '@';\n                else\n                    mark[v[i]] = true;\n            }\n        }\n\n        UnionFind uf(n);\n        rep(i, n)\n            if (!mark[i])\n                uf.unite(par[i], i);\n\n        ll res = 0;\n        revrep(i, q - 1)\n        {\n            if (op[i] == 'Q')\n                res += uf.root(v[i]) + 1;\n            else if (op[i] == 'M')\n                uf.unite(par[v[i]], v[i]);\n        }\n        \n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, last, next, prev;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(auto & e : es) addEdge(e >> 32, e & 0xFFFFFFFF);\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        last.assign(size, 0);\n        next.assign(size, -1);\n        prev.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                last[v] = path.back();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                prev[v] = i != 0 ? path[i-1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        while(1){\n            dump(v);\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(v);\n            if(it != ms.end()){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        return 0;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nint solve(){\n    int ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q'){\n            ans += h.query(qv[i]) + 1;\n        } else {\n            h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[i+1].eb(i+1,par);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n \nint to[123456];\nchar o[123456];\nint v[123456];\n \nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n \n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (y < x) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void sep(int x){\n    data[x] = -1;\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    memset(to,0,sizeof(to));\n    memset(o,0,sizeof(o));\n    memset(v,0,sizeof(v));\n    unionfind uf(n+10);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+2] = a;\n    }\n    for(int i = n;i > 1;--i){\n        uf.unionset(to[i],i);\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      if(o[i]=='M'){\n        uf.sep(v[i]);\n      }    \n    }\n    int sum = 0;\n     \n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i]);\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// グラフ用ヘッダ\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int limit;\n    Edge(int src, int dst, Weight weight, int limit) :\n        src(src), dst(dst), weight(weight), limit(limit) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n#include <queue>\n\n// d,speed,v,from\ntypedef tuple<double,int,int,int> State;\n\nconst double inf = 1e100;\n\n// speed,v,from\ndouble dp[32][32][32];\nGraph g;\nint src,dst;\n\nconst char* solve(){\n    priority_queue<State> q;\n    q.emplace(0.0,0,src,31);\n    rep(i,32)rep(j,32)rep(k,32) dp[i][j][k] = inf;\n    dp[0][src][31] = 0;\n    while(q.size()){\n        double d; int speed, v, from;\n        tie(d,speed,v,from) = q.top(); q.pop();\n        d = -d;\n        if(v==dst && speed==1){\n            static char buf[100];\n            sprintf(buf,\"%.12lf\",d);\n            return buf;\n        }\n        if(d > dp[speed][v][from]) continue;\n        for(Edge & e : g[v]){\n            for(int diff : {-1,0,1}){\n                int ns = speed + diff;\n                if(ns < 1 || e.limit < ns) continue;\n                double nd = d + (double)e.weight / ns;\n                int nv = e.dst;\n                if(nv == from) continue;\n                if(dp[ns][nv][v] > nd){\n                    dp[ns][nv][v] = nd;\n                    q.emplace(-nd,ns,nv,v);\n                }\n            }\n        }\n    }\n    return \"unreachable\";\n}\n\nint main(){\n    int n,m;\n    while(~scanf(\"%d%d\", &n,&m) && n){\n        scanf(\"%d%d\",&src,&dst);\n        g.assign(n+1,{});\n        rep(i,m){\n            int x,y,d,c;\n            scanf(\"%d%d%d%d\", &x,&y,&d,&c);\n            g[x].eb(x,y,d,c);\n            g[y].eb(y,x,d,c);\n        }\n        puts(solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=100010;\nint n,q,v;\nchar buf[4];\nvector<int> g[N];\nint p[N],dsu[N];\nbool marked[N];\n\nint fi(int x) {\n    return dsu[x]==x?x:(dsu[x]=fi(dsu[x]));\n}\n\nvoid dfs(int x,int ma) {\n    if (marked[x]) {\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],x);\n        }\n    } else {\n        dsu[x]=ma;\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],ma);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&q);\n        if (n==0&&q==0) break;\n        memset(p,0,sizeof(p));\n        memset(marked,0,sizeof(marked));\n        for (int i=1;i<=n;i++) {\n            dsu[i]=i;\n            g[i].clear();\n        }\n        for (int i=2;i<=n;i++) {\n            scanf(\"%d\",&v);\n            p[i]=v;\n            g[v].pb(i);\n        }\n        vector<PII> op;\n        marked[1]=1;\n        for (int i=1;i<=q;i++) {\n            scanf(\"%s%d\",buf,&v);\n            if (buf[0]=='M') {\n                if (!marked[v]) {\n                    marked[v]=1;\n                    op.pb(mp(0,v));\n                }\n            } else {\n                op.pb(mp(1,v));\n            }\n        }\n        dfs(1,1);\n        ll ans=0;\n        for (int i=op.size()-1;i>=0;i--) {\n            if (op[i].first) {\n                ans+=fi(op[i].second);\n            } else {\n                int r=fi(p[op[i].second]);\n                dsu[op[i].second]=r;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n/*#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>*/\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct UnionFind\n{\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tUnionFind(int N) :parent(N, 0), rank(N, 0)\n\t{\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif (x == y)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (rank[x] < rank[y])\n\t\t{\n\t\t\tparent[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvector<int> G[100005];\nint anc[100005];\n\nvoid dfs(int nv, int tanc)\n{\n\tif (anc[nv] == tanc || anc[nv] == nv)\n\t{\n\t\treturn;\n\t}\n\tanc[nv] = tanc;\n\tfor (auto n : G[nv])\n\t{\n\t\tdfs(n, tanc);\n\t}\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true)\n\t{\n\t\tint N, Q;\n\t\tcin >> N >> Q;\n\t\tif (N + Q == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint to;\n\t\trep(i, 0, N - 1)\n\t\t{\n\t\t\tcin >> to;\n\t\t\tG[to - 1].push_back(i + 1);\n\t\t}\n\t\tchar c;\n\t\tint v;\n\t\tll ans = 0;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')\n\t\t\t{\n\t\t\t\tdfs(v - 1, v - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += anc[v - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 100001\nusing namespace std;\ntypedef long long ll;\nint func(int);\nint n,q,e,k;\nbool marked[N];\nvector<int> edge[N];\n\nint main(){\n  char c;\n  ll cnt;\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n-1;i++) cin>>e,edge[i+2].push_back(e);\n    for(int i=0;i<n-1;i++) marked[i+2]=false;\n    marked[1]=true;\n    cnt=0;\n    while(q--){\n      cin>>c>>k;\n      if(c=='M') marked[k]=true;\n      else cnt+=func(k);\n    }\n    cout<<cnt<<endl;\n    for(int i=2;i<=n;i++) edge[i].clear();\n  }\n  return 0;\n}\n\nint func(int x){\n  if(marked[x]) return x;\n  return func(edge[x][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define A 100010\n#define X first\n#define Y second\nusing namespace std;int n,q,z,m[A],u[A];vector<int> c[A];stack<pair<char,int> > Q;void D(int x,int g){u[x]=g;if(m[x])g=x;for(int i=0;i<c[x].size();i++)D(c[x][i],g);}int F(int x){if(m[x])return x;int t=F(u[x]);u[x]=t;return t;}int main(){while(cin>>n>>q&&n){for(int i=0;i<n;i++){c[i].clear();u[i]=0,m[i]=0;}for(int i=1;i<n;i++){cin>>z;z--;c[z].push_back(i);}m[0]++;for(int i=0;i<q;i++){pair<char,int> r;cin>>r.X>>r.Y;r.Y--;if(r.X=='M')m[r.Y]++;Q.push(r);}D(0,0);long long s=0;while(!Q.empty()){if(Q.top().X=='M')m[Q.top().Y]--;else s+=F(Q.top().Y)+1;Q.pop();}cout<<s<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tvi T(n);\n\t\tvi m(n);\n\t\tvi mv(n);\n\t\tiota(ALL(mv), 0);\n\t\tm[0] = 1;\n\t\trep1(i, n - 1)cin >> T[i], T[i]--;\n\t\tvpii a(q);\n\t\tunionfind uf(n);\n\t\tll ans = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')m[v - 1] = 1;\n\t\t\ta[i] = { c,v };\n\t\t}\n\t\trrep(i, q) {\n\t\t\tif (a[i].first == 'M')m[a[i].second - 1] = 0;\n\t\t\telse {\n\t\t\t\tint v = a[i].second - 1;\n\t\t\t\twhile (!m[v = mv[uf.find(v)]]) {\n\t\t\t\t\tint u = uf.find(T[v]);\n\t\t\t\t\tuf.unite(v, u);\n\t\t\t\t\tmv[uf.find(v)] = mv[u];\n\t\t\t\t}\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    int m[MAX];\n    vector<int> c[MAX];\n    vector<int> p;\n    int n;\n    \n    UF(int k):par(k),rank(k),p(k)\n    {\n        n=k;\n        for(int i=0;i<n;i++) par[i]=i;\n        for(int i=0;i<n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=0;\n        m[0]=1;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]++;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[c[x][i]]>0) par[c[x][i]]=c[x][i];\n            else           par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)+1;\n    }\n    \n    void delmark(int x)\n    {\n        m[x]--;\n        if(m[x]==0) unite(x,p[x]);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n            (uf.p)[i]=p-1;\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint edge[1000001];\nvector<int> G[1000000];\nint par[1000001];\nbool flag[1000001];\nchar s[1000001];\nint v[1000001],fm[1000001];\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tpar[i]=i;\n\t\tG[i].clear();\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tmemset(fm,-1,sizeof(fm));\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tpar[x]=y;\n\t}\n\n}\n\nvoid unite_dfs(int v,int p){\n\tif(!flag[v])unite(v,p);\n\telse p=v;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tunite_dfs(G[v][i],p);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&edge[i]);\n\t\t\tG[edge[i]].push_back(i);\n\t\t}\n\t\tflag[1]=true;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tcin >> s[i] >> v[i];\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]=true;\n\t\t\t\tif(fm[v[i]]==-1)fm[v[i]]=i;\n\t\t\t}\n\t\t}\n\t\tunite_dfs(1,1);\n\t\tlong long res=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(s[i]=='Q'){\n\t\t\t\tres+=(long long)find(v[i]);\n\t\t\t}\n\t\t\tif(s[i]=='M' && fm[v[i]]==i){\n\t\t\t\tunite(v[i],edge[v[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint find(int v){\n\t\treturn data[v]<0?v:find(data[v]);\n\t}\n\tbool unite(int u,int v){\n\t\tint ru=find(u),rv=find(v);\n\t\tif(ru==rv) return false;\n\t\tdata[ru]+=data[rv];\n\t\tdata[rv]=ru;\n\t\treturn true;\n\t}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi ps(n);\n\t\trepi(i,1,n) cin>>ps[i],ps[i]--;\n\t\tvector<tuple<char,int>> qs;\n\t\trep(i,m){\n\t\t\tchar c; cin>>c;\n\t\t\tint v; cin>>v; v--;\n\t\t\tqs.emplace_back(c,v);\n\t\t}\n\t\t\n\t\tvi marked(n);\n\t\tmarked[0]=1;\n\t\tfor(auto q:qs)\n\t\t\tif(get<0>(q)=='M')\n\t\t\t\tmarked[get<1>(q)]=1;\n\t\t\n\t\tUnionFind uf(n);\n\t\trep(i,n) if(!marked[i])\n\t\t\tuf.unite(ps[i],i);\n\t\t\n\t\tll res=0;\n\t\tper(i,m){\n\t\t\tchar t; int v; tie(t,v)=qs[i];\n\t\t\tif(t=='M')\n\t\t\t\tuf.unite(ps[v],v);\n\t\t\telse if(t=='Q')\n\t\t\t\tres+=uf.find(v)+1;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint n, q;\nint p[100005];\nvector<int> G[100005];\nchar c[100005]; int v[100005];\nbool mark[100005];\nUnionFind uf(100005);\n\nvoid dfs(int v)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!mark[G[v][i]]) uf.unite(G[v][i], v);\n\t\tdfs(G[v][i]);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> q;\n\t\tif(n == 0 && q == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> p[i];\n\t\t\tG[p[i]].push_back(i);\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c[i] >> v[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) mark[i] = false;\n\t\tmark[1] = true;\n\t\t\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'M') mark[v[i]] = true;\n\t\t}\n\t\tuf.init();\n\t\tdfs(1);\n\t\t\n\t\treverse(c, c+q);\n\t\treverse(v, v+q);\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'Q') ans += uf.root(v[i]);\n\t\t\telse uf.unite(v[i], p[v[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m,x,sum,flg;\nstring str;\nint t[100001],u[100001],v[100001];\nint dfs(int x){\n  if(flg==1&&v[x]!=0)return v[x];\n  if(u[x]==1)return x;\n  return dfs(t[x]);\n}\nint main(){\n  while(cin>>n>>m,n){\n    for(int i=0;i<100001;i++)u[i]=v[i]=0;\n    t[1]=u[1]=1;\n    sum=0;\n    \n    for(int i=0;i<n-1;i++)cin>>t[i+2];\n    for(int i=0;i<m;i++){\n      cin>>str>>x;\n      if(str==\"Q\"){\n\tsum+=dfs(x);\n      }else{\n\tu[x]=1;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> graph;\ntypedef pair<char, int> query;\n\nvector<int> mark_parent;\nvector<int> marked;\n\nvoid walk_graph(int v, int mark_p, graph& g) {\n\n    mark_parent[v] = mark_p;\n\n    if (marked[v]) {\n        mark_p = v;\n    }\n\n    for (int& nv : g[v]) {\n        walk_graph(nv, mark_p, g);\n    }\n}\n\nint find_mark_parent(int v) {\n    if (marked[v]){\n        // cout << endl;\n        return v;\n    }\n    // cout << v << \"->\";\n    mark_parent[v] = find_mark_parent(mark_parent[v]);\n    return mark_parent[v];\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<query>& queries) {\n    mark_parent = vector<int>(N, 0);\n    marked = vector<int>(N, 0);\n\n    graph g = graph(N, vector<int>());\n\n    for (int j = 1; j < N; ++j) {\n        g[parent[j]].push_back(j);\n    }\n\n    marked[0] = 1;\n    for (query& q : queries) {\n        if (q.first == 'M') {\n            ++marked[q.second];\n        }\n    }\n\n    walk_graph(0, -1, g);\n    \n    // cout << \"####walk_graph####\" << endl;\n\n    int ret = 0;\n\n    for (int j = Q-1; j >= 0; --j) {\n        char ch = queries[j].first;\n        int v = queries[j].second;\n\n        // cout << \"####\" << j << \" \" << queries[j].first << \" \" << queries[j].second << \"####\" << endl;\n\n        if (ch == 'Q') {\n            ret += find_mark_parent(v) + 1;\n        }\n\n        if (ch == 'M') {\n            --marked[v];\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, Q;\n    vector<int> parent;\n    vector<query> queries;\n\n    while (true) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        parent.resize(N);\n        parent[0] = 0;\n        for (int j = 1; j < N; ++j) {\n            cin >> parent[j];\n            --parent[j];\n        }\n\n        queries.resize(Q);\n        for (query& q : queries) {\n            cin >> q.first >> q.second;\n            --q.second;\n        }\n\n        // cout << N << \" \" << Q << endl;\n\n        cout << solve(N, Q, parent, queries) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<vector>\n#define oo 0x3f3f3f33f\nusing namespace std;\nint n, m, vis[100010];\nint pre[100010];\nint Quary(int x)\n{\n    if(vis[x]==1)\n        return x;\n    if(vis[pre[x]]==1)\n        return pre[x];\n    return Quary(pre[x]);\n}\nint main()\n{\n    int i;\n    while(scanf(\"%d%d\", &n, &m), n+m)\n    {\n        memset(vis, 0, sizeof(vis));\n        char str[6];\n        long long ans = 0;\n        int root, v;\n        vis[1]=1;\n        pre[1]=1;\n        for(i=2; i<=n; i++)\n        {\n            scanf(\"%d\", &root);\n            pre[i]=root;\n        }\n        for(i=0; i<m; i++)\n        {\n            scanf(\"%s%d\", str, &v);\n            if(str[0]=='M')\n                vis[v]=1;\n            else\n                ans+=Quary(v);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 100000;\n\nint n, p;\nint pre[N+1];\n\nint find(int x)\n{\n    while (x != pre[x])\n        x = pre[x];\n    return x;\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &n, &p) != EOF) {\n        if (!n && !p) break;\n        pre[1] = 1;\n        for (int i = 2; i <= n; i ++)\n            scanf(\"%d\", &pre[i]);\n        int sum = 0;\n        for (int i = 1; i <= p; i ++) {\n            char s[2];\n            int x;\n            scanf(\"%s%d\", s, &x);\n            if (s[0] == 'M')\n                pre[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%d\\n\", sum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nbool mark[101010];\nint g[101010];\n\nint dfs(int s) {\n        return mark[s] ? s : dfs(g[s]);\n}\n\nint main() {\n        int n, q;\n        while (cin >> n >> q && n) {\n                memset(mark, 0, sizeof(mark));\n                for (int i = 1; i < n; i ++) {\n                        int p;\n                        cin >> p;\n                        p --;\n                        g[i] = p;\n                }\n                mark[0] = true;\n                long long ans = 0;\n                rep(i, q) {\n                        char s;\n                        int v;\n                        cin >> s >> v;\n                        v --;\n                        if (s == 'M') mark[v] = true;\n                        else ans += dfs(v) + 1;\n                }\n                cout << ans << endl;\n        }\n}\n\n//#define int long long\n//\n//struct query {\n//        char s;\n//        int node;\n//};\n//\n//struct state {\n//        int d;\n//        int timing;\n//        int node;\n//        bool operator < (const state& r) const { return d < r.d; }\n//        bool operator > (const state& r) const { return d > r.d; }\n//};\n//\n//vector<int> depth;\n//vector<vector<int> > g;\n//vector<bool> used;\n//vector<int> mark;\n//vector<priority_queue<state>> st;\n//vector<query> v;\n//\n//void depth_init_dfs(int s, int d) {\n//        depth[s] = d;\n//        for (auto v : g[s]) if (!used[v]) { \n//                used[v] = true;\n//                depth_init_dfs(v, d + 1);\n//        }\n//}\n//\n//void dfs(int s) {\n//        if (mark[s] != -1) {\n//                priority_queue<state> tmp;\n//                tmp = st[s];\n//                tmp.push({depth[s], mark[s], s + 1});\n//                for (auto v : g[s]) if (!used[v]) {\n//                        used[v] = true;\n//                        st[v] = tmp;\n//                        dfs(v);\n//                }\n//        } else {\n//                for (auto v : g[s]) if (!used[v]) {\n//                        used[v] = true;\n//                        st[v] = st[s];\n//                        dfs(v);\n//                }\n//        }\n//}\n//\n//signed main() {\n//        int n, q;\n//        while (true) {\n//                cin >> n >> q;\n//                if (n == 0 && q == 0) break;\n//                cerr << n << ' ' <<  q << endl;\n//                v.clear();\n//                v.resize(q);\n//                g.clear();\n//                g.resize(n);\n//                rep(i, n - 1) {\n//                        int p;\n//                        cin >> p;\n//                        p --;\n//                        g[p].push_back(i + 1);\n//                }\n//                rep(i, q) {\n//                        cin >> v[i].s >> v[i].node;\n//                        v[i].node --;\n//                }\n//                depth.clear();\n//                depth.resize(n);\n//                used.clear();\n//                used.resize(n, false);\n//                used[0] = true;\n//                depth_init_dfs(0, 0);\n//                //rep(i, n) {\n//                //        cout << depth[i] << ' ' << i << endl;\n//                //}\n//                mark.clear();\n//                mark.resize(n, -1);\n//                mark[0] = 0;\n//                rep(i, q) {\n//                        if (v[i].s == 'M') {\n//                                mark[v[i].node] = i + 1;\n//                        }\n//                }\n//                st.clear();\n//                st.resize(n);\n//                used.clear();\n//                used.resize(n, false);\n//                st[0].push({0, 0, 1});\n//                dfs(0);\n//                //rep(i, n) {\n//                //        state s = st[i].top();\n//                //        cout << s.d << ' ' << s.timing << ' ' << s.node << endl;\n//                //}\n//                int ans = 0;\n//                for (int i = q - 1; i >= 0; i --) {\n//                        if (v[i].s == 'Q') {\n//                                while (!st[v[i].node].empty()) {\n//                                        if (i < st[v[i].node].top().timing < i + 1) {\n//                                                ans += st[v[i].node].top().node;\n//                                                break;\n//                                        }\n//                                        st[v[i].node].pop();\n//                                }\n//                        }\n//                }\n//                cout << ans << endl;\n//        }\n//        return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nstruct seg_rangemin_getmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\tint inff=inf*1000000ll;\n\tpa e={inf+1,inf+1};\n\tvector<pa> vec;\n\tvector<pa> lazy;\n\tvoid shoki1(){\n\t\t\tvec.resize(2*cor+3, {inf,inf});\n\t\tlazy.resize(2*cor+3, e);\n\t}\n\tvoid shoki2(){\n\t\t\n\t\t//初期値\n\t}\n\t\t\n\tvoid chien(int k,int l,int r){\n\t\tif(lazy[k]==e) return;\n\t\tif(l+1<r){\n\t\t\tvec[k]=min(vec[k],lazy[k]);\n\t\t\tlazy[2*k]=min(lazy[k],lazy[2*k]);\n\t\t\tlazy[2*k+1]=min(lazy[k],lazy[2*k+1]);\n\t\t\tlazy[k]=e;\n\t\t}\n\t\telse {\n\t\t\tvec[k]=min(lazy[k],vec[k]);\n\t\t\tlazy[k]=e;\n\t\t}\n\t}\n\t\n\tpa rangemin(int a,int b,pa w, int k=1,int l=0,int r=-3){\n\t\t//[a,b)を wに変更\n\t\tif(r<0) r=cor;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\t\n\t\t\t lazy[k]=min(lazy[k],w);\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\t\n\t\tchien(k,l,r);\n//\tcout<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\tpa w1=rangemin(a,b,w,k*2,l,(l+r)/2);\n\t\tpa w2=rangemin(a,b,w,k*2+1,(l+r)/2,r);\n\t\tvec[k]=min(w1,w2);\n\t\treturn vec[k];\n\t}\n\t\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\t\n\tpa getmin(int a,int b,int k=1,int l=0,int r=-1){\n\t\t//[a,b)のminを取得\n\t\tif(r<0) r=cor;\n\t\tchien(k,l,r);\n\t\tif(r<=a || b<=l){// 区間外\n\t\t\treturn {inf,inf};\n\t\t}\n\t\t\n\t\tif(a<=l && r<=b){// 完全含む\n\t\t\t\n\t\t\treturn vec[k];\n\t\t}\n\t\tpa w1=getmin(a,b,k*2,l,(l+r)/2);\n\t\tpa w2=getmin(a,b,k*2+1,(l+r)/2,r);\n\t\treturn min(w1,w2);\n\t}\n\t/*\n\tvoid pre(){\n\t\tfor(int i=1;i<2*cor;i++){\n\t\t\tcout<<vec[i]<<\" \";\n\t\t\tif(((i+1)&(-(i+1)))==i+1) cout<<endl;\n\t\t}\n\t}\n\t*/\n\t\n};\n\nvector<int> G[100020];\nvector<int> ve;\nint l[100020][2];\nint dep[100020];\nvoid dfs(int r,int d){\n//\tcout<<r<<\" \"<<d<<endl;\n\tve.pb(r);\n\tdep[r]=d;\n\tl[r][0]=ve.size()-1;\n\tfor(auto v:G[r])dfs(v,d-1);\n\tve.pb(r);\n\tl[r][1]=ve.size()-1;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \t\n \twhile(1){\n \tint n,m;\n \t\tcin>>n>>m;\n \t\tif(n==0&& m==0) return 0;\n \t\tfor(int i=1;i<=n;i++)G[i].clear();\n \t\tfor(int i=2;i<=n;i++){\n \t\t\tint y;\n \t\t\tcin>>y;\n \t\t\tG[y].pb(i);\n \t\t}\n \t\tve.clear();\n \t\tdfs(1,10000000);\n \t\tseg_rangemin_getmin SE;\n \t\tSE.shoki1();\n \t\tSE.shoki2();\n \t//\tfor(int i=1;i<=n;i++)cout<<dep[i]<<endl;\n \t\tint ans=0;\n \t\tSE.rangemin(l[1][0],l[1][1]+1,{dep[1],1});\n \t\tfor(int er=0;er<m;er++){\n \t\t\tstring s;\n \t\t\tint y;\n \t\t\tcin>>s;\n \t\t\tcin>>y;\n \t\t\tif(s==\"Q\"){\n \t\t\t\tpa z=SE.getmin(l[y][0],l[y][0]+1);\n \t\t\t//\tcout<<z.first<<\" \"<<z.second<<endl;\n \t\t\t\tans+=z.second;\n \t\t\t}\n \t\t\telse{\n \t\t\t\t\tSE.rangemin(l[y][0],l[y][1]+1,(pa){dep[y],y});\n \t\t\t}\n \t\t}\n \t\tcout<<ans<<endl;\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\ta[1] = 1;\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<bool> roots(n);\n\t\troots[1] = true;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots[v]) continue;\n\t\t\tif(c == 'M') roots[v] = true;\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(!roots[i]){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N=2*1e5;\nconstexpr int Log=log2(MAX_N)+10;\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r+3 && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(int i=0;i<2*r;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//{Headers\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n\nusing namespace std;\ntypedef vector< int > vi;\ntypedef vector< vi > vvi;\ntypedef pair< int,int > pii;\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\n//}\n\nconst int MAXN=1e5;\nint N,Q,par[MAXN+1];\n\nint root(int x){return x==par[x]?x:root(par[x]);}\n\nvoid solve(){\n    long long ans=0;\n    char op;\n    int x;\n    par[1]=1;\n    for(int i=2;i<=N;i++) scanf(\"%d\",&par[i]);\n    while(Q--){\n        scanf(\" %c %d \",&op,&x);\n        if(op=='Q') ans+=root(x);\n        else par[x]=x;\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nint main(void){\n//    freopen(\"in.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&N,&Q) && N!=0)\n        solve();\n    return 0;\n}\n\n/*\nSample Input\n6 3\n1\n1\n2\n3\n3\nQ 5\nM 3\nQ 5\n0 0\nOutput for the Sample Input\n4\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define ll long long\nint q, n, v;\nchar c;\nint p[100005];\nint main() {\n    while ((~scanf(\"%d %d\", &n, &q)) && q && n) {\n        for (int i = 2; i <= n; ++i) scanf(\"%d\", &p[i]);\n        p[1] = 1;\n        ll ans = 0;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"\\n%c %d\", &c, &v);\n            if (c == 'M')p[v] = v;\n            else {\n                while (p[v] != v) v = p[v];\n                ans += v;\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n\nint const M = 1000100;\n\nint N,Q;\nint par[M];\nvector<int> ch[M];\nchar q[M];\nint v[M];\nbool use[M];\nbool flg[M];\nint g[M];\nbool marked[M];\n\nvoid rec(int v){\n    for(int c : ch[v]){\n        if(marked[c]){\n            g[c] = c;\n        } else {\n            g[c] = g[v];\n        }\n        rec(c);\n    }\n}\n\nint solve(){\n    rep(i,N+1) flg[i] = false;\n    rep(i,Q)if(q[i]=='M'){\n        if(flg[v[i]]) use[i] = false;\n        else {\n            use[i] = true;\n            flg[v[i]] = true;\n        }\n    }\n    marked[1] = true;\n    per(i,Q)if(use[i]){\n        marked[v[i]] = true;\n    }\n\n    par[1] = 1;\n    g[1] = 1;\n    rec(1);\n\n    int ans = 0;\n    per(i,Q)if(use[i] || q[i]=='Q'){\n        if(q[i]=='M'){\n            g[v[i]] = g[par[i]];\n        } else {\n            int u = v[i];\n            while(u!=g[u]){\n                u = par[u];\n            }\n            dump(u);\n            ans += u;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(cin>>N>>Q && N){\n        par[0] = 0;\n        rep(i,N-1){\n            int v; cin>>v;\n            par[i+2] = v;\n            ch[v].push_back(i+2);\n        }\n        rep(i,Q){\n            cin >> q[i] >> v[i];\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nint find(int x) {\n\tif(x==par[x])\n\t\treturn x;\n\telse\n\t\treturn  find(par[x]);\n}\n\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tlong long sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tpar[1] = 1;\n\t\t//flag[1] = true;\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(p);\n\t\t\t}else{\n\t\t\t\tpar[p] = p;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001],mpar[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n  fill(mpar, mpar+N+1, 1);\n  \n  marked[1] = 1;\n  par[1] = 1;\n}\n\nint ans(int v){\n\n  if(marked[par[v]] == 1) return par[v];\n  return mpar[v] = ans(par[v]);\n\n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=2;i<=N;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\n// TODO ????????????????????????\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ????£???????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ????£??????????\n    /**********************/\n    // x?????????????§???????op=+, invop=1, T=int, T0=0?????´???\n    // i????????????????????°?????????s[i]??¨?????????x[i] = s[i]????????? (???: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n    // O(log n)\n    T query(int j) {\n        T S = T0;\n        for (j; j >= 0; j = (j & (j + 1)) - 1) { // j??????C->B->7??¨????§??????????0??????C?????????????????????????????°???????????????????£???¶\n            S = op(S, x[j]); \n        }\n        return S;\n    }\n    // O(log n)\n    void update(int k, T a) {\n        for (; k < x.size(); k |= k+1) x[k] = op(x[k], a); // k??????C->D->F??¨????§??????????C????????????????????°????????¨???????£???¶\n    }\n    // O(1)\n    // ??????x[i]?????¢???????????????\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n// ????????¨\nclass Tree {\npublic:\n    static const int MAXLOGV = 25;\n    vector<vector<int> > m_edges; // m_edges[i][j]????????¨: i->j??????????????¨\n    int vn; // ???????????°, vn<2^MAXLOGV\n    int root; // ?????????????????????\n\n    vector<vector<int>> parent; // parent[i][j]: j???i^2???????????????j=0??§??´????????????\n    vector<int> depth; // depth[i]: ??????i?????????????????±???, ??????0\n\n    vector<int> euler; // ??????????§????????????????????????¢???\n    vector<int> f; // f[i] = euler??§i???????????????1???????????????\n    vector<int> s; // f[i] = euler??§i???????????????2???????????????\n\n    /*********/\n    // ?§????\n    /*********/\n    Tree(int vn, int root) : vn(vn), root(root) {\n        parent.resize(MAXLOGV);\n        m_edges.resize(vn);\n        for (int i = 0; i < MAXLOGV; i++) parent[i].resize(vn);\n        depth.resize(vn);\n    }\n    // ?????????????§????\n    // TODO parent?????\\?????´??°??????????????????????????????????????????????????????????????????\n    void unite(int u, int v) {\n        m_edges[u].push_back(v);\n        m_edges[v].push_back(u);\n    }\n    // root???????????±?????¨???????¢???????\n    // unite???????????£??????????????????????????¶?????¨???\n    void init() {\n        euler.clear(); euler.reserve(2 * vn);\n        f.clear(); f.resize(vn);\n        s.clear(); s.resize(vn);\n        dfs(root, -1, 0);\n        for (int k = 0; k+1 < MAXLOGV; k++) { // 2^k??£?\\????????¨????\n            for (int v = 0; v < vn; v++) {\n                if (parent[k][v] < 0) parent[k+1][v] = -1; // 2^k??£????????????????¶???????????????????2^(k+1)??£????????????????????????????¶?????????????\n                else parent[k+1][v] = parent[k][parent[k][v]]; // 2^(k+1)??£????????????2^k??£?????????2^k??£?????????\n            }\n        }\n    }\n    // ?????£????????¨??±???????¢????????????????\n    void dfs(int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        f[v]=euler.size();\n        euler.push_back(v);\n        for (int next : m_edges[v]) {\n            if (next != p) dfs(next, v, d+1);\n        }\n        s[v]=euler.size();\n        euler.push_back(v);\n    }\n\n    /*********/\n    // ?????¨???\n    /*********/\n    // ??????u, v???????°???±???????\\?\n    //\n    // O(log n)\n    int lca(int u, int v) const {\n        if (depth[u] > depth[v]) swap(u, v); // u?????????????????????????????????\n        for (int k = 0; k < MAXLOGV; k++)    // v???u??¨????????±????????§??????\n            if ((depth[v] - depth[u])>>k & 1) \n                v = parent[k][v];\n        if (u == v) return u;\n        for (int k = MAXLOGV-1; k >= 0; k--) { // ????????????????????????????????§??????\n            if (parent[k][u] == parent[k][v]) // ????????????\n                continue; \n            u = parent[k][u];\n            v = parent[k][v];\n        }\n        return parent[0][u];\n    }\n    // u??¨v????????¢????±???????\n    // ?????¢?????¨?????????????????§????????????????§??????°??§??????\n    //\n    // O(log n)\n    int dist(int u, int v) const {\n        int p = lca(u, v);\n        return (depth[u]-depth[p]) + (depth[v]-depth[p]);\n    }\n    // [root, v]????????????f???????????????????????´?????????????????????\n    //\n    // O(log n)\n    // 1???????????????????????????-1????????????\n    int binary_search(int v, function<bool(int)> f) {\n        for(int j = MAXLOGV - 1; j >= 0;j--) \n            if(parent[j][v] != -1) {\n                if (f(parent[j][v])) {\n//                    cout << j << \" \" << v << \"#hit\" << endl;\n                    v = parent[j][v];\n                } else {\n//                    cout << j << \" \" << v << \"#not hit\" << endl;\n                }\n            }\n        return (f(v) ? v : -1);\n    }\n    // ??¨????§??????????\n    void print_dfs(int v, int p) {\n        for (int i = 0; i < depth[v]; i++)\n            cout << \" \";\n        cout << v << endl;\n        for (int next : m_edges[v]) if (next != p) \n            print_dfs(next, v);\n    }\n    void print(void) {\n        print_dfs(root, -1);\n    }\n\n};\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n\n    ll n, q; \n    while (cin >> n >> q && n && q) {\n        Tree t(n, 0);\n        rep(i, n-1) {\n            ll tmp; cin >> tmp;\n            t.unite(i+1, tmp-1); \n        }\n        t.init();\n\n        fenwick_tree<ll> ft(n*2);\n        ft.update(t.f[0], 1);\n        ft.update(t.s[0], -1);\n\n        ll ret = 0;\n        rep(_, q) {\n            char c; ll v; cin >> c >> v; v--;\n            if (c == 'M') {\n                if (ft.access(t.f[v]))\n                    continue;\n                ft.update(t.f[v], 1);\n                ft.update(t.s[v], -1);\n            } else {\n                ll marked_num = ft.query(t.f[v]);\n                ret += t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1; \n//                cout << t.binary_search(v, [&](ll x){ return ft.query(t.f[x]) == marked_num; }) + 1 << endl;\n            }\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint size = 0, value[100000], parents[100000];\nbool ignore[100000], is_mark[100000], is_root[100000];\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int child, int parent) {\n\t\tuf[child] = find(parent);\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\ninline void push(int x) {\n\tvalue[size++] = x;\n}\n\ninline int pop() {\n\treturn value[--size];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tcin >> parents[i];\n\t\t\t--parents[i];\n\t\t}\n\n\t\tmemset(is_root, false, sizeof(is_root));\n\t\tmemset(ignore, false, sizeof(ignore));\n\t\tis_root[0] = true;\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tpush(--v);\n\t\t\tif(ope == 'Q')\n\t\t\t\tis_mark[i] = false;\n\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tif(is_root[v])\n\t\t\t\t\tignore[i] = true;\n\t\t\t\telse\n\t\t\t\t\tis_root[v] = true;\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parents[i]);\n\n\t\tlong long ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tint v = pop();\n\n\t\t\tif(is_mark[i]) {\n\t\t\t\tif(!ignore[i])\n\t\t\t\t\tuf.unite(v, parents[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tans += uf.find(v) + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\n\nvoid create_UF(int size) {\n\tfor (int i = 0; i < size; i++) {\n\t\tmarked_ancestor[i] = i;\n\t}\n}\n\nint getroot(int a) {\n\tif (a == marked_ancestor[a])return a;\n\treturn marked_ancestor[a] = getroot(marked_ancestor[a]);\n}\n\nbool is_same_unit(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\t//parent kid\n\tif (is_same_unit(a, b))return;\n\tmarked_ancestor[b] = a;\n}\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tint ancestor[100000] = {}, ismarked[100000] = {};\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tcreate_UF(n);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tunite(getroot(ancestor[i]), i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tmarked_ancestor[0] = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M')unite(getroot(ancestor[outlog[i].second]), outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//for (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int n):data(n,-1){}\n\tint find(int v){\n\t\treturn data[v]<0?v:find(data[v]);\n\t}\n\tbool unite(int u,int v){\n\t\tint ru=find(u),rv=find(v);\n\t\tif(ru==rv) return false;\n\t\tdata[ru]+=data[rv];\n\t\tdata[rv]=ru;\n\t\treturn true;\n\t}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvi ps(n);\n\t\trepi(i,1,n) cin>>ps[i],ps[i]--;\n\t\tvector<tuple<char,int>> qs;\n\t\trep(i,m){\n\t\t\tchar c; cin>>c;\n\t\t\tint v; cin>>v; v--;\n\t\t\tqs.emplace_back(c,v);\n\t\t}\n\t\t\n\t\tvi marked(n);\n\t\tmarked[0]=1;\n\t\tfor(auto q:qs)\n\t\t\tif(get<0>(q)=='M')\n\t\t\t\tmarked[get<1>(q)]++;\n\t\t\n\t\tUnionFind uf(n);\n\t\trep(i,n) if(!marked[i])\n\t\t\tuf.unite(ps[i],i);\n\t\t\n\t\tll res=0;\n\t\tper(i,m){\n\t\t\tchar t; int v; tie(t,v)=qs[i];\n\t\t\tif(t=='M' && --marked[v]==0)\n\t\t\t\tuf.unite(ps[v],v);\n\t\t\tif(t=='Q')\n\t\t\t\tres+=uf.find(v)+1;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass RMQ{\n\tint seg;\n\tvector<P> dat;\n\tpublic:\n\tRMQ(int siz) : seg(1){\n\t\twhile(seg < siz) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = P(0,0);\n\t}\n\tvoid update(int a,int b,P x,int k = 0,int l = 0,int r = -1){\n\t\tif(r == -1) r = seg;\n\t\tif(b <= l || r <= a) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tdat[k] = max(dat[k],x);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,x,k * 2 + 1,l,(l + r) / 2);\n\t\tupdate(a,b,x,k * 2 + 2,(l + r) / 2,r);\n\t}\n\tint get(int i){\n\t\ti += seg - 1;\n\t\tP ret = dat[i];\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tret = max(dat[i],ret);\n\t\t}\n\t\treturn ret.second;\n\t}\n};\n\nclass EulerTour{\n\tint cnt;\n\tvector<int> first,last,depth;\n\tvector<vector<int> > g;\n\tpublic:\n\tEulerTour(int siz) : first(siz),last(siz),g(siz),depth(siz){}\n\tvoid add(int u,int v){\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvoid dfs(int v,int par){\n\t\tif(par == -1) depth[v] = 0;\n\t\telse depth[v] = depth[par] + 1;\n\t\tfirst[v] = cnt++;\n\t\tfor(int to : g[v]){\n\t\t\tif(to == par) continue;\n\t\t\tdfs(to,v);\n\t\t}\n\t\tlast[v] = cnt++;\n\t}\n\tint build(int root){\n\t\tcnt = 0;\n\t\tdfs(root,-1);\n\t\treturn cnt;\n\t}\n\tP get(int v){\n\t\treturn P(first[v],last[v]);\n\t}\n\tint dep(int v){\n\t\treturn depth[v];\n\t}\n};\n\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d %d\",&n,&m),n){\n\t\tll ans = 0ll;\n\t\tEulerTour et(n);\n\t\tfor(int i = 1;i < n;i++){\n\t\t\tint p;\n\t\t\tscanf(\"%d\",&p);\n\t\t\tet.add(i,p - 1);\n\t\t}\n\t\tRMQ rmq(et.build(0) + 1);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tscanf(\"\\n%c %d\",&c,&v); v--;\n\t\t\tif(c == 'M'){\n\t\t\t\tP p = et.get(v);\n\t\t\t\trmq.update(p.first,p.second + 1,P(et.dep(v),v));\n\t\t\t}\n\t\t\telse ans += rmq.get(et.get(v).first) + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        int res = -1;\n        while(v != -1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf){\n                res = it->second;\n                break;\n            } else {\n                v = goUp(v);\n            }\n        }\n        return res;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q'){\n                ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            } else {\n                marks.insert(mp(-d, qv[i]));\n            }\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q'){\n                ans += h.query(qv[i]) + 1;\n            } else {\n                h.mark(qv[i]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100001;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n\n    for(int i = 0; i < MAX; i++)\n      mark[i] = 0;\n\n  }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  int ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nconst int maxn=100005;\nint n,q;\nint a[maxn];\nint flag[maxn];\nint find1(int x)\n{\n    if(flag[x])\n        return x;\n    else\n        return find1(a[x]);\n}\nint main()\n{\n    while (scanf(\"%d%d\",&n,&q)!=EOF&&(n||q))\n    {\n        memset (flag,0,sizeof(flag));\n        for (int i=1;i<=n;i++)\n                a[i]=i;\n        for (int i=2;i<=n;i++)\n        {\n            scanf(\"%d\",&a[i]);\n        }\n        long long int sum=0;\n        flag[1]=1;\n        for (int i=0;i<q;i++)\n        {\n            char s[3];\n            int xx;\n            scanf(\"%s\",s);\n            scanf(\"%d\",&xx);\n            if(s[0]=='Q')\n            {\n                sum+=find1(xx);\n            }\n            else\n            {\n                flag[xx]=1;\n            }\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] =  find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y; // parent of x is y\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    long long int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 18;\n#define int long long\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=0;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n     dat[k]=p;\n  }else{\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  }\n}\n\nvector<int> G[MAX_N];\nint st[MAX_N],en[MAX_N],de[MAX_N];\nint pos=0;\nvoid dfs(int v,int p=-1,int d=0){\n  de[v]=d;\n  st[v]=pos++;\n  for(auto i:G[v]) if(i!=p) dfs(i,v,d+1);\n  en[v]=pos;\n}\n\nvoid update(int k,P p){\n  update(st[k],en[k],p);\n}\n\nsigned main(){\n  int _n,q;\n  while(cin>>_n>>q,_n||q){\n    for(int i=0;i<MAX_N;i++) G[i].clear();\n    init(_n+1);\n    for(int i=1;i<_n;i++) {\n      int p;\n      cin>>p;\n      p--;\n      G[p].push_back(i);\n      G[i].push_back(p);\n    }\n    dfs(0);\n    int ans=0;\n    for(int i=0;i<q;i++){\n      char c;\n      int u;\n      cin>>c>>u;\n      u--;\n      if(c=='M') update(u,P(de[u],u));\n      else ans+=query(u)+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define int long long\nusing namespace std;\nstatic const int MAX_N = 100000;\nstatic const int inf  = 1ll<<60;\nstatic const int MAX_SEG=1<<17;\ntypedef pair<int,int> pii;\n\nint N,Q;\nvector<int> g[MAX_N+5];\nint root;\nint depth[MAX_N+5];\nint par[21][MAX_N];\n\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    depth[v]=d;\n    for(int u=0;u<g[v].size();++u){\n        if(g[v][u]!=p)dfs(g[v][u],v,d+1);\n    }\n}\n\nvoid fill_table(){\n    for(int i=0;i<20;i++){\n        for(int j=0;j<N;j++){\n            if(par[i][j]==-1)par[i+1][j]=-1;\n            else par[i+1][j]=par[i][par[i][j]];\n        }\n    }\n}\n\nint LCA(int u,int v){\n    if(depth[u]>depth[v])swap(u,v);\n    for(int i=0;i<20;++i){\n        if((depth[v]-depth[u])>>i&1)v=par[i][v];\n    }\n    if(v==u)return u;\n    for(int i=20;i>=0;--i){\n        if(par[i][v]!=par[i][v]){\n            u=par[i][u];\n            v=par[i][v];\n        }\n    }\n    return par[0][u];\n}\n\nsigned main(){\n    cin>>N;\n    for(int i=0;i<N;++i){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;++j){\n            int c;\n            cin>>c;\n            g[i].PB(c);\n        }\n    }\n    dfs(root,-1,0);\n    fill_table();\n    cin>>Q;\n    while(Q--){\n        int u,v;\n        cin>>u>>v;\n        cout<<LCA(u,v)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\nconst int INF=0x3f3f3f3f;\n#define N 200005\n\nint p[N],m[N];\n\nint find(int x){\n\tif(m[x]!=0)return x;\n\telse return p[x]=find(p[x]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,q;\n\twhile(cin>>n>>q){\n\t\tif(n==0&&q==0)break;\n\t\tmemset(p,0,sizeof(p));\n\t\tmemset(m,0,sizeof(m));\n\t\tp[1]=1;\n\t\tm[1]=-1;\n\t\tfor (int i = 0; i < n-1; i++){\n\t\t\tcin>>p[i+2];\n\t\t}\n\t\tvector<pair<char,int>> st;\n\t\twhile(q--){\n\t\t\tchar t;\n\t\t\tint x;\n\t\t\tcin>>t>>x;\n\t\t\tst.push_back({t,x});\n\t\t\tif(t=='M'&&m[x]==0){\n\t\t\t\tm[x]=st.size();\n\t\t\t}\n\t\t}\n\t\tll sum=0;\n\t\tfor(int i=st.size()-1;i>=0;i--){\n\t\t\tif(st[i].fi=='M'){\n\t\t\t\tif(m[st[i].se]==i+1)m[st[i].se]=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum+=find(st[i].se);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ------ lib ------ //\n\n#include <cstdio>\n#include <string>\n\n#pragma warning(disable: 4996)\n\nusing namespace std;\nstring ID = \"1\";\n\nFILE *in = freopen((\"./in\" + ID + \".txt\").c_str(), \"r\", stdin);\nFILE *out = freopen((\"./out\" + ID + \".txt\").c_str(), \"w\", stdout);\n\n// ------ end ------ //\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000], R[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)K[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint D = i;\n\t\t\tfor (int j = 0; j < 50; j++) D = a[i];\n\t\t\tR[i] = D;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M' && K[i] != 1)UF.unite(a[K[i]], K[i]);\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\tbool flag = true;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\tsum += D; flag = false; break;\n\t\t\t\t\t}\n\t\t\t\t\tD = a[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nint rak[100001],par[100001],p[100001];\n\nbool mark[100001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    }\n  }\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n    }else{\n    return find(par[x]);\n    }\n  }\n\nint findancestor(int x){\n  if(mark[par[x]]){\n    return par[x];\n    }else{\n      return findancestor(par[x]);\n    }\n  }\n  \nvoid unite(int x,int y){\n   x=find(x);\n   y=find(y);\n   if(x==y) return;\n   \n   if(rak[x]<rak[y]){\n     par[y]=x;\n     }else{\n     par[y]=x;         \n     if(rak[x]==rak[y]) rak[x]++;\n     }\n  }\n\nint main() {\n  \n  while(1){\n\n   int N,Q;  scanf(\"%d %d\",&N,&Q);\n   \n   if(N==0&&Q==0) break;\n   \n   memset(mark,0,sizeof(mark));\n   \n   init(N);   mark[1]=1;\n   \n   for(int i=1; i<=N-1; i++){\n     int x; cin>>x;\n     p[i+1]=x;\n     }\n     \n   for(int i=N; i>=2; i--){\n     unite(p[i],i);\n     }\n     \n   long long ans=0;\n     \n   for(int i=0; i<Q; i++){\n     \n     char t; cin>>t;\n     \n       if(t=='M'){\n       \n        int v; cin>>v; mark[v]=1;\n       \n       }else if(t=='Q'){\n         \n        int v; cin>>v; \n        ans+=findancestor(v);\n         \n       }\n     \n     }\n               \n              cout<<ans<<endl;\n              \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    int n,q;\n    stack<pair<char,int> > qu;\n    cin>>n>>q;\n    UF uf(n);\n    for(int i=1;i<n;i++)\n    {\n        int p;\n        cin>>p;\n        (uf.c[p-1]).push_back(i);\n    }\n    for(int i=0;i<q;i++)\n    {\n        char temp;\n        int v;\n        cin>>temp>>v;\n        qu.push(P(temp,v-1));\n        if(temp=='M') uf.mark(v-1);\n    }\n    int a,b;\n    cin>>a>>b;\n    uf.furiwake(0);\n    \n    ll ans=0;\n    for(int i=0;i<q;i++)\n    {\n        pair<char,int> a=qu.top();\n        qu.pop();\n        if(a.first=='Q')\n        {\n            ans+=uf.score(a.second);\n        }\n        else\n        {\n            uf.delmark(a.second);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (sizeOf(x) < sizeOf(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint sizeOf(int x) { return -parent[root(x)]; }\n};\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, Q; cin >> N >> Q&&N;) {\n\t\tvector<int> p(N); rep(i, 1, N) {\n\t\t\tcin >> p[i]; p[i]--;\n\t\t}\n\t\tvector<char> c(Q);\n\t\tvector<int> a(Q);\n\t\tvector<bool> mark(N);\n\t\tmark[0] = true;\n\t\trep(i, 0, Q) {\n\t\t\tcin >> c[i] >> a[i];\n\t\t\ta[i]--;\n\t\t\tif (c[i] == 'M')mark[a[i]] = true;\n\t\t}\n\t\tdump(mark);\n\t\tUnionFind uf(N);\n\t\tvector<int> anc(N);\n\t\tiota(all(anc), 0);\n\t\trep(i, 0, N) {\n\t\t\tif (!mark[i]) {\n\t\t\t\tint t = anc[uf.root(p[i])];\n\t\t\t\tuf.unite(i, p[i]);\n\t\t\t\tanc[uf.root(i)] = t;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trrep(i, 0, Q) {\n\t\t\tif (c[i] == 'Q')\n\t\t\t\tans += anc[uf.root(a[i])] + 1;\n\t\t\telse {\n\t\t\t\tint t = anc[uf.root(p[a[i]])];\n\t\t\t\tuf.unite(a[i], p[a[i]]);\n\t\t\t\tanc[uf.root(a[i])] = t;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nconst P idnt=P(-1,-1);\n\nclass segtree {\npublic:\n\tsegtree (int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=idnt;\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,P a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tP query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return idnt;\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tP vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tP vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<P> _dat;\n};\n\nvector<ll> marked;\nvector<vector<ll>> queried;\nvector<ll> dpt;\nvector<vector<ll>> adj;\nll n,q;\n\nvoid dpt_fill(ll pos, ll par, ll d) {\n\tdpt[pos]=d;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdpt_fill(adj[pos][i],pos,d+1);\n\t}\n}\n\nll dfs(ll pos, ll par, segtree& segt) {\n\tif(marked[pos]!=-1) segt.update(marked[pos],P(dpt[pos],pos));\n\tll ret=0;\n\tREP(i,(ll)queried[pos].size()) {\n\t\tP tmp=segt.query(0,queried[pos][i]);\n\t\tif(tmp==idnt) ret++;\n\t\telse ret+=tmp.second+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tret+=dfs(adj[pos][i],pos,segt);\n\t}\n\tif(marked[pos]!=-1) segt.update(marked[pos],idnt);\n\treturn ret;\n}\n\nll solve() {\n\tmarked.assign(n,-1);\n\tqueried.assign(n,vector<ll>(0));\n\tdpt.assign(n,0);\n\tadj.assign(n,vector<ll>(0));\n\tsegtree segt(q);\n\tFOR(i,1,n) {\n\t\tll p;\n\t\tcin>>p;\n\t\tp--;\n\t\tadj[i].pb(p);\n\t\tadj[p].pb(i);\n\t}\n\tREP(i,q) {\n\t\tchar ty;\n\t\tll p;\n\t\tcin>>ty>>p;\n\t\tp--;\n\t\tif(ty=='M') if(marked[p]==-1) marked[p]=i;\n\t\tif(ty=='Q') queried[p].pb(i);\n\t}\n\tdpt_fill(0,-1,0);\n\treturn dfs(0,-1,segt);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define int_ int64_t\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=100010;\nint n,q,v;\nchar buf[4];\nvector<int> g[N];\nint p[N],dsu[N];\nbool marked[N];\n\nint fi(int x) {\n    return dsu[x]==x?x:(dsu[x]=fi(dsu[x]));\n}\n\nvoid dfs(int x,int ma) {\n    if (marked[x]) {\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],x);\n        }\n    } else {\n        dsu[x]=ma;\n        for (int i=0;i<g[x].size();i++) {\n            dfs(g[x][i],ma);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&q);\n        if (n==0&&q==0) break;\n        memset(p,0,sizeof(p));\n        memset(marked,0,sizeof(marked));\n        for (int i=1;i<=n;i++) {\n            dsu[i]=i;\n            g[i].clear();\n        }\n        for (int i=2;i<=n;i++) {\n            scanf(\"%d\",&v);\n            p[i]=v;\n            g[v].pb(i);\n        }\n        vector<PII> op;\n        for (int i=1;i<=q;i++) {\n            scanf(\"%s%d\",buf,&v);\n            op.pb(mp(buf[0]=='Q',v));\n            if (buf[0]=='M') marked[v]=1;\n        }\n        marked[1]=1;\n        dfs(1,1);\n        ll ans=0;\n        for (int i=q-1;i>=0;i--) {\n            if (op[i].first) {\n                ans+=fi(op[i].second);\n            } else {\n                int r=fi(p[op[i].second]);\n                dsu[op[i].second]=r;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long \nusing namespace std;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\nconst int MAX_V = 100010;\nconst int MAX_LOG_V = 30;\n\nstruct BIT{\n    int N;\n    vector<int> dat;\n    BIT() {}\n    BIT(int n) {\n        N = n;\n        dat.resize(N + 1);\n    }\n    // update k th element (0-index)\n    void add(int k, int x){\n        k++;\n        while(k <= N){\n            dat[k] += x;\n            k += k&-k;\n        }\n    }\n    // sum [0, k) (0-index)\n    int sum(int k){\n        int s = 0;\n        while(k > 0){\n            s += dat[k];\n            k -= k&-k;\n        }\n        return s;\n    }\n    // sum [a, b) (0-index)\n    int query(int a, int b){\n        return sum(b) - sum(a);\n    }\n};\n\nint n, q;\nvector<int> G[MAX_V]; \n\nclass Euler_Tour{\npublic:\n    // vector<vector<int> > g;\n    //begin[v],end[v]はそれぞれvがオイラーツアー上で最初と最後に現れるインデックス\n    //[begin[v], end[v])がvを根とする部分木 (半開区間に注意)\n    vector<int> euler_tour, begin, end, dist;\n    Euler_Tour(int n) : /*g(n),*/ begin(2 * n), end(2 * n){};\n    int k = 0, root = 0;\n    void dfs(int curr, int par){\n        begin[curr] = k;\n        euler_tour.push_back(curr);\n        k++;\n        for(auto next : G[curr]){\n            if(next == par) continue;\n            dfs(next, curr);\n            euler_tour.push_back(curr);\n            k++;\n        }\n        end[curr] = k;\n    }\n};\n\nint root = 0;\nint parent[MAX_LOG_V][MAX_V];\nint depth[MAX_V];\n\nvoid dfs2(int v, int p, int d){\n    parent[0][v] = p;\n    depth[v] = d;\n    for(int i = 0; i < G[v].size(); i++){\n        if(G[v][i] != p) dfs2(G[v][i], v, d + 1);\n    }\n}\n\nvoid init(int V){\n    memset(depth, 0, sizeof(depth));\n    for(int i = 0; i < MAX_LOG_V; i++){\n        for(int j = 0; j < MAX_V; j++){\n            parent[i][j] = 0;\n        }\n    }\n    dfs2(root, -1, 0);\n    for(int k = 0; k + 1 < MAX_LOG_V; k++){\n        for(int v = 0; v < V; v++){\n            if(parent[k][v] < 0) parent[k + 1][v] = -1;\n            else parent[k + 1][v] = parent[k][parent[k][v]];\n        }\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> q;\n        if(n + q == 0) break;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 1, n){\n            int v;\n            cin >> v;\n            v--;\n            G[v].push_back(i);\n            G[i].push_back(v);\n        }\n        vector<bool> marked(n);         \n        Euler_Tour et(n);\n        et.dfs(0, -1);\n        init(n);\n        BIT bt(2 * n);\n        // mark 0\n        marked[0] = true;\n        bt.add(et.begin[0], 1);\n        bt.add(et.end[0] - 1, -1);\n        int ans = 0;\n        rep(i, 0, q){\n            char c; int v;\n            cin >> c >> v;\n            v--;\n            if(c == 'M'){\n                marked[v] = true;\n                bt.add(et.begin[v], 1);\n                bt.add(et.end[v] - 1, -1);\n            }else{\n                int tmp = 0;\n                // check v is marked\n                if(marked[v]){\n                    tmp = v;\n                }else{\n                    int nowv = v;\n                    for(int k = MAX_LOG_V - 1; k >= 0; k--){\n                        int tmpv = parent[k][nowv];\n                        if(tmpv == -1) tmpv = 0;\n                        int val = bt.query(et.begin[tmpv], et.begin[v]);\n                        if(val <= 0){\n                            nowv = tmpv;\n                        }\n                    }\n                    tmp = parent[0][nowv];\n                    if(tmp < 0) tmp = 0;     \n                }\n                ans += (tmp + 1);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nint dfs(int x){\n\tBEGIN_STACK_EXTEND(32*1024*1024);\n\tfor( int i : M[x] ) near[i] = x;\n\tfor( int i : Q[x] ){\n\t\tint a = (*(--near.lower_bound(i))).second;\n\t\tans += a+1;\n\t}\n\tfor( auto c : ch[x] ) dfs(c);\n\tfor( int i : M[x] ) near.erase(i);\n\tEND_STACK_EXTEND\n\treturn 0;\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear();\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\nusing namespace std;\n\nint find(int v, int *T);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tT[1] = 1;\n\t\tfor(int i=2; i<=N; i++) cin >> T[i];\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(v, T); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n\nint find(int v, int *T){\n\tint ans = v;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint pars[100000];\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q;\n  while(cin >> N >> Q, N){\n\tpars[0] = 0;\n\tREP(i,N-1){\n\t  int p;\n\t  cin >> p;\n\t  --p;\n\t  pars[i+1] = p;\n\t}\n\t\n\tvector<bool> marked(N);\n\tmarked[0] = true;\n\tvector<PII> qs(Q);\n\tREP(q,Q){\n\t  char c;\n\t  int pyon;\n\t  cin >> c >> pyon;\n\t  --pyon;\n\t  qs[q] = MP(c == 'M'?0: 1, pyon);\n\t  if(c == 'M') marked[pyon] = true;\n\t}\n\n\tUnionFind uf(N);\n\tVI rt(N);\n\tiota(ALL(rt), 0);\n\tREP(i,N){\n\t  if(!marked[i]){\n\t\tint nrt = rt[uf.find(pars[i])];\n\t\tuf.unite(i, pars[i]);\n\t\trt[uf.find(i)] = nrt;\n\t  }\n\t}\n\n\tLL ans = 0;\n\tfor(int q=Q-1;q>=0;--q){\n\t  int u = qs[q].SS;\n\t  if(qs[q].FF == 0){\n\t\tint nrt = rt[uf.find(pars[u])];\n\t\tuf.unite(u, pars[u]);\n\t\trt[uf.find(u)] = nrt;\n\t  }\n\t  else{\n\t\tans += rt[uf.find(u)]+1;\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int MAX_N=100010;\nint par[MAX_N];\nint rnk[MAX_N];\n\nvoid init(int n){\n  REP(i,n){\n    par[i]=i;\n    rnk[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(rnk[x]<rnk[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(rnk[x]==rnk[y]) rnk[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\nint n,q;\nint par2[100010];\npair<char,int> query[100010];\nint main(){ _;\n  while(cin>>n>>q,n|q){\n    par[1]=1;\n    REP(i,n-1) cin>>par[i+2],par2[i+2]=par[i+2];\n    for(int i=q-1;i>=0;i--){\n      cin>>query[i].first>>query[i].second;\n      if(query[i].first=='M') par[query[i].second]=query[i].second;\n    }\n    int sum=0;\n    REP(i,q){\n      if(query[i].first=='M') unite(par2[query[i].second],query[i].second);\n      else sum+=find(query[i].second);\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    HeavyLightDecomposition(int n_ = 0) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\nint n,q;\nchar qt[100010];\nint qv[100010];\nHeavyLightDecomposition h;\n\nll solve(){\n    ll ans = 0;\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        h = HeavyLightDecomposition(n);\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            h.addEdge(par-1,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][20],ff[100000],ss[100000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint find(vector<int> par, int k){\n  if(par[k] == k) return k;\n  return par[k] = find(par,par[k]);\n}\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N){\n    vector<int> par(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n    int p[N-1];\n    for(int i = 0; i < N-1; ++i){\n      cin >> p[i];\n      par[i+1] = p[i]-1;\n    }\n    vector< pair<char,int> > Query;\n    char c;\n    int k;\n    for(int i = 0; i < Q; ++i){\n      cin >> c >> k;\n      --k;\n      if(c == 'M') par[k] = k;\n    Query.push_back(make_pair(c,k));\n    }\n    reverse(Query.begin(),Query.end());\n    int ans = 0;\n    for(int i = 0; i < Q; ++i){\n      c = Query[i].first;\n    k = Query[i].second;\n    if(c == 'Q') ans += find(par,k)+1;\n    else par[find(par,k)] = par[p[par[find(par,k)]-1]];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nint v[444444], dep[444444], bg[444444], ed[444444];\nvector<int> edges[444444];\nchar st[111];\nvector<pair<int, int> > st0;\nvoid build(int k, int l, int r) {\n\tv[k] = 1;\n\tif(l != r) {\n\t\tbuild(k + k, l, (l + r) / 2);\n\t\tbuild(k + k + 1, (l + r) / 2 + 1, r);\n\t}\n}\nvoid renew(int k, int l, int r, int ql, int qr, int x) {\n\tif (qr < l || r < ql) {\n\t\treturn ;\n\t}\n\tif (ql <= l && r <= qr) {\n\t\tif (dep[x] > dep[v[k]]) {\n\t\t\tv[k] = x;\n\t\t}\n\t\treturn ;\n\t}\n\tint mid = (l + r) / 2;\n\trenew(k << 1, l, mid, ql, qr, x);\n\trenew(k << 1 | 1, mid + 1, r, ql, qr, x);\n}\n\nint ask(int k, int l, int r, int pos) {\n\tif (l == r) {\n\t\treturn v[k];\n\t}\n\tint mid = (l + r) / 2;\n\tint res;\n\tif (pos <= mid) {\n\t\tres = ask(k << 1, l, mid, pos);\n\t} else {\n\t\tres = ask(k << 1 | 1, mid + 1, r, pos);\n\t}\n\tif (dep[v[k]] > dep[res]) {\n\t\treturn v[k];\n\t} else {\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tfor(;;) {\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n and !m) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i(1); i <= n; i++) {\n\t\t\tedges[i].clear();\n\t\t}\n\t\tfor(int i(2); i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tedges[x].push_back(i);\n\t\t}\n\t\tst0.clear();\n\t\tst0.push_back(make_pair(1, 0));\n\t\tdep[1] = 0;\n\t\tbg[1] = 1;\n\t\tint l(1);\n\t\twhile(!st0.empty()) {\n\t\t\tint v(st0.back().first), p(st0.back().second++);\n\t\t\tif(p != (int)edges[v].size()) {\n\t\t\t\tst0.push_back(make_pair(edges[v][p], 0));\n\t\t\t\tdep[edges[v][p]] = dep[v] + 1;\n\t\t\t\tbg[edges[v][p]] = ++l;\n\t\t\t}else {\n\t\t\t\ted[v] = l;\n\t\t\t\tst0.pop_back();\n\t\t\t}\n\t\t}\n\t\tbuild(1, 1, n);\n\t\tlong long ans(0);\n\t\tfor(int i(1); i <= m; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\", st, &x);\n\t\t\tif(st[0] == 'M') {\n\t\t\t\trenew(1, 1, n, bg[x], ed[x], x);\n\t\t\t}else {\n\t\t\t\tans = ans + ask(1, 1, n, bg[x]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*Marked Ancestor????§£????????????????????????????????????????????????????????¨????????¨??¨??????????????§?????????????????????????????§??????????????????\n?????°???????????????????????????:1???????????????*/\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n,q;\nlong long par[100005];\nvector<long long> child[100005];\nqueue<P> mna;//marked nearest ancestor\nlong long mark[100005];\nlong long query[100005];\nlong long qquery[100005];\nlong long mnalist[100005];\nstring s;\nlong long ans;\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,100005)\n\t\t{\n\t\t\tmark[i]=0;\n\t\t\tquery[i]=0;\n\t\t\tqquery[i]=0;\n\t\t\tchild[i].clear();\n\t\t\tpar[i]=0;\n\t\t\tmnalist[i]=0;\n\t\t}\n\t\tans=0;\n\t\tcin>>n>>q;\n\t\tif(n==0)break;\n\t\trep(i,n-1)\n\t\t{\n\t\t\tcin>>par[i+1];\n\t\t\tpar[i+1]--;\n\t\t\tchild[par[i+1]].push_back(i+1);\n\t\t}\n\t\tmark[0]=1;\n\t\trep(i,q)\n\t\t{\n\t\t\tcin>>s>>qquery[i];\n\t\t\tqquery[i]--;\n\t\t\tif(s==\"M\")\n\t\t\t{\n\t\t\t\tquery[i]=1;\n\t\t\t\tmark[qquery[i]]++;\n\t\t\t}\n\t\t}\n\t\tmna.push(P(0,0));\n\t\tmnalist[0]=0;\n\t\twhile(!mna.empty())\n\t\t{\n\t\t\tP p=mna.front();mna.pop();\n\t\t\trep(i,child[p.first].size())\n\t\t\t{\n\t\t\t\tif(mark[child[p.first][i]]==1)\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=child[p.first][i];\n\t\t\t\t\tmna.push(P(child[p.first][i],child[p.first][i]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=p.second;\n\t\t\t\t\tmna.push(P(child[p.first][i],p.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long person;\n\t\tfor(long long kkk=q-1;kkk>=0;kkk--)\n\t\t{\n\t\t\tif(query[kkk]==1)\n\t\t\t{\n\t\t\t\tmark[qquery[kkk]]--;\n\t\t\t\tif(mark[qquery[kkk]]==0)mnalist[qquery[kkk]]=mnalist[par[qquery[kkk]]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tperson=mnalist[qquery[kkk]];\n\t\t\t\twhile(person!=mnalist[person])\n\t\t\t\t{\n\t\t\t\t\tperson=mnalist[person];\n\t\t\t\t}\n\t\t\t\tans+=(person+1);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nPath compression happens \nwhen no node on the path is marked before query happens\n*/\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 1e5 + 16;\n\nint p[MAXN], mark[MAXN], qt[MAXN], qv[MAXN];\n// mark[i] is the time node i is marked\n// qt[q] is the time query q happens\n// qv[q] is the node of query q\nint t;\n\nint find(int i) {\n    return mark[i] < t ? i : p[i] = find(p[i]);\n}\n\nint main() {\n    //freopen(\"2170-input.txt\", \"r\", stdin);\n    int N, Q;\n    while (~scanf(\"%d%d\", &N, &Q) && (N | Q)) {\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", p + i);\n            mark[i] = INF;\n        }\n        int cnt = 0, x;\n        char op[2];\n        for (int i = 1; i <= Q; i++) {\n            scanf(\"%s%d\", op, &x);\n            if (op[0] == 'M') {\n                mark[x] = min(i, mark[x]);\n            } else {\n                qt[cnt] = i;\n                qv[cnt++] = x;\n            }\n        }\n        unsigned long long result = 0;\n        while (cnt--) {\n            t = qt[cnt];\n            result += find(qv[cnt]);\n        }\n        printf(\"%lld\\n\", result);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\tlong long ans;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tans=0;\n\t\tSet[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=1LL*Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int MAX = 110000;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n+2 ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n  bool mark[MAX];\n\n  while(cin >> n >> q ,n + q){\n    stack<P> st;\n    fill(mark,mark+MAX,false);\n    mark[1] = true;\n    long long sum = 0;\n    init(n);\n    par[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'M'){\n\tmark[num] = true;\n      }\n      st.push(P(ch,num));\n    }\n    for(int i = 2 ; i <= n ; i++){\n      if(!mark[i]) unite(par[i],i);\n    }\n\n    while(!st.empty()){\n      P p = st.top(); st.pop();\n\n      if(p.first == 'Q'){\n\tsum += find(p.second)+1;\n      }\n      else{\n\tmark[p.second] = false;\n\tunite(par[p.second],p.second);\n      }\n    }\n      cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint parents[100010];\nint ranks[100010];\n\n// trees[x] -> y, x?????????y\n// ??\\???????????¨?§?????????±\nint trees[100010]; \n\nvoid initUnionFind() {\n    for (int i=0; i<100010; ++i) {\n        parents[i] = i;\n        ranks[i] = 1;\n    }\n}\nint findParent(int x) {\n    if (x == parents[x]) return x;\n    return parents[x] = findParent(parents[x]);\n}\n\nint main() {\n    int N,Q;\n\n    while (cin >> N >> Q) {\n        if (N == 0 && Q == 0) break;\n\n        initUnionFind();\n        for (int i=0; i<100010; ++i) trees[i] = i;\n\n        for (int i=0; i<N-1; ++i) {\n            int p; cin >> p;\n            parents[i + 2] = p;\n            trees[i + 2] = p;\n        }\n\n        vector<pair<char, int> > queries;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            // ????????????????????????????????????\n            if (ope == 'M' && parents[v] == v) continue;\n\n            // ???????????????\n            if (ope == 'M') {\n                parents[v] = v;\n            }\n            queries.push_back( make_pair(ope, v) );\n        }\n\n        // ???????????????\n        reverse( queries.begin(), queries.end() );\n        long long ans = 0;\n        for (int i=0; i<queries.size(); ++i) {\n            if (queries[i].first == 'M') {\n                // mark??????????????????node??¨??£???\n                parents[queries[i].second] = trees[queries[i].second];\n            } else {\n                // ope = 'Q'\n                ans += findParent(queries[i].second);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tvector<int> parent(n, -1);\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tint input;\n\t\t\tcin >> input;\n\t\t\tparent[i] = --input;\n\t\t}\n\n\t\tstack<int> mark, query;\n\t\tvector<bool> is_mark(q, false);\n\t\tvector<bool> is_root(n, false);\n\t\tis_root[0] = true;\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tif(ope == 'Q')\n\t\t\t\tquery.push(v);\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tis_root[v] = true;\n\t\t\t\tmark.push(v);\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tint ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tif(is_mark[i]) {\n\t\t\t\tint v = mark.top();\n\t\t\t\tmark.pop();\n\t\t\t\tuf.unite(v, parent[v]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint v = query.top();\n\t\t\t\tquery.pop();\n\t\t\t\tans += uf.find(v) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nint rak[100001],par[100001],p[100001];\n\nbool mark[100001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    }\n  }\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n    }else{\n    return find(par[x]);\n    }\n  }\n\nint findancestor(int x){\n  if(mark[x]){\n    return x;\n    }else{\n      return findancestor(par[x]);\n    }\n  }\n  \nvoid unite(int x,int y){\n   x=find(x);\n   y=find(y);\n   if(x==y) return;\n   \n   if(rak[x]<rak[y]){\n     par[y]=x;\n     }else{\n     par[y]=x;         \n     if(rak[x]==rak[y]) rak[x]++;\n     }\n  }\n\nint main() {\n  \n  while(1){\n\n   int N,Q;  scanf(\"%d %d\",&N,&Q);\n   \n   if(N==0&&Q==0) break;\n   \n   memset(mark,0,sizeof(mark));\n   \n   init(N);   mark[1]=1;\n   \n   for(int i=1; i<=N-1; i++){\n     int x; cin>>x;\n     p[i+1]=x;\n     }\n     \n   for(int i=N; i>=2; i--){\n     unite(p[i],i);\n     }\n     \n   long long ans=0;\n     \n   for(int i=0; i<Q; i++){\n     \n     char t; cin>>t;\n     \n       if(t=='M'){\n       \n        int v; cin>>v; mark[v]=1;\n       \n       }else if(t=='Q'){\n         \n        int v; cin>>v; \n        ans+=findancestor(v);\n         \n       }\n     \n     }\n               \n              cout<<ans<<endl;\n              \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\npublic:\n    vector<int> par;\n    UnionFind(vector<int> par) : par(par) {}\n    int get_root(int i) {\n        if (par[i] == i) return i;\n        return par[i] = get_root(par[i]);\n    }\n    void set_root(int i, int root) {\n        par[i] = get_root(root);\n    }\n};\n\nint main()\n{\n    while (1) {\n        int n, q; cin >> n >> q;\n        if (!n) break;\n\n        vector<int> par(n);\n        loop (n-1, i) {\n            cin >> par[i+1];\n            par[i+1]--;\n        }\n\n        vector<char> type(q);\n        vector<int> val(q);\n        loop (q, i) {\n            cin >> type[i] >> val[i];\n            val[i]--;\n        }\n\n        vector<int> marked(n);\n        loop (q, i) {\n            if (type[i] == 'M') {\n                if (marked[val[i]]) type[i] = 'x';\n                else marked[val[i]] = 1;\n            }\n        }\n\n        vector<int> ufpar(n);\n        loop (n, i) {\n            if (marked[i]) ufpar[i] = i;\n            else ufpar[i] = par[i];\n        }\n\n        UnionFind UF(ufpar);\n\n        ll ans = 0;\n        loop (q, i) {\n            int j = q - 1 - i;\n            if (type[j] == 'Q') {\n                ans += UF.get_root(val[j]) + 1;\n            }\n            if (type[j] == 'M') {\n                UF.set_root(val[j], par[val[j]]);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nstruct UnionFind\n{\nprivate:\n  vi data;\n  int cnt;\n\npublic:\n  UnionFind(const int size) : data(size, -1), cnt(size) {}\n  bool unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x != y){\n      data[x] += data[y];\n      data[y] = x;\n      cnt -= 1;\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return root(x) == root(y); }\n  int root(int x){ return data[x] < 0 ? x : data[x] = root(data[x]); }\n  int size(int x){ return -data[root(x)]; }\n  int group(){ return cnt; }\n};\n\nconst int MAX_Q = 111111;\nconst int MAX_N = 111111;\nint N, Q;\nint q[MAX_Q];\nint p[MAX_N];\npair<char, int> query[MAX_N];\nbool flag[MAX_N];\n\nint main()\n{\n  while(cin >> N >> Q, Q){\n    rep(i, N) flag[i] = false;\n\n    UnionFind uf(N);\n    p[0] = 0;\n    rep(i, N - 1) cin >> p[i + 1],  p[i + 1] -= 1;\n    rep(i, Q) cin >> query[i].first >> query[i].second, query[i].second -= 1;\n\n    rep(i, Q) if(query[i].first == 'M') if(flag[query[i].second]) query[i].first = 'a'; else flag[query[i].second] = true;\n    rep(i, N) if(!flag[i]) uf.unite(p[i], i);\n    ll res = 0LL;\n    rev(i, Q){\n      if(query[i].first == 'M') uf.unite(p[query[i].second], query[i].second);\n      if(query[i].first == 'Q') res += (ll)uf.root(query[i].second) + 1LL;\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\nint query(int i)\n{\n\tint par = tree[i];\n\twhile(!ar[par])\n\t\tpar = tree[par];\n\treturn par;\n}\nint main()\n{\n\tint n,q,par;\n\twhile(scanf(\"%d%d\",&n,&q)==2&&n|q)\n\t{\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&par);\n\t\t\ttree[i] = par;\n\t\t}\n\t\tgetchar();\n\t\tchar cmd;\n\t\tint a;\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t{\n\t\t\tscanf(\"%c%d\",&cmd,&a);getchar();\n\t\t\tif(cmd=='M')ar[a] = true;\n\t\t\tif(cmd=='Q')sum += query(a);\n\t\t}\n\t\tprintf(\"sum = %lld\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nint N, Q;\nint p[MAX_N+5];\nbool M[MAX_N+5];\nint uf_par[MAX_N+5];\nint uf_rank[MAX_N+5];\nint mark[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < N; i++) {\n        uf_par[i] = i;\n        uf_rank[i] = 0;\n        mark[i] = i;\n        p[i] = 0;\n        M[i] = false;\n    }\n}\n\nint find(int x) {\n    if (uf_par[x] == x) {\n        return x;\n    } else {\n        return uf_par[x] = find(uf_par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(uf_rank[x] < uf_rank[y]) {\n        uf_par[x] = y;\n        mark[y] = mark[x];\n    } else {\n        uf_par[y] = x;\n        if(uf_rank[x] == uf_rank[y]) uf_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid debug() {\n    for(int i = 0; i < N; i++) {\n        cout << i << \": \" << mark[i] << \": \" << find(i) << \": \" << mark[find(i)] << endl;\n    }\n}\n\nint main() {\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        init(N);\n        for(int i = 1; i < N; i++) {\n            cin >> p[i];\n            p[i]--;\n        }\n        vector<P> query;\n        char qm;\n        int num;\n        for(int i = 0; i < Q; i++) {\n            cin >> qm >> num;\n            num--;\n            if(qm == 'M') {\n                M[num] = true;\n            }\n            query.push_back(P(qm, num));\n        }\n\n        for(int i = 0; i < N; i++) {\n            if(!M[i]) {\n                // cout << \"unite \" << p[i] << \": \" << i << endl;\n                // cout << M[i] << endl;\n                unite(p[i], i);\n                // debug();\n            }\n        }\n\n        // cout << \"====\" << endl;\n        int count = 0;\n        for(int i = query.size()-1; i >= 0; i--) {\n            int n = query[i].second;\n            if(query[i].first == 'M') {\n                // cout << \"unite \" << p[n] << \": \" << n << endl;\n                unite(p[n], n);\n                // debug();\n            } else {\n                count += mark[find(n)] + 1;\n                // cout << \"n: \" << n << \" count += \" << mark[find(n)] << endl;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    int n;\n    vector<int> parent; // 親ノード\n    vector<int> num;    // グループの要素数\npublic:\n    UnionFindTree(int n0){ // コンストラクタ\n        n = n0;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        num.assign(n, 1);\n    }\n    void unite(int x, int y){ // xとyのグループを併合\n        if((x = find(x)) != (y = find(y))){\n            parent[y] = x;\n            num[x] += num[y];\n            -- n;\n        }\n    }\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, q;\n        cin >> n >> q;\n        if(n == 0)\n            return 0;\n\n        vector<int> parent(n+1, -1);\n        for(int i=2; i<=n; ++i)\n            cin >> parent[i];\n\n        vector<char> ope(q);\n        vector<int> v(q);\n        vector<int> cnt(n+1, 0);\n        for(int i=0; i<q; ++i){\n            cin >> ope[i] >> v[i];\n            if(ope[i] == 'M')\n                ++ cnt[v[i]];\n        }\n\n        UnionFindTree uft(n+1);\n        for(int i=2; i<=n; ++i){\n            if(cnt[i] == 0)\n                uft.unite(parent[i], i);\n        }\n\n        long long ret = 0;\n        for(int i=q-1; i>=0; --i){\n            if(ope[i] == 'Q'){\n                ret += uft.find(v[i]);\n            }else if(-- cnt[v[i]] == 0 && v[i] != 1){\n                uft.unite(parent[v[i]], v[i]);\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint pars[20][100000];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q;\n  while(cin >> N >> Q, N){\n\tpars[0][0] = 0;\n\tREP(i,N-1){\n\t  int p;\n\t  cin >> p;\n\t  --p;\n\t  pars[0][i+1] = p;\n\t}\n\t\n\tfor(int i=1;i<20;++i)\n\t  REP(u,N)\n\t\tpars[i][u] = pars[i-1][pars[i-1][u]];\n\tvector<bool> marked(N);\n\tmarked[0] = true;\n\t\n\tLL ans = 0;\n\tREP(q,Q){\n\t  char c;\n\t  int pyon;\n\t  cin >> c >> pyon;\n\t  --pyon;\n\t  if(c == 'M'){\n\t\twhile(!marked[pyon]){\n\t\t  marked[pyon] = true;\n\t\t  pyon = pars[0][pyon];\n\t\t}\n\t  }\n\t  else{\n\t\tfor(int i=19;i>=0;--i){\n\t\t  if(!marked[pars[i][pyon]])\n\t\t\tpyon = pars[i][pyon];\n\t\t}\n\t\tpyon = pars[0][pyon];\n\t\tans += pyon+1;\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\n#define maxn 100000\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[maxn+5];\nint node[maxn + 5];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemset(node, 0, sizeof(node));\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tLL sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tnode[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')node[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (node[a] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],pa[MAXN],n,m,used[MAXN];\nlong long ans;\nchar c;\npair<int,int> a[MAXN];\nint get_fa(int x){\n    if(fa[x]==0)\n        return x;\n    fa[x]=get_fa(fa[x]);\n    return fa[x];\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    while(n*m!=0){\n        for(int i=2;i<=n;i++)\n            SF(\"%d\",&pa[i]);\n        int x;\n        for(int i=1;i<=m;i++){\n            SF(\"\\n\");\n            SF(\"%c\",&c);\n            SF(\"%d\",&x);\n            if(c=='M'){\n                a[i].first=0;\n                a[i].second=x;\n                used[x]=1;\n            }\n            else{\n                a[i].first=1;\n                a[i].second=x;\n            }\n        }\n        for(int i=2;i<=n;i++)\n            if(used[i]==0)\n                fa[i]=get_fa(pa[i]);\n        for(int i=m;i>=1;i--){\n            if(a[i].first==0)\n                fa[i]=get_fa(pa[i]);\n            else\n                ans+=get_fa(i);\n        }\n        PF(\"%lld\\n\",ans);\n        SF(\"%d%d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    p[0]=ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint un[100000];\nint find(int x){\n  if(x==un[x]) return x;\n  return un[x]=find(un[x]);\n}\n\nvoid unit(int a,int b){\n  un[find(a)]=find(b);\n}\n\nint pa[100000];\n\nint main(){\n  int n,q;\n  while(cin >> n >> q && n){\n    rep(i,n-1){\n      cin >> pa[i+1];\n      --pa[i+1];\n      un[i+1]=pa[i+1];\n    }\n  \n    vector<PI> que;\n    ll ans=0;\n    rep(i,q){\n      char ch;\n      int a;\n      cin >> ch >> a;\n      --a;\n      assert(a);\n      que.pb(mp(ch,a));\n      if(ch=='M') un[a]=a;\n    }\n\n    reverse(ALL(que));\n    FOR(it,que){\n      if(it->F=='M') unit(it->S,pa[it->S]);\n      else ans+=find(it->S)+1;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt n,q;\nlnt queri[100000][2];\nbool marked[100000];\nlnt par[100000];\nvoid init(void)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t}\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\t\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tx=find(x);\n\ty=find(y);\n\tpar[x]=y;\n\treturn;\n}\n\nchar str[10];\nlnt anc[100000];\nlnt depth[100000];\nvector<lnt> to[100000];\nlnt m;\n\nvoid defdep(lnt x,lnt y){\n\tdepth[x]=y;\n\tfor(lnt i=0;i<to[x].size();i++) defdep(to[x][i],y+1);\n}\n\nint main()\n{while(1){\n\tlnt ans=0;\n\tinit();\n\tscanf(\"%lld%lld\",&n,&q);\n\tif(!n&&!q) return 0;\n\tfor(lnt i=0;i<n;i++) to[i].clear();\n\tmemset(marked,0,sizeof(marked));\n\tfor(lnt i=1;i<n;i++){\n\t\tscanf(\"%lld\",&anc[i]);\n\t\tanc[i]--;\n\t\tto[anc[i]].push_back(i);\n\t}\n\tdefdep(0,0);\n\tmarked[0]=1;\n\tfor(lnt i=0;i<q;i++){\n\t\tscanf(\"%s%lld\",str,&queri[i][1]);\n\t\tqueri[i][1]--;\n\t\tif(*str=='M'){\n\t\t\tqueri[i][0]=1;\n\t\t\tmarked[queri[i][1]]=1;\n\t\t}\n\t\telse queri[i][0]=0;\n\t}\n\tfor(lnt i=0;i<n;i++){\n\t\tm=i;\n\t\twhile(!marked[m]&&!same(m,anc[m])){\n\t\t\tunite(m,anc[m]);\n\t\t\tm=anc[m];\n\t\t}\n\t}\n\tfor(lnt i=q-1;i>=0;i--){\n\t\tif(queri[i][0]){\n\t\t\tunite(queri[i][1],anc[queri[i][1]]);\n\t\t}\n\t\telse{\n\t\t\tm=queri[i][1];\n\t\t\tans+=depth[m]-depth[find(m)];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n, q;\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\tif(p <= 0 || n < p) return;\n\n\troot[p] = v;\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\tif( root[edge[p][i]] == edge[p][i] ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tupdate(edge[p][i], v);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> q, n||q) {\n\t\troot.clear();\n\t\tedge.clear();\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = 1;\n\t\tll sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\nconst int B = 450;\n\nint N, Q;\nstd::vector<int> G[100100];\nint start[100100], friends[100100];\nint buckets[450], parts[200200];\nint doubling[17][100100];\n\nvoid makeDoubling(){\n    for(int i=0;i+1<=16;++i){\n        for(int j=1;j<=N;++j){\n            if(doubling[i][j] == -1){\n                doubling[i+1][j] = -1;\n            }else{\n                doubling[i+1][j] = doubling[i][doubling[i][j]];\n            }\n        }\n    }\n}\n\nvoid dfs(int v, int& n){\n    start[v] = n++;\n    \n    for(int u : G[v]){\n        dfs(u, n);\n    }\n\n    friends[v] = n++;\n}\n\nvoid update(int l, int r){\n    while(l % B > 0){\n        ++parts[l];\n        ++l;\n    }\n\n    while(r % B > 0){\n        --r;\n        ++parts[r];\n    }\n\n    l /= B;\n    r /= B;\n\n    while(l < r){\n        ++buckets[l];\n        ++l;\n    }\n}\n\ninline int query2(int v){\n    return buckets[start[v] / B] + parts[start[v]];\n}\n\nint query(int v){\n    int lb = 0, ub = 100100, res = v;\n\n    while(std::abs(ub - lb) > 1){\n        int mid = (lb + ub) / 2;\n        int x = v, y = mid, z = 0;\n\n        while(y > 0){\n            if(x != -1 && y % 2 == 1){\n                x = doubling[z][x];\n            }\n            ++z;\n            y >>= 1;\n        }\n        \n        if(x != -1 && query2(x) == query2(v)){\n            lb = mid;\n            res = x;\n        }else{\n            ub = mid;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N >> Q;\n\n    memset(doubling[0], -1, sizeof(doubling[0]));\n    \n    for(int i=0;i<N-1;++i){\n        int p;\n        std::cin >> p;\n\n        G[p].emplace_back(i+2);\n        doubling[0][i+2] = p;\n    }\n\n    makeDoubling();\n\n    // for(int i=0;i<16;++i){\n    //     printf(\"# %d\\n\", i);\n    //     for(int j=1;j<=N;++j){\n    //         printf(\"%d\\n\", doubling[i][j]);            \n    //     }\n    // }\n    \n    int ET_N = 0;\n    dfs(1, ET_N);\n\n    update(start[1], friends[1]);\n    \n    // {\n        // int v = 3;\n        // update(start[v], friends[v]);\n    // }    \n    // for(int v = 1;v<=N;++v){\n    //     int q = query(v);\n    //     printf(\"%d\\n\", q);\n    // }\n    // exit(0);\n\n    ll sum = 0;\n    for(int i=0;i<Q;++i){\n        std::string q;\n        int v;\n        std::cin >> q >> v;\n\n        if(q[0] == 'M'){\n            update(start[v], friends[v]);\n        }else{\n            sum += query(v);\n            // printf(\"%d\\n\", query(v));\n        }\n    }\n\n    printf(\"%lld\\n\", sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\tcin >> n >> q;\n\tint a[100000];\n\tfor(int i=0;i<n-1;i++){\n\t\tcin >> a[i];\n\t}\n\tmap<int,int> roots;\n\tvector<pair<char,int>> queries;\n\tfor(int i=0;i<q;i++){\n\t\tchar c;\n\t\tint v;\n\t\tcin >> c >> v;\n\t\tif(c == 'M') roots[i+2] = v;\n\t\tqueries.emplace_back(make_pair(c,v));\n\t}\n\tUnionFind uf(n);\n\tfor(int i=0;i<n-1;i++){\n\t\tif(roots.find(i+2) == roots.end()){\n\t\t\tuf.unionSet(i+2,roots[i+2]);\n\t\t}\n\t}\n\tint sum = 0;\n\tfor(int i=q-1;i>=0;i--){\n\t\tif(queries[i].first == 'M'){\n\t\t\tuf.unionSet(i+2,queries[i].second);\n\t\t}\n\t\tif(queries[i].first == 'Q'){\n\t\t\tsum += uf.root(queries[i].second);\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[100005];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tfa[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')fa[a] = a;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (fa[a] != a)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(x);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nbool marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tscanf(\"%d\",fa+i);\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;marked[id]=1;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nvector<int> G[100001];\nint node_vals[100001];\n\nint dfs(int cur,int root){\n  for(int i=0;i<G[cur].size();i++){\n    int to = G[cur][i];\n    node_vals[to] = root;\n    dfs(to,root);\n  }\n}\n\nint main(){\n  int total_nodes;\n  int total_queries;\n  while(~scanf(\"%d %d\",&total_nodes,&total_queries)){\n    if(total_nodes == 0 && total_queries == 0) break;\n\n    for(int i=0;i<=100000;i++) G[i].clear();\n    fill(node_vals,node_vals+100001,1);\n\n    for(int node_idx = 2;node_idx-1<total_nodes;node_idx++){\n      int parent;\n      scanf(\"%d\",&parent);\n      G[parent].push_back(node_idx);\n    }\n    int sum = 0;\n    for(int query_idx=0;query_idx < total_queries; query_idx++){\n      char operation[2];\n      int node_val;\n      scanf(\"%s %d\",operation,&node_val);\n      if(operation[0] == 'M'){\n\tdfs(node_val,node_val);\n      }\n      else if(operation[0] == 'Q'){\n\tsum += node_vals[node_val];\n      }\n    }\n\n    printf(\"%d\\n\",sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\nbool marked[MAX_N+5];\n\nvoid init(int N) {\n    for(int i = 0; i <= MAX_N; i++) {\n        par[i] = i;\n        par2[i] = i;\n        marked[i] = false;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nvoid show_par() {\n    for(int i = 1; i <= N; i++) {\n        cout << i << \": \" << par[i] << \", \";\n    }\n    cout << endl;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par2[i] = p;\n        }\n        vector<P> v;\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                marked[t] = true;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            v.push_back(q);\n        }\n\n        // solve\n        for(int i = 1; i <= N; i++) {\n            if(!marked[i]) unite(par2[i], i);\n        }\n        long long int ans = 0;\n        // show_par();\n        for(int i = v.size()-1; i >= 0; i--) {\n            if(v[i].first == 'M') {\n                unite(par2[v[i].second], v[i].second);\n            } else {\n                ans += find(v[i].second);\n            }\n            // cout << v[i].first << \" \" << v[i].second << endl;\n            // show_par();\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\nset<int> s;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tmarked[t[i]]=true;\n\tif(s.find(t[i])==s.end()) s.insert(t[i]);\n\telse c[i]='E';\n      }\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M'&&t[i]!=1) marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint g[100010];\nbool a[100010];\n\nint f(int v) {\n\t//cout << v << endl;\n\tif(a[v]) return v;\n\treturn f(g[v]);\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tint n, q;\n\t\tcin >> n >> q;\n\t\tif(!n && !q) break;\n\t\tREP(i, n-1) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tg[i+2] = a;\n\t\t}\n\t\tmemset(a, false, sizeof(a));\n\t\ta[1] = true;\n\t\tll su = 0;\n\t\tREP(i, q) {\n\t\t\tchar c;\n\t\t\tint t;\n\t\t\tcin >> c >> t;\n\t\t\tif(c == 'Q') su += f(t);\n\t\t\telse a[t] = true;\n\t\t}\n\t\tcout << su << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][18],ff[100000],ss[100000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tlong long ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\", ans);\n}\n  \nint main()\n{\n  Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(long i=0; i<(n); i++)\n#define dmp(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nbool m[100000];\nlong a[100000];\nchar com[100000];\nlong d[100000];\n\nlong calc(int n)\n{\n  if(m[n])\n    return n;\n  else\n    return calc(a[n]);\n}\n\nint main()\n{\n  int N,Q;\n  scanf(\"%d %d\", &N, &Q);\n  for(int i=2;i<N+1;i++){\n    scanf(\"%ld\",a+i);\n  }\n  m[1]=1;\n  rep(i,Q){\n    scanf(\" %c %ld\", com+i,d+i);\n  }\n\n  long long ret=0;\n\n  rep(i,Q) switch(com[i]) {\n  case 'M':\n    m[d[i]]=true;\n    break;\n  case 'Q':\n    ret += calc(d[i]);\n  }\n  printf(\"%lld\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nll n,q,u,t[Q],p[Q],ans;\nbool marked[Q];\nchar c[Q];\n\nint find(int x){\n  if(marked[p[x]]) return p[x];\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n#define inf 0x7f7f7f7f\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c;\n\tlong sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = nn = 1; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'M' && mark[x] > i)\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i = nn - 1, sum = 0; i >= 1; i--)\n\t\t{\n\t\t\ttt = qt[i];\n\t\t\tsum += find(qx[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q;\nlong long ans;\n// int Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\nbool marked[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n\n// int find(int x) {\n//   if (par[x] == x) return x;\n//   else return par[x] = find(par[x]);\n// }\n\nint search(int x) {\n  // int a = par[x];\n  if (x < 0 || x > N) return 0;\n  if (marked[x]) return x;\n  else return search(par[x]);\n}\n\n// void unite(int x, int y) {\n//   par[find(x)] = find(y);\n// }\n\n// bool same(int x, int y) {\n//   return find(x) == find(y);\n// }\n\nvoid solve() {\n  ans = 0;\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    \n    if (ope == 'M') {\n      marked[num] = true;\n    }\n    \n    else if(ope == 'Q'){\n      ans += search(num);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n  \nint main()\n{\n  marked[1] = true;\n  int num;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    init();\n    \n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &num);\n      //unite(num,i);\n      par[i] = num;\n      marked[i] = false;\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll D = 20;\nll p[D][100000];\n\nll s[100000], t[100000];\nvector<ll> E[100000];\n\nvoid dfs(ll v, ll &d) {\n  s[v] = d++;\n  for(ll u : E[v]) dfs(u, d);\n  t[v] = d;\n}\n\ntemplate<typename T, typename E> class LazySegmentTree {\npublic:\n  typedef function<T (T, T)> Operator;\n  typedef function<E (E, E)> Merge;\n  typedef function<T (T, E)> Apply;\n  typedef function<E (E, ll)> Product;\n\n  vector<T> data;\n  vector<E> lazy;\n  ll n;        // size of elements (2^x alignment)\n  T e;         // identity of monoid\n  Operator op; // binary operator of monoid\n  E d;         // identity of effect\n  Merge merge; // merge effects\n  Apply apply; // apply effect to monoid\n  Product p;   // calculate effect * n\n\n  // construction with size of elements\n  LazySegmentTree(ll _n, T e, Operator op, E d, Merge merge, Apply apply, Product p):\n    e(e), op(op), d(d), merge(merge), apply(apply), p(p) {\n    for(n = 1; n < _n; n *= 2);\n    data.resize(n * 2 - 1, e);\n    lazy.resize(n * 2 - 1, d);\n  }\n\n  // construction with initial values\n  LazySegmentTree(const vector<T> &vec, T e, Operator op, E d, Merge merge, Apply apply, Product p):\n    e(e), op(op), d(d), merge(merge), apply(apply), p(p) {\n    for(n = 1; n < (ll) vec.size(); n *= 2);\n    data.resize(n * 2 - 1, e);\n    lazy.resize(n * 2 - 1, d);\n    REP(i, 0, vec.size()) data[i + n - 1] = vec[i];\n    for(ll i = n - 2; i >= 0; i--) data[i] = op(data[i * 2 + 1], data[i * 2 + 2]);\n  }\n\n  // evaluate lazy update\n  void eval(ll k, ll l, ll r) {\n    if(r - l > 1) {\n      lazy[k * 2 + 1] = merge(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = merge(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = apply(data[k], p(lazy[k], r - l));\n    lazy[k] = d;\n  }\n\n  // query for [a, b)\n  T query(ll a, ll b) { return query(a, b, 0, 0, n); }\n  T query(ll a, ll b, ll k, ll l, ll r) {\n    eval(k, l, r);\n    if(r <= a || b <= l) return e;\n    if(a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return op(vl, vr);\n  }\n\n  // update values of [a, b)\n  T update(ll a, ll b, E x) { return update(a, b, x, 0, 0, n); }\n  T update(ll a, ll b, E x, ll k, ll l, ll r) {\n    eval(k, l, r);\n    if(r <= a || b <= l) return data[k];\n    if(a <= l && r <= b) {\n      lazy[k] = merge(lazy[k], x);\n      return apply(data[k], p(lazy[k], r - l));\n    }\n    T vl = update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    T vr = update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    return data[k] = op(vl, vr);\n  }\n};\n\nint main(void) {\n  ll N, Q;\n  while(cin >> N >> Q) {\n    if(N == 0 && Q == 0) break;\n    REP(i, 0, 100000) E[i].clear();\n    REP(i, 1, N) {\n      cin >> p[0][i], p[0][i]--;\n      E[p[0][i]].push_back(i);\n    }\n\n    REP(i, 0, D - 1) REP(j, 0, N) {\n      if(p[i][j] != -1) p[i + 1][j] = p[i][p[i][j]];\n      else p[i + 1][j] = -1;\n    }\n\n    ll d = 0;\n    dfs(0, d);\n\n    LazySegmentTree<ll, ll>::Operator op = [](ll a, ll b) { return a + b; };\n    LazySegmentTree<ll, ll>::Merge merge = [](ll x, ll y) { return x + y; };\n    LazySegmentTree<ll, ll>::Apply apply = [](ll a, ll x) { return a + x; };\n    LazySegmentTree<ll, ll>::Product _p = [](ll x, ll n) { return x; };\n    LazySegmentTree<ll, ll> segtree(N, 0, op, 0, merge, apply, _p);\n\n    ll ans = 0;\n    REP(i, 0, Q) {\n      string I;\n      ll v;\n      cin >> I >> v; v--;\n\n      if(I == \"Q\") {\n        ll u = v;\n        for(ll i = D - 1; i >= 0; i--) {\n          if(p[i][u] != -1 && segtree.query(s[u], s[u] + 1) == segtree.query(s[p[i][u]], s[p[i][u]] + 1)) {\n            u = p[i][u];\n          }\n        }\n        ans += u + 1;\n      }\n      if(I == \"M\") {\n        segtree.update(s[v], t[v], 1);\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\n#define reep(i,n,m) for(int i = n;i < m;i++)\n#define rep(i,m) for(int i = 0;i < m;i++)\n#define MAX_N 100000\n\nusing namespace std;\n\ntypedef struct node{\n\tint par;\n\tbool mark;\n\tnode(){\n\t\tpar = 0;\n\t\tmark = false;\n\t}\n\tnode(int _par,int _mark){\n\t\tpar = _par;\n\t\tmark = _mark;\n\t}\n}node;\n\nnode field[MAX_N + 1];\n\nint N,Q;\n\nint ans;\n\nvoid init(){\n\treep(i,0,MAX_N + 1){\n\t\tfield[i].par = i;\n\t\tfield[i].mark = false;\n\t}\n\tfield[1].mark = true;\n\n\treturn ;\n}\n\nint query(int n){\n\t//printf(\"###query to %d\\n\",n);\n\tif(field[n].mark) return n;\n\treturn query(field[n].par);\t\n}\n\nint main(){\n\n\twhile(true){\n\n\tinit();\n\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N == 0 && Q == 0) break;\n\tint _par;\n\tfor(int i = 2;i <= N;i++){\n\t\tscanf(\"%d\",&_par);\n\t\tfield[i].par = _par;\n\t}\n\tans = 0;\n\tchar q;\n\tint node;\n\trep(i,Q){\n\t\tscanf(\" %c%d\",&q,&node);\n\t\t//printf(\"###%c###%d\\n\",q,node);\n\t\tswitch(q){\n\t\tcase 'M':\n\t\t\tfield[node].mark = true;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tans += query(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1147483647;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define gchar(i) scanf(\"%c\",&(i))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n\n//#define my_debug\n\nconst int MAX_N = 100005;\nint all[MAX_N];\nbool stu[MAX_N];\n\nint n, q;\n\nvoid solve(){\n\n}\n\nint get_f(int i){\n\tint out = all[i];\n\tif (stu[out])\n\t\treturn out;\n\telse\n\t\treturn get_f(out);\n}\n\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,q) != EOF){\n\t\tll out = 0;\n\t\tif (n == 0 && q == 0)\n\t\t\tbreak;\n\t\tinit(all, 0);\n\t\tinit(stu, 0);\n\t\tstu[1] = true;\n\t\tall[1] = 1;\n\t\trep(i, 2, (n + 1)){\n\t\t\tgint(all[i]);\n\t\t}\n\t\trep(i, 0, q){\n\t\t\tchar c;\n\t\t\tint tmp;\n\t\t\tgchar(c);\n\t\t\tgchar(c);\n\t\t\tgint(tmp);\n\t\t\tif (c == 'Q'){\n\t\t\t\tout += (ll)get_f(tmp);\n\t\t\t}\n\t\t\telse if (c == 'M'){\n\t\t\t\tstu[tmp] = true;\n\t\t\t}\n\t\t}\n\t\tpint(out);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N]; //i(i = 0,1,2,...,n)?????????node???????????\\????????????\nchar Ope[MAX_N]; //operations?????\\????????????\nint Openum[MAX_N]; //operation??¨??????????????°????????\\????????????\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1, num);\n    }\n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          printf(\"%d\", nodeNum);\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n\n     \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n  Node[1] = 1;\n  for(int i = 2; i <= N; i++){\n    scanf(\"%d\", &Node[i]);\n  }\n  for(int i = 0; i < Q; i++){\n    scanf(\"  %c\", &Ope[i]);\n    scanf(\"%d\", &Openum[i]);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n//------- Union-Find木 ---------\nvector<int> par; // 親\n// 初期化\nvoid init(int n) {\n  par = vector<int>(n);\n  par[0] = 0;\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  par[x] = y;\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n//-------------------\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  // ifstream cin (\"2170_input.txt\");\n  int N, Q;\n  while (1) {\n    cin >> N >> Q;\n    if (!(N | Q)) break;\n    init(N);\n    int a, i;\n    for (i = 1; i < N; i++) {\n      cin >> a;\n      par[i] = a - 1;\n    }\n    vector<pair<char, int> > query(Q);\n    char q;\n    for (i = 0; i < Q; i++) {\n      cin >> q >> a;\n      query[i] = make_pair(q, a);\n    }\n\n    // 先にマークする。つまり木を分離する。親となるノードを覚えておく。\n    // 同じノードに2回以上マークしている場合も考慮する。\n    map<int, int> ori_par;\n    map<int, int> ori_par_cnt;\n    for (i = 0; i < Q; i++) {\n      if (query[i].first == 'M') {\n        a = query[i].second - 1;\n        if (!ori_par_cnt.count(a)) {\n          ori_par[a] = par[a];\n          ori_par_cnt[a] = 1;\n          par[a] = a;\n        } else {\n          ori_par_cnt[a]++;\n        }\n      }\n    }\n\n    // クエリを後ろから処理する\n    long long sum = 0;\n    reverse(query.begin(), query.end());\n    for (i = 0; i < Q; i++) {\n      a = query[i].second - 1;\n      if (query[i].first == 'Q') {\n        sum += find(a) + 1;\n      } else if (query[i].first == 'M') {\n        if (ori_par_cnt[a] == 1) {\n          unite(a, ori_par[a]);\n        } else {\n          ori_par_cnt[a]--;\n        }\n      }\n    }\n\n    // 出力\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <stack>\n#include <vector>\nusing namespace std;\nvector<tuple<int, bool>> tree; //parent,marked\nstack<int> tmp_s;\n\nint n_marked(int index)\n{\n    while (!get<1>(tree[index]))\n    {\n        tmp_s.push(index);\n        index = get<0>(tree[index]);\n    }\n    while (!tmp_s.empty())\n    {\n        get<0>(tree[tmp_s.top()]) = index;\n        tmp_s.pop();\n    }\n    return index;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    int size, n_opr, parent;\n    while (1)\n    {\n        //scanf(\"%d %d\", &size, &n_opr);\n        cin >> size >> n_opr;\n        if (size == 0)\n            break;\n        uintmax_t result(0);\n        tree.clear();\n        tree.push_back(make_tuple(0, true));\n        vector<tuple<char, int>> op_s;\n        for (int i = 0; i < size - 1; i++)\n        {\n            //scanf(\"%lld\", &parent);\n            cin >> parent;\n            tree.push_back(make_tuple(parent - 1, 0));\n        }\n        for (int i = 0; i < n_opr; i++)\n        {\n            char cmd;\n            int opr;\n            //scanf(\"%c %d\", &cmd, &opr);\n            cin >> cmd >> opr;\n            if (cmd == 'M')\n            {\n                if (get<1>(tree[opr - 1]) == false)\n                {\n                    get<1>(tree[opr - 1]) = true;\n                    op_s.push_back(make_tuple(cmd, opr));\n                }\n                else\n                {\n                    continue;\n                }\n            }\n            else\n            {\n                op_s.push_back(make_tuple(cmd, opr));\n            }\n        }\n        while (!op_s.empty())\n        {\n            auto op = op_s.end() - 1;\n            char cmd = get<0>(*op);\n            int opr = get<1>(*op);\n            if (cmd == 'Q')\n            {\n                result += (n_marked(opr - 1) + 1);\n            }\n            else\n            {\n                get<1>(tree[opr - 1]) = false;\n            }\n            op_s.erase(op);\n        }\n        cout << result << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\n#define LL long long\n#define reep(i,n,m) for(int i = n;i < m;i++)\n#define rep(i,m) for(int i = 0;i < m;i++)\n#define MAX_N 100000\n\nusing namespace std;\n\ntypedef struct node{\n\tint par;\n\tbool mark;\n\tnode(){\n\t\tpar = 0;\n\t\tmark = false;\n\t}\n\tnode(int _par,int _mark){\n\t\tpar = _par;\n\t\tmark = _mark;\n\t}\n}node;\n\nnode field[MAX_N + 1];\n\nint N,Q;\n\nLL ans;\n\nvoid init(){\n\treep(i,0,MAX_N + 1){\n\t\tfield[i].par = i;\n\t\tfield[i].mark = false;\n\t}\n\tfield[1].mark = true;\n\n\treturn ;\n}\n\nint query(int n){\n\t//printf(\"###query to %d\\n\",n);\n\tif(field[n].mark) return n;\n\treturn query(field[n].par);\t\n}\n\nint main(){\n\n\twhile(true){\n\n\tinit();\n\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N == 0 && Q == 0) break;\n\tint _par;\n\tfor(int i = 2;i <= N;i++){\n\t\tscanf(\"%d\",&_par);\n\t\tfield[i].par = _par;\n\t}\n\tans = 0;\n\tchar q;\n\tint node;\n\trep(i,Q){\n\t\tscanf(\" %c%d\",&q,&node);\n\t\t//printf(\"###%c###%d\\n\",q,node);\n\t\tswitch(q){\n\t\tcase 'M':\n\t\t\tfield[node].mark = true;\n\t\t\tbreak;\n\t\tcase 'Q':\n\t\t\tans += query(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n#include <cstdio>\n#include <tuple>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\ntemplate <int N>\nstruct UnionFind {\n    int ig[N];\n    int d[N];\n    vector<int> gi[N];\n    int dc;\n    void init(int n = N) {\n        for (int i = 0; i < n; ++i) {\n            ig[i] = d[i] = i;\n            gi[i] = {i};\n        }\n        dc = 0;\n    }\n \n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        dc++;\n        int x = ig[a], y = ig[b];\n        d[x] = d[y];\n        if (gi[x].size() < gi[y].size()) swap(x, y);\n        for (int j: gi[y]) {\n            ig[j] = x;\n        }\n        gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n        gi[y].clear();\n    }\n \n    bool same(int a, int b) {\n        return ig[a] == ig[b];\n    }\n    int get(int a) {\n        return d[ig[a]];\n    }\n};\n\n\nconst int MN = 100100;\nP q[MN];\nint root[MN];\nbool ism[MN];\nUnionFind<MN> uf;\n\nint main() {\n    while (true) {\n        int n, m;\n        scanf(\"%d %d\\n\", &n, &m);\n        if (!n) break;\n        uf.init(n);\n        fill_n(ism, n, false);\n        ism[0] = true;\n        for (int i = 1; i < n; i++) {\n            int u;\n            scanf(\"%d\\n\", &u); u--;\n            //assert(u < i);\n            root[i] = u;\n        }\n        for (int i = 0; i < m; i++) {\n            char c; int d;\n            scanf(\" %c %d\\n\", &c, &d); d--;\n            if (c == 'Q') {\n                q[i] = P(0, d);\n            } else {\n                if (ism[d]) {\n                    q[i] = P(2, d);\n                } else {\n                    ism[d] = true;\n                    q[i] = P(1, d);\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (ism[i]) continue;\n            uf.merge(i, root[i]);\n        }\n        ll res = 0;\n        for (int i = m-1; i >= 0; i--) {\n            int a, b;\n            tie(a, b) = q[i];\n            if (a == 2) continue;\n            if (a == 1) {\n                uf.merge(b, root[b]);\n            } else {\n                res += uf.get(b)+1;\n            }\n        }\n        printf(\"%lld\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\t\tint sn = sqrt(n);\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tint ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].count--;\n\t\t\t\tif (e[v[i]].count == 0) {\n\t\t\t\t\ttb[e[v[i]].m] = e[e[v[i]].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += tb[e[v[i]].m] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll __int64\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,d;\n//#define N 200005\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nint fa[100005];\nint find(int x){\n\treturn x==fa[x]?fa[x]:find(fa[x]);\n}\nint main(){\n    while(sfd(n,m)!=EOF && n+m){\n    \tint x;\n    \tfor(int i=2;i<=n;i++){\n    \t\tsf(fa[i]);\n    \t}\n    \tfa[1]=1;\n    \tll ans=0;\n    \tchar op[5];\n    \tfor(int i=0;i<m;i++){\n    \t\tscanf(\"%s%d\",op,&x);\n    \t\tif(op[0] == 'Q'){\n    \t\t\tans += (ll)find(x);\n    \t\t}else\n    \t\t\tfa[x] = x;\n    \t}\n    \tpfI(ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <fstream>\nconst int MAX = 1e5+10;\nconst int INF = 1e6;\n\nusing namespace std;\n\nint n,m;\nint par[MAX];\nbool mak[MAX];//是否被标记过 \n\n//查询 \nint Find(int x){\n\tint r=x;\n\twhile(r!=par[r])\n\t{\n\t\tr=par[r];\n\t}\n\treturn r;\n}\n\n//测试函数 \nint main(){\n\t/*ifstream cin (\"D:\\\\钢铁程序员\\\\程序数据\\\\061标记父节点.txt\");//从文件读取数据流，省去手动输入的麻烦 \n\tif(!cin){//读取如果失败 \n\t\tcout << \"ERROR\" << endl;\n\t}*/\n\twhile(cin >> n >> m,n&&m){\n\t\tfill(mak,mak+n,false);\n\t\tmak[1] = true;//初始只有根节点标记 \n\t\tpar[1] = 1;\n\t\tfor(int i=2; i<=n; i++)\n\t\t\tcin >> par[i];//i节点的父节点 \n\t\t//opra\n\t\tlong long sum = 0;\n\t\twhile(m--){\n\t\t\tchar c;\n\t\t\tint x;\n\t\t\tcin >> c >> x;\n\t\t\t//M \n\t\t\tif(c == 'M'){\n\t\t\t\tpar[x]=x;\n\t\t\t}\n\t\t\t//Q \n\t\t\telse{\n\t\t\t\tsum += Find(x);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n//\tcin.close();//打开文件以后要关闭 \n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\nbool marked[MAX_N+5];\n\nstack<P> s;\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n        marked[i] = false;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par[i] = p;\n            par2[i] = p;\n        }\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                if(marked[t]) continue;\n                marked[t] = true;\n                par[t] = t;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            s.push(q);\n        }\n\n        // solve\n        long long int ans = 0;\n        while(!s.empty()) {\n            P q = s.top(); s.pop();\n            if(q.first == 'M') {\n                unite(par2[q.second], q.second);\n            } else {\n                ans += find(q.second);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\n\nint used[MAX_N];\nint mark[MAX_N];\nmap<int,vector<int> > child;\n\nvoid dfs(int start,int root){\n    //cout<<used[start]<<start<<endl;\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        //map<int,vector<int> > child;\n        //int used[MAX_N];\n        //int mark[MAX_N];\n        \n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n        \n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        int ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint n, q;\nvector<int> root;\nvector< vector<int> > edge;\n\nvoid update(int p, int v) {\n\tif(p <= 0 || n < p) return;\n\n\troot[p] = v;\n\tfor(int i=0; i<edge[p].size(); i++) {\n\t\tif( root[edge[p][i]] == edge[p][i] ) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tupdate(edge[p][i], v);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> q, n||q) {\n\t\troot.clear();\n\t\tedge.clear();\n\t\troot.resize(n+1);\n\t\tedge.resize(n+1);\n\t\tfor(int i=2; i<=n; i++) {\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\troot[i] = 1;\n\t\t\tedge[p].push_back(i);\n\t\t}\n\t\troot[1] = 1;\n\t\tint sum = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'Q') {\n\t\t\t\tsum += root[v];\n\t\t\t} else if(c == 'M') {\n\t\t\t\tupdate(v, v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int np,bool f){\n  p[v]=np;\n  if(!f){\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],np,!m[v]);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    int s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tm[v]=true;\n\tfor(int i=0;i<t[v].size();i++){\n\t  dfs(t[v][i],v,true);\n\t}\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nint par[100010];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x] = find(par[x]);\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint n,q;\nint par2[100010];\npair<char,int> query[100010];\nint main(){ _;\n  while(cin>>n>>q,n|q){\n    par[1]=1;\n    par2[1]=1;\n    REP(i,n-1) cin>>par2[i+2],par[i+2]=par2[i+2];\n    for(int i=q-1;i>=0;i--){\n      cin>>query[i].first>>query[i].second;\n      if(query[i].first=='M'){\n\tif(par[query[i].second]==query[i].second)\n\t  query[i].first='-';\n\tpar[query[i].second]=query[i].second;\n      }\n    }\n    long long sum=0;\n    REP(i,q){\n      if(query[i].first=='M') par[query[i].second]=par2[query[i].second];\n      else if(query[i].first=='Q') sum+=find(query[i].second);\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//?????¨????????????, UnionFind, ?????????. [Q v?????????]??§???????????°???????????????????????¨, ?????°????????????marked???1????????¨???????????¨?????????.\n#include <iostream>\n#define int long long\nusing namespace std;\n\nclass UF {\n\tint par[100001];\npublic:\n\tvoid init(int n) { for (int i = 0; i < n; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid marge(int x, int y) { x = root(x); y = root(y); par[x] = y; }\n};\n\nint n, q;\nint parent[100000];\npair<char, int> query[100000];\nint markCount[100000];\nUF uf;\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) { markCount[i] = 0; }\n\tuf.init(n);\n}\n\nsigned main() {\n\tint i;\n\t\n\twhile (cin >> n >> q) {\n\t\tif (!n) break;\n\t\tinit(n);\n\t\t\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tcin >> parent[i];\n\t\t\tparent[i]--;\n\t\t}\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tcin >> query[i].first >> query[i].second;\n\t\t\tquery[i].second--;\n\t\t\tif (query[i].first == 'M') {\n\t\t\t\tmarkCount[query[i].second]++;\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tif (!markCount[i]) {\n\t\t\t\tuf.marge(i, parent[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (i = q - 1; i >= 0; i--) {\n\t\t\tint v = query[i].second;\n\t\t\tif (query[i].first == 'M') {\n\t\t\t\tmarkCount[v]--;\n\t\t\t\tif (markCount[v] == 0) uf.marge(v, parent[v]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.root(v) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#define LL long long\n#define L (x << 1)\n#define R (x << 1 | 1)\n#define N 100110\nusing namespace std;\nvector<int> edge[N];\nvector<int> mark[N], query[N];\nint n, m;\nstruct Tree{\n\tstruct node{\n\t\tint v;\n\t}tr[N * 3];\n\tvoid init(){\n\t\tmemset(tr, 0, sizeof(tr));\n\t}\n\tvoid update(int x){\n\t\ttr[x].v = max(tr[L].v, tr[R].v);\n\t}\n\tvoid modify(int x, int a, int b, int pos, int ad){\n\t\tif(a == b){\n\t\t\ttr[x].v = ad;\n\t\t\treturn;\n\t\t}\n\t\tint mid = a + b >> 1;\n\t\tif(pos <= mid) modify(L, a, mid, pos, ad);\n\t\telse modify(R, mid + 1, b, pos, ad);\n\t\tupdate(x);\n\t}\n\tint query(int x, int a, int b, int l, int r){\n\t\tif(l <= a && b <= r) return tr[x].v;\n\t\tint mid = a + b >> 1;\n\t\tif(r <= mid) return query(L, a, mid, l, r);\n\t\telse if(l > mid) return query(R, mid + 1, b, l, r);\n\t\telse return max(query(L, a, mid, l, r), query(R, mid + 1, b, l, r));\n\t}\n}sg;\n\nLL ans = 0;\nint list[N];\nint pos[N], f[N];\nvoid dfs(){\n\tint u = 1, d = 1;\n\tfor(int i = 1; i <= n; i ++) pos[i] = 0;\n\twhile(1){\n\t\tlist[d] = u;\n\t\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\t\tint _index = mark[u][i];\n\t\t\tsg.modify(1, 1, m, _index, d);\n\t\t}\n\t\tfor(int i = 0; i < query[u].size(); i ++){\n\t\t\tint _index = query[u][i];\n\t\t\tint id = sg.query(1, 1, m, 1, _index);\n\t\t\tans = ans + list[id];\n\t\t\t//cout << u << ' ' << id << ' ' << list[id] << endl;\n\t\t}\n\t\tif(pos[u] < edge[u].size()){\n\t\t\tu = edge[u][pos[u] ++];\n\t\t\td ++;\n\t\t}\n\t\telse{ \n\t\t\twhile(1){\n\t\t\t\tif(pos[u] < edge[u].size() || u == 1) break;\n\t\t\t\tfor(int i = 0; i < mark[u].size(); i ++){\n\t\t\t\t\tint _index = mark[u][i];\n\t\t\t\t\tsg.modify(1, 1, m, _index, 0);\n\t\t\t\t}\n\t\t\t\tu = f[u];\n\t\t\t\td --;\n\t\t\t}\n\t\t\tif(pos[u] < edge[u].size()){\n\t\t\t\tu = edge[u][pos[u] ++];\n\t\t\t\td ++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n}\nvoid solve(){\n\tans = 0;\n\tfor(int i = 1; i <= n; i ++){\n\t\tedge[i].clear();\n\t\tquery[i].clear();\n\t\tmark[i].clear();\n\t}\n\tfor(int i = 2; i <= n; i ++){\n\t\tscanf(\"%d\", &f[i]);\n\t\tedge[f[i]].push_back(i);\n\t}\n\t\n\tmark[1].push_back(1);\n\tm ++;\n\tfor(int i = 2; i <= m; i ++){\n\t\tchar str[2];\n\t\tint v;\n\t\tscanf(\"%s%d\", str, &v);\n\t\tif(str[0] == 'Q') query[v].push_back(i);\n\t\telse mark[v].push_back(i);\n\t}\n\t\n\tsg.init();\n\tdfs();\n\t\n\tprintf(\"%lld\\n\", ans);\n}\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m) == 2 && n + m){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\nstruct node {\n\tint id;\n\tint nearmark;\n\tint dis;\n\tvector<int>edges;\n};\n\n\nvector<node>nodes;\nvoid dfs(const int nowid,const int nowdis,const int mark) {\n\tif (nodes[nowid].dis > nowdis) {\n\t\tnodes[nowid].dis = nowdis;\n\t\tnodes[nowid].nearmark = mark;\n\t\tfor (auto nextid : nodes[nowid].edges) {\n\t\t\tdfs(nextid, nowdis + 1, mark);\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tnodes.push_back( node{0,0,0,vector<int>() });\n\tfor (int i = 1; i < N; ++i) {\n\t\tint a; cin >> a; a--;\n\t\tnode anode{ i,nodes[a].nearmark,nodes[a].dis + 1,vector<int>{a} };\n\t\tnodes.push_back(anode);\n\t\tnodes[a].edges.push_back(i);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tchar c; cin >> c;\n\t\tint n; cin >> n;\n\t\tn--;\n\t\tif (c == 'Q') {\n\t\t\tans += nodes[n].nearmark+1;\n\t\t}\n\t\telse {\n\t\t\tdfs(n, 0,n);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct UnionFind {\n  int parent[110000];\n  void unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) { return; }\n    parent[y] = x;\n  }\n  int findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n};\n\nint n, q;\nUnionFind ufind;\nint parent[110000];\nbool mark[110000];\nint query[11000];\n\nint main() {\n  while (scanf(\"%d %d\", &n, &q), n|q) {\n    memset(&ufind, -1, sizeof(ufind));\n    MEMSET(mark, false);\n    parent[0] = 0;\n    REP(i, n -1) {\n      int p;\n      scanf(\"%d\", &p);\n      parent[i + 1] = p - 1;\n    }\n    int m = 0;\n    REP(i, q) {\n      char c;\n      int v;\n      scanf(\" %c %d\", &c, &v);\n      if (c == 'Q') {\n        query[m++] = v;\n      } else if (c == 'M' && !mark[v - 1]) {\n        mark[v - 1] = true;\n        query[m++] = -v;\n      }\n    }\n    REP(i, n) {\n      if (mark[i]) { continue; }\n      ufind.unionSet(parent[i], i);\n    }\n    reverse(query, query + m);\n    ll ans = 0;\n    REP(i, m) {\n      int index = abs(query[i]) - 1;\n      if (query[i] > 0) {\n        ans += ufind.root(index) + 1;\n      } else {\n        ufind.unionSet(parent[index], index);\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 100005;\nint p[N];\nint find(int x)\n{\n\tif(p[x] == x)\treturn x;\n\treturn find(p[x]);\n}\nint main()\n{\n\tint n,q;cin >> n >> q;\n\twhile(n && q)\n\t{\n\t\tlong long res = 0;\n\t\tp[1] = 1;\n\t\tfor(int i = 2;i <= n;++i)\n\t\t\tcin >> p[i];\n\t\tfor(int i = 0;i < q;++i)\n\t\t{\n\t\t\tchar op;int x;\n\t\t\tcin >> op >> x;\n\t\t\tif(op == 'M') p[x] = x;\n\t\t\telse res += (long long)find(x);\n\t\t}\n\t\tcout << res << endl;\n\t\tcin >> n >> q;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001],mpar[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n  fill(mpar, mpar+N+1, 1);\n  \n  marked[1] = 1;\n  par[1] = 0; mpar[1] = 0;\n}\n\nint ans(int v){\n\n  if(marked[par[v]] == 1) return par[v];\n  return mpar[v] = ans(par[v]);\n\n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=2;i<=N;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nconst int MAX_N = 100010;\nint n, q;\nint par[MAX_N];\nchar t[MAX_N];\nint v[MAX_N];\nint cnt[MAX_N];\n\nint lma(int x) {\n    if (cnt[x]) return x;\n    return par[x] = lma(par[x]);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> n >> q, n) {\n        fill(par, par + n, -1);\n        rep2(i, 1, n) {\n            int p;\n            cin >> p;\n            p--;\n            par[i] = p;\n        }\n\n        fill(cnt, cnt + n, 0);\n        cnt[0] = 1;\n        rep(i, q) {\n            cin >> t[i] >> v[i];\n            v[i]--;\n            if (t[i] == 'M') {\n                cnt[v[i]]++;\n            }\n        }\n\n        int ans = 0;\n        rrep(i, q) {\n            if (t[i] == 'M') {\n                cnt[v[i]]--;\n            }\n            else {\n                ans += lma(v[i]) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\t\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\t//update_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\t//update_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2017/12/27  Problem: AOJ 2170 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\t//if (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n\n};\n// UnionFind uf(n); uf.unionSet(i,j); if(uf.same(x,y))\n\n\nLL N;\n\nLL ans = 0LL;\n\n\n\nint main() {\n\n\tint Q;\n\twhile (scanf(\"%d%d\", &N, &Q), N) {\n\n\t\tVI pre(N);\n\t\tFOR(i, 0, N - 1) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\tv--;\n\t\t\tpre[i] = v;\n\t\t}\n\t\tUnionFind uf(N);\n\t\tVI mark(N, 0);\n\t\tmark[0] = 1;\n\t\tvector<PII> qu(Q);\n\t\tFOR(i, 0, Q) {\n\t\t\tchar c[3]; int v; scanf(\"%s%d\", c, &v);\n\t\t\tqu[i].first = (c[0] == 'Q');\n\t\t\tv--;\n\t\t\tqu[i].second = v;\n\t\t\tif (qu[i].first == 0)mark[v]++;\n\t\t}\n\t\tFOR(i, 0, N) {\n\t\t\tif (mark[i] == 0)uf.unionSet(pre[i],i);\n\t\t\t//debug(uf.root(i));\n\t\t}\n\n\t\tans = 0;\n\t\tFORR(i, Q - 1, 0 - 1) {\n\t\t\tint v = qu[i].second;\n\t\t\tif (qu[i].first == 0) { // delete mark\n\t\t\t\tuf.unionSet(pre[v],v);\n\t\t\t\t//debug(uf.root(v));\n\t\t\t}\n\t\t\telse { // sum\n\t\t\t\tans += uf.root(v) + 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\nconst int MAX = 100010;\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nll par[MAX], nma[MAX];\nbool ism[MAX];\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tmemset(par, 0, sizeof(par));\n\t\tmemset(nma, 0, sizeof(nma));\n\t\tmemset(ism, 0, sizeof(ism));\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int MAXN = 100010;\n\nvector<int> G[MAXN];\nint qtype[MAXN], vertex[MAXN], marked[MAXN];\nint par[MAXN], pp[MAXN];\n\nvoid init() {\n    for (int i = 0; i < MAXN; i++) par[i] = i;\n}\n\nint find(int x) {\n    if (par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return;\n    par[y] = x;\n}\n\nvoid dfs(int v, int p, int m) {\n    int nm = m;\n    if (marked[v]) nm = v;\n    pp[v] = p;\n    unite(nm, v);\n    for (size_t i = 0; i < G[v].size(); i++) {\n        dfs(G[v][i], v, nm);\n    }\n}\n\nint main(void) {\n    int N, Q;\n    while (cin >> N >> Q) {\n        if (N == 0 && Q == 0) break;\n        init();\n        for (int i = 0; i < MAXN; i++) marked[i] = 0;\n        marked[1] = 1;\n        for (int i = 0; i < MAXN; i++) G[i].clear();\n        for (int i = 2; i <= N; i++) {\n            int v;\n            scanf(\"%d\", &v);\n            G[v].push_back(i);\n        }\n        for (int i = 0; i < Q; i++) {\n            char c;\n            scanf(\" %c %d\", &c, vertex+i);\n            if (c == 'Q') qtype[i] = 1;\n            else {\n                qtype[i] = 0;\n                marked[vertex[i]]++;\n            }\n        }\n        dfs(1, 0, 0);\n        ll ans = 0;\n        for (int i = Q-1; i >= 0; i--) {\n            if (qtype[i]) {\n                ans += find(vertex[i]);\n//                cout << \"now ans is \" << ans << endl;\n            }\n            else {\n                marked[vertex[i]]--;\n                if (!marked[vertex[i]]) unite(pp[vertex[i]], vertex[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N = 100005;\nint pre[N];     //存??点之?的?系\nint marked[N];  //存?是否被??以及??的?序\n\nint operation_order[N];     //按?序存??入的Q操作\nint operation_node_index[N];//存?Q操作??的?点下?\n\nlong long sum;\nint process_time;\n\nint find_ance(int index) {\n    if (marked[index] < process_time) {\n        return index;\n    }\n    else {\n        pre[index] = find_ance(pre[index]);\n        return pre[index];\n    }\n}\n\nint main() {\n    int n, q;\n    char op;\n    int index;\n\n    while (cin >> n >> q, n) {\n        sum = 0;\n        pre[1] = 1;\n        marked[1] = 0;\n        for (int i = 2; i <= n; ++i) {\n            cin >> pre[i];\n            marked[i] = q + 1;\n        }\n        int Q_operation_num = 0;\n        for (int i = 1; i <= q; ++i) {\n            cin >> op >> index;\n            if (op == 'Q') {\n                operation_order[Q_operation_num] = i;\n                operation_node_index[Q_operation_num++] = index;\n            }\n            else {\n                marked[index] = min(marked[index], i);\n            }\n        }\n\n        while (Q_operation_num--) {\n            process_time = operation_order[Q_operation_num];\n            sum += find_ance(operation_node_index[Q_operation_num]);\n        }\n        cout << sum << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (sizeOf(x) < sizeOf(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint sizeOf(int x) { return -parent[root(x)]; }\n};\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, Q; cin >> N >> Q;\n\tvector<int> p(N); rep(i, 1, N) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<char> c(Q);\n\tvector<int> a(Q);\n\tvector<bool> mark(N);\n\tmark[0] = true;\n\trep(i, 0, Q) {\n\t\tcin >> c[i] >> a[i];\n\t\ta[i]--;\n\t\tif (c[i] == 'M')mark[a[i]] = true;\n\t}\n\tdump(mark);\n\tUnionFind uf(N);\n\tvector<int> anc(N);\n\tiota(all(anc), 0);\n\trep(i, 0, N) {\n\t\tif (!mark[i]) {\n\t\t\tint t = anc[uf.root(p[i])];\n\t\t\tuf.unite(i, p[i]);\n\t\t\tanc[uf.root(i)] = t;\n\t\t}\n\t}\n\tint ans = 0;\n\trrep(i, 0, Q) {\n\t\tif (c[i] == 'Q')\n\t\t\tans += anc[uf.root(a[i])] + 1;\n\t\telse {\n\t\t\tint t = anc[uf.root(p[a[i]])];\n\t\t\tuf.unite(a[i], p[a[i]]);\n\t\t\tanc[uf.root(a[i])] = t;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nint anc[100000];\nint dpt[100000];\nint lnd[100000];\nint nea[100000];\nint chn[100000];\nint han[100000];\nint n;\nint nn;\n\nvector<vector<int> > decend;\n\nvoid calc(int pos, int depth, int land){\n  dpt[pos] = depth;\n  lnd[pos] = land;\n  if(depth % nn == 0) land = pos;\n  REP(i, decend[pos].size())\n    calc(decend[pos][i], depth + 1, land);\n}\n\nint query(int);\n\nint dfs(int pos, int land){\n  int ret;\n  if(pos == land)\n    ret = query(pos);\n  else if(nea[pos] == pos)\n    ret = pos;\n  else\n    ret = dfs(anc[pos], land);\n  han[pos] = chn[land];\n  return nea[pos] = ret;\n}\n\nint query(int pos){\n  int land = lnd[pos];\n  int ans  = nea[pos];\n  if(ans == pos) return pos;\n  if(han[pos] < chn[land])\n    return dfs(pos, land);\n  if(dpt[land] <= dpt[ans])\n    return nea[pos] = ans;\n  return nea[pos] = query(land);\n}\n\nint main(){\n  int q;\n\n  while(~scanf(\"%d%d\", &n, &q) && n + q){\n    decend = vector<vector<int> >(n);\n\n    REP(i, n){\n      nea[i] = 0;\n      chn[i] = -1;\n      han[i] = -1;\n    }\n\n    REP(i, n - 1){\n      scanf(\"%d\", &anc[i + 1]);\n      anc[i + 1]--;\n      decend[anc[i + 1]].push_back(i + 1);\n    }\n\n    nn = (int)sqrt(n);\n    calc(0, 0, 0);\n\n    ll sum = 0;\n\n    REP(qq, q){\n      char buff[2];\n      int m;\n      // REP(i,n) printf(\"%d \", query(i)); puts(\"\");\n\n      scanf(\"%s%d\", buff, &m);\n      m--;\n\n      if(buff[0] == 'Q'){\n        // query\n        int ans = query(m) + 1;\n        sum += ans;\n      }else{\n        // marked\n        if(nea[m] != m){\n          nea[m] = m;\n          chn[lnd[m]] = qq;\n        }\n      }\n    }\n\n    printf(\"%lld\\n\", sum);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nconst int INF = (1<<26);\nconst int segN=(1<<20);\n\nstruct data{\n  P value;\n  data* ch[2];\n\n  void clear(){\n    for(int i=0;i<2;i++){\n      if(ch[i]->ch[0]!=NULL)ch[i]->clear();\n      free(ch[i]);\n    }\n  }\n  \n  void init(){\n    value=P(-INF,-1);\n    ch[0]=(data*)malloc(sizeof(data));\n    ch[1]=(data*)malloc(sizeof(data));\n    ch[0]->ch[0]=NULL;\n    ch[1]->ch[0]=NULL;\n  }\n  \n  void set(int a,int b,P x,int l,int r){\n    int m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    \n    if(b<=l || r<=a)return; \n    else if(a<=l && r<=b){\n      value=(x>value?x:value);\n    }else{\n      ch[0]->set(a,b,x,l,m);\n      ch[1]->set(a,b,x,m,r);\n    }\n  }\n   \n  void set(int a,int b,P x){\n    set(a,b,x,0,segN);\n  }\n  \n  P max(int i,int l,int r){\n    \n    int m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    if(i<l || r<=i)return P(-INF,-1);\n   \n    if(r-l==1){\n      return value;\n    }\n    \n    P res=value;\n    P lc=ch[0]->max(i,l,m);\n    res=(lc>res?lc:res);\n    P rc=ch[1]->max(i,m,r);\n    res=(rc>res?rc:res);\n    return res;\n  }\n \n  P max(int i){\n    return max(i,0,segN);\n  }\n};\n\n#define MAX 100005\nint n,m,a;\nchar str[2];\nvector<int> vec;\nvector<int> G[MAX];\nint l[MAX],r[MAX],depth[MAX];\ndata T;\n\nvoid init(){\n  T.init();\n  vec.clear();\n  for(int i=0;i<n;i++){\n    depth[i]=0;\n    l[i]=INF;\n    r[i]=0;\n    G[i].clear();\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    init();\n    for(int i=1;i<n;i++){\n      scanf(\"%d\",&a);\n      a--;\n      G[a].push_back(i);\n    }\n\n    stack<int> st;\n    st.push(0);\n    while(!st.empty()){\n      int pos=st.top();st.pop();\n      l[pos]=min(l[pos],(int)vec.size());\n      r[pos]=max(r[pos],(int)vec.size());\n      vec.push_back(pos);\n      if(G[pos].empty())continue;\n      st.push(pos);\n      st.push(G[pos].back());\n      depth[G[pos].back()]=depth[pos]+1;\n      G[pos].pop_back();\n    }\n\n    /*\n    for(int i=0;i<(int)vec.size();i++)\n      cout<<vec[i]<<' ';cout<<endl;\n\n    for(int i=0;i<n;i++){\n      cout<<i<<' '<<l[i]<<' '<<r[i]<<' '<<depth[i]<<endl;\n    }\n    */\n    T.set(l[0],r[0]+1,P(0,0));\n    \n    long long sum=0;\n    for(int i=0;i<m;i++){\n      scanf(\"%s %d\",str,&a);\n      a--;\n      if(str[0]=='Q'){\n        sum+=(T.max(l[a]).second+1LL);\n      }else{\n        T.set(l[a],r[a]+1,P(depth[a],a));\n      }\n    }\n    cout<<sum<<endl;\n    //T.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T, int* OT);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tint OrigT[N+1];\n\t\tT[1] = OrigT[1] = 1;\n\t\tfor(int i=2; i<=N; i++){ cin >> T[i]; OrigT[i] = T[i]; }\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(v, T, OrigT); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T, int* OT){\n\tif(!v) return 0;\n\tint ans = OT[v];\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef vector< int > Array;\ntypedef pair< int, int > pii;\n\nconst int iINF = 1L << 30;\n\nint N, Q;\nvector< Array > edges;\nint depth[100010], node_number[100010];\npii ranges[100010];\n\n// lazy evaluate segment tree\nstruct SegmentTreeL {\nprivate:\n\ttypedef int data_type;\n\tstatic const data_type dINF = iINF;\n\t\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\npublic:\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tif (lazy[_k] == 0) lazy[_k] = _val;\n\t\telse if (depth[ lazy[_k] ] < depth[_val]) lazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint dfs(int v, int& nv, int dp) {\n\tdepth[v] = dp;\n\t\n\tint e_size = size_of(edges[v]), mn = iINF;\n\t\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tmn = min(mn, dfs(u, nv, dp + 1));\n\t}\n\t\n\t++nv;\n\tnode_number[v] = nv;\n\tranges[v] = pii(min(mn, nv), nv);\n\t\n\treturn min(mn, nv);\n}\n\nvoid solve() {\n\tSegmentTreeL stl(N + 5, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint nv = 0;\n\tdfs(1, nv, 0);\n\t\n\tlint ans = 0;\n\t\n\tfor_(i,0,Q) {\n\t\tchar q; int v; scanf(\"%s %d\", &q, &v);\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tnv = node_number[v];\n\t\t\tans += (lint)stl.query(nv, nv + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tedges.assign(N + 1, Array());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; scanf(\"%d\", &p);\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<iostream>\n#include<stdio.h>\n#include<string>\nusing namespace std;\nconst int MAX_N=100005;\nbool mark[MAX_N];\nint par[MAX_N];//父亲数组\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        par[i]=i;\n    }\n}\n\n\n\nint find(int x)//查询最近的已标记的祖先节点\n{\n    if(x==par[x])return x;\n    else if(mark[par[x]])\n    {\n        return par[x];\n    }\n    else\n    {\n        return find(par[x]);//递归查找\n    }\n}\n\n\nvoid unite(int x,int y)//记x为y的子节点\n{\n    par[x]=y;\n}\n\nint main()\n{\n    //freopen(\"c://Users/kkk/Destop/acm.txt\",\"r\",stdin);\n    int N,M;\n    while(1)\n    {\n    cin>>N>>M;\n    if(N==0&&M==0)break;\n    int parent;\n    init(N+1);\n    for(int i=2;i<=N;i++)\n    {\n        cin>>parent;\n        unite(i,parent);\n    }\n    long long ans=0;\n    while(M--)\n    {\n        char c;int t;\n        cin>>c;\n        cin>>t;\n        if(c=='Q')\n        {\n            ans+=find(t);\n        }\n        else if(c=='M')\n        {\n            mark[t]=1;\n        }\n    }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n \nusing namespace std;\n \nint n, q, res;\nint root[105000], parent[105000];\nvector<int> child[105000];\npair<char, int> query[105000];\n \nvoid set_root(int x, int y){\n    if(root[x] == 0)\n\troot[x] = y;\n    else\n\tswap(y, root[x]);\n    for(int i = 0;i < child[x].size();i++){\n\tset_root(child[x][i], y);\n    }\n}\n \nint r(int x){\n    if(root[x] == x)return x;\n    else return root[x] = r(root[x]);\n}\n \nvoid unite(int x, int y){\n    x = r(x);\n    y = r(y);\n    root[x] = y;\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(root, root + n + 1, 0);\n\tfor(int i = 0;i <= n;i++)child[i].clear();\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> parent[i];\n\t    child[parent[i]].push_back(i);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\troot[query[i].second] = query[i].second;\n\t}\n\tset_root(1, 1);\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tunite(num, parent[num]);\n\t    }\n\t    else{\n\t\tres += r(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }       \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        if(x > y) swap(x, y);\n        // y を x に統合 (数字の小さい方に合わせる)\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nvoid init(int root, int val) {\n    for(size_t i=0; i<G[root].size(); i++) {\n        int to = G[root][i];\n        if(to == root) continue;\n        if(mark[to]) init(to, to);\n        else {\n            uf.unite(root, to);\n            init(to, val);\n        }\n    }\n}\n\nvoid debug() {\n    /*\n    for(int i=0; i<N; i++) {\n        printf(\"node %d: root = %d\\n\", i+1, uf.find(i) + 1);\n    }\n    */\n}\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n        init(0, 0);\n        debug();\n\n        ll ans = 0;\n        for(int i=0; i<Q; i++) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n            debug();\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N (int)1e5\ntypedef long long LL;\nint tree[N + 1];\nbool marked[N + 1];\nLL Query(int now){\n    if(marked[now]){\n        return now;\n    }\n    else{\n        return Query(tree[now]);\n    }\n}\nvoid Mark(int index){\n    marked[index] = true;\n}\nint main(){\n    int n, q, arg;\n    LL sum;\n    char com;\n    while(cin >> n >> q && n && q){\n        sum = 0;\n        memset(marked, 0, sizeof(marked));\n        marked[1] = true;\n        for(int i = 2; i <= n; i++){\n            cin >> tree[i];\n        }\n        for(int i = 0; i < q; i++){\n            cin >> com >> arg;\n            if(com == 'Q'){\n                sum += Query(arg);\n            }\n            else{\n                Mark(arg);\n            }\n        }\n        cout << sum << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int maxn=100000+5;\nint par[maxn];\nint find(int x)\n{\n    if(par[x]==x)\n        return x;\n    else\n        return find(par[x]);\n}\nint main()\n{\n    int n,m;\n    char str[5];\n    int x;\n    long long sum;\n    while(scanf(\"%d%d\",&n,&m)==2&&m+n!=0)\n    {\n        par[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            scanf(\"%d\",&x);\n            par[i]=x;\n        }\n        sum=0;\n        while(m--)\n        {\n            scanf(\"%s%d\",str,&x);\n            if(str[0]=='Q')\n                sum+=find(x);\n            else\n                par[x]=x;\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100000+1109\n\nusing namespace std;\n\nchar ch[30];\nlong long n,m;\nlong long fa[MAXN];\nlong long a[MAXN],Q[MAXN];\nbool Is[MAXN];\nlong long Ans=0;\nlong long Mark[MAXN];\n\nlong long find(long long x)\n{\n\tif(fa[x]==x) return x;\n\tif(Is[x]==true) return x;\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid read();\nvoid work();\nvoid print();\n\nint main()\n{\n\tbool flag=false;\n\twhile(~scanf(\"%lld%lld\",&n,&m))\n\t{\n\t\tmemset(Is,0,sizeof(Is));\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(Mark,0,sizeof(Mark));\n\t\tif(n==0&&m==0) return 0;\n\t\tif(flag) printf(\"\\n\");\n\t\tflag=true;\n\t\tAns=0;\n\t\tread();\n\t\twork();\n\t\tprint();\n\t}\n\treturn 0;\n}\n\nvoid read()\n{\n\t\n\tif(n==0&&m==0) exit(0);\n\tfa[1]=1;\n\tfor(long long i=2;i<=n;i++)\n\t\tscanf(\"%lld\",&fa[i]);\n\tIs[1]=true;\n\tfor(long long i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%lld\",ch,&Q[i]);\n\t\tif(ch[0]=='Q') a[i]=1;\n\t\telse\n\t\t{\n\t\t\ta[i]=2,Is[Q[i]]=true;\n\t\t\tif(Mark[Q[i]]) continue;\n\t\t\tMark[Q[i]]=i;\n\t\t}\n\t}\n}\nvoid work()\n{\n\tfor(long long i=m;i;i--)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tif(Q[i]==1) continue;\n\t\t\tif(Is[Q[i]])\n\t\t\t\tAns+=find(fa[Q[i]]);\n\t\t\telse Ans+=find(Q[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Mark[Q[i]]!=i) continue;\n\t\t\tIs[Q[i]]=false;\n\t\t}\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<char, int> P;\n\nint ancestor[100000];\nint n, q;\nint marked_ancestor[100000];\nbool ismarked[100000];//false = unmarked\nP outlog[100000];\n\nvoid create_UF(int size) {\n\tfor (int i = 0; i < size; i++) {\n\t\tmarked_ancestor[i] = i;\n\t}\n}\n\nint getroot(int a) {\n\tif (a == marked_ancestor[a])return a;\n\treturn marked_ancestor[a] = getroot(marked_ancestor[a]);\n}\n\nbool is_same_unit(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\t//parent kid\n\tif (is_same_unit(a, b))return;\n\tmarked_ancestor[b] = a;\n}\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tcreate_UF(n);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tunite(getroot(ancestor[i]), i);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tmarked_ancestor[0] = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M')unite(getroot(ancestor[outlog[i].second]), outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, Q; cin >> N >> Q&&N;) {\n\t\tvector<int> p(N); p[0] = -1; rep(i, 1, N) { cin >> p[i]; p[i]--; }\n\t\tvector<bool> m(N); m[0] = true;\n\t\tvector<char> q1(Q);\n\t\tvector<int> q2(Q);\n\t\trep(i, 0, Q) {\n\t\t\tcin >> q1[i] >> q2[i];\n\t\t\tq2[i]--;\n\t\t\tif (q1[i] == 'M')m[q2[i]] = true;\n\t\t}\n\t\tUnionFind UF(N);\n\t\tint ans = 0;\n\t\trrep(i, 0, Q) {\n\t\t\tif (q1[i] == 'Q') {\n\t\t\t\tint root = UF.root(q2[i]);\n\t\t\t\twhile (!m[root]) {\n\t\t\t\t\tUF.unite(root, p[root]);\n\t\t\t\t\troot = p[root];\n\t\t\t\t\tif (m[root]) {\n\t\t\t\t\t\tans += (root + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm[q2[i]] = false;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nPath compression happens \nwhen no node on the path is marked before query happens\n*/\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 1e5 + 16;\n\nint p[MAXN], mark[MAXN], qt[MAXN], qv[MAXN];\n// mark[i] is the time node i is marked\n// qt[q] is the time query q happens\n// qv[q] is the node of query q\nint t;\n\nint find(int i) {\n    return mark[i] <= t ? i : p[i] = find(p[i]);\n}\n\nint main() {\n    //freopen(\"2170.in\", \"r\", stdin);\n    int N, Q;\n    while (~scanf(\"%d%d\", &N, &Q) && (N | Q)) {\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", p + i);\n            mark[i] = INF;\n        }\n        int cnt = 0, x;\n        char op[2];\n        for (int i = 1; i <= Q; i++) {\n            scanf(\"%s%d\", op, &x);\n            if (op[0] == 'M') {\n                mark[x] = i;\n            } else {\n                qt[cnt] = i;\n                qv[cnt++] = x;\n            }\n        }\n        int result = 0;\n        while (cnt--) {\n            t = qt[cnt];\n            result += find(qv[cnt]);\n        }\n        printf(\"%d\\n\", result);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\nint parent[100001];\nint ans[100001];\npair<char,int> query[100001];\n\nvoid Init(int n){\n\n    for(int i=1;i<=n;++i)\n        ans[i] = parent[i];\n\n}\n\nint Find(int x){\n\n    return x==ans[x]?x:(ans[x]=Find(ans[x]));\n\n}\n\nvoid Union(int x, int y){\n\n    ans[Find(x)] = Find(y);\n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    while(1){\n\n        int N,Q;\n        cin >> N >> Q;\n\n        if(N==0 && Q==0)break;\n\n        parent[1] = 1;\n\n        for(int i=2;i<=N;++i){\n\n            int x;\n\n            cin >> x;\n\n            parent[i] = x;\n\n        }\n\n        Init(N);\n\n        for(int i=0;i<Q;++i){\n\n            string str;\n            int x;\n\n            cin >> str >> x;\n\n            query[i].first  = str[0];\n            query[i].second = x;\n\n            if(str[0]=='M') ans[x] = x;\n\n        }\n\n        long long sum = 0;\n\n        for(int i=Q-1;i>=0;--i){\n\n            pair<char,int> p = query[i];\n\n            if(p.first == 'Q'){\n\n                sum += Find(parent[p.second]);\n\n            } else {\n\n                Union(p.second,parent[p.second]);\n\n            }\n\n        }\n       \n        cout << sum << endl;\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 1 << 18;\n#define int long long\ntypedef pair<int,int> P;\nint n;\nP dat[2*MAX_N-1];\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  for(int i=0;i<2*n-1;i++) dat[i].first=-1,dat[i].second=0;\n}\nint query(int k){\n  k+=n-1;\n  P p=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    p=max(p,dat[k]);\n  }\n  return p.second;\n}\n\nvoid update(int a,int b,P p,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l) return;\n  if(a<=l&&r<=b) {\n     dat[k]=p;\n  }else{\n    update(a,b,p,k*2+1,l,(l+r)/2);\n    update(a,b,p,k*2+2,(l+r)/2,r);\n  }\n}\n\nvector<int> G[MAX_N];\nint st[MAX_N],en[MAX_N],de[MAX_N];\nint pos=0;\nvoid dfs(int v,int p=-1,int d=0){\n  de[v]=d;\n  st[v]=pos++;\n  for(auto i:G[v]) if(i!=p) dfs(i,v,d+1);\n  en[v]=pos;\n}\n\nvoid update(int k,P p){\n  update(st[k],en[k],p);\n}\n\nsigned main(){\n  int _n,q;\n  while(cin>>_n>>q,_n||q){\n    for(int i=0;i<MAX_N;i++) G[i].clear();\n    init(_n+1);\n    for(int i=1;i<_n;i++) {\n      int p;\n      cin>>p;\n      p--;\n      G[p].push_back(i);\n      G[i].push_back(p);\n    }\n    dfs(0);\n    int ans=0;\n    for(int i=0;i<q;i++){\n      char c;\n      int u;\n      cin>>c>>u;\n      u--;\n      if(c=='M') update(u,P(de[u],u));\n      else ans+=query(u)+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nint ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q),n|q){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] += 1;\n\t\tlong long sum = 0;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] -= 1;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int maxn = 100005;\nint tree[maxn];\nint ar[maxn];\nP query[maxn];\nint get(int i)\n{\n\tint par = tree[i];\n\twhile(!ar[par])\n\t{\n\t\tpar = tree[par];\n\t}\n\treturn par;\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q)&&(q+n)!=0){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] += 1;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] -= 1;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nint n,q;    //n个节点，q个操作 \nint par[100010];\n\nint find(int a)\n{\n\tif(a == par[a])\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn find(par[a]);\n\t}\n}\n\nint main()\n{\n\twhile(cin>>n>>q)\n\t{\n\t\tif(n==0&&q==0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)   //每个节点的初始父节点都是1 \n\t\t    par[i] = 1;\n\t\tfor(int i = 2;i <= n;i++)\n\t\t{\n\t\t\tcin>>par[i];\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor(int i = 1;i <= q;i++)\n\t\t{\n\t\t\tint a; \n\t\t\tchar op;\n\t\t\tcin>>op>>a;\n\t\t\tif(op == 'M')    //标记 \n\t\t\t{\n\t\t\t\tpar[a] = a;\n\t\t\t}\n\t\t\telse             //查询 \n\t\t\t{\n\t\t\t\tans = ans + find(a);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <map>\n#include <stack>\n#include <vector>\n#include <set>\n#include <queue>\n#pragma comment (linker,\"/STACK:102400000,102400000\")\n#define maxn 100005\n#define MAXN 2005\n#define mod 1000000009\n#define INF 0x3f3f3f3f\n#define pi acos(-1.0)\n#define eps 1e-6\n#define lson rt<<1,l,mid\n#define rson rt<<1|1,mid+1,r\n#define FRE(i,a,b)  for(i = a; i <= b; i++)\n#define FREE(i,a,b) for(i = a; i >= b; i--)\n#define FRL(i,a,b)  for(i = a; i < b; i++)\n#define FRLL(i,a,b) for(i = a; i > b; i--)\n#define mem(t, v)   memset ((t) , v, sizeof(t))\n#define sf(n)       scanf(\"%d\", &n)\n#define sff(a,b)    scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define pf          printf\n#define DBG         pf(\"Hi\\n\")\ntypedef long long ll;\nusing namespace std;\n \nll father[maxn];\nint n,q;\n \nll find_father(ll x)\n{\n    if (x==father[x])\n        return father[x];\n    return find_father(father[x]);\n}\n \nint main()\n{\n    int i,j;\n    ll x;\n    char s[2];\n    while (sff(n,q))\n    {\n        if (n==0&&q==0) break;\n        father[1]=1;\n        FRE(i,2,n)\n        {\n            sf(x);\n            father[i]=x;\n        }\n        ll ans=0;\n        while (q--)\n        {\n            scanf(\"%s%lld\",s,&x);\n            if (s[0]=='M')\n                father[x]=x;\n            else\n                ans+=find_father(x);\n        }\n        pf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100005;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n\n   for(int i = 0; i < MAX; i++){\n      mark[i] = 0;\n      par[i] = 0;\n      rank[i] = 0;\n    }\n\n\n    for(int i = 1; i <= n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n\n   }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  int ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[100005];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tfa[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')fa[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (fa[a] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w[2];\n\n\twhile(true){\n\n\tscanf(\"%d%d\",&n,&q);\n\tif(!n)break;\n\t\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d\",&z);z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\tcout<<\"#\"<<endl;\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tscanf(\"%s%d\",w,&z);z--;\n\n\t\tif(w[0]=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\telse{\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<long long int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<long long int> sizes;\n\n  UnionFind(long long int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    rep(i,n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  long long int find(long long int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(long long int x, long long int y) {\n    // ?????????????????????????????????\n    x = find(x);\n    y = find(y);\n\n    // ??¢???????????¨????±?????????????????????????????????????\n    if (x == y) return;\n\n    // x?????¨???y?????¨????????§???????????????????????????\n    if (x > y) swap(x, y);\n\n    // x???y??????????????????????????£?????????\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]????????????????????¨???????????§0?????\\????????????????????????\n  }\n\n  // 2???????????????x, y????±?????????¨???????????????true?????????\n  bool same(long long int x, long long int y) {\n    return find(x) == find(y);\n  }\n\n  // ?????????x?????????????????¨?????§???????????????\n  int size(long long int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tcout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unite(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unite(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.find(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  bool flag = true;\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      same(1,num);\n      if(flag) flag = false;\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(flag){\n          ans += 1;\n          break;\n        }\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          // printf(\"%d\", nodeNum);\n          break;\n        }\n  \n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n\n     \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n    Node[1] = 1;\n  while(1){\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> e[100000];\nint par[18][100000];\nint index[200000];\nint fapr[100000];\nint lapr[100000];\nint bit[200000];\nint bit_n;\nvoid add(int i,int x){\n\twhile(i<=bit_n){\n\t\tbit[i]+=x;\n\t\ti+=i&-i;\n\t}\n}\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-=i&-i;\n\t}\n\treturn s;\n}\nint dfs(int v,int k){\n\tindex[k]=v;\n\tfapr[v]=k++;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tk=dfs(e[v][i],k);\n\t\tindex[k++]=v;\n\t}\n\tlapr[v]=k-1;\n\treturn k;\n}\nint main(){\n\twhile(1){\n\tint n,q;\n\tint i,j;\n\tscanf(\"%d %d\",&n,&q);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;1<<j<n;j++)par[j][i]=-1;\n\tfor(i=0;i<n;i++)e[i].clear();\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d\",&par[0][i]);\n\t\tpar[0][i]--;\n\t\te[par[0][i]].push_back(i);\n\t}\n\tfor(i=1;1<<i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(par[i-1][j]==-1)continue;\n\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint m=i-1;\n\tdfs(0,1);\n\tbit_n=n*2;\n\tfor(i=0;i<bit_n;i++)bit[i]=0;\n\tadd(2,1);\n\tlong long ans=0;\n\tfor(i=0;i<q;i++){\n\t\tchar t;int v;\n\t\tscanf(\" %c %d\",&t,&v);\n\t\tv--;\n\t\tif(t=='M'){\n\t\t\tadd(fapr[v]+1,1);\n\t\t\tadd(lapr[v],-1);\n\t\t}else{\n\t\t\tint k=sum(fapr[v]);\n\t\t\tfor(j=m;j>=0;j--){\n\t\t\t\tif(par[j][v]==-1)continue;\n\t\t\t\tif(sum(fapr[par[j][v]])==k){\n\t\t\t\t\tv=par[j][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=par[0][v]+1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < int(n); i++)\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\t//if (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n};\n\nint main(){\n\tlong long int n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\ta[1] = 1;\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<bool> roots(n);\n\t\troots[1] = true;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M' && roots[v]) continue;\n\t\t\tif(c == 'M') roots[v] = true;\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(!roots[i]){\n\t\t\t\t//cout << a[i] << \" - \" << i << endl;\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\t//cout << queries[i].first << \" \" << queries[i].second << endl;\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\t//cout << uf.find(queries[i].second) << endl;\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ndouble zero(double d) {\n    return d < EPS ? 0.0 : d;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    return os << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    rep(i, a.size()) os << (i ? \" \" : \"\") << a[i];\n    return os << ']';\n}\n\n// to avoid error on mingw\nstring toString(int i) {\n    stringstream ss;\n    ss << i;\n    return ss.str();\n}\n\nconst int M = 1000000007;\n// a^k\nll fpow(ll a, ll k, int M) {\n    ll res = 1ll;\n    ll x = a;\n    while (k != 0) {\n        if ((k & 1) == 1)\n            res = (res * x) % M;\n        x = (x * x) % M;\n        k >>= 1;\n    }\n    return res;\n}\n\nclass UnionFind {\nprivate:\n    vi rank;\n\npublic:\n\n    int find(int x) {\n        if(par[x] == x)\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\n    vi par;\n\n    UnionFind(int n) {\n        rep(i,n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    // ??????x????????????????????????????????????\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n\n        par[y] = x;\n        if(rank[x] == rank[y])\n            rank[x]++;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(8);\n    ios_base::sync_with_stdio(false);\n\n    int N, Q;\n    while(cin >> N >> Q, (N|Q)) {\n        vi parents(N-1);\n        rep(i, N-1) {\n            int t;\n            cin >> t;\n            parents[i] = (--t);\n        }\n\n        vector< pair<char, int> > queries;\n        vector<bool> marked(N-1, false);\n        marked[0] = true;\n        rep(i, Q) {\n            char c;\n            int t;\n            cin >> c >> t;\n            t--;\n            if(c == 'M') {\n                if(! marked[t])\n                    queries.push_back(mp(c,t));\n                marked[t] = true;\n            }\n            else {\n                queries.push_back((mp(c,t)));\n            }\n        }\n\n        // ?????????????????????????????????????????¨????????????\n        // ?¬¬????????°??????????????????????????????????????????\n        UnionFind uf(N-1);\n        rep(i, N-1) {\n            if(! marked[i])\n                uf.unite(parents[i], i);\n        }\n\n        // ?????¨???????????????\n        reverse(all(queries));\n\n        int res = 0;\n        tr(it, queries) {\n            char c = it->first;\n            int t = it->second;\n\n            // ??????????????????\n            if(c=='M') {\n                // ?????¨unite????¬¬????????°??????????????????????????????????????????\n                uf.unite(parents[t], t);\n            }\n            else {\n                int ans = uf.find(t);\n                res += ans + 1;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<vector>\n#define MAX 100010\n#define X first\n#define Y second\nusing namespace std;\n\nint n,q,z;\nint m[MAX];\nvector<int> c[MAX];\nstack<pair<char,int> > Q;\n\nint u[MAX];\n\nvoid DFS(int x,int g){\n\tu[x]=g;\n\tif(m[x])g=x;\n\tfor(int i=0;i<c[x].size();i++){\n\t\tDFS(c[x][i],g);\n\t}\n}\n\nint FIND(int x){\n\tif(m[x])return x;\n\tint ret=FIND(u[x]);\n\tu[x]=ret;\n\treturn ret;\n}\n\nint main(){\n\n\twhile(cin>>n>>q&&n){\n\n\tfor(int i=0;i<n;i++){\n\t\tc[i].clear();\n\t\tu[i]=0,m[i]=0;\n\t}\n\n\tfor(int i=1;i<n;i++){\n\t\tcin>>z;z--;\n\t\tc[z].push_back(i);\n\t}\n\n\tm[0]++;\n\tfor(int i=0;i<q;i++){\n\t\tpair<char,int> r;\n\t\tcin>>r.X>>r.Y;r.Y--;\n\t\tif(r.X=='M')m[r.Y]++;\n\t\tQ.push(r);\n\t}\n\n\tDFS(0,0);\n\n\tlong long ans=0;\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().X=='M'){\n\t\t\tm[Q.top().Y]--;\n\t\t}\n\t\telse{\n\t\t\tans+=FIND(Q.top().Y)+1;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\trep(i, n-1) {\n\t\t\tcin >> par0[i + 1]; par0[i + 1]--;\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<long long int> data;\n\tUnionFind(long long int size) : data(size, -1) { }\n\tbool unionSet(long long int x, long long int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(long long int x, long long int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tlong long int root(long long int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tlong long int size(long long int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<long long int> roots;\n\t\tvector<pair<char,long long int>> queries;\n\t\tfor(long long int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tlong long int v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(long long int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(long long int i=(long long int)queries.size()-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\n\ntemplate<class T>\nstruct Vector{\n\tint sz,cap;\n\tT *p;\n\tVector():sz(0),cap(0),p(0){}\n\t~Vector(){\n\t\tclear();\n\t}\n\tvoid swap(Vector &v){\n\t\tstd::swap(sz,v.sz);\n\t\tstd::swap(cap,v.cap);\n\t\tstd::swap(p,v.p);\n\t}\n\tint size()const{return sz;}\n\tbool empty()const{return !sz;}\n\tT& back()const{\n\t\treturn p[sz-1];\n\t}\n\tvoid push_back(T v){\n\t\tif(sz==cap)reserve(sz?sz*2:1);\n\t\tnew(p+sz++) T(v);\n\t}\n\tvoid pop_back(){\n\t\tp[--sz].~T();\n\t\tif(sz&&sz*4<cap){\n\t\t\treserve(cap/2);\n\t\t}\n\t}\n\tvoid resize(int n){\n\t\tclear();\n\t\tif(n==0)return;\n\t\tcap=1;\n\t\twhile(cap<n)cap*=2;\n\t\treserve(cap);\n\t\tfor(int i=0;i<n;i++)new(p+i) T();\n\t\tsz=n;\n\t}\n\tvoid reserve(int n){\n\t\tT *p=(T*)operator new(n*sizeof(T));\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tnew(p+i) T(this->p[i]);\n\t\t\tp[i].~T();\n\t\t}\n\t\tif(this->p)operator delete(this->p);\n\t\tthis->p=p;\n\t\tcap=n;\n\t}\n\tvoid clear(){\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tp[i].~T();\n\t\t}\n\t\tif(p)operator delete(p);\n\t\tsz=cap=0;\n\t\tp=0;\n\t}\n\tT& operator[](int i)const{\n\t\treturn p[i];\n\t}\n};\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tVector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tVector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid push(T v){\n\t\timax=-1;\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].push(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\nvector<int> par,Rank,mark;\nvoid init(int n){\n\tpar.resize(n,0);\n\tRank.resize(n,0);\n\tmark.resize(n,0);\n\tmark[0] = 1;\n\tREP(i,n)par[i] = i;\n}\n\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\n\nint mark_find(int x){\n\tif(mark[x])return x;\n\telse if(par[x] == x)return -1;\n\telse return mark_find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\tif(Rank[x] > Rank[y])par[y] = x;\n\telse{\n\t\tpar[x] = y;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x,int y){return find(x) == find(y);}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n||m){\n\t\tinit(n);\n\t\tREP(i,n-1){cin >> par[i];par[i]--;}\n\t\tint ans = 0;\n\t\tREP(i,m){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M'){\n\t\t\t\tmark[v-1] = 1;\n\t\t\t}else if(c == 'Q'){\n\t\t\t\tans += mark_find(v-1) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nconst P idnt=P(-1,-1);\n\nclass segtree {\npublic:\n\tsegtree (int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=idnt;\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,P a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tP query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return idnt;\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tP vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tP vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<P> _dat;\n};\n\nvector<ll> marked;\nvector<vector<ll>> queried;\nvector<ll> dpt;\nvector<vector<ll>> adj;\n\nvoid dpt_fill(ll pos, ll par, ll d) {\n\tdpt[pos]=d;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdpt_fill(adj[pos][i],pos,d+1);\n\t}\n}\n\nll dfs(ll pos, ll par, segtree& segt) {\n\tif(marked[pos]!=-1) segt.update(marked[pos],P(dpt[pos],pos));\n\tll ret=0;\n\tREP(i,(ll)queried[pos].size()) {\n\t\tP tmp=segt.query(0,queried[pos][i]);\n\t\tif(tmp==idnt) ret++;\n\t\telse ret+=tmp.second+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tret+=dfs(adj[pos][i],pos,segt);\n\t}\n\tif(marked[pos]!=-1) segt.update(marked[pos],idnt);\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,q;\n\tcin>>n>>q;\n\tmarked.assign(n,-1);\n\tqueried.assign(n,vector<ll>(0));\n\tdpt.assign(n,0);\n\tadj.assign(n,vector<ll>(0));\n\tFOR(i,1,n) {\n\t\tll p;\n\t\tcin>>p;\n\t\tp--;\n\t\tadj[i].pb(p);\n\t\tadj[p].pb(i);\n\t}\n\tREP(i,q) {\n\t\tchar ty;\n\t\tll p;\n\t\tcin>>ty>>p;\n\t\tp--;\n\t\tif(ty=='M') if(marked[p]==-1) marked[p]=i;\n\t\tif(ty=='Q') queried[p].pb(i);\n\t}\n\tdpt_fill(0,-1,0);\n\tsegtree segt(q);\n\tcout<<dfs(0,-1,segt)<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint edge[200001];\nvector<int> G[200000];\nint par[200001];\nbool flag[200001];\nchar s[200001];\nint v[200001],fm[200001];\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tpar[i]=i;\n\t\tG[i].clear();\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tmemset(fm,-1,sizeof(fm));\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tpar[x]=y;\n\t}\n\n}\n\nvoid unite_dfs(int v,int p){\n\tif(!flag[v])unite(v,p);\n\telse p=v;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tunite_dfs(G[v][i],p);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&edge[i]);\n\t\t\tG[edge[i]].push_back(i);\n\t\t}\n\t\tflag[1]=true;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tcin >> s[i] >> v[i];\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]=true;\n\t\t\t\tif(fm[v[i]]==-1)fm[v[i]]=i;\n\t\t\t}\n\t\t}\n\t\tunite_dfs(1,1);\n\n\t\tlong long res=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(s[i]=='Q'){\n\t\t\t\tres+=(long long)find(v[i]);\n\t\t\t}\n\t\t\tif(s[i]=='M' && fm[v[i]]==i){\n\t\t\t\tunite(v[i],edge[v[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nint N,Q;\nll rec(ll v,vector<int>& G,vector<int>& marked){\n    if(marked[v]) return v+1;\n    return rec(G[v],G,marked);\n}\nll solve(){\n    ll res = 0;\n    vector<int> G(N);\n    vector<int> marked(N,0); marked[0] = 1;\n    for(int i = 1; i < N;i++){\n        int par; cin >> par;\n        G[i] = par - 1;\n    }\n    while(Q--){\n        char c; int v;\n        cin >> c >> v; v--;\n        if(c == 'Q'){\n            res += rec(v,G,marked);\n        }else{\n            marked[v] = 1;\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N >> Q,N){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <iomanip>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dir[9][2] = { 0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1, 0, 0 };\nconst ll  ll_inf = 0x7fffffff;\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\nconst int inf = 0x3f3f3f;\nconst int mod = (int) 998244353;\nconst int Max = (int) 1e5 + 22;\nstringstream ss;\n\n/**********************************************Head-----Template****************************************/\nbool Finish_read;\ntemplate<class T>inline void read(T &x){Finish_read=0;x=0;int f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-1;if(ch==EOF)return;ch=getchar();}while(isdigit(ch))x=x*10+ch-'0',ch=getchar();x*=f;Finish_read=1;}\ntemplate<class T>inline void print(T x){if(x/10!=0)print(x/10);putchar(x%10+'0');}\ntemplate<class T>inline void writeln(T x){if(x<0)putchar('-');x=abs(x);print(x);putchar('\\n');}\ntemplate<class T>inline void write(T x){if(x<0)putchar('-');x=abs(x);print(x);}\n\n/********************************Head----Temlate**********************************************/\n\n//tools:\n//priority_queue <int, vector<int>, greater<int> > Q;\n//ios::sync_with_stdio(false);\n//freopen(\"input.txt\", \"r\", stdin);\n//ss<<int; ss>>str;\n\nint n, q;\nint Fa[Max];\nint value[Max];\n\nvoid Init() {\n\tFa[1] = 0;\n\tmemset(value, 0, sizeof(value));\n\tvalue[1] = 1;\n}\n\nint main() {\n\twhile (~scanf(\"%d %d\", &n, &q) && n+q) {\n\t\tInit();\n\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\tscanf(\"%d\", &Fa[i]);\n\t\t}\n\n\t\tll ans = 0;\n\t\tint x;\n\t\tchar ch[10];\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tscanf(\"%s %d\", ch, &x);\n\t\t\tif (ch[0] == 'Q') {\n\t\t\t\twhile (x) {\n\t\t\t\t\tif (value[x]) {\n\t\t\t\t\t\tans += (ll)x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx = Fa[x];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue[x] = 1;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct BIT{\n\tvector<ll> dat;\n\tint n;\n\n\tBIT(int _n){\n\t\tdat = vector<ll>(n = _n);\n\t}\n\n\tvoid add(int x, ll val){\n\t\tfor (int i = x; i < n; i += i&-i) dat[i] += val;\n\t}\n\tint sum(int x){\n\t\tll s = 0;\n\t\tfor (int i = x; i > 0; i -= i&-i) s += dat[i];\n\t\treturn s;\n\t}\n};\n\nconst int N = 1e5 + 10;\n\nvector<int> G[N];\n\nint idx[N][2];\n\nvoid dfs(){\n\tint i = 1;\n\tstack<int> st;\n\tst.push(0);\n\twhile (!st.empty()){\n\t\tint v = st.top();\n\t\tif (idx[v][0] < 0){\n\t\t\tidx[v][0] = i++;\n\t\t\tfor (auto nxt : G[v]){\n\t\t\t\tst.push(nxt);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tidx[v][1] = i++;\n\t\t\tst.pop();\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n){\n\t\trep(i, N) G[i].clear();\n\t\tFOR(i, 1, n){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p - 1].push_back(i);\n\t\t}\n\t\tMEMSET(idx, -1);\n\t\tdfs();\n\n\t\tBIT bit(n * 2 + 10);\n\n\t\tll ans = 0;\n\t\twhile (q--){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif (c == 'Q'){\n\t\t\t\t++ans;\n\t\t\t\tans += bit.sum(idx[v][0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// [idx[v][0], idx[v][1]] => v\n\t\t\t\tll x = bit.sum(idx[v][0]);\n\t\t\t\tbit.add(idx[v][0] + 1, -x + v);\n\t\t\t\tbit.add(idx[v][1], x - v);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t\t//rep(i, n){\n\t\t//\tcout << bit.sum(idx[i][0]) << endl;\n\t\t//\t//cout << idx[i][0] << ' ' << idx[i][1] << endl;\n\t\t//}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100000+1109\n\nusing namespace std;\n\nchar ch[30];\nint n,m;\nint fa[MAXN];\nint a[MAXN],Q[MAXN];\nbool Is[MAXN];\nlong long Ans=0;\n\nint find(int x)\n{\n\tif(fa[x]==x) return x;\n\tif(Is[x]==true) return x;\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid read();\nvoid work();\nvoid print();\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(Is,0,sizeof(Is));\n\t\tAns=0;\n\t\tread();\n\t\twork();\n\t\tprint();\n\t}\n\treturn 0;\n}\n\nvoid read()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tif(n==0&&m==0) exit(0);\n\tfa[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t\tscanf(\"%d\",&fa[i]);\n\tIs[1]=true;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s%d\",ch,&Q[i]);\n\t\tif(ch[0]=='Q') a[i]=1;\n\t\telse a[i]=2,Is[Q[i]]=true;\n\t}\n}\nvoid work()\n{\n\tfor(int i=m;i;i--)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tif(Is[Q[i]])\n\t\t\t\tAns+=find(fa[Q[i]]);\n\t\t\telse Ans+=find(Q[i]);\n\t\t\t//printf(\"%lld\\n\",Ans);\n\t\t}\n\t\telse Is[Q[i]]=false;\n\t\t/*for(int i=1;i<=n;i++)\n\t\t\tprintf(\"%d \",fa[i]);\n\t\tprintf(\"\\n\");\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tprintf(\"%d \",Is[i]);\n\t\tprintf(\"\\n\");*/\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n//< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy += max(seg[2 * k+1].lazy, seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn max(vl , vr);\n}\n\n\nclass Tree {\npublic:\n\tTree(int V, int root) : V(V), root(root),cnum(V),place(V),id(V) {\n\t\tT.resize(V);\n\t\tfor (int i = 0; i < MAXLOGV; i++) {\n\t\t\tparent[i].resize(V);\n\t\t}\n\t\tdepth.resize(V);\n\t}\n\t// u??¨v????????????\n\t// lca????±????????????¨????????????????????§????????°????????¨????????????\n\tvoid unite(int u, int v) {\n\t\tT[u].push_back(v);\n\t\tT[v].push_back(u);\n\t}\n\t// init??????\n\t// ????????????????????????????????????????????????????????°????????¨lca????±???????????????????\n\tvoid init() {\n\t\tdfs(root, 0, 0);\n\t\tint id = 0;\n\t\tgetid(root, 0, id);\n\t}\n\t// u??¨v???lca????±???????\n\tint lca(int u, int v) const {\n\t\tif (depth[u] > depth[v]) swap(u, v);\n\t\tfor (int k = 0; k < MAXLOGV; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = MAXLOGV - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\t// u??¨v????????¢????±???????\n\t// edge????????????????????¨????????????????????????????????????\n\tint dist(int u, int v) const {\n\t\tint p = lca(u, v);\n\t\treturn (depth[u] - depth[p]) + (depth[v] - depth[p]);\n\t}\n\tint dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tcnum[v] = 0;\n\t\tfor (int i = 1; i < MAXLOGV; i++) {\n\t\t\tparent[i][v] = parent[i - 1][parent[i - 1][v]];\n\t\t}\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) cnum[v]+=dfs(next, v, d + 1);\n\t\t}\n\t\treturn cnum[v]+1;\n\t}\n\n\tvoid getid(const int v, const int p,int &nplace) {\n\t\tplace[v] = nplace;\n\t\tid[nplace] = v;\n\t\tnplace++;\n\t\tfor (int next : T[v]) {\n\t\t\tif (next != p) getid(next, v, nplace);\n\t\t}\n\t}\n\tstatic const int MAXLOGV = 25;\n\t// ??°???????????£??\\???????????¨???\n\tvector<vector<int> > T;\n\t// ???????????°\n\tint V;\n\t// ?????????????????????\n\tint root;\n\n\t// ????????????\n\tvector<int> parent[MAXLOGV];\n\t// ??????????????±???\n\tvector<int> depth;\n\n\t//????????°\n\tvector<int>cnum;\n\n\t//??????\n\tvector<int>place;\n\tvector<int>id;\n\n};\nint main() {\n\twhile (1) {\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tupdate(1, N, 0);\n\t\tvector<int>nums;\n\t\tnums.push_back(0);\n\t\tTree t(N,0);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tt.unite(a, i+1);\n\t\t}\n\t\tt.init();\n\t\tlong long int asum = 0;\n\t\twhile (Q--) {\n\t\t\tchar c;int  n;\n\t\t\tcin >> c >> n;\n\t\t\tconst int aplace = t.place[n-1];\n\t\t\tif (c == 'M') {\n\t\t\t\tupdate(aplace+1, aplace + t.cnum[n-1]+1, n-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ans = get(aplace, aplace);\n\t\t\t\tasum += ans+1;\n\t\t\t}\n\t\t}\n\t\tcout << asum << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            a--;\n            if(a==0){continue;}\n            a=P[a];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m;}\n            }\n            bool done=false;\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; done=true; break;}\n            }\n            if(!done){ans++;}\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nusing namespace std;\nvector<int> e[100000];\nint par[18][100000];\nint index[200000];\nint fapr[100000];\nint lapr[100000];\nint bit[200000];\nint bit_n;\nint n;\nvoid add(int i,int x){\n\twhile(i<=bit_n){\n\t\tbit[i]+=x;\n\t\ti+=i&-i;\n\t}\n}\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-=i&-i;\n\t}\n\treturn s;\n}\nint dfs(int v,int k){\n\tindex[k]=v;\n\tfapr[v]=k++;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tk=dfs(e[v][i],k);\n\t\tindex[k++]=v;\n\t}\n\tlapr[v]=k-1;\n\treturn k;\n}\nint main(){\n\twhile(1){\n\tint q;\n\tint i,j;\n\tscanf(\"%d %d\",&n,&q);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;1<<j<n;j++)par[j][i]=-1;\n\tfor(i=0;i<n;i++)e[i].clear();\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d\",&par[0][i]);\n\t\tpar[0][i]--;\n\t\te[par[0][i]].push_back(i);\n\t}\n\tfor(i=1;1<<i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(par[i-1][j]==-1)continue;\n\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint m=i-1;\n\tdfs(0,1);\n\tbit_n=n*2;\n\tfor(i=0;i<bit_n;i++)bit[i]=0;\n\tadd(2,1);\n\tlong long ans=0;\n\tfor(i=0;i<q;i++){\n\t\tchar t;int v;\n\t\tscanf(\" %c %d\",&t,&v);\n\t\tv--;\n\t\tif(t=='M'){\n\t\t\tif(fapr[v]==lapr[v])continue;\n\t\t\tadd(fapr[v]+1,1);\n\t\t\tadd(lapr[v],-1);\n\t\t}else{\n\t\t\tint k=sum(fapr[v]);\n\t\t\tfor(j=m;j>=0;j--){\n\t\t\t\tif(par[j][v]==-1)continue;\n\t\t\t\tint s=sum(fapr[par[j][v]]);\n\t\t\t\tif(s==k){\n\t\t\t\t\tv=par[j][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=par[0][v]+1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id,ans;\n\twhile(~scanf(\"%d%d\",&N,&Q))\n\t{\n\t\tif(!N&&!Q)break;\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tans=0;\n\t\tSet[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    if(flag[t[n]] == 1)\n\treturn t[n];\n    else\n    {\n\tint fa = find(t[n]);\n\tt[n] = fa;\n\treturn t[n];    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n//#ifndef ONLINE_JUDGE\n//    READ;\n//#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 0;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]] = 1;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M' ) flag[idx[i]] = 0;\n\t    else ret = ret + find(idx[i]);\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[i+1].emplace_back(p, 1);\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tvector<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tint sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.push_back(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, pii>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), pii(*u, -1));\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tconst pii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second.first;\n\t\t\t\t\tconst int p = que.front().second.second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v].first <= c.first) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tFOR(e, g[v])if(e->first!=p)\n\t\t\t\t\t\tque.emplace(pii(c.first+1, c.second), pii(e->first, v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main() {\n    int N, Q;\n    int mark[100001];\n    int tree[100001];\n    while (1) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        fill_n(mark, 100001, 0);\n        mark[1] = 1; \n        tree[1] = 0;\n        for (int i=2; i<=N; ++i) {\n            cin >> tree[i];\n        } \n\n        long long sum = 0;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            if (ope == 'Q') {\n                for (int j=v; j>=1; j=tree[j]) {\n                    if (mark[j] == 1) {\n                        sum += j;\n                        break;\n                    }\n                }\n            } else if (ope == 'M') {\n                mark[v] = 1;\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\nconst int maxn = 5e5+5;\nint n,m;\nint far[maxn];\nint Rank[maxn];\nint Mark[maxn];\nint find(int x){\n\tif(far[x] == x || Mark[x])return x;\n\telse return find(far[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\t\n\tif(Rank[x] < Rank[y]) far[x] = y;\n\telse\n\t{\n\t\tfar[y] = x;\n\t\tif(Rank[x] == Rank[y]) Rank[x]++;\n\t}\n}\nbool check(int x,int y){\n\treturn find(x) == find(y);\n}\nvoid init(int n){\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tfar[i] = i;\n\t\tRank[i] = 0;\n\t\tMark[i] = 0;\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d %d\",&n,&m) &&(m||n))\n\t{\n\t\tinit(n);\n\t\tint a;\n\t\tint ans = 0;\n\t\tfor(int i = 1;i < n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tfar[i] = a;\n\t\t\tif(a == i) Mark[i] = 1;\n\t\t}\n\t\tchar c[3];\n\t\tfor(int i = 0;i <m;i++)\n\t\t{\n\t\t\tscanf(\"%s %d\",c,&a);\n\t\t\tif(c[0] == 'M') Mark[a] = 1;\n\t\t\telse  \n\t\t\t{\n\t\t\t\tans += find(a);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nvector<int> G[1000005],GG[1000005];\nint val[1000005];\nint path[100005];\nbool vis[100005];\nint n,q;\n\nvoid init(){\n\tfor(int i=0;i<=n;++i){\n\t\tval[i]=1;\n\t\tpath[i]=0;\n\t\tG[i].clear();\n\t}\n}\n\nvoid dfs(int root){\n\tif(vis[root])return ;\n\tvis[root]=1;\n\tfor(int i=0;i<G[root].size();++i){\n\t\tif(vis[G[root][i]])continue;\n\t\tpath[G[root][i]]=path[root]+1;\n\t\tdfs(G[root][i]);\n\t}\n}\n\nvoid dfsG(int root,int cnt,int x){\n\tif(vis[root])return ;\n\tvis[root]=1;\n\tfor(int i=0;i<G[root].size();++i){\n\t\tint son = G[root][i];\n\t\tif(vis[son])continue;\n\t\tif(path[son]>cnt){\n\t\t\tpath[son]=cnt;\n\t\t\tval[son]=x;\n\t\t\tdfsG(son,cnt+1,x);\n\t\t}\n\t}\n}\n\nvoid bfs(int root){\n\tqueue<int>q;\n\tq.push(root);\n\tmemset(vis,0,sizeof(vis));\n\twhile(!q.empty()){\n\t\tint r = q.front();\n\t\tq.pop();\n\t\tif(vis[r])continue;\n\t\tvis[r]=1;\n\t\tfor(int i=0;i<G[r].size();++i){\n\t\t\tint s=G[r][i];\n\t\t\tif(vis[s])continue;\n\t\t\t//cout<<\"path\"<<' '<<s<<' '<<path[s]<<endl;\n\t\t\tif(path[s]>vis[r]){\n\t\t\t\tvis[s]=vis[r]+1;\n\t\t\t\tval[s]=r;\n\t\t\t\tq.push(s);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\n\twhile(cin>>n>>q && (n||q)){\n\t\tinit();\n\t\tint par;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tscanf(\"%d\",&par);\n\t\t\tG[par].push_back(i);\n\t\t\tG[i].push_back(par);\t\t\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tdfs(1);\n\t\tval[1]=0;\n\t\tchar s[2];\n\t\tint x;\n\t\tll sum = 0;\n\t\tfor(int i=0;i<q;++i){\n\t\t\tscanf(\"%s %d\",s,&x);\n\t\t\tif(s[0]=='Q')sum+=val[x];\n\t\t\telse {\n\t\t\t\tbfs(x);\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n } "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\n// lazy evaluate segment tree\ntypedef int data_type;\nconst data_type dINF = iINF;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q; int v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    HeavyLightDecomposition(int n_ = 0) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\nint n,q;\nchar qt[100010];\nint qv[100010];\nHeavyLightDecomposition h;\n\nlong long solve(){\n    long long ans = 0;\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(cin >> n >> q && n){\n        h = HeavyLightDecomposition(n);\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            h.addEdge(par-1,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Node {\n    int parent;\n    vector<int> children;\n};\n\nstruct HLNode {\n    int parent;\n    int position;   // position in the parent's path.\n    vector<int> children;\n    vector<int> path;\n};\n\nstruct Decompose {\n    const vector<Node>& tree;\n    vector<HLNode>& decomposed;\n    pair<int, int> operator()(int u) const {\n        if (tree[u].children.empty()) {\n            decomposed.push_back((HLNode){-1, -1, vector<int>(), vector<int>(1, u)});\n            return make_pair(1, decomposed.size()-1);\n        } else {\n            int max_weight = -1, max_index = -1, total_weight = 0;\n            vector<int> indices(tree[u].children.size());\n            REP(i, tree[u].children.size()) {\n                int v = tree[u].children[i];\n                int weight, idx; tie(weight, idx) = (*this)(v);\n                indices[i] = idx;\n                total_weight += weight;\n                if (weight > max_weight) {\n                    max_weight = weight;\n                    max_index = idx;\n                }\n            }\n            for (int idx : indices) if (idx != max_index) {\n                decomposed[idx].parent = max_index;\n                decomposed[idx].position = decomposed[max_index].path.size();\n                decomposed[max_index].children.push_back(idx);\n            }\n            decomposed[max_index].path.push_back(u);\n            return make_pair(total_weight+1, max_index);\n        }\n    }\n};\n\n// ??¨??? Heavy-Light Decomposition ????????????\n// Arguments:\n//   tree: ??¨???\n//   root: ?????¨???????????????????????????\n// Returns:\n//   vector<HLNode>: ????´?????????¨???\n//   int: ????´?????????¨????????¨???????????????????????????\npair<vector<HLNode>, int> heavy_light_decomposition(const vector<Node>& tree, int root) {\n    vector<HLNode> decomposed;\n    int index; tie(ignore, index) = (Decompose){tree, decomposed}(root);\n    for (auto& node : decomposed) {\n        reverse(node.path.begin(), node.path.end());\n        if (node.parent != -1)\n            node.position = decomposed[node.parent].path.size() - node.position - 1;\n    }\n    return make_pair(move(decomposed), index);\n}\n\n/*\ntemplate <class N>\nvoid print_tree(const vector<N>& tree, int u) {\n    cout << \"(\" << u;\n    for (int child : tree[u].children) {\n        cout << \" \";\n        print_tree(tree, child);\n    }\n    cout << \")\";\n}\n\ntemplate <typename T>\nvoid print_vector(const vector<T>& v) {\n    REP(i, v.size()) {\n        if (i != 0) cout << \", \";\n        cout << v[i];\n    }\n}\n*/\n\ntemplate <typename Int>\nstruct FenwickTree {\n  vector<Int> data;\n  explicit FenwickTree(int n): data(n, 0) {}\n  void set(int i, Int x) { for (; i < (int)data.size(); i |= i+1) data[i] = max(data[i], x); }\n  Int maximum(int i) const { Int s = 0; for (; i >= 0; i = (i & (i+1)) - 1) s = max(s, data[i]); return s; }\n};\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, Q;\n    while (cin>>N>>Q, N|Q) {\n        vector<Node> tree(N);\n        tree[0].parent = -1;\n        FOR(i, 1, N) {\n            int p; cin >> p; --p;\n            tree[i].parent = p;\n            tree[p].children.push_back(i);\n        }\n\n        auto t = heavy_light_decomposition(tree, 0);\n        auto& decomposed = t.first;\n        /*\n        int root = t.second;\n        cout << \"Original:\\n\";\n        print_tree(tree, 0);\n        cout << \"\\nDecomposed:\\n\";\n        print_tree(decomposed, root);\n        cout << \"\\nPaths:\\n\";\n        REP(i, decomposed.size()) {\n            cout << i << \": \";\n            print_vector(decomposed[i].path);\n            cout << \"\\n\";\n        }\n        cout << \"Positions:\\n\";\n        REP(i, decomposed.size()) {\n            cout << i << \": \" << decomposed[i].position << endl;\n        }\n        */\n\n        vector<int> node_mapping(N);\n        vector<int> position_mapping(N);\n        REP(i, decomposed.size()) {\n            auto& node = decomposed[i];\n            REP(j, node.path.size()) {\n                int v = node.path[j];\n                node_mapping[v] = i;\n                position_mapping[v] = j;\n            }\n        }\n\n        vector<FenwickTree<int>> fenwick_trees;\n        for (auto& node : decomposed)\n            fenwick_trees.emplace_back(node.path.size());\n\n        long long sum = 0;\n        REP(query_index, Q) {\n            char q; int v; cin >> q >> v; --v;\n            if (q == 'M') {\n                fenwick_trees[node_mapping[v]].set(position_mapping[v], v);\n            } else {\n                int ans = 0, u = node_mapping[v], p = position_mapping[v];\n                while (u != -1) {\n                    ans = max(ans, fenwick_trees[u].maximum(p));\n                    p = decomposed[u].position;\n                    u = decomposed[u].parent;\n                }\n                sum += ans + 1;\n            }\n        }\n        cout << sum << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(auto i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(auto i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//Setting\n#define OPT std::cin.tie(0);std::ios::sync_with_stdio(false);\n\n//debug message\nbool debug = true;\n#define MSG(s)   if(debug){std::cout << s << std::endl;}\n#define DEBUG(x) if(debug){std::cout << \"debug(\" << #x << \"): \" << x << std::endl;}\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\n\nconst int MAX_N = 100000;\n\nint N, M;\nVI2 tree(MAX_N);\n\nVI parent(MAX_N);\nVI depth(MAX_N);\nVI graph(MAX_N);\nstd::vector<bool> isMark(MAX_N, false);\nstd::vector<std::pair<char,int>> query(MAX_N);\n\n//uf\nint find(int x){\n    if(parent[x] == x){\n        return x;\n    }else {\n        return parent[x] = find(parent[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] > depth[y]){\n        parent[x] = y;\n    }else{\n        parent[y] = x;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid dfs(int k) {\n    for(int i: tree[k]) {\n        if(graph[i] != -1) continue;\n        depth[i] = depth[k] + 1;\n        graph[i] = k;\n        dfs(i);\n    }\n}\n\n\n\n\nint main(){\n    while(std::cin >> N >> M, N != 0 && M != 0) {\n        REP(i, N) {\n            parent[i] = i;\n            depth[i] = 0;\n            graph[i] = -1;\n            isMark[i] = false;\n\n            tree[i].clear();\n            query.clear();\n        }\n\n        REP(i, N-1) {\n            int a;\n            std::cin >> a;\n            --a;\n            tree[i+1].push_back(a);\n            tree[a].push_back(i+1);\n        }\n\n        isMark[0] = true;\n        REP(i, M) {\n            char q;\n            int k;\n\n            std::cin >> q >> k;\n            --k;\n            if(q == 'M') {\n                if(isMark[k]) continue;\n                isMark[k] = true;\n                query.push_back(std::make_pair(q, k));\n            } else {\n                query.push_back(std::make_pair(q, k));         \n            }\n        }\n\n        graph[0] = 0;\n        dfs(0);\n\n        REP(i, N) {\n            if(!isMark[i]) {\n                unite(graph[i], i);\n            }\n        }\n\n        LL ans = 0;\n        for(auto it=query.rbegin(), _END=query.rend(); it != _END; ++it) {\n            if(it->first == 'Q') {\n                ans += find(it->second) + 1;\n            } else {\n                unite(graph[it->second], it->second);\n            }\n        }\n        std::cout << ans << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint p[100000], par[100000], t[100000];\nint find(int x) {\n\tif (x == par[x])return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tpar[find(x)] = find(y);\n}\nchar s[100000][2];\nbool m[100000];\nint main() {\n\tint n, q;\n\twhile (scanf(\"%d%d\", &n, &q), n) {\n\t\trep(i, n)par[i] = i;\n\t\trep(i, n - 1)scanf(\"%d\", &p[i + 1]), p[i + 1]--;\n\t\tmemset(m, 0, sizeof(m)); m[0] = 1;\n\t\trep(i, q) {\n\t\t\tscanf(\"%s%d\", s[i], &t[i]); t[i]--;\n\t\t\tif (s[i][0] == 'M')m[t[i]] = 1;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!m[i])unite(i, p[i]);\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (s[i][0] == 'M')unite(t[i], p[t[i]]);\n\t\t\telse ans += find(t[i]) + 1;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nint sum;\nint find(int x,int flag){\n    if(flag)    return 0;\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define sz(x) ((int)(x).size())\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nstruct UnionFind{\n\tint par[100100],rank[100100];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t\treturn;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tpar[y]=x;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nint N,Q;\nchar qtype[100100];\nint qval[100100];\nint par[100100];\nint col[100100];\nvector<int> g[100100];\nvoid dfs(int v,int val){\n\tif(col[v]==-1)col[v]=val;\n\tfor(int i=0;i<g[v].size();i++)dfs(g[v][i],col[v]);\n}\nint solve(){\n\tscanf(\"%d %d\",&N,&Q);\n\tif(N+Q==0)return 1;\n\tuf.init(N+10);\n\tfor(int i=1;i<=N;i++)g[i].clear();\n\tfor(int i=2;i<=N;i++)scanf(\"%d\",&par[i]);\n\tfor(int i=2;i<=N;i++){\n\t\tg[par[i]].pb(i);\n\t}\n\tcol[1]=1;\n\tfor(int i=2;i<=N;i++)col[i]=-1;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\" %c %d\",&qtype[i],&qval[i]);\n\t\tif(qtype[i]=='M')col[qval[i]]=qval[i];\n\t}\n\tdfs(1,1);\n\t//for(int i=1;i<=N;i++)printf(\"%d:%d\\n\",i,col[i]);\n\tfor(int i=1;i<=N;i++){\n\t\tif(col[i]!=i)uf.unite(col[i],i);\n\t}\n\tll ans = 0;\n\tfor(int i=Q-1;i>=0;i--){\n\t\tint val = qval[i];\n\t\tif(qtype[i]=='M'){\n\t\t\tuf.unite(par[val],val);\n\t\t}else{\n\t\t\tans += (ll)uf.find(val);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate<class T>inline string toString(T x){\n        ostringstream sout; sout<<x; return sout.str();\n}\nconst ll MOD=1e9+7;\nconst int inf=(ll)1e9;\nconst double PI=acos(-1.0);\n\nstruct UF\n{\n\tint par[100001];\n\tbool mark[100001];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=0;\n\t\t\tmark[i]=0;\n\t\t}\n\t\tmark[0]=1;\n\t}\n\tvoid parent(int p,int c){\n\t\tpar[c]=p;\n\t}\n\tvoid Mark(int a){\n\t\tmark[a]=1;\n\t}\n\tint find(int a){\n\t\tif(mark[a])return a;\n\t\telse return find(par[a]);\n\t}\n\tvoid test(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcerr<<par[i]<<\" \";\n\t\t}\n\t\tcerr<<endl;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcerr<<mark[i]<<\" \";\n\t\t}\n\t\tcerr<<endl;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m){\n    \tif(n==0 && m==0)return 0;\n    \tUF uf;\n    \tuf.init(n);\n    \tfor(int i=1;i<n;i++){\n    \t\tint a;cin>>a;a--;\n    \t\tuf.parent(a,i);\n    \t}\n    \tll ans=0;\n    \tfor(int i=0;i<m;i++){\n    \t\tchar a;\n    \t\tint b;\n    \t\tcin>>a>>b;b--;\n    \t\tif(a=='M'){\n    \t\t\tuf.Mark(b);\n    \t\t\t//uf.test(n);\n    \t\t}else{\n    \t\t\tans+=uf.find(b)+1;\n    \t\t}\n    \t}\n    \tcout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\nconst int MAXN = 100000 + 10;\nint par[MAXN];\nint Find(int x){\n\tif (x == par[x])\n\t\treturn par[x];\n\treturn Find(par[x]);\n}\nint main(){\n\tint n, q;\n\tchar ins[10];\n\tint v;\n\n\twhile (~scanf(\"%d%d\", &n, &q) && n && q){\n\t\tlong long sum = 0;\n\t\tpar[1] = 1;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%s%d\", ins, &v);\n\t\t\tif (strcmp(ins, \"M\") == 0){\n\t\t\t\tpar[v] = v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += Find(v);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n/*\n    AOJ 2170 Marked Ancestor\n*/\n\n/*\n6 3\n1\n1\n2\n3\n3\nQ 5\nM 3\nQ 5\n0 0\n\n\n4\n*/\n\ntypedef long long ll;\n\nconst ll MAX_N = 1e5 + 10;\nconst ll MAX_Q = 1e5 + 10;\n\nll N = 0;\nll Q = 0;\nchar OP[MAX_Q];\nll NUM[MAX_Q];\n\n// 实现并查集\nll par[MAX_N + 1];\nll rnk[MAX_N + 1];\n\nvoid init(ll n) {\n    for (ll i = 0; i <= n; i++) {\n        par[i] = i;\n        rnk[i] = 0;\n    }\n}\n\nll find(ll x) {\n    if (par[x] == x) {\n        return x;\n    }\n\n    return find(par[x]);    // 在本题, 这个不能使用路径压缩策略. 因为本质上并不是并查集. 而只是一棵普通的树.\n}\n\nvoid solve() {\n    ll res = 0;\n    for (ll i = 0; i < Q; i++) {\n        if (OP[i] == 'Q') {\n            res += find(NUM[i]);\n        }\n        else if (OP[i] == 'M') {\n            ll tmp = NUM[i];\n            par[tmp] = tmp;\n        }\n    }\n\n    printf(\"%lld\\n\", res);\n}\n\nint main() {\n    while (scanf(\"%lld %lld\", &N, &Q) != EOF) {\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        init(N);\n        for (ll i = 2; i <= N; i++) {\n            scanf(\"%lld\", &par[i]);\n        }\n        getchar();\n        for (ll i = 0; i < Q; i++) {\n            scanf(\"%c %lld\", &OP[i], &NUM[i]);\n            getchar();\n        }\n\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    bool mark[100001];\n    int tree[100001];\n    while (1) {\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            break;\n        }\n\n        memset(mark, false, sizeof(mark));\n        mark[1] = true; \n        tree[1] = 0;\n        for (int i=2; i<=N; ++i) {\n            cin >> tree[i];\n        } \n\n        long long sum = 0;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            if (ope == 'Q') {\n                for (int j=v; j>=1; j=tree[j]) {\n                    if (mark[j] == true) {\n                        sum += j;\n                        break;\n                    }\n                }\n            } else if (ope == 'M') {\n                mark[v] = true;\n            }\n        }\n        cout << sum << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nbool marked[100000];\nint prt[100000];\n\nint gm(int i) {\n  if (marked[i]) return i;\n  return prt[i] = gm(prt[i]);\n}\n\nint main() {\n  while(1) {\n    int n,q;\n    cin>>n>>q;\n    if(!n) break;\n    REP(i,n)marked[i]=false;\n    marked[0] = true;\n    REP(i,n-1) {\n      cin>>prt[i+1];\n      --prt[i+1];\n    }\n    vector<tuple<int,int>> ql;\n    REP(i,q){\n      string c;\n      int v;\n      cin>>c>>v;\n      --v;\n      ql.emplace_back(c==\"Q\", v);\n      if (c==\"M\")\n        marked[v] = true;\n    }\n    reverse(begin(ql),end(ql));\n    int sum = 0;\n    REP(i,q){\n      int c,v;\n      tie(c,v) = ql[i];\n      if(c) // Q\n        sum += gm(v) + 1;\n      else\n        marked[v] = false;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pi=pair<int,int>;\n\nvector<int> treerank;\nvector<vector<int>> G;\nvector<bool> visited;\nvector<int> et;\nvector<pi> pos;\n\ntemplate <typename T>\nstruct LazySegmentTree{\nprivate:\n    int n;\n    T init;\n    vector<T> node;\n    vector<T> lazy;\n\n    void update(int k){\n        if(lazy[k]!=0){\n            if(treerank[node[k]]<treerank[lazy[k]])node[k]=lazy[k];\n            if(k<n-1){\n                if(treerank[lazy[2*k+1]]<treerank[lazy[k]])lazy[2*k+1]=lazy[k];\n                if(treerank[lazy[2*k+2]]<treerank[lazy[k]])lazy[2*k+2]=lazy[k];\n            }\n            lazy[k]=0;\n        }\n    }\npublic:\n    explicit LazySegmentTree(int sz,T initv=0){\n        n=1;\n        init = initv;\n        while(n<sz)n=n*2;\n        node.assign(static_cast<unsigned int>(2*n-1),init);\n        for (int i = 0; i < sz; ++i) {\n            node[i+n-1]=init;\n        }\n        lazy.assign(static_cast<unsigned int>(2*n-1),init);\n    }\n\n    void mark(int p,int q,T val,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        update(k);\n        if(r<=p||l>=q)return;\n        if(p<=l&&r<=q){\n            lazy[k]=val;\n            update(k);\n        }\n        else{\n            mark(p,q,val,2*k+1,l,(l+r)/2);\n            mark(p,q,val,2*k+2,(l+r)/2,r);\n            if(treerank[node[2*k+1]]<treerank[node[2*k+2]])node[k]=node[2*k+2];\n            else node[k]=node[2*k+1];\n        }\n    }\n\n    T query(int p,int q,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=p||l>=q)return 0;\n\n        update(k);\n        if(p<=l&&r<=q)return node[k];\n        T vl=query(p,q,2*k+1,l,(l+r)/2);\n        T vr=query(p,q,2*k+2,(l+r)/2,r);\n        if(treerank[vl]<treerank[vr])return vr;\n        else return vl;\n    }\n};\n\nvoid dfs(int x,int rank){\n    pos[x].first=et.size();\n    et.push_back(x);\n    visited[x]=true;\n    treerank[x]=rank;\n    for(auto i:G[x]){\n        if(visited[i])continue;\n        dfs(i,rank+1);\n    }\n    pos[x].second=et.size();\n    et.push_back(x);\n}\n\nvoid EulerTour(){\n    treerank.resize(G.size());\n    treerank[0]=0;\n    et.clear();\n    visited.assign(G.size(),false);\n    for (int i = 0; i < G.size(); ++i) {\n        if(visited[i])continue;\n        dfs(i,0);\n    }\n}\n\nbool solve(){\n    int n,q;\n    cin>>n>>q;\n    if(n==0)return false;\n    G.resize(n);\n    pos.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int a;\n        cin>>a;\n        --a;\n        G[a].push_back(i);\n    }\n    EulerTour();\n    LazySegmentTree<int> st(2*n);\n    long long ans=0;\n    for (int Q = 0; Q < q; ++Q) {\n        char c;\n        cin>>c;\n        int x;\n        cin>>x;\n        --x;\n        if(c=='Q'){\n            //cout<<ans<<endl;\n            ans+=st.query(pos[x].first,pos[x].first+1)+1;\n        }\n        else{\n            st.mark(pos[x].first,pos[x].second+1,x);\n        }\n    }\n    cout<<ans<<endl;\n    treerank.clear();\n    G.clear();\n    pos.clear();\n    et.clear();\n    pos.clear();\n    return true;\n}\n\n\nint main(){\n    while(solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)b[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]]++;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M' && K[i] != 1) {\n\t\t\t\tb[K[i]]--;\n\t\t\t\tif (b[K[i]] == 0)UF.unite(a[K[i]], K[i]);\n\t\t\t}\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\tsum += D; break;\n\t\t\t\t\t}\n\t\t\t\t\tD = a[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int SIZE_N = 100000; \nbool marked[SIZE_N];\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\tUnionFind(int n) :par(n) {\n\t\tfor (int i=0; i<n; ++i) par[i] = i;\n\t}\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y); \n\t\tif (x == y) return;\n\t\tpar[y] = x;\n\t}\n\t// bool same(int x, int y) {\n\t// \treturn root(x) == root(y);\n\t// }\n};\n\nint main() {\n\tint N, Q;\n\twhile (cin >> N >> Q, N) {\n\t\tvector<int> p(N);\n\t\tfor (int i=1; i<N; ++i) {\n\t\t\tcin >> p[i];\n\t\t\tp[i] --;\n\t\t}\n\t\tfill(marked, marked+SIZE_N, false);\n\t\tmarked[0] = true;\n\t\tvector<pair<char,int>> qu(Q);\n\t\tfor (int i=0; i<Q; ++i) {\n\t\t\tcin >> qu[i].first >> qu[i].second;\n\t\t\tqu[i].second --;\n\t\t\tif (qu[i].first == 'M') {\n\t\t\t\tif (marked[qu[i].second]) {\n\t\t\t\t\tqu[i].first = '_';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmarked[qu[i].second] = true;\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(N);\n\t\tfor (int i=1; i<N; ++i) {\n\t\t\tif ( ! marked[i]) uf.unite(p[i], i);\n\t\t}\n\t\tlong long ans = 0;\n\t\tfor (int i=Q-1; i>=0; --i) {\n\t\t\tif (qu[i].first == 'Q') {\n\t\t\t\tans += uf.root(qu[i].second) + 1;\n\t\t\t} else if (qu[i].first == 'M') {\n\t\t\t\tif (qu[i].second != 0) uf.unite(p[qu[i].second], qu[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,q;\nchar c[100100];\nint v[100100], p[100100];\nint marked[100100], root[100100];\n\nint main(){\n  while(scanf(\"%d%d\",&n,&q), n){\n    for(int i=1;i<n;i++){\n      scanf(\"%d\",&p[i]); p[i]--;\n    }\n    memset(marked,0,sizeof(marked));\n\n    marked[0] = 1;\n    for(int i=0;i<q;i++){\n      scanf(\" %c %d \",&c[i],&v[i]); v[i]--;\n      if(c[i]=='M')marked[v[i]]++;\n    }\n\n    UF uf(n);\n    for(int i=1;i<n;i++){\n      if(!marked[i])uf.unite(i,p[i]);\n    }\n\n    for(int i=0;i<n;i++){\n      if(marked[i])root[uf.find(i)] = i;\n    }\n\n    long long ans = 0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i] == 'M'){\n\tmarked[v[i]]--;\n\tif(marked[v[i]] == 0){\n\t  int tmp = root[uf.find(p[v[i]])];\n\t  uf.unite(v[i],p[v[i]]);\n\t  root[uf.find(v[i])] = tmp;\n\t}\n      }else{\n\tans += root[uf.find(v[i])] + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\n//再利用する場合はMAX_Nの値を設定し直すことを忘れない！！！\n//Union-Find木を少し改造\n\nconst int MAX_N = 100005;\n\nint Par[MAX_N];\nbool Marked[MAX_N];\n//int Rank[MAX_N];\n\nvoid init(int n){  //0~n-1まで初期化\n    for (int i = 0; i < n; i++) {\n        Par[i] = i;\n        //Rank[i] = 0;\n    }\n}\n\nint find(int x) {  //xの根を返す\n    if (Marked[x]) return x;\n    else {\n        return find(Par[x]);\n    }\n}\n\nvoid unite(int x, int y) {  //xとyを併合.ただし、yをxに繋げる\n    Par[y] = x;\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n\n\nint N;  //Nodeの数\nint Q;  //Operationの数\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) break;\n        init(N);\n        fill(Marked, Marked+N, false);\n        Marked[0] = true;\n        for (int i = 1; i < N; i++) {  //1~N-1まで\n            int p;  //iの親\n            scanf(\"%d\", &p);\n            unite(p-1,i);  //iをpに繋げる\n        }\n        int ret = 0;\n        for (int i = 0; i < Q; i++) {\n            char c;\n            int v;\n            scanf(\" %c %d\", &c, &v);\n            if (c == 'Q') {  //Markの付いた最近の祖先を調べる\n                ret += find(Par[v-1]);  //自分にMarkが入っている時に、自分をカウントしないようにする\n                ret++;\n            } else if (c == 'M') {  //印をつける\n                Marked[v-1] = true;\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\t\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\n//再利用する場合はMAX_Nの値を設定し直すことを忘れない！！！\n//Union-Find木を少し改造\n\nconst int MAX_N = 100005;\n\nint Par[MAX_N];\nbool Marked[MAX_N];\n//int Rank[MAX_N];\n\nvoid init(int n){  //0~n-1まで初期化\n    for (int i = 0; i < n; i++) {\n        Par[i] = i;\n        //Rank[i] = 0;\n    }\n}\n\nint find(int x) {  //xの根を返す\n    if (Marked[x]) return x;\n    else {\n        return find(Par[x]);\n    }\n}\n\nvoid unite(int x, int y) {  //xとyを併合.ただし、yをxに繋げる\n    Par[y] = x;\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n\n\nint N;  //Nodeの数\nint Q;  //Operationの数\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) break;\n        init(N);\n        fill(Marked, Marked+N, false);\n        Marked[0] = true;\n        for (int i = 1; i < N; i++) {  //1~N-1まで\n            int p;  //iの親\n            scanf(\"%d\", &p);\n            unite(p-1,i);  //iをpに繋げる\n        }\n        int ret = 0;\n        for (int i = 0; i < Q; i++) {\n            char c;\n            int v;\n            scanf(\" %c %d\", &c, &v);\n            if (c == 'Q') {  //Markの付いた最近の祖先を調べる\n                ret += find(v-1);\n                ret++;\n            } else if (c == 'M') {  //印をつける\n                Marked[v-1] = true;\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tmarked[1] = true;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t}\n}\nint getnode(int x){\n\tif(par[x]==x||marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tint sum;\n\tinit(n);\n\twhile(cin>>n>>q,n||q){\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\tsum +=getnode(k);\n\t\t\t}\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout <<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll maxi=buf.query(0,(int)checked[pos][i]);\n\t\tif(maxi>=0) ret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n,q;\nint tree[100050];\n\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&q)==2)\n    {\n        if(n==0&&q==0)\n            break;\n        tree[1]=1;\n        for(int i=2;i<=n;i++)\n            scanf(\"%d\",&tree[i]);\n        getchar();\n        long long ans=0;\n        for(int i=1;i<=q;i++)\n        {\n            int temp;\n            char s[100];\n            gets(s);\n            sscanf(&s[2],\"%d\",&temp);\n            if(s[0]=='M')\n                tree[temp]=temp;\n            else if(s[0]=='Q')\n                ans+=Find(temp);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n[C++]"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int NMAX = 1e6;\nint par[NMAX];\nbool marked[NMAX];\n\nvoid init(int n) {\n  par[1] = 1;\n  marked[1] = true;\n  for (int i = 2; i <= n; i++) {\n    marked[i] = false;\n  }\n}\n\nint find(int x) {\n  if (marked[x]) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    init(N);\n    if (N > 1) {\n      for (int i = 2; i <= N; i++) {\n        cin >> par[i];\n      }\n    }\n\n    stack<pair<bool,int>> s;\n    for (int i = 0; i < Q; i++) {\n      char c; int node;\n      cin >> c >> node;\n      if (c == 'M' && !marked[node]) {\n        marked[node] = true;\n        s.push(make_pair(true, node));\n      } else if (c == 'Q') {\n        s.push(make_pair(false, node));\n      }\n    }\n\n    long long int sum = 0;\n    while (!s.empty()) {\n      pair<bool,int> p = s.top(); s.pop();\n      if (p.first) {\n        marked[p.second] = false;\n      } else {\n        sum += find(par[p.second]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <string>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cstring>\n#include <set>\n#include <queue>\n#include <cmath>\n\n//#define Local\nusing namespace std;\nint p[100010];\nint mark[100010];\nint find(int id)\n{\n\tif (mark[id]) return id;\n\tmark[id] = find(p[id]);\n\treturn mark[id];\n}\nint main() {\n\tchar line[10];\n\tint n, t, m;\n\tint cases = 0, oth;\n\tint c = 1;\n#ifdef Local\n\tifstream ifs(\"input.txt\");\n\twhile(ifs >> n>>m&&(n||m))\n#else\n\t//        while(~scanf(\"%d%d\",&n,&d))\n\twhile(scanf(\"%d%d\", &n,&m)&&(n||m))\n#endif\n\t{\n\t\tint maxv = 0;\n\t\tp[1] = 1;\n\t\tfor (int i = 1; i < n; ++i){\n#ifdef Local\n\t\t\tifs >>  cases;\n#else\n\t\t\t//cin >> line >> cases >> oth;\n\t\t\tscanf(\"%d\", &cases);\n#endif\n\t\t\tp[i+1] = cases;\n\t\t}\n\t\tmemset(mark, 0, sizeof mark);\n\t\tmark[1] = 1;\n\t\tfor(int i=0;i<m;++i){\n#ifdef Local\n\t\t\tstring line;\n\t\t\tifs >> line >> cases;\n#else\n\t\t\tscanf(\"%s %d\", line, &cases);\n#endif\n\t\t\tswitch (line[0])\n\t\t\t{\n\t\t\tcase 'Q':\n\t\t\t\tmaxv += find(p[cases]);\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tmark[cases] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << maxv << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct UnionFind {\n    vector<int> par, value;\n    int n, cnt;\n    UnionFind(const int& x = 0) {init(x);}\n    void init(const int& x) {par.assign(cnt=n=x, -1);}\n    inline int find(const int& x) {return par[x] < 0 ? x : par[x] = find(par[x]);}\n    inline bool same(const int& x, const int& y) {return find(x) == find(y);}\n    inline bool unite(int x, int y) {\n        if ((x = find(x)) == (y = find(y))) return false;\n        --cnt;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    inline int count() const {return cnt;}\n    inline int count(int x) {return -par[find(x)];}\n};\n\nconst int MAXN = 100100;\npair<char, int> query[MAXN];\n\nint par[MAXN], value[MAXN], cnt[MAXN];\n\nint getPar(int v) {\n    if (cnt[v]) return v;\n    else return par[v] = getPar(par[v]);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, Q;\n    while (cin >> N >> Q) {\n        if (N==0 && Q==0) break;\n        memset(par, -1, sizeof(par));\n        memset(cnt, 0, sizeof(cnt));\n        for (int i = 1; i < N; i++) {\n            int p;\n            cin >> p; p--;\n            par[i] = p;\n        }\n        cnt[0] = 1;\n        for (int i = 0; i < Q; i++) {\n            cin >> query[i].first >> query[i].second;\n            query[i].second--;\n            if (query[i].first == 'M') {\n                cnt[query[i].second]++;\n            }\n        }\n        ll ans = 0;\n        for (int i = Q-1; i >= 0; i--) {\n            char c = query[i].first;\n            int v = query[i].second;\n            if (c == 'M') cnt[v]--;\n            else ans += getPar(v)+1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <memory.h>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nint N;\nint Q;\nbool marked[MAX_N + 4];\nint par[MAX_N + 16];\n\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    }\n    return find(par[x]);\n}\n\nint main() {\n    while (scanf(\"%d %d\", &N, &Q) && N) {\n        long long res = 0;\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", &par[i]);\n        }\n        par[1] = 1;\n        cin.ignore();\n        char operation;\n        int node;\n        for (int i = 0; i < Q; i++) {\n            scanf(\"%c %d\", &operation, &node);\n            if (operation == 'Q') {\n                res += find(node);\n            }\n            else if (operation == 'M') {\n                par[node] = node;\n            }\n            cin.ignore();\n        }\n        cout << res;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nvoid dfs(int now, int pre, int lma, vi& group, const vector<bool>& marked, const Graph& G) {\n    if (marked[now]) lma = now;\n    group[now] = lma;\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs(nxt, now, lma, group, marked, G);\n    }\n}\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    // x <- y\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        // if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    int getSize(int x) {\n        return -uni[root(x)];\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, q;\n    while (cin >> n >> q, n) {\n        Graph G(n);\n        vi par(n);\n        par[0] = -1;\n        rep2(i, 1, n) {\n            cin >> par[i];\n            par[i]--;\n            G[i].emplace_back(par[i]);\n            G[par[i]].emplace_back(i);\n        }\n\n        vector<char> type(q);\n        vi vertex(q);\n        vector<bool> marked(n);\n        marked[0] = true;\n        rep(i, q) {\n            cin >> type[i] >> vertex[i];\n            vertex[i]--;\n            if (type[i] == 'M') {\n                marked[vertex[i]] = true;\n            }\n        }\n\n        vi group(n);\n        dfs(0, -1, 0, group, marked, G);\n\n        UnionFind uf(n);\n        rep(i, n) {\n            uf.unite(group[i], i);\n        }\n\n        int ans = 0;\n        rrep(i, q) {\n            int v = vertex[i];\n            if (type[i] == 'M') {\n                if (v == 0) continue;\n                uf.unite(par[v], v);\n            }\n            else {\n                ans += uf.root(v) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<vector>\n#define oo 0x3f3f3f33f\nusing namespace std;\nint n, m, vis[100010];\nlong long pre[100010];\nlong long Quary(int x)\n{\n    long long k=pre[x];\n    if(vis[k]==1)\n        return k;\n    return Quary(pre[x]);\n}\nint main()\n{\n    int i;\n    while(scanf(\"%d%d\", &n, &m), n+m)\n    {\n        char order;\n        long long ans = 0, root, v;\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(i=1; i<=n; i++)\n            pre[i]=i;\n        for(i=2; i<=n; i++)\n        {\n            scanf(\"%lld\", &root);\n            pre[i]=root;\n        }\n        getchar();\n        for(i=0; i<m; i++)\n        {\n            scanf(\"%c%lld\", &order, &v);\n            if(order=='M')\n                vis[v]=1;\n            else\n                ans+=Quary(v);\n            getchar();\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nint N, Q;\nint p[MAX_N+5];\nbool M[MAX_N+5];\nint uf_par[MAX_N+5];\nint uf_rank[MAX_N+5];\nint mark[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < N; i++) {\n        uf_par[i] = i;\n        uf_rank[i] = 0;\n        mark[i] = i;\n        p[i] = 0;\n        M[i] = false;\n    }\n}\n\nint find(int x) {\n    if (uf_par[x] == x) {\n        return x;\n    } else {\n        return uf_par[x] = find(uf_par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(uf_rank[x] < uf_rank[y]) {\n        uf_par[x] = y;\n        mark[y] = mark[x];\n    } else {\n        uf_par[y] = x;\n        if(uf_rank[x] == uf_rank[y]) uf_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid debug() {\n    for(int i = 0; i < N; i++) {\n        cout << i << \": \" << mark[i] << \": \" << find(i) << \": \" << mark[find(i)] << endl;\n    }\n}\n\nint main() {\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        init(N);\n        for(int i = 1; i < N; i++) {\n            cin >> p[i];\n            p[i]--;\n        }\n        vector<P> query;\n        char qm;\n        int num;\n        for(int i = 0; i < Q; i++) {\n            cin >> qm >> num;\n            num--;\n            if(qm == 'M') {\n                M[num] = true;\n            }\n            query.push_back(P(qm, num));\n        }\n\n        for(int i = 0; i < N; i++) {\n            if(!M[i]) {\n                cout << \"unite \" << p[i] << \": \" << i << endl;\n                cout << M[i] << endl;\n                unite(p[i], i);\n                debug();\n            }\n        }\n\n        cout << \"====\" << endl;\n        int count = 0;\n        for(int i = query.size()-1; i >= 0; i--) {\n            int n = query[i].second;\n            if(query[i].first == 'M') {\n                cout << \"unite \" << p[n] << \": \" << n << endl;\n                unite(p[n], n);\n                debug();\n            } else {\n                count += mark[find(n)] + 1;\n                cout << \"n: \" << n << \" count += \" << mark[find(n)] << endl;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    HeavyLightDecomposition(int n_ = 0) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\nint n,q;\nchar qt[100010];\nint qv[100010];\nHeavyLightDecomposition h;\n\nlong long solve(){\n    long long ans = 0;\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    while(cin >> n >> q && n){\n        h = HeavyLightDecomposition(n);\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            h.addEdge(par-1,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n#define N 100010\nint n, q;\nint tree[N];\nint Bulid(int x)\n{\n\tif (tree[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn Bulid(tree[x]);\n\t}\n}\nint main()\n{\n\tchar order;\n\tint p;\n\tint sum;\n\twhile (scanf(\"%d%d\", &n, &q) )\n\t{\n\t\tif (n+q==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tsum = 0;\n\t\ttree[1] = 1;\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &tree[i]);\n\t\t}\n\t\tfor (int i = 1; i <= q; i++)\n\t\t{\n\t\t\tgetchar();\n\t\t\tscanf(\"%c %d\", &order, &p);\n\t\t\tif (order == 'Q')\n\t\t\t{\n\t\t\t\tsum += Bulid(p);\n\t\t\t}\n\t\t\telse if (order == 'M')\n\t\t\t{\n\t\t\t\ttree[p] = p;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nclass UnionFind {\nprivate:\n  vector<int> a;\npublic:\n  UnionFind(int n) {rep (i, n) a.push_back(i);}\n  int find(int x) {return a[x] == x ? x : (a[x] = find(a[x]));}\n  bool equal(int x, int y) {return find(x) == find(y);}\n  void unite(int x, int y) {a[find(y)] = find(x);}\n};\n\nint main() {\n  while (true) {\n    int n, q;\n    cin >> n >> q;\n    if (n == 0 && q == 0) break;\n    int parent[n];\n    rep (i, n - 1) {\n      cin >> parent[i + 1];\n      --parent[i + 1];\n    }\n    UnionFind uf(n);\n    vector<pair<int, int> > query;\n    rep (i, q) {\n      string s;\n      int v;\n      cin >> s >> v;\n      --v;\n      if (s == \"M\") query.push_back(make_pair(0, v));\n      else query.push_back(make_pair(1, v));\n    }\n    reverse(query.begin(), query.end());\n    int m[n];\n    rep (i, n) m[i] = 0;\n    m[0] = 1;\n    rep (i, q) if (query[i].first == 0) ++m[query[i].second];\n    rep (i, n) if (m[i] == 0) uf.unite(parent[i], i);\n    long long res = 0;\n    rep (i, q) {\n      if (query[i].first == 0) {\n\t--m[query[i].second];\n\tif (m[query[i].second == 0]) uf.unite(parent[query[i].second], query[i].second);\n      } else {\n\tres += uf.find(query[i].second) + 1;\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct segtree{\n    int n;\n    vector<pii> dat;\n    segtree(int size,pii x){\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,x);\n    }\n    // update k th element\n    void update(int k,pii a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=max(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    // min [a, b)\n    pii query(int a,int b) { return query(a,b,0,0,n); }\n    pii query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return make_pair(-1,-1);\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return max(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    while(true){\n        int n,q;\n        cin >> n >> q;\n        if(n==0 and q==0) break;\n\n        vector<int> parent(n,-1);\n        vector<vector<int>> children(n);\n        vector<bool> is_leaf(n,true);\n        rep(i,1,n){\n            cin >> parent[i];\n            --parent[i];\n            children[parent[i]].emplace_back(i);\n            is_leaf[parent[i]]=false;\n        }\n\n        vector<int> depth(n);\n        vector<vector<int>> belong(n);\n        vector<segtree> segs;\n        function<void(int,int)> calc_depth=[&](const int v,const int d){\n            depth[v]=d;\n            for(const auto& u:children[v]) calc_depth(u,d+1);\n        };\n        calc_depth(0,0);\n        rep(i,0,n) if(is_leaf[i]){\n            segs.emplace_back(segtree(depth[i]+1,make_pair(-1,-1)));\n            segs.back().update(0,make_pair(0,0));\n            int v=i;\n            while(v!=-1){\n                belong[v].emplace_back(segs.size()-1);\n                v=parent[v];\n            }\n        }\n\n        ll ans=0;\n        vector<bool> done(n);\n        rep(i,0,q){\n            char ch;\n            int v;\n            cin >> ch >> v;\n            --v;\n            if(ch=='M'){\n                if(done[v]) continue;\n                done[v]=true;\n                for(const int tmp:belong[v]) segs[tmp].update(depth[v],make_pair(depth[v],v));\n            }else ans+=segs[belong[v][0]].query(0,depth[v]+1).second+1;\n        }\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <utility>\n#include <stdio.h>\n\n\n#define dprintf(s,...) printf(\"%s:%d\" s,__func__,__LINE__,__VA_ARGS__)\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\n//Marked Ancestor\n//AOJ 2170\n\nint N,Q;\n\nint par[100001],marked[100001];\n\nvoid init(){\n  \n  fill(par, par+N+1, -1);\n  fill(marked, marked+N+1, 0);\n\n  marked[1]=1;\n\n}\n\nint ans(int v){\n\n  int u = par[v];\n  \n  while(marked[u]==0)\n    u = par[u];\n  \n  return u;\n\n}\n\n\nint main(){\n\n  ios_base::sync_with_stdio(false);\n  \n  while(1){\n\n    int res=0;\n    \n    scanf(\"%d %d\",&N,&Q);\n    if(N==0 && Q==0) break;\n\n    init();\n    \n    \n    for(int i=1;i<=N-1;i++)\n      scanf(\"%d\",&par[i]);\n\n    for(int i=0;i<Q;i++){\n      char op;\n      int v;\n      scanf(\"%s %d\",&op,&v);\n\n      if(op=='Q') res += ans(v);\n      if(op=='M') marked[v]=1;\n    }\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Node {\n    int parent;\n    vector<int> children;\n};\n\nstruct HLNode {\n    int parent;\n    int position;   // position in the parent's path.\n    vector<int> children;\n    vector<int> path;\n};\n\n// ??¨??? Heavy-Light Decomposition ????????????\n// Arguments:\n//   tree: ??¨???\n//   root: ?????¨???????????????????????????\n// Returns:\n//   vector<HLNode>: ????´?????????¨???\n//   int: ????´?????????¨????????¨???????????????????????????\n// Verified: AOJ 2170 (Marked Ancestor)\npair<vector<HLNode>, int> heavy_light_decomposition(const vector<Node>& tree, int root) {\n    vector<HLNode> decomposed;\n    stack<int> S, loop, max_weight, max_index, total_weight, indices;\n    int index, weight;\n\n    {\n        S.push(root);\nstart:\n        int u = S.top();\n        if (tree[u].children.empty()) {\n            decomposed.push_back((HLNode){-1, -1, vector<int>(), vector<int>(1, u)});\n            weight = 1;\n            index = decomposed.size()-1;\n            S.pop();\n            if (!S.empty()) goto ret;\n        } else {\n            max_weight.push(-1); max_index.push(-1); total_weight.push(0); loop.push(0);\n            while (loop.top() < (int)tree[u].children.size()) {\n                S.push(tree[u].children[loop.top()]);\n                goto start;\nret:\n                u = S.top();\n                indices.push(index);\n                total_weight.top() += weight;\n                if (weight > max_index.top()) {\n                    max_weight.top() = weight;\n                    max_index.top() = index;\n                }\n                ++loop.top();\n            }\n            int m = max_index.top();\n            REP(i, tree[u].children.size()) {\n                int idx = indices.top(); indices.pop();\n                if (idx == m) continue;\n                decomposed[idx].parent = m;\n                decomposed[idx].position = decomposed[m].path.size();\n                decomposed[m].children.push_back(idx);\n            }\n            decomposed[m].path.push_back(u);\n            weight = total_weight.top()+1;\n            index = m;\n            max_weight.pop(); max_index.pop(); total_weight.pop(); loop.pop(); S.pop();\n            if (!S.empty()) goto ret;\n        }\n    }\n\n    for (auto& node : decomposed) {\n        reverse(node.path.begin(), node.path.end());\n        if (node.parent != -1)\n            node.position = decomposed[node.parent].path.size() - node.position - 1;\n    }\n    return make_pair(move(decomposed), index);\n}\n\ntemplate <typename Int>\nstruct FenwickTree {\n  vector<Int> data;\n  explicit FenwickTree(int n): data(n, -1) {}\n  void set(int i, Int x) { for (; i < (int)data.size(); i |= i+1) data[i] = max(data[i], x); }\n  Int maximum(int i) const { Int s = -1; for (; i >= 0; i = (i & (i+1)) - 1) s = max(s, data[i]); return s; }\n};\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, Q;\n    while (cin>>N>>Q, N|Q) {\n        vector<Node> tree(N);\n        tree[0].parent = -1;\n        FOR(i, 1, N) {\n            int p; cin >> p; --p;\n            tree[i].parent = p;\n            tree[p].children.push_back(i);\n        }\n\n        auto t = heavy_light_decomposition(tree, 0);\n        auto& decomposed = t.first;\n        int root = t.second;\n\n        vector<int> node_mapping(N);\n        vector<int> position_mapping(N);\n        REP(i, decomposed.size()) {\n            auto& node = decomposed[i];\n            REP(j, node.path.size()) {\n                int v = node.path[j];\n                node_mapping[v] = i;\n                position_mapping[v] = j;\n            }\n        }\n\n        vector<FenwickTree<int>> fenwick_trees;\n        for (auto& node : decomposed)\n            fenwick_trees.emplace_back(node.path.size());\n        fenwick_trees[root].set(0, 0);\n\n        long long sum = 0;\n        REP(query_index, Q) {\n            char q; int v; cin >> q >> v; --v;\n            int u = node_mapping[v], p = position_mapping[v];\n            if (q == 'M') {\n                fenwick_trees[u].set(p, p);\n            } else if (q == 'Q') {\n                int ans = 0;\n                while (u != -1) {\n                    int k = fenwick_trees[u].maximum(p);\n                    if (k != -1) {\n                        ans = decomposed[u].path[k];\n                        break;\n                    }\n                    p = decomposed[u].position;\n                    u = decomposed[u].parent;\n                }\n                sum += ans + 1;\n            } else {\n                assert(false);\n            }\n        }\n        cout << sum << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (size_of(x) < size_of(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint size_of(int x) { return -parent[root(x)]; }\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N, Q; cin >> N >> Q&&N;) {\n\t\tvector<int> p(N); p[0] = -1; rep(i, 1, N) { cin >> p[i]; p[i]--; }\n\t\tvector<bool> m(N); m[0] = true;\n\t\tvector<char> q1(Q);\n\t\tvector<int> q2(Q);\n\t\trep(i, 0, Q) {\n\t\t\tcin >> q1[i] >> q2[i];\n\t\t\tq2[i]--;\n\t\t\tif (q1[i] == 'M')m[q2[i]] = true;\n\t\t}\n\t\tUnionFind UF(N);\n\t\tint ans = 0;\n\t\trrep(i, 0, Q) {\n\t\t\tif (q1[i] == 'Q') {\n\t\t\t\tint root = UF.root(q2[i]);\n\t\t\t\twhile (!m[root]) {\n\t\t\t\t\tUF.unite(root, p[root]);\n\t\t\t\t\troot = p[root];\n\t\t\t\t\tif (m[root]) {\n\t\t\t\t\t\tans += (root + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm[q2[i]] = false;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i  = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nstruct UF {\n  int n;\n  vector<int> d;\n  UF(int v) : n(v+1), d(v+1, -1){\n    REP(i, 1, n) d[i] = -i;\n  }\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return false;\n    d[y] = x;\n    return true;\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, q;\n  while(cin >> n >> q) {\n    if(n == 0 && q  == 0) break;\n    vector<int> par(n+1);\n    REP(i, 2, n+1) cin >> par[i];\n    using P = pair<int, int>;\n    vector<P> query(q);\n    vector<int> marked(n+1);\n    marked[1] = 1;\n    rep(i, q) {\n      char c;\n      int t;\n      cin >> c >> t;\n      query[i].first = (c == 'M');\n      query[i].second = t;\n      if(query[i].first) marked[t]++;\n    }\n    UF uf(n);\n    REP(i, 1, n+1) {\n      if(!marked[i]) {\n\tuf.unite(par[i], i);\n      }\n    }\n    // REP(i, 1, n+1) {\n    //   cout << i << \" \" << uf.root(i) << endl;\n    // }\n    long long int ans = 0LL;\n    for(int i = q-1; i >= 0; --i) {\n      int v = query[i].second;\n      if(query[i].first) {\n\tmarked[v]--;\n\tif(marked[v] == 0) uf.unite(par[v], v);\n      }\n      else {\n\tans += uf.root(v);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct Node {\n    int parent;\n    vi child;\n};\n\nvi ancestor;\nvector<Node> nodes;\n\nvoid mark(int v, int pos){\n    if(ancestor[pos] == pos) return;\n\n    ancestor[pos] = v;\n    \n    rep(i, nodes[pos].child.size()){\n        mark(v, nodes[pos].child[i]);\n    }\n}\n\nint main(void){\n    ll res;\n    for(int n, q; cin >> n >> q, n; cout << res << endl){\n        res = 0;\n        nodes = vector<Node>(n + 1);\n        ancestor = vi(n + 1, 1);\n\n        range(u, 2, n + 1){\n            int p; cin >> p;\n\n            nodes[u].parent = p;\n            nodes[p].child.pb(u);\n        }\n\n        rep(i, q){\n            char op; int v; cin >> op >> v;\n\n            if(op == 'M'){\n                mark(v, v);\n            }\n            else {\n                res += ancestor[v];\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\ntypedef pair<char,int> cp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint n,m;\n\nvector<int> vs[100005];\nint uni[100010];\nint ma[100005];\nint marked[100005];\n\nvoid dfs(int no,int p){\n\tma[no] = p;\n\tif(marked[no]==1)p = no;\n\telse uni[no] = p;\n\t\n\trep(i,vs[no].size()){\n\t\tdfs(vs[no][i],p);\n\t}\n}\n\nint find(int p){\n\tif(uni[p] == p)return p;\n\tuni[p] = find(uni[p]);\n\treturn uni[p];\n}\n\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\treg(i,1,n){\n\t\t\tvs[i].clear();\n\t\t\tuni[i] = i;\n\t\t}\n\t\tmemset(marked,0,sizeof(marked));\n\t\t\n\t\treg(i,2,n){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tvs[a].push_back(i);\n\t\t}\n\t\t\n\t\tvector<cp> qs;\n\t\trep(i,m){\n\t\t\tint a;\n\t\t\tchar s[5];\n\t\t\tscanf(\"%s%d\",s,&a);\n\t\t\tif(s[0]=='M')marked[a] = 1;\n\t\t\tqs.push_back(cp(s[0],a));\n\t\t}\n\t\t\n\t\tmarked[1] = 1;\n\t\tdfs(1,1);\n\t\t\n\t\tlli ans = 0;\n\t\tirep(i,qs.size()){\n\t\t\tint a = qs[i].sec;\n\t\t\tif(qs[i].fir == 'Q'){\n\t\t\t\tlli na = find(a);\n\t\t\t\tans += na;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(marked[a]==0)continue;\n\t\t\t\tmarked[a] = 0;\n\t\t\t\tuni[a] = find(ma[a]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\nprivate:\n    vector<int> p,s;\n\tint cnt;\npublic:\n\tUnionFind(){}\n\tUnionFind(int N){\n\t\tcnt = N;\n\t\tp = s = vector<int>(N+1,0);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tp[i] = i; s[i] = 1;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(p[x]==x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(s[x]>s[y]){\n\t\t\tp[y] = x;\n\t\t\ts[x] += s[y];\n\t\t}else{\n\t\t\tp[x] = y;\n\t\t\ts[y] += s[x];\n\t\t}\n\t\tcnt--;\n\t}\n\tbool is_same_set(int x,int y) {return find(x)==find(y);}\n\tint size(int x) {return s[find(x)];}\n\tint compnents_number(){return cnt;}\n};\n\nint N,Q;\n\nvoid dfs(int n,int p,vector<vector<int>>& c,vector<int>& marked,vector<ll>& val,UnionFind& uf){\n    uf.unite(n,p);\n    val[uf.find(n)] = p;\n    for(auto x:c[n]){\n        if(marked[x]) dfs(x,x,c,marked,val,uf);\n        else dfs(x,p,c,marked,val,uf);\n    }\n}\n\nint main(){\n    while(cin >> N >> Q && N){\n        vector<int> p(N+1),num(Q+1),marked(N+1,0);\n        vector<ll> val(N+1);\n        vector<char> C(Q+1);\n        vector<vector<int>> c(N+1);\n        map<int,int> m;\n        UnionFind uf(N);\n        for(int i=2;i<=N;i++){\n            cin >> p[i];\n            c[p[i]].push_back(i);\n        }\n        marked[1] = 1;\n        m[1]++;\n        for(int i=1;i<=Q;i++){\n            cin >> C[i] >> num[i];\n            if(C[i]=='M'){\n                marked[num[i]] = 1;\n                m[num[i]]++;\n            }\n        }\n        dfs(1,1,c,marked,val,uf);\n        ll ans = 0;\n        for(int i=Q;i>=1;i--){\n            if(C[i]=='Q') ans += val[uf.find(num[i])];\n            else{\n                m[num[i]]--;\n                if(m[num[i]]==0){\n                    ll a = val[uf.find(p[num[i]])];\n                    uf.unite(a,num[i]);\n                    val[uf.find(num[i])] = a;\n                    m.erase(num[i]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 100001\nusing namespace std;\ntypedef long long ll;\nint func(int);\nint n,q,e,k,edge[N];\nbool marked[N];\n\nint main(){\n  char c;\n  ll cnt;\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n-1;i++) cin>>e,edge[i+2]=e;\n    for(int i=0;i<n-1;i++) marked[i+2]=false;\n    marked[1]=true;\n    cnt=0;\n    while(q--){\n      cin>>c>>k;\n      if(c=='M') marked[k]=true;\n      else cnt+=func(k);\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}\n\nint func(int x){\n  if(marked[x]) return x;\n  return func(edge[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[200000],euler;\nint dbl[200000][36],ff[200000],ss[200000],bit[400001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nvector<int> depth;\nstruct UnionFind {\n    int sz;\n    std::vector<int> par;\n    UnionFind(int n) : par(n, -1) {}\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    void unite(int a, int b) {\n        int roota = root(a);\n        int rootb = root(b);\n        if(roota == rootb) return;\n        par[roota] += par[rootb];\n        par[rootb] = roota;\n    }\n    bool same(int a, int b) {\n        return (root(a) == root(b));\n    }\n    int size(int a) {\n        return -par[root(a)];\n    }\n};\nint cnt = 0;\nbool solve() {\n  cnt++;\n  int n, t; cin >> n >> t;\n  if(n == 0) return false;\n  vector<int> prev(n, -1);\n  for(int i=1;i<n;++i) {\n    cin >> prev[i];\n    prev[i]--;\n  }\n  vector<char> q;\n  vector<int> v;\n  vector<bool> mark(n, false);\n  mark[0] = true;\n  UnionFind uf(n);\n  for(int i=0;i<t;++i) {\n    char c; int tmp; cin >> c >> tmp;\n    tmp--;\n    if(c == 'Q') {\n      q.push_back('Q');\n      v.push_back(tmp);\n    } else if(!mark[tmp]) {\n      q.push_back('M');\n      v.push_back(tmp);\n      mark[tmp] = true;\n    }\n  }\n  for(int i=0;i<n;++i) {\n    if(!mark[i]) {\n      uf.unite(prev[i], i);\n    }\n  }\n  ll ans = 0;\n  for(int i=(int)(v.size())-1;i>=0;--i) {\n    if(q[i] == 'M') {\n      uf.unite(prev[v[i]], v[i]);\n    } else if(q[i] == 'Q') {\n      ans += uf.root(v[i]) + 1;\n    }\n  }\n  cout << ans << endl;\n  return true;\n}\nsigned main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(solve()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nstruct UnionFind{\n    vector <int> par;\n    UnionFind(int N) : par(N, -1){}\n    void unite(int x, int y){\n        x = root(x); y = root(y);\n        if(x != y){\n            par[x] += par[y];\n            par[y] = x;\n        }\n    }\n    int root(int x){ return par[x] < 0 ? x : par[x] = root(par[x]);}\n    bool same(int x, int y){ return root(x) == root(y);}\n};\n\ntypedef pair<bool, int> pbt;;\nbool marked[100000];\nint p[100000];\nint main(){\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, Q, _t;\n    char _c;\n    while(ifs >> N >> Q && N){\n        memset(marked, 0, sizeof(marked));\n        marked[0] = true;\n        UnionFind uf(N);\n        vector<pbt> query;\n        \n        REP(i, 1, N){\n            ifs >> p[i]; --p[i];\n        }\n        rep(i, Q){\n            ifs >> _c >>_t; --_t;\n            if(_c == 'Q')\n              query.push_back(pbt(1, _t));\n            else if(!marked[_t]){\n                query.push_back(pbt(0, _t));\n                marked[_t] = true;\n            }\n        }\n        rep(i, N)\n          if(!marked[i])\n            uf.unite(p[i], i);\n        ll sum = 0LL;\n        for(int i = query.size() - 1; i >= 0; --i){\n            int v = query[i].second;\n            if(query[i].first)\n              sum += uf.root(v) + 1;\n            else\n              uf.unite(p[v], v);\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n,q;\nint tree[100050];\n\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&q)==2)\n    {\n        if(n==0&&q==0)\n            break;\n        tree[1]=1;\n        for(int i=2;i<=n;i++)\n            scanf(\"%d\",&tree[i]);\n        getchar();\n        long long ans=0;\n        for(int i=1;i<=q;i++)\n        {\n            int temp;\n            char s[100];\n            gets(s);\n            sscanf(&s[2],\"%d\",&temp);\n            if(s[0]=='M')\n                tree[temp]=temp;\n            else if(s[0]=='Q')\n                ans+=Find(temp);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits//stdc++.h>\nusing namespace std;\nstruct UnionFind{\n    vector <int> par;\n    UnionFind(int N) : par(N, -1){}\n    void unite(int x, int y){\n        x = root(x); y = root(y);\n        if(x != y){\n            par[x] += par[y];\n            par[y] = x;\n        }\n    }\n    int root(int x){ return par[x] < 0 ? x : par[x] = root(par[x]);}\n    bool same(int x, int y){ return root(x) == root(y);}\n};\ntypedef pair<bool, int> pbt;\ntypedef  long long int ll;\nbool marked[100000];\nint p[100000];\n#define rep(i,n) for(int i = 0;i <n;i++)\n#define REP(i,a,b) for(int i = a; i <b;i++)\nint main(){\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, Q, _t;char _c;\n    while(cin >> N >> Q && N){\n        memset(marked, 0, sizeof(marked));\n        marked[0] = true;\n        UnionFind uf(N);vector<pbt> query;\n        REP(i, 1, N){ cin >> p[i]; --p[i];}\n        rep(i, Q){\n            cin >> _c >>_t; --_t;\n            if(_c == 'Q')\n              query.push_back(pbt(1, _t));\n            else if(!marked[_t]){\n                query.push_back(pbt(0, _t));\n                marked[_t] = true;\n            }\n        }\n        rep(i, N)\n          if(!marked[i])\n            uf.unite(p[i], i);\n        ll sum = 0LL;\n        for(int i = query.size() - 1; i >= 0; --i){\n            int v = query[i].second;\n            if(query[i].first)\n              sum += uf.root(v) + 1;\n            else\n              uf.unite(p[v], v);\n        }\n        cout << sum << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\nvoid setLevel(int i, int n)\n{\n\tnearest[i]=P(0,0);\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\t//cout << \"nearest \" << p << \", \" << n.second << endl;\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\tchild[0][p].push_back(i);\n\t}\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tfor(int k=0;k<child[pre][j].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << level[i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << j << \", \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tint sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nint N, Q;\nint p[MAX_N+5];\nbool M[MAX_N+5];\nint uf_par[MAX_N+5];\nint uf_rank[MAX_N+5];\nint mark[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < N; i++) {\n        uf_par[i] = i;\n        uf_rank[i] = 0;\n        mark[i] = i;\n    }\n}\n\nint find(int x) {\n    if (uf_pair[x] == x) {\n        return x;\n    } else {\n        return uf_par[x] = find(uf_par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(uf_rank[x] < uf_rank[y]) {\n        uf_par[x] = y;\n        mark[y] = mark[x];\n    } else {\n        uf_par[y] = x;\n        if(uf_rank[x] == uf_rank[y]) uf_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return uf_find(x) == uf_find(y);\n}\n\nint main() {\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        for(int i = 1; i < N; i++) {\n            cin >> p[i-1];\n            p[i-1]--;\n        }\n        vector<P> query;\n        char qm;\n        int num;\n        for(int i = 0; i < Q; i++) {\n            cin >> qm >> num;\n            if(num == 'M') {\n                M[num-1] = true;\n            }\n            query.push_back(P(qm, num));\n        }\n\n        for(int i = 0; i < N; i++) {\n            if(!M[i]) {\n                unite(p[i], i);\n            }\n        }\n\n        int count = 0;\n        for(int i = query.size()-1; i >= 0; i++) {\n            int n = query[i].second;\n            if(query[i].first == 'M') {\n                unite(p[n], n);\n            } else {\n                count += mark[find(n)];\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\ntypedef pair<char,int> P;\nP query[maxn];\nint get(int i)\n{\n\tint par = tree[i];\n\twhile(!ar[par])\n\t\tpar = tree[par];\n\treturn par;\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q),n|q){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tlong long sum = 0;\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = true;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n, q;\nvi par;\nvector<char> t;\nvi v;\nvi cnt;\n\nint lma(int x) {\n    if (cnt[x]) return x;\n    return par[x] = lma(par[x]);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> n >> q, n) {\n        par.assign(n, -1);\n        rep(i, n - 1) {\n            int p;\n            cin >> p;\n            p--;\n            par[i] = p;\n        }\n\n        t.clear(); t.resize(n);\n        v.clear(); v.resize(n);\n        cnt.assign(n, 0);\n        cnt[0] = 1;\n        rep(i, q) {\n            cin >> t[i] >> v[i];\n            v[i]--;\n            if (t[i] == 'M') {\n                cnt[v[i]]++;\n            }\n        }\n\n        int ans = 0;\n        rrep(i, q) {\n            if (t[i] == 'M') {\n                cnt[v[i]]--;\n            }\n            else {\n                ans += lma(v[i]) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,bool> P;\nint N,Q;\nint p[1000000];\nbool hoge[10000000];\nint q;\nchar s;\n\nint parent(int x){\n  if(hoge[p[x]]==1) return p[x];\n  else return parent(p[x]);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\",&N,&Q);\n    if(N==0) break;\n    memset(p,0,sizeof(p));\n    memset(hoge,0,sizeof(hoge));\n    p[1]=-1;\n    hoge[1]=1;\n    lli res=0;\n    for(int i=2;i<=N;i++) scanf(\"%d\\n\",&p[i]);\n    for(int i=0;i<Q;i++) {\n      scanf(\"%c %d\\n\",&s,&q);\n//      printf(\"%d\\n\",hoge[q]);\n      if(s=='M'){\n        hoge[q]=1;\n      }\n      if(s=='Q'){\n        res+=parent(q);\n      }\n    }\n\n    printf(\"%lld\\n\",res);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n//#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <array>\n//#include <set>\n\nusing namespace std;\n\nusing ll_t = long long;\n// #define ll_t long long\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170&lang=jp\n\nclass UnionFind {\nprotected:\n    vector<size_t> parent;\n    vector<size_t> rank;\npublic:\n    explicit UnionFind(size_t size) {\n        parent.resize(size);\n        rank.resize(size);\n        for (size_t i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    virtual ~UnionFind() {}\n    void unite(size_t x, size_t y) {\n        size_t px = findParent(x);\n        size_t py = findParent(y);\n        if (px == py) {\n            return;\n        }\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else { // rank[px] == rank[py]\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n    bool isSame(size_t x, size_t y) {\n        return findParent(x) == findParent(y);\n    }\n    size_t findParent(size_t x) {\n        if (parent[x] == x) {\n            return x;\n        } else {\n            parent[x] = findParent(parent[x]);\n            return parent[x];\n        }\n    }\n};\n\nclass MarkedTree {\npublic:\n    vector<size_t> parent;\n    vector<bool> marks;\n    explicit MarkedTree(size_t size) {\n        parent = vector<size_t>(size, 0);\n        marks = vector<bool>(size, false);\n        parent[0] = -1; // root\n        marks[0] = true;\n    }\n    size_t findMarkedParent(size_t node) {\n        if (marks[node]) {\n            return node;\n        } else {\n            size_t ret = findMarkedParent(parent[node]);\n            parent[node] = ret;\n            return ret;\n        }\n    }\n    void unMark(size_t node) {\n        marks[node] = false;\n    }\n    void mark(size_t node) {\n        marks[node] = true;\n    }\n    void setParent(size_t node, size_t parentNode) {\n        parent[node] = parentNode;\n    }\n};\n\nint main() {\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) {\n            return 0;\n        }\n        MarkedTree tree(N);\n        for (int node = 1; node <= N-1; node++) {\n            int parent;\n            cin >> parent;\n            tree.setParent(node, parent - 1);\n        }\n        vector<pair<char, int>> inputs;\n        inputs.reserve(Q);\n        for (int i = 0; i < Q; i++) {\n            char q;\n            int p;\n            cin >> q >> p;\n            inputs.emplace_back(q,p);\n            if (q == 'M') {\n                tree.mark(p-1);\n            }\n        }\n        int querySum = 0;\n        for (int i = (int)inputs.size() - 1; i >= 0; i--) {\n            char q = inputs[i].first;\n            int node = inputs[i].second;\n            if (q == 'Q') {\n                querySum += tree.findMarkedParent(node - 1) + 1;\n            } else { // Mark\n                tree.unMark(node - 1);\n            }\n        }\n        cout << querySum << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define TEST 0\nint par[100001];\nbool marked[100001];\nint find_marked(int id)\n{\n    if(marked[id])return id;\n    return find_marked(par[id]);\n}\nint main(void)\n{\n    int n,q;\n    while(scanf(\"%d%d\",&n,&q)==2 && (n!=0 || q != 0))\n    {\n        par[1]=0;\n        marked[1]=true;\n        int sum=0;\n        for(int i=0;i<n;i++)\n        {\n            scanf(\"%d\",par + i+2);\n            marked[i+2]=false;\n        }\n        for(int j=0;j<q;j++)\n        {\n            char str[8];\n            int num;\n            scanf(\"\\n%[QM]%d\",str,&num);\n#if TEST\n            printf(\"%c:%d\\n\",str[0],num);\n#endif\n            switch(str[0])\n            {\n            case 'Q':\n                    sum+=find_marked(num);\n                    break;\n            case 'M':\n                    marked[num]=true;\n                    break;\n            }\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M'&&t[i]!=1) marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing graph = vector<vector<int>>;\n\nconst int MAX = 1e5;\n\nint it;\nint dep[MAX];\nint lv[MAX], rv[MAX];\n\nvoid euler_tour(int v, const graph& G) {\n\tlv[v] = it++;\n\tfor (auto to : G[v]) {\n\t\tdep[to] = dep[v] + 1;\n\t\teuler_tour(to, G);\n\t}\n\trv[v] = it - 1;\n}\n\nstruct RU {\n\tusing t1 = pii;\n\tusing t2 = pii;\n\tstatic t2 id2() { return pii(INT_MIN, -1); }\n\tstatic t1 op2(const t1& l, const t2& r) { return max(l, r); }\n\tstatic t2 op3(const t2& l, const t2& r) { return max(l, r); }\n};\n\ntemplate <typename M>\nclass lazy_segment_tree {\n\tusing T1 = typename M::t1;\n\tusing T2 = typename M::t2;\n\tconst int h, n;\n\tvector<T2> lazy;\npublic:\n\tlazy_segment_tree(int n_)\n\t\t: h(ceil(log2(n_))), n(1 << h), lazy(n << 1, M::id2()) {}\n\tvoid update(int l, int r, T2 val) {\n\t\tl += n, r += n + 1;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) lazy[l] = M::op3(lazy[l], val), l++;\n\t\t\tif (r & 1) r--, lazy[r] = M::op3(lazy[r], val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t}\n\tT1 find(int p) {\n\t\tT1 res = M::id2();\n\t\tp += n;\n\t\twhile (p) res = M::op2(res, lazy[p]), p >>= 1;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N, Q;\n\twhile (cin >> N >> Q, N | Q) {\n\t\tgraph G(N);\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tint p;\n\t\t\tcin >> p; --p;\n\t\t\tG[p].push_back(i);\n\t\t}\n\t\tit = 0;\n\t\tdep[0] = 0;\n\t\teuler_tour(0, G);\n\t\tlazy_segment_tree<RU> lst(N);\n\t\tlst.update(0, N, pii(0, 1));\n\t\tll res = 0;\n\t\twhile (Q--) {\n\t\t\tchar com;\n\t\t\tint v;\n\t\t\tcin >> com >> v; --v;\n\t\t\tif (com == 'M') {\n\t\t\t\tlst.update(lv[v], rv[v], pii(dep[v], v + 1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += lst.find(lv[v]).second;\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace  std;\nconst int maxn = 1e5 + 5;\nint f[maxn];\nint ma[maxn];\nbool ismark[maxn];\n\nvector<int> mp[maxn];\ntypedef long long ll;\nvoid init(int n)\n{\n    for (int i = 1; i <= n; i ++) {\n        ma[i] = 1;//\n        mp[i].clear();\n    }\n    memset(ismark,0,sizeof(int) * (n + 1));\n    ismark[1] = 1;\n}\n\nint find(int x)\n{\n    if(x == 1) return 1;\n    if(ismark[x]) return ma[x];\n    else if(ismark[f[x]]) return ma[x];\n    else return ma[x] = find(f[x]);\n}\nvoid update(int x)\n{\n    ismark[x] = 1;\n    for (int i = 0; i < mp[x].size(); i ++) {\n        if(f[x] != mp[x][i]){\n            ma[mp[x][i]] = x;\n        }\n    }\n}\nint main()\n{\n    int n,q;\n    while (scanf(\"%d%d\",&n,&q) != EOF) {\n        if(n == 0 && q == 0) break;\n        init(n);\n        int a;\n        for (int i = 2; i <= n; i ++) {\n            scanf(\"%d\",&a);\n            mp[a].push_back(i);\n            mp[i].push_back(a);\n            f[i] = a;\n        }\n        getchar();\n        char op;\n        int v;\n        ll sum = 0;\n        for (int i = 0; i < q; i ++) {\n            scanf(\"%c%d\",&op,&v);\n            if(op == 'M'){\n                update(v);\n                           }\n            else{\n//                int t = find(v);\n//                sum += 1ll * t;\n//                printf(\"%d %d\\n\",v,t);\n                sum += 1ll * find(v);\n            }\n            getchar();\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <algorithm>\n#define int long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n\nusing namespace std;\n\nconstexpr int kMaxN = 100000;\nconstexpr int kMaxQ = 100000;\n\nstruct Op {\n  char com;\n  int idx;\n};\n\nint N,Q;\nint par[kMaxN];\nvector<bool> marked;\nvector<Op> ops;\n\nvoid Init(void) {\n\n  marked.resize(N);\n  fill(marked.begin(), marked.end(), false);\n  marked[0] = true;\n\n}\n\nint dfs(int i) {\n  if (marked[i]) return i;\n  return dfs(par[i]);\n}\n\nvoid solve(void) {\n  Init();\n\n  int ans = 0;\n  for (auto op : ops) {\n    if (op.com == 'Q') {\n      ans += dfs(op.idx) + 1;\n    } else {\n      marked[op.idx] = true;\n    }\n  }\n  cout << ans << endl;\n}\n\nsigned main(void) {\n  while(true) {\n    cin >> N >> Q;\n    if ( N == 0 && Q == 0) break;\n    par[0] = 0;\n    rep (i, N-1) {\n      cin >> par[i+1];\n      par[i+1]--;\n    }\n    ops.resize(Q);\n    rep (i,Q) {\n      cin >> ops[i].com >> ops[i].idx;\n      ops[i].idx--;\n    }\n    solve();\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nvi d;\nvector<vi> g;\n\nvoid dfs(int now, int a){\n    d[now] = a;\n    rep(i,g[now].size())dfs(g[now][i],a);\n}\n\nsigned main(void) {\n    int n,q;\n    while(1){\n        scanf(\"%lld %lld\",&n,&q);\n        if(n == 0)return 0;\n        g = vector<vi>(n);\n        loop(i,1,n){\n            int a;\n            scanf(\"%lld\",&a);\n            a--;\n            g[a].push_back(i);\n        }\n        d = vi(n,1);\n        int ans = 0;\n        while(q--){\n            char s[5];\n            scanf(\"%s\",s);\n            int v;\n            scanf(\"%lld\",&v);\n            v--;\n            if(s[0] == 'M'){\n                dfs(v,v+1);\n            }else{\n                ans += d[v];\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define int long long\ntypedef pair<char,int>P;\nint uni[100009],r[100009];\nint find(int a){\n    if(a!=uni[a])a=find(uni[a]);\n    return a;\n}\nbool same(int a,int b){\n    return find(a)==find(b);\n}\nvoid unit(int a,int b){\n    int c=find(a),d=find(b);\n    if(r[c]>r[d])uni[d]=c;\n    else{\n      uni[d]=c;\n      r[d]++;\n    }\n\n}\n \nint M[100007];\nvector<int>v[100007];\n \nvoid dfs(int x,int col){\n  if(M[x]!=-1)col=x;\n  uni[x]=col;\n  r(i,v[x].size()){\n    dfs(v[x][i],col);\n  }\n}\nint n,m,x,sum;\nvector<P>query;\nint xx[100009];\n\n\nmain(){\n  while(cin>>n>>m,n){\n    sum=0;\n    memset(uni,0,sizeof(uni));\n    memset(r,0,sizeof(r));\n    memset(M,-1,sizeof(M));\n    query.clear();\n    r(i,100007)v[i].clear();\n    r(i,n-1){\n      cin>>xx[i+2];\n      v[xx[i+2]].push_back(i+2);\n    }\n    xx[1]=1;\n    set<P>s;\n    r(i,m){\n      char c;\n      cin>>c>>x;\n      if(c=='M'&&s.count(P(c,x)))continue;\n      if(c=='M')M[x]=x;\n      s.insert(P(c,x));\n      query.push_back(P(c,x));\n    }\n    dfs(1,1);\n    reverse(query.begin(),query.end());\n    r(i,query.size()){\n      if(query[i].first=='Q') sum += find(query[i].second);\n      else{\n        unit(xx[query[i].second],query[i].second);\n      }\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\nconst int MAX_N=100000;\nint par[MAX_N];\nint myrank[MAX_N];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tmyrank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)return;\n\n\tif(myrank[x]<myrank[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(myrank[x]==myrank[y])myrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(){\n\tint n,q;\n\twhile(cin>>n>>q,n|q){\n\t\tvi a(n);\n\t\tvi parents(n,-1);\n\t\tREP(i,n-1){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tparents[i+1]=p-1;\n\t\t}\n\n\t\tinit(n);\n\t\tvi marked(n);\n\n\t\tvector<pair<char,int> > queries;\n\t\tREP(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin>>c>>v;\n\t\t\tqueries.push_back(make_pair(c,v-1));\n\t\t\tif(c=='M'){\n\t\t\t\tmarked[v-1]=1;\n\t\t\t}\n\t\t}\n\n\t\tREP(i,n){\n\t\t\tif(!marked[i]&&parents[i]!=-1){\n\t\t\t\tunite(parents[i],i);\n\t\t\t}\n\t\t}\n\n\t\tll ans=0;\n\t\tREP(i,q){\n\t\t\tchar c=queries[q-i-1].first;\n\t\t\tint v=queries[q-i-1].second;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=find(i)+1;\t\n\t\t\t}else{\n\t\t\t\tunite(parents[i],i);\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int DEPTH = 18;\nclass RUQ\n{\n\tint value[1 << (DEPTH + 1)];\n\tint t[1 << (DEPTH + 1)];\npublic:\n\tRUQ() {\n\t\tfor (int i = 0; i < (1 << (DEPTH + 1)); i++) {\n\t\t\tvalue[i] = 0;\n\t\t\tt[i] = -1;\n\t\t}\n\t}\n\t\n\tvoid update(int l, int r, int v, int t, int a = 0, int b = (1 << DEPTH), int id = 0) {\n\t\tif (l >= b || r <= a) return;\n\t\tif (l <= a && b <= r) {\n\t\t\tvalue[id] = v;\n\t\t\tthis->t[id] = t;\n\t\t\treturn;\n\t\t}\n\t\tupdate(l, r, v, t, a, a + (b - a) / 2, id * 2 + 1);\n\t\tupdate(l, r, v, t, a + (b - a) / 2, b, id * 2 + 2);\n\t}\n\t\n\tint getValue(int id) {\n\t\tid = (1 << DEPTH) - 1 + id;\n\t\tint newestId = id;\n\t\twhile (id > 0) {\n\t\t\tid = (id - 1) / 2;\n\t\t\tif (t[id] > t[newestId]) newestId = id;\n\t\t}\n\t\treturn value[newestId];\n\t}\n};\n\nint n, q;\nvector<int> et[100000];\t\t//et[i][j] = ??????i??¨??????et[i][j]??????????????£?????????\nint ord[100000];\t\t\t//ord[i] = ??????i??????????????????(0-indexed)\nint Size[100000];\t\t\t//Size[i] = ??????i????????¨????????¨?????¨????????????\nint ordInv[100000];\t\t\t//ordInv[i] = ??????????????????i??????????????????\nRUQ seg;\n\nint dfs(int p, int v, int id) {\n\tint ret = 0;\n\t\n\tord[v] = id;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tint subSize = dfs(v, et[v][i], id + ret + 1);\n\t\tret += subSize;\n\t}\n\tret++;\n\treturn Size[v] = ret;\n}\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) et[i].clear();\n\tseg.update(0, n, 0, -1);\n}\n\nint main() {\n\tint i;\n\t\n\twhile (cin >> n >> q) {\n\t\tif (!n) break;\n\t\tinit(n);\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tint p; cin >> p; p--;\n\t\t\tet[p].push_back(i);\n\t\t}\n\t\tdfs(-1, 0, 0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tordInv[ord[i]] = i;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tchar com; int v;\n\t\t\tcin >> com >> v; v--;\n\t\t\tif (com == 'Q') {\n\t\t\t\tans += ordInv[seg.getValue(ord[v])] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tseg.update(ord[v], ord[v] + Size[v], ord[v], i);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(long i=0; i<(n); i++)\n#define dmp(x) cerr << #x << \" = \" << x << endl;\nusing namespace std;\n\nbool m[100000];\nlong a[100000];\nchar com[100000];\nlong d[100000];\n\nlong long calc(int n)\n{\n  if(m[n])\n    return n;\n  else\n    return calc(a[n]);\n}\n\nint main()\n{\n  int N,Q;\n  while(scanf(\"%d %d\", &N, &Q),N){\n    for(int i=2;i<N+1;i++){\n      scanf(\"%ld\",a+i);\n    }\n    m[1]=true;\n    rep(i,Q){\n    scanf(\" %c %ld\", com+i,d+i);\n    }\n    \n    long long ret=0;\n    \n    rep(i,Q) switch(com[i]) {\n    case 'M':\n      m[d[i]]=true;\n      break;\n    case 'Q':\n      ret += calc(d[i]);\n    }\n    printf(\"%lld\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// range max, point assign\npii dat[1<<18];\nint N;\nvoid init(int n){\n  N = 1;\n  while(N<n)N<<=1;\n  REP(i,2*N-1)dat[i] = pii(-1,-1);\n}\nvoid add(int l,int r,pii val,int a,int b,int k){\n  if(r<=a || b<=l)return;\n  if(l<=a && b<=r){\n    dat[k] = max(dat[k],val);\n    return;\n  }\n  add(l,r,val,a,(a+b)/2,2*k+1);\n  add(l,r,val,(a+b)/2,b,2*k+2);\n}\nvoid add(int l,int r,pii val){\n  if(r<=l)return;\n  add(l,r,val,0,N,0);\n}\npii get(int x,int a,int b,int k){\n  pii ret = dat[k];\n  if(a+1==b && a==x)return ret;\n  int mid = (a+b)/2;\n  if(x<mid){\n    return max(ret,get(x,a,mid,2*k+1));\n  }else{\n    return max(ret,get(x,mid,b,2*k+2));\n  }\n}\npii get(int x){\n  return get(x,0,N,0);\n}\n\nvi g[125252];\nbool used[125252];\nint lft[125252],rig[125252];\nint height[125252];\n\nvoid dfs(int p,int &iter,int h){\n  used[p] = true;\n  height[p] = h;\n  lft[p] = iter;\n  iter++;\n  REP(i,g[p].size()){\n    int to = g[p][i];\n    if(used[to])continue;\n    dfs(to,iter,h+1);\n  }\n  used[p] = false;\n  rig[p] = iter;\n  iter++;\n}\nint main(){\n  while(true){\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0 && q==0)break;\n    REP(i,n){\n      g[i].clear();\n      used[i] = false;\n      lft[i] = n+1;\n      rig[i] = -1;\n    }\n    REP(i,n-1){\n      int src = i+1;\n      int to;\n      scanf(\"%d\",&to);--to;\n      g[src].push_back(to);\n      g[to].push_back(src);\n    }\n    init(n);\n    int iter = 0;\n    dfs(0,iter,0);\n    add(lft[0],rig[0],pii(height[0],0));\n    ll ans = 0;\n    while(q--){\n      char s[5];\n      int x;\n      scanf(\"%s%d\",s,&x);\n      --x;\n      if(s[0]=='M'){\n        add(lft[x],rig[x],pii(height[x],x));\n      }else{\n        pii val = get(lft[x]);\n        ans += val.second+1;\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1<<29)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nstruct SegmetTree {\n    int n;\n    P dat[2*MAX-1];    \n    \n    SegmetTree(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = P(0, 1);\n        }\n    }\n\n    ll get_nearest_marked_node(int k)\n    {\n        k += n - 1;\n        P p = dat[k];\n        while (k > 0) {\n            k = (k - 1) / 2;\n            p = max(p, dat[k]);\n        }\n        return p.second;\n    }\n        \n    void mark(int a, int b, int k, int l, int r, P x)\n    {\n        if (r <= a || b <= l) return;\n\n        if (a <= l && r <= b) {\n            dat[k] = max(dat[k], x);\n        } else {\n            mark(a, b, k * 2 + 1, l, (l + r) / 2, x);\n            mark(a, b, k * 2 + 2, (l + r) / 2, r, x);\n        }\n    }    \n};\n\nint L[MAX], R[MAX], D[MAX], p;\nvector<int> G[MAX];\n\nvoid init(int N)\n{\n    p = 0;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();        \n    }\n}\n\nvoid dfs(int v, int depth)\n{\n    L[v] = p++;\n    D[v] = depth;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        dfs(G[v][i], depth + 1);\n    }\n    R[v] = p;\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0, 0);\n\n        SegmetTree st(N);\n        \n        char m;\n        ll v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.mark(L[v], R[v], 0, 0, st.n, P(D[v], v+1));\n            } else {\n                res += st.get_nearest_marked_node(v);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    // Your code here!\ncout<<\"私はこの問題の場所がわからず、ようやく見つけたのに日本語に直すと見つからなくなってしまうのでこのようなばかげたことをしました。てへ。\";\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n#define int ll\n\nint const M = 1000100;\n\nint N,Q;\nint par[M];\nvector<int> ch[M];\nchar q[M];\nint v[M];\nbool use[M];\nbool flg[M];\nint g[M];\nbool marked[M];\nint top[M]; // グループ→グループの根\n\n// markを外すときにunionしていく。\n// その際、グループ→グループの根の表を更新する\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nUnionFind uf(0);\n\nvoid rec(int v){\n    for(int c : ch[v]){\n        if(marked[c]){\n            g[c] = c;\n        } else {\n            g[c] = g[v];\n            uf.unionSet(c,v);\n        }\n        rec(c);\n    }\n}\n\nint solve(){\n    rep(i,N+1) flg[i] = false;\n    rep(i,Q)if(q[i]=='M'){\n        if(flg[v[i]]) use[i] = false;\n        else {\n            use[i] = true;\n            flg[v[i]] = true;\n        }\n    }\n    marked[1] = true;\n    per(i,Q)if(use[i]){\n        marked[v[i]] = true;\n    }\n\n    uf = UnionFind(N+1);\n    par[1] = 1;\n    g[1] = 1;\n    rec(1);\n\n    rep(i,N+1)if(i){\n        top[uf.root(i)] = g[i];\n    }\n\n    int ans = 0;\n    per(i,Q)if(use[i] || q[i]=='Q'){\n        if(q[i]=='M'){\n            top[uf.root(v[i])] = top[uf.root(par[v[i]])];\n            uf.unionSet(v[i], par[v[i]]);\n        } else {\n            ans += top[uf.root(v[i])];\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    while(cin>>N>>Q && N){\n        rep(i,N-1){\n            int v; cin>>v;\n            par[i+2] = v;\n            ch[v].push_back(i+2);\n        }\n        rep(i,Q){\n            cin >> q[i] >> v[i];\n        }\n        cout << solve() << endl;\n        rep(i,N+1) ch[i].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string.h>\n#include<sstream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double PI=acos(-1.0);\ntypedef long long ll;\nconst int maxn=100010;\nint tree[maxn];\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\nint main()\n{\n    int n,m,id,i;\n    char com[10];\n    ll ans;\n\n    while(scanf(\"%d%d\",&n,&m),n||m)\n    {\n        tree[1]=1;\n        ans=0;\n        for(i=2;i<=n;i++)\n            scanf(\"%d\",&tree[i]);\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%s%d\",com,&id);\n            if(com[0]=='M')\n                tree[id]=id;\n            else\n                ans+=Find(id);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else{\n    int a = query(t[v]);\n    t[v] = a;\n    return a;\n  }\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v] = 1;\n      qs.push_front(make_pair(order,v));\n    }\n\n    // printf(\"asdf %d\\n\",(int)qs.size());\n    // for(int i=0; i<qs.size(); i++){\n    //    printf(\"%c %d\\n\",qs[i].first,qs[i].second);\n    // }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second] = 0;\n    \n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\nint N,Q;\nint a[100005][2];\nchar q1[100005];\nint q2[100005];\nvector<vector<int> > vec(1000000);\n//vec = vector < vector <int> >(1000000,vector<int>(100000,0)) ;\n\nint queue(int x){\n  //    printf(\"%d\\n\",a[5][0]);\n  // printf(\"cookies\\n\");\n  if(a[x][1]==1){\n    return x;\n  }else{\n    return queue(a[x][0]);\n  }\n}\n\nvoid mark(int x){\n  a[x][1]=1;\n}\n\nvoid test(int x,int y){\n  a[x][1]=y;\n  if(!vec[x].empty()){\n    for(vector<int>::iterator it=vec[x].begin();it !=vec[x].end(); it++){\n      test(*it,y);\n    }\n  }else return;\n}\n\n\n\nvoid solve(){\n  int res=0;\n  for(int i=0;i<Q;i++){\n    if(q1[i]=='Q'){\n      // res+=queue(q2[i]);\n      res+=a[q2[i]][1];\n    }else{\n      //  mark(q2[i]);\n      test(q2[i],q2[i]);\n    }\n  }\n  printf(\"%d\\n\",res);\n\n}\n\nvoid init(){\n  memset(a,0,sizeof(a));\n  memset(q1,0,sizeof(q1));\n  memset(q2,0,sizeof(q2));\n}\n\nint main(){\n  while(true){\n    init();\n    scanf(\"%d%d\",&N,&Q);\n\n    if(N==0 && Q==0)\n      return 0;\n\n    a[1][0]=0;\n    a[1][1]=1;\n    for(int i=0;i<N-1;i++){\n      scanf(\"%d\",&a[i+2][0]);\n      a[i+2][1]=1;\n      vec[a[i+2][0]].push_back(i+2);\n\n    }\n    //    printf(\"%d\\n\",a[5][0]);\n\n    for(int i=0;i<Q;i++){\n      // scanf(\"%s%d\",&q1[i],&q2[i]);\n      cin >> q1[i] >> q2[i];\n    }\n\n    solve();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define int long long\n \nint to[123456];\nchar o[123456];\nint v[123456];\n \nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n \n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (y < x) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void sep(int x){\n    data[x] = -1;\n  }\n};\nsigned main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    memset(to,0,sizeof(to));\n    memset(o,0,sizeof(o));\n    memset(v,0,sizeof(v));\n    unionfind uf(n+10);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+2] = a;\n    }\n    for(int i = n;i > 1;--i){\n        uf.unionset(to[i],i);\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      if(o[i]=='M'){\n        uf.sep(v[i]);\n      }    \n    }\n    int sum = 0;\n     \n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i]);\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct node{\n\tint parent;\n\tbool marked;\n};\nnode V[100000];\nint query(int v){\n\tif(V[v].marked) return v+1;\n\telse return query(V[v].parent);\n}\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n){\n\t\tV[0].marked = true;\n\t\tfor(int i = 1; i < n; ++i){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tV[i].parent = --p;\n\t\t\tV[i].marked = false;\n\t\t}\n\t\tlong long sum = 0;\n\t\tfor(int i = 0; i < q; ++i){\n\t\t\tchar q;int v;\n\t\t\tcin >> q >> v;\n\t\t\t--v;\n\t\t\tif(q == 'M') V[v].marked = true;\n\t\t\telse{\n\t\t\t\tsum += query(v);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\nusing namespace std;\n\nconst int N=100000;\n\narray<int,N+1> par;\narray<bool,N+1>  is_marked;\n\nint nth_marked(int idx){\n    while(!is_marked[par[idx]]) idx=par[idx];\n    return par[idx];\n}\n\nvoid solve(){\n    int n,q;\n\n    while(cin>>n>>q,n|q){\n\n        is_marked[1]=true;\n\n        for(int i=2;i<=n;++i){\n            int t;\n            cin>>t;\n            par[i]=t;\n            is_marked[i]=false;\n        }\n\n        int sum=0;\n\n        for(int i=0;i<q;i++){\n            char c;int t;\n            cin.ignore();\n            cin>>c>>t;\n\n            if(c=='M'){\n                is_marked[t]=true;\n            }else{\n                sum += nth_marked(t);\n            }\n        }\n\n        cout<<sum<<endl;\n\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\n#define maxn 100000\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[maxn+5];\nint node[maxn + 5];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemset(node, 0, sizeof(node));\n\t\tcin>>N>>Q;\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tLL sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tcin>>fa[i+1];\n\t\t}\n\t\tnode[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tcin>>ope>>a;\n\t\t\tif (ope == 'M')node[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (node[a] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    int lca(int u, int v){\n        while(chain[u] != chain[v]){\n            if(depth[head[u]] > depth[head[v]]) u = goUp(u);\n            else v = goUp(v);\n        }\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    vector<set<pair<int,int>>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        int res = -1;\n        while(v != -1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(make_pair(-depth[v],-inf));\n            if(it->first != inf){\n                res = it->second;\n                break;\n            } else {\n                v = goUp(v);\n            }\n        }\n        return res;\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q'){\n                ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            } else {\n                marks.insert(mp(-d, qv[i]));\n            }\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q'){\n                ans += h.query(qv[i]) + 1;\n            } else {\n                h.mark(qv[i]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define mp make_pair\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<int> V;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\ntypedef priority_queue<ll> PQ;\ntypedef priority_queue<ll, V, greater<ll>> PQG;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\n\n//通常\nstruct UnionFind {\n    V par, rank;\n    UnionFind(int size) { init(size); }\n    void init(int size) {\n        REP(i, size) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n    int root(int x) {\n        if(par[x] == x)\n            return x;\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]) {\n            swap(x, y);\n        } else {\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n        par[y] = x;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n};\n\nint T[100000];\nbool marked[100000];\nint dfs(int v) { return marked[v] ? v : dfs(T[v]); }\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, Q, _t;\n    char _c;\n    while(cin >> N >> Q && N) {\n        memset(marked, 0, sizeof(marked));\n        FOR(i, 1, N) {\n            cin >> _t;\n            _t--;\n            T[i] = _t;\n        }\n        marked[0] = true;\n        ll sum = 0;\n        REP(i, Q) {\n            cin >> _c >> _t;\n            _t--;\n            if(_c == 'Q')\n                sum += dfs(_t) + 1;\n            else\n                marked[_t] = true;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint pars[100000];\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q;\n  while(cin >> N >> Q, N){\n\tpars[0] = 0;\n\tREP(i,N-1){\n\t  int p;\n\t  cin >> p;\n\t  --p;\n\t  pars[i+1] = p;\n\t}\n\t\n\tVI marked(N);\n\t++marked[0];\n\tvector<PII> qs(Q);\n\tREP(q,Q){\n\t  char c;\n\t  int pyon;\n\t  cin >> c >> pyon;\n\t  --pyon;\n\t  qs[q] = MP(c == 'M'?0: 1, pyon);\n\t  if(c == 'M') ++marked[pyon];\n\t}\n\n\tUnionFind uf(N);\n\tVI rt(N);\n\tiota(ALL(rt), 0);\n\tREP(i,N){\n\t  if(!marked[i]){\n\t\tint nrt = rt[uf.find(pars[i])];\n\t\tuf.unite(i, pars[i]);\n\t\trt[uf.find(i)] = nrt;\n\t  }\n\t}\n\n\tLL ans = 0;\n\tfor(int q=Q-1;q>=0;--q){\n\t  int u = qs[q].SS;\n\t  if(qs[q].FF == 0){\n\t\tif(!--marked[u]){\n\t\t  int nrt = rt[uf.find(pars[u])];\n\t\t  uf.unite(u, pars[u]);\n\t\t  rt[uf.find(u)] = nrt;\n\t\t}\n\t  }\n\t  else{\n\t\tans += rt[uf.find(u)]+1;\n\t  }\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int B = 300;\n\nconst int maxn = 100010;\nint par[maxn];\nvector<int> ch[maxn];\n\nint   V[maxn];\nchar QT[maxn];\nint ancester[maxn];\nbool use[maxn];\nbool marked[maxn];\n\nvoid compress(int l, int r){\n  vector<int> vs;\n  \n  memcpy(use, marked, sizeof(marked));\n  REP2(i, l, r) use[V[i]] = true;\n  \n  queue<P> que;\n  que.push(P(1, 0));\n  ancester[1] = 0;\n  \n  while(!que.empty()){\n    int v = que.front().first;\n    int a = que.front().second;\n    que.pop();\n    if(use[v] || marked[v]) a = v;\n    REP(i, ch[v].size()){\n      int to = ch[v][i];\n      ancester[to] = a;\n      que.push(P(to, a));\n    }\n  }\n}\n\nvoid mark(int v){\n  marked[v] = true;\n}\n\nint calc(int v){\n  while(!marked[v]) v = ancester[v];\n  return v;\n}\n\nint main(){\n  int N, Q;\n\n  while(cin >> N >> Q && N + Q){\n    memset(par, 0, sizeof(par));\n    REP(i, maxn) ch[i].clear();\n\n    marked[1] = true;\n    \n    REP(i, N - 1){\n      cin >> par[i+2];\n      ch[par[i+2]].push_back(i+2);\n    }\n  \n    REP(i, Q){\n      cin >> QT[i] >> V[i];\n    }\n  \n    ll s = 0;\n    for(int l = 0; l < Q; l += B){\n      int r = min(l + B, Q);\n      compress(l, r);\n      REP2(i, l, r){\n        if(QT[i] == 'M') mark(V[i]);\n        if(QT[i] == 'Q') s += calc(V[i]);\n      }\n    }\n    cout << s << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      if(num == 0) continue;\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 100000;\n\nint n, p;\nint pre[N+1];\n\nint find(int x)\n{\n    while (x != pre[x])\n        x = pre[x];\n    return x;\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &n, &p) != EOF) {\n        if (!n && !p) break;\n        pre[1] = 1;\n        for (int i = 2; i <= n; i ++)\n            scanf(\"%d\", &pre[i]);\n        long long sum = 0;\n        for (int i = 1; i <= p; i ++) {\n            char s[2];\n            int x;\n            scanf(\"%s%d\", s, &x);\n            if (s[0] == 'M')\n                pre[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <stdlib.h>\n#define ll long long\nusing namespace std;\nconst int NUM=100010;\nint pa[NUM];\nint Find(int x);\nvoid Union(int x,int y);\nint main()\n{\n    int n,m,x;\n    char c;\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    while(~scanf(\"%d %d\",&n,&m)&&n+m)\n    {\n        pa[1]=1;\n        for(int i=1; i<=n-1; i++)\n        {\n            scanf(\"%d\",&x);\n            pa[i+1]=x;\n        }\n        ll ans=0;\n        for (int i=0; i<m; i++)\n        {\n            scanf(\" %c %d\",&c,&x);\n            if (c=='M'&&pa[x]!=x)\n                pa[x]=x;\n            if (c=='Q')\n                ans+=Find(x);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\nint Find(int x)\n{\n    return pa[x]==x?x:Find(pa[x]);\n}\n*/\n#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <stdlib.h>\nusing namespace std;\nconst int NUM=100010;\nint pa[NUM];\nvector<int> G[NUM];\nvoid init(int n);\nint Find(int x);\nvoid Union(int x,int y);\nvoid dfs(int start,int x);\nint main()\n{\n    int n,m,x;\n    char c;\n   // freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n     int size = 256 << 20; //256M\n    char * p = (char *)malloc(size) + size;\n#if (defined _WIN64) or (defined __unix)\n    __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n#else\n    __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n#endif\n\n    while(~scanf(\"%d %d\",&n,&m)&&n+m)\n    {\n        for (int i=1;i<=n;i++)\n        {\n            G[i].clear();\n        }\n        for(int i=1;i<=n-1;i++)\n        {\n            scanf(\"%d\",&x);\n            G[x].push_back(i+1);\n        }\n        init(n);\n       long long ans=0;\n        for (int i=0;i<m;i++)\n        {\n            scanf(\" %c %d\",&c,&x);\n            if (c=='M'&&pa[x]!=x)\n            {\n                pa[x]=x;\n                dfs(x,x);\n            }\n            if (c=='Q')\n            {\n                ans+=pa[x];\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    exit(0);\n}\nvoid init(int n)\n{\n    for (int i=1; i<=n; i++)\n        pa[i]=1;\n}\nvoid dfs(int start,int x)\n{\n    for (int i=0;i<G[start].size();i++)\n    {\n        if (pa[G[start][i]]!=G[start][i])\n        {\n            pa[G[start][i]]=x;\n            dfs(G[start][i],x);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100001\nusing namespace std;\nint n,q,u,t[Q],p[Q],ans;\nchar c[Q];\nbool marked[Q];\n\nint find(int x){\n  if(marked[x]) return x;\n  else return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=0;i<n;i++) marked[i]=false;\n    for(int i=1;i<n;i++) cin>>u,u--,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i],t[i]--;\n      if(c[i]=='M') marked[t[i]]=true;\n    }\n    marked[0]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i])+1;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define x first\n# define y second \n# define mp make_pair\n\n# define pb push_back\n# define vec vector\n# define sz(a) int(a.size())\n\n# define y1 kek_y1\n# define left kek_left\n# define right kek_right\n\nusing namespace std;\n\ntypedef long  long ll;\ntypedef pair<int, int> pii;\ntypedef long double ld;\n\nconst int Sz = 1110111;\nconst int Mod = (int)1e9 + 7;\nconst int MX = (1<<30) - 1; // 1e9\nconst ll MXLL = (1ll<<62) - 1;        \n\ninline void Read_rap() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n}\nvoid files (string name) {\n\tif (fopen ((name+\".in\").c_str(), \"r\")) {\n\t\tfreopen ((name+\".in\").c_str(), \"r\", stdin);\n\t\tfreopen ((name+\".out\").c_str(), \"w\", stdout);\n\t}\n}       \nstruct fenwick { \n\tint n;\n\tvec < multiset <pii> > t;            \n\tfenwick (int n = 0) : n(n), t(n+1) {}\n\n\tvoid init (int _n) {\n\t\tn = _n;\n\t\tt.clear();\n\t\tt.resize(n);\n\t}\t\n\n\tvoid add (int i, int x, int y) {\n\t\tpii cur = mp (x, y);\n\t\tfor (; i <= n; i |= (i + 1))\t\n\t\t\tt[i].insert (cur);\n\t}\n\tvoid del (int i, int x, int y) {\n\t\tpii cur = mp (x, y);\n\t\tfor (; i <= n; i |= (i + 1)) { \n\t\t\tt[i].erase (t[i].find(cur));\n\t\t}\n\t}\n\n\tint get (int i) {\n\t\tpii res = mp (0, 0);\n\t\tfor (; i >= 0; i = (i & (i + 1)) - 1)\n\t\t\tif (sz(t[i]))\t\n\t\t\t\tres = max (res, *t[i].rbegin());\n\t\treturn res.y;\n\t}\n};\n\nstruct tree {\n\tint n;\n\tvec <vec<int> > g;\n                \n    vec <vec<int> > m, q;\n    fenwick F;\n\ttree (int n = 0, int n2 = 0) : n(n), g(n+1), m(n+1), q(n+1), F(n2)  {}\n\t     \n\tvoid init (int _n, int _q) {\n\t\tF.init(_q);      \n\t\tn = _n;        \n\t\tg.clear(), m.clear(), q.clear();\n\t\tg.resize(n+1), q.resize(n+1), m.resize(n+1);\n\t}\t\n\t\t\t\n\n\tvoid mark (int v, int i) {\n\t\tm[v].pb (i);\n\t}\n\tvoid query (int v, int i) {\n\t\tq[v].pb (i);\n\t}\n        \n   \tvoid calc (int v, int lvl, ll &sum) {\n   \t\tfor (int &i : m[v])\n   \t\t\tF.add (i, lvl, v);\n\n   \t\tfor (int &i : q[v])\n   \t\t\tsum += F.get (i - 1);\n\n   \t\tfor (int &to : g[v]) \n   \t\t\tcalc (to, lvl + 1, sum);\n   \t\tfor (int &i : m[v])\n   \t\t\tF.del (i, lvl, v);\n   \t}\n};       \n                                   \n\nint main()\n{\n\ttree T;  \n\tint n, q;\n\twhile (true) {\n\t\tscanf (\"%d %d\", &n, &q);\n\t\tif (n+q == 0)\n\t\t\tbreak;\n\n\t\tT.init(n, q);\n        for (int i = 2, pr; i <= n; i++) {\n        \tscanf (\"%d\", &pr);\n        \tT.g[pr].pb (i);                \n        }         \n        T.mark (1, 0);\n        for (int i = 1; i <= q; i++) {\n        \tstatic char c[10];\n        \tstatic int v;                 \n        \tscanf (\"%s %d\", c, &v);          \n        \tif (c[0] == 'M')\n        \t\tT.mark (v, i);\n        \telse\n        \t\tT.query (v, i);\n    \t}\n        ll ans = 0;\n        T.calc (1, 0, ans);\n        //return 0;\n    \tprintf (\"%lld\\n\", ans);\n\t}\n\t\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n//Coded by Z....\t\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(void){\n  int n=0;\n  int q=0;\n  scanf(\"%d%d\",&n,&q);\n  while(n!=0){\n    int tree[100005][2]={0};\n    tree[1][0]=1;\n    tree[1][1]=1;\n    int ans=0;\n    int i=0;\n    for(i=2;i<=n;i++){\n      scanf(\"%d\",&(tree[i][0]));\n    }\n\n    char zi=0;\n    int no=0;\n    for(i=0;i<q;i++){\n      scanf(\"%s%d\",&zi,&no);\n      if(zi=='M'){\n\ttree[no][1]=1;\n      }\n      else if(zi=='Q'){\n        no=tree[no][0];\n\twhile(tree[no][1]==0){\n\t  \n\t  no=tree[no][0];\n\t   }\n\tans+=no;\n\tno=0;\n      }\n    }\n    /*for(i=1;i<=n;i++){\n      printf(\"%d%d\\n\",tree[i][0],tree[i][1]);\n      }*/\n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&q);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nint par[100001],p[100001];\n\nbool mark[100001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    }\n  }\n\nint findancestor(int x){\n  if(mark[x]){\n    return x;\n    }else{\n      return findancestor(par[x]);\n    }\n  }\n  \nvoid unite(int x,int y){\n     par[y]=x;         \n  }\n\nint main() {\n  \n  while(1){\n\n   int N,Q;  scanf(\"%d %d\",&N,&Q);\n   \n   if(N==0&&Q==0) break;\n   \n   memset(mark,0,sizeof(mark));\n   \n   init(N);   mark[1]=1;\n   \n   for(int i=1; i<=N-1; i++){\n     int x; cin>>x;\n     p[i+1]=x;\n     }\n     \n   for(int i=N; i>=2; i--){\n     unite(p[i],i);\n     }\n     \n   long long ans=0;\n     \n   for(int i=0; i<Q; i++){\n     \n     char t; cin>>t;\n     \n       if(t=='M'){\n       \n        int v; cin>>v; mark[v]=1;\n       \n       }else if(t=='Q'){\n         \n        int v; cin>>v; \n        ans+=findancestor(v);\n         \n       }\n     \n     }\n               \n              cout<<ans<<endl;\n              \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 1e5+10;\n\nint n,p;\nint pa[N+1];\n\nint find(int x){\n    while(x != pa[x])\n        x = pa[x];\n    return x;\n}\n\n\nint main(){\n    while(scanf(\"%d%d\",&n,&p) == 2){\n        if(!n && !p) break;\n        pa[1] = 1;\n        for(int i=2; i<=n; i++)\n            scanf(\"%d\",&pa[i]);\n\n        long long sum = 0;\n        for(int i=1; i<=p; i++){\n            char s[2];\n            int x;\n            scanf(\"%s%d\",s,&x);\n            if(s[0] == 'M')\n                pa[x] = x;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\",sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint segtree[262144];\nvoid update(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c)return ;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]=max(segtree[e],f);\n\t\treturn;\n\t}\n\tupdate(a,(a+b)/2,c,d,e*2,f);\n\tupdate((a+b)/2+1,b,c,d,e*2+1,f);\n}\nint query(int a){\n\ta+=131072;\n\tint ret=0;\n\twhile(a){\n\t\tret=max(ret,segtree[a]);\n\t\ta/=2;\n\t}\n\treturn ret;\n}\nvector<int> g[100000];\nint L[100000];\nint R[100000];\nint Z[100000];\nint val;\nvoid dfs(int a){\n\tL[a]=val++;\n\tfor(int i=0;i<g[a].size();i++)\n\t\tdfs(g[a][i]);\n\tR[a]=val-1;\n}\nchar str[2];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tval=0;\n\t\tfor(int i=0;i<262144;i++)segtree[i]=1;\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tfor(int i=1;i<a;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tc--;\n\t\t\tg[c].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\tfor(int i=0;i<a;i++)Z[L[i]]=i;\n\t\tlong long ret=0LL;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint d;\n\t\t\tscanf(\"%s%d\",str,&d);\n\t\t\td--;\n\t\t\tif(str[0]=='M'){\n\t\t\t\tupdate(0,131071,L[d],R[d],1,d+1);\n\t\t\t}else{\n\t\t\t\tret+=query(L[d]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tll ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\ttb[e[j].m] = e[e[j].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\ttb[e[j].m] = to;\n\t\t\t\tans += tb[to] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint N, O; // O: number of operations\n\nstruct Node {\n\tint index;\n\tint r, l;\n\tint p;\n\tbool marked;\n\tNode() {\n\t\tr = l = 0;\n\t\tp = 0;\n\t\tmarked = false;\n\t}\n};\n\nint Q(Node *tree, int index) {\n\twhile (!tree[tree[index].p].marked) {\n\t\tindex = tree[index].p;\n\t}\n\treturn tree[index].p;\n}\n\nvoid M(Node *tree, int index) {\n\ttree[index].marked = true;\n}\n\nint main() {\n\twhile (cin >> N >> O) {\n\t\tif (N == 0 && O == 0) break;\n\t\tNode tree[N+1];\n\t\ttree[1].index = 1;\n\t\ttree[1].marked = true;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tint parent; cin >> parent;\n\t\t\ttree[i].index = i;\n\t\t\ttree[i].p = parent;\n\t\t}\n\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < O; i++) {\n\t\t\tchar op; int index;\n\t\t\tcin >> op >> index;\n\t\t\tif (op == 'Q') {\n\t\t\t\tsum += Q(tree, index);\n\t\t\t} else {\n\t\t\t\tM(tree, index);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint size = 0;\nint value[100000], parent[100000];\nbool is_mark[100000], is_root[100000];\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\ninline void push(int x) {\n\tvalue[size++] = x;\n}\n\ninline int pop() {\n\treturn value[--size];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tint input;\n\t\t\tcin >> input;\n\t\t\tparent[i] = --input;\n\t\t}\n\n\t\tmemset(is_root, false, sizeof(is_root));\n\t\tis_root[0] = true;\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tpush(v);\n\t\t\tif(ope == 'Q')\n\t\t\t\tis_mark[i] = false;\n\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tis_root[v] = true;\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tint ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tint v = pop();\n\n\t\t\tif(is_mark[i])\n\t\t\t\tuf.unite(v, parent[v]);\n\t\t\telse\n\t\t\t\tans += uf.find(v) + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint find(int v, int *T);\n\nint main()\n{\n\tint N, Q;\n\twhile(cin>>N>>Q){\n\t\tif( !N && !Q ){break;}\n\t\tint T[N+1];\n\t\tint OrigT[N+1];\n\t\tT[1] = OrigT[1] = 1;\n\t\tfor(int i=2; i<=N; i++){ cin >> T[i]; OrigT[i] = T[i]; }\n\n\t\tint ans = 0;\n\t\tfor(int i=0; i<Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tif(v==1) continue;\n\t\t\tswitch(ch){\n\t\t\tcase 'Q': ans += find(OrigT[v], T); break;\n\t\t\tcase 'M': T[v] = v; break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\nint find(int v, int *T){\n\tint ans = v;\n\twhile( ans != T[ans] ) ans = T[ans];\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par[i] = p;\n            par2[i] = p;\n        }\n        vector<P> v;\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                par[t] = t;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            v.push_back(q);\n        }\n\n        // solve\n        long long int ans = 0;\n        for(int i = v.size()-1; i >= 0; i--) {\n            if(v[i].first == 'M') {\n                unite(par2[v[i].second], v[i].second);\n            } else {\n                ans += find(v[i].second);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    for(int j = 0;j <= 0;j++){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\tr[0] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n // x =find(x);\n//  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<N;i++){\n      marked_list[i]=0;\n    }marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n\t\t\t\tif(marked_list[query_list[i][1]]==1){\n\t\t\t\t\tquery_list[i][0]='N';\n\t\t\t\t}\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tvi T(n);\n\t\tvi m(n);\n\t\tvi mv(n);\n\t\tiota(ALL(mv), 0);\n\t\tm[0] = 1;\n\t\trep1(i, n - 1)cin >> T[i], T[i]--;\n\t\tvpii a(q);\n\t\tunionfind uf(n);\n\t\tll ans = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')m[v - 1]++;\n\t\t\ta[i] = { c,v };\n\t\t}\n\t\trrep(i, q) {\n\t\t\tif (a[i].first == 'M')m[a[i].second - 1]--;\n\t\t\telse {\n\t\t\t\tint v = a[i].second - 1;\n\t\t\t\twhile (!m[v = mv[uf.find(v)]]) {\n\t\t\t\t\tint u = uf.find(T[v]);\n\t\t\t\t\tuf.unite(v, u);\n\t\t\t\t\tmv[uf.find(v)] = mv[u];\n\t\t\t\t}\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n#include <map>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <memory>\n\nusing namespace std;\n\n#if 1\n#define PRINT(x) { cout << #x << \": \" << (x) << endl; }\n#define PRINT_CONTAINER(x)  { cout << #x << \": \";                       \\\n        for (size_t ix = 0; ix < (x).size(); ++ix) cout << (x)[ix] << \", \"; \\\n        cout << endl; }\n#else\n#define PRINT(x)\n#define PRINT_CONTAINER(x)\n#endif\n\n#define MAX_N 100005\nint parent[MAX_N];\nint rank[MAX_N];\nint mark[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\n// find a root of tree\nint find(int x) {\n    if (parent[x] == x) return x;\n    if (mark[x]) return x;\n    return parent[x] = find(parent[x]);\n}\n\n// unite a group which includes x and a group which includes y\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n\n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y]) {\n            ++rank[x];\n        }\n    }\n}\n\n// check if x and y belong to the same group\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n\ntypedef pair<char, int> p;\n\nint n, q;\nvector<p> qs;\n\nint main(int argc, char *argv[]) {\n    char buf[1024];\n    while (true) {\n        fgets(buf, 1024, stdin);\n        sscanf(buf, \"%d%d\", &n, &q);\n        //cout << n << \", \" << q << endl;\n        if (n == 0) break;\n        init(n);\n        memset(mark, 0, sizeof(mark));\n        qs.clear();\n        for (int i = 1; i < n; ++i) {\n            int par;\n            fgets(buf, 1024, stdin);\n            sscanf(buf, \"%d\", &par); --par;\n            //cout << i << \", \" << par << endl;\n            parent[i] = par;\n        }\n        for (int i = 0; i < q; ++i) {\n            fgets(buf, 1024, stdin);\n            char c;\n            int a;\n            sscanf(buf, \"%c %d\", &c, &a); --a;\n            //cout << c << \", \" << a << endl;\n            qs.push_back(p(c, a));\n            if (c == 'M') {\n                mark[a] = 1;\n            }\n        }\n        long long int sum = 0;\n        for (int i = qs.size()-1; i >= 0; --i)\n        {\n            //cout << qs[i].first << \", \" << qs[i].second << endl;\n            if (qs[i].first == 'M') {\n                mark[qs[i].second] = 0;\n            } else {\n                sum += find(qs[i].second) + 1;\n            }\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define TEST 0\nint par[100001];\nbool marked[100001];\nint find_marked(int id)\n{\n    if(marked[id])return id;\n    return find_marked(par[id]);\n}\nint main(void)\n{\n    int n,q;\n    while(scanf(\"%d%d\",&n,&q)==2 && (n!=0 || q != 0))\n    {\n        par[1]=0;\n        marked[1]=true;\n        int sum=0;\n        for(int i=0;i<n-1;i++)\n        {\n            scanf(\"%d\",par + i+2);\n            marked[i+2]=false;\n        }\n        for(int j=0;j<q;j++)\n        {\n            char str[8];\n            int num;\n            scanf(\"\\n%[QM]%d\",str,&num);\n#if TEST\n            printf(\"%c:%d\\n\",str[0],num);\n#endif\n            switch(str[0])\n            {\n            case 'Q':\n                    sum+=find_marked(num);\n                    break;\n            case 'M':\n                    marked[num]=true;\n                    break;\n            }\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint find(int i,vector<int>&p,vector<int>&q){\n\tif(q[i]==i){\n\t\treturn q[i];\n\t}else{\n\t\treturn q[i] = find(p[i],p,q);\n\t}\n}\n\n\nint main(){\n\tint n,Q;\n\twhile(cin >> n >> Q&&n!=0){\n\t\tvector<int>p(n);\n\t\tvector<int>q(n);\n\t\tll ans = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tq[i] = 0;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint t;\n\t\t\tcin >>t;\n\t\t\tt--;\n\t\t\tp[i] = t;\n\t\t}\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tchar z;\n\t\t\tint k;\n\t\t\tcin >> z >> k;\n\t\t\tk--;\n\t\t\tif(z=='M'){\n\t\t\t\tq[k]=k;\n\t\t\t}else{\n\t\t\t\tans += (ll)find(k,p,q);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tconst int N;\n\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tint groups_;\n\tstd::vector< int > sizes;\n\npublic:\n\tUnionFind( int n ) : N( n ), parent( N ), rank( N, 0 ), groups_( N ), sizes( N, 1 )\n\t{\n\t\tstd::iota( parent.begin(), parent.end(), 0 );\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( parent[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tbool unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tparent[x] = y;\n\t\t\tsizes[y] += sizes[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tsizes[x] += sizes[y];\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\t++rank[x];\n\t\t\t}\n\t\t}\n\n\t\t--groups_;\n\t\treturn true;\n\t}\n\n\tint groups() const\n\t{\n\t\treturn groups_;\n\t}\n\n\tint groupSize( const int x )\n\t{\n\t\treturn sizes[ find( x ) ];\n\t}\n};\n// UnionFind( N )\n// find( x )\n// same( x, y )\n// unite( x, y )\n// groups()\n// groupSize( x )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int N, Q; scanf( \"%d%d\", &N, &Q ) && ( N | Q ); )\n\t{\n\t\tVI parents( N, -1 );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tscanf( \"%d\", &parents[i] );\n\t\t\t--parents[i];\n\t\t}\n\t\tVT( char ) types( Q );\n\t\tVI vs( Q );\n\t\tREP( i, Q )\n\t\t{\n\t\t\tscanf( \" %c%d\", &types[i], &vs[i] );\n\t\t\t--vs[i];\n\t\t}\n\t\t// end of input\n\n\n\t\tVVI G( N );\n\t\tREP( i, 1, N )\n\t\t{\n\t\t\tG[ parents[i] ].PB( i );\n\t\t}\n\t\t\n\t\tVI marked( N );\n\t\tmarked[0] = 1;\n\t\tREP( i, Q )\n\t\t{\n\t\t\tif ( types[i] == 'M' )\n\t\t\t{\n\t\t\t\tmarked[ vs[i] ] = 1;\n\t\t\t}\n\t\t}\n\t\tREP( i, N )\n\t\t{\n\t\t\tif ( marked[i] )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttypes.PB( 'M' );\n\t\t\tvs.PB( i );\n\t\t}\n\n\t\tVI answers( N );\n\t\tiota( ALL( answers ), 1 );\n\t\tUnionFind uf( N );\n\t\tLL res = 0;\n\t\tfor ( int i = SZ( types ) - 1; 0 <= i; --i )\n\t\t{\n\t\t\tconst char T = types[i];\n\t\t\tconst int v = vs[i];\n\n\t\t\tif ( T == 'M' )\n\t\t\t{\n\t\t\t\tconst int na = answers[ parents[v] ];\n\t\t\t\tuf.unite( v, parents[v] );\n\t\t\t\tanswers[ uf.find( v ) ] = na;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres += answers[ uf.find( v ) ];\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%I64d\\n\", res );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            a--;\n            if(a==0){ans++; continue;}\n            //a=P[a];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m;}\n            }\n            bool done=false;\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; done=true; break;}\n            }\n            if(!done){ans++;}\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\nvector <ll> par;\nvector <bool> ism;\n\n//find marked root (keiroasshuku at the same time)\nll root(ll x){\n\tif (ism[x]) return x;\n\telse return par[x] = root(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += root(par[q[i].snd]) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint par[MAX_N];\nint root;\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start){\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++){\n            if(used[child[start][i]]==0) dfs(child[start][i]);\n        }\n    }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        tmp.child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    tmp.used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if (a=='Q') {\n            //cout<<\"as\"<<mark[b-1]<<endl;\n            ans+=tmp.mark[b-1];\n            ans++;\n        }\n        else {\n            root=b-1;\n            tmp.used[b-1]=1;\n            tmp.dfs(b-1);\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(k),rank(k)\n    {\n        n=k;\n        for(int i=0;i<n;i++) par[i]=i;\n        for(int i=0;i<n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[c[x][i]]) par[c[x][i]]=x;\n            else           par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1<<29)\n\nstruct SegmetTree {\n    int n, dat[2*MAX-1];    \n    \n    SegmetTree(int n_, vector<int> &d)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = 1;\n        }\n    }\n\n    void update(int k, int a)\n    {\n        k += n - 1;\n        dat[k] = max(dat[k], a);\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    \n    int get_max(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return -INF;\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            int vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n            int vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }    \n};\n\nint child[MAX];\nvector<int> G[MAX], vec;\n\nvoid init(int N)\n{\n    vec.clear();\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n        child[i] = 0;\n    }\n}\n\nint dfs(int v)\n{\n    int c = 0;\n    vec.push_back(v);\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        c += dfs(G[v][i]) + 1;\n    }\n    return (child[v] = c);\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0);\n\n        vector<int> num(N);\n        for (int i = 0; i < (int)vec.size(); i++) {\n            num[vec[i]] = i;\n        }\n        \n        SegmetTree st(N, vec);\n        \n        char m;\n        int v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.update(num[v], v + 1);\n                for (int i = num[v] + 1; i <= num[v] + child[v]; i++) {\n                    st.dat[i+st.n-1] = max(st.dat[i+N-1], v+1);\n                }\n            } else {\n                int n = num[v];\n                res += st.get_max(n, n + child[v] + 1, 0, 0, st.n);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define min(a, b) a < b ? a : b\n#define maxN 100000 + 16\n#define inf 0x7f7f7f7f\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c[2];\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tfor (i = 1, nn = 0; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%s%d\", c, &x);\n\t\t\tif (c[0] == 'M')\n\t\t\t\tmark[x] = min(mark[x], i);\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\twhile(nn--)\n\t\t{\n\t\t\ttt = qt[nn];\n\t\t\tsum += find(qx[nn]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nconst int MAX = 1e5;\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvector<int> tr[MAX+1];\nint par[MAX+1],n,q;\nint mark[MAX+1];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        par[i] = i;\n    }\n}\n\nint find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    \n    par[y] = x;\n}\n\nbool same(int x,int y){\n    return find(x) == find(y);\n}\n\nint tmp[MAX+1];\nvoid rec(int x,int y,int z){\n    int t = z;\n    tmp[x] = y;\n    if(mark[x]){\n        t = x;\n    }\n    unite(t,x);\n    \n    for(int i = 0 ; i < tr[x].size() ; i++){\n        rec(tr[x][i],x,t);\n    }\n}\n\nint main(){\n    int p,num;\n    char m;\n    while(cin >> n >> q , n + q){\n        ll sum = 0;\n        stack<P> st;\n        init();\n        fill(mark,mark+MAX,0);\n        fill(tmp,tmp+MAX,0);\n        mark[0] = 1;\n        for(int i = 0 ; i < MAX ; i++){\n            tr[i].clear();\n        }\n        for(int i = 1 ; i < n ; i++){\n            cin >> p; --p;\n            tr[p].push_back(i);\n        }\n        for(int i = 0 ; i < q ; i++){\n            cin >> m >> num; --num;\n            st.push(P(m,num));\n            \n            if(m == 'M'){\n                ++mark[num];\n            }\n        }\n        rec(0,-1,-1);\n        while(q--){\n            P p = st.top(); st.pop();\n            if(p.first == 'Q'){\n                sum += find(p.second)+1;\n            }\n            else{\n                --mark[p.second];\n                if(!mark[p.second]) {\n                    unite(tmp[p.second],p.second);\n                }\n            }\n        }\n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nclass LCADist{\n\tint n;\n\tvector< vector<int> > parentI;\n\tvector< vector<ll > > parentL;\n\tvector<int> depth;\n\tll ans;\n\tint maxdepth;\n\t\n\tvoid initdfs(vector< vector<pii> > &g, int r, int p, int d){\n\t\tdepth[r] = d;\n\t\tREP(i, g[r].size()){\n\t\t\tif(g[r][i].first != p){\n\t\t\t\tparentI[0][g[r][i].first] = r;\n\t\t\t\tparentL[0][g[r][i].first] = g[r][i].second;\n\t\t\t\tinitdfs(g, g[r][i].first, r, d+1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tLCADist(vector< vector<pii> > &g, int root) {\n\t\tn=g.size();\n\t\tmaxdepth = 0;\n\t\twhile(n>>maxdepth) maxdepth ++;\n\t\t\n\t\tparentI = vector< vector<int> >(maxdepth+1, vector<int>(n));\n\t\tparentL = vector< vector<ll > >(maxdepth+1, vector<ll>(n));\n\t\tdepth = vector<int>(n);\n\t\t\n\t\tparentI[0][0] = -1;\n\t\tinitdfs(g, root, -1, 0);\n\t\tREP(k, maxdepth){\n\t\t\tREP(i, n){\n\t\t\t\tif(parentI[k][i] < 0) parentI[k+1][i] = -1;\n\t\t\t\telse{\n\t\t\t\t\tparentI[k+1][i] = parentI[k][parentI[k][i]];\n\t\t\t\t\tparentL[k+1][i] = parentL[k][parentI[k][i]] + parentL[k][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll lca(int u, int v){\n\t\tif(depth[u] > depth[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tif(u==v) return ans;\n\t\tREP(k, maxdepth+1){\n\t\t\tif((depth[v]-depth[u])>>k&1){\n\t\t\t\tans += parentL[k][v];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\tif(u==v) return ans;\n\t\tRREP(k, maxdepth+1){\n\t\t\tif(parentI[k][u] != parentI[k][v]){\n\t\t\t\tans += parentL[k][u] + parentL[k][v];\n\t\t\t\tu = parentI[k][u];\n\t\t\t\tv = parentI[k][v];\n\t\t\t}\n\t\t}\n\t\treturn ans + parentL[0][u] + parentL[0][v];\n\t}\n\t\n\tint getDepth(int v){\n\t\treturn depth[v];\n\t}\n};\nint n, q;\nconst int BLOCK = 255;\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> q, n){\n\t\tvector< vector<pii> > g(n);\n\t\tREP(i, n-1){\n\t\t\tint p; cin >> p; p--;\n\t\t\tg[i+1].emplace_back(p, 1);\n\t\t\tg[p].emplace_back(i+1, 1);\n\t\t}\n\t\tLCADist lca(g, 0);\n\t\tvector<int> marked;\n\t\tvector<pii> res(n);\n\t\tREP(i, n) res[i] = pii(lca.getDepth(i), 0);\n\t\tint sum = 0;\n\t\tREP(i, q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v; v--;\n\t\t\tif(c == 'Q'){\n\t\t\t\tpii ans = res[v];\n\t\t\t\tFOR(u, marked){\n\t\t\t\t\tint d = lca.lca(*u, v);\n\t\t\t\t\tans = min(ans, pii(d, *u));\n\t\t\t\t}\n\t\t\t\tsum += ans.second+1;\n\t\t\t}else{\n\t\t\t\tmarked.push_back(v);\n\t\t\t}\n\t\t\tif((i & BLOCK) == BLOCK){\n\t\t\t\tqueue<pair<pii, pii>> que;\n\t\t\t\tFOR(u, marked) que.emplace(pii(0, *u), pii(*u, -1));\n\t\t\t\tmarked.clear();\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tconst pii c = que.front().first;\n\t\t\t\t\tconst int v = que.front().second.first;\n\t\t\t\t\tconst int p = que.front().second.second;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif(res[v].first > c.first) continue;\n\t\t\t\t\tres[v] = c;\n\t\t\t\t\tFOR(e, g[v])if(e->first!=p)\n\t\t\t\t\t\tque.emplace(pii(c.first+1, c.second), pii(e->first, v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\n#define maxn 100000\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[maxn+5];\nint node[maxn + 5];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemset(node, 0, sizeof(node));\n\t\tcin>>N>>Q;\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tLL sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tcin>>fa[i+1];\n\t\t}\n\t\tnode[1] = 1;\n                while(getchar()!='\\n');\n\t\twhile (Q--)\n\t\t{\n\t\t\tcin>>ope>>a;\nwhile(getchar()!='\\n');\n\t\t\tif (ope == 'M')node[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (node[a] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<string.h>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,bool> P;\nint N,Q;\nint p[1000000];\nbool hoge[10000000];\nint q;\nchar s;\n\nint parent(int x){\n  if(hoge[p[x]]==1) return p[x];\n  else return parent(p[x]);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\",&N,&Q);\n    if(N==0) break;\n    memset(p,0,sizeof(p));\n    memset(hoge,0,sizeof(hoge));\n    p[1]=-1;\n    hoge[1]=1;\n    lli res=0;\n    for(int i=2;i<=N;i++) scanf(\"%d\\n\",&p[i]);\n    for(int i=0;i<Q;i++) {\n      scanf(\"%c %d\\n\",&s,&q);\n//      printf(\"%d\\n\",hoge[q]);\n      if(s=='M'){\n        hoge[q]=1;\n      }\n      if(s=='Q'){\n        res+=parent(q);\n      }\n    }\n\n    printf(\"%lld\\n\",res);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define N 100000 + 10\nint par[N];\nint Find(int x){\n\tif (x == par[x])\n\t\treturn x;\n\treturn Find(par[x]);\n}\nint main(){\n\tint n, q;\n\tint a;\n\tchar ch[5];\n\n\twhile (~scanf(\"%d%d\" ,&n,&q) && n&&q){\n\t\tpar[1] = 1;\n\t\tfor (int i = 2; i <= n; i++){\n\t\t\tscanf(\"%d\", &a);\n\t\t\tpar[i] = a;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < q; i++){\n\t\t\tscanf(\"%s%d\",ch, &a);\n\t\t\tif (ch[0] == 'Q')\n\t\t\t\tsum += Find(a);\n\t\t\telse\n\t\t\t\tpar[a] = a;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){ // aの根をa∪bの根にする\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\t//if(-data[ra]<-data[rb])\n\t\t\t//\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int n,q;cin>>n>>q,n|q;){\n\t\tvi par(n); par[0]=-1;\n\t\trepi(i,1,n) cin>>par[i],par[i]--;\n\t\t\n\t\tvector<pair<char,int>> qs;\n\t\tvi mark(n); mark[0]=1;\n\t\trep(i,q){\n\t\t\tchar t; int x; cin>>t>>x; x--;\n\t\t\tif(t=='Q')\n\t\t\t\tqs.emplace_back(t,x);\n\t\t\telse if(!mark[x]){\n\t\t\t\tmark[x]=1;\n\t\t\t\tqs.emplace_back(t,x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\trep(i,n) if(!mark[i]) uf.Unite(par[i],i);\n\t\t\n\t\tint res=0;\n\t\tper(i,qs.size())\n\t\t\tif(qs[i].first=='Q')\n\t\t\t\tres+=uf.Find(qs[i].second)+1;\n\t\t\telse{\n\t\t\t\tint x=qs[i].second;\n\t\t\t\tuf.Unite(par[x],x);\n\t\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint parents[100010];\nint ranks[100010];\n\n// trees[x] -> y, x?????????y\n// ??\\???????????¨?§?????????±\nint trees[100010]; \n\nvoid initUnionFind() {\n    for (int i=0; i<100010; ++i) {\n        parents[i] = i;\n        ranks[i] = 1;\n    }\n}\nint findParent(int x) {\n    if (x == parents[x]) return x;\n    return parents[x] = findParent(parents[x]);\n}\nvoid unite(int x, int y) {\n    int px = findParent(x);\n    int py = findParent(y);\n    if (px == py) return;\n    if (ranks[px] > ranks[py]) {\n        parents[py] = px;\n    } else {\n        parents[px] = py;\n        if (ranks[px] == ranks[py]) {\n            ranks[py] += 1;\n        }\n    }\n}\n\nint main() {\n    int N,Q;\n\n    while (cin >> N >> Q) {\n        if (N == 0 && Q == 0) break;\n\n        initUnionFind();\n        for (int i=0; i<100010; ++i) trees[i] = i;\n\n        for (int i=0; i<N-1; ++i) {\n            int p; cin >> p;\n            parents[i + 2] = p;\n            trees[i + 2] = p;\n        }\n\n        /*\n        // debug\n        cout << \"before marked\" << endl;\n        for (int i=0; i<=N; ++i) {\n            printf(\"node:%2d\\tparent:%2d\\n\", i, parents[i]);\n        }\n        cout << endl;\n        */\n\n        vector<pair<char, int> > queries;\n        for (int i=0; i<Q; ++i) {\n            char ope;\n            int v;\n            cin >> ope >> v;\n            // ????????????????????????????????????\n            if (ope == 'M' && parents[v] == v) continue;\n\n            // ???????????????\n            if (ope == 'M') {\n                parents[v] = v;\n            }\n            queries.push_back( make_pair(ope, v) );\n        }\n\n        /*\n        // debug\n        cout << \"after marked\" << endl;\n        for (int i=0; i<=N; ++i) {\n            printf(\"node:%2d\\tparent:%2d\\n\", i, findParent(i));\n        }\n        cout << endl;\n        */\n\n        // ???????????????\n        reverse( queries.begin(), queries.end() );\n        long long ans = 0;\n        for (int i=0; i<queries.size(); ++i) {\n            if (queries[i].first == 'M') {\n                // mark??????????????????node??¨??£???\n                unite(queries[i].second, trees[queries[i].second]);\n            } else {\n                // ope = 'Q'\n                ans += findParent(queries[i].second);\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nclass UnionFind\n{\nprivate:\n  vector<int> par;\n  vector<int> rank;\n\npublic:\n  UnionFind(int n)\n  {\n    par.resize(n);\n    rank.resize(n);\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  int find(int x)\n  {\n    if (par[x] == x) {\n      return x;\n    } else  {\n      return par[x] = find(par[x]);\n    }\n  }\n  \n  bool same(int x, int y)\n  {\n    return find(x) == find(y);\n  }\n  \n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 100000;\nint N, Q;\nint par[MAXN];\nGraph G;\n\nint main()\n{\n  while (cin >> N >> Q && (N|Q)) {\n    G = Graph(N);\n    for (int i = 1; i < N; ++i) {\n      cin >> par[i]; --par[i];\n      G[par[i]].push_back(i);\n    }\n\n    vector<char> op(Q);\n    vector<int> v(Q);\n    for (int i = 0; i < Q; ++i) {\n      cin >> op[i] >> v[i];\n      --v[i];\n    }\n    reverse(op.begin(), op.end());\n    reverse(v.begin(), v.end());\n\n    vector<int> M(N);\n    for (int i = 0; i < Q; ++i)\n      if (op[i] == 'M') M[v[i]] = true;\n\n    UnionFind uf(N);\n    vector<int> nearest(N);\n    for (int st = 0; st < N; ++st) {\n      if (!M[st]) continue;\n      queue<int> que;\n      que.push(st);\n      while (que.size()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n          int nv = G[v][i];\n          if (M[nv]) continue;\n          uf.unite(v, nv);\n          que.push(nv);\n        }\n      }\n      nearest[uf.find(st)] = st;\n    }\n\n    lli res = 0;\n    for (int i = 0; i < Q; ++i) {\n      if (op[i] == 'Q') {\n        res += nearest[uf.find(par[v[i]])] + 1;\n      } else {\n        int tmp = nearest[uf.find(par[v[i]])];\n        uf.unite(v[i], par[v[i]]);\n        nearest[uf.find(par[v[i]])] = tmp;\n      }\n    }\n    cout<< res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n练习题：Marked Ancestor_AOJ 2170\n*/ \n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N=100007;\n\n//DUS start line\n\nint par[MAX_N];//父亲 \nint ran[MAX_N];//树的高度\n\n//初始化n个元素\nvoid init(int n)\n{\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tpar[i]=i;\n\t\tran[i]=0;\n\t}\n}\n\n//查询树的根\nint find(int x)\n{\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn find(par[x]);//此题这里不要给par[x]赋值，即不要做路径优化 \n}\n\n//合并x和y所属的集合\nvoid unite(int x, int y)\n{\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)\n\t\treturn ;\n\tif(ran[x]<ran[y])\n\t\tpar[x]=y;\n\telse\n\t{\n\t\tpar[y]=x;\n\t\tif(ran[x]==ran[y])\n\t\t\tran[x]++;\n\t}\n}\n\n//判断x和y是否属于同一个集合\nbool same(int x, int y)\n{\n\treturn find(x)==find(y);\n}\n\n//DUS end line \n\nint N, Q;\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &N, &Q)!=EOF)\n\t{\n\t\tif(N==0&&Q==0)\n\t\t\tbreak;\n\t\t\t\n\t\tmemset(par, 0, sizeof(par));\n\t\tmemset(ran, 0, sizeof(ran));\n\t\tpar[1]=1;\n\t\t\n\t\tfor(int i=2; i<=N; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t}\n\t\t\n\t\tlong long ans=0;\n\t\tfor(int i=0; i<Q; i++)\n\t\t{\n\t\t\tchar t;\n\t\t\tgetchar();\n\t\t\tt=getchar();\n\t\t\tif(t=='Q')\n\t\t\t{\n\t\t\t\tint q;\n\t\t\t\tscanf(\"%d\", &q);\n\t\t\t\tans+=find(q);\n\t\t\t}\n\t\t\telse if(t=='M')\n\t\t\t{\n\t\t\t\tint m;\n\t\t\t\tscanf(\"%d\", &m);\n\t\t\t\tpar[m]=m;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\t\n\t\t\n\t}\n\t\t\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nlong long par[MAX_N+1];//parents\nlong long Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(long long n){\n\tfor(long long i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nlong long find(long long x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(long long x,long long y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(long long x, long long y){\n\treturn find(x) == find(y);\n}\n\nlong long N,Q;\nlong long sum = 0;\nlong long tree[MAX_N+1];\n\nlong long nearestAncstr(long long num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,long long num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nlong long num;char symbol;\n\n\nvoid solve(){\n\tinit(N);sum = 0;\n\ttree[0] = 0;\n\tfor(long long i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tfor(int i = 0;i < Q;i++){\n\t\tcin >>symbol >>num;num--;\n\t\toperate(symbol,num);\n\t}\n\tprintf(\"%lld\\n\",sum);\n}\n\nint main(){\n\twhile(true){\n\t\tcin >>N >>Q;\n\t\tif(N == 0 && Q == 0)break;\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct segment_tree{\n    static const int SEG=1<<17;\n    vector<int>dat;\n    segment_tree():dat(SEG*2){}\n    void update(int a,int b,int x,int k=0,int l=0,int r=SEG){\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n            dat[k]=max(dat[k],x);\n            return;\n        }\n        update(a,b,x,k*2+1,l,(l+r)/2);\n        update(a,b,x,k*2+2,(l+r)/2,r);\n    }\n    int query(int k){\n        k+=SEG-1;\n        int ret=dat[k];\n        while(k){\n            k=(k-1)/2;\n            ret=max(ret,dat[k]);\n        }\n        return ret;\n    }\n};\n\nconst int SIZE=100000;\n\nint N,Q;\nvector<int>G[SIZE];\n\nint tt,tin[SIZE],tout[SIZE];\nint par[20][SIZE],dep[SIZE];\nvoid dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    tin[v]=tt++;\n    for(auto u:G[v])dfs(u,v,d+1);\n    tout[v]=tt;\n}\n\nint main(){\n    while(scanf(\"%d%d\",&N,&Q),N||Q){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=1;i<N;i++){\n            int p;scanf(\"%d\",&p);p--;\n            G[p].push_back(i);\n        }\n        tt=0;\n        dfs(0,-1,0);\n\n        for(int i=0;i<19;i++){\n            for(int j=0;j<N;j++){\n                if(par[i][j]==-1)par[i+1][j]=-1;\n                else par[i+1][j]=par[i][par[i][j]];\n            }\n        }\n\n        segment_tree seg;\n        long long ans=0;\n        while(Q--){\n            char c;\n            int v;\n            scanf(\" %c%d\",&c,&v);\n            v--;\n            if(c=='M'){\n                seg.update(tin[v],tout[v],dep[v]);\n            }\n            else{\n                int d=seg.query(tin[v]);\n                for(int i=19;i>=0;i--)if((dep[v]-d)>>i&1)v=par[i][v];\n                ans+=v+1;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\n\nstruct Unionfind {\n  vector<int> size;\n  vector<int> par;\n\n  Unionfind( int n ) :  size(n, 1), par(n) {\n    iota( par.begin() , par.end() , 0 );\n  }\n\n  int find( int x ) {\n    if ( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n\n  bool unite( int x , int y ) {\n    x = find(x);\n    y = find(y);\n    if ( x == y ) return false;\n\n    //if ( size[y] < size[x] ) swap( x , y );\n    //y is always_parent\n    par[x] = y;\n    size[y] += size[x];\n\n    return true;\n  }\n\n  bool same( int x , int y ) {\n    return find(x) == find(y);\n  }\n};\nint main(void)\n{\n  for(;;){\n    int n,q;\n    cin >> n >> q;\n    if(!n&&!q) return 0;\n    vector<int> p(n+1);\n    FOR(i,2,n+1) cin >> p[i];\n    vector<pair<string,int> > o(q);\n    REP(i,q) cin >> o[i].first >> o[i].second;\n    vector<bool> m(n+1,false);\n    m[1]=true;\n    REP(i,q) if(o[i].first==\"M\") m[o[i].second]=true;\n    Unionfind t(n+1);\n    FOR(i,1,n+1) if(!m[i]) t.unite(i,p[i]);\n    LL answer=0;\n    for(int i=o.size()-1;i>=0;--i){\n      if(o[i].first==\"M\") t.unite(o[i].second,p[o[i].second]);\n      else answer+=t.find(o[i].second);\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass IN{\npublic:\n  char c;\n  int a;\n  IN(char c, int a):c(c),a(a){}\n};\n\nclass UF{\npublic:\n  vector<int> per;\n  void init(int n){\n    per = vector<int>(n+1);\n    rep(i,per.size())per[i]=i;\n\n  }\n  int find(int a){\n    if(per[a]==a)return a;\n    return per[a] = find(per[a]);\n  }\n  void uni(int a, int b){\n\n    a = find(a);\n    b = find(b);\n\n\n    if(a==b)return;\n    per[b] = a;\n  }\n  bool same(int a,int b){\n    return find(a)==find(b);\n  }\n  void print(){\n    reps(i,1,per.size())printf(\"%d \",per[i]);puts(\"\");\n  }\n  void fprint(){\n    reps(i,1,per.size())printf(\"%d \",find(i));puts(\"\");\n  }\n};\n\nint n,m;\nvector<int> tree;\nvector<IN> in;\n\nbool input(){\n  if(!(cin>>n>>m))return false;\n  if(n==0)return false;\n  tree = vector<int>(n+1);\n  tree[1] = -1;\n\n  rep(i,n-1){\n    cin>>tree[i+2];\n  }\n  in.clear();\n\n  vector<int> check(n+1,0);\n  check[1]=1;\n  in.push_back(IN('M',1));\n\n  rep(i,m){\n    char c;\n    int a;\n    cin>>c>>a;\n    if(c=='M'){\n      if(check[a]==1)continue;\n      check[a]=1;\n    }\n    in.push_back(IN(c,a));\n    //rep(i,check.size())printf(\" ==%d \",check[i]);puts(\"\");\n  }\n  return true;\n\n}\n\n\nUF uf;\n\nlong long solve(){\n  vector<IN> rev = in;\n  reverse(rev.begin(),rev.end());\n  uf.init(n);\n  vector<int> check(n+1,0);\n  rep(i,in.size()){\n    if(in[i].c=='M'){\n      check[in[i].a]=1;\n    }\n    //printf(\"hoooo %c %d\\n\",in[i].c, in[i].a);\n  }\n\n  reps(i,1,n+1){\n    //printf(\"uniiii %d %d\\n\",tree[i],i);\n    if(check[i]==0)uf.uni(tree[i], i);\n    if(check[i]==1)uf.per[i]=i;\n  }\n  \n  long long ret = 0;\n  rep(i,rev.size()){\n\n    if(rev[i].c=='Q'){\n      int t = uf.find(rev[i].a);\n      ret += t;\n      //printf(\"%d %d\\n\",i,t);\n    }else{\n      //printf(\"  \");uf.fprint();\n      uf.uni(tree[rev[i].a], rev[i].a);\n    }\n    //printf(\"  \");uf.fprint();\n  }\n  return ret;\n}\n\nint main(){\n  while(input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint pre[100005];\nint find_root(int x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    int n, q;\n    while(scanf(\"%d%d\", &n, &q), n || q)\n    {\n        pre[1] = 1;\n        for(int i = 2; i <= n; i++)\n            scanf(\"%d\", &pre[i]);\n        char a;\n        int b;\n        int ans = 0;\n        while(q--)\n        {\n            scanf(\" %c%d\", &a, &b);\n            if(a == 'Q')\n                ans += find_root(b);\n            else\n                pre[b] = b;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nvector<node> T;\nint main(){\n  while(1){\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    node root;\n    root.marked = true;\n    root.parent = 0;\n    root.num = 1;\n    T.push_back(root);\n    for(int i=2;i<n+1;i++){\n      int parent;\n      cin >> parent;\n      node child;\n      T.push_back(child);\n      T[i-1].marked = false;\n      T[i-1].num = i;\n      T[i-1].parent = parent-1;\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }\n      if(q=='Q'){\n        node n = T[v-1];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n//#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <array>\n//#include <set>\n\nusing namespace std;\n\nusing ll_t = long long;\n// #define ll_t long long\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170&lang=jp\n\nclass MarkedTree {\npublic:\n    vector<size_t> parent;\n    vector<bool> marks;\n    explicit MarkedTree(size_t size) {\n        parent = vector<size_t>(size, 0);\n        marks = vector<bool>(size, false);\n        parent[0] = -1; // root\n        marks[0] = true;\n    }\n    size_t findMarkedParent(size_t node) {\n        if (marks[node]) {\n            return node;\n        } else {\n            size_t ret = findMarkedParent(parent[node]);\n            parent[node] = ret;\n            return ret;\n        }\n    }\n    void unMark(size_t node) {\n        marks[node] = false;\n    }\n    void mark(size_t node) {\n        marks[node] = true;\n    }\n    void setParent(size_t node, size_t parentNode) {\n        parent[node] = parentNode;\n    }\n};\n\nint main() {\n    while (true) {\n        int N, Q;\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) {\n            return 0;\n        }\n        MarkedTree tree(N);\n        for (int node = 1; node <= N-1; node++) {\n            int parent;\n            scanf(\"%d\", &parent);\n            tree.setParent(node, parent - 1);\n        }\n        vector<pair<char, int>> inputs;\n        inputs.reserve(Q);\n        for (int i = 0; i < Q; i++) {\n            char q;\n            int p;\n            scanf(\" %c\", &q);\n            scanf(\"%d\", &p);\n            if (q == 'M') {\n                if (!tree.marks[p-1]) {\n                    inputs.emplace_back(q,p);\n                }\n                tree.mark(p-1);\n            } else if (q == 'Q') {\n                inputs.emplace_back(q,p);\n            }\n        }\n        ll_t querySum = 0;\n        for (int i = (int)inputs.size() - 1; i >= 0; i--) {\n            char q = inputs[i].first;\n            int node = inputs[i].second;\n            if (q == 'Q') {\n                querySum += tree.findMarkedParent(node - 1) + 1;\n            } else { // M\n                tree.unMark(node - 1);\n            }\n        }\n        cout << querySum << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nbool marked[100000];\nint prt[100000];\n\nint gm(int i) {\n  if (marked[i]) return i;\n  return prt[i] = gm(prt[i]);\n}\n\nint main() {\n  while(1) {\n    int n,q;\n    cin>>n>>q;\n    if(!n) break;\n    REP(i,n)marked[i]=false;\n    marked[0] = true;\n    REP(i,n-1) {\n      cin>>prt[i+1];\n      --prt[i+1];\n    }\n    vector<tuple<int,int>> ql;\n    REP(i,q){\n      string c;\n      int v;\n      cin>>c>>v;\n      --v;\n      if (c==\"M\") {\n        if (marked[v]) continue;\n        marked[v] = true;\n      }\n      ql.emplace_back(c==\"Q\", v);\n    }\n    reverse(begin(ql),end(ql));\n    int sum = 0;\n    REP(i,q){\n      int c,v;\n      tie(c,v) = ql[i];\n      if(c) // Q\n        sum += gm(v) + 1;\n      else\n        marked[v] = false;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<algorithm>\n#define MAXM 106\n#define MAXN 100006\n#define INF 2099999999\nusing namespace std;\nint n,m,fa[MAXN],a,caozuo[MAXN],time[MAXN];\nlong long ans;\nstruct node\n{\n    char p;\n    int a;\n}work[MAXN];\nint root(int x)\n{\n    if(fa[x]==x) return x;\n    fa[x]=root(fa[x]);\n    return fa[x];\n};\nint main()\n{\n    while(1)\n    {\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0) return 0;\n        ans=0;\n        memset(time,0,sizeof(time));\n        fa[1]=caozuo[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            scanf(\"%d\",&caozuo[i]);\n            fa[i]=caozuo[i];\n        }\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"\\n%c%d\",&work[i].p,&work[i].a);\n            if(work[i].p=='M')\n            {\n                time[work[i].a]++;\n                fa[work[i].a]=work[i].a;\n            }\n        }\n        for(int i=m;i>=1;i--)\n        {\n            if(work[i].p=='M')\n            {\n                if(work[i].a==1) continue ;\n                time[work[i].a]--;\n                if(!time[work[i].a]) fa[work[i].a]=caozuo[work[i].a];\n            }\n            else\n                ans+=root(work[i].a);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n//\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]?????????????????????v???????§?????¶????. k,a,b????£????\n\nstruct NODE {\n\tint sum;//??´??°????????????. ?????????????????§??????????????????????????¨????????????????????????????????????.\n\tint lazy;\t//?????¶???????????????????????????????????????\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inline??????????????¨??§???????????¨????????????!(??????)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum = max(seg[k].sum,seg[k].lazy);\n\tif (k < Seg_Max_N) { // 2*k(???????????????) < 2*N (???????????°) ?????????????????§. ???????????????????????????????????¬???????????¨??????.\n\t\tseg[2 * k].lazy =max(seg[2*k].lazy, seg[k].lazy);\t//?¬???????????????¬??????????????£?????????.\n\t\tseg[2 * k + 1].lazy = max(seg[2*k+1].lazy,seg[k].lazy);\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // k???????????¢?????????????????????????????¨?????????. ????????\\????????¨????????????????????????????????????????????????????????§if???????????????.\n\tseg[k].sum = max(seg[2 * k].sum , seg[2 * k + 1].sum);\n}\n\n// update(l,r,v) := [l,r]?????´??°??????. ?????????1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\tseg[k].lazy = max(seg[k].lazy,v);\n\t\tlazy_evaluate_node(k, a, b); //???????????¶???????????¨???????????¨?????????????????§.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]?????????????????¨?????????????????????. ?????????1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // ??¨?????????????????£???????????????????????????????????§?????¬?????¨???????\\?.\n\n\tif (b < l || r < a) //[a,b]??¨[l,r]???????????????????????´???\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]???[a,b]????????¨???????????§????????´???\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tint vl = get(l, r, 2 * k, a, m);\n\tint vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nvoid dfs(const int now, vector<pair<int, int>>&ps,vector<int>&ids,int&id,const vector<vector<int>>&edges) {\n\tids[now] = id;\n\tps[now].first = id;\n\tid++;\n\tfor (auto e : edges[now]) {\n\t\tdfs(e, ps, ids, id, edges);\n\t}\n\tps[now].second = id - 1;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i] = NODE();\n\t\t}\n\t\tint N, Q; cin >> N >> Q;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tedges[a - 1].push_back(i + 1);\n\t\t}\n\t\tvector<pair<int, int>>ps(N);\n\t\tvector<int>ids(N);\n\t\tint id = 0;\n\t\tdfs(0, ps, ids, id, edges);\n\t\tlong long int sum = 0;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'Q') {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tint aid = ids[a];\n\t\t\t\tint ans = get(aid, aid);\n\t\t\t\tsum += ans+1;\n\t\t\t\t//cout << ans+1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint a; cin >> a;\n\t\t\t\ta--;\n\t\t\t\tupdate(ps[a].first, ps[a].second,a);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stdio.h>\n#define MAX_N 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,bool> p;\np fa[MAX_N];\nint main(){\n    int n,q;\n    fa[1].first = 1;\n    fa[1].second = true;\n    while(~scanf(\"%d%d\",&n,&q)&&n>0){\n        int ans = 0;\n        for(int i = 2;i <= n;i++){\n            scanf(\"%lld\",&fa[i].first);\n            fa[i].second = false;\n        }\n        getchar();\n        for(int i = 0;i<q;i++){\n            char ch;int a;\n            scanf(\"%c%d\",&ch,&a);\n            getchar();\n            if(ch =='Q'){\n                while(fa[a].second==false){\n                    a = fa[a].first;\n                }\n                ans += a;\n            }\n            else{\n                fa[a].second = true;\n            }\n\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int np,bool f){\n  p[v]=np;\n  if(!f){\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],np,!m[v]);\n    }\n  }\n}\n\nvoid dfsa(int v,int pn){\n  if(!m[v]){\n    p[v]=pn;\n    for(int i=0;i<t[v].size();i++){\n      dfsa(t[v][i],pn);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    long long s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tm[v]=true;\n\tfor(int i=0;i<t[v].size();i++){\n\t  //\t  dfs(t[v][i],v,true);\n\t  dfsa(t[v][i],v);\n\t}\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else return query(t[v]);\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M') mark[v] = 1;\n      qs.push_front(make_pair(order,v));\n    }\n\n    // printf(\"asdf %d\\n\",(int)qs.size());\n    // for(int i=0; i<qs.size(); i++){\n    //    printf(\"%c %d\\n\",qs[i].first,qs[i].second);\n    // }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second] = 0;\n    \n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\nint ancestor[100000] = {}, ismarked[100000] = {}, is_doubleused[100000] = {};\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint tmp = outlog[i].second;\n\t\t\tif (outlog[i].first == 'M' && !is_doubleused[i])uf.unite(ancestor[tmp], tmp), is_doubleused[i] = true;\n\t\t\telse {\n\t\t\t\tans += (uf.getroot(tmp) + 1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false,is_doubleused[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma;\nvector <bool> ism;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (ism[x]) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N), nma.resize(N);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear(), nma.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint par[1000001];\nint rank[1000001];\nbool flag[1000001];\n\nvoid init(){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=0;\n\t\trank[i]=0;\n\t}\n\tmemset(flag,false,sizeof(flag));\n}\n\nint find(int x){\n\tif(flag[x])return x;\n\treturn find(par[x]);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&par[i]);\n\t\t}\n\t\tflag[1]=true;\n\t\tint res=0;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar s;\n\t\t\tint v;\n\t\t\tcin >> s >> v;\n\t\t\tif(s=='M'){\n\t\t\t\tflag[v]=true;\n\t\t\t}\n\t\t\tif(s=='Q'){\n\t\t\t\tres+=find(v);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nint parent[MAX_N+1];\nchar op[MAX_N+1];\nint node[MAX_N+1];\nbool marked[MAX_N+1];\n\nvoid init()\n{\n  marked[1] = true;\n  for (int i = 2; i <= N; i++)\n  {\n    marked[i] = false;\n  }\n}\n\nint find(int x)\n{\n  if (marked[x]) return x;\n  else return find(parent[x]);\n}\n\nint main()\n{\n  parent[1] = 1;\n  int ans = 0;\n\n  while(1)\n  {\n    cin >> N >> Q;\n    if (N == 0 && Q == 0)\n    {\n      printf(\"%d\\n\", ans);\n      return 0;\n    }\n    for(int i=2; i<=N; i++)\n    {\n      scanf(\"%d\", &parent[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n      cin >> op[i] >> node[i];\n    }\n\n    init();\n\n    for(int i = 0; i < Q; i++)\n    {\n      switch (op[i]) {\n      case 'Q':\n        ans += find(node[i]);\n        break;\n      case 'M':\n        marked[node[i]] = true;\n        break;\n      default:\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct UnionFind {\n\tvector<int> parent;\n\tint size;\n\tUnionFind(int n) :parent(n, -1), size(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y)return false;\n\t\tif (sizeOf(x) < sizeOf(y))swap(x, y);\n\t\tparent[x] += parent[y]; parent[y] = x; size--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n\tint sizeOf(int x) { return -parent[root(x)]; }\n};\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, Q; cin >> N >> Q;\n\tvector<int> p(N); rep(i, 1, N) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<char> c(Q);\n\tvector<int> a(Q);\n\tvector<bool> mark(N);\n\tmark[0] = true;\n\trep(i, 0, Q) {\n\t\tcin >> c[i] >> a[i];\n\t\ta[i]--;\n\t\tif (c[i] == 'M')mark[a[i]] = true;\n\t}\n\tdump(mark);\n\tUnionFind uf(N);\n\tvector<int> anc(N);\n\tiota(all(anc), 0);\n\trep(i, 0, N) {\n\t\tif (!mark[i]) {\n\t\t\tint t = anc[uf.root(p[i])];\n\t\t\tuf.unite(i, p[i]);\n\t\t\tanc[uf.root(i)] = t;\n\t\t}\n\t}\n\tint ans = 0;\n\trrep(i, 0, Q) {\n\t\tif (c[i] == 'Q')\n\t\t\tans += anc[uf.root(a[i])] + 1;\n\t\telse {\n\t\t\tint t = anc[uf.root(p[a[i]])];\n\t\t\tuf.unite(a[i], p[a[i]]);\n\t\t\tanc[uf.root(a[i])] = t;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\tlong long ans;\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tans=0;\n\t\tSet[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=1LL*Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct BIT{\n\tvector<ll> dat;\n\tint n;\n\n\tBIT(int _n){\n\t\tdat = vector<ll>(n = _n);\n\t}\n\n\tvoid add(int x, ll val){\n\t\tfor (int i = x; i < n; i += i&-i) dat[i] += val;\n\t}\n\tint sum(int x){\n\t\tll s = 0;\n\t\tfor (int i = x; i > 0; i -= i&-i) s += dat[i];\n\t\treturn s;\n\t}\n};\n\nconst int N = 1e5 + 10;\n\nvector<int> G[N];\n\nint idx[N][2];\n\nvoid dfs(){\n\tint i = 1;\n\tstack<int> st;\n\tst.push(0);\n\twhile (!st.empty()){\n\t\tint v = st.top();\n\t\tif (idx[v][0] < 0){\n\t\t\tidx[v][0] = i++;\n\t\t\tfor (auto nxt : G[v]){\n\t\t\t\tst.push(nxt);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tidx[v][1] = i++;\n\t\t\tst.pop();\n\t\t}\n\t}\n}\n\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n){\n\t\trep(i, N) G[i].clear();\n\t\tFOR(i, 1, n){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p - 1].push_back(i);\n\t\t}\n\t\tMEMSET(idx, -1);\n\t\tdfs();\n\n\t\tBIT bit(n * 2 + 10);\n\n\t\tll ans = 0;\n\t\twhile (q--){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif (c == 'Q'){\n\t\t\t\t++ans;\n\t\t\t\tans += bit.sum(idx[v][0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// [idx[v][0], idx[v][1]] => v\n\t\t\t\tll x = bit.sum(idx[v][0]);\n\t\t\t\tbit.add(idx[v][0], -x + v);\n\t\t\t\tbit.add(idx[v][1] + 1, x - v);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t\t//rep(i, n){\n\t\t//\tcout << bit.sum(idx[i][0]) << endl;\n\t\t//\t//cout << idx[i][0] << ' ' << idx[i][1] << endl;\n\t\t//}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair<char,int>\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    stack<pair<char,int> > qu;\n    \n    UF(int n):par(2*n),rank(2*n)\n    {\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x=0)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     par[c[x][i]]=x;\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) break;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    int n,q;\n    cin>>n>>q;\n    Uf uf(n);\n    for(int i=1;i<n;i++)\n    {\n        int p;\n        cin>>p;\n        (uf.c[p]).push_back(i);\n    }\n    for(int i=0;i<q;i++)\n    {\n        char temp;\n        int v;\n        cin>>temp>>v;\n        (uf.qu).push(P(temp,v-1));\n        if(temp=='M') uf.m[v-1]=true;\n    }\n    int a,b;\n    cin>>a>>b;\n    uf.furiwake(0);\n    \n    ll ans=0;\n    for(int i=0;i<q;i++)\n    {\n        pair<char,int> a=qu.top();\n        qu.pop();\n        if(a.first=='Q')\n        {\n            ans+=uf.score(a.second);\n        }\n        else\n        {\n            uf.delmark(a.second);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n,q;\nint tree[100050];\n\nint Find(int x)\n{\n    if(tree[x]==x)\n        return x;\n    return Find(tree[x]);\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&n,&q)==2)\n    {\n        if(n==0&&q==0)\n            break;\n        tree[1]=1;\n        for(int i=2;i<=n;i++)\n            scanf(\"%d\",&tree[i]);\n        getchar();\n        long long ans=0;\n        for(int i=1;i<=q;i++)\n        {\n            int temp;\n            char s[100];\n            gets(s);\n            sscanf(&s[2],\"%d\",&temp);\n            if(s[0]=='M')\n                tree[temp]=temp;\n            else if(s[0]=='Q')\n                ans+=Find(temp);\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n}\n\nvoid solve() {\n    int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nvector<int> G[100000],euler;\nint dbl[100000][18],ff[200000],ss[200000],bit[200001],n,q;\nint sum(int i){\n\tint s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-= i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,int x){\n\twhile(i<=2*n){\n\t\tbit[i]+=x;\n\t\ti+= i&-i;\n\t}\n}\nvoid dfs(int v){\n\tff[v]=euler.size();\n\teuler.push_back(v);\n\trep(i,G[v].size()) dfs(G[v][i]);\n\tss[v]=euler.size();\n\teuler.push_back(v);\n}\nint main(){\n\twhile(true){\n\t\tcin >> n >> q;\n\t\tif(n==0) break;\n\t\teuler.clear();\n\t\trep(i,n) G[i].clear();\n\t\trep(i,n) rep(j,18) dbl[i][j]=-1;\n\t\trep(i,2*n+1) bit[i]=0;\n\t\trep(i,n-1){\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tG[p-1].push_back(i+1);\n\t\t\tdbl[i+1][0]=p-1;\n\t\t}\n\t\trep(i,17){\n\t\t\trep(j,n){\n\t\t\t\tif(dbl[j][i]==-1) dbl[j][i+1]=-1;\n\t\t\t\telse dbl[j][i+1]=dbl[dbl[j][i]][i];\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tadd(ff[0]+1,1);\n\t\tadd(ss[0]+1,-1);\n\t\tint ans=0;\n\t\trep(i,q){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tv--;\n\t\t\tif(c=='M'){\n\t\t\t\tadd(ff[v]+1,1);\n\t\t\t\tadd(ss[v]+1,-1);\n\t\t\t}else{\n\t\t\t\tv=dbl[v][0];\n\t\t\t\tint x=sum(ff[v]+1);\n\t\t\t\tfor(int j=17;j>=0;j--){\n\t\t\t\t\tif(dbl[v][j]!=-1 && sum(ff[dbl[v][j]]+1)>=x) v=dbl[v][j];\n\t\t\t\t}\n\t\t\t\tans+=(v+1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, Graph& revg, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        g.addEdge(s, to);\n        revg.addEdge(to, s);\n        make_dfs(to, g_, g, revg, visited);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        for (int i = 0; i < N - 1; i++) {\n            int to;\n            cin >> to;\n            to--;\n            g_.addEdge(to, i);\n            g_.addEdge(i, to);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        Graph revg(N);\n        make_dfs(0, g_, g, revg, visited);\n\n        using P = pair<char, int>;\n        vector<P> query;\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = 0;\n        }\n        vector<bool> drawn(N, false);\n        drawn[0] = true;\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            if (c == 'M') {\n                if (drawn[n]) {\n                    continue;\n                }\n                drawn[n] = true;\n                comp[n] = n;\n                marked[n] = true;\n            }\n            query.push_back(make_pair(c, n));\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        int sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n\n                const int s = q.second;\n                const int par = revg.edge[s][0];\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nint n, q;\nint p[100005];\nvector<int> G[100005];\nchar c[100005]; int v[100005];\nbool mark[100005];\nUnionFind uf(100005);\n\nvoid dfs(int v)\n{\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!mark[G[v][i]]) uf.unite(G[v][i], v);\n\t\tdfs(G[v][i]);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> q;\n\t\tif(n == 0 && q == 0) break;\n\t\t\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> p[i];\n\t\t\tG[p[i]].push_back(i);\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c[i] >> v[i];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) mark[i] = false;\n\t\tmark[1] = true;\n\t\t\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'M') mark[v[i]] = true;\n\t\t}\n\t\tuf.init();\n\t\tdfs(1);\n\t\t\n\t\treverse(c, c+q);\n\t\treverse(v, v+q);\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tif(c[i] == 'Q') ans += uf.root(v[i]);\n\t\t\telse uf.unite(v[i], p[v[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct node{\n    int id;\n    node* parent;\n    int h;\n    vector<node*> child;\n};\nint main(){\n    int n,q,p;\n    while(cin>>n>>q,n){\n        vector<node*>vec;\n        vector<node*>marked;\n        node* no=new node;\n        no->id=1;\n        no->parent=no;\n        no->h=1;\n        vec.push_back(no);\n        marked.push_back(no);\n        for(int i=2;i<=n;i++){\n            cin>>p;\n            node* no=new node;\n            no->id=i;\n            no->parent=vec[p-1];\n            no->h=no->parent->h+1;\n            vec[p-1]->child.push_back(no);\n            vec.push_back(no);\n        }\n//        for(int i=0;i<vec.size();i++){\n//            cout<<\"id: \"<<vec[i]->id<<\"  h:\"<<vec[i]->h<<\"   parent:\"<<vec[i]->parent->id<<\"     child:\";\n//            for(int j=0;j<vec[i]->child.size();j++){\n//                cout<<vec[i]->child[j]->id<<\" \";\n//            }\n//            cout<<endl;\n//        }\n        int ans=0;\n        for(int i=0;i<q;i++){\n            char que;int num;\n            cin>>que>>num;\n            if(que=='M'){\n                marked.push_back(vec[num-1]);\n            }\n            else{\n                node* pa=vec[num-1]->parent;\n                int found=0;\n                while(true){\n                    int ma=0;\n                    for(int j=0;j<marked.size();j++){\n                        if(marked[j]->id==pa->id){\n                            ma=max(ma,pa->id);\n                            found=1;\n                        }\n                    }\n                    if(found){\n                        ans+=ma;\n                        goto next;\n                    }\n                    if(pa->id==1){\n                        goto next;\n                    }\n                    pa=vec[pa->id]->parent;\n                }\n                \n            next:;\n                \n            }\n            \n        }\n        cout<<ans<<endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\nstruct node {\n\tint id;\n\tint nearmark;\n\tint dis;\n\tvector<int>edges;\n};\nstruct aa{\n\tint id;\n\tint dis;\n};\n\n\nvector<node>nodes;\nvector<aa>aas;\nvoid dfs(const int nowid,const int nowdis,const int mark) {\n\tif (nodes[nowid].dis > nowdis) {\n\t\tnodes[nowid].dis = nowdis;\n\t\tnodes[nowid].nearmark = mark;\n\t\tfor (auto nextid : nodes[nowid].edges) {\n\t\t\t//dfs(nextid, nowdis + 1, mark);\n\t\t\taas.push_back(aa{ nextid,nowdis + 1 });\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tnodes.push_back( node{0,0,0,vector<int>() });\n\tfor (int i = 1; i < N; ++i) {\n\t\tint a; cin >> a; a--;\n\t\tnode anode{ i,nodes[a].nearmark,nodes[a].dis + 1,vector<int>{a} };\n\t\tnodes.push_back(anode);\n\t\tnodes[a].edges.push_back(i);\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tchar c; cin >> c;\n\t\tint n; cin >> n;\n\t\tn--;\n\t\tif (c == 'Q') {\n\t\t\tans += nodes[n].nearmark+1;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t}\n\t}\n\tint a, bb; cin >> a >> bb;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint size = 0, value[100000], parent[100000];\nbool ignore[100000], is_mark[100000], is_root[100000];\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\n\t\tif(x > y)\n\t\t\tswap(x, y);\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\ninline void push(int x) {\n\tvalue[size++] = x;\n}\n\ninline int pop() {\n\treturn value[--size];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tcin >> parent[i];\n\t\t\t--parent[i];\n\t\t}\n\n\t\tmemset(is_root, false, sizeof(is_root));\n\t\tmemset(ignore, false, sizeof(ignore));\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tpush(--v);\n\t\t\tif(ope == 'Q')\n\t\t\t\tis_mark[i] = false;\n\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tif(is_root[v])\n\t\t\t\t\tignore[i] = true;\n\t\t\t\telse\n\t\t\t\t\tis_root[v] = true;\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 1; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tlong long ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tint v = pop();\n\n\t\t\tif(is_mark[i] && !ignore[i])\n\t\t\t\tuf.unite(v, parent[v]);\n\t\t\telse\n\t\t\t\tans += uf.find(v) + 1;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define ll long long\nint q, n, v;\nchar c;\nint p[100005];\nbool m[100005];\nint main() {\n    while ((~scanf(\"%d %d\", &n, &q)) && q && n) {\n        for (int i = 1; i <= n; ++i) scanf(\"%d\", &p[i]);\n        memset(m, 0, sizeof m);\n        m[1] = true;\n        ll ans = 0;\n        for (int i = 0; i < q; ++i) {\n            scanf(\"\\n%c %d\", &c, &v);\n            if (c == 'M')m[v] = true;\n            else {\n                while (!m[v]) v = p[v];\n                ans += v;\n                //printf(\"%d**\\n\", v);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int np){\n  p[v]=np;\n  if(!m[v]){\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],np);\n    }\n  }\n}\n\nvoid dfsa(int v,int pn){\n  if(!m[v]){\n    p[v]=pn;\n    for(int i=0;i<t[v].size();i++){\n      dfsa(t[v][i],pn);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    long long s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tm[v]=true;\n\tp[v]=v;\n\tfor(int i=0;i<t[v].size();i++){\n\t  dfs(t[v][i],v);\n\t  //\t  dfsa(t[v][i],v);\n\t}\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\tll mini=buf.query(0,(int)checked[pos][i]);\n\t\tif(mini>0) ret[checked[pos][i]-1]=idx_rev[mini]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<char, int>;\n\nint root(int x, vector<int>& par, vector<int> const& cnt) {\n    if(cnt[x] > 0) {\n        return x;\n    }\n    return par[x] = root(par[x], par, cnt);\n}\n\nint main() {\n    int N, Q;\n    while(cin >> N >> Q, N) {\n        vector<int> parent(N);\n        for(int i=1; i<N; ++i) {\n            int p;\n            cin >> p;\n            p--;\n            parent[i] = p;\n        }\n        vector<P> query(Q);\n        vector<int> m_cnt(N);  \n        m_cnt[0] = 1;\n        for(int i=0; i<Q; ++i) {\n            cin >> query[i].first >> query[i].second;\n            query[i].second--;\n            if(query[i].first == 'M') {\n                m_cnt[query[i].second]++;\n            }\n        }\n        reverse(query.begin(), query.end());\n        long long res = 0;\n        for(auto& q : query) {\n            if(q.first == 'Q') {\n                res += root(q.second, parent, m_cnt) + 1;\n            } else {\n                m_cnt[q.second]--;\n            }\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\nconst int B = 450;\n\nint N, Q;\nstd::vector<int> G[100100];\nint start[100100], friends[100100];\nint buckets[450], parts[200200];\nint doubling[17][100100];\nbool marked[100100];\n\nvoid makeDoubling(){\n    for(int i=0;i+1<=16;++i){\n        for(int j=1;j<=N;++j){\n            if(doubling[i][j] == -1){\n                doubling[i+1][j] = -1;\n            }else{\n                doubling[i+1][j] = doubling[i][doubling[i][j]];\n            }\n        }\n    }\n}\n\nvoid dfs(int v, int& n){\n    start[v] = n++;\n    \n    for(int u : G[v]){\n        dfs(u, n);\n    }\n\n    friends[v] = n++;\n}\n\nvoid update(int l, int r){\n    while(l % B > 0){\n        ++parts[l];\n        ++l;\n    }\n\n    while(r % B > 0){\n        --r;\n        ++parts[r];\n    }\n\n    l /= B;\n    r /= B;\n\n    while(l < r){\n        ++buckets[l];\n        ++l;\n    }\n}\n\ninline int query2(int v){\n    return buckets[start[v] / B] + parts[start[v]];\n}\n\nint query(int v){\n    int lb = 0, ub = 100100, res;\n    int target = marked[v] ? query2(v) - 1 : query2(v);\n    \n    while(std::abs(ub - lb) > 1){\n        int mid = (lb + ub) / 2;\n        int x = v, y = mid, z = 0;\n\n        while(y > 0){\n            if(x != -1 && y % 2 == 1){\n                x = doubling[z][x];\n            }\n            ++z;\n            y >>= 1;\n        }\n        \n        if(x != -1 && query2(x) >= target){\n            lb = mid;\n            res = x;\n        }else{\n            ub = mid;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> N >> Q;\n        if(N == 0){return 0;}\n\n        memset(doubling[0], -1, sizeof(doubling[0]));\n\n        for(int i=1;i<=N;++i){\n            G[i].clear();\n        }\n        \n        for(int i=0;i<N-1;++i){\n            int p;\n            std::cin >> p;\n\n            G[p].emplace_back(i+2);\n            doubling[0][i+2] = p;\n        }\n\n        makeDoubling();\n\n        // for(int i=0;i<16;++i){\n        //     printf(\"# %d\\n\", i);\n        //     for(int j=1;j<=N;++j){\n        //         printf(\"%d\\n\", doubling[i][j]);            \n        //     }\n        // }\n    \n        int ET_N = 0;\n        dfs(1, ET_N);\n\n        memset(buckets, 0, sizeof(buckets));\n        memset(parts, 0, sizeof(parts));\n        \n        update(start[1], friends[1]);\n    \n        // {\n        // int v = 3;\n        // update(start[v], friends[v]);\n        // }    \n        // for(int v = 1;v<=N;++v){\n        //     int q = query(v);\n        //     printf(\"%d\\n\", q);\n        // }\n        // exit(0);\n\n        ll sum = 0;\n        for(int i=0;i<Q;++i){\n            std::string q;\n            int v;\n            std::cin >> q >> v;\n\n            if(q[0] == 'M'){\n                update(start[v], friends[v]);\n                marked[v] = true;\n            }else{\n                sum += query(v);\n                // printf(\"%d\\n\", query(v));\n            }\n        }\n\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    lowmark[0]=1;\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n\tcontinue;\n      }\n      if(cmd=='Q'){\n\tint nex=v;\n\tbool ressed=false;\n\tfor(int i=0;i<2*r+3 && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(int i=0;i<2*r;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int MAX_N=100001;\nvector<int>edge[MAX_N];\nvector<int>id[MAX_N];\nstruct S{int n,i;S(int n,int i):n(n),i(i){}};\n\nint main()\n{\n\tint N,Q,x,i,t;\n\tchar c;\n\tlong long res;\n\ttypedef map<int,int>M;\n\tM m;\n\tM::iterator ite;\n\tvector<S>v;\n\tv.reserve(MAX_N*2);\n\twhile(scanf(\"%d%d\",&N,&Q),N)\n\t{\n\t\tm.clear();\n\t\tfor(i=1;i<=N;++i)edge[i].clear(),id[i].clear();\n\t\tfor(i=2;i<=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tedge[x].push_back(i);\n\t\t}\n\t\tv.push_back(S(1,0));\n\t\tfor(t=1;!v.empty();)\n\t\t{\n\t\t\tS&s(v.back());\n\t\t\tid[s.n].push_back(t++);\n\t\t\tif(s.i<edge[s.n].size())\n\t\t\t\tv.push_back(S(edge[s.n][s.i++],0));\n\t\t\telse\n\t\t\t\tv.pop_back();\n\t\t}\n\n\t\tm[1]=1;\n\t\tm[N*2]=-1;\n\t\tres=0;\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c-'Q')\n\t\t\t{\n\t\t\t\tite=m.lower_bound(id[x][0]);\n\t\t\t\tif(ite->second==x)continue;\n\t\t\t\tt=(--ite)->second;\n\t\t\t\tfor(i=0;i<id[x].size();++i)\n\t\t\t\t\tm[id[x][i]]=x;\n\t\t\t\tm[id[x].back()+1]=t;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tite=m.upper_bound(id[x][0]-1);\n\t\t\t\tres+=(--ite)->second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define MAX_N 100000\nint par[MAX_N + 1];\nbool check[MAX_N + 1];\n\nvoid init(int n){\n\tcheck[1] = true;\n\tfor(int i = 2; i <= n; i++) check[i] = false;\n}\n\nvoid mark(int n){\n\tcheck[n] = true;\n}\n\nint search(int n){\n\tif(check[n]){\n\t\treturn n;\n\t}\n\telse{\n\t\treturn search(par[n]);\n\t}\n}\n\nint main(){\n\tint N, Q;\n\tchar order[5];\n\tint v;\n\tint ans;\n\t\n\twhile(true){\n\t\tscanf(\"%d%d\", &N, &Q);\n\t\t\n\t\tif(N == 0 && Q == 0) break;\n\t\t\n\t\tinit(N);\n\t\t\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\", &v);\n\t\t\tpar[i] = v;\n\t\t}\n\t\t\n\t\tans = 0;\n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tscanf(\"%s %d\", order, &v);\n\t\t\t\n\t\t\tif(order[0] == 'M'){\n\t\t\t\tmark(v);\n\t\t\t}\n\t\t\telse if(order[0] == 'Q'){\n\t\t\t\tans += search(v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint edge[100001];\nvector<int> G[100001];\nint par[100001];\nint flag[100001];\nchar s[100001];\nint v[100001];\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tpar[i]=i;\n\t\tG[i].clear();\n\t}\n\tmemset(flag,0,sizeof(flag));\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tpar[x]=y;\n\t}\n\n}\n\nvoid unite_dfs(int v,int p){\n\tif(flag[v]==0)unite(v,p);\n\telse p=v;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tunite_dfs(G[v][i],p);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&edge[i]);\n\t\t\tG[edge[i]].push_back(i);\n\t\t}\n\t\tflag[1]++;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tcin >> s[i] >> v[i];\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]++;\n\t\t\t}\n\t\t}\n\t\tunite_dfs(1,1);\n\t\tlong long res=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(s[i]=='Q'){\n\t\t\t\tres+=(long long)find(v[i]);\n\t\t\t}\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]--;\n\t\t\t\tif(flag[v[i]]==0)unite(v[i],edge[v[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <ctime>\nusing namespace std ;\n#define SET(arr, what)  memset(arr, what, sizeof(arr))\n#define FF(i, s, e)     for(int i=s; i<e; i++)\n#define SD(a)           scanf(\"%d\", &a)\n#define SSD(a, b)       scanf(\"%d%d\", &a, &b)\n#define SF(a)           scanf(\"%lf\", &a)\n#define SS(a)           scanf(\"%s\", a)\n#define SLD(a)          scanf(\"%lld\", &a)\n#define PF(a)           printf(\"%d\\n\", a)\n#define PPF(a, b)       printf(\"%d %d\\n\", a, b)\n#define SZ(arr)         (int)arr.size()\n#define SWAP(a,b)       a=a xor b;b= a xor b;a=a xor b;\n#define READ            freopen(\"in.txt\", \"r\", stdin)\n#define WRITE           freopen(\"fracdec.out\", \"w\", stdout)\n#define SYNCOFF         std::ios_base::sync_with_stdio(false);\n#define MAX             1<<30\n#define ESP             1e-5\n#define lson            l, m, rt<<1\n#define rson            m+1, r, rt<<1|1\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline void AMin(T &a,T b){if(a>b)a=b;}\ntemplate<class T> inline void AMax(T &a,T b){if(a<b)a=b;}\ntemplate<class T> inline T Min(T a,T b){return a>b?b:a;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\n\nint t[1100000],flag[1100000],idx[1100000];\nchar query[1100000];\nint n,q;\n\n\nint find(int n)\n{\n    //if(n == 0)\n//\tint m = 1;\n    \n    if(flag[t[n]] == 1)\n    {\n\treturn t[n];\t    \n    }\n\n    else\n    {\t\n\treturn t[n] = find(t[n]);    \n    }\n\t\n    \n\n//    int node = n;\n    //while(flag[t[node]] != 1 )\n//\t{\n//\t    node = t[node];\n//\t}\n//    return t[node];\n}\n\nint main(int argc,char* argv[])\n{\n//#ifndef ONLINE_JUDGE\n//    READ;\n//#endif\n    SYNCOFF;\n    while( (std::cin>>n>>q) && !(n==0&&q==0))\n    {\n\tint root,tmp;\n\tlong long ret = 0;\n\tchar chs[100],ch;\n\tmemset(flag,0,sizeof(flag));\n\tt[1] = 1;\n\tflag[1] = 1;\n\tfor(int i = 2 ; i <= n ; i++)\n\t{\n\t    std::cin >> root;\n\t    t[i] = root;\n\t}\n\n\tfor(int i = 0 ; i < q ; i++)\n\t{\n\t    cin.getline(chs,100);\n\t    ch = cin.get();\n\t    cin>>tmp;\n\n\t    query[i] = ch;\n\t    idx[i] = tmp;\n\t    \n\t    //if(ch == 'M')\n\t    //\tflag[tmp] = 1;\n\t    //if(ch == 'Q')\n\t    //\tret = ret + find(tmp);\n\t}\n\n\tfor(int i = q - 1 ; i >= 0; i--)\n\t{\n\t    if(query[i] == 'M' )  flag[idx[i]] = 1;\n\t}\n\n\tfor(int i = q - 1; i >= 0 ; i--)\n\t{\n\t    if(query[i] == 'M' && idx[i] != 1 ) flag[idx[i]] = 0;\n\t    else ret = ret + find(idx[i]);\n\t    //std::cout<<idx[i]<<std::endl;\n\t    //if(idx[i] == 0)\n\t    //int m = 1;\n\t}\n\t\n\tstd::cout<< ret <<std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>p[i];\n    marked[1]=true;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tif(marked[t[i]]) c[i]='E';\n\tmarked[t[i]]=true;\n      }\n    }\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M') marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nint ancestor[100000] = {}, ismarked[100000] = {}, is_doubleused[100000] = {};\nvector<P> outlog;\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tchar c;\n\t\t\tint a;\n\t\t\tcin >> c >> a;\n\t\t\ta--;\n\t\t\tif (c == 'M' && !is_doubleused[a]) {\n\t\t\t\tismarked[a] = true;\n\t\t\t\tis_doubleused[a] = true;\n\t\t\t\toutlog.push_back(make_pair(c, a));\n\t\t\t}\n\t\t\telse if(c == 'Q') {\n\t\t\t\toutlog.push_back(make_pair(c, a));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = outlog.size() - 1; i >= 0; i--) {\n\t\t\tint tmp = outlog[i].second;\n\t\t\tif (outlog[i].first == 'M')uf.unite(ancestor[tmp], tmp);\n\t\t\telse {\n\t\t\t\tans += (uf.getroot(tmp) + 1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false,is_doubleused[i] = false;\n\t\toutlog.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\nint f[100010],sum[100010],v[100010];\n\nint father(int x)\n{\n\tif (f[x]==x) return x;\n\tif (sum[x]==sum[f[x]]) return f[x];\n\tf[x]=father(v[x]);\n\tsum[x]=sum[f[x]]; \n\treturn f[x];\n}\n\nint main()\n{\n\tint t,n,m,i,x;\n\tchar op;\n\twhile (scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tf[1]=1; sum[1]=0;\n\t\tfor (i=2;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x);\n\t\t\tv[i]=x;\n\t\t\tf[i]=1;\n\t\t\tsum[i]=0;\n\t\t}\n\t\tint s=0;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tgetchar();\n\t\t\tscanf(\"%c%d\",&op,&x);\n\t\t\tif (op=='M')\n\t\t\t{\n\t\t\t\tsum[father(x)]++;\n\t\t\t\tf[x]=x;\n\t\t\t}\n\t\t\telse s+=father(x); \n\t\t}\n\t\tcout<<s<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 100100;\npair<char, int> query[MAXN];\n\nint par[MAXN], cnt[MAXN];\n\nint getPar(int v) {\n    if (cnt[v]) return v;\n    else return par[v] = getPar(par[v]);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, Q;\n    while (cin >> N >> Q) {\n        if (N==0 && Q==0) break;\n        memset(par, -1, sizeof(par));\n        memset(cnt, 0, sizeof(cnt));\n        for (int i = 1; i < N; i++) {\n            int p;\n            cin >> p; p--;\n            par[i] = p;\n        }\n        cnt[0] = 1;\n        for (int i = 0; i < Q; i++) {\n            cin >> query[i].first >> query[i].second;\n            query[i].second--;\n            if (query[i].first == 'M') {\n                cnt[query[i].second]++;\n            }\n        }\n        ll ans = 0;\n        for (int i = Q-1; i >= 0; i--) {\n            char c = query[i].first;\n            int v = query[i].second;\n            if (c == 'M') cnt[v]--;\n            else ans += getPar(v)+1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<stack>\n#include<vector>\n#include<cstdio>\n#define MAXN 2555\n#define INF 0x3f3f3f3f\n#define v first\n#define b second\nusing namespace std;\nint p[100005];\nbool vis[100005];\nint sum;\nint Find(int x)\n{\n   if(p[x]==x)\n      return x;\n   else return p[x]=Find(p[x]);\n}\nint Find2(int x)\n{\n   if(vis[p[x]])\n      sum+=p[x];\n   if(p[x]==x)\n      return x;\n   else return p[x]=Find2(p[x]);\n}\nvoid init(int n)\n{\n   memset(vis,false,sizeof(vis));\n   for(int i=1;i<=n;i++)\n      p[i]=i;\n}\nint main()\n{\n   int n,m;\n   while(scanf(\"%d%d\",&n,&m)==2)\n   {\n      if(n==m&&n==0)\n         break;\n      init(n);\n      vis[1]=true;\n      for(int i=2;i<=n;i++)\n      {\n         int a;\n         scanf(\"%d\",&a);\n         int x=Find(i);\n         p[x]=a;\n      }\n      sum=0;\n      for(int i=0;i<m;i++)\n      {\n         char a[5];int b;\n         scanf(\"%s %d\",a,&b);\n         if(a[0]=='M') vis[b]=true;\n         if(a[0]=='Q')\n         Find2(b);\n      }\n      cout<<sum<<endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par;\n\tUF() { par = vector<int>(um, 0); rep(i, 0, um) par[i] = i; }\n\tint operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n\tvoid operator()(int x, int y)\n\t{\n\t\tx = operator[](x); y = operator[](y); if (x != y) par[x] = y;\n\t}\n};\n\nint N, Q;\nvector<int> E[101010];\nint P[101010];\n\nchar O[101010];\nint V[101010];\n\nbool marked[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> Q)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) E[i].clear();\n\t\trep(i, 0, N) marked[i] = false;\n\n\t\tP[0] = -1;\n\t\trep(i, 1, N)\n\t\t{\n\t\t\tint p; cin >> p; p--;\n\t\t\tP[i] = p;\n\t\t\tE[i].push_back(p);\n\t\t\tE[p].push_back(i);\n\t\t}\n\n\t\tmarked[0] = true;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> O[i] >> V[i];\n\t\t\tV[i]--;\n\t\t\tif(O[i] == 'M') marked[V[i]] = true;\n\t\t}\n\t\t\n\t\tUF<101010> uf;\n\t\trep(i, 0, Q) if (marked[i])\n\t\t{\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tuf(q, i);\n\n\t\t\t\tfor (int to : E[q]) if (to != P[q]) if (!marked[to])\n\t\t\t\t{\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\n\t\tll ans = 0;\n\t\trrep(i, Q - 1, 0)\n\t\t{\n\t\t\tint v = V[i];\n\t\t\tif (O[i] == 'M')\n\t\t\t{\n\t\t\t\tif (P[v] < 0) continue;\n\t\t\t\t//printf(\"[%d, %d]\\n\", P[v], v);\n\t\t\t\tuf(v, P[v]);\n\n\t\t\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (ll)uf[V[i]] + 1;\n\t\t\t\t//cout << uf[V[i]] << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long \nusing namespace std;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\nconst int MAX_V = 100010;\nint n, q;\nvector<int> G[MAX_V]; \n\nstruct BIT{\n    int N;\n    vector<int> dat;\n    BIT() {}\n    BIT(int n) {\n        N = n;\n        dat.resize(N + 1);\n    }\n    // update k th element (0-index)\n    void add(int k, int x){\n        k++;\n        while(k <= N){\n            dat[k] += x;\n            k += k&-k;\n        }\n    }\n    // sum [0, k) (0-index)\n    int sum(int k){\n        int s = 0;\n        while(k > 0){\n            s += dat[k];\n            k -= k&-k;\n        }\n        return s;\n    }\n    // sum [a, b) (0-index)\n    int query(int a, int b){\n        return sum(b) - sum(a);\n    }\n};\n\nclass Euler_Tour{\npublic:\n    // vector<vector<int> > g;\n    //begin[v],end[v]はそれぞれvがオイラーツアー上で最初と最後に現れるインデックス\n    //[begin[v], end[v])がvを根とする部分木 (半開区間に注意)\n    vector<int> euler_tour, begin, end, dist;\n    Euler_Tour(int n) : /*g(n),*/ begin(2 * n), end(2 * n){};\n    int k = 0, root = 0;\n    void dfs(int curr, int par){\n        begin[curr] = k;\n        euler_tour.push_back(curr);\n        k++;\n        for(auto next : G[curr]){\n            if(next == par) continue;\n            dfs(next, curr);\n            euler_tour.push_back(curr);\n            k++;\n        }\n        end[curr] = k;\n    }\n};\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> q;\n        if(n + q == 0) break;\n        rep(i, 0, n) G[i].clear();\n        rep(i, 1, n){\n            int v;\n            cin >> v;\n            v--;\n            G[v].push_back(i);\n            G[i].push_back(v);\n        }\n        Euler_Tour et(n);\n        et.dfs(0, -1);\n        q++;\n        vector<pair<char, int> > qr(q);\n        qr[0] = {'M', 0};\n        rep(i, 1, q){\n            cin >> qr[i].first >> qr[i].second;\n            qr[i].second--;\n        } \n        BIT bt(2 * n), bt2(2 * n);\n        vector<bool> use(q); \n        rep(i, 0, q){\n            if(qr[i].first == 'Q') continue;\n            int v = qr[i].second;\n            int tmp = bt.query(et.begin[v], et.end[v]);\n            if(tmp == 0) use[i] = true;\n            bt.add(et.begin[v], 1);\n        }\n        int ans = 0;\n        for(int i = q - 1; i >= 0; i--){\n            int v = qr[i].second;\n            if(qr[i].first == 'Q'){\n                bt2.add(et.begin[v], 1);\n            }else{\n                if(use[i] == false) continue;\n                int tmp = bt2.query(et.begin[v], et.end[v]);\n                // cout << i << ' ' << tmp << \" \" << v << endl;\n                bt2.add(et.begin[v], -tmp);\n                ans += tmp * (v + 1);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) data[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF, mx = 0;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t\tmx = max(mx, res);\n\t}\n\t\n\tranges[v] = pii(mn, mx);\n\t\n\t++d;\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i + 2);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#define mem(name,value) memset(name,value,sizeof(name))\n#define loop(i,from,to) for(int i=from;i<to;i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn=100000+5;\nint par[maxn],n,q,v;\nchar op;\nbool marked[maxn];\nll ans;\n\nvoid init(int N)\n{\n    loop(i,0,N)\n        par[i]=i;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&n,&q)!=EOF){\n        if(n==0 && q==0) break;\n        init(n+1);\n        mem(marked,false);\n        marked[1]=true;\n        ans=0;\n        loop(i,2,n+1)\n            scanf(\"%d\",&par[i]);\n        loop(i,0,q){\n            getchar();\n            scanf(\"%c%d\",&op,&v);\n            if(op=='M') marked[v]=true;\n            if(op=='Q'){\n                while(!marked[v]) v=par[v];\n                ans+=v;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tvi T(n);\n\t\tvi m(n);\n\t\tvi mv(n);\n\t\tiota(ALL(mv), 0);\n\t\tm[0] = 1;\n\t\trep1(i, n - 1)cin >> T[i], T[i]--;\n\t\tvpii a(q);\n\t\tunionfind uf(n);\n\t\tll ans = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')m[v - 1] = 1;\n\t\t\ta[i] = { c,v };\n\t\t}\n\t\trrep(i, q) {\n\t\t\tif (a[i].first == 'M')m[a[i].second - 1] = 0;\n\t\t\telse {\n\t\t\t\tint v = a[i].second - 1;\n\t\t\t\twhile (!m[v = mv[uf.find(v)]])uf.unite(v, T[v]), mv[uf.find(v)] = T[v];\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> children[100010];\npriority_queue<int> query[100010];\nint markedAt[100010];\nint ans[100010];\n\nvoid pull(int v) {\n    for (int c : children[v]) {\n        pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            query[v].push(query[c].top());\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        ans[query[v].top()] = v;\n        query[v].pop();\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(query, query + n, priority_queue<int>());\n        fill(markedAt, markedAt+n, 1e9);\n        fill(ans, ans + q, -1);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        pull(0);\n        long long sum = 0;\n        for (int i = 0; i < q; ++i) {\n            if (ans[i] != -1) {\n                sum += ans[i] + 1;\n            }\n        }\n        cout << sum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n#define inf 0x7f7f7f7f\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c;\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = nn = 1; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'M' && mark[x] > i)\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i = nn - 1, sum = 0; i >= 1; i--)\n\t\t{\n\t\t\ttt = qt[i];\n\t\t\tsum += find(qx[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nclass UF{\n\tvector<int> par, rank;\npublic:\n\tUF(int n): par(n + 1), rank(n + 1) {\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn x != par[x] ? par[x] = find(par[x]) : x;\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x != y){\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\t++rank[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint par[100001], root[100001], qv[100001];\nchar qc[100001], con[100001];\n\nint main(){\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 2; i <= n; ++i){\n\t\tscanf(\"%d\", &par[i]);\n\t}\n\tfor(int i = 1; i <= n; ++i){\n\t\troot[i] = i;\n\t}\n\tfor(int i = 0; i < q; ++i){\n\t\tscanf(\" %c%d\", &qc[i], &qv[i]);\n\t\tif(qc[i] == 'M'){\n\t\t\tcon[qv[i]] = 1;\n\t\t}\n\t}\n\n\tUF u(n);\n\tfor(int i = 2; i <= n; ++i){\n\t\tif(!con[i]){\n\t\t\troot[u.find(i)] = root[u.find(par[i])];\n\t\t\tu.unite(i, par[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\tfor(int i = q - 1; i >= 0; --i){\n\t\tif(qc[i] == 'M'){\n\t\t\troot[u.find(qv[i])] = root[u.find(par[qv[i]])];\n\t\t\tu.unite(qv[i], par[qv[i]]);\n\t\t}\n\t\telse{\n\t\t\tans += root[u.find(qv[i])];\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nvi col,in;\nint dfs(int a){\n\tif(col[a])return a;\n\telse return dfs(in[a]);\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tcol=vi(n);\n\t\tcol[0]=1;\n\t\tin=vi(n);\n\t\trep(i,n-1){\n\t\t\tint a;cin>>a;\n\t\t\tin[i+1]=a-1;\n\t\t}\n\t\tint out=0;\n\t\trep(i,m){\n\t\t\tchar c;int a;\n\t\t\tcin>>c>>a;\n\t\t\tif(c=='M')col[a-1]=true;\n\t\t\telse{\n\t\t\t\tout+=1+dfs(in[a-1]);\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint n,q;\nint par[100005];\nvector<int> child[100005];\nqueue<P> mna;//marked nearest ancestor\nint mark[100005];\nint query[100005];\nint qquery[100005];\nint mnalist[100005];\nstring s;\nint ans;\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,100005)\n\t\t{\n\t\t\tmark[i]=0;\n\t\t\tquery[i]=0;\n\t\t\tqquery[i]=0;\n\t\t\tchild[i].clear();\n\t\t\tpar[i]=0;\n\t\t\tmnalist[i]=0;\n\t\t}\n\t\tans=0;\n\t\tcin>>n>>q;\n\t\tif(n==0)break;\n\t\trep(i,n-1)\n\t\t{\n\t\t\tcin>>par[i+1];\n\t\t\tpar[i+1]--;\n\t\t\tchild[par[i+1]].push_back(i+1);\n\t\t}\n\t\tmark[0]=1;\n\t\trep(i,q)\n\t\t{\n\t\t\tcin>>s>>qquery[i];\n\t\t\tqquery[i]--;\n\t\t\tif(s==\"M\")\n\t\t\t{\n\t\t\t\tquery[i]=1;\n\t\t\t\tmark[qquery[i]]=1;\n\t\t\t}\n\t\t}\n\t\tmna.clear();\n\t\tmna.push(P(0,0));\n\t\tmnalist[0]=0;\n\t\twhile(!mna.empty())\n\t\t{\n\t\t\tP p=mna.front();mna.pop();\n\t\t\trep(i,child[p.first].size())\n\t\t\t{\n\t\t\t\tif(mark[child[p.first][i]]==1)\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=child[p.first][i];\n\t\t\t\t\tmna.push(P(child[p.first][i],child[p.first][i]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=p.second;\n\t\t\t\t\tmna.push(P(child[p.first][i],p.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint person;\n\t\tfor(int kkk=q-1;kkk>=0;kkk--)\n\t\t{\n\t\t\tif(query[kkk]==1)\n\t\t\t{\n\t\t\t\tmnalist[qquery[kkk]]=mnalist[par[qquery[kkk]]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tperson=mnalist[qquery[kkk]];\n\t\t\t\twhile(person!=mnalist[person])\n\t\t\t\t{\n\t\t\t\t\tperson=mnalist[person];\n\t\t\t\t}\n\t\t\t\tans+=(person+1);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100016\n\nusing namespace std;\n\nint par[maxN], rank[maxN];\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, j, x;\n\tlong long sum;\n\tchar c;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tfor (i = 2; i <= n; i++)\n\t\t\tscanf(\"%d\", &par[i]);\n\t\tgetchar();\n\t\tfor (i = sum = 0; i < t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'Q')\n\t\t\t\tsum += find(x);\n\t\t\telse\n\t\t\t\tpar[x] = x;\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int gmax_n = 100005;\n\nint par[gmax_n]; //???\nint depth[gmax_n];//??¨?????±???\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid dfs(vector<int> t[gmax_n], int g[gmax_n], int cur, bool marked[gmax_n]){\n    rep(i,t[cur].size()){\n        int next = t[cur][i];\n        if(g[next] != -1) continue;\n\n        //???????????????????????????????????????????????????????????¨unite\n        if(marked[next] == false) unite(cur, next);\n        g[next] = cur;\n        dfs(t,g,next,marked);\n    }\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        vector<int> tree[gmax_n];\n        init(n);\n        rep(i,n - 1){ //??¨????§????\n            int a;\n            cin >> a;\n            a--;\n            tree[i + 1].emplace_back(a);\n            tree[a].emplace_back(i + 1);\n        }\n\n        bool marked[gmax_n] = {false};//???????????????????????????????¨????\n        marked[0] = true;\n        vector<pair<char, int>> q;\n        rep(i,m){\n            char a;\n            int b;\n            cin >> a >> b;\n            b--;\n            if(a == 'M'){\n                if(marked[b]) continue; //????????¨???????????????????????´?????????????????\\???????????????\n                else{\n                    marked[b] = true;\n                    q.emplace_back(make_pair(a, b));\n                }\n            }else{\n                q.emplace_back(make_pair(a,b));\n            }\n        }\n\n        int g[gmax_n];\n        rep(i,gmax_n) g[i] = -1;\n        g[0] = 0;\n        dfs(tree, g, 0, marked);\n\n        //rep(i,n) show(g[i])\n        //rep(i,n){ show(find(i)) }\n\n        long long ans = 0;\n        for(int i = q.size() - 1; i >= 0; i--){ //?????¨?????????????????????\n            if(q[i].first == 'Q') ans += find(q[i].second) + 1;\n            else{\n                unite(g[q[i].second], q[i].second);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x] ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t\tchk[x] = true;\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\tnear[-1] = -1;\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\t//for( auto i : memo ) cout << i << endl;\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int np){\n  p[v]=np;\n  if(!m[v]){\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],np);\n    }\n  }\n}\n\nvoid dfsa(int v,int pn){\n  if(!m[v]){\n    p[v]=pn;\n    for(int i=0;i<t[v].size();i++){\n      dfsa(t[v][i],pn);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    long long s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tm[v]=true;\n\tp[v]=v;\n\tfor(int i=0;i<t[v].size();i++){\n\t  //\t  dfs(t[v][i],v);\n\t  dfsa(t[v][i],v);\n\t}\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nconst int MAX_N = 10010;\nusing TYPE = long long; // ?????¢???????????\\??????\nvector<pair<int, TYPE> > G[MAX_N];\nvector<TYPE> dijkstra(int start){\n\tvector<TYPE> dist(MAX_N, INFF);\n\tdist[start] = 0;//dist[i] :=???start->i?????§??????????????¢\n\tpriority_queue<pair<TYPE, int>, vector<pair<TYPE, int> >, greater<pair<TYPE, int> > >  que;\n\tque.push(make_pair(0, start));\n\twhile(!que.empty()){\n\t\tTYPE cost; int u;//????????§???????????£????????? ?????¨?????????\n\t\tcost = que.top().first, u = que.top().second;\n\t\tque.pop();\n\t\tif(dist[u] < cost) continue;\n\t\tfor (auto tmp : G[u]){\n\t\t\tint v = tmp.first; TYPE time = tmp.second;//??£??\\???????????? ?????????????????§????????????\n\t\t\tif(dist[v] > dist[u] + time){//u->v\n\t\t\t\tdist[v] = dist[u] + time;\n\t\t\t\tque.push(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nint main(void) {\n\twhile(1) {\n\t\tint N, M; scanf(\"%d %d\", &N, &M);\n\t\tif(N == 0 && M == 0) break;\n\t\tint u[20010], v[20010], d[20010], c[20010];\n\t\trep(i, M) scanf(\"%d %d %d %d\", &u[i], &v[i], &d[i], &c[i]);\n\t\trep(i, M) u[i]--, v[i]--;\n\n\t\tmap<pair<int, int>, int> ma;\n\t\trep(i, M) G[u[i]].pb(mp(v[i], d[i])), G[v[i]].pb(mp(u[i], d[i]));\n\t\trep(i, M) ma[make_pair(u[i], v[i])] = c[i], ma[make_pair(v[i], u[i])] = c[i];\n\t\tauto dist = dijkstra(0);\n\n\t\tll ans = 0;\n\t\treps(v, 1, N) { // 0->v ?????§???????????????\n\t\t\tll mi = INFF;\n\t\t\tfor(auto t : G[v]) {\n\t\t\t\tint u = t.fi, d = t.se;\n\t\t\t\tint cost = ma[make_pair(u, v)];\n\t\t\t\tif(dist[v] == dist[u] + d) chmin(mi, cost);\n\t\t\t}\n\t\t\tans += mi;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\nset<int> s;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tmarked[t[i]]=true;\n\tif(s.find(t[i])==s.end()) s.insert(t[i]);\n\telse c[i]='E';\n      }\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M'&&t[i]!=1) marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n    s.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<iostream>\n#include<set>\n#include<cctype>\n#include<bitset>\n#define ShimaKZ 404 Not Found\n#define dec(a) memset(a,-1,sizeof(a))\n#define mem(a) memset(a,0,sizeof(a))\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define bug() cerr<<\"Surprise MotherFucker\"<<endl\n#define FOR(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;++i)\n#define SFOR(i,a,b) for(int i=(a),i##_end_=(b);i<i##_end_;++i)\n#define DOR(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;--i)\n#define y1 juiue\n#define y2 skjda\ntypedef long long ll;\ntemplate<class _> _ gcd(_ a,_ b) {return !b?a:gcd(b,a%b);}\ntemplate<class _,class __> bool checkmax(_ &a,__ b) {return a<b?a=b,true:false;}\ntemplate<class _,class __> bool checkmin(_ &a,__ b) {return a>b?a=b,true:false;}\ntemplate<class _> _ lcm(_ a,_ b) {return a*b/gcd(a,b);}\ntemplate<class _,class __> _ Mod(_ a,__ b) {return (a%b+b)%b;}\nusing namespace std;\n#define M 100086\nint Fa[M];\nint fa[M];\nvector<int>edge[M];\nbool mark[M];\nvoid Init(int n){FOR(i,1,n)Fa[i]=i;}\nint Find(int x){return x==Fa[x]?x:Fa[x]=Find(Fa[x]);}\nbool same(int x,int y){return Find(x)==Find(y);}\nvoid unite(int x,int y){Fa[Find(x)]=Find(y);}\nint n,m;\nstruct node{\n\tint op;\n\tint vetrix;\n}A[M<<1];\nint anc[M];\nint cnt[M];\n//void dfs(int x,int f,bool itself){\n//\tif(itself)anc[x]=anc[f];\n//\telse anc[x]=f;\n//\tSFOR(i,0,edge[x].size()){\n//\t\tint y=edge[x][i];\n//\t\tif(mark[y])dfs(y,y,1);\n//\t\telse dfs(y,f,0);\n//\t}\n//}\nvoid solve(){\n\tFa[1]=1;\n\tFOR(i,2,n)scanf(\"%d\",&fa[i]);\n\tfa[1]=1;\n\tmem(mark);\n\tmem(cnt);\n\tmark[1]=1;\n\tFOR(i,1,m){\n\t\tchar s[4];\n\t\tscanf(\"%s%d\",s,&A[i].vetrix);\n\t\tA[i].op=s[0]=='Q'?0:1;\n\t\tif(A[i].op){\n\t\t\tmark[A[i].vetrix]=true;\n\t\t\tcnt[A[i].vetrix]++;\n\t\t}\n\t}\n\tFOR(i,1,n)if(!mark[i])A[++m].vetrix=i,A[m].op=1,cnt[i]++;\n\tll ans=0;\n\tInit(n);\n\tDOR(i,m,1){\n\t\tif(A[i].op&&!same(A[i].vetrix,fa[A[i].vetrix])&&!--cnt[A[i].vetrix]==1)\n\t\t\tunite(A[i].vetrix,fa[A[i].vetrix]);\n\t\telse ans+=Find(A[i].vetrix);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m)){\n\t\tif(!n&&!m)return EXIT_SUCCESS;\n\t\tsolve();\n\t}\n\treturn EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "//37\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,q;\nint p[100001];\nbool m[100001];\nvector<int> t[100001];\n\nvoid dfs(int v,int pn){\n  if(!m[v]){\n    p[v]=pn;\n    for(int i=0;i<t[v].size();i++){\n      dfs(t[v][i],pn);\n    }\n  }\n}\n\nint main(){\n  while(cin>>n>>q,n|q){\n    fill(p,p+n+1,1);\n    fill(m,m+n+1,false);\n    m[1]=true;\n    for(int i=1;i<=n;i++){\n      t[i].clear();\n    }\n    for(int i=2;i<=n;i++){\n      int pn;\n      cin>>pn;\n      t[pn].push_back(i);\n    }\n    long long s=0;\n    while(q--){\n      char e;\n      int v;\n      cin>>e>>v;\n      if(e=='Q'){\n\ts+=p[v];\n      }else{\n\tdfs(v,v);\n\tm[v]=true;\n      }\n    }\n    cout<<s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define Q 100005\nusing namespace std;\ntypedef long long ll;\nint n,q,u,t[Q],p[Q];\nbool marked[Q];\nchar c[Q];\nll ans;\n\nint find(int x){\n  if(marked[x]) return x;\n  return p[x]=find(p[x]);\n}\n\nint main(){\n  while(1){\n    cin>>n>>q;\n    if(!n&&!q) break;\n    for(int i=1;i<=n;i++) marked[i]=false;\n    for(int i=2;i<=n;i++) cin>>u,p[i]=u;\n    for(int i=0;i<q;i++){\n      cin>>c[i]>>t[i];\n      if(c[i]=='M'){\n\tif(marked[t[i]]) c[i]='E';\n\tmarked[t[i]]=true;\n      }\n    }\n    marked[1]=true;\n    ans=0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i]=='E') continue;\n      if(c[i]=='M'&&t[i]!=1) marked[t[i]]=false;\n      else ans+=find(t[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Marked Ancestor????§£????????????????????????????????????????????????????????¨????????¨??¨??????????????§?????????????????????????????§??????????????????\n?????°???????????????????????????:1???????????????*/\n\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(long long x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<long long,long long> P;\ntypedef pair<long long,P> PP;\nlong long n,q;\nlong long par[100005];\nvector<long long> child[100005];\nqueue<P> mna;//marked nearest ancestor\nlong long mark[100005];\nlong long query[100005];\nlong long qquery[100005];\nlong long mnalist[100005];\nstring s;\nlong long ans;\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,100005)\n\t\t{\n\t\t\tmark[i]=0;\n\t\t\tquery[i]=0;\n\t\t\tqquery[i]=0;\n\t\t\tchild[i].clear();\n\t\t\tpar[i]=0;\n\t\t\tmnalist[i]=0;\n\t\t}\n\t\tans=0;\n\t\tcin>>n>>q;\n\t\tif(n==0)break;\n\t\trep(i,n-1)\n\t\t{\n\t\t\tcin>>par[i+1];\n\t\t\tpar[i+1]--;\n\t\t\tchild[par[i+1]].push_back(i+1);\n\t\t}\n\t\tmark[0]=1;\n\t\trep(i,q)\n\t\t{\n\t\t\tcin>>s>>qquery[i];\n\t\t\tqquery[i]--;\n\t\t\tif(s==\"M\")\n\t\t\t{\n\t\t\t\tquery[i]=1;\n\t\t\t\tmark[qquery[i]]++;\n\t\t\t}\n\t\t}\n\t\tmna.push(P(0,0));\n\t\tmnalist[0]=0;\n\t\twhile(!mna.empty())\n\t\t{\n\t\t\tP p=mna.front();mna.pop();\n\t\t\trep(i,child[p.first].size())\n\t\t\t{\n\t\t\t\tif(mark[child[p.first][i]]!=0)\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=child[p.first][i];\n\t\t\t\t\tmna.push(P(child[p.first][i],child[p.first][i]));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmnalist[child[p.first][i]]=p.second;\n\t\t\t\t\tmna.push(P(child[p.first][i],p.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long person;\n\t\tfor(long long kkk=q-1;kkk>=0;kkk--)\n\t\t{\n\t\t\tif(query[kkk]==1)\n\t\t\t{\n\t\t\t\tmark[qquery[kkk]]--;\n\t\t\t\tif(mark[qquery[kkk]]==0)mnalist[qquery[kkk]]=mnalist[par[qquery[kkk]]];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tperson=mnalist[qquery[kkk]];\n\t\t\t\twhile(person!=mnalist[person])\n\t\t\t\t{\n\t\t\t\t\tperson=mnalist[person];\n\t\t\t\t}\n\t\t\t\tans+=(person+1);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#define INF 1000000000\n#define M 100005\n#define LL long long\nusing namespace std;\nstruct node{\n    int x,y;\n}A[M],Q[M];\nint fa[M];\nbool mark[M];\nint edge[M];\nint get(int x){\n    if(fa[x]==x) return x;\n    else return fa[x]=get(fa[x]);\n}\nint get_ans(int x){\n    x=get(x);\n    while(!mark[x]){\n        fa[x]=get(edge[x]);\n        x=get(edge[x]);\n    }\n    return x;\n}\nint readin(){\n    int res=0;\n    char a;\n    while(a=getchar(),!isdigit(a));\n    do{\n        res=(res<<3)+(res<<1)+(a^48);\n    }while(a=getchar(),isdigit(a));\n    return res;\n}\nint main(){\n    int n,q,j,k;\n    while(scanf(\"%d%d\",&n,&q)!=EOF){\n        if(n==0&&q==0) break;\n        memset(mark,0,sizeof(mark));\n        mark[1]=1;edge[1]=1;\n        for(j=1;j<=n;j++) fa[j]=j;\n        for(j=2;j<=n;j++){\n            int a;\n            scanf(\"%d\",&a);\n            edge[j]=a;\n        }\n        char s[2];\n        for(j=1;j<=q;j++){\n            scanf(\"%s%d\",s,&Q[j].y);\n            if(s[0]=='Q') Q[j].x=0;\n            else{\n                mark[Q[j].y]=1;\n                Q[j].x=1;\n            }\n        }\n        long long ans=0;\n        for(j=1;j<=n;j++) get_ans(j);\n        for(j=q;j>=1;j--){\n            if(Q[j].x==0){\n                ans+=get(Q[j].y);\n            }\n            else if(mark[Q[j].y]){\n                mark[Q[j].y]=0;\n                fa[Q[j].y]=get(edge[Q[j].y]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M;\nint par [100001];\nint root [100001];\n\nint find(int x)\n{\n\tif(root [x] == x) return x;\n\treturn root [x] = find(root [x]);\n}\n\nvoid unite(int x,int y)\n{\n\tx = find(x); y = find(y);\n\troot [y] = x;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&M) && N){\n\t\tFOR(i,2,N + 1){\n\t\t\tint u;\n\t\t\tscanf(\"%d\",&u);\n\t\t\tpar [i] = u;\n\t\t}\n\t\tvector< pair<int,int> > qy(M);\n\t\tdeque<bool> d(N + 1);\n\t\tFOR(i,0,M){\n\t\t\tchar str [20];\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\",str,&x);\n\t\t\tif(str [0] == 'M'){\n\t\t\t\td [x] = true;\n\t\t\t}\n\t\t\tqy [i] = make_pair(x,str [0] == 'Q');\n\t\t}\n\t\tFOR(i,2,N + 1) if(d [i] == false){\n\t\t\tqy.push_back(make_pair(i,0));\n\t\t}\n\t\treverse(qy.begin(),qy.end());\n\t\tll ans = 0;\n\t\tfor(int i = 1;i <= N;i++){\n\t\t\troot [i] = i;\n\t\t}\n\t\tFOR(i,0,qy.size()){\n\t\t\tif(qy [i].second == 0){\n\t\t\t\tunite(par [qy [i].first],qy [i].first);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += find(qy [i].first);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <stack>\nusing namespace std;\n#define MAX_N 100010\n\nint N,Q, marked[MAX_N], visited[MAX_N];\ntypedef pair<char, int> QUERY;\nstack<QUERY> query;\nint parent[MAX_N];\n\nint par[MAX_N]; // root\nint rank[MAX_N]; // depth of tree\n\n// 要素数nで初期化\nvoid init(int n) {\nfor (int i=0;i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    }\n}\n\n// 木の根を求める\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    } else {\n        return find(par[x]);\n    }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n    //x = find(x);\n    y = find(y);\n    if(x==y) return;\n\n    par[x] = y; // parent of x is y\n\n    /*\n    if (rank[x] <= rank[y]) {\n        par[x] = y;\n        if (rank[x] == rank[y]) rank[y]++;\n    } else {\n        par[y] = x;\n    }\n    */\n}\n\nvoid solve() {\n    int ans = 0;\n\n    for(int i=2;i<=N;i++) {\n        if(marked[i] == false) {\n            unite(i, parent[i]);\n        }\n    }\n\n    int num = query.size();\n    while(!query.empty()) {\n        QUERY q = query.top(); query.pop();\n        char op = q.first;\n        int index = q.second;\n        if(op == 'M') { // Mark\n            marked[index] = false;\n            unite(index, parent[index]);\n        } else if(op == 'Q') { // Query\n            ans += find(index);\n        }\n    }\n    cout << ans << endl;\n}\n\nmain() {\n    while(1) {\n        cin >> N >> Q;\n        if(N==Q&&N==0) break;\n        memset(marked,0,sizeof(marked));\n        memset(parent,0,sizeof(parent));\n        init(N+2);\n        set<int> s;\n\n        marked[1] = 1; // node 1 is already marked \n        parent[1] = 1;\n        for(int i=2;i<=N;i++) {\n            int d;\n            cin >> d;\n            parent[i] = d;\n        }\n\n        // Question\n        s.insert(1); \n        for(int i=0;i<Q;i++) {\n            char op;\n            int index;\n            cin >> op >> index;\n            if(op == 'M' && s.find(index) != s.end()) continue;\n            if(op == 'M') marked[index] = true;\n            s.insert(index);\n            query.push(make_pair(op, index));\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\tarr[1].isMarked = true;\n\t\tarr[1].nearest_index = 1;\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tif (arr[_index].isMarked == true)return;\n\t\tarr[_index].isMarked = true;\n\t\tarr[_index].nearest_index = _index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tif (arr[itr].isMarked == false)updateNearest(itr, _index);\n\t\t}\n\t}\n\tvoid updateNearest(int _index,int _nearest_index)\n\t{\n\t\tarr[_index].nearest_index = _nearest_index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tif (arr[itr].isMarked == false)updateNearest(itr, _nearest_index);\n\t\t}\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct SegmentTree {\n  using T = int;\n  static T op(const T& x, const T& y) { return max(x, y); }\n  static constexpr T e() { return -1; }\n  using U = int;\n  static void ap(const U& f, T& x) { x = max(f, x); }\n  static void cp(const U& g, U& f) { f = max(g, f); }\n  static constexpr U id() { return -1; }\n\n  const int n;\n  V<T> t;\n  V<U> u;\n  SegmentTree(int n) : n(n), t(2 * n, e()), u(n, id()) {}\n  T& operator[](int i) { return t[i + n]; }\n  void build() { for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]); }\n  void push() { for (int i = 1; i < n; ++i) push(i); }\n  void apply(const U& f, int i) {\n    ap(f, t[i]);\n    if (i < n) cp(f, u[i]);\n  }\n  void push(int i) {\n    if (u[i] == id()) return;\n    apply(u[i], 2 * i);\n    apply(u[i], 2 * i + 1);\n    u[i] = id();\n  }\n  void push(int l, int r) {\n    for (int hl = __lg(l + n), hr = __lg(r - 1 + n); hr > 0; --hl, --hr) {\n      int al = l + n >> hl, ar = r - 1 + n >> hr;\n      if (al < n) push(al);\n      if (ar != al) push(ar);\n    }\n  }\n  T acc(int l, int r) {\n    push(l, r);\n    T resl = e(), resr = e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) resl = op(resl, t[l++]);\n      if (r & 1) resr = op(t[--r], resr);\n    }\n    return op(resl, resr);\n  }\n  T get(int i) { return acc(i, i + 1); }\n  void act(int l, int r, const U& f) {\n    push(l, r);\n    for (int i = l + n, j = r + n; i < j; i >>= 1, j >>= 1) {\n      if (i & 1) apply(f, i++);\n      if (j & 1) apply(f, --j);\n    }\n    l = l + n >> __builtin_ctz(l + n);\n    while (l >>= 1) t[l] = op(t[2 * l], t[2 * l + 1]);\n    r = r + n >> __builtin_ctz(r + n);\n    while (r >>= 1) t[r] = op(t[2 * r], t[2 * r + 1]);\n  }\n  void set(int i, const T& x) {\n    push(i, i + 1);\n    t[i += n] = x;\n    while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n  }\n};\n\nnamespace LCA {\n  using T = int;\n  struct Edge { int to; T w; };\n  T op(const T& x, const T& y) { return x + y; }\n  constexpr T e = 0;\n\n  V<> dep;\n  VV<> par;\n  VV<T> val;\n  void init(const VV<Edge>& g, int r) {\n    int n = g.size();\n    dep.resize(n);\n    par.assign(__lg(2 * n - 1), V<>(n, -1));\n    val.assign(__lg(2 * n - 1), V<>(n, e));\n    auto dfs = [&](const auto& dfs, int v, int p) -> void {\n      for (const auto& e : g[v]) if (e.to != p) {\n        dep[e.to] = dep[v] + 1;\n        par[0][e.to] = v;\n        val[0][e.to] = e.w;\n        dfs(dfs, e.to, v);\n      }\n    };\n    dep[r] = 0;\n    dfs(dfs, r, -1);\n    for (int k = 1; k < (int) par.size(); ++k) {\n      for (int v = 0; v < n; ++v) {\n        if (par[k - 1][v] == -1) continue;\n        par[k][v] = par[k - 1][par[k - 1][v]];\n        val[k][v] = op(val[k - 1][v], val[k - 1][par[k - 1][v]]);\n      }\n    }\n  }\n  int get_par(int v, int h) {\n    for (int k = 0; h > 0; h >>= 1, ++k) {\n      if (v == -1) break;\n      if (h & 1) v = par[k][v];\n    }\n    return v;\n  }\n  int lca(int u, int v) {\n    if (dep[u] > dep[v]) swap(u, v);\n    v = get_par(v, dep[v] - dep[u]);\n    if (u == v) return u;\n    for (int k = par.size() - 1; k >= 0; --k) {\n      if (par[k][u] != par[k][v]) {\n        u = par[k][u];\n        v = par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n  T get_val(int v, int h) {\n    T res = e;\n    for (int k = 0; h > 0; h >>= 1, ++k) {\n      if (v == -1) break;\n      if (h & 1) {\n        res = op(res, val[k][v]);\n        v = par[k][v];\n      }\n    }\n    return res;\n  }\n  T acc(int u, int v) {\n    int a = lca(u, v);\n    return op(get_val(v, dep[v] - dep[a]), get_val(u, dep[u] - dep[a]));\n  }\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, q;\n  while (cin >> n >> q, n) {\n    VV<> ch(n);\n    VV<LCA::Edge> g(n);\n    for (int i = 1; i < n; ++i) {\n      int p; cin >> p, --p;\n      ch[p].push_back(i);\n      g[i].emplace_back(LCA::Edge{p, 0});\n      g[p].emplace_back(LCA::Edge{i, 0});\n    }\n    V<> in(n), out(n), dep(n);\n    int t = 0;\n    auto dfs = [&](const auto& dfs, int v) -> void {\n      in[v] = t++;\n      for (int w : ch[v]) {\n        dep[w] = dep[v] + 1;\n        dfs(dfs, w);\n      }\n      out[v] = t;\n    };\n    dfs(dfs, 0);\n    SegmentTree st(n);\n    st.act(in[0], out[0], dep[0]);\n    LCA::init(g, 0);\n    lint res = 0;\n    while (q--) {\n      char c; cin >> c;\n      int v; cin >> v, --v;\n      if (c == 'M') {\n        st.act(in[v], out[v], dep[v]);\n      } else {\n        res += LCA::get_par(v, dep[v] - st.get(in[v])) + 1;\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\nclass union_find{\n\tvector<int> parent;\npublic:\n\tvector<int> marked;\n\tint root(int a){return parent[a]==a||marked[a]?a:(parent[a]=root(parent[a]));}\n\tunion_find(int n):parent(n),marked(n){for(int i=1;i<n;i++)parent[i]=i;}\n\tint same(int a,int b){return root(a)==root(b);}\n\tint unite(int a,int b){\n\t\tint x=root(a),y=root(b);//if(x==y)return 0;\n\t\tparent[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint main(){\n\tint N,M;\n\tfor(;scanf(\"%d%d\",&N,&M),N;){\n\t\tvector<int>parent(N);\n\t\tfor(int i=1;i<N;i++)scanf(\"%d\",&parent[i]),parent[i]--;\n\t\tunion_find uf(N);\n\t\tvector<pair<char,int> >query;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tchar s[2];int n;\n\t\t\tscanf(\"%s%d\",s,&n),n--;\n\t\t\tif(*s=='Q'||!uf.marked[n]){\n\t\t\t\tif(*s=='M')uf.marked[n]=1;\n\t\t\t\tquery.emplace_back(*s,n);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<N;i++)if(!uf.marked[i])uf.unite(i,parent[i]);\n\t\treverse(query.begin(),query.end());\n\t\tint R=0;\n\t\tfor(auto &e:query){\n\t\t\tif(e.first=='Q')R+=uf.root(e.second)+1;\n\t\t\telse uf.marked[e.second]=0,uf.unite(e.second,parent[e.second]);\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m,x,sum,flg;\nstring str;\nint t[100001],u[100001];\nint dfs(int x){\n  if(u[x]==1)return x;\n  return dfs(t[x]);\n}\nint main(){\n  while(cin>>n>>m,n){\n    for(int i=0;i<100001;i++)u[i]=0;\n    t[1]=u[1]=1;\n    sum=0;\n    for(int i=0;i<n-1;i++)cin>>t[i+2];\n    for(int i=0;i<m;i++){\n      cin>>str>>x;\n      if(str==\"Q\"){\n\tsum+=dfs(t[x]);\n      }else{\n\tu[x]=1;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nAOJ 2170 Marked Ancestor\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\nint isMarked[MAXN];\nint N, Q;\n\nstruct OPER{\n    char s[2];\n    int p;\n    void input(){\n        scanf(\"%s%d\", s, &p);\n        if(s[0] == 'M') isMarked[p]++;\n    };\n}op[MAXN];\n\n\nclass UnionSet{\npublic:\n    int Find(int x)\n    {\n        if(isMarked[x]) return x;\n        else {\n            int fx = parent[x];\n            parent[x] = Find(fx);\n            return parent[x];\n        }\n    }\n};\n\nUnionSet us;\n\nbool read()\n{\n    scanf(\"%d%d\", &N, &Q);\n    if(N==0&&Q==0) return false;\n    memset(isMarked, 0, sizeof(isMarked));\n    parent[1] = 1;\n    isMarked[1] = N+1;\n    for(int i=2; i<=N; ++i){\n        scanf(\"%d\", &parent[i]);\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int q=0; q<Q; ++q)\n        op[q].input();\n\n    long long sum = 0;\n    for(int q=Q-1; q>=0; --q){\n        int v = op[q].p;\n        if(op[q].s[0] == 'M'){\n            isMarked[v]--;\n        }\n        else {\n            sum += us.Find(v);\n        }\n    }\n    printf(\"%lld\\n\", sum);\n}\n\nint main()\n{\n    while(read()){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nint v[444444], dep[444444], bg[444444], ed[444444];\nvector<int> edges[444444];\nchar st[111];\nvector<pair<int, int> > st0;\nvoid build(int k, int l, int r) {\n\tv[k] = 1;\n\tif(l != r) {\n\t\tbuild(k + k, l, (l + r) / 2);\n\t\tbuild(k + k + 1, (l + r) / 2 + 1, r);\n\t}\n}\nvoid renew(int k, int l, int r, int ql, int qr, int x) {\n\tif (qr < l || r < ql) {\n\t\treturn ;\n\t}\n\tif (ql <= l && r <= qr) {\n\t\tif (dep[x] > dep[v[k]]) {\n\t\t\tv[k] = x;\n\t\t}\n\t\treturn ;\n\t}\n\tint mid = (l + r) / 2;\n\trenew(k << 1, l, mid, ql, qr, x);\n\trenew(k << 1 | 1, mid + 1, r, ql, qr, x);\n}\n\nint ask(int k, int l, int r, int pos) {\n\tif (l == r) {\n\t\treturn v[k];\n\t}\n\tint mid = (l + r) / 2;\n\tint res;\n\tif (pos <= mid) {\n\t\tres = ask(k << 1, l, mid, pos);\n\t} else {\n\t\tres = ask(k << 1 | 1, mid + 1, r, pos);\n\t}\n\tif (dep[v[k]] > dep[res]) {\n\t\treturn v[k];\n\t} else {\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tfor(;;) {\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(!n and !m) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i(1); i <= n; i++) {\n\t\t\tedges[i].clear();\n\t\t}\n\t\tfor(int i(2); i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tedges[x].push_back(i);\n\t\t}\n\t\tst0.clear();\n\t\tst0.push_back(make_pair(1, 0));\n\t\tdep[1] = 0;\n\t\tbg[1] = 1;\n\t\tint l(1);\n\t\twhile(!st0.empty()) {\n\t\t\tint v(st0.back().first), p(st0.back().second++);\n\t\t\tif(p != (int)edges[v].size()) {\n\t\t\t\tst0.push_back(make_pair(edges[v][p], 0));\n\t\t\t\tdep[edges[v][p]] = dep[v] + 1;\n\t\t\t\tbg[edges[v][p]] = ++l;\n\t\t\t}else {\n\t\t\t\ted[v] = l;\n\t\t\t\tst0.pop_back();\n\t\t\t}\n\t\t}\n\t\tbuild(1, 1, n);\n\t\tlong long ans(0);\n\t\tfor(int i(1); i <= m; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\", st, &x);\n\t\t\tif(st[0] == 'M') {\n\t\t\t\trenew(1, 1, n, bg[x], ed[x], x);\n\t\t\t}else {\n\t\t\t\tans = ans + ask(1, 1, n, bg[x]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans)\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stdio.h>\n#define MAX_N 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int ,bool> p;\np fa[MAX_N];\nint main(){\n    int n,q;\n    fa[1].first = 1;\n    fa[1].second = true;\n    while(~scanf(\"%d%d\",&n,&q)&&n>0){\n        ll ans = 0;\n        for(int i = 2;i <= n;i++){\n            scanf(\"%d\",&fa[i].first);\n            fa[i].second = false;\n        }\n        getchar();\n        for(int i = 0;i<q;i++){\n            char ch;int a;\n            scanf(\"%c%d\",&ch,&a);\n            getchar();\n            if(ch =='Q'){\n                while(fa[a].second==false){\n                    a = fa[a].first;\n                }\n                ans += a;\n            }\n            else{\n                fa[a].second = true;\n            }\n\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tvector<int> tb(n);\n\t\trep(i, n)tb[i] = i;\n\t\tll ans = 0;\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\ttb[e[j].m] = e[e[j].p].m;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint to = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\tint last = to;\n\t\t\t\tto = e[j].m;\n\t\t\t\twhile (tb[to] != to) {\n\t\t\t\t\ttb[to] = last;\n\t\t\t\t\tto = tb[to];\n\t\t\t\t}\n\t\t\t\tans += tb[to] + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int NN=100*1000+1;\nint parent[2][NN];\nvector<int> child[2][NN];\nint level[NN];\nint N,Q;\nP nearest[NN];\nvoid setLevel(int i, int n)\n{\n\tnearest[i]=P(0,0);\n\tlevel[i]=n;\n\tfor(int j=0;j<child[0][i].size();j++){\n\t\tsetLevel(child[0][i][j],n+1);\n\t}\n}\nint setNearest(int p, int cur, P n)\n{\n\tif(nearest[p].first < n.first){\n\t\t//cout << \"nearest \" << p << \", \" << n.second << endl;\n\t\tnearest[p]=n;\n\t\tfor(int i=0;i<child[cur][p].size();i++){\n\t\t\tsetNearest(child[cur][p][i], cur, n);\n\t\t}\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tif(N==0&&Q==0){\n\t\texit(0);\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tchild[0][i].clear();\n\t}\n\tfor(int i=2;i<=N;i++){\n\t\tscanf(\"%d\",parent[0]+i);\n\t\tint p=parent[0][i];\n\t\tchild[0][p].push_back(i);\n\t}\n\tsetLevel(1,0);\n\tint step=2;\n\tint pre=1;\n\tint cur=0;\n\t/*\n\tcout << \"step 1\" << endl;\nfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\twhile(step<N){\n\t\tswap(cur,pre);\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(level[i]%step==0){\n\t\t\t\tint p=parent[pre][i];\n\t\t\t\tparent[cur][i]=parent[pre][p];\n\t\t\t\tchild[cur][i].clear();\n\t\t\t\tfor(int j=0;j<child[pre][i].size();j++){\n\t\t\t\t\tint ch=child[pre][i][j];\n\t\t\t\t\tfor(int k=0;k<child[pre][ch].size();k++){\n\t\t\t\t\t\tchild[cur][i].push_back(child[pre][ch][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild[cur][i].swap(child[pre][i]);\n\t\t\t\tparent[cur][i]=parent[pre][i];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tcout << \"step \" << step << endl;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tcout << i << \", \" << level[i] << \": \";\n\t\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\t\tcout << child[cur][i][j] << \", \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tstep*=2;\n\t}\n\n\t/*\n\tfor(int i=2;i<=N;i++){\n\t\tcout << i << \", \" << level[i] << \": \";\n\t\tfor(int j=0;j<child[cur][i].size();j++){\n\t\t\tcout << child[cur][i][j] << \", \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\tnearest[1]=P(0,1);\n\tchar c[2];\n\tint v;\n\tint sum=0;\n\tfor(int i=0;i<Q;i++){\n\t\tscanf(\"%1s %d\",c,&v);\n\t\tif(c[0]=='Q')\n\t\t{\n\t\t\twhile(nearest[v].second==0){\n\t\t\t\tv=parent[cur][v];\n\t\t\t}\n\t\t\tsum+=nearest[v].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tP n=P(level[v],v);\n\t\t\tsetNearest(v,cur,n);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum);\n}\nint main() {\n\twhile(true)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n#define inf 0x7f7f7f7f\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c;\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = 1, nn = 0; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'M' && mark[x] > i)\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\twhile(nn--)\n\t\t{\n\t\t\ttt = qt[nn];\n\t\t\tsum += find(qx[nn]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\n#define INF 0x3f3f3f3f\n#define N 100005\nint baba[N],vis[N];\nusing namespace std;\nint main()\n{\n    int n,m,a,b,sum;\n    char x;\n    while(scanf(\"%d%d\",&n,&m),(n+m))\n    {\n        sum=0;\n        memset(baba,0,sizeof(baba));\n        memset(vis,0,sizeof(vis));\n        baba[1]=1;\n        vis[1]=1;\n        for(int i=2;i<=n;i++)\n        {\n            scanf(\"%d\",&a);\n            baba[i]=a;\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\" %c %d\",&x, &b);\n            if(x=='M')\n                vis[b]=1;\n            else\n            {\n                while(vis[b]==0)\n                {\n                    b=baba[b];\n                }\n                sum+=b;\n            }\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n#define inf 0x7f7f7f7f\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c[2];\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tfor (i = 1, nn = 0; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%s%d\", c, &x);\n\t\t\tif (c[0] == 'M' && mark[x] > i)\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\twhile(nn--)\n\t\t{\n\t\t\ttt = qt[nn];\n\t\t\tsum += find(qx[nn]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint fa[MAXN],pa[MAXN],n,m,used[MAXN];\nlong long ans;\nchar c;\npair<int,int> a[MAXN];\nint get_fa(int x){\n    if(fa[x]==0)\n        return x;\n    fa[x]=get_fa(fa[x]);\n    return fa[x];\n}\nint main(){\n    SF(\"%d%d\",&n,&m);\n    while(n*m!=0){\n        for(int i=2;i<=n;i++)\n            SF(\"%d\",&pa[i]);\n        int x;\n        for(int i=1;i<=m;i++){\n            SF(\"\\n\");\n            SF(\"%c\",&c);\n            SF(\"%d\",&x);\n            if(c=='M'){\n                a[i].first=0;\n                a[i].second=x;\n                used[x]=1;\n            }\n            else{\n                a[i].first=1;\n                a[i].second=x;\n            }\n        }\n        for(int i=2;i<=n;i++)\n            if(used[i]==0)\n                fa[i]=get_fa(pa[i]);\n        for(int i=m;i>=1;i--){\n            if(a[i].first==0)\n                fa[i]=get_fa(pa[i]);\n            else\n                ans+=get_fa(i);\n        }\n        PF(\"%lld\\n\",ans);\n        SF(\"%d%d\",&n,&m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tmap<int,int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots[v] = a[v];\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1147483647;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define gchar(i) scanf(\"%c\",&(i))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n\n#define my_debug\n\nconst int MAX_N = 100005;\nint all[MAX_N];\nbool stu[MAX_N];\n\nint n, q;\n\nvoid solve(){\n\n}\n\nint get_f(int i){\n\tint out = all[i];\n\tif (stu[out])\n\t\treturn out;\n\telse\n\t\treturn get_f(out);\n}\n\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,q) != EOF){\n\t\tll out = 0;\n\t\tif (n == 0 && q == 0)\n\t\t\tbreak;\n\t\tinit(all, 0);\n\t\tinit(stu, 0);\n\t\tstu[1] = true;\n\t\tall[1] = 1;\n\t\trep(i, 2, (n + 1)){\n\t\t\tgint(all[i]);\n\t\t}\n\t\trep(i, 0, q){\n\t\t\tchar c;\n\t\t\tint tmp;\n\t\t\tgchar(c);\n\t\t\tgchar(c);\n\t\t\tgint(tmp);\n\t\t\tif (c == 'Q'){\n\t\t\t\tout += (ll)get_f(tmp);\n\t\t\t}\n\t\t\telse if (c == 'M'){\n\t\t\t\tstu[tmp] = true;\n\t\t\t}\n\t\t}\n\t\t//pint(out);\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nstruct UnionFind {\n\tvector<int> par;\n\tint size;\n\tUnionFind(int n) :size(n) {\n\t\tpar.resize(size);\n\t\tfor (int i = 0; i < size; i++) par[i] = i;\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tpar[y] = x;\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\treturn x == y;\n\t}\n};\nbool marked[100000];\nint par[100000];\nint main() {\n\tint N, Q;\n\twhile (cin >> N >> Q, N) {\n\t\tvector<P> query;\n\t\tmemset(marked, 0, sizeof(marked));\n\t\tmarked[0] = 1;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tcin >> par[i];\n\t\t\tpar[i]--;\n\t\t}\n\t\tUnionFind U(N);\n\t\tfor (int i = 0; i < Q; i++) {\n\t\t\tstring t;\n\t\t\tint v;\n\t\t\tcin >> t >> v; v--;\n\t\t\tif (t == \"M\") {\n\t\t\t\tif (marked[v]) continue;\n\t\t\t\tmarked[v] = 1;\n\t\t\t}\n\t\t\tquery.emplace_back(t == \"M\", v);\n\t\t}\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tif (!marked[i]) U.unite(par[i], i);\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = query.size() - 1; i >= 0; i--) {\n\t\t\tif (query[i].first) {\n\t\t\t\tU.unite(par[query[i].second], query[i].second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += U.find(query[i].second) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n#define inf 0x7f7f7f7f\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c[2];\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &par[i]);\n\t\t\tmark[i] = inf;\n\t\t}\n\t\tfor (i = 1, nn = 0; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%s%d\", c, &x);\n\t\t\tif (c[0] == 'M' && mark[x] > i)\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\twhile(nn--)\n\t\t{\n\t\t\ttt = qt[nn];\n\t\t\tsum += find(qx[nn]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+5) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int MAX_N = 100000 + 10;\nint N, Q;\nint P[MAX_N];\nint vis[MAX_N];\n\nvoid build(int N) {\n    for (int i = 0; i <= N; i++)\n        P[i] = 1;\n}\n\nint find(int x) {\n    if (vis[x])\n        return x;\n    else\n        return find(P[x]);\n}\n\nvoid Unite(int parent, int child) {\n    P[child] = parent;\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &N, &Q) && (N || Q)) {\n        memset(vis, 0, sizeof(vis));\n        vis[1] = 1;\n        build(N);\n        int x;\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", &x);\n            Unite(x, i);\n        }\n        char s;\n        long long sum = 0;\n        getchar();\n        for (int i = 0; i < Q; i++) {\n            scanf(\"%c %d\", &s, &x);\n            getchar();\n            if (s == 'M')\n                vis[x] = 1;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N]; //i(i = 0,1,2,...,n)?????????node???????????\\????????????\nchar Ope[MAX_N]; //operations?????\\????????????\nint Openum[MAX_N]; //operation??¨??????????????°????????\\????????????\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1, num);\n    }\n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          printf(\"%d\", nodeNum);\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n\n     \nint main()\n{\n  scanf(\"%d %d\", &N, &Q);\n    Node[1] = 1;\n  while(1){\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[1] = true;\n\tfor(int i = 1;i < n;i++){\n\t    cin >> root[i];\n\t    root[i]--;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    query[i].second--;\n\t    marked[query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q;i-- > 0;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second) + 1;\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\n// lazy evaluate segment tree\ntypedef int data_type;\nconst data_type dINF = iINF;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\t//update_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\t//update_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q; int v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// marked ancester\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170\n// 正解してないのであとでまた提出\n\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst int C = 100010;\nconst int UFSIZE = 100010;\nint P[UFSIZE]; // 親\nint T[UFSIZE]; // 木\n\nvoid init() {\n  for (auto i=0; i<UFSIZE; i++) {\n    P[i] = i;\n  }\n}\n\nint root(int a) {\n  if (a == P[a]) return a;\n  return (P[a] = root(P[a]));\n}\n\nbool issame(int a, int b) {\n  return root(a) == root(b);\n}\n\nvoid unite(int a, int b) {\n  P[root(a)] = root(b);\n}\n\nbool isroot(int a) {\n  return root(a) == a;\n}\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q && N) {\n    T[0] = 0;\n    for (auto i=1; i<N; i++) {\n      cin >> T[i];\n      T[i]--;\n    }\n    vector< pair<bool, int> > V;\n    bool marked[C];\n    fill(marked, marked+C, false);\n    for (auto i=0; i<Q; i++) {\n      char op;\n      int v;\n      cin >> op >> v;\n      v--;\n      if (op == 'M' && marked[v]) continue;\n      if (op == 'M') marked[v] = true;\n      V.push_back(make_pair((op == 'M'), v));\n    }\n    for (auto i=0; i<N; i++) {\n      P[i] = T[i];\n    }\n    Q = (int) V.size();\n    for (auto i=0; i<Q; i++) {\n      if (V[i].first) {\n\tP[V[i].second] = V[i].second;\n      }\n    }\n    reverse(V.begin(), V.end());\n    long long ans = 0;\n    for (auto i=0; i<Q; i++) {\n      if (V[i].first) {\n\tunite(V[i].second, T[V[i].second]);\n      } else {\n\tans += root(V[i].second)+1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\ntypedef pair<char,int> P;\nconst int MAX = 110000;\n\nint par[MAX+2];\nint rank[MAX+2];\nint n;\n\nvoid init(int n){\n  for(int i = 0 ; i < n+2 ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n  bool mark[MAX];\n\n  while(cin >> n >> q ,n + q){\n    stack<P> st;\n    fill(mark,mark+MAX,false);\n    mark[1] = true;\n    long long sum = 0;\n    init(n);\n    rank[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      rank[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'M'){\n\tmark[num] = true;\n      }\n      st.push(P(ch,num));\n    }\n    for(int i = 2 ; i <= n ; i++){\n      if(!mark[i]) unite(rank[i],i);\n    }\n\n    while(!st.empty()){\n      P p = st.top(); st.pop();\n\n      if(p.first == 'Q'){\n\tsum += find(p.second)+1;\n      }\n      else{\n\tmark[p.second] = false;\n\tunite(rank[p.second],p.second);\n      }\n    }\n      cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1LL<<55)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nstruct SegmetTree {\n    int n;\n    P dat[2*MAX-1];    \n    \n    SegmetTree(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = P(0, 1);\n        }\n    }\n\n    ll get_nearest_marked_node(int k)\n    {\n        k += n - 1;\n        P p = dat[k];\n        while (k > 0) {\n            k = (k - 1) / 2;\n            p = max(p, dat[k]);\n        }\n        return p.second;\n    }\n        \n    void mark(int a, int b, int k, int l, int r, P x)\n    {\n        if (r <= a || b <= l) return;\n\n        if (a <= l && r <= b) {\n            dat[k] = max(dat[k], x);\n        } else {\n            mark(a, b, k * 2 + 1, l, (l + r) / 2, x);\n            mark(a, b, k * 2 + 2, (l + r) / 2, r, x);\n        }\n    }    \n};\n\nll L[MAX], R[MAX], D[MAX], p;\nvector<int> G[MAX];\n\nvoid init(int N)\n{\n    p = 0;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();        \n    }\n}\n\nvoid dfs(int v, int depth)\n{\n    L[v] = p++;\n    D[v] = depth;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        dfs(G[v][i], depth + 1);\n    }\n    R[v] = p;\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0, 0);\n\n        SegmetTree st(N);\n        \n        char m;\n        ll v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.mark(L[v], R[v], 0, 0, st.n, P(D[v], v+1));\n            } else {\n                res += st.get_nearest_marked_node(L[v]);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 500000\nvector<int>conq[MAX_N]; int group[MAX_N], root[MAX_N];\nint n, m, a[MAX_N], b[MAX_N], c[MAX_N], ret[MAX_N]; bool M[MAX_N];\nvoid init() {\n\tfor (int i = 0; i < MAX_N; i++) { conq[i].clear(); a[i] = 0; b[i] = 0; c[i] = 0; group[i] = 0; root[i] = 0; ret[i] = 0; }\n\tfor (int i = 0; i < MAX_N; i++) { conq[i].push_back(i); group[i] = i; root[i] = i; M[i] = false; }\n}\nvoid unite(int p, int q) {\n\tint P = group[p], Q = group[q];\n\tint F1 = conq[P].size(), F2 = conq[Q].size();\n\tif (P == Q)return;\n\tint E = min(root[P], root[Q]);\n\tif (F1 >= F2) {\n\t\tfor (int i = 0; i < F2; i++) {\n\t\t\tconq[P].push_back(conq[Q][i]);\n\t\t\tgroup[conq[Q][i]] = P; root[conq[Q][i]] = E;\n\t\t}\n\t\tconq[Q].clear();\n\t}\n\tif (F1 < F2) {\n\t\tfor (int i = 0; i < F1; i++) {\n\t\t\tconq[Q].push_back(conq[P][i]);\n\t\t\tgroup[conq[P][i]] = Q; root[conq[P][i]] = E;\n\t\t}\n\t\tconq[P].clear();\n\t}\n}\nint Query(int p) {\n\treturn root[p];\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m; if (n == 0)break; init(); for (int i = 1; i < n; i++) { cin >> a[i]; a[i]--; }\n\t\tfor (int i = 0; i < m; i++) { char C; cin >> C >> c[i]; c[i]--; if (C == 'M')b[i] = 0; else b[i] = 1; }\n\t\tfor (int i = 0; i < m; i++)if (b[i] == 0)M[c[i]] = true;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (M[i] == false)unite(a[i], i);\n\t\t}\n\t\tfor (int i = m - 1; i >= 0; i--) {\n\t\t\tif (b[i] == 0)unite(a[c[i]], c[i]);\n\t\t\tif (b[i] == 1)ret[i] = Query(c[i]) + 1;\n\t\t}\n\t\tlong long sum = 0; for (int i = 0; i < m; i++)sum +=(long long) ret[i]; cout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt n,q;\nlnt queri[100000][2];\nbool marked[100000];\nlnt par[100000];\nvoid init(void)\n{\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t}\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\t\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tx=find(x);\n\ty=find(y);\n\tpar[x]=y;\n\treturn;\n}\n\nchar str[10];\nlnt anc[100000];\nlnt depth[100000];\nvector<lnt> to[100000];\nlnt m;\n\nvoid defdep(lnt x,lnt y){\n\tdepth[x]=y;\n\tfor(lnt i=0;i<to[x].size();i++) defdep(to[x][i],y+1);\n\treturn;\n}\n\nint main()\n{while(1){\n\tlnt ans=0;\n\tscanf(\"%lld%lld\",&n,&q);\n\tinit();\n\tif(!n&&!q) return 0;\n\tfor(lnt i=0;i<n;i++) to[i].clear();\n\tmemset(marked,0,sizeof(marked));\n\tfor(lnt i=1;i<n;i++){\n\t\tscanf(\"%lld\",&anc[i]);\n\t\tanc[i]--;\n\t\tto[anc[i]].push_back(i);\n\t}\n\tdefdep(0,0);\n\tmarked[0]=1;\n\tfor(lnt i=0;i<q;i++){\n\t\tscanf(\"%s%lld\",str,&queri[i][1]);\n\t\tqueri[i][1]--;\n\t\tif(*str=='M'){\n\t\t\tqueri[i][0]=1;\n\t\t\tif(!marked[queri[i][1]]) queri[i][0]=2;\n\t\t\tmarked[queri[i][1]]=1;\n\t\t}\n\t\telse queri[i][0]=0;\n\t}\n\tfor(lnt i=0;i<n;i++){\n\t\tm=i;\n\t\twhile(!marked[m]&&!same(m,anc[m])){\n\t\t\tunite(m,anc[m]);\n\t\t\tm=anc[m];\n\t\t}\n\t}\n\tfor(lnt i=q-1;i>=0;i--){\n\t\tif(queri[i][0]){\n\t\t\tif(queri[i][0]==2) unite(queri[i][1],anc[queri[i][1]]);\n\t\t}\n\t\telse{\n\t\t\tm=queri[i][1];\n\t\t\tans+=(depth[m]-depth[find(m)]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nint N, Q;\n\nint main(){\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        par[1]=1;\n        for(int i=2; i<=N; i++) scanf(\"%d \", &par[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n\t\t\tchar ch; int num;\n        \tscanf(\"%c \", &ch); \n\t\t\tscanf(\"%d \", &num); \n           if(ch=='M'){\n                vis[num]=1;\n            }\n            else if(ch=='Q'){\n                int cur=num;\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\nvector <ll> par;\nvector <bool> ism;\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\treverse(all(q));\n\n\t\trep(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (!ism[par[q[i].snd]]) {\n\t\t\t\tpar[q[i].snd] = par[par[q[i].snd]];\n\t\t\t}\n\t\t\tans += par[q[i].snd] + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nvector<node> T;\nint main(){\n  while(1){\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    node root;\n    root.marked = true;\n    root.parent = 0;\n    root.num = 1;\n    T.push_back(root);\n    for(int i=2;i<n+1;i++){\n      int parent;\n      cin >> parent;\n      node child;\n      T.push_back(child);\n      T[i-1].marked = false;\n      T[i-1].num = i;\n      T[i-1].parent = parent-1;\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }\n      if(q=='Q'){\n        node parent = T[T[v-1].parent];\n        while(!parent.marked){\n          parent = T[parent.parent];\n        }\n        sum += parent.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "    #include <cstdio>\n    #include <iostream>\n     \n    using namespace std;\n     \n    const int MAX_N = 100000;\n     \n    int N, Q, ans;\n    int Node[MAX_N][2];\n    char Ope[MAX_N];\n    int Openum[MAX_N];\n     \n    void mark(int x) {\n      for(int i = x+1; i <= N; i++){\n        if(x == Node[i][0]) {\n          Node[i][1] = x;\n          mark(i);\n        }\n      }\n    }\n     \n    void solve() {\n      ans = 0;\n      for (int i = 0; i < Q; i++) {\n        char ope = Ope[i];\n        int num = Openum[i];\n        if (ope == 'M') {\n          mark(num);\n        } \n        else if(ope == 'Q'){\n          ans += Node[num][1];\n        }\n      }\n      printf(\"%d\\n\", ans);\n    }\n     \n    int main()\n    {\n      while(1){\n        scanf(\"%d %d\", &N, &Q);\n        if(N == 0 && Q == 0) break;\n        for(int i = 2; i <= N; i++){\n          Node[i][0] = 1;\n        }\n        for(int i = 2; i <= N; i++){\n          scanf(\"%d\", &Node[i][1]);\n        }\n        for(int i = 0; i < Q; i++){\n          scanf(\"  %c\", &Ope[i]);\n          scanf(\"%d\", &Openum[i]);\n        }\n        solve();\n      }\n      return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#define rep(i, a, b) for (int i = a; i < b; ++i)\n#define repr(i, a, b) for (int i = a; i <= b; ++i)\n#define dep(i, a, b) for (int i = a; i > b; --i)\n#define depr(i, a, b) for (int i = a; i >= b; --i)\n#define getnum(n) scanf(\"%d\", &n)\n#define LL long long\n#define INF 0x7f7f7f7f\n#define PI acos(-1.0)\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nint f[MAXN], mark[MAXN], n, q, x, qt[MAXN], qv[MAXN], cnt, t;\nLL ans;\n\ninline int Find(int x) {\n\treturn mark[x] < t ? x : f[x] = Find(f[x]);\n}\n\ninline void Init() {\n\tmark[1] = cnt = ans = 0;\n\tf[1] = 1;\n\trepr(i, 2, n) {\n\t\tgetnum(f[i]);\n\t\tmark[i] = INF;\n\t}\n}\n\ninline void Solve() {\n\tchar op[2];\n\trepr(i, 1, q) {\n\t\tscanf(\"%s%d\", op, &x);\n\t\tif (op[0] == 'Q') {\n\t\t\tqt[cnt] = i;\n\t\t\tqv[cnt++] = x;\n\t\t}\n\t\telse mark[x] = min(mark[x], i);\n\t}\n\twhile (cnt) {\n\t\tt = qt[--cnt];\n\t\tans += Find(qv[cnt]);\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%d\", &n, &q) && (n || q)) {\n\t\tInit();\n\t\tSolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)K[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]] = 1;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M')UF.unite(a[K[i]], K[i]);\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\tsum += D; break;\n\t\t\t\t\t}\n\t\t\t\t\tD = a[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Marked Ancestor: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170\n// ????????????: 60???~\n// ?§£???: ?????¨???????????????????????´????????????????????¨??????????????????????????????????????£???????????£??????\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nstruct RecentMarkedTree {\n  vector<int> parents;\n  vector<int> checkers;\n\n  RecentMarkedTree(int n) : parents(n, 0), checkers(n, 0) { }\n\n  void mark(const vector<bool>& marked) {\n    vector<vector<int>> children(parents.size());\n\n    for(int i = 1; i < parents.size(); i++) {\n      children[parents[i]].push_back(i);\n    }\n\n    queue<pair<int, int>> que;\n    for(que.push(make_pair(0, 0)); !que.empty(); que.pop()) {\n      int p = que.front().first, c = que.front().second;\n\n      if(marked[p]) {\n        c = p;\n      }\n\n      checkers[p] = c;\n\n      for(auto child : children[p]) {\n        que.push(make_pair(child, c));\n      }\n    }\n  }\n\n  // return p's new parent;\n  int unmark(int p) {\n    if(checkers[p] == p) {\n      return checkers[p] = checkers[parents[p]];\n    } else {\n      return checkers[p] = unmark(parents[p]);\n    }\n  }\n};\n\nint main() {\n  for(int N, M; cin >> N >> M && N; ) {\n    RecentMarkedTree tree(N);\n\n    for(int i = 0; i < N - 1; i++) {\n      cin >> tree.parents[i];\n      tree.parents[i] -= 1;\n    }\n\n    vector<bool> marked(N, false);\n    vector<pair<char, int>> MQ;\n\n    for(int i = 0; i < M; i++) {\n      char c;\n      int num;\n\n      cin >> c >> num;\n\n      if(c == 'M') {\n        marked[num - 1] = true;\n      }\n\n      MQ.push_back(make_pair(c, num - 1));\n    }\n\n    tree.mark(marked);\n\n    reverse(MQ.begin(), MQ.end());\n\n    int answer = 0;\n\n    for(auto mq : MQ) {\n      if(mq.first == 'Q') {\n        answer += tree.checkers[mq.second];\n      } else {\n        tree.unmark(mq.second);\n      }\n    }\n\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nint N, Q;\nint parent[105000];\nchar Query[105000];\nint M[105000];\nint IsMarked[105000];\nll ans;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n    cin >> N >> Q;\n    if(N == 0) break;\n    for(int i = 1; i <= N; i++) {\n        IsMarked[i] = 1e9;\n    }\n    ans = 0;\n    for(int i = 2; i <= N; i++) {\n        cin >> parent[i];\n    }\n    IsMarked[1] = true;\n    for(int i = 1; i <= Q; i++) {\n        cin >> Query[i] >> M[i];\n        if(Query[i] == 'M') {\n            chmin(IsMarked[M[i]], i);\n        }\n    }\n    UnionFind uni(N + 1);\n    for(int i = 1; i <= N; i++) {\n        if(IsMarked[i] != 1e9) continue;\n        uni.merge(parent[i], i);\n    }\n    for(int q = Q; q >= 1; q--) {\n        if(Query[q] == 'M') {\n            if(IsMarked[M[q]] == q) uni.merge(parent[M[q]], M[q]);\n            continue;\n        } else {\n            ans += uni.root(M[q]);\n        }\n    }\n    cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[1] = true;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    marked[query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q;q--;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), {});\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto & ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it != ms.end()) return it->second;\n            else v = goUp(v);\n        }\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    h.prepare();\n    h.mark(0);\n    rep(i,q){\n        if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n        else h.mark(qv[i]);\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint par[MAX_N];\nint root;\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start){\n            if(used[start]==1) return ;\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++) dfs(child[start][i]);\n        }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        tmp.child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    tmp.used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if (a=='Q') {\n            //cout<<\"as\"<<tmp.mark[b-1]<<endl;\n            ans+=(tmp.mark[b-1]+1);\n        }\n        else {\n            root=b-1;\n            tmp.dfs(b-1);\n            tmp.used[b-1]=1;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< int > data;\n\tvector< int > lazy;\n\t\n\tSegmentTreeL(int _size, int _init) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tvoid lazy_calculation(int _k, int _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\tif (lazy[_k] != 0) data[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, int _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tint calculation(int _a, int _b) {\n\t\treturn min(_a, _b);\n\t}\n\t\n\tint query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tint query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return iINF;\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\tint res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t  query(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r) );\n\t\t\t\t\t\t\t \n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d, SegmentTreeL& stl) {\n\tint mn = iINF, mx = 0;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d, stl);\n\t\tmn = min(mn, res);\n\t\tmx = max(mx, res);\n\t}\n\t\n\tranges[v] = pii(mn, mx + 1);\n\t\n\t++d;\n\tnode_number[v] = d;\n\t\n\treturn d;\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d, stl);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q;\n\t\tint v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tif (rng.first == iINF) {\n\t\t\t\tint nn = node_number[v];\n\t\t\t\tstl.update(nn, nn + 1, v);\n\t\t\t} else {\n\t\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(x < y) swap(x, y);\n    par[x] = y, size[y] += size[x];\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  for(int N, Q; cin >> N >> Q && (N|Q);) {\n    vector<int> ps(N);\n    ps[0] = -1;\n    rep(i, N) {\n      int c; scanf(\"%d\", &c); c--;\n      ps[i + 1] = c;\n    }\n    set<pair<int, int>> st;\n    vector<pair<char, int>> qs;\n    rep(i, Q) {\n      char c; int x;\n      scanf(\"%c%d\\n\", &c, &x); x--;\n      if(c == 'M') {\n        st.insert({x, ps[x]});\n      }\n      qs.push_back({c, x});\n    }\n\n    tree::union_find uf(N);\n\n    rep(i, N) {\n      if(!st.count({i, ps[i]})) {\n        uf(i, ps[i]);\n      }\n    }\n\n    reverse(all(qs));\n\n    ll sum = 0;\n\n    rep(i, N) {\n      char c; int x; tie(c, x) = qs[i];\n      if(c == 'Q') {\n        sum += uf[x] + 1;\n      }\n      else {\n        uf(x, ps[x]);\n      }\n    }\n\n    printf(\"%lld\\n\", sum);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint N;\nint* marked_boss,*height;\n\nstruct Info{\n\tvector<int> Children;\n};\n\nInfo*info;\n\nvoid recursive(int id,int curren_boss_id,int new_marked_boss_id){\n\tfor(int i = 0; i < info[id].Children.size();i++){\n\t\tif(marked_boss[info[id].Children[i]] == curren_boss_id){\n\t\t\tmarked_boss[info[id].Children[i]] = new_marked_boss_id;\n\t\t\trecursive(info[new_marked_boss_id].Children[i],curren_boss_id,new_marked_boss_id);\n\t\t}\n\t}\n}\n\nvoid update(int new_marked_boss_id){\n\n\tint tmp = marked_boss[new_marked_boss_id];\n\n\tfor(int i = 0; i < info[new_marked_boss_id].Children.size();i++){\n\t\tif(marked_boss[info[new_marked_boss_id].Children[i]] == tmp){\n\t\t\tmarked_boss[info[new_marked_boss_id].Children[i]] = new_marked_boss_id;\n\t\t\trecursive(info[new_marked_boss_id].Children[i],tmp,new_marked_boss_id);\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint Q,value;\n\tchar buf[2];\n\tll ans;\n\n\tmarked_boss = new int[100001];\n\theight = new int[100001];\n\tinfo = (Info*)malloc(sizeof(Info)*(100001));\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif(N == 0 && Q == 0)break;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tmarked_boss[i] = 1;\n\t\t\theight[i] = 0;\n\t\t\tinfo[i].Children.clear();\n\t\t}\n\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\",&value);\n\t\t\tinfo[value].Children.push_back(i);\n\t\t}\n\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < Q; i++){\n\n\t\t\tscanf(\"%s %d\",buf,&value);\n\n\t\t\tif(buf[0] == 'Q'){\n\t\t\t\tans += marked_boss[value];\n\t\t\t}else{\n\t\t\t\tupdate(value);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nint parent[MAX_N+1];\nchar op[MAX_N+1];\nint node[MAX_N+1];\nbool marked[MAX_N+1];\n\nvoid init()\n{\n  marked[1] = true;\n  for (int i = 2; i <= N; i++)\n  {\n    marked[i] = false;\n  }\n}\n\nint find(int x)\n{\n  if (marked[x]) return x;\n  else return find(parent[x]);\n}\n\nint main()\n{\n  int ans = 0;\n\n  parent[1] = 1;\n\n  while(1)\n  {\n    cin >> N >> Q;\n    if (N == 0 && Q == 0)\n    {\n      printf(\"%d\\n\", ans);\n      return 0;\n    }\n    for(int i=2; i<=N; i++)\n    {\n      scanf(\"%d\", &parent[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n      cin >> op[i] >> node[i];\n    }\n\n    init();\n    for(int i = 0; i < Q; i++)\n    {\n      switch (op[i]) {\n      case 'Q':\n        ans += find(node[i]);\n        break;\n      case 'M':\n        marked[node[i]] = true;\n        break;\n      default:\n        break;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<iostream>\n#include<set>\n#include<cctype>\n#include<bitset>\n#define ShimaKZ 404 Not Found\n#define dec(a) memset(a,-1,sizeof(a))\n#define mem(a) memset(a,0,sizeof(a))\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define bug() cerr<<\"Surprise MotherFucker\"<<endl\n#define FOR(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;++i)\n#define SFOR(i,a,b) for(int i=(a),i##_end_=(b);i<i##_end_;++i)\n#define DOR(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;--i)\n#define y1 juiue\n#define y2 skjda\ntypedef long long ll;\ntemplate<class _> _ gcd(_ a,_ b) {return !b?a:gcd(b,a%b);}\ntemplate<class _,class __> bool checkmax(_ &a,__ b) {return a<b?a=b,true:false;}\ntemplate<class _,class __> bool checkmin(_ &a,__ b) {return a>b?a=b,true:false;}\ntemplate<class _> _ lcm(_ a,_ b) {return a*b/gcd(a,b);}\ntemplate<class _,class __> _ Mod(_ a,__ b) {return (a%b+b)%b;}\nusing namespace std;\n#define M 100086\nint Fa[M];\nint fa[M];\nvector<int>edge[M];\nbool mark[M];\nvoid Init(int n){FOR(i,1,n)Fa[i]=i;}\nint Find(int x){return x==Fa[x]?x:Fa[x]=Find(Fa[x]);}\nbool same(int x,int y){return Find(x)==Find(y);}\nvoid unite(int x,int y){Fa[Find(x)]=Find(y);}\nint n,m;\nstruct node{\n\tint op;\n\tint vetrix;\n}A[M<<1];\nint anc[M];\nint cnt[M];\n//void dfs(int x,int f,bool itself){\n//\tif(itself)anc[x]=anc[f];\n//\telse anc[x]=f;\n//\tSFOR(i,0,edge[x].size()){\n//\t\tint y=edge[x][i];\n//\t\tif(mark[y])dfs(y,y,1);\n//\t\telse dfs(y,f,0);\n//\t}\n//}\nvoid solve(){\n\tFOR(i,2,n)scanf(\"%d\",&fa[i]);\n\tfa[1]=1;\n\tmem(mark);\n\tmem(cnt);\n\tmark[1]=1;\n\tFOR(i,1,m){\n\t\tchar s[4];\n\t\tscanf(\"%s%d\",s,&A[i].vetrix);\n\t\tA[i].op=s[0]=='Q'?0:1;\n\t\tif(A[i].op){\n\t\t\tmark[A[i].vetrix]=true;\n\t\t\tcnt[A[i].vetrix]++;\n\t\t}\n\t}\n\tFOR(i,1,n)if(!mark[i])A[++m].vetrix=i,A[m].op=1,cnt[i]++;\n\tll ans=0;\n\tInit(n);\n\tDOR(i,m,1){\n\t\tif(A[i].op){\n\t\t\tif(!same(A[i].vetrix,fa[A[i].vetrix])&&!--cnt[A[i].vetrix]==1)unite(A[i].vetrix,fa[A[i].vetrix]);}\n\t\telse ans+=Find(A[i].vetrix);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m)){\n\t\tif(!n&&!m)return EXIT_SUCCESS;\n\t\tsolve();\n\t}\n\treturn EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nbool flag[MAX_N];\nint ran[MAX_N];\nvoid init(int n) {\n\tfor(int i=2; i<=n; i++) {\t\t\n\t\tflag[i] = false;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif(flag[par[x]])\n\t\treturn par[x];\n\telse\n\t\tfind(par[x]);\n}\n\nvoid unite(int x,int y) {\n\tx = find(x);\n\ty = find(y);\n\n\tif(x==y) return;\n\n\tif(ran[x]<ran[y]) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif(ran[x]==ran[y]) ran[x]++;\n\t}\n}\n\nbool same(int x,int y) {\n\treturn find(x)==find(y);\n}\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tint sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tflag[1] = true;\n\t\tinit(n);\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(p);\n\t\t\t}else{\n\t\t\t\tflag[p] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define MAXN 110930\nusing namespace std;\n\nint n,Q;\nint FA[MAXN],fa[MAXN],Mark[MAXN];\nint QES[MAXN],FLAG[MAXN],Cnt=0;\n\nchar ch[12];\nlong long ANS=0;\n\nint FIND(int x)\n{\n\tif(!fa[x]) fa[x]=FIND(FA[x]);\n\treturn fa[x];\n}\nint find(int x)\n{\n\tif(fa[x]!=x) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid readin();\nvoid work();\nvoid print();\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&Q); \n\treadin();\n\twork();\n\tprint();\n\treturn 0;\n}\n\nvoid readin()\n{\n\tif(!n&&!Q) exit(0);\n\tfor(int i=2;i<=n;i++)\n\t\tscanf(\"%d\",&FA[i]);\n\tFA[1]=fa[1]=1;\n\tint x;\n\tfor(int i=1;i<=Q;i++)\n\t{\n\t\tscanf(\"%s%d\",ch,&x);\n\t\tif(ch[0]=='Q')\n\t\t{\n\t\t\tQES[++Cnt]=x;\n\t\t\tFLAG[Cnt]=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(fa[x]) continue;\n\t\t\tQES[++Cnt]=x;\n\t\t\tfa[x]=x;\n\t\t}\n\t}\n}\nvoid work()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tif(!fa[i]) fa[i]=FIND(i);\n\n\tfor(int i=Cnt;i;i--)\n\t{\n\t\tif(FLAG[i])\n\t\t\tANS+=find(QES[i]);\n\t\telse\n\t\t\tfa[QES[i]]=FA[QES[i]];\n\t}\n}\nvoid print()\n{\n\tprintf(\"%lld\",ANS);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\nusing namespace std;\n\nconst int DEPTH = 18;\nclass RUQ\n{\n\tint value[1 << (DEPTH + 1)];\n\tint t[1 << (DEPTH + 1)];\npublic:\n\tRUQ() {\n\t\tfor (int i = 0; i < (1 << (DEPTH + 1)); i++) {\n\t\t\tvalue[i] = 0;\n\t\t\tt[i] = -1;\n\t\t}\n\t}\n\t\n\tvoid update(int l, int r, int v, int t, int a = 0, int b = (1 << DEPTH), int id = 0) {\n\t\tif (l >= b || r <= a) return;\n\t\tif (l <= a && b <= r) {\n\t\t\tvalue[id] = v;\n\t\t\tthis->t[id] = t;\n\t\t\treturn;\n\t\t}\n\t\tupdate(l, r, v, t, a, a + (b - a) / 2, id * 2 + 1);\n\t\tupdate(l, r, v, t, a + (b - a) / 2, b, id * 2 + 2);\n\t}\n\t\n\tint getValue(int id) {\n\t\tid = (1 << DEPTH) - 1 + id;\n\t\tint newestId = id;\n\t\twhile (id > 0) {\n\t\t\tid = (id - 1) / 2;\n\t\t\tif (t[id] > t[newestId]) newestId = id;\n\t\t}\n\t\treturn value[newestId];\n\t}\n};\n\nint n, q;\nvector<int> et[100000];\t\t//et[i][j] = ??????i??¨??????et[i][j]??????????????£?????????\nint ord[100000];\t\t\t//ord[i] = ??????i??????????????????(0-indexed)\nint Size[100000];\t\t\t//Size[i] = ??????i????????¨????????¨?????¨????????????\nint ordInv[100000];\t\t\t//ordInv[i] = ??????????????????i??????????????????\nRUQ seg;\n\nint dfs(int p, int v, int id) {\n\tint ret = 0;\n\t\n\tord[v] = id;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tint subSize = dfs(v, et[v][i], id + ret + 1);\n\t\tret += subSize;\n\t}\n\tret++;\n\treturn Size[v] = ret;\n}\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) et[i].clear();\n\tseg.update(0, n, 0, -1);\n}\n\nsigned main() {\n\tint i;\n\t\n\twhile (cin >> n >> q) {\n\t\tif (!n) break;\n\t\tinit(n);\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tint p; cin >> p; p--;\n\t\t\tet[p].push_back(i);\n\t\t}\n\t\tdfs(-1, 0, 0);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tordInv[ord[i]] = i;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (i = 0; i < q; i++) {\n\t\t\tchar com; int v;\n\t\t\tcin >> com >> v; v--;\n\t\t\tif (com == 'Q') {\n\t\t\t\tans += ordInv[seg.getValue(ord[v])] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tseg.update(ord[v], ord[v] + Size[v], ord[v], i);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\tarr[1].isMarked = true;\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tarr[_index].isMarked = true;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tupdateNearest(itr,_index);\n\t\t}\n\t}\n\tvoid updateNearest(int _index,int _parent_index)\n\t{\n\t\tarr[_index].nearest_index = _parent_index;\n\t\tif (arr[_index].isMarked == false)\n\t\t{\n\t\t\tfor (auto itr : arr[_index].c)\n\t\t\t{\n\t\t\t\tupdateNearest(itr, _parent_index);\n\t\t\t}\n\t\t}\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 100000;\nint p[MAX_N + 10];\nint n, t;\nll ans;\n\nint find(int a) {\n    return p[a] == a ? a : find(p[a]);\n}\n\nvoid unite(int a, int b) {\n    int pa = find(a), pb = find(b);\n    if(pa != pb) p[pa] = pb;\n}\n\nint main() {\n    while(scanf(\"%d%d\", &n, &t) && n && t) {\n        for(int i = 1; i < n; i++) {\n            scanf(\"%d\", &p[i+1]);\n        }\n        p[1] = 1;\n        char op[3];\n        int id;\n        ans = 0;\n        while(t--) {\n            scanf(\"%s%d\", op, &id);\n            if(op[0] == 'M') {\n                p[id] = id;\n            } else {\n                ans += (ll)find(id);\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nll sum;\nint find(int x,int flag){\n    if(flag)    return 0;\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                if(vis[t])  sum+=t;\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\nconst int MAX_V = 100010;\n\nstruct UF{\n   vector<int> par;\n   UF(int n){\n       par.resize(n, -1);\n   }\n   int find(int x){\n        if(par[x] < 0) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       par[y] = x;\n   }\n};\n\nint p[MAX_V];\nbool marked[MAX_V];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, q;\n    while(cin >> n >> q && n){\n        memset(marked, false, sizeof(marked));\n        marked[0] = true;  \n        UF uf(n);           \n        vector<char> c(q); \n        vector<int> v(q);           \n        vector<bool> use(q); \n        rep(i, 1, n){\n            cin >> p[i]; p[i]--;\n        }\n        rep(i, 0, q){\n            cin >> c[i] >> v[i]; v[i]--;\n            if(c[i] == 'M' && marked[v[i]] == false){\n                marked[v[i]] = true;\n                use[i] = true;\n            }\n        }\n        int ans = 0;\n        rep(i, 0, n){\n            if(!marked[i]){\n                uf.unite(p[i], i);\n            }\n        }\n        for(int i = q - 1; i >= 0; i--){\n            if(c[i] == 'M'){\n                if(use[i]) uf.unite(p[v[i]], v[i]);\n            }else{\n                ans += uf.find(v[i]) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX_N 100005\nint par[MAX_N];\nbool flag[MAX_N];\nint ran[MAX_N];\nvoid init(int n) {\n\tfor(int i=2; i<=n; i++) {\t\t\n\t\tflag[i] = false;\n\t\tran[i] = 0;\n\t}\n}\nint find(int x) {\n\tif(flag[x])\n\t\treturn x;\n\telse\n\t\tfind(par[x]);\n}\n\n\n\nint main(){\n\tint n,q;\n\twhile(true){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0&&q==0) break;\n\t\tint x;\n\t\tlong long sum=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\t\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpar[i] = x;\n\t\t}\n\t\tpar[1]= 1;\n\t\tflag[1] = true;\n\t\tinit(n);\n\t\t\n\t\tgetchar();\n\t\tchar c;\n\t\tint p;\n\t\twhile(q--){\n\t\t\tscanf(\"%c%d%*c\",&c,&p);\n\t\t\tif(c=='Q'){\n\t\t\t\tsum+=find(par[p]);\n\t\t\t}else{\n\t\t\t\tflag[p] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = (1<<17);\n\nclass RMQ{\n  int n,dat[2*MAX_N-1];\n\npublic:\n  void init(int _n = MAX_N){ \n    n = 1;\n    while(n < _n) n *= 2;\n    fill(dat,dat+2*n-1,1);\n  }\n\n  int get(int k){\n    k += n - 1;\n    int ret = dat[k];\n    while(k > 0){\n      k = (k - 1) / 2;\n      ret = max( ret, dat[k] );\n    }\n    return ret;\n  }\n\n  void query(int a, int b,int x){ query(a, b, x, 0, 0, n);}\n  int query(int a, int b, int x, int k, int l, int r){\n    if(r <= a || b <= l) return 0;\n    if(a <= l && r <= b) return dat[k]=max(dat[k],x);\n    else{\n      int vl = query(a, b, x, k*2+1, l, (l+r)/2);\n      int vr = query(a, b, x, k*2+2, (l+r)/2, r);\n      return min(vl,vr);\n    }\n  }\n};\n\nRMQ seg;\nvector<int> G[100003];\nint L[100003];\nint R[100003];\nint cnt;\nvoid dfs(int id){\n  L[id] = cnt++; \n  for(int i=0;i<(int)G[id].size();i++){\n    dfs(G[id][i]);\n  }\n  R[id] = cnt;\n}\n\nint main(){\n  int n,q;\n  while(cin >> n >> q && (n||q) ){\n    seg.init(n+1);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=2;i<=n;i++){\n      int p; cin >> p;\n      G[p].push_back( i );\n    }\n    cnt = 0;\n    dfs(1);\n    long long res = 0;\n    for(int i=0;i<q;i++){\n      char c; cin >> c;\n      int d; cin >> d;\n      if( c  == 'Q' ){\n\tres += (long long)seg.get(L[d]);\n      } else {\n\tseg.query(L[d],R[d],d);\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        if(x > y) swap(x, y);\n        // y を x に統合 (数字の小さい方に合わせる)\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nvoid init(int root, int val) {\n    for(size_t i=0; i<G[root].size(); i++) {\n        int to = G[root][i];\n        if(to == root) continue;\n        if(mark[to]) init(to, to);\n        else {\n            uf.unite(root, to);\n            init(to, val);\n        }\n    }\n}\n\nvoid debug() {\n    /*\n    for(int i=0; i<N; i++) {\n        printf(\"node %d: root = %d\\n\", i+1, uf.find(i) + 1);\n    }\n    */\n}\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n        init(0, 0);\n        debug();\n\n        ll ans = 0;\n        for(int i=0; i<Q; i++) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n            debug();\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\n\n\nstruct node{\n  bool marked;\n  int parent;\n  int num;\n};\n\nint main(){\n  while(1){\n    vector<node> T;\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    if(n==0&&q==0){\n      return 0;\n    }\n\n    node root;\n    root.marked = true;\n    root.parent = 0;\n    root.num = 1;\n    T.push_back(root);\n    for(int i=2;i<n+1;i++){\n      int parent;\n      cin >> parent;\n      node child;\n      T.push_back(child);\n      T[i-1].marked = false;\n      T[i-1].num = i;\n      T[i-1].parent = parent-1;\n    }\n\n    int sum = 0;\n    for(int i=0;i<q;i++){\n      char q;\n      int v;\n      cin >> q >> v;\n      if(q=='M'){\n        T[v-1].marked = true;\n      }\n      if(q=='Q'){\n        node n = T[v-1];\n        while(!n.marked){\n          n = T[n.parent];\n        }\n        sum += n.num;\n      }\n    }\n    cout << sum << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define SIZE 100010\n\ntypedef struct Node\n{\n\tint father;\n\tint ancester;\n\tstd::vector<int> childs;\n} Node;\n\nNode node[SIZE];\n\nvoid mark(int num)\n{\n\tstd::queue<int> q;\n\tq.push(num);\n\twhile (!q.empty())\n\t{\n\t\tint n = q.front();\n\t\tq.pop();\n\t\tif (node[n].ancester == n)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tnode[n].ancester = num;\n\t\tfor (std::vector<int>::iterator it = node[n].childs.begin(); it != node[n].childs.end(); ++it)\n\t\t{\n\t\t\tq.push(*it);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint count, order_count;\n\twhile (scanf(\"%d%d\", &count, &order_count), !(count == 0 && order_count == 0))\n\t{\n\t\tint sum = 0;\n\t\tint father;\n\t\tfor (int i = 1; i <= count; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &father);\n\t\t\tnode[i].father = father;\n\t\t\tnode[i].ancester = 1;\n\t\t\tnode[father].childs.push_back(i);\n\t\t\tnode[i].childs.clear();\n\t\t}\n\t\tchar ch;\n\t\tint num;\n\t\twhile (order_count--)\n\t\t{\n\t\t\tscanf(\"%c %d\", &ch, &num);\n\t\t\tgetchar();\n\t\t\tif (ch == 'Q')\n\t\t\t{\n\t\t\t\tsum += node[num].ancester;\n\t\t\t}\n\t\t\telse if (ch == 'M')\n\t\t\t{\n\t\t\t\tmark(num);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define MAXN 100005\nint Set[MAXN];\nint Root(int x)\n{return Set[x]==x?x:Set[x]=Root(Set[x]);}\nint N,Q;\nint fa[MAXN];\nint Que[MAXN][2];\nint marked[MAXN];\nint main()\n{\n\tchar op[3];\n\tint id;\n\tlong long ans;\n\twhile(~scanf(\"%d%d\",&N,&Q)&&N&&Q)\n\t{\n\t\tmemset(Que,0,sizeof Que);\n\t\tmemset(fa,0,sizeof fa);\n\t\tmemset(Set,0,sizeof Set);\n\t\tmemset(marked,0,sizeof marked);\n\t\tans=0;\n\t\tSet[1]=1;fa[1]=1;\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",fa+i);\n\t\t\tSet[i]=fa[i];\n\t\t}\n\t\tfor(int i=1;i<=Q;i++)\n\t\t{\n\t\t\tscanf(\"%s%d\",op,&id);\n\t\t\tif(op[0]=='Q')Que[i][0]=1;\n\t\t\telse {Que[i][0]=2;Set[id]=id;marked[id]++;}\n\t\t\tQue[i][1]=id;\n\t\t}\n\t\tfor(int i=Q;i>=1;i--)\n\t\t{\n\t\t\tif(Que[i][0]==1)\n\t\t\t\tans+=1LL*Root(Que[i][1]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarked[Que[i][1]]--;\n\t\t\t\tif(!marked[Que[i][1]])\n\t\t\t\t\tSet[Que[i][1]]=fa[Que[i][1]];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\nvector <ll> par;\nvector <bool> ism;\n\nvoid solve(void){\n\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\treverse(all(q));\n\n\t\trep(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (!ism[par[q[i].snd]]) {\n\t\t\t\tpar[q[i].snd] = par[par[q[i].snd]];\n\t\t\t}\n\t\t\tans += par[q[i].snd] + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tint index = -1;\n\tint parent_index = -1;\n\tint nearest_index = 1;\n\tbool isMarked = false;\n\tvector<int> c;\n};\n\nclass Tree\n{\npublic:\n\tTree()\n\t{\n\t\tarr = new Node[100002];\n\t\toperationM(1);\n\t}\n\t~Tree()\n\t{\n\t\tdelete [] arr;\n\t}\n\tvoid addNode(int _index, int _parent_index)\n\t{\n\t\tarr[_index].index = _index;\n\t\tarr[_index].parent_index = _parent_index;\n\t\tarr[_parent_index].c.push_back(_index);\n\t}\n\tvoid operationM(int _index)\n\t{\n\t\tif (arr[_index].isMarked == true)return;\n\t\tarr[_index].isMarked = true;\n\t\tarr[_index].nearest_index = _index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tif (arr[itr].isMarked == false)updateNearest(itr, _index);\n\t\t}\n\t}\n\tvoid updateNearest(int _index,int _nearest_index)\n\t{\n\t\tarr[_index].nearest_index = _nearest_index;\n\t\tfor (auto itr : arr[_index].c)\n\t\t{\n\t\t\tif (arr[itr].isMarked == false)updateNearest(itr, _nearest_index);\n\t\t}\n\t}\n\tint operationQ(int _index)\n\t{\n\t\treturn arr[_index].nearest_index;\n\t}\n\tNode* arr;\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint N, Q, ans = 0;\n\t\tTree tree;\n\t\tcin >> N >> Q;\n\t\tif (N == 0)break;\n\t\tfor (unsigned int i = 2; i < N + 1; i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\ttree.addNode(i, p);\n\t\t}\n\t\tfor (unsigned int i = 0; i < Q; i++)\n\t\t{\n\t\t\tchar qes;\n\t\t\tint index;\n\t\t\tcin >> qes >> index;\n\t\t\tif (qes == 'Q')ans += tree.operationQ(index);\n\t\t\telse tree.operationM(index);\n\t\t}\n\t\tint hoge;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace  std;\nconst int maxn = 1e5 + 5;\nint f[maxn];\nint p[maxn];\n\nvector<int> mp[maxn];\ntypedef long long ll;\nvoid init(int n)\n{\n    for (int i = 1; i <= n; i ++) {\n        f[i] = 1;//\n        mp[i].clear();\n    }\n}\nint find(int x)\n{\n    if(x == 1) return 1;\n    if(f[p[x]] == p[x]) return p[x];//如果f[x]是根\n    else return find(p[x]);\n}\nvoid update(int x)\n{\n    f[x] = x;\n}\nint main()\n{\n    int n,q;\n    while (scanf(\"%d%d\",&n,&q) != EOF) {\n        if(n == 0 && q == 0) break;\n        init(n);\n        int a;\n        for (int i = 2; i <= n; i ++) {\n            scanf(\"%d\",&a);\n            mp[a].push_back(i);\n            mp[i].push_back(a);\n            p[i] = a;\n        }\n        getchar();\n        char op;\n        int v;\n        ll sum = 0;\n        for (int i = 0; i < q; i ++) {\n            scanf(\"%c%d\",&op,&v);\n            if(op == 'M'){\n                update(v);\n             }\n            else{\n//                int t = find(v);\n//                sum += 1ll * t;\n//                printf(\"%d %d\\n\",v,t);\n             sum += 1ll * find(v);\n            }\n            getchar();\n        }\n        printf(\"%lld\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nvector<int> p[MAX_N];\nint pp[MAX_N];\nint par[MAX_N];\nchar c[MAX_N];\nint num[MAX_N];\nint a[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tpar[y] = x;\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nvoid dfs(int v,int anc)\n{\n\tif(a[v]==1){\n\t\trep(i,p[v].size()){\n\t\t\tdfs(p[v][i],v);\n\t\t}\n\t}else{\n\t\tunite(anc,v);\n\t\trep(i,p[v].size()){\n\t\t\tdfs(p[v][i],anc);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n,q;\n\t\tcin >> n >> q;\n\t\tif(n==0&&q==0){\n\t\t\tbreak;\n\t\t}\n\t\trep(i,n){\n\t\t\tp[i].clear();\n\t\t}\n\t\trep(i,n-1){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tp[x-1].push_back(i+1);\n\t\t\tpp[i+1] = x-1;\n\t\t}\n\t\tinitial(n);\n\t\tfill(a,a+n,0);\n\t\ta[0] = 1;\n\t\trep(i,q){\n\t\t\tcin >> c[i] >> num[i];\n\t\t\tif(c[i]=='M'){\n\t\t\t\ta[num[i]-1] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(0,0);\n\t\tll ans = 0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tif(c[i] == 'M'){\n\t\t\t\tunite(pp[num[i]-1],num[i]-1);\n\t\t\t}else{\n\t\t\t\tans += find(num[i]-1)+1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nint parent[MAX_N+1];\nchar op[MAX_N+1];\nint node[MAX_N+1];\nbool marked[MAX_N+1];\n\nvoid init()\n{\n  marked[1] = true;\n  for (int i = 2; i <= N; i++)\n  {\n    marked[i] = false;\n  }\n}\n\nint find(int x)\n{\n  if (marked[x]) return x;\n  else return find(parent[x]);\n}\n\nint main()\n{\n  parent[1] = 1;\n\n  while(1)\n  {\n    cin >> N >> Q;\n    if (N == 0 && Q == 0)\n    {\n      return 0;\n    }\n\n    init();\n\n    for(int i=2; i<=N; i++)\n    {\n      scanf(\"%d\", &parent[i]);\n    }\n\n    for(int i = 0; i < Q; i++){\n      cin >> op[i] >> node[i];\n    }\n\n    long long ans = 0;\n    for(int i = 0; i < Q; i++)\n    {\n      switch (op[i]) {\n      case 'Q':\n        ans += find(node[i]);\n        break;\n      case 'M':\n        marked[node[i]] = true;\n        break;\n      default:\n        break;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int maxn = 100005;\nint tree[maxn];\nbool ar[maxn];\ntypedef pair<char,int> P;\nP query[maxn];\nint get(int i)\n{\n\tif(ar[i])return i;\n\treturn tree[i] = get(tree[i]);\n}\nint main()\n{\n\tint n,q;\n\twhile(scanf(\"%d%d\",&n,&q),n|q){\n\t\tmemset(ar,0,sizeof(ar));\n\t\tar[1] = true;\n\t\tfor(int i = 2;i<=n;i++)\n\t\t\tscanf(\"%d\",&tree[i]);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tscanf(\" %c%d\",&query[i].first,&query[i].second);\n\t\tfor(int i = 0;i<q;i++)\n\t\t\tif(query[i].first=='M')\n\t\t\t\tar[query[i].second] = 1;\n\t\tlong long sum = 0;\n\t\tfor(int i = q-1;i>=0;i--)\n\t\t\tif(query[i].first=='M')ar[query[i].second] = 0;\n\t\t\telse sum += get(query[i].second);\n\t\tprintf(\"%lld\\n\",sum);\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nbool mark[101010];\nint g[101010];\n\nint dfs(int s) {\n        return mark[s] ? s : dfs(g[s]);\n}\n\nint main() {\n        int n, q;\n        while (cin >> n >> q && n) {\n                for (int i = 1; i < n; i ++) {\n                        int p;\n                        cin >> p;\n                        p --;\n                        g[i] = p;\n                }\n                mark[0] = true;\n                long long ans = 0;\n                rep(i, q) {\n                        char s;\n                        int v;\n                        cin >> s >> v;\n                        v --;\n                        if (s == 'M') mark[v] = true;\n                        else ans += dfs(v) + 1;\n                }\n                cout << ans << endl;\n        }\n}\n\n//#define int long long\n//\n//struct query {\n//        char s;\n//        int node;\n//};\n//\n//struct state {\n//        int d;\n//        int timing;\n//        int node;\n//        bool operator < (const state& r) const { return d < r.d; }\n//        bool operator > (const state& r) const { return d > r.d; }\n//};\n//\n//vector<int> depth;\n//vector<vector<int> > g;\n//vector<bool> used;\n//vector<int> mark;\n//vector<priority_queue<state>> st;\n//vector<query> v;\n//\n//void depth_init_dfs(int s, int d) {\n//        depth[s] = d;\n//        for (auto v : g[s]) if (!used[v]) { \n//                used[v] = true;\n//                depth_init_dfs(v, d + 1);\n//        }\n//}\n//\n//void dfs(int s) {\n//        if (mark[s] != -1) {\n//                priority_queue<state> tmp;\n//                tmp = st[s];\n//                tmp.push({depth[s], mark[s], s + 1});\n//                for (auto v : g[s]) if (!used[v]) {\n//                        used[v] = true;\n//                        st[v] = tmp;\n//                        dfs(v);\n//                }\n//        } else {\n//                for (auto v : g[s]) if (!used[v]) {\n//                        used[v] = true;\n//                        st[v] = st[s];\n//                        dfs(v);\n//                }\n//        }\n//}\n//\n//signed main() {\n//        int n, q;\n//        while (true) {\n//                cin >> n >> q;\n//                if (n == 0 && q == 0) break;\n//                cerr << n << ' ' <<  q << endl;\n//                v.clear();\n//                v.resize(q);\n//                g.clear();\n//                g.resize(n);\n//                rep(i, n - 1) {\n//                        int p;\n//                        cin >> p;\n//                        p --;\n//                        g[p].push_back(i + 1);\n//                }\n//                rep(i, q) {\n//                        cin >> v[i].s >> v[i].node;\n//                        v[i].node --;\n//                }\n//                depth.clear();\n//                depth.resize(n);\n//                used.clear();\n//                used.resize(n, false);\n//                used[0] = true;\n//                depth_init_dfs(0, 0);\n//                //rep(i, n) {\n//                //        cout << depth[i] << ' ' << i << endl;\n//                //}\n//                mark.clear();\n//                mark.resize(n, -1);\n//                mark[0] = 0;\n//                rep(i, q) {\n//                        if (v[i].s == 'M') {\n//                                mark[v[i].node] = i + 1;\n//                        }\n//                }\n//                st.clear();\n//                st.resize(n);\n//                used.clear();\n//                used.resize(n, false);\n//                st[0].push({0, 0, 1});\n//                dfs(0);\n//                //rep(i, n) {\n//                //        state s = st[i].top();\n//                //        cout << s.d << ' ' << s.timing << ' ' << s.node << endl;\n//                //}\n//                int ans = 0;\n//                for (int i = q - 1; i >= 0; i --) {\n//                        if (v[i].s == 'Q') {\n//                                while (!st[v[i].node].empty()) {\n//                                        if (i < st[v[i].node].top().timing < i + 1) {\n//                                                ans += st[v[i].node].top().node;\n//                                                break;\n//                                        }\n//                                        st[v[i].node].pop();\n//                                }\n//                        }\n//                }\n//                cout << ans << endl;\n//        }\n//        return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M;\nint par [100001];\nint root [100001];\n\nint find(int x)\n{\n\tif(root [x] == x) return x;\n\treturn root [x] = find(root [x]);\n}\n\nvoid unite(int x,int y)\n{\n\tx = find(x); y = find(y);\n\troot [y] = x;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&M) && N){\n\t\tFOR(i,2,N + 1){\n\t\t\tint u;\n\t\t\tscanf(\"%d\",&u);\n\t\t\tpar [i] = u;\n\t\t}\n\t\tpar [1] = 1;\n\t\tvector< pair<int,int> > qy(M);\n\t\tdeque<bool> d(N + 1);\n\t\tFOR(i,0,M){\n\t\t\tchar str [20];\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\",str,&x);\n\t\t\tif(str [0] == 'M' && d [x]) continue;\n\t\t\tif(str [0] == 'M'){\n\t\t\t\td [x] = true;\n\t\t\t}\n\t\t\tqy [i] = make_pair(x,str [0] == 'Q');\n\t\t}\n\t\tFOR(i,2,N + 1) if(d [i] == false){\n\t\t\tqy.push_back(make_pair(i,0));\n\t\t}\n\t\treverse(qy.begin(),qy.end());\n\t\tll ans = 0;\n\t\tfor(int i = 1;i <= N;i++){\n\t\t\troot [i] = i;\n\t\t}\n\t\tFOR(i,0,qy.size()){\n\t\t\tif(qy [i].second == 0){\n\t\t\t\tunite(par [qy [i].first],qy [i].first);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += find(qy [i].first);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nint par[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tpar[x] = y;\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n); int par0[100000] = {}; int marked[100000] = {}; marked[0] = 1;\n\t\trep(i, n-1) {\n\t\t\tcin >> par0[i+1];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b; b--;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par0[i]);\n\t\t\t}\n\t\t}\n\t\tll out = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par0[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      if(num != 0){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\ntypedef long long ll;\n\nint tpar[100000],par[100000];\nbool mark[100000];\nint search(int a){\n    if(mark[a]) return a;\n    else return search(tpar[a]);\n}\nint find(int a){\n    if(par[a]==a) return a;\n    else return par[a]=find(par[a]);\n}\nvoid unite(int a,int b){\n    par[find(a)]=find(b);\n}\nint main(){\n    int N,Q;\n    for(;;){\n        scanf(\"%d %d\\n\",&N,&Q);\n        if(N==0 && Q==0) break;\n        tpar[0]=0;\n        int p;\n        for(int i=1;i<N;i++){\n            scanf(\"%d\\n\",&p);\n            tpar[i]=p-1;\n        }\n        fill(mark,mark+N,false);\n        mark[0]=true;\n        char q;\n        int a;\n        vector<pair<char,int>> query;\n        for(int i=0;i<Q;i++){\n            scanf(\"%c %d\\n\",&q,&a);\n            a--;\n            query.PB(MP(q,a));\n            if(q=='M') mark[a]=true;\n        }\n        for(int i=0;i<N;i++){\n            par[i]=search(i);\n        }\n        ll ans=0;\n        for(int i=Q-1;i>=0;i--){\n            int now=query[i].second;\n            if(query[i].first=='Q') ans+=find(now)+1;\n            else unite(now,tpar[find(now)]);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nlong long pre[100005];\nlong long find_root(long long x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    long long n, q;\n    while(scanf(\"%lld%lld\", &n, &q) != EOF)\n    {\n        pre[1] = 1;\n        for(long long i = 2; i <= n; i++)\n            scanf(\"%lld\", &pre[i]);\n        char a;\n        long long b;\n        long long ans = 0ll;\n        while(scanf(\" %c%lld\", &a, &b), a != '0')\n        {\n            if(a == 'Q')\n                ans += find_root(b);\n            else\n                pre[b] = b;\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\n\ntemplate<class T>\nstruct Vector{\n\tint sz,cap;\n\tT *p;\n\tVector():sz(0),cap(0),p(0){}\n\t~Vector(){\n\t\tclear();\n\t}\n\tvoid swap(Vector &v){\n\t\tstd::swap(sz,v.sz);\n\t\tstd::swap(cap,v.cap);\n\t\tstd::swap(p,v.p);\n\t}\n\tint size()const{return sz;}\n\tbool empty()const{return !sz;}\n\tT& back()const{\n\t\treturn p[sz-1];\n\t}\n\tvoid push_back(T v){\n\t\tif(sz==cap)reserve(sz?sz*2:1);\n\t\tnew(p+sz++) T(v);\n\t}\n\tvoid pop_back(){\n\t\tp[--sz].~T();\n\t\tif(sz&&sz*4<cap){\n\t\t\treserve(cap/2);\n\t\t}\n\t}\n\tvoid resize(int n){\n\t\tclear();\n\t\tif(n==0)return;\n\t\tcap=1;\n\t\twhile(cap<n)cap*=2;\n\t\treserve(cap);\n\t\tfor(int i=0;i<n;i++)new(p+i) T();\n\t\tsz=n;\n\t}\n\tvoid reserve(int n){\n\t\tT *p=(T*)operator new(n*sizeof(T));\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tnew(p+i) T(this->p[i]);\n\t\t\tp[i].~T();\n\t\t}\n\t\tif(this->p)operator delete(this->p);\n\t\tthis->p=p;\n\t\tcap=n;\n\t}\n\tvoid clear(){\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tp[i].~T();\n\t\t}\n\t\tif(p)operator delete(p);\n\t\tsz=cap=0;\n\t\tp=0;\n\t}\n\tT& operator[](int i)const{\n\t\treturn p[i];\n\t}\n};\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tVector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tVector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.clear();\n\t}\n\t//O(log n)\n\tvoid push(T &v){\n\t\timax=-1;\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].push(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    rank = vector<int>(n, 0);\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n  vector<int> rank;\n};\n\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nvoid dfs(int idx, int par) {\n  if (marked[idx]) {\n    par = idx;\n  } else {\n    tree.unite(par, idx);\n  }\n  for (int i = 0; i < G[idx].size(); i++) {\n    dfs(G[idx][i], par);\n  }\n}\n\nint solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  marked = vector<bool>(N);\n  marked[0] = true;\n  for (int i = 0; i < queries.size(); i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n  tree = UnionFindTree(N);\n  dfs(0, -1);\n\n  int res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (strcmp(buf, \"Q\") == 0) {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    int ans = solve(N, Q, parent, queries);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iostream>\n\nusing namespace std;\n\nstruct op\n{\n\tchar s; int v;\n};\n\nint t[100010];\nint f[100010];\nint p[100010];\nop r[100010];\nint n, q, v;\nlong long o = 0;\nop x;\n\nint query(int x)\n{\n\tint i;\n\tfor (i = 0;; i++)\n\t{\n\t\tf[i] = x;\n\t\tif (t[x] == x)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tx = t[x];\n\t}\n\tfor (int j = i; j >= 0; j--)\n\t{\n\t\tt[f[j]] = x;\n\t}\n\treturn x;\n}\n\nvoid mark(int x)\n{\n    p[x]=t[x];\n\tt[x] = x;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tt[0] = 0;\n\twhile (1)\n\t{\n\t\tcin >> n >> q;\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i<n; i++)\n\t\t{\n\t\t\tcin >> v;\n\t\t\tt[i] = v - 1;\n\t\t}\n\t\tint i;\n\t\tfor (i = 0; i<q; i++)\n\t\t{\n\t\t\tcin >> x.s >> x.v;\n\t\t\tif (x.s == 'Q')\n\t\t\t{\n\t\t\t\tr[i] = x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = x.v - 1;\n\t\t\t\tif (t[v] == v) \n\t\t\t\t{\n\t\t\t\t\ti-=1;\n\t\t\t\t\tq -= 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmark(v);\n\t\t\t\tr[i] = x;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i-1; j >= 0; j--)\n\t\t{\n\t\t\tv = r[j].v - 1;\n\t\t\tif (r[j].s == 'M')\n\t\t\t{\n\t\t\t\tt[v] = p[v];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to += query(v);\n\t\t\t\to += 1;\n\t\t\t}\n\t\t}\n\t\tcout << o << endl;\n\t\to = 0;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tscanf(\"%d%d\", &n, &q);\n//\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[1] = true;\n\tfor(int i = 1;i < n;i++){\n\t    cin >> root[i];\n\t    root[i]--;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    query[i].second--;\n\t    marked[query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q;i-- > 0;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second) + 1;\n\t    }\n\t}\n\tprintf(\"%lld\\n\", res);\n//\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define maxn 100005\nusing namespace std;\n\nint pre[maxn],rank[maxn],vis[maxn];\n\nvoid init(int n)\n{\n    int i;\n    for(i=1;i<=n;i++)\n    {\n        pre[i]=i;\n        rank[i]=1;\n    }\n}\n\nint find(int x)\n{\n\n    while(!vis[x])\n        x=pre[x];\n\n    return x;\n}\n\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF && (n||m))\n    {\n        memset(vis,0,sizeof(vis));\n        init(n);\n        for(int i=2;i<=n;i++)\n        {\n            int fat;\n            scanf(\"%d\",&fat);\n            pre[i]=fat;\n        }\n\n        int ans=0;\n        vis[1]=1;\n        while(m--)\n        {\n            char str[2];\n            int x;\n            scanf(\"%s%d\",str,&x);\n            if(str[0]=='Q')\n            ans+=find(x);\n            else\n            {\n                vis[x]=1;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\nstruct UnionFindTree {\n  vector<int> par, rank;\n  UnionFindTree(int n) {\n    par.reserve(n);\n    rank.reserve(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int i) {\n    if (par[i] == i) {\n      return i;\n    } else {\n      return par[i] = find(par[i]);\n    }\n  }\n\n  void unite(int i, int j) {\n    i = find(i);\n    j = find(j);\n    if (i == j) return;\n\n    if (rank[i] < rank[j]) {\n      par[i] = j;\n    } else {\n      par[j] = i;\n      if (rank[i] == rank[j]) rank[i]++;\n    }\n  }\n\n  bool same(int i, int j) {\n    return find(i) == find(j);\n  }\n};\n\ntypedef long long int lli;\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q and N != 0) {\n    UnionFindTree tree(N + 1);\n    vector<int> parent(N + 1, -100);\n    vector<bool> cut(N + 1);\n    int i;\n\n    i = 2;\n    while (i <= N) {\n      cin >> parent[i]; \n      ++i; \n    }\n  \n    vector<pair<char,int>> query(Q);\n    REP(i, Q) {\n      char kind; int v;\n      cin >> kind >> v;\n      if (kind == 'M') { cut[v] = true; }\n      query[i] = make_pair(kind, v);\n    }\n    reverse(ALL(query));\n\n    tree.par[1] = parent[1] = 1;\n    i = 2;\n    while (i <= N) {\n      if (not cut[i]) tree.par[i] = parent[i];\n      ++i;\n    }\n\n    lli ans = 0;\n    for (auto q : query) {\n      int v = q.second;\n      if (q.first == 'Q') {\n        ans += tree.find(v);\n      } else {\n        tree.par[v] = parent[v];\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint find(vector<int> par, int k){\n  if(par[k] == k) return k;\n  return par[k] = find(par,par[k]);\n}\n\nint main(){\n  int N, Q;\n  while(cin >> N >> Q, N){\n    vector<int> par(N);\n    for(int i = 0; i < N; ++i) par[i] = i;\n    int p[N-1];\n    for(int i = 0; i < N-1; ++i){\n      cin >> p[i];\n      par[i+1] = p[i]-1;\n    }\n    vector< pair<char,int> > Query;\n    char c;\n    int k;\n    for(int i = 0; i < Q; ++i){\n      cin >> c >> k;\n      --k;\n      if(c == 'M') par[k] = k;\n    Query.push_back(make_pair(c,k));\n    }\n    reverse(Query.begin(),Query.end());\n    int ans = 0;\n    for(int i = 0; i < Q; ++i){\n      c = Query[i].first;\n    k = Query[i].second;\n    if(c == 'Q') ans += find(par,k)+1;\n    else par[find(par,k)] = p[par[find(par,k)]-1];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1LL<<55)\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nstruct SegmentTree {\n    int n;\n    P dat[2*MAX-1];    \n    \n    SegmentTree(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = P(0, 1);\n        }\n    }\n\n    ll get_nearest_marked_node(int k)\n    {\n        k += n - 1;\n        P p = dat[k];\n        while (k > 0) {\n            k = (k - 1) / 2;\n            p = max(p, dat[k]);\n        }\n        return p.second;\n    }\n        \n    void mark(int a, int b, int k, int l, int r, P x)\n    {\n        if (r <= a || b <= l) return;\n\n        if (a <= l && r <= b) {\n            dat[k] = max(dat[k], x);\n        } else {\n            mark(a, b, k * 2 + 1, l, (l + r) / 2, x);\n            mark(a, b, k * 2 + 2, (l + r) / 2, r, x);\n        }\n    }    \n};\n\nll L[MAX], R[MAX], D[MAX], p;\nvector<int> G[MAX];\n\nvoid init(int N)\n{\n    p = 0;\n    for (int i = 0; i < N; i++) {\n        G[i].clear();        \n    }\n}\n\nvoid dfs(int v, int depth)\n{\n    L[v] = p++;\n    D[v] = depth;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        dfs(G[v][i], depth + 1);\n    }\n    R[v] = p;\n}\n\nint main()\n{\n    int N, Q, x;\n    while (scanf(\"%d %d\", &N, &Q), N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            scanf(\"%d\", &x); x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0, 0);\n\n        SegmentTree st(N);\n        \n        char m;\n        ll v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.mark(L[v], R[v], 0, 0, st.n, P(D[v], v+1));\n            } else {\n                res += st.get_nearest_marked_node(L[v]);\n            }\n        }\n        printf(\"%lld\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nconst int maxn = 100004;\nconst int INF = 0x3f3f3f3f;\n\nint pre[maxn];\nbool vis[maxn];\n\nint find(int x) {\n    while(!vis[x] && pre[x] != x) {\n        x = pre[x];\n    }\n    return x;\n}\n\nint main() {\n    int n, m;\n    while(~scanf(\"%d%d\", &n, &m) && (n || m)) {\n        vis[1] = true; pre[1] = 1;\n        for(int i = 2; i <= n; ++i)\n            scanf(\"%d\", &pre[i]);\n        ll ans = 0;\n        for(int i = 0; i < m; ++i) {\n            getchar();\n            char c = getchar();\n            int a;\n            scanf(\"%d\", &a);\n            switch(c) {\n            case 'M':\n                vis[a] = true;\n                break;\n            case 'Q':\n                ans += find(a);\n            }\n        }\n        printf(\"%lld\\n\", ans);\n        memset(vis, 0, sizeof(vis));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100002;\n\nint par[MAX+1];\nint n;\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init();\n    par[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tunite(num,par[num]);\n\tsum += par[num]+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\nstruct SkewHeap{\n\tSkewHeap *l,*r;\n\tint val;\n};\n\nSkewHeap* meld(SkewHeap* a, SkewHeap* b) {\n    if (a==NULL) return b;\n    if (b==NULL) return a;\n    if (a->val < b->val) swap(a, b);\n    a->r = meld(a->r, b);\n\tstd:: swap(a->l, a->r);\n    return a;\n}\nSkewHeap* insert(SkewHeap* a,int v) {\n    SkewHeap* b=new SkewHeap;\n\tb->l=b->r=NULL;\n\tb->val=v;\n\treturn meld(a,b);\n}\nint getmax(SkewHeap* a){\n\treturn a->val;\n}\nSkewHeap* pop(SkewHeap* a){\n\tSkewHeap* res = meld(a->l,a->r);\n\tdelete a;\n\treturn res;\n}\nvoid del(SkewHeap* a){\n\tif(a->l)del(a->l);\n\tif(a->r)del(a->r);\n\tdelete a;\n}\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nSkewHeap* bh[100000];\nlong long ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u]=meld(bh[u],bh[edge[u][i]]);\n\t\tbh[edge[u][i]]=NULL;\n\t}\n\twhile(bh[u] && marked[u]<getmax(bh[u])){\n\t\tans+=u+1;\n\t\tbh[u]=pop(bh[u]);\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)if(bh[i]){\n\t\t\tdel(bh[i]);\n\t\t\tbh[i]=NULL;\n\t\t}\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v]=insert(bh[v],i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\n\ntemplate<class T>\nclass BinomialHeap{\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree *> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\n\tBinomialHeap(std::vector<Tree*>& e):trees(e),imax(-1){}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\tif(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\tif(carry){\n\t\t\t\tif(i<h.trees.size() && h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t\th.trees[i]=NULL;\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(i<h.trees.size() && h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=h.trees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t\t\th.trees[i]=NULL;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\t//h.clear();\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn trees[imax]->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h(trees[imax]->edge);\n\t\ttrees[imax]->edge.clear();\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\twhile(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\treturn trees.empty();\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nvector<int> edge[100000];\nint marked[100000];\nBinomialHeap<int> bh[100000];\nint ans;\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\t/*while(!bh[u].empty() && t<bh[u].getmax()){\n\t\t//cout<<' '<<u+1<<' '<<bh[u].getmax()<<endl;\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}*/\n}\n\nint main(){\n\twhile(cin>>n>>q,n|q){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n\n/*\n\n6 3\n1\n1\n2\n3\n3\nQ 5\nM 3\nQ 5\n\n10 3\n1\n1\n2\n3\n5\n5\n8\n9\n4\nQ 1\nM 3\nQ 2\n0 0\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int MAXN = 1e5+50;\nint pre[MAXN];\nbool flag[MAXN];\nint n, m;\n\nint Find(int x)\n{\n    while(!flag[x] && pre[x] != x)\n        x = pre[x];\n    return x;\n}\nint main()\n{\n    while(scanf(\"%d%d\", &n, &m) != EOF && n != 0 && m != 0)\n    {\n        int ans = 0;\n        memset(flag, 0, sizeof(flag));\n        pre[1] = 1;\n        flag[1] = true;\n        for(int i = 2; i <= n; i++) {\n            int temp; scanf(\"%d\", &temp);\n            pre[i] = temp;\n        }\n        for(int i = 0; i < m; i++) {\n            char a[5];int temp;\n            scanf(\"%s%d\", a, &temp);\n\n            if (a[0] == 'M') {\n                flag[temp] = true;\n            }\n            else {\n                ans += Find(temp);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\nvector <ll> par;\nvector <bool> ism;\n\n//find marked root (keiroasshuku at the same time)\nll root(ll x){\n\tif (ism[x]) return x;\n\telse return par[x] = root(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q, N && Q) {\n\t\t//init\n\t\tpar.resize(N), ism.resize(N);\n\t\tpar[0] = 0, ism[0] = 1;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\n\t\t//クエリ受け取り\n\t\tvector <query> q(Q);\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += root(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\tpar.clear(), ism.clear();\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1<<28;\n\n\nint Find(int p, vec& par) {\n    if (p == par[p]) return (p);\n    return (par[p] = Find(par[p], par));\n}\n\nvoid Merge(int x, int y, vec& par) {\n    x = Find(x, par), y = Find(y, par);\n    if (x != y) {\n        par[x] = y;\n    }\n}\n\nvoid dfs(int now, int p, vec& par, mat& T, vec& MarkedTime) {\n    if (MarkedTime[now] != MarkedTime[p] && MarkedTime[now] != INF) return ;\n    par[now] = p;\n    for (int i = 0; i < T[now].size(); i++) {\n        dfs(T[now][i], p, par, T, MarkedTime);\n    }\n}\n\nvoid solve(int N, int Q) {\n    mat T(N+1);\n    vec Tr(N+1);\n    Tr[1] = 1;\n    for (int i = 2; i <= N; i++) {\n        int v; cin >> v;\n        T[v].push_back(i);\n        Tr[i] = v;\n    }\n\n    vec MarkedTime(N+1, INF);\n    vec TimeToMarkedVertex(Q+1);\n    vec QueryTimeToVertex(Q+1);\n    MarkedTime[1] = -1;\n    for (int i = 0; i < Q; i++) {\n        char q;\n        int v;\n        cin >> q >> v;\n        if (q == 'M') MarkedTime[v] = i, TimeToMarkedVertex[i] = v;\n        else QueryTimeToVertex[i] = v;\n    }\n\n    vec par(N+1);\n    for (int i = 1; i <= N; i++) par[i] = i;\n    for (int i = 1; i <= N; i++) {\n        if (MarkedTime[i] == INF) continue;\n        dfs(i, i, par, T, MarkedTime);\n    }\n\n    long long int cost = 0LL;\n    for (int i = Q - 1; i > -1; i--) {\n        if (QueryTimeToVertex[i] > 0) cost += Find(par[QueryTimeToVertex[i]], par);\n        else Merge(TimeToMarkedVertex[i], Tr[TimeToMarkedVertex[i]], par);\n    }\n\n    cout << cost << endl;\n}\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N || Q) solve(N, Q);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nint n,q,askl=0;\nlong long father[100001]={},ask[100001][2],Time[100001]={};\nbool mark[100001]={};\n/*long long getF(int t)\n{\n    if(mark[t]&&Time[t]<=ask[askl][1])\n        return t;\n    return (father[t]=getF(father[t]));\n}*/\nint main()\n{\n    scanf(\"%d%d\",&n,&q);\n    char c;\n    int i,j,fax;\n    long long x,ans=0,t=0;\n    for(i=2;i<=n;++i)\n        cin>>father[i];\n    getchar();\n    bool flag=false;\n    Time[1]=0;\n    mark[1]=true;\n    scanf(\"%c\",&c);\n    while(c!='0'){\n        cin>>x;\n        if(c=='M'){\n            if(!flag){\n                ++t;\n                flag=true;\n            }\n            mark[x]=true;\n            Time[x]=t;\n        }\n        else{\n            flag=false;\n            ++askl;\n            ask[askl][0]=x;\n            ask[askl][1]=t;\n        }\n        getchar();\n        scanf(\"%c\",&c);\n    }\n    while(askl>0){\n        //ans+=getF((int)ask[askl][0]);\n        --askl;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nint rak[100001],par[100001],p[100001];\n\nbool mark[100001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    rak[i]=0;\n    }\n  }\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n    }else{\n    return find(par[x]);\n    }\n  }\n\nint findancestor(int x){\n  if(mark[x]){\n    return x;\n    }else{\n      return findancestor(par[x]);\n    }\n  }\n  \nvoid unite(int x,int y){\n   x=find(x);\n   y=find(y);\n   if(x==y) return;\n   \n   if(rak[x]<rak[y]){\n     par[y]=x;\n     }else{\n     par[y]=x;         \n     if(rak[x]==rak[y]) rak[x]++;\n     }\n  }\n\nint main() {\n  \n  while(1){\n\n   int N,Q;  scanf(\"%d %d\",&N,&Q);\n   \n   if(N==0&&Q==0) break;\n   \n   memset(mark,0,sizeof(mark));\n   \n   init(N);   mark[1]=1;\n   \n   for(int i=1; i<=N-1; i++){\n     int x; cin>>x;\n     p[i+1]=x;\n     }\n     \n   for(int i=N; i>=2; i--){\n     unite(p[i],i);\n     }\n     \n   long long ans=0;\n     \n   for(int i=0; i<Q; i++){\n     \n     char t; cin>>t;\n     \n       if(t=='M'){\n       \n        int v; cin>>v; mark[v]=1;\n       \n       }else if(t=='Q'){\n         \n        int v; cin>>v; \n        ans+=findancestor(v);\n         \n       }\n     \n     }\n               \n              cout<<ans<<endl;\n              \n    }\n     \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\nstruct UnionFindTree {\n  vector<int> par, rank;\n  UnionFindTree(int n) {\n    par.reserve(n);\n    rank.reserve(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int i) {\n    if (par[i] == i) {\n      return i;\n    } else {\n      return par[i] = find(par[i]);\n    }\n  }\n\n  void unite(int i, int j) {\n    i = find(i);\n    j = find(j);\n    if (i == j) return;\n\n    if (rank[i] < rank[j]) {\n      par[i] = j;\n    } else {\n      par[j] = i;\n      if (rank[i] == rank[j]) rank[i]++;\n    }\n  }\n\n  bool same(int i, int j) {\n    return find(i) == find(j);\n  }\n};\n\ntypedef long long int lli;\n\nint main() {\n  int N, Q;\n  while (cin >> N >> Q and N != 0) {\n    UnionFindTree tree(N + 1);\n    vector<int> parent(N + 1, -100);\n    vector<bool> cut(N + 1);\n    int i;\n\n    i = 2;\n    while (i <= N) {\n      cin >> parent[i]; \n      ++i; \n    }\n  \n    vector<pair<char,int>> query(Q);\n    REP(i, Q) {\n      char kind; int v;\n      cin >> kind >> v;\n      if (kind == 'M') { cut[v] = true; }\n      query[i] = make_pair(kind, v);\n    }\n    reverse(ALL(query));\n\n    tree.par[1] = 1;\n    i = 2;\n    while (i <= N) {\n      if (not cut[i]) { tree.par[i] = parent[i]; }\n      ++i;\n    }\n\n    lli ans = 0;\n    for (auto q : query) {\n      int v = q.second;\n      if (q.first == 'Q') {\n        ans += tree.find(v);\n      } else {\n        tree.par[v] = parent[v];\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate<class T>inline string toString(T x){\n        ostringstream sout; sout<<x; return sout.str();\n}\nconst ll MOD=1e9+7;\nconst int inf=(ll)1e9;\nconst double PI=acos(-1.0);\nconst int N=100000;\nstruct UF\n{\n\tstatic const int n=100001;\n\tint par[100001];\n\tint Rank[100001];\n\tvoid init(int size){\n\t\tfor(int i=0;i<size;i++){\n\t\t\tpar[i]=i;\n\t\t\tRank[i]=0;\n\t\t}\n\t}\n\tint find(int a){\n\t\tif(par[a]==a)return a;\n\t\treturn par[a]=find(par[a]);\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tvoid unite(int a,int b){\n\t\tint x=find(a);\n\t\tint y=find(b);\n\t\tif(x==y)return;\n\t\tif(Rank[x]>Rank[y]){\n\t\t\tpar[y]=x;\n\t\t}else if(Rank[x]<Rank[y]){\n\t\t\tpar[x]=y;\n\t\t}else{\n\t\t\tif(x>y){\n\t\t\t\tpar[x]=y;\n\t\t\t\tRank[y]++;\n\t\t\t}else{\n\t\t\t\tpar[y]=x;\n\t\t\t\tRank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tvoid test(int size){\n\t\tcerr<<\"==================\"<<endl;\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcerr<<par[i]<<\" \";\n\t\t}\n\t\tcerr<<\"\\n\";\n\t\tfor(int i=0;i<size;i++){\n\t\t\tcerr<<Rank[i]<<\" \";\n\t\t}\n\t\tcerr<<\"\\n\";\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n    \tvector<int> edge[n];\n    \tfor(int i=1;i<n;i++){\n    \t\tint a;cin>>a;\n    \t\ta--;\n    \t\tedge[a].push_back(i);\n    \t}\n    \tUF uf;\n    \tuf.init(n);\n    \tvector<pair<int,int> > Q,M;\n    \tint nowq=0;\n    \tbool flag1=0;\n    \tM.push_back(make_pair(-1,0));\n    \tfor(int i=0;i<m;i++){\n    \t\tchar a;\n    \t\tint b;\n    \t\tcin>>a>>b;\n    \t\tb--;\n    \t\tif(a=='Q'){\n    \t\t\tif(flag1)nowq++;\n    \t\t\tQ.push_back(make_pair(nowq,b));\n    \t\t\tflag1=0;\n    \t\t}\n    \t\telse{\n    \t\t\tM.push_back(make_pair(nowq,b));\n    \t\t\tflag1=1;\n    \t\t}\n    \t}\n    \tll ans=0;\n    \tint qsize=(int)Q.size();\n    \tint msize=(int)M.size();\n    \tsort(Q.begin(),Q.end());\n    \tint nowqq=Q[qsize-1].fi;\n    \tint nowmm=M[msize-1].fi;\n    \tint lastq=qsize-1;\n    \tint lastm=msize-1;\n    \tbool flag=1;\n    \twhile(flag){\n    \t\tflag=0;\n    \t\tint lastmfi=M[lastm].fi;\n    \t\tfor(int i=lastm;i>=0;i--){\n    \t\t\tif(lastmfi>M[i].fi)break;\n    \t\t\tflag=1;\n    \t\t\tfor(int j=0;j<(int)edge[M[i].se].size();j++){\n    \t\t\t\t//cerr<<\"unite:\"<<M[i].se<<\" \"<<edge[M[i].se][j]<<endl;\n    \t\t\t\tuf.unite(M[i].se,edge[M[i].se][j]);\n    \t\t\t}\n    \t\t\tlastm--;\n    \t\t}\n    \t\tint lastqfi=Q[lastq].fi;\n    \t\tfor(int i=lastq;i>=0;i--){\n    \t\t\tif(lastqfi>Q[i].fi)break;\n    \t\t\tflag=1;\n    \t\t\tint aa=(uf.find(Q[i].se)+1);\n    \t\t\t//cerr<<aa<<endl;\n    \t\t\tans+=aa;\n    \t\t\t//uf.test(n);\n    \t\t\tlastq--;\n    \t\t}\n    \t}\n    \tcout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int gmax_n = 100005;\n\nint par[gmax_n]; //???\nint depth[gmax_n];//??¨?????±???\n\nvoid init(int n){\n    rep(i,n){\n        par[i] = i;\n        depth[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(depth[x] < depth[y]){\n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(depth[x] == depth[y]) depth[x]++;\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n||m){\n        int g[gmax_n];\n        init(n);\n        rep(i,n - 1){ //??¨????§????\n            int a;\n            cin >> a;\n            a--;\n            g[i + 1] = a;\n        }\n\n        bool marked[gmax_n] = {false};//???????????????????????????????¨????\n        marked[0] = true;\n        vector<pair<char, int>> q;\n        rep(i,m){\n            char a;\n            int b;\n            cin >> a >> b;\n            b--;\n            if(a == 'M'){\n                if(marked[a]) continue; //????????¨???????????????????????´?????????????????\\???????????????\n                else{\n                    marked[b] = true;\n                    q.emplace_back(make_pair(a, b));\n                }\n            }else{\n                q.emplace_back(make_pair(a,b));\n            }\n        }\n\n        rep(i,n){ //???????????????????????????????????¨?????????????????????unite\n            if(not marked[i]){\n                unite(g[i], i);\n            }\n        }\n\n        //rep(i,n){ show(find(i)) }\n\n        long long ans = 0;\n        for(int i = q.size() - 1; i >= 0; i--){ //?????¨?????????????????????\n            if(q[i].first == 'Q') ans += find(q[i].second) + 1;\n            else{\n                unite(g[q[i].second], q[i].second);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include?<iostream>\n#include?<vector>\n#include?<queue>\n#include?<stack>\nusing?namespace?std;\n\n//?并?集相?数据与算法\n#define?MAX_N?100000?+?16\nint?parent[MAX_N];\nint?height[MAX_N];\n\nvoid?init(const?int&?n)\n{\n\tfor?(int?i?=?0;?i?<?n;?++i)\n\t{\n\t\tparent[i]?=?i;\n\t\theight[i]?=?0;\n\t}\n}\n\nint?find(const?int&?x)\n{\n\tif?(parent[x]?==?x)\n\t{\n\t\treturn?x;\n\t}\n\telse\n\t{\n\t\treturn?parent[x]?=?find(parent[x]);\n\t}\n}\n\nvoid?unite(int?x,?int?y)\n{\n\tx?=?find(x);\n\ty?=?find(y);\n\tif?(x?==?y)\n\t{\n\t\treturn;\n\t}\n\n\tif?(height[x]?<?height[y])\n\t{\n\t\tparent[x]?=?y;\n\t}\n\telse\n\t{\n\t\tparent[y]?=?x;\n\t\tif?(height[x]?==?height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n\nbool?same(const?int&?x,?const?int&?y)\n{\n\treturn?find(x)?==?find(y);\n}\n//?End?Of?并?集\n\n//?原始的?用它来描述\nvector<int>?children[MAX_N];\nint?parent_tree[MAX_N];\nbool?marked[MAX_N];\nint?ancestor[MAX_N];\n//??条指令被拆分??操作?+?目?\nstack<char>?operation;\nstack<int>??target;\n\nvoid?bfs(int?index,?int?the_ancestor)\n{\n\tqueue<int>?q_index;\n\tqueue<int>?q_ancestor;\n\tq_index.push(index);\n\tq_ancestor.push(the_ancestor);\n\twhile?(!q_index.empty())\n\t{\n\t\tthe_ancestor?=?q_ancestor.front();?q_ancestor.pop();\n\t\tindex?=?q_index.front();?q_index.pop();\n\t\tif?(marked[index]?==?true)\n\t\t{\n\t\t\tthe_ancestor?=?index;\n\t\t}\n\t\tancestor[index]?=?the_ancestor;\n\t\tfor?(vector<int>::iterator?it?=?children[index].begin();?it?!=?children[index].end();?++it)\n\t\t{\n\t\t\tq_index.push(*it);\n\t\t\tq_ancestor.push(the_ancestor);\n\t\t}\n\t}\n}\n\nint?main(int?argc,?char?*argv[])\n{\n\n\tint?N,?Q;\n\twhile?(cin?>>?N,?cin?>>?Q,?N)\n\t{\n\t\tfor?(int?i?=?0;?i?<?N;?++i)\n\t\t{\n\t\t\tchildren[i].clear();\n\t\t\tmarked[i]?=?false;\n\t\t}\n\t\tmarked[0]?=?true;\n\t\tint?p;\n\t\tfor?(int?i?=?1;?i?<?N;?++i)\n\t\t{\n\t\t\tcin?>>?p;?--p;\n\t\t\tparent_tree[i]?=?p;\n\t\t\tchildren[p].push_back(i);\n\t\t}\n\t\tfor?(int?i?=?0;?i?<?Q;?++i)\n\t\t{\n\t\t\tchar?o;\n\t\t\tint?t;\n\t\t\tcin?>>?o?>>?t;?--t;\n\t\t\tif?(o?==?'M')\n\t\t\t{\n\t\t\t\tif?(marked[t])\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmarked[t]?=?true;\n\t\t\t\t}\n\t\t\t}\n\t\t\toperation.push(o);\n\t\t\ttarget.push(t);\n\t\t}\n\t\tbfs(0,?0);\n\t\tinit(N);\n\t\tfor?(int?i?=?0;?i?<?N;?++i)\n\t\t{\n\t\t\tunite(i,?ancestor[i]);\n\t\t}\n\t\tunsigned?long?long?result?=?0;\n\t\twhile?(!operation.empty())\n\t\t{\n\t\t\tchar?o?=?operation.top();?operation.pop();\n\t\t\tint?t?=?target.top();?target.pop();\n\t\t\tif?(o?==?'Q')\n\t\t\t{\n\t\t\t\tresult?+=?ancestor[find(t)]?+?1;\t//??目index从1?始\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//??行“反染色”操作，之后?个?点的祖先??其父?点的祖先\n\t\t\t\tint?p?=?ancestor[find(parent_tree[t])];\n\t\t\t\tunite(t,?parent_tree[t]);\n\t\t\t\tancestor[find(t)]?=?p;\n\t\t\t}\n\t\t}\n\t\tcout?<<?result?<<?endl;\n\t}\n\t\n\n\treturn?0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<class T>\nclass segment_tree_RMQ{\n\tstatic const int N_MAX=1<<17;\n\tint n;\n\tT dat[2*N_MAX];\n\n\tvoid update_min(int l,int r,int a,int b,int u,T v){\n\t\tif(l<=a && b<=r){ dat[u]=min(dat[u],v); return; }\n\n\t\tint c=(a+b+1)/2;\n\t\tif(l<c && a<r) update_min(l,r,a,c,2*u,v);\n\t\tif(l<b && c<r) update_min(l,r,c,b,2*u+1,v);\n\t}\n\npublic:\n\tvoid build(int N,T val){\n\t\tfor(n=1;n<N;n*=2);\n\t\trep(u,2*n) dat[u]=val;\n\t}\n\n\tvoid update_min(int l,int r,T v){ update_min(l,r,0,n,1,v); }\n\n\tT query(int u){\n\t\tu+=n;\n\t\tT res=dat[u];\n\t\tfor(u/=2;u>=1;u/=2) res=min(res,dat[u]);\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tfor(int n,q;scanf(\"%d%d\",&n,&q),n;){\n\t\tstatic vector<int> T[100000]; // tree\n\t\trep(u,n) T[u].clear();\n\t\trep(i,n-1){\n\t\t\tint u,v=i+1; scanf(\"%d\",&u); u--;\n\t\t\tT[u].push_back(v);\n\t\t}\n\n\t\t// euler tour technique\n\t\tstatic int start[100000],end[100000];\n\t\tint idx=0;\n\t\tstack< pair<int,int> > D; D.push(make_pair(0,0));\n\t\twhile(!D.empty()){\n\t\t\tint u=D.top().first,type=D.top().second; D.pop();\n\t\t\tif(type==0){ // in\n\t\t\t\tstart[u]=idx++;\n\t\t\t\tD.push(make_pair(u,1));\n\t\t\t\trep(i,T[u].size()) D.push(make_pair(T[u][i],0));\n\t\t\t}\n\t\t\telse{ // out\n\t\t\t\tend[u]=idx;\n\t\t\t}\n\t\t}\n\n\t\tstatic segment_tree_RMQ<int> S;\n\t\tS.build(n,0);\n\n\t\tll ans=0;\n\t\twhile(q--){\n\t\t\tchar c;\n\t\t\tint u; scanf(\" %c%d\",&c,&u); u--;\n\t\t\tif(c=='Q'){\n\t\t\t\tans+=-S.query(start[u])+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tS.update_min(start[u],end[u],-u);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint mark[MAX_N];\nint used[MAX_N];\nint par[MAX_N];\nint root;\nclass ut{\n    public:\n        map<int,vector<int> > child;\n        void dfs(int start){\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++){\n            if(used[child[start][i]]==0) dfs(child[start][i]);\n        }\n    }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        scanf(\"%d\",&par[i+1]);\n        par[i+1]--;\n        tmp.child[par[i+1]].push_back(i+1);\n    }\n    int ans=0;\n    used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if(a=='0' and b==0)break;\n        if (a=='Q') {\n            //cout<<\"as\"<<mark[b-1]<<endl;\n            ans+=mark[b-1];\n            ans++;\n        }\n        else {\n            root=b-1;\n            tmp.dfs(b-1);\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX = 100000 + 1; // 1-indexed\n\nvector<int> par(MAX);\nvector<bool> marked(MAX);\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            //if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n};\n\nint main() {\n    int N, Q;\n    while (cin >> N >> Q, N) {\n        fill(marked.begin(), marked.end(), false);\n        marked[1] = true;\n        for (int v = 2; v <= N; v++) cin >> par[v];\n        vector<pair<char, int>> query(Q);\n        for (int i = 0; i < Q; i++) {\n            char cmd; int v;\n            cin >> cmd >> v;\n            // 同じ部分にマークした場合は，初回以外を無視\n            if (cmd == 'M' && marked[v]) continue;\n            query.emplace_back(cmd, v);\n            // 1. M(v) で指定された全部の頂点を塗る\n            if (cmd == 'M') marked[v] = true;\n        }\n        // 2. 塗られていない頂点については，その親と併合する\n        UnionFind uf(N + 1);    // 1-origin\n        for (int v = 1; v <= N; v++) if (!marked[v]) uf.unionSet(par[v], v);\n        // 3. クエリを逆回しする\n        reverse(query.begin(), query.end());\n        long long sum = 0;\n        for (auto p : query) {\n            char cmd = p.first; int v = p.second;\n            if (cmd == 'Q') sum += uf.root(v);      // v の根を sum に加える\n            if (cmd == 'M') uf.unionSet(par[v], v); // v と v の親を併合する\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<char, int> P;\n\nint ancestor[100000];\nint n, q;\nint marked_ancestor[100000];\nbool ismarked[100000];//false = unmarked\nP outlog[100000];\n\nvoid create_UF(int size) {\n\tfor (int i = 0; i < size; i++) {\n\t\tmarked_ancestor[i] = i;\n\t}\n}\n\nint getroot(int a) {\n\tif (a == marked_ancestor[a])return a;\n\treturn marked_ancestor[a] = getroot(marked_ancestor[a]);\n}\n\nbool is_same_unit(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\t//parent kid\n\tif (is_same_unit(a, b))return;\n\tmarked_ancestor[b] = a;\n}\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tcreate_UF(n);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tunite(getroot(ancestor[i]), i);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tmarked_ancestor[0] = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (outlog[i].first == 'M')unite(getroot(ancestor[outlog[i].second]), outlog[i].second);\n\t\t\telse {\n\t\t\t\tans += getroot(outlog[i].second), ans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long fa[100005],ans,a;\nint n,q,i;\nbool r[100005];\nchar c;\nlong long find(long long x)\n{\n\tif(r[x]==1)\n\t\treturn x;\n\treturn find(fa[x]);\n}\nint main()\n{\n\tfa[1]=1;\n\tr[1]=1;\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0||q==0)\n\t\t\treturn 0;\n\t\tans=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tr[i]=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tscanf(\"%lld\",&fa[i]);\n\t\tfor(i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"\\n%c %lld\",&c,&a);\n\t\t\tif(c=='M')\n\t\t\t\tr[a]=1;\n\t\t\tif(c=='Q')\n\t\t\t\tans=ans+find(a);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nint N, Q;\n\nint main(){\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        par[1]=1;\n        for(int i=2; i<=N; i++) scanf(\"%d\", &par[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n\t\t\tchar ch; int num;\n        \tscanf(\"%c \", &ch); \n\t\t\tscanf(\"%d \", &num); \n           if(ch=='M'){\n                vis[num]=1;\n            }\n            else if(ch=='Q'){\n                int cur=num;\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nint n,q;\nchar c[100100];\nint v[100100], p[100100];\nint marked[100100], root[100100];\n\nint main(){\n  while(cin >> n >> q, n){\n    for(int i=1;i<n;i++)cin >> p[i], p[i]--;\n    memset(marked,0,sizeof(marked));\n\n    marked[0] = 1;\n    for(int i=0;i<q;i++){\n      cin >> c[i] >> v[i], v[i]--;\n      if(c[i]=='M')marked[v[i]] = 1;\n    }\n\n    UF uf(n);\n    for(int i=1;i<n;i++){\n      if(!marked[i])uf.unite(i,p[i]);\n    }\n\n    for(int i=0;i<n;i++){\n      if(marked[i])root[uf.find(i)] = i;\n    }\n\n    long long ans = 0;\n    for(int i=q-1;i>=0;i--){\n      if(c[i] == 'M'){\n\tint tmp = root[uf.find(p[v[i]])];\n\tuf.unite(v[i],p[v[i]]);\n\troot[uf.find(v[i])] = tmp;\n      }else{\n\tans += root[uf.find(v[i])] + 1;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100010;\nconst int MAXM = 100010;\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nint N, Q;\nint father[MAXN];\nbool vis[MAXN];\n\nvoid Init() {\n\tfor (int i = 0; i < MAXN; ++i) {\n\t\tfather[i] = i;\n\t}\n}\nint Find(int x) {\n\twhile (!vis[x])\n\t\tx = father[x];\n\treturn x;\n}\n\nint main(int argc, char const *argv[]) {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &N, &Q) != EOF && !(N == 0 && Q == 0)) {\n\t\tint a, b;\n\t\tLL res = 0;\n\t\tchar opt[5];\n\t\tInit();\n\t\tfill(vis, vis + MAXN, false);\n\t\tvis[1] = true;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tscanf(\"%d\", &father[i]);\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tscanf(\"%s %d\", opt, &b);\n\t\t\tif (opt[0] == 'Q') {\n\t\t\t\tres += Find(b);\n\t\t\t}\n\t\t\telse\n\t\t\t\tvis[b] = true;\n\t\t}\n\t\tprintf(\"%lld\\n\", res);\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n// ------ Class ------ //\nclass QuickUnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> g; std::vector<std::vector<unsigned> > v;\npublic:\n\tQuickUnionFind() : size_(0), g(std::vector<unsigned>()), v(std::vector<std::vector<unsigned> >()) {};\n\tQuickUnionFind(unsigned size__) : size_(size__) {\n\t\tg.resize(size_); v.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) g[i] = i, v[i] = { i };\n\t};\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return g[x]; }\n\tunsigned size(unsigned x) { return v[x].size(); }\n\tbool same(unsigned x, unsigned y) { return g[x] == g[y]; }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) std::swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const QuickUnionFind& u) { return g == u.g; }\n\tbool operator!=(const QuickUnionFind& u) { return g != u.g; }\n};\n\n\nlong long n, q, a[200000], b[200000];\nchar J[200000]; int K[200000], R[200000];\nint main() {\n\twhile (true) {\n\t\tcin >> n >> q; if (n == 0 && q == 0)break;\n\t\tfor (int i = 0; i < 200000; i++)K[i] = 0;\n\t\tfor (int i = 2; i <= n; i++) cin >> a[i];\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> J[i] >> K[i]; if (J[i] == 'M')b[K[i]] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint D = i;\n\t\t\tfor (int j = 0; j < 50; j++) D = a[i];\n\t\t\tR[i] = D;\n\t\t}\n\t\tQuickUnionFind UF(n + 2); long long sum = 0;\n\t\tfor (int i = 2; i <= n; i++) { if (b[i] == 0)UF.unite(i, a[i]); }\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (J[i] == 'M')UF.unite(a[K[i]], K[i]);\n\t\t\tif (J[i] == 'Q') {\n\t\t\t\tint D = K[i];\n\t\t\t\tbool flag = true;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (UF.same(R[D], K[i]) == false) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tif (UF.same(a[D], K[i]) == false) {\n\t\t\t\t\t\t\t\tsum += D; flag = false; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tD = a[D];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag == false)break;\n\t\t\t\t\t}\n\t\t\t\t\tD = R[D];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par;\n\tUnion_Find_Tree(int n){\n\t\tPar=vi(n);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tPar[x]=y;\n\t\treturn 1;\n\t}\n};\n\nint n,q;\nvi a;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>q;\n\t\tif(!n) break;\n\t\ta=vi(n+1);\n\t\tfor(int i=2;i<=n;i++) cin>>a[i];\n\t\tvp p(q);\n\t\tvi b(n+1);\n\t\tUnion_Find_Tree uft(n+1);\n\t\tll res=0;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin>>c>>v;\n\t\t\tif(c=='Q') p[i]={0,v};\n\t\t\telse{\n\t\t\t\tp[i]={1,v};\n\t\t\t\tb[v]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=2;i<=n;i++) if(!b[i]) uft.Unite(i,a[i]);\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tbool B=p[i].first;\n\t\t\tint v=p[i].second;\n\t\t\tif(B){\n\t\t\t\tb[v]--;\n\t\t\t\tif(v!=1&&!b[v]) uft.Unite(v,a[v]);\n\t\t\t}\n\t\t\telse res+=uft.Find_Par(v);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef vector< int > Array;\ntypedef pair< int, int > pii;\n\nconst int iINF = 1L << 30;\n\nint N, Q;\nvector< Array > edges;\nint depth[100010], node_number[100010];\npii ranges[100010];\n\n// lazy evaluate segment tree\nstruct SegmentTreeL {\nprivate:\n\ttypedef int data_type;\n\tstatic const data_type dINF = iINF;\n\t\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\npublic:\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tif (lazy[_k] == 0) lazy[_k] = _val;\n\t\telse if (depth[ lazy[_k] ] < depth[_val]) lazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tdata[_k] = lazy[_k];\n\t\tif (_k < st_size - 1) {\n\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t}\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\tupdate_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\tupdate_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint dfs(int v, int& nv, int dp) {\n\tdepth[v] = dp;\n\t\n\tint e_size = size_of(edges[v]), mn = iINF;\n\t\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tmn = min(mn, dfs(u, nv, dp + 1));\n\t}\n\t\n\t++nv;\n\tnode_number[v] = nv;\n\tranges[v] = pii(min(mn, nv), nv);\n\t\n\treturn min(mn, nv);\n}\n\nvoid solve() {\n\tSegmentTreeL stl(N + 5, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint nv = 0;\n\tdfs(1, nv, 0);\n\t\n\tlint ans = 0;\n\t\n\tfor_(i,0,Q) {\n\t\tchar q; int v; scanf(\"%s %d\", &q, &v);\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tnv = node_number[v];\n\t\t\tans += (lint)stl.query(nv, nv + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tedges.assign(N + 1, Array());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; scanf(\"%d\", &p);\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\n\nstruct Unionfind {\n  vector<int> size;\n  vector<int> par;\n\n  Unionfind( int n ) :  size(n, 1), par(n) {\n    iota( par.begin() , par.end() , 0 );\n  }\n\n  int find( int x ) {\n    if ( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n\n  bool unite( int x , int y ) {\n    x = find(x);\n    y = find(y);\n    if ( x == y ) return false;\n\n    //if ( size[y] < size[x] ) swap( x , y );\n    //y is always_parent\n    par[x] = y;\n    size[y] += size[x];\n\n    return true;\n  }\n\n  bool same( int x , int y ) {\n    return find(x) == find(y);\n  }\n};\nint main(void)\n{\n  for(;;){\n    int n,q;\n    cin >> n >> q;\n    if(!n&&!q) return 0;\n    vector<int> p(n+1);\n    p[1]=1;\n    FOR(i,2,n+1) cin >> p[i];\n    vector<pair<string,int> > o(q);\n    REP(i,q) cin >> o[i].first >> o[i].second;\n    vector<int> m(n+1,0);\n    m[1]=true;\n    REP(i,q) if(o[i].first==\"M\") ++m[o[i].second];\n    Unionfind t(n+1);\n    FOR(i,1,n+1) if(!m[i]) t.unite(i,p[i]);\n    LL answer=0;\n    for(int i=o.size()-1;i>=0;--i){\n      if(o[i].first==\"M\"){\n\tif(!--m[o[i].second])t.unite(o[i].second,p[o[i].second]);\n      }\n      else answer+=t.find(o[i].second);\n    }\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Limit: 32768K / 8000ms\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nclass UnionFindTree {\npublic:\n  UnionFindTree(int n) {\n    par = vector<int>(n);\n    for (int i = 0; i < n; i++) par[i] = i;\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    int rx = find(x), ry = find(y);\n    if (rx != ry) par[ry] = rx;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\nprivate:\n  vector<int> par;\n};\n\nvector<vector<int> > G;\nvector<bool> marked;\nUnionFindTree tree(0);\n\nlong long solve(int N, int Q, vector<int>& parent, vector<pair<bool, int> >& queries) {\n  marked = vector<bool>(N);\n  marked[0] = true;\n  for (int i = 0; i < Q; i++) {\n    if (queries[i].first == false) marked[queries[i].second-1] = true;\n  }\n\n  tree = UnionFindTree(N);\n  for (int i = 0; i < N; i++) {\n    if (!marked[i]) tree.unite(parent[i], i);\n  }\n\n  long long res = 0;\n  for (int i = Q - 1; i >= 0; i--) {\n    int x = queries[i].second - 1;\n    if (queries[i].first == false) {\n      tree.unite(parent[x], x);\n    } else {\n      res += tree.find(x) + 1;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int N, Q; scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    vector<int> parent(N);\n    G = vector<vector<int> >(N);\n    for (int i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      G[n-1].push_back(i);\n      parent[i] = n-1;\n    }\n    vector<pair<bool, int> > queries(Q);\n    char buf[2];\n    for (int i = 0; i < Q; i++) {\n      int n; scanf(\"%s %d\", buf, &n);\n      if (buf[0] == 'Q') {\n        queries[i] = make_pair(true, n);\n      } else {\n        queries[i] = make_pair(false, n);\n      }\n    }\n    long long ans = solve(N, Q, parent, queries);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 100005\nusing namespace std;\nint n,m,fa[M],mark[M];\nvector<int>edge[M];\nstruct node{int op,x;}A[M];\nchar op[2];\nint Fa[M];\nint Find(int x){return x==Fa[x]?x:Fa[x]=Find(Fa[x]);}\nvoid Union(int x,int y){Fa[Find(x)]=Find(y);}\nvoid f1(int x,int f){\n\tif(mark[x])Fa[x]=x;\n\telse Union(x,f);\n\tfor(int i=0;i<(int)edge[x].size();i++){\n\t\tint y=edge[x][i];\n\t\tf1(y,x);\n\t}\n}\nvoid Init(){\n\tfor(int i=1;i<=n;i++){\n\t\tedge[i].clear();\n\t\tFa[i]=i;\n\t}\n}\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m)&&(n||m)){\n\t\tInit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&fa[i]);\n\t\t\tedge[fa[i]].push_back(i);\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\",op,&x);\n\t\t\tif(op[0]=='M'){\n\t\t\t\tA[i].op=0;A[i].x=x;\n\t\t\t\tmark[x]++;\n\t\t\t}else{\n\t\t\t\tA[i].op=1;A[i].x=x;\n\t\t\t}\n\t\t}\n\t\tf1(1,1);\n\t\tint ans=0;\n\t\tfor(int i=m;i>=1;i--){\n\t\t\tint x=A[i].x;\n\t\t\tif(A[i].op==0){\n\t\t\t\tmark[x]--;\n\t\t\t\tif(!mark[x])Union(x,fa[x]);\n\t\t\t}else{\n\t\t\t\tans+=Find(x);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100002\nusing namespace std;\n\nint n,q;\nvector<int> v[MAX];\nint marked[MAX]={};\n\nvoid dfs(int now,int a){\n  if(marked[now]==a || marked[now]==now)return;\n  marked[now]=a;\n  for(int i=0;i<v[now].size();i++){\n    dfs(v[now][i],a);\n  }\n}\n\nint main()\n{\n  char c;\n  int a;\n\n  while(1){\n    cin>>n>>q;\n    if(n+q==0)break;\n    for(int i=0;i<MAX;i++){\n      marked[i]=0;\n      v[i].clear();\n    }\n    for(int i=1;i<n;i++){\n      cin>>a;\n      v[a-1].push_back(i);\n    }\n    long long ans=0;\n    for(int i=0;i<q;i++){\n      cin>>c>>a;\n      if(c=='Q'){\n\tans+=marked[a-1]+1;\n      }\n      else {\n\tdfs(a-1,a-1);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define INF (1<<29)\n\n\n\n\ntemplate<class T>\nclass BinomialHeap{\n\t/*template<class S>\n\tstruct Vector{\n\t\tint sz,cap;\n\t\tS *p;\n\t\tVector():sz(0),cap(0),p(0){}\n\t\t~Vector(){\n\t\t\tclear();\n\t\t}\n\t\tvoid swap(Vector &v){\n\t\t\tstd::swap(sz,v.sz);\n\t\t\tstd::swap(cap,v.cap);\n\t\t\tstd::swap(p,v.p);\n\t\t}\n\t\tint size()const{return sz;}\n\t\tbool empty()const{return !sz;}\n\t\tS& back()const{\n\t\t\treturn p[sz-1];\n\t\t}\n\t\tvoid push_back(S v){\n\t\t\tif(sz==cap)reserve(sz?sz*2:1);\n\t\t\tnew(p+sz++) S(v);\n\t\t}\n\t\tvoid pop_back(){\n\t\t\tp[--sz].~S();\n\t\t\tif(sz&&sz*4<cap){\n\t\t\t\treserve(cap/2);\n\t\t\t}\n\t\t}\n\t\tvoid reserve(int n){\n\t\t\tS *p=(S*)operator new(n*sizeof(S));\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tnew(p+i) S(this->p[i]);\n\t\t\t\tp[i].~S();\n\t\t\t}\n\t\t\tif(this->p)operator delete(this->p);\n\t\t\tthis->p=p;\n\t\t\tcap=n;\n\t\t}\n\t\tvoid clear(){\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tp[i].~S();\n\t\t\t}\n\t\t\tif(p)operator delete(p);\n\t\t\tsz=cap=0;\n\t\t\tp=0;\n\t\t}\n\t\tS& operator[](int i)const{\n\t\t\treturn p[i];\n\t\t}\n\t};*/\n\tstruct Tree{\n\t\tT val;\n\t\tstd::vector<Tree*> edge;\n\t\tTree(T &v):val(v){}\n\t\t~Tree(){\n\t\t\tfor(int i=0;i<degree();i++)delete edge[i];\n\t\t}\t\n\t\tvoid add(Tree *t){edge.push_back(t);}\n\t\tvoid pop(Tree *t){edge.pop_back();}\n\t\tint degree()const{return edge.size();}\n\t};\n\tstd::vector<Tree*> trees;\n\tmutable int imax;\n\n\tstatic Tree* add(Tree* a,Tree* b){\n\t\tif(a->val > b->val){\n\t\t\ta->add(b);\n\t\t\treturn a;\n\t\t}else{\n\t\t\tb->add(a);\n\t\t\treturn b;\n\t\t}\n\t}\n\tvoid findmax()const{\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i] && (imax==-1||trees[i]->val > trees[imax]->val))\n\t\t\t\timax=i;\n\t}\npublic:\n\tBinomialHeap():imax(-1){}\n\t~BinomialHeap(){\n\t\tclear();\n\t}\n\t//O(log n)\n\tvoid meld(BinomialHeap &h){\n\t\timax=-1;\n\t\tTree* carry=NULL;\n\t\t//if(trees.size()<h.trees.size())trees.swap(h.trees);\n\t\twhile(trees.size()<h.trees.size())trees.push_back(NULL);\n\t\twhile(trees.size()>h.trees.size())h.trees.push_back(NULL);\n\t\tfor(int i=0;i<trees.size();i++){\n\t\t\t//if(carry==NULL && h.trees.size()<=i)break;\n\t\t\t/*if(carry){\n\t\t\t\tif(h.trees[i]){\n\t\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t\t}else if(trees[i]){\n\t\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=carry;\n\t\t\t\t\tcarry=NULL;\n\t\t\t\t}\n\t\t\t}else if(h.trees[i]){\n\t\t\t\tif(trees[i]){\n\t\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\t\ttrees[i]=NULL;\t\n\t\t\t\t}else{\n\t\t\t\t\ttrees[i]=h.trees[i];\t\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tif(carry && h.trees[i]){\n\t\t\t\tcarry=add(carry,h.trees[i]);\n\t\t\t}else if(carry && trees[i]){\n\t\t\t\tcarry=add(carry,trees[i]);\n\t\t\t\ttrees[i]=NULL;\n\t\t\t}else if(trees[i] && h.trees[i]){\n\t\t\t\tcarry=add(trees[i],h.trees[i]);\n\t\t\t\ttrees[i]=NULL;\n\t\t\t}else if(h.trees[i]){\n\t\t\t\ttrees[i]=h.trees[i];\n\t\t\t}\n\t\t}\n\t\tif(carry)trees.push_back(carry);\n\t\th.trees.clear();\n\t}\n\t//O(log n)\n\tvoid insert(T v){\n\t\tBinomialHeap h;\n\t\th.trees.push_back(new Tree(v));\n\t\tmeld(h);\n\t}\n\tT getmax()const{\n\t\tif(imax==-1)findmax();\n\t\treturn (trees[imax])->val;\n\t}\n\tvoid popmax(){\n\t\tif(imax==-1)findmax();\n\t\tBinomialHeap h;\n\t\ttrees[imax]->edge.swap(h.trees);\t\n\t\tdelete trees[imax];\n\t\ttrees[imax]=NULL;\t\n\t\tmeld(h);\n\t\t//while(!trees.empty() && trees.back()==NULL)trees.pop_back();\n\t\timax=-1;\n\t}\n\tbool empty()const{\n\t\t//return trees.empty();\n\t\timax=-1;findmax();\n\t\treturn imax==-1;\n\t}\n\tvoid clear(){\n\t\timax=-1;\n\t\tfor(int i=0;i<trees.size();i++)\n\t\t\tif(trees[i])\n\t\t\t\tdelete trees[i];\n\t\ttrees.clear();\n\t}\n\t//void remove(int id){}\n\t//decrease_key remove(int id,T v){}\n};\n\n\n\nint n,q;\nint marked[100000];\nBinomialHeap<int> bh[100000];\nvector<int> edge[100000];\nlong long ans;\n\n\n\nvoid dfs(int u){\n\tfor(int i=0;i<edge[u].size();i++){\n\t\tdfs(edge[u][i]);\n\t\tbh[u].meld(bh[edge[u][i]]);\n\t}\n\tint t=marked[u];\n\twhile(!bh[u].empty() && t<bh[u].getmax()){\n\t\tans+=u+1;\n\t\tbh[u].popmax();\n\t}\n}\n\n\nint main(){\n\twhile(cin>>n>>q&&n){\n\t\tfor(int i=0;i<n;i++)edge[i].clear();\n\t\tfor(int i=0;i<n;i++)bh[i].clear();\n\t\tfor(int i=0;i<n;i++)marked[i]=INF;\n\t\tmarked[0]=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint p;\n\t\t\tcin>>p;\n\t\t\tedge[p-1].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar op;\n\t\t\tint v;\n\t\t\tcin>>op>>v;\n\t\t\tv--;\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[v]=min(marked[v],i+1);\n\t\t\t}else{\n\t\t\t\tbh[v].insert(i+1);\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tdfs(0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\ntypedef long long ll;\n\ntemplate<int um> class UF {\npublic:\n\tvector<int> par, rank;\n\tUF() { rank = vector<int>(um, 0); for (int i = 0; i<um; i++) par.push_back(i); }\n\tint operator[](int x) { return (par[x] == x) ? (x) : (par[x] = operator[](par[x])); }\n\tint operator()(int x, int y) {\n\t\tif ((x = operator[](x)) == (y = operator[](y))) return x;\n\t\tif (rank[x]<rank[y]) return par[x] = y;\n\t\trank[x] += rank[x] == rank[y]; return par[y] = x;\n\t}\n};\n\nint N, Q;\nvector<int> E[101010];\nint P[101010];\n\nchar O[101010];\nint V[101010];\n\nbool marked[101010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> Q)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) E[i].clear();\n\t\trep(i, 0, N) marked[i] = false;\n\n\t\tP[0] = -1;\n\t\trep(i, 1, N)\n\t\t{\n\t\t\tint p; cin >> p; p--;\n\t\t\tP[i] = p;\n\t\t\tE[i].push_back(p);\n\t\t\tE[p].push_back(i);\n\t\t}\n\n\t\tmarked[0] = true;\n\t\trep(i, 0, Q)\n\t\t{\n\t\t\tcin >> O[i] >> V[i];\n\t\t\tV[i]--;\n\t\t\tif(O[i] == 'M') marked[V[i]] = true;\n\t\t}\n\t\t\n\t\tUF<101010> uf;\n\t\trep(i, 0, Q) if (marked[i])\n\t\t{\n\t\t\tqueue<int> que;\n\t\t\tque.push(i);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint q = que.front(); que.pop();\n\t\t\t\tuf(i, q);\n\n\t\t\t\tfor (int to : E[q]) if (to != P[q]) if (!marked[to])\n\t\t\t\t{\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i, 0, N) cout << uf[i] << endl;\n\n\t\tll ans = 0;\n\t\trrep(i, Q - 1, 0)\n\t\t{\n\t\t\tint v = V[i];\n\t\t\tif (O[i] == 'M')\n\t\t\t{\n\t\t\t\tif (P[v] < 0) continue;\n\t\t\t\tuf(v, P[v]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += (ll)uf[V[i]];\n\t\t\t\t//cout << uf[V[i]];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000;\nconst int MAX_Q = 100000;\nint N, Q;\nint p[MAX_N+5];\nbool M[MAX_N+5];\nint uf_par[MAX_N+5];\nint uf_rank[MAX_N+5];\nint mark[MAX_N+5];\n\nvoid init(int n) {\n    for(int i = 0; i < N; i++) {\n        uf_par[i] = i;\n        uf_rank[i] = 0;\n        mark[i] = i;\n    }\n}\n\nint find(int x) {\n    if (uf_par[x] == x) {\n        return x;\n    } else {\n        return uf_par[x] = find(uf_par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(uf_rank[x] < uf_rank[y]) {\n        uf_par[x] = y;\n        mark[y] = mark[x];\n    } else {\n        uf_par[y] = x;\n        if(uf_rank[x] == uf_rank[y]) uf_rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid debug() {\n    for(int i = 0; i < N; i++) {\n        cout << i << \": \" << mark[i] << \": \" << uf_par[i] << endl;\n    }\n}\n\nint main() {\n    while(true) {\n        cin >> N >> Q;\n        if(!N && !Q) break;\n\n        init(N);\n        for(int i = 1; i < N; i++) {\n            cin >> p[i];\n            p[i]--;\n        }\n        vector<P> query;\n        char qm;\n        int num;\n        for(int i = 0; i < Q; i++) {\n            cin >> qm >> num;\n            num--;\n            if(qm == 'M') {\n                M[num] = true;\n            }\n            query.push_back(P(qm, num));\n        }\n\n        for(int i = 0; i < N; i++) {\n            if(!M[i]) {\n                // cout << \"unite \" << p[i] << \": \" << i << endl;\n                // cout << M[i] << endl;\n                unite(p[i], i);\n                // debug();\n            }\n        }\n\n        // cout << \"====\" << endl;\n        int count = 0;\n        for(int i = query.size()-1; i >= 0; i--) {\n            int n = query[i].second;\n            if(query[i].first == 'M') {\n                // cout << \"unite \" << p[n] << \": \" << n << endl;\n                unite(p[n], n);\n                // debug();\n            } else {\n                count += mark[find(n)] + 1;\n                // cout << \"n: \" << n << \" count += \" << mark[find(n)] << endl;\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long fa[100005],ans,a;\nint n,q,i;\nbool r[100005];\nchar c;\nlong long find(long long x)\n{\n\tif(r[x]==1)\n\t\treturn x;\n\treturn find(fa[x]);\n}\nint main()\n{\n\tfa[1]=1;\n\tr[1]=1;\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n==0||q==0)\n\t\t\treturn 0;\n\t\tans=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tr[i]=0;\n\t\tfor(i=2;i<=n;i++)\n\t\t\tscanf(\"%lld\",&fa[i]);\n\t\tfor(i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"\\n%c %lld\",&c,&a);\n\t\t\tif(c=='M')\n\t\t\t\tr[a]=1;\n\t\t\tif(c=='Q')\n\t\t\t\tans=ans+find(a);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n    \n    void pushc(int p,int l)\n    {\n        c[p].push_back(l);\n    }\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        unite(x+n,x);\n    }\n};\n\nint main()\n{\n    while(1)\n    {\n        int n,q;\n        stack<pair<char,int> > qu;\n        cin>>n>>q;\n        if(n==0) break;\n        UF uf(n);\n        for(int i=1;i<n;i++)\n        {\n            int p;\n            cin>>p;\n            uf.pushc(p-1,i);\n        }\n        for(int i=0;i<q;i++)\n        {\n            char temp;\n            int v;\n            cin>>temp>>v;\n            qu.push(P(temp,v-1));\n            if(temp=='M') uf.mark(v-1);\n        }\n        uf.furiwake(0);\n        \n        ll ans=0;\n        for(int i=0;i<q;i++)\n        {\n            pair<char,int> a=qu.top();\n            qu.pop();\n            if(a.first=='Q')\n            {\n                ans+=uf.score(a.second);\n            }\n            else\n            {\n                uf.delmark(a.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,1,1,0,-1,-1,-1};\nconst static int ty[] = {-1,-1,0,1,1,1,0,-1};\n \nstatic const double EPS = 1e-8;\n\nclass UnionFindTree {\nprivate:\n  int* par;\npublic:\n  UnionFindTree(int n){\n    par = new int[n]();\n    for(int i=0;i<n;i++){\n      par[i] = i;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] par;\n  }\n\n  int find(int x){\n    if(par[x] == x){\n      return x;\n    } else {\n      return par[x] = find(par[x]);\n    }\n  }\n\n  void unite(int x,int y){\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    par[x] = y;\n  }\n\n  bool same(int x,int y){\n    return find(x) == find(y);\n  }\n};\n\nvector<int> G[100001];\nint marked_count[100001];\nint prev_parent[100001];\n\nvoid dfs(int current_node,int parent,int last_marked_node,UnionFindTree* uft){\n  if(marked_count[current_node] > 0){\n    last_marked_node = current_node;\n  }\n\n  prev_parent[current_node] = parent;\n  uft->unite(current_node,last_marked_node);\n  for(int to_idx=0;to_idx<G[current_node].size();to_idx++){\n    int to = G[current_node][to_idx];\n    dfs(to,current_node,last_marked_node,uft);\n  }\n}\n\nint main(){\n  int total_nodes;\n  int total_queries;\n  while(~scanf(\"%d %d\",&total_nodes,&total_queries)){\n    if(total_nodes == 0 && total_queries == 0) break;\n\n    for(int i=0;i<=100000;i++) G[i].clear();\n\n    memset(marked_count,0,sizeof(marked_count));\n    for(int node_idx = 2;node_idx-1<total_nodes;node_idx++){\n      int parent;\n      scanf(\"%d\",&parent);\n      G[parent].push_back(node_idx);\n    }\n\n    int queries[100001];\n    for(int query_idx=0;query_idx < total_queries; query_idx++){\n      char operation[2];\n      int target_node;\n      scanf(\"%s %d\",operation,&target_node);\n      if(operation[0] == 'M'){\n\tmarked_count[target_node]++;\n\tqueries[query_idx] = target_node;\n      }\n      else if(operation[0] == 'Q'){\n\tqueries[query_idx] = -target_node;\n      }\n    }\n\n    UnionFindTree uft(total_nodes+1);\n    dfs(1,1,1,&uft);\n\n    int sum = 0;\n    for(int query_idx=total_queries-1;query_idx>=0;query_idx--){\n      if(queries[query_idx] <= 0){\n\tint target_node = -queries[query_idx];\n\tsum += uft.find(target_node);\n      }\n      else if(queries[query_idx] > 0){\n\tint target_node = queries[query_idx];\n\tmarked_count[target_node]--;\n\tif(marked_count[target_node] <= 0){\n\t  uft.unite(target_node,prev_parent[target_node]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",sum);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int N = 100010;\n\nint n, q, par[N];\nint find(int x)\n{\n    if(par[x] == x) \n        return x;\n    return find(par[x]);\n}\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &q))\n    {\n        if(n==0&&q==0)\n            break;\n        par[1] = 1;\n        for(int i = 2; i <= n; ++i)\n         scanf(\"%d\", &par[i]);\n        long long ans = 0;\n        for(int i = 1; i <= q; ++i)\n        {\n            char op[2];\n            int x;\n            scanf(\"%s%d\", op, &x);\n            if(op[0] == 'Q')\n                ans += find(x);\n            else par[x] = x;\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n\nint to[123456];\nchar o[123456];\nint v[123456];\nbool mark[123456];\n\nstruct unionfind{\n  vector<int> data;\n  unionfind(int n):data(n,-1){}\n  int root(int x)\n  {\n    return data[x]<0?x:data[x] = root(data[x]);\n  }\n  bool unionset(int x, int y)\n  {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (y < x) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  void print(){\n    REP(i,data.size()){\n      cout << i << \"->\" << data[i] << endl;\n    }\n  }\n};\nint main()\n{\n  int n;\n  int q;\n  while(cin >> n >> q,n+q){\n    REP(i,123456){\n      mark[i] = false;\n      to[i] = 0;\n      o[i] = '0';\n      v[i] = 0;\n    }\n    mark[0]=true;\n    unionfind uf(n);\n    REP(i,n-1){\n      int a;\n      cin >> a;\n      to[i+1] = a-1;\n    }\n    REP(i,q){\n      cin >> o[i] >> v[i];\n      v[i]--;\n      if(o[i]=='M'){\n       if(mark[v[i]]){\n         v[i]=0;\n        }\n       else{\n         mark[v[i]] = true;\n      }\n      }\n    }\n    int sum = 0;\n    \n    REP(i,n-1){\n      if(!mark[i+1]){\n        uf.unionset(i+1,to[i+1]);\n      }\n    }\n\n    for(int i = q-1;i>=0;--i){\n      if(o[i]=='Q'){\n        sum+=uf.root(v[i])+1;\n      }else{\n       uf.unionset(to[v[i]],v[i]);\n      }\n    }\n    cout << sum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n, q;\nvi par;\nvector<char> t;\nvi v;\nvi cnt;\n\nint lma(int x) {\n    if (cnt[x]) return x;\n    return par[x] = lma(par[x]);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> n >> q, n) {\n        par.assign(n, -1);\n        rep2(i, 1, n) {\n            int p;\n            cin >> p;\n            p--;\n            par[i] = p;\n        }\n\n        t.clear(); t.resize(n);\n        v.clear(); v.resize(n);\n        cnt.assign(n, 0);\n        cnt[0] = 1;\n        rep(i, q) {\n            cin >> t[i] >> v[i];\n            v[i]--;\n            if (t[i] == 'M') {\n                cnt[v[i]]++;\n            }\n        }\n\n        int ans = 0;\n        rrep(i, q) {\n            if (t[i] == 'M') {\n                cnt[v[i]]--;\n            }\n            else {\n                ans += lma(v[i]) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100016\n\nusing namespace std;\n\nint par[maxN], rank[maxN];\n\nvoid init(int x)\n{\n\tint i;\n\tfor (i = 0; i < x; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, j, x, sum;\n\tchar c;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tinit(n);\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = --x;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = sum = 0; i < t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tx--;\n\t\t\tif (c == 'Q')\n\t\t\t\tsum += find(x) + 1;\n\t\t\telse\n\t\t\t\tpar[x] = x;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\nint n, q, f[100005];\nlong long sum;\nint find(int v)\n{\n    int r = v;\n    while(r != f[r])\n        r = f[r];\n    return r;\n}\nint main()\n{\n    while (scanf(\"%d %d\", &n, &q) != EOF)\n    {\n        if (n == 0 && q == 0)\n            break;\n        sum = 0;\n        f[1] = 1;\n        for (int i = 2; i <= n; i++)\n            scanf(\"%d\", &f[i]);\n        for (int i = 0; i < q; i++)\n        {\n            getchar();\n            char s[10];\n            int a;\n            scanf(\"%s %d\", s, &a);\n            if (s[0] == 'M')\n                f[a] = a;\n            else if (s[0] == 'Q')\n                sum += find(a);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=100000;\nconst int MAX_Q=100000;\nint par[MAX_N+1];\nbool vis[MAX_N+1];\nint N, Q;\n\nint main(){\n\tfreopen(\"in.txt\", \"r\", stdin);\n    while(scanf(\"%d %d\", &N, &Q)&&N>0){\n        memset(vis, 0, sizeof(vis));\n        vis[1]=1;\n        for(int i=1; i<=N; i++) scanf(\"%d\", &par[i]);\n        long long cnt=0;\n        for(int i=1; i<=Q; i++){\n\t\t\tchar ch; int num;\n        \tscanf(\"%c \", &ch); \n\t\t\tscanf(\"%d \", &num); \n           if(ch=='M'){\n                vis[num]=1;\n            }\n            else if(ch=='Q'){\n                int cur=num;\n                while(cur>0){\n                    if(vis[cur]){\n                        cnt+=cur;\n                        break;\n                    }\n                    else cur=par[cur];\n                } \n            }\n        }\n        cout<<cnt<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, SIZE(vv)) {\n        REP(j, SIZE(vv[i])) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    if(a > b) swap(a, b);\n    if(a == 0) return b;\n    else return gcd(b%a, a);\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\nVI par, rnk, stp;\n\nint root(int x) {\n    if(stp[x]) return x;\n    else return par[x] = root(par[x]);\n}\n\nbool same(int x, int y) {\n    x = root(x);\n    y = root(y);\n    return x == y;\n}\n\nvoid unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(rnk[x] < rnk[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n}\n\n#define INF 1e8\n\nint main(void) {\n    int n, q;\n    while(1) {\n        cin >> n >> q;\n        if(n == 0 && q == 0) return 0;\n        par = VI(n);\n        iota(ALL(par), 0);\n        rnk = VI(n, 1);\n        stp = VI(n, 0);\n        stp[0] = 1;\n        FOR(i, 1, n) {\n            int tmp;\n            cin >> tmp;\n            tmp--;\n            par[i] = tmp;\n        }\n        LL ans = 0;\n        VS s(q);\n        VI v(q);\n        for(int i = q-1; i >= 0; i--) {\n            cin >> s[i] >> v[i];\n            v[i]--;\n            if(s[i] == \"M\") stp[v[i]]++; \n        }\n        // vprint(par);\n        // vprint(stp);\n        REP(i, q) {\n            if(s[i] == \"M\") {\n                stp[v[i]]--;\n            } else {\n                ans += root(v[i]) + 1;\n                // cerr << ans << endl;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main(void){\n  int n=0;\n  int q=0;\n  scanf(\"%d%d\",&n,&q);\n  while(n!=0){\n    int tree[100005][2]={0};\n    tree[1][0]=1;\n    tree[1][1]=1;\n    int ans=0;\n    int i=0;\n    for(i=2;i<=n;i++){\n      scanf(\"%d\",&(tree[i][0]));\n    }\n\n    char zi=0;\n    int no=0;\n    for(i=0;i<q;i++){\n      scanf(\"%s%d\",&zi,&no);\n      if(zi=='M'){\n\ttree[no][1]=1;\n      }\n      else if(zi=='Q'){\n\twhile(tree[no][1]==0){\n\t  \n\t  no=tree[no][0];\n\t   }\n\tans+=no;\n\tno=0;\n      }\n    }\n    /*for(i=1;i<=n;i++){\n      printf(\"%d%d\\n\",tree[i][0],tree[i][1]);\n      }*/\n    printf(\"%d\\n\",ans);\n    scanf(\"%d%d\",&n,&q);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nusing T = pair<int,int>;\nT INF = {1e9,1e9};\nclass RMQ{\n    int N;\n    vector<T> dat;\n\n    T impl(int l,int r,int k,int a,int b){\n        if(l<=a && b<=r) return dat[k];\n        if(r<=a || b<=l) return INF;\n        int mid = (a+b)/2;\n        return min(impl(l,r,k*2+1,a,mid),impl(l,r,k*2+2,mid,b));\n    }    \n    public:\n    RMQ(int n){\n        N=1;\n        while(N<n) N*=2;\n        dat.resize(2*N-1,INF);\n    }\n    void update(int pos,T v){\n        pos+=N-1;\n        dat[pos] = v;\n        while(pos){\n            int par = (pos-1)/2;\n            int c1 = par*2+1;\n            int c2 = par*2+2;\n            dat[par]=min(dat[c1],dat[c2]);\n            pos =par;\n        }\n    }\n    T get(int pos){\n        return dat[pos+N-1];\n    }\n\n    T query(int l,int r){\n        return impl(l,r,0,0,N);\n    }\n\n};\n\nusing Graph=vector<vector<int>>;\n\nstruct Query{\n    char qtype;\n    int t;\n    int v;\n};\n\nll dfs(int v,int height,Graph& g,vector<vector<Query>>& qs,RMQ& rmq){\n    stack<pair<int,T>> st;\n    ll res = 0;\n    for(auto q:qs[v]){\n        if(q.qtype=='M'){\n            st.push({q.t,rmq.get(q.t)});\n            rmq.update(q.t,{height,q.v});\n        }\n        else{\n            // cerr<<0<<\" \"<<q.t<<\" \"<<v<<endl;\n            // cerr<<q.t<<\" \"<<rmq.query(0,q.t).second+1<<endl;\n            res+=rmq.query(0,q.t).second+1;\n        }\n    }\n    for(auto to:g[v]){\n        res+=dfs(to,height-1,g,qs,rmq);\n    }\n    while(!st.empty()){\n        auto tmp = st.top(); st.pop();\n        rmq.update(tmp.first,tmp.second);\n    }\n    return res;\n}\nvoid solve(int n,int q){\n    Graph g(n);\n    for(int i=1;i<n;i++){\n        int p;\n        cin>>p; p--;\n        g[p].push_back(i);\n    }\n    vector<vector<Query>> qs(n);\n    for(int i=0;i<q;i++){\n        Query qu;\n        cin>>qu.qtype>>qu.v;\n        qu.v--;\n        qu.t = i+1;\n        qs[qu.v].push_back(qu);\n    }\n    RMQ rmq(q+1);\n    rmq.update(0,T{n,0});\n    cout<< dfs(0,n,g,qs,rmq)<<endl;\n}\nint main(){\n    int n,q;\n    while(cin>>n>>q,!(n==0 && q==0)){\n        solve(n,q);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=n-1;i>=(0);i--)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define eall(v) unique(all(v), v.end())\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\nconst ll INFF = 1e18;\n\nint N, Q;\nint p[100010];\nstring T[100010];\nint NUM[100010];\n\nvector<int> G[100010];\nint ans[100010];\nbool used[100010];\n\nvoid dfs(int u, int k) {\n\tfor(auto v : G[u]){\n\t\tans[v] = k;\n\t\tif(used[v]) continue;\n\t\tdfs(v, k);\n\t}\n}\n\nint main(void) {\n\twhile(1){\n\t\tscanf(\"%d %d\", &N, &Q);\n\t\tif(N == 0 && Q == 0) break;\n\t\trep(i, N - 1) scanf(\"%d\", &p[i]);\n\t\trep(i, Q){\n\t\t\tcin >> T[i] >> NUM[i];\n\t\t}\n\n\t\trep(i, 100010) G[i].clear();\n\t\trep(i, 100010) ans[i] = 1;\n\t\trep(i, 100010) used[i] = false;\n\n\t\trep(i, N - 1) G[p[i]].pb(i + 2);\n\n\t\tll ret = 0;\n\t\trep(i, Q) {\n\t\t\tif(T[i] == \"Q\") {\n\t\t\t\t// printf(\"ans %d\\n\", ans[NUM[i]] + 1);\n\t\t\t\tret += ans[NUM[i]];\n\t\t\t}else{\n\t\t\t\tdfs(NUM[i], NUM[i]);\n\t\t\t\tused[NUM[i]] = true;\n\t\t\t\tans[NUM[i]] = NUM[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#define MAX_N 100000\n#define MAX_Q 100000\n#define M 0\nusing namespace std;\n\nint par[MAX_N+1];//parents\nint Rank[MAX_N+1];//depth of tree\n\n//initialize\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//find root\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn find(par[x]);\n\t}\n}\n\n//unite group of x and group of y\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\n\tif(Rank[x] < Rank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t\t//in other cases we don't have to change rank[x] cos \n\t\t//rank of x is needed only if x is root of tree\n\t}\n}\n\n//check if x and y belong to the same group\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint N,Q,sum = 0;//sumのみ0で初期化\nint tree[MAX_N+1];\n\nint nearestAncstr(int num){\n\tif(same(num,M))return num;\n\tnearestAncstr(tree[num]);\n}\n\nvoid operate(char symbol,int num){\n\tif(symbol == 'Q'){\n\t\tsum += nearestAncstr(num);sum++;//1-indexed\n\t}else unite(num,M);\n}\n\nint num;char symbol;\n\n\nvoid solve(){\n\tinit(N);\n\tfor(int i = 1;i < N;i++){cin >>tree[i];tree[i]--;}//0-indexed\n\tcin >>symbol >>num;num--;\n\t//scanf(\"%c%d\",&symbol,&num);\n\twhile(!(symbol == '0' && num == -1)){\n\t\toperate(symbol,num);\n\t\tcin >>symbol >>num;num--;\n\t\t//scanf(\"%c%d\",&symbol,&num);\n\t}\n\tprintf(\"%d\\n\",sum);\n}\n\nint main(){\n\tcin >>N >>Q;\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n//#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n//#include <unordered_map>\n//#include <unordered_set>\n//#include <array>\n//#include <set>\n\nusing namespace std;\n\nusing ll_t = long long;\n// #define ll_t long long\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170&lang=jp\n\nclass MarkedTree {\npublic:\n    vector<size_t> parent;\n    vector<bool> marks;\n    explicit MarkedTree(size_t size) {\n        parent = vector<size_t>(size, 0);\n        marks = vector<bool>(size, false);\n        parent[0] = -1; // root\n        marks[0] = true;\n    }\n    size_t findMarkedParent(size_t node) {\n        if (marks[node]) {\n            return node;\n        } else {\n            size_t ret = findMarkedParent(parent[node]);\n            parent[node] = ret;\n            return ret;\n        }\n    }\n    void unMark(size_t node) {\n        marks[node] = false;\n    }\n    void mark(size_t node) {\n        marks[node] = true;\n    }\n    void setParent(size_t node, size_t parentNode) {\n        parent[node] = parentNode;\n    }\n};\n\nint main() {\n    while (true) {\n        int N, Q;\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) {\n            return 0;\n        }\n        MarkedTree tree(N);\n        for (int node = 1; node <= N-1; node++) {\n            int parent;\n            scanf(\"%d\", &parent);\n            tree.setParent(node, parent - 1);\n        }\n        vector<pair<char, int>> inputs;\n        inputs.reserve(Q);\n        for (int i = 0; i < Q; i++) {\n            char q;\n            int p;\n            scanf(\" %c\", &q);\n            scanf(\"%d\", &p);\n            if (q == 'M') {\n                if (!tree.marks[p-1]) {\n                    inputs.emplace_back(q,p);\n                }\n                tree.mark(p-1);\n            } else if (q == 'Q') {\n                inputs.emplace_back(q,p);\n            }\n        }\n        int querySum = 0;\n        for (int i = (int)inputs.size() - 1; i >= 0; i--) {\n            char q = inputs[i].first;\n            int node = inputs[i].second;\n            if (q == 'Q') {\n                querySum += tree.findMarkedParent(node - 1) + 1;\n            } else { // M\n                tree.unMark(node - 1);\n            }\n        }\n        cout << querySum << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\ntypedef long long ll;\n\nint n,m;\nconst int MAX_N=100005;\n\nint used[MAX_N];\nint mark[MAX_N];\nvector<int> child[100010];\nvoid dfs(int start,int root){\n    //cout<<used[start]<<start<<endl;\n    if(used[start]==1) return ;\n    mark[start]=root;\n    for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n}\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        //map<int,vector<int> > child;\n        //int used[MAX_N];\n        //int mark[MAX_N];\n        \n        for(int i=0;i<MAX_N;i++){\n            used[i]=0;\n            mark[i]=0;\n            child[i].clear();\n\n        }\n        \n\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            child[par].push_back(i+1);\n        }\n        ll ans=0;\n        used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                ans+=(ll)(mark[b]+1);\n            }\n            else {\n                dfs(b,b);\n                used[b]=1;\n                //for(int i=0;i<10;i++) cout<<mark[i]<<endl;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tvi T(n);\n\t\tvi m(n);\n\t\tvi mv(n);\n\t\tiota(ALL(mv), 0);\n\t\tm[0] = 1;\n\t\trep1(i, n - 1)cin >> T[i], T[i]--;\n\t\tvpii a(q);\n\t\tunionfind uf(n);\n\t\tll ans = 0;\n\t\trep(i, q) {\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif (c == 'M')m[v - 1] = 1;\n\t\t\ta[i] = { c,v };\n\t\t}\n\t\trrep(i, q) {\n\t\t\tif (a[i].first == 'M')m[a[i].second - 1] = 0;\n\t\t\telse {\n\t\t\t\tint v = a[i].second - 1;\n\t\t\t\twhile (!m[v = mv[uf.find(v)]])uf.unite(v, T[v]), mv[uf.find(v)] = mv[uf.find(T[v])];\n\t\t\t\tans += v + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n,q;\nint edge[200001];\nvector<int> G[200000];\nint par[200001];\nbool flag[200001];\nchar s[200001];\nint v[200001],fm[200001];\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tpar[i]=i;\n\t\tG[i].clear();\n\t}\n\tmemset(flag,false,sizeof(flag));\n\tmemset(fm,-1,sizeof(fm));\n}\n\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\tpar[x]=y;\n\t}\n\n}\n\nvoid unite_dfs(int v,int p){\n\tif(!flag[v])unite(v,p);\n\telse p=v;\n\tint np=p;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tunite_dfs(G[v][i],p);\n\t}\n\tif(np!=p)while(1);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&q);\n\t\tif(n+q==0)break;\n\t\tinit();\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&edge[i]);\n\t\t\tG[edge[i]].push_back(i);\n\t\t}\n\t\tflag[1]=true;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tcin >> s[i] >> v[i];\n\t\t\tif(s[i]=='M'){\n\t\t\t\tflag[v[i]]=true;\n\t\t\t\tif(fm[v[i]]==-1)fm[v[i]]=i;\n\t\t\t}\n\t\t}\n\t\tunite_dfs(1,1);\n\n\t\tlong long res=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(s[i]=='Q'){\n\t\t\t\tres+=(long long)find(v[i]);\n\t\t\t}\n\t\t\tif(s[i]=='M' && fm[v[i]]==i){\n\t\t\t\tunite(v[i],edge[v[i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 100010\n#define INF 1<<20\nusing namespace std;\n\nvector<int> lis[MAX];\n\nint u[MAX],r[MAX];\n\nbool vis[MAX];\n\nvoid DFS(int x,int len,int nod){\n\tvis[x]=true;\n\tr[x]=len,u[x]=nod;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!vis[lis[x][i]]&&r[lis[x][i]]>len+1){\n\t\t\tDFS(lis[x][i],len+1,nod);\n\t\t}\n\t}\n\tvis[x]=false;\n}\n\nint main(){\n\tint n,q,z;char w[2];\n\n\twhile(cin>>n>>q&&n){\n\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d\",&z);z--;\n\t\tlis[i].push_back(z);\n\t\tlis[z].push_back(i);\n\t\tr[i]=INF;\n\t}\n\tlong long ans=0;\n\n\tDFS(0,0,0);\n\twhile(q--){\n\t\tscanf(\"%s%d\",w,&z);z--;\n\n\t\tif(w[0]=='M'){\n\t\t\tDFS(z,0,z);\n\t\t}\n\t\telse{\n\t\t\tans+=u[z]+1;\n\t\t}\n\t}\n\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<memory.h>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\n#define maxn 100000\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[maxn+5];\nint node[maxn + 5];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemset(node, 0, sizeof(node));\n\t\tscanf_s(\"%d%d\", &N, &Q);\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tunsigned long long sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tscanf_s(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tnode[1] = 1;\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf_s(\"%c\", &ope);\n\t\t\tscanf_s(\"%c\", &ope);\n\t\t\tscanf_s(\"%d\", &a);\n\t\t\tif (ope == 'M')node[a] = a;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (node[a] != a)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += a;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint s[100001];\nint N, Q;\nint p[100001];\nint operation[100001];\n\nint find_root(int i);\n\nint find_p_root(int i)\n{\n\tif (s[i]==0) {\n\t\ts[i] = find_p_root(p[i]);\n\t\treturn s[i];\n\t}\n\telse if (s[i]!=-i) {\n\t\ts[i] = find_root(s[i]);\n\t\treturn s[i];\n\t}\n\telse\n\t\treturn i;\n\n}\n\nint find_root(int i)\n{\n\tif (s[i]!=-i) {\n\t\ts[i] = find_root(s[i]);\n\t\treturn s[i];\n\t}\n\telse\n\t\treturn i;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &Q)==2) {\n\t\tif (N==0 && Q==0) break;\n\t\tint i;\n\t\tp[1] = 1;\n\t\tfor (i=2; i<=N; i++) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\tchar c;\n\t\tfor (i=0; i<Q; i++) {\n\t\t\tdo { c = getchar();\n\t\t\t} while (c!='M' && c!='Q');\n\t\t\tscanf(\"%d\", &operation[i]);\n\t\t\tif (c=='Q')\n\t\t\t\toperation[i] = -operation[i];\n\t\t}\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\ts[i] = 0;\n\t\t}\n\t\ts[1] = -1;\n\t\tfor (i=0; i<Q; i++) {\n\t\t\tif (operation[i]>0) {\n\t\t\t\ts[operation[i]] = -operation[i];\n\t\t\t}\n\t\t}\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (s[i]==0) {\n\t\t\t\tint root = find_p_root(i);\n\t\t\t\ts[i] = root;\n\t\t\t}\n\t\t}\n\n\t\tlong long sum = 0;\n\t\tfor (i=Q-1; i>=0; i--) {\n\t\t\tif (operation[i]<0) {\n\t\t\t\tint root = find_root(-operation[i]);\n\t\t\t\tsum += root;\n\t\t\t}\n\t\t\telse if (operation[i]>0) {\n\t\t\t\tif (operation[i]!=1) {\n\t\t\t\t\tint parent = p[operation[i]];\n\t\t\t\t\ts[operation[i]] = parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\nconst int iINF = 1L << 30;\n\n// lazy evaluate segment tree\ntypedef int data_type;\nconst data_type dINF = iINF;\n\nstruct SegmentTreeL {\n\tint st_size;\n\tvector< data_type > data;\n\tvector< data_type > lazy;\n\t\n\tSegmentTreeL(int _size, data_type _init_val) {\n\t\tst_size = 1;\n\t\twhile (st_size < _size) st_size *= 2;\n\t\tdata.assign(2 * st_size - 1, _init_val);\n\t\tlazy.assign(2 * st_size - 1, 0);\n\t}\n\t\n\tdata_type calculation(data_type _d1, data_type _d2) {\n\t\treturn min(_d1, _d2);\n\t}\n\t\n\tvoid lazy_calculation(int _k, data_type _val) {\n\t\tlazy[_k] = _val;\n\t}\n\t\n\tinline void lazy_evaluate(int _a, int _b, int _k) {\n\t\t// change for purpose\n\t\tif (lazy[_k] != 0) {\n\t\t\tdata[_k] = lazy[_k];\n\t\t\tif (_k < st_size - 1) {\n\t\t\t\tlazy_calculation(2 * _k + 1, lazy[_k]);\n\t\t\t\tlazy_calculation(2 * _k + 2, lazy[_k]);\n\t\t\t}\n\t\t}\n\t\tlazy[_k] = 0;\n\t}\n\t\n\tinline void update_at(int _k) {\n\t\tdata[_k] = calculation(data[2 * _k + 1], data[2 * _k + 2]);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x) {\n\t\tupdate(_a, _b, _x, 0, 0, st_size);\n\t}\n\t\n\tvoid update(int _a, int _b, data_type _x, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return;\n\t\tif (_a <= _l && _r <= _b) {\n\t\t\tlazy_calculation(_k, _x);\n\t\t\tlazy_evaluate(_a, _b, _k);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(_a, _b, _x, 2 * _k + 1, _l, (_l + _r) / 2);\n\t\tupdate(_a, _b, _x, 2 * _k + 2, (_l + _r) / 2, _r);\n\t\t//update_at(_k);\n\t}\n\t\n\tdata_type query(int _a, int _b) {\n\t\treturn query(_a, _b, 0, 0, st_size);\n\t}\n\t\n\tdata_type query(int _a, int _b, int _k, int _l, int _r) {\n\t\tlazy_evaluate(_a, _b, _k);\n\t\t\n\t\tif (_r <= _a || _b <= _l) return dINF;\n\t\t\n\t\tif (_a <= _l && _r <= _b) return data[_k];\n\t\t\n\t\tdata_type res = calculation(query(_a, _b, 2 * _k + 1, _l, (_l + _r) / 2),\n\t\t\t\t\t\t\t\t\tquery(_a, _b, 2 * _k + 2, (_l + _r) / 2, _r));\n\t\t//update_at(_k);\n\t\treturn res;\n\t}\n\t\n\tint size() {\n\t\treturn st_size;\n\t}\n};\n\nint N, Q;\n\nvector< int > node_number;\nvector< pii > ranges;\nvector< vector< int > > edges;\n\nint dfs(int v, int& d) {\n\tint mn = iINF;\n\t\n\tint e_size = (int)edges[v].size();\n\tfor_(i,0,e_size) {\n\t\tint u = edges[v][i];\n\t\tint res = dfs(u, d);\n\t\tmn = min(mn, res);\n\t}\n\t\n\t++d;\n\tranges[v] = pii(min(mn, d), d);\n\tnode_number[v] = d;\n\t\n\treturn min(mn, d);\n}\n\nvoid solve() {\n\tnode_number.assign(N + 1, -1);\n\tranges.assign(N + 1, pii(-1, -1));\n\t\n\tSegmentTreeL stl(N + 10, iINF);\n\tfor_(i,1,N+1) stl.update(i, i + 1, 1);\n\t\n\tint d = 0;\n\tdfs(1, d);\n\t\n\tlint ans = 0;\n\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \" << node_number[i] << \" \" << ranges[i].first << \" \" << ranges[i].second << endl;\n\tfor_(i,0,Q) {\n\t\tchar q; int v;\n\t\tcin >> q >> v;\n\t\t\n\t\tif (q == 'Q') {\n\t\t\tint nn = node_number[v];\n\t\t\tans += (lint)stl.query(nn, nn + 1);\n\t\t} else {\n\t\t\tpii rng = ranges[v];\n\t\t\tstl.update(rng.first, rng.second + 1, v);\n\t\t}\n\t\t\n\t\t//for_(i,1,N+1) cout << stl.query(i, i + 1) << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> Q, N) {\n\t\tedges.assign(N + 1, vector< int >());\n\t\t\n\t\tfor_(i,2,N+1) {\n\t\t\tint p; cin >> p;\n\t\t\tedges[p].push_back(i);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#define maxN 100000 + 16\n\nusing namespace std;\n\nint par[maxN], mark[maxN];\nint qx[maxN], qt[maxN], tt;\n\nint find(int x)\n{\n\treturn mark[x] < tt ? x : par[x] = find(par[x]);\n}\n\nint main()\n{\n\tint n, t, i, x, nn;\n\tchar c;\n\tlong long sum;\n\twhile (scanf(\"%d%d\", &n, &t) && (n || t))\n\t{\n\t\tpar[1] = 1;\n\t\tmark[1] = 0;\n\t\tfor (i = 2; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tpar[i] = x;\n\t\t\tmark[i] = maxN;\n\t\t}\n\t\tgetchar();\n\t\tfor (i = nn = 1; i <= t; i++)\n\t\t{\n\t\t\tscanf(\"%c%d%*c\", &c, &x);\n\t\t\tif (c == 'M' && mark[x] > i)\n\t\t\t\tmark[x] = i;\n\t\t\telse\n\t\t\t{\n\t\t\t\tqx[nn] = x;\n\t\t\t\tqt[nn++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (i = nn - 1, sum = 0; i >= 1; i--)\n\t\t{\n\t\t\ttt = qt[i];\n\t\t\tsum += find(qx[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAX 100001\n\nusing namespace std;\n\nint mark[MAX],t[MAX];\n\nint query(int v){\n  if(mark[v]) return v;\n  else return t[v] = query(t[v]);\n}\n\nint main(){\n  int n,q;\n  while(scanf(\"%d %d\",&n,&q),n){\n    int ans=0;\n    deque<pair<char,int> > qs;\n\n    for(int i=1; i<=n; i++) mark[i]=0; mark[1]=1;\n\n    for(int i=2; i<=n; i++){\n      int p;\n      scanf(\"%d\",&p);\n      t[i] = p;\n    }\n\n    for(int i=0; i<q; i++){\n      char order; int v;\n      scanf(\" %c %d\",&order,&v);\n      if(order=='M')\n\tmark[v] = 1;\n      qs.push_front(make_pair(order,v));\n    }\n\n    // printf(\"asdf %d\\n\",(int)qs.size());\n    // for(int i=0; i<qs.size(); i++){\n    //   printf(\"%c %d\\n\",qs[i].first,qs[i].second);\n    // }\n\n    for(int i=0; i<qs.size(); i++)\n      if(qs[i].first=='Q')\n\tans += query(qs[i].second);\n      else\n\tmark[qs[i].second] = 0;\n    \n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint par[100005];\nint find(int x){\n\treturn x == par[x]?x:find(par[x]); \n} \nint main(){\n\tint n,q,i,j;\n\twhile(cin>>n>>q&&(n+q)){\n\t\tfor(i=1;i<n;i++)\n\t\t\tscanf(\"%d\",&par[i+1]);\n\t\t\tpar[1]=1;\n\t\t\tgetchar();\n\t\t\tchar c ;\n\t\t\tlong long ans =0;\n\t\t\tfor(i=1;i<=q;i++){\n\t\t\t\tc=getchar();\n\t\t\t\tscanf(\"%d\",&j);\n\t\t\t\tgetchar();\n\t\t\t\tif(c=='M')\n\t\t\t\tpar[j]=j;\n\t\t\t\telse{\n\t\t\t\t\tans+=(long long)find(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <stack>\n#include <map>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nconst int maxn = 1e5+100;\nconst int INF = 0x3f3f3f3f;\n#define pr(x)      // cout << #x << \" = \" << x << \" \";\n#define prln(x)    // cout << #x << \" = \" << x <<endl;\n#define ll long long\nint head[maxn], nxt[maxn], to[maxn], dfsn, cnt, id[maxn], r[maxn], _n, sum[maxn<<2], dep[maxn];\nvoid addedge(int u, int v) {\n\tnxt[cnt] = head[u];\n\thead[u] = cnt;\n\tto[cnt++] = v;\n}\nvoid init(int n) {\n\tcnt = dfsn = 0;\n\t_n = 1;\n\twhile(_n < n) _n = _n*2;\n\tint _nn = _n*2;\n\tfor(int i = 0; i <= _nn; ++i) sum[i] = -1;\n\tfor(int i = 0; i <= n;++i) {\n\t\thead[i] =-1;\n\t}\n}\n\nvoid dfstree(int fa,int u) {\n\tid[u] = ++dfsn;\n\tdep[u] = dep[fa]+1;\n\tfor(int i = head[u]; ~i; i = nxt[i]){\n\t\tdfstree(u,to[i]);\n\t}\n\tr[u] = dfsn;\n}\ninline void getans(int& ans, const int& v2){\n\tif(ans == -1 || dep[ans] < dep[v2]) ans = v2;\n}\nvoid pushdown(int rt) {\n\tif(sum[rt] != -1) {\n\t\tgetans(sum[rt<<1], sum[rt]);\n\t\tgetans(sum[rt<<1|1],sum[rt]);\n\t}\n}\nvoid update(int rt, int l, int r, int ql, int qr, int v) {\n\tif(ql <= l && r <= qr) {\n\t\tgetans(sum[rt], v);\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tint m = l + r >> 1;\n\tif(m >= ql) update(rt<<1, l, m, ql, qr, v);\n\tif(m < qr) update(rt<<1|1, m+1, r, ql, qr, v);\n}\nint query(int rt) {\n\trt += _n-1;\n\tint ans = 0;\n\twhile(rt>=1) {\n\t\tgetans(ans,sum[rt]);\n\t\trt = rt>>1;\n\t}\n\treturn ans;\n}\nint main(){\n#ifdef LOCAL\n    freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\",\"r\",stdin);\n  //freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\out.txt\",\"w\",stdout);\n #endif\n    int n, m, x;\n    char op[10];\n    while(cin >> n >> m && (n||m)) {\n    \tll ans = 0;\n    \tinit(n);\n    \tfor(int i = 2; i <= n; ++i) {\n    \t\tscanf(\"%d\", &x);\n    \t\taddedge(x,i);\n    \t}\n    \tdep[0] = 0;\n    \tdfstree(0,1);\n    \tupdate(1, 1, _n, id[1], r[1], 1);\n    \tfor(int i = 0; i < m; ++i) {\n    \t\tscanf(\"%s%d\", op, &x);\n    \t\tif(op[0] == 'M')\tupdate(1, 1, _n, id[x], r[x], x);\n    \t\telse\tans += query(id[x]);\n    \t}\n    \tprintf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,bool> P;\nint N,Q;\nint p[1000000];\nbool hoge[10000000];\nint q;\nchar s;\n\nint parent(int x){\n  if(hoge[p[x]]==1) return p[x];\n  else return parent(p[x]);\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\",&N,&Q);\n    if(N==0) break;\n    memset(p,0,sizeof(p));\n    memset(hoge,0,sizeof(hoge));\n    p[1]=-1;\n    hoge[1]=1;\n    lli res=0;\n    for(int i=2;i<=N;i++) scanf(\"%d\\n\",&p[i]);\n    for(int i=0;i<Q;i++) {\n      scanf(\"%c %d\\n\",&s,&q);\n//      printf(\"%d\\n\",hoge[q]);\n      if(s=='M'){\n        hoge[q]=1;\n      }\n      if(s=='Q'){\n        res+=parent(q);\n      }\n    }\n\n    printf(\"%lld\\n\",res);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<cmath>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n\ninline int input(){\n\tchar c;\n\tfor(c = getchar();c<'0' || c>'9';c = getchar());\n\tint res = c - '0';\n\tfor(c = getchar();c>='0' && c<='9';c = getchar()) res = res * 10 + (c - '0');\n\treturn res;\n}\ninline char letter(){\n\tchar c;\n\tfor(c = getchar();c != 'M' && c != 'Q';c = getchar());\n\treturn c;\n}\nint n,q,p[100005],par[100005];\nint mark[100005];\nchar c[100005];\nint v[100005];\ninline void ini(int x){\n\tfor(int i=1;i<=x;i++){\n\t\tif(mark[i]) par[i] = i;\n\t\telse par[i] = p[i];\n\t}\n}\nint find_(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find_(par[x]);\n}\nint main(){\n//\tios::sync_with_stdio(false);\n\twhile(true){\n\t\tll ans = 0;\n\t\tn = input();\n\t\tq = input();\n\t\tif(n == 0 && q == 0) break;\n\t\tp[1] = 1;\n\t\tmark[1] = 1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tp[i] = input();\n\t\t}\n\t\tfor(int i=1;i<=q;i++){\n\t\t\tc[i] = letter();\n\t\t\tv[i] = input();\n\t\t\tif(c[i] == 'M') mark[v[i]]++;\n\t\t}\n\t\tini(n);\n\t\tfor(int i=q;i>=1;i--){\n\t\t\tif(c[i] == 'Q') ans += find_(v[i]);\n\t\t\telse{\n\t\t\t\tmark[v[i]]--;\n\t\t\t\tif(!mark[v[i]]) par[v[i]] = p[v[i]];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\n\n// #define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define per(i,b) for(ll i=b-1;i>=0;i--)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\nstruct Node {\n    int par;\n    vi cs;\n    Node(int p, vi const& cs) : par(p), cs(cs) {}\n    Node(){}\n};\n\nvi ansester;\nvi marked;\n\nvoid update(vector<Node> & g, int v, int a){\n    ansester[v] = a;\n    for(int c : g[v].cs) if(!marked[c]) update(g,c,a);\n}\n\nint solve(vector<Node> & g, vector<pair<char,int>> & query){\n    ansester.assign(g.size()+1, 1);\n    marked.assign(g.size()+1, 0);\n    int ans = 0;\n    for(auto & p : query){\n        char q; int v;\n        tie(q,v) = p;\n        if(q=='M'){\n            update(g,v,v);\n            marked[v] = true;\n        } else {\n            ans += ansester[v];\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    int N, Q;\n    while(cin>>N>>Q && N){\n        vector<Node> g(N+1);\n        rep(i,N-1){\n            int x; cin>>x;\n            g[i+2].par = x;\n            g[x].cs.eb(i+2);\n        }\n        vector<pair<char,int>> query(Q);\n        rep(i,Q){\n            char c; int v;\n            cin >> c >> v;\n            query[i] = mp(c,v);\n        }\n        cout << solve(g,query) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nint root;\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start){\n            if(used[start]==1 or mark[start]==root) return ;\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++) dfs(child[start][i]);\n        }\n};\nint main(){\n    while(1){\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 and m==0)break;\n    ut tmp;\n    for(int i=0;i<n-1;i++){\n        int par;\n        scanf(\"%d\",&par);\n        par--;\n        tmp.child[par].push_back(i+1);\n    }\n    int ans=0;\n    tmp.used[0]=1;\n\n    for(int i=0;i<m;i++){\n        char a;\n        int b;\n        cin>>a>>b;\n        if (a=='Q') {\n            //cout<<\"as\"<<tmp.mark[b-1]<<endl;\n            ans+=(tmp.mark[b-1]+1);\n        }\n        else {\n            root=b-1;\n            tmp.dfs(b-1);\n            tmp.used[b-1]=1;\n        }\n    }\n    cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: 王文宇\n* @Date:   2018-03-18 23:31:38\n* @Last Modified by:   王文宇\n* @Last Modified time: 2018-03-18 23:36:46\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define _for(i,a,b) for(int i=a;i<=b;i++)\nconst int maxn = 100007;\nint fa[maxn],vis[maxn],n,m;\nint main(int argc, char const *argv[])\n{\n\twhile(cin>>n>>m)\n\t{\n\t\tint sum = 0;\n\t\tif(n==0&&m==0)break;\t\n\t\tfa[1]=1;\n\t\tvis[1]=1;\n\t\t_for(i,2,n)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tfa[i]=x;\n\t\t}\n\t\t_for(i,1,m)\n\t\t{\n\t\t\tchar s;\n\t\t\tint x;\n\t\t\tcin>>s>>x;\n\t\t\tif(s=='Q')\n\t\t\t{\n\t\t\t\tint k = x;\n\t\t\t\twhile(vis[k]!=1)\n\t\t\t\t{\n\t\t\t\t\tk=fa[k];\n\t\t\t\t}\n\t\t\t\tsum+=k;\n\t\t\t}\n\t\t\telse vis[x]=1;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int lli;\n\nvector<int> a;\n\nint find(int m){\n\tif(a[m] == m)\n\t\treturn m;\n\treturn find(a[m]);\n}\n\n\nint main(void){\n\tint n, q, p, v, i;\n\tlli ans;\n\tchar c;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(n == 0 && q == 0)\n\t\t\tbreak;\n\t\tans = 0;\n\t\ta.push_back(0);\n\t\ta.push_back(1);\n\t\tfor(i = 2;i <= n;i++){\n\t\t\tscanf(\"%d%*c\",&p);\n\t\t\ta.push_back(p);\n\t\t}\n\t\tfor(i = 0;i < q;i++){\n\t\t\tscanf(\"%c%d%*c\",&c,&v);\n\t\t\tif(c == 'Q'){\n\t\t\t\tans += (lli)find(v);\n\t\t\t}\n\t\t\telse if(c == 'M'){\n\t\t\t\ta[v] = v;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t\ta.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint pre[100005];\nint find_root(int x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    int n, q;\n    while(scanf(\"%d%d\", &n, &q), n || q)\n    {\n        pre[1] = 1;\n        for(int i = 2; i <= n; i++)\n            scanf(\"%d\", &pre[i]);\n        char a;\n        int b;\n        int ans = 0;\n        while(q--)\n        {\n            scanf(\" %c%d\", &a, &b);\n            if(a == 'Q')\n                ans += find_root(b);\n            else\n                pre[b] = b;\n        }\n        printf(\"%dn\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define all(n)\tn.begin(),n.end()\n#define each(i,n) for(auto &i : n)\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> to;\n\tUnionFind(int size) : data(size, -1), to(size,-1) {\n\t\trep(i, size)to[i] = i;\n\t}\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tvoid setTo(int x, int to) {\n\t\tthis->to[root(x)] = to;\n\t}\n\tint findTo(int x) {\n\t\treturn to[root(x)];\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n\nsigned main() {\n\n\tint n, q;\n\twhile (cin >> n >> q && n) {\n\t\tstruct edge {\n\t\t\tint p, m;\n\t\t\tint count;\n\t\t\tvector<int> t;\n\t\t};\n\n\t\tvector<edge> e(n + 1);\n\t\tfor (int i = 1; i < n;i++) {\n\t\t\tcin >> e[i].p; \n\t\t\te[i].p--; \n\t\t\te[i].m = -1;\n\t\t\te[i].count = 0;\n\t\t\te[e[i].p].t.push_back(i);\n\t\t}\n\t\te[0].m = 0; e[0].count = 1;\n\n\t\tvector<int> v(q);\n\t\tvector<char> c(q);\n\t\trep(i, q) {\n\t\t\tcin >> c[i] >> v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[v[i]].m = --v[i];\n\t\t\t\te[v[i]].count++;\n\t\t\t}\n\t\t}\n\t\tfunction<void(int, int)> dfs = [&](int a,int b) {\n\t\t\tif (e[a].m == -1) {\n\t\t\t\te[a].m = b;\n\t\t\t}\n\t\t\trep(i, e[a].t.size()) {\n\t\t\t\tdfs(e[a].t[i], e[a].m);\n\t\t\t}\n\t\t};\n\t\tdfs(0, 0);\n\t\tll ans = 0;\n\t\tUnionFind uf(n);\n\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint j = v[i];\n\t\t\tif (c[i] == 'M') {\n\t\t\t\te[j].count--;\n\t\t\t\tif (e[j].count == 0) {\n\t\t\t\t\tint root = uf.findTo(e[e[j].p].m);\n\t\t\t\t\tuf.unionSet(e[j].m, e[e[j].p].m);\n\t\t\t\t\tuf.setTo(e[j].m, root);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += uf.findTo(e[j].m) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\t\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma, ism;\nvector <query> q;\n\n//find nearest marked ancestor (経路圧縮 at the same time)\nll find_nma(ll x){\n\tif (nma[x] == x) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\tENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd]++;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd]--;\n\t\t\t\tif (ism[q[i].snd]) continue;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tmap<int,int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.count(v) != 0) continue;\n\t\t\tif(c == 'M') roots[v] = a[v];\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> p;\n\n\nint n,m;\nconst int MAX_N=100005;\nint used[MAX_N];\nclass ut{\n    public:\n        int mark[MAX_N];\n        map<int,vector<int> > child;\n        int used[MAX_N];\n        void dfs(int start,int root){\n            if(mark[start]==root or mark[start]==start) return ;\n            mark[start]=root;\n            for(int i=0;i<child[start].size();i++) dfs(child[start][i],root);\n        }\n};\nint main(){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0 and m==0)break;\n        ut tmp;\n        for(int i=0;i<n-1;i++){\n            int par;\n            scanf(\"%d\",&par);\n            par--;\n            tmp.child[par].push_back(i+1);\n        }\n        int ans=0;\n        tmp.used[0]=1;\n\n        for(int i=0;i<m;i++){\n            char a;\n            int b;\n            cin>>a>>b;\n            b--;\n            if (a=='Q') {\n                //cout<<\"as\"<<tmp.mark[b-1]<<endl;\n                ans+=(tmp.mark[b]+1);\n            }\n            else {\n                tmp.dfs(b,b);\n                tmp.used[b]=1;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "//\n//  2170.cpp\n//  \n//\n//  Created by Yoshida Satoshi on 2018/10/28.\n//\n\n#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <utility>\n\n#define MAX 100010\n#define P make_pair\ntypedef long long ll;\n\nusing namespace std;\n\nstruct UF\n{\n    vector<int> par;\n    vector<int> rank;\n    bool m[MAX];\n    vector<int> c[MAX];\n    int n;\n    \n    UF(int k):par(2*k),rank(2*k)\n    {\n        n=k;\n        for(int i=0;i<2*n;i++) par[i]=i;\n        for(int i=0;i<2*n;i++) rank[i]=0;\n        for(int i=0;i<n;i++)   m[i]=false;\n        m[0]=true;\n    }\n\n    \n    void mark(int x)\n    {\n        m[x]=true;\n    }\n    \n    int root(int x)\n    {\n        if(par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    \n    void unite(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        par[rx]=ry;\n    }\n    \n    bool same(int x,int y)\n    {\n        int rx=root(x);\n        int ry=root(y);\n        \n        return rx==ry;\n    }\n    \n    void furiwake(int x)\n    {\n        for(int i=0;i<c[x].size();i++)\n        {\n            if(m[x]) par[c[x][i]]=x+n;\n            else     unite(c[x][i],x);\n            furiwake(c[x][i]);\n        }\n    }\n    \n    int score(int x)\n    {\n        return root(x)-n+1;\n    }\n    \n    void delmark(int x)\n    {\n        if(!m[x]) return;\n        par[x+n]=x;\n    }\n};\n\nint main()\n{\n    int n,q;\n    stack<pair<char,int> > qu;\n    cin>>n>>q;\n    UF uf(n);\n    for(int i=1;i<n;i++)\n    {\n        int p;\n        cin>>p;\n        (uf.c[p-1]).push_back(i);\n    }\n    for(int i=0;i<q;i++)\n    {\n        char temp;\n        int v;\n        cin>>temp>>v;\n        qu.push(P(temp,v-1));\n        if(temp=='M') uf.mark(v-1);\n    }\n    int a,b;\n    cin>>a>>b;\n    uf.furiwake(0);\n    \n    ll ans=0;\n    for(int i=0;i<q;i++)\n    {\n        pair<char,int> a=qu.top();\n        qu.pop();\n        if(a.first=='Q')\n        {\n            ans+=uf.score(a.second);\n        }\n        else\n        {\n            uf.delmark(a.second);\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1147483647;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define gchar(i) scanf(\"%c\",&(i))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n\n//#define my_debug\n\nconst int MAX_N = 100005;\nint all[MAX_N];\nbool stu[MAX_N];\n\nint n, q;\n\nvoid solve(){\n\n}\n\nint get_f(int i){\n\tint out = all[i];\n\tif (stu[out])\n\t\treturn out;\n\telse\n\t\treturn get_f(out);\n}\n\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,q) != EOF){\n\t\tint out = 0;\n\t\tif (n == 0 && q == 0)\n\t\t\tbreak;\n\t\tinit(all, 0);\n\t\tinit(stu, 0);\n\t\tstu[1] = true;\n\t\tall[1] = 1;\n\t\trep(i, 2, (n + 1)){\n\t\t\tgint(all[i]);\n\t\t}\n\t\trep(i, 0, q){\n\t\t\tchar c;\n\t\t\tint tmp;\n\t\t\tgchar(c);\n\t\t\tgchar(c);\n\t\t\tgint(tmp);\n\t\t\tif (c == 'Q'){\n\t\t\t\tout += get_f(tmp);\n\t\t\t}\n\t\t\telse if (c == 'M'){\n\t\t\t\tstu[tmp] = true;\n\t\t\t}\n\t\t}\n\t\tpint(out);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]].insert(mp(-depth[v], v));\n    }\n    int query(int v){\n        while(1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        set<pair<int,int>> marks;\n        marks.insert(make_pair(0,0));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q') ans += marks.lower_bound(make_pair(-d, -inf))->second + 1;\n            else marks.insert(mp(-d, qv[i]));\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n            else h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[105000];\nlong long res;\nint marked[105000];\npair<char, int> query[105000];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tscanf(\"%d%d\", &n, &q);\n//\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, 0);\n\tmarked[0] = true;\n\tfor(int i = 1;i < n;i++){\n\t    cin >> root[i];\n\t    root[i]--;\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    query[i].second--;\n\t    marked[query[i].second] += (query[i].first == 'M');\n\t}\n\tfor(int i=q;i-- > 0;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second]--;\n\t    }else{\n\t\tres += r(query[i].second) + 1;\n\t    }\n\t}\n\tprintf(\"%lld\\n\", res);\n//\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=100010;\nconst int qmax=100010;\n\nvi trees[nmax];\nint p[nmax];\nint last[nmax];\n\nvoid add_edge(int a,int b){\n\ttrees[a].pb(b);\n\ttrees[b].pb(a);\n}\n\nint uf[nmax];\nint find(int i){\n\tif(uf[i]==i)\n\t\treturn i;\n\treturn uf[i]=find(uf[i]);\n}\n\nvoid unite(int p,int c){\n\tuf[c]=p;\n\treturn;\n}\n\n\nvoid dfs(int v,int p){\n\tif(last[v]==-1)\n\t\tunite(p,v);\n\tfor(auto &e:trees[v]){\n\t\tif(e!=p)\n\t\t\tdfs(e,v);\n\t}\n}\n\n\nchar type[qmax];\nint num[qmax];\n\nint main(void){\n\tint n,q;\n\twhile(cin >> n >> q){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\ttrees[i].clear();\n\t\t\tuf[i]=i;\n\t\t\tlast[i]=-1;\n\t\t}\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tcin >> p[i];\n\t\t\tadd_edge(p[i],i);\n\t\t}\n\t\tlast[1]=-2;\n\t\trep(i,q){\n\t\t\tcin >> type[i] >> num[i];\n\t\t\tif(type[i]=='M'&&last[num[i]]==-1)\n\t\t\t\tlast[num[i]]=i;\n\t\t}\n\t\tdfs(1,-1);\n\t\tll ans=0;\n\t\tfor(int i=q-1;i>=0;--i){\n\t\t\tif(type[i]=='Q')\n\t\t\t\tans+=find(num[i]);\n\t\t\telse{\n\t\t\t\tif(last[num[i]]==i)\n\t\t\t\t\tunite(p[num[i]],num[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> par, rank;\n\n    UnionFind(int n) {\n        rep(n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    int find(int x) {\n        return ((par[x] == x) ? x : par[x] = find(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if(x == y) return;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n        return;\n    }\n\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint main() {\n    ll n,q,node;\n    char c;\n    cin >> n >> q;\n    while(n || q){\n        vector<ll> parent(n+1, 1);\n        ll ans = 0;\n        reppp(i, 2, n+1){\n            cin >> node;\n            parent[i] = node;\n        }\n\n        vector<Pll> query(q);\n        vector<bool> marked(n+1, false);\n        rep(q){\n            cin >> c >> query[i].second;\n            query[i].first = (c=='Q'?1:0);\n            if(c == 'M') marked[query[i].second] = true;\n        }\n        UnionFind uf = UnionFind(n+1);\n        reppp(i, 2, n+1){\n            if(marked[i]) continue;\n            uf.unite(parent[i], i);\n        }\n        for(int i=q-1;i>=0;--i){\n            if(query[i].first){\n                ans += uf.find(query[i].second);\n            }else{\n                uf.unite(parent[query[i].second], query[i].second);\n            }\n        }\n        cout << ans << endl;\n        cin >> n >> q;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#define inf 0x7fffffff\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=1e9+10;\nconst int MAX=100000+10;\nint f[MAX];\nint vis[MAX];\nint sum;\nint find(int x,int flag){\n    if(flag||x==1)    return 0;\n    else{\n        if(vis[f[x]]){\n            sum+=f[x];\n            find(f[x],1);\n        }\n        else\n            find(f[x],0);\n    }\n}\nint main(){\n   #ifdef SIYU\n   freopen(\"in.txt\",\"r\",stdin);\n   #endif // SIYU\n   //ios::sync_with_stdio(false);\n   int n,m;\n    while(scanf(\"%d%d\",&n,&m)&&(n+m)){\n        memset(vis,0,sizeof(vis));\n        f[1]=1;sum=0;vis[1]=1;\n        for(int i=2;i<=n;i++){\n            cin>>f[i];\n        }\n        for(int i=0;i<m;i++){\n            getchar();\n            char ch;int t;\n            scanf(\"%c%d\",&ch,&t);\n            if(ch=='M'){\n                vis[t]=1;\n            }\n            else{\n                find(t,0);\n            }\n        }\n        cout<<sum<<endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint pre[100005];\nint find_root(int x)\n{\n    if(pre[x] == x)\n        return x;\n    return find_root(pre[x]);\n}\nint main()\n{\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    pre[1] = 1;\n    for(int i = 2;i <= n;i++)\n        scanf(\"%d\", &pre[i]);\n    char a;\n    int b;\n    int ans = 0;\n    while(scanf(\" %c%d\", &a, &b), a != '0')\n    {\n        if(a == 'Q')\n            ans += find_root(b);\n        else\n            pre[b] = b;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 100000, MAX_Q = 100000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par[i] = p;\n            par2[i] = p;\n        }\n        vector<P> v;\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                par[t] = t;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            v.push_back(q);\n        }\n\n        // solve\n        int ans = 0;\n        for(int i = v.size()-1; i >= 0; i--) {\n            if(v[i].first == 'M') {\n                unite(par2[v[i].second], v[i].second);\n            } else {\n                ans += find(v[i].second);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int MAX=1e5+5;\nint n,q;\nint fa[MAX],lv[MAX];\nchar lin[10];\nint x;\nint an;\nvoid init(int s)\n{\n    for(int i=0;i<=s;i++)\n    {\n        fa[i]=i;\n//        lv[i]=0;\n    }\n}\nint find(int s)\n{\n    if(fa[s]==s)\n        return s;\n    else return find(fa[s]);\n}\nint main()\n{\n    while(~scanf(\"%d %d\",&n,&q))\n    {\n        an=0;\n        if(n==0&&q==0)\n            break;\n        init(n);\n        int i;\n        for(i=2;i<=n;i++)\n            scanf(\"%d\",&fa[i]);\n        while(q--)\n        {\n//            for(i=1;i<=n;i++)\n//                printf(\"%d \",fa[i]);\n//            puts(\"\");\n            scanf(\"%s %d\",lin,&x);\n            if(lin[0]=='Q')\n                an+=find(x);\n//{\n//    printf(\"%d\\n\",find(x));\n//    an+=find(x);\n//}\n            else\n                fa[x]=x;\n        }\n        printf(\"%d\\n\",an);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<char,int> P;\n\nint N,Q;\nbool mark[100000];\nint tree[100000];\nP query[100000];\n\nint get(int i){\n  if(mark[i]) return i;\n  return tree[i]=get(tree[i]);\n}\n\nint main() {\n  while(scanf(\"%d%d\",&N,&Q),N|Q){\n    memset(mark,0,sizeof(mark));\n    mark[0]=1;\n    for(int i=1;i<N;i++){\n      scanf(\"%d\",tree+i);\n      tree[i]--;\n    }\n    for(int i=0;i<Q;i++){\n      scanf(\" %c %d\",&query[i].first,&query[i].second);\n    }\n    for(int i=0;i<Q;i++){\n      if(query[i].first=='M'){\n        mark[query[i].second-1]=1;\n      }\n    }\n\n    long long c=0;\n    for(int i=Q-1;i>=0;i--){\n      int t=query[i].second;\n      if(query[i].first=='M'){\n        mark[t]=0;\n      }else{\n        c+=get(t);\n      }\n    }\n    printf(\"%lld\\n\",c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Marked_Ancestor\n{\n  vector< int > graph[100000];\n  set< int > querys[100000];\n  vector< int > marked[100000];\n  \n  pair< long long, set< int >* > rec(int idx)\n  {\n    set< int >* curr = &querys[idx]; \n    long long ret = 0;\n    for(int to : graph[idx]) {\n      auto child = rec(to);\n      if(curr -> size() < child.second -> size()) swap(curr, child.second);\n      curr -> insert(child.second -> begin(), child.second -> end());\n      ret += child.first;\n    }\n    int now = 0;\n    while(now < marked[idx].size()) {\n      while(!curr -> empty() && *--curr -> end() > marked[idx][now]) {\n        curr -> erase(--curr -> end());\n        ret += idx + 1;\n      }\n      ++now;\n    }\n    return(make_pair(ret, curr));\n  }\n\n  Marked_Ancestor(int N, int Q, int *a, char *c, int* x)\n  {\n    for(int i = 1; i < N; i++) {\n      graph[--a[i]].push_back(i);\n    }\n    marked[0].push_back(-1);\n    for(int i = 0; i < Q; i++) {\n      if(c[i] == 'Q') querys[--x[i]].insert(i);\n      else marked[--x[i]].push_back(i);\n    }\n    printf(\"%lld\\n\", rec(0).first);\n  }\n};\n\nint main()\n{\n  int N, Q, a[100000], x[100000];\n  char c[100000];\n  while(scanf(\"%d %d\", &N, &Q), N) {\n    for(int i = 1; i < N; i++) {\n      int x;\n      scanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < Q; i++) {\n      scanf(\" %c %d\", c + i, x + i);\n    }\n    Marked_Ancestor(N, Q, a, c, x);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\n//Marked Ancestor(AOJ)\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2170&lang=en\n//about 45min\n//参考解答 http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=584073#1\n//union findでmarkされた親に対してそれらの子のうちmarkされていない子をもつことで, queryを後から見ていけばmarkの消失⇔そのnodeとそのnodeの親との結合で表現できるところが賢いなぁと。\n\nvin par(100050);\nvoid init(int n);\nint root(int x);\nvoid unite(int x,int y);\nbool same(int x,int y);\n\nll ancestor(int n,int q){\n    vin parent(n+1);parent[1]=1;\n    rep2(i,2,n+1)cin>>parent[i];\n    vch ope(q);\n    vin v(q),marked(n+1,0);marked[1]=1;\n    rep(i,q){\n        cin>>ope[i]>>v[i];\n        if(ope[i]=='M')marked[v[i]]++;\n    }\n    init(n);\n    rep2(i,1,n+1){\n        if(marked[i]==0)unite(i,parent[i]);//parent[i]を親にしてunite\n    }\n    ll res=(ll)0;\n    for(int i=q-1;i>=0;i--){\n        if(ope[i]=='Q')res+=(ll)root(v[i]);\n        else if(--marked[v[i]]==0)unite(v[i],parent[v[i]]);\n    }\n    return res;\n}\n\nint main(){\n    int n,q;\n    queue<ll> ans;\n    while(1){\n        cin>>n>>q;\n        if(n==0)break;\n        ans.push(ancestor(n,q));\n    }\n    while(ans.size()){\n        cout<<ans.front()<<endl;\n        ans.pop();\n    }\n}\n\nvoid init(int n){\n    rep(i,n+1)par[i]=i;\n}\nint root(int x){\n    if(par[x]==x)return x;\n    else return par[x]=root(par[x]);\n}\nvoid unite(int x,int y){//deepを考慮しない\n    x=root(x);\n    y=root(y);\n    if(x==y)return;\n    par[x]=y;\n}\nbool same(int x,int y){\n    return root(x)==root(y);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <memory.h>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nint N;\nint Q;\nbool marked[MAX_N + 4];\nint par[MAX_N + 4];\n\nint find(int x) {\n//    if (marked[par[x]]) {\n    if (par[x] == x) {\n        return par[x];\n    }\n    return find(par[x]);\n}\n\nint main() {\n    while (scanf(\"%d %d\", &N, &Q) != EOF && N > 0 && Q > 0) {\n        memset(marked, 0, sizeof(marked));\n        marked[1] = 1;\n        long long res = 0;\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", &par[i]);\n        }\n        par[1] = 1;\n        cin.ignore();\n        char operation;\n        int node;\n        for (int i = 0; i < Q; i++) {\n            scanf(\"%c %d\", &operation, &node);\n            if (operation == 'Q') {\n                res += find(node);\n            }\n            else if (operation == 'M') {\n//                marked[node] = 1;\n                par[node] = node;\n            }\n            cin.ignore();\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 100001;\nclass UnionFind{\npublic:\n  int par[MAX];\n  int rank[MAX];\n  int mark[MAX];\n  void init(int n){\n    for(int i = 1; i <= n; i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n\n    for(int i = 0; i < MAX; i++)\n      mark[i] = 0;\n\n  }\n  \n  int find(int x){\n    if(mark[x] > 0){\n      mark[x]--;\n      return x;\n    }\n    else return par[x] = find(par[x]);\n  }\n};\n\nint N,M;\nUnionFind T;\nvector<int> V;\n\nvoid init(){\n  T.init(N);\n  T.mark[1] = MAX;\n  V.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < N-1; i++){\n    int in;\n    cin >> in;\n    T.par[i+2] = in;\n  }\n\n  for(int i = 0; i < M; i++){\n    char c;\n    int in;\n    cin >> c >> in;\n    if(c == 'M') T.mark[in]++;\n    else V.push_back(in);\n  }\n}\n\nvoid solve(){\n  int ans = 0;\n  for(int i = V.size()-1; i>=0; i--){\n    ans += T.find(V[i]);\n  }\n  cout << ans << endl;\n}\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\nint par[100001];\nint rank1[100001];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, q;\n\twhile (cin >> n >> q, n) {\n\t\tinit(n);\n\t\trep(i, n-1) {\n\t\t\tcin >> par[i+2];\n\t\t}\n\t\tvector<pair<char,int>> p;\n\t\tint marked[100001] = {}; marked[0] = 1;\n\t\tchar a; int b;\n\t\trep(i, q) {\n\t\t\tcin >> a >> b;\n\t\t\tif (a == 'M')marked[b] = 1;\n\t\t\tp.push_back({ a,b });\n\t\t}\n\t\tll out = 0;\n\t\trep(i,n+1) {\n\t\t\tif (!marked[i]) {\n\t\t\t\tunite(i, par[i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tif (p[i].first == 'M') {\n\t\t\t\tunite(p[i].second, par[p[i].second]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout += (ll)find(p[i].second)+(ll)1;\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#define ll long long\nusing namespace std;\n\nconst int N = 100010;\n\nint n,qu;\nint fa[N],mark[N];\n\nstruct Node {int t,v;}q[N];\n\nint gi() {\n  int x=0,o=1; char ch=getchar();\n  while(ch!='-' && (ch<'0'||ch>'9')) ch=getchar();\n  if(ch=='-') ch=getchar(),o=-1;\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return o*x;\n}\n\nint find(int x, int ti) {\n  return mark[x]<ti?x:fa[x]=find(fa[x],ti);\n} \n\nint main() {\n  while(scanf(\"%d%d\", &n, &qu) && n+qu) {\n    ll ans=0; int t=0;\n    for(int i=2; i<=n; i++) fa[i]=gi(),mark[i]=qu+1;\n    for(int i=1; i<=qu; i++) {\n      char c; int x;\n      scanf(\"%c\", &c),x=gi();\n      if(c=='M') mark[x]=min(mark[x],i);\n      else q[t].t=i,q[t++].v=x;\n    }\n    while(t--) ans+=find(q[t].v,q[t].t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nclass RMQ {\n#define RMQ_MAX 1\npublic:\n\tRMQ(int n) {\n\t\t_n=1;\n\t\twhile(_n<n) _n*=2;\n\t\t_dat.resize(2*_n-1);\n\t\tfor(int i=0;i<2*_n-1;++i) _dat[i]=-(RMQ_MAX);\n\t}\n\tint size() {\n\t\treturn _n;\n\t}\n\tvoid update(int k,long long a) {\n\t\tk+=_n-1;\n\t\t_dat[k]=a;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\t_dat[k]=max(_dat[k*2+1],_dat[k*2+2]);\n\t\t}\n\t}\n\t// return the minimum number in [a,b)\n\t// external call should be written like query(a,b,0,0,_n)\n\tll query(int a,int b,int k=0,int l=0,int r=-1) {\n\t\tif(r==-1) r=_n;\n\t\tif(r<=a||b<=l) return -(RMQ_MAX);\n\t\tif(a<=l&&r<=b) return _dat[k];\n\t\telse {\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn max(vl,vr);\n\t\t}\n\t}\nprivate:\n\tint _n;\n\tvector<ll> _dat;\n};\n\nvector<vector<ll>> adj;\nvector<ll> idx;\nvector<ll> idx_rev;\nvector<ll> marked;\nvector<ll> marked_rev;\nvector<vector<ll>> checked;\nvector<ll> ret;\nll id=0;\n\nvoid detidx(ll pos, ll par) {\n\tidx[pos]=id;\n\tidx_rev[id]=pos;\n\tid++;\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdetidx(adj[pos][i],pos);\n\t}\n}\n\nvoid dfs(ll pos, ll par, RMQ& buf) {\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],idx[pos]);\n\tREP(i,(ll)checked[pos].size()) {\n\t\t//ll maxi=buf.query(0,(int)checked[pos][i]);\n\t\t//ret[checked[pos][i]-1]=idx_rev[maxi]+1;\n\t}\n\tREP(i,(ll)adj[pos].size()) {\n\t\tif(adj[pos][i]==par) continue;\n\t\tdfs(adj[pos][i],pos,buf);\n\t}\n\tif(marked[pos]!=-1) buf.update((int)marked[pos],-(RMQ_MAX));\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n,q;\n\t\tcin>>n>>q;\n\t\tif(n==0&&q==0) break;\n\t\tadj.resize(0); adj.resize(n);\n\t\tidx.resize(0); idx.resize(n);\n\t\tidx_rev.resize(0); idx_rev.resize(n);\n\t\tmarked.resize(0); marked.resize(n); REP(i,n) marked[i]=-1; marked[0]=0;\n\t\tchecked.resize(0); checked.resize(n);\n\t\tret.resize(0); ret.resize(q); REP(i,q) ret[i]=0;\n\t\tid=0;\n\t\tRMQ buf((int)(q+10)); buf.update(0,0);\n\t\tREP(i,n-1) {\n\t\t\tll a;\n\t\t\tcin>>a;\n\t\t\ta--;\n\t\t\tadj[i+1].pb(a);\n\t\t\tadj[a].pb(i+1);\n\t\t}\n\t\tREP(i,q) {\n\t\t\tchar c;\n\t\t\tll v;\n\t\t\tcin>>c>>v;\n\t\t\tv--;\n\t\t\tif(c=='M'&&marked[v]==-1) marked[v]=i+1;\n\t\t\tif(c=='Q') checked[v].pb(i+1);\n\t\t}\n\t\tdetidx(0,-1);\n\t\tdfs(0,-1,buf);\n\t\tll sum=0;\n\t\tREP(i,q) sum+=ret[i];\n\t\tcout<<sum<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#define INF 1000000007\n#define inf 100000000000000000\nusing namespace std;\ntypedef long long ll;\nint far[100005],ran[100005],n,q,i,j,x,sum;\nchar c;\nint findx(int k)\n{\n    if(far[k]==k)return k;\n    findx(far[k]);\n}\nint main()\n{\n    while(scanf(\"%d%d\",&n,&q)!=EOF&&(n!=0||q!=0))\n    {\n        sum=0;\n        for(i=2;i<=n;i++)scanf(\"%d\",&far[i]);\n        far[1]=1;\n        for(i=0;i<q;i++)\n        {\n            scanf(\"\\n%c%d\",&c,&x);\n            if(c=='Q')sum+=findx(x);\n            else far[x]=x;\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nint n, q, root[10500];\nlong long res;\nbool marked[10500];\npair<char, int> query[10500];\n \nint r(int x){\n    if(marked[x])return x;\n    return root[x]=r(root[x]);\n}\n \nint main() {\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(marked, marked + n + 2, false);\n\tmarked[1] = true;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    marked[query[i].second] = (query[i].first == 'M');\n\t}\n\tfor(int i=q;q--;){\n\t    if(query[i].first=='M'){\n\t\tmarked[query[i].second] = false;\n\t    }else{\n\t\tres += r(query[i].second);\n\t    }\n\t}\n\tcout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ONLINE_JUDGE\n#pragma warning(disable : 4996)\n#endif\n#include <iostream>\nusing namespace std;\n #include<stdio.h>\n#define MAX_N 100005\ntypedef pair<int,bool > p;\np fa[MAX_N];\nint main(){\n    int n,q;\n    fa[1].first = 1;\n    fa[1].second = true;\n    while(~scanf(\"%d%d\",&n,&q)&&n>0){\n        int ans = 0;\n        for(int i = 2;i <= n;i++){\n            cin>>fa[i].first;\n            fa[i].second = false;\n        }\n        getchar();\n        for(int i = 0;i<q;i++){\n            char ch;int a;\n            scanf(\"%c%d\",&ch,&a);\n            getchar();\n            if(ch =='Q'){\n                while(fa[a].second==false){\n                    a = fa[a].first;\n                }\n                ans += a;\n            }\n            else{\n                fa[a].second = true;\n            }\n\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include<cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <deque>\n#include <set>\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <unordered_map>\n#include <cassert>\n#endif\n#include <ctime>\n#include <queue>\n#include <stack>\n#include<iomanip>\n#include <sstream>\n#include <cmath>\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nstruct SegTree {\n    vector<int> c;\n    void init(int n) {\n        c.assign(n << 2, 1);\n    }\n    void pushDown(int rt, int L, int R, int l, int r, int x, vector<PII>& seg) {\n        if (c[rt] != -1) {\n            c[rt] = -1;\n            if (c[rt << 1] == -1 || seg[c[rt << 1]].first <= seg[c[rt]].first\n                && seg[c[rt]].second <= seg[c[rt << 1]].second) {\n                c[rt << 1] = c[rt];\n            }\n            if (c[rt << 1|1] == -1 || seg[c[rt << 1|1]].first <= seg[c[rt]].first\n                && seg[c[rt]].second <= seg[c[rt << 1|1]].second) {\n                c[rt << 1|1] = c[rt];\n            }\n        }\n    }\n    void update(int rt, int L, int R, int l, int r, int x, vector<PII>& seg) {\n        if (l <= L && R <= r) {\n            if (c[rt] == -1 || seg[c[rt]].first <= l && r <= seg[c[rt]].second) {\n                c[rt] = x;\n            }\n            return;\n        }\n        pushDown(rt, L, R, l, r, x, seg);\n        int m = L + R >> 1;\n        if (m >= l) update(rt << 1, L, m, l, r, x, seg);\n        if (m + 1 <= r) update(rt << 1 | 1, m + 1, R, l, r, x, seg);\n    }\n    void query(int rt, int L, int R, int x, vector<PII>& seg, int& ans) {\n        if (c[rt] != -1) {\n            if (ans == -1 || seg[ans].first <= seg[c[rt]].first && seg[c[rt]].second <= seg[c[rt]].second) {\n                ans = c[rt];\n            }\n        }\n        if (L == R) return;\n        int m = L + R >> 1;\n        if (x <= m) query(rt << 1, L, m, x, seg, ans);\n        if (m + 1 <= x) query(rt << 1 | 1, m + 1, R, x, seg, ans);\n    }\n}segtree;\nvector<vector<int> > tree;\nvoid dfs_sons(int root, vector<int>& cnt) {\n    cnt[root] = 1;\n    for(int i = 0; i < tree[root].size(); i ++) {\n        dfs_sons(tree[root][i], cnt);\n        cnt[root] += cnt[tree[root][i]];\n    }\n}\nvoid dfs(int root, vector<PII>& seg, vector<int>& cnt, int l, int r) {\n    seg[root] = PII(l, r);\n    int s = l;\n    for(int i = 0; i < tree[root].size(); i ++) {\n        int e = s + cnt[tree[root][i]];\n        dfs(tree[root][i], seg, cnt, s, e - 1);\n        s = e;\n    }\n}\nvoid solve(int ncase) {\n    int n, m;\n    while(scanf(\"%d%d\", &n, &m), !(n == 0 && m == 0)) {\n        // form tree\n        tree.assign(n + 1, vector<int>());\n        for(int i = 2; i <= n; i ++) {\n            int pre;\n            scanf(\"%d\", &pre);\n            tree[pre].push_back(i);\n        }\n        // form seg from point\n        vector<PII> seg(n + 1);\n        vector<int> cnt(n + 1);\n        dfs_sons(1, cnt);\n        dfs(1, seg, cnt, 1, n);\n        // init seg tree\n        segtree.init(n);\n        // process query Q / M\n        char op[2];\n        vector<int> marker(n + 1);\n        int x;\n        ll sum = 0;\n        for(int i = 0; i < m; i ++) {\n            scanf(\"%s%d\", &op, &x);\n            if (op[0] == 'Q') {\n                int ans = -1;\n                segtree.query(1, 1, n, x, seg, ans);\n                //printf(\"%d\\n\", ans);\n                sum += ans;\n            } else {\n                if (marker[x]) continue;\n                marker[x] = 1;\n                segtree.update(1, 1, n, seg[x].first, seg[x].second, x, seg);\n            }\n        }\n        printf(\"%I64d\\n\", sum);\n    }\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    //cout << setprecision(16) << endl;\n#ifdef _zzz_\n   freopen(\"in.txt\", \"r\", stdin);\n   //freopen(\"out.txt\", \"w\", stdout);\n#endif\n    int T = 1;\n    //scanf(\"%d\", &T);\n    //cin >> T;\n    int ncase = 0;\n    while(T --) {\n        solve(++ ncase);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\tr[0] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{return 0;\n\t\tres += solve(num);\n\t    }\n\t}\n\tcout << res << endl;\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <array>\n#include <limits>\n \ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n \n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n \ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n \ntemplate <typename Weight>\nstruct edge {\n  using value_type = Weight;\n  size_t src, dst;\n  value_type cost;\n \n  edge(size_t src, size_t dst, value_type cost = 1):\n    src(src), dst(dst), cost(cost)\n  {}\n \n  bool operator <(edge<value_type> const& rhs) const {\n    if (cost != rhs.cost) return cost < rhs.cost;\n    if (src != rhs.src) return src < rhs.src;\n    return dst < rhs.dst;\n  }\n};\n \ntemplate <typename Weight>\nstruct graph: public std::vector<std::vector<edge<Weight>>> {\n  using value_type = Weight;\n  graph(size_t n): std::vector<std::vector<edge<value_type>>>(n) {}\n \n  void connect_with(size_t src, size_t dst, value_type cost = 1) {\n    (*this)[src].emplace_back(src, dst, cost);\n    (*this)[dst].emplace_back(dst, src, cost);\n  }\n};\n \ntemplate <typename Tp>\nstd::array<std::vector<size_t>, 2> euler_tour(graph<Tp> const& g, size_t s = 0) {\n  std::array<std::vector<size_t>, 2> res;\n  res[0] = res[1] = std::vector<size_t>(g.size());\n  size_t j = 0;\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    res[0][i] = j++;\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      dfs(e.dst, i);\n    }\n    res[1][i] = j++;\n  })(s, -1);\n  return res;\n}\n \ntemplate <typename Tp>\nstd::vector<size_t> depth(graph<Tp> const& g, size_t s = 0) {\n  std::vector<size_t> res(g.size());\n  make_fix_point([&](auto dfs, size_t i, size_t pi) -> void {\n    for (auto const& e: g[i]) {\n      if (e.dst == pi) continue;\n      res[e.dst] = res[e.src] + 1;\n      dfs(e.dst, e.src);\n    }\n  })(s, -1);\n  return res;\n}\n \ntemplate <\n  typename Monoid,\n  typename Container = std::vector<typename Monoid::first_type>,\n  typename SubContainer = std::vector<typename Monoid::second_type>\n>\nclass segment_tree {\npublic:\n  using first_type = typename Monoid::first_type;\n  using second_type = typename Monoid::second_type;\n  using value_type = first_type;\n  using binary_operation = typename Monoid::binary_operation;\n  using external_binary_operation = typename Monoid::external_binary_operation;\n  using merge_operation = typename Monoid::merge_operation;\n  using container = Container;\n  using sub_container = SubContainer;\n \nprivate:\n  size_t M_base_size;\n  binary_operation M_op1;\n  external_binary_operation M_op2;\n  merge_operation M_op3;\n  container M_c;\n  sub_container M_d;  // deferred\n \n  void M_build(size_t i) {\n    while (i > 1) {\n      i >>= 1;\n      M_c[i] = M_op2(M_op1(M_c[i<<1|0], M_c[i<<1|1]), M_d[i]);\n    }\n  }\n \n  void M_resolve(size_t i) {\n    size_t h = (sizeof(size_t) * CHAR_BIT) - __builtin_clzll(M_base_size*2);\n    for (size_t s = h; s > 0; --s) {\n      size_t p = i >> s;\n      if (M_d[p] != M_op3.identity) {\n        M_apply(p<<1|0, M_d[p]);\n        M_apply(p<<1|1, M_d[p]);\n        M_d[p] = M_op3.identity;\n      }\n    }\n  }\n \n  void M_apply(size_t i, second_type const& x) {\n    M_c[i] = M_op2(M_c[i], x);\n    if (i < M_base_size) M_d[i] = M_op3(M_d[i], x);\n  }\n \npublic:\n  segment_tree() = default;\n  segment_tree(segment_tree const&) = default;\n  segment_tree(segment_tree&&) = default;\n \n  segment_tree(size_t n, first_type const& x = binary_operation().identity):\n    M_base_size(n),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(n+n, x), M_d(n, M_op3.identity)\n  {\n    for (size_t i = n; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n \n  template <typename InputIt>\n  segment_tree(InputIt first, InputIt last):\n    M_base_size(std::distance(first, last)),\n    M_op1(binary_operation()),\n    M_op2(external_binary_operation()),\n    M_op3(merge_operation()),\n    M_c(M_base_size*2), M_d(M_base_size, M_op3.identity)\n  {\n    for (size_t i = M_base_size; first != last; ++i)\n      M_c[i] = *first++;\n    for (size_t i = M_base_size; i--;)\n      M_c[i] = M_op1(M_c[i<<1|0], M_c[i<<1|1]);\n  }\n \n  segment_tree& operator =(segment_tree const&) = default;\n  segment_tree& operator =(segment_tree&&) = default;\n \n  void modify(size_t l, size_t r, second_type const& x) {\n    l += M_base_size;\n    r += M_base_size;\n    size_t l0 = l;\n    size_t r0 = r;\n    while (l < r) {\n      if (l & 1) M_apply(l++, x);\n      if (r & 1) M_apply(--r, x);\n      l >>= 1;\n      r >>= 1;\n    }\n    M_build(l0);\n    M_build(r0-1);\n  }\n \n  first_type accumulate(size_t l, size_t r) {\n    first_type resl = M_op1.identity;\n    first_type resr = resl;\n    l += M_base_size;\n    r += M_base_size;\n    M_resolve(l);\n    M_resolve(r-1);\n    while (l < r) {\n      if (l & 1) resl = M_op1(resl, M_c[l++]);\n      if (r & 1) resr = M_op1(M_c[--r], resr);\n      l >>= 1;\n      r >>= 1;\n    }\n    return M_op1(resl, resr);\n  }\n \n  first_type operator [](size_t i) {\n    return accumulate(i, i+1);\n  }\n};\n \nnamespace std {\n  template <typename T1, typename T2>\n  struct numeric_limits<std::pair<T1, T2>> {\n    static std::pair<T1, T2> constexpr min() {\n      return std::make_pair(std::numeric_limits<T1>::min(), std::numeric_limits<T2>::min());\n    }\n  };\n}\n \ntemplate <typename Tp>\nstruct range_max_range_max {\n  using first_type = Tp;\n  using second_type = Tp;\n  struct binary_operation {\n    first_type identity = std::numeric_limits<Tp>::min();\n    first_type operator ()(first_type const& x, first_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct external_binary_operation {\n    first_type operator ()(first_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n  struct merge_operation {\n    second_type identity = std::numeric_limits<Tp>::min();\n    second_type operator ()(second_type const& x, second_type const& y) const {\n      return std::max(x, y);\n    }\n  };\n};\n \nint testcase_ends() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n  if (n == 0 && q == 0) return 1;\n \n  graph<int> g(n);\n  for (size_t i = 1; i < n; ++i) {\n    size_t p;\n    scanf(\"%zu\", &p);\n    --p;\n    g.connect_with(i, p);\n  }\n \n  auto d = depth(g);\n  auto et = euler_tour(g);\n \n  // {depth, nma}\n  segment_tree<range_max_range_max<std::pair<size_t, size_t>>> st(n+n, std::make_pair(0, 0));\n \n  size_t res = 0;\n  for (size_t i = 0; i < q; ++i) {\n    char t;\n    size_t v;\n    scanf(\" %c %zu\", &t, &v);\n    --v;\n \n    if (t == 'Q') {\n      res += st[et[0][v]].second+1;\n    } else if (t == 'M') {\n      st.modify(et[0][v], et[1][v]+1, std::make_pair(d[v], v));\n    }\n  }\n \n  printf(\"%zu\\n\", res);\n  return 0;\n}\n \nint main() {\n  while (!testcase_ends()) {}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\n\nint N, Q;\nchar Ope[MAX_N];\nint Openum[MAX_N], Marked[MAX_N];\nvector<int> child[MAX_N];\n\nvoid mark(int x, int num) {\n  if(Marked[x] == x || Marked[x] == num) return;\n  Marked[x] = num;\n  for(int i = 0; i < child[x].size(); i++){\n    mark(child[x][i], num);\n  }\n}\n\nvoid solve() {\n  int ans = 0;\n  memset(Marked, 0, sizeof(Marked));\n  for(int i = 0; i < Q; i++){\n    char ope = Ope[i];\n    int num = Openum[i];\n    if(ope == 'M') mark(num, num);\n    else if(ope == 'Q') ans += Marked[num]+1;\n  }\n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 0; i < N; i++) child[i].clear();\n    for(int i = 1; i < N; i++){\n      int par;\n      scanf(\"%d\", &par);\n      child[par].push_back(i);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nN?????????????????§?§???????????????¨T????????????\n????????????1~N?????§???????????????????????????1??????????????????\nT??????????????\\??????2????????????????????????:\n\t\nM v:?????????v??????????????????\nQ v:v??????????????????????????????????\\????????????????????????????\n\n?????????????????????????????????????????????(?????????1??????)???\n???????????????????????????????¨?????????????????????????\n\n??????????????°:N<=100000\n?????¨????????°:Q<=100000\n\n?????????1???:N??¨Q\n???????¬????N-1???:2~N??????????????????\n?¬????Q???:?????¨???(M v or Q v)?????¢\n*/\n\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nlong const long N=100000;\n\nlong par[N+1];\nlong tree[N+1]; //??¨????§????\n\nlong find(long x){\n\t//printf(\" x=%ld\\n\", x);\n\tif(par[x]==x) return x;\n\telse return find(par[x]);\t\n}\n\nint main(){\n\twhile(1){\n\t\tlong n, q;\n\t\tscanf(\" %ld %ld\", &n, &q);\n\t\tif(n==0) break;\n\t\t\t\n\t\tpar[1]=1;\n\t\tfor(long i=2; i<=n; ++i) scanf(\" %ld\", &par[i]);\n\t\t\n\t\tlong ans=0;\n\t\tfor(long i=0; i<q; ++i){\n\t\t\tchar req;\n\t\t\tlong m;\n\t\t\t\n\t\t\tscanf(\" %c %ld\", &req, &m);\n\t\t\tif(req=='M') par[m]=m; //????????§????????¢?????????????????????\n\t\t\telse if(req=='Q') ans+=find(m);\n\t\t\t//printf(\"%ld\\n\", ans);\n\t\t}\n\t\t\t\n\t\tprintf(\"%ld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long Long;\n\n#define MN 100000\n#define MQ 100000\nint N, Q;\nint parent[MN + 1];\nbool marked[MN + 1];\npair<int, int> queries[MQ];\nint group[MN + 1];\n\nint fillGroup(int n) {\n    if (group[n] >= 1) return group[n];\n    return group[n] = fillGroup(parent[n]);\n}\nint findGroup(int n) {\n    if (marked[ group[n] ]) return group[n];\n    return group[n] = findGroup(parent[n]);\n}\n\nbool input() {\n    scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) return false;\n    for (int i = 2; i <= N; i++) {\n        int p;\n        scanf(\"%d\", &p);\n        parent[i] = p;\n    }\n    memset(marked, false, N + 1);\n    marked[1] = true;\n    memset(group, -1, sizeof(int) * (N + 1));\n    group[1] = 1;\n    for (int i = 0; i < Q; i++) {\n        char t; int n;\n        scanf(\"%*[ \\t\\r\\n]%c %d\", &t, &n);\n        if (t == 'M') {\n            marked[n] = true;\n            group[n] = n;\n        }\n        queries[i] = make_pair(t, n);\n    }\n    for (int i = 1; i <= N; i++) {\n        if (group[i] < 0) fillGroup(i);\n    }\n    return true;\n}\n\nvoid solve() {\n    Long ans = 0;\n    for (int q = Q - 1; q >= 0; q--) {\n        pair<int, int> query = queries[q];\n        if (query.first == 'Q') {\n            ans += findGroup(query.second);\n        } else {\n            marked[query.second] = false;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    while (input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 10000000\nusing namespace std;\nint par[MAX];\nint N,Q;\n\nvoid init()\n{\n  rep(i,MAX)par[i] = i;\n}\n\nint find(int x)\n{\n  if(x == par[x])return x;\n  return find(par[x]);\n}\n\nbool unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x != y)par[y] = x;\n}\n\nbool same(int x,int y)\n{\n  return find(x) == find(y);\n}\n\nint main()\n{\n  while(cin >> N >> Q,N|Q)\n    {\n      init();\n      REP(i,1,N)\n\t{\n\t  int variable;\n\t  cin >> variable;\n\t  variable--;\n\t  par[i] = variable;\n\t}\n\n      int cost = 0;\n      rep(i,Q)\n\t{\n\t  char Query;\n\t  int v;\n\t  cin >> Query >> v;\n\t  v--;\n\t  if(Query == 'Q')\n\t    {\n\t      cost += find(v)+1;\n\t    }\n\t  else \n\t    {\n\t      par[v] = v;\n\t    }\n\t}\n      cout << cost << endl;\n    }\n  return 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\n//再利用する場合はMAX_Nの値を設定し直すことを忘れない！！！\n//Union-Find木を少し改造\n\nconst int MAX_N = 100005;\n\nint Par[MAX_N+1];\nbool Marked[MAX_N+1];\n//int Rank[MAX_N];\n\nvoid init(int n){  //1~nまで初期化\n    for (int i = 1; i <= n; i++) {\n        Par[i] = i;\n        //Rank[i] = 0;\n    }\n}\n\nint find(int x) {  //xの根を返す\n    if (Marked[x]) return x;\n    else {\n        return find(Par[x]);\n    }\n}\n\nvoid unite(int x, int y) {  //xとyを併合.ただし、yをxに繋げる\n    Par[y] = x;\n}\n\nint N;  //Nodeの数\nint Q;  //Operationの数\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &Q);\n        if (N == 0 && Q == 0) break;\n        init(N);  //1~Nまで\n        fill(Marked, Marked+N+1, false);\n        Marked[1] = true;\n        for (int i = 2; i <= N; i++) {  //2~Nまで\n            int p;  //iの親\n            scanf(\"%d\", &p);\n            unite(p,i);  //iをpに繋げる\n        }\n        int ret = 0;\n        for (int i = 0; i < Q; i++) {\n            char c;\n            int v;\n            scanf(\" %c %d\", &c, &v);\n            if (c == 'Q') {  //Markの付いた最近の祖先を調べる\n                ret += find(Par[v]);  //自分にMarkが入っている時に、自分をカウントしないようにする\n            } else if (c == 'M') {  //印をつける\n                Marked[v] = true;\n            }\n        }\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <ctime>\n#include <sstream>\n#include <fstream>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\n\n#define PII pair<int, int>\n#define sz(X) ((int)((X).size()))\n\n#define Rep(i, a, b) for (int i(a); i <= (b); ++i)\n\ntemplate<class T> T abs(T x){return x < 0 ? -x : x;}\n\nconst int maxn = 444444;\nint head[maxn], sgt[maxn];\npair<int, int> S[maxn];\nint L[maxn], R[maxn], d[maxn];\nint n, m, num;\n\nstruct Edge{\n\tint x, next;\n}graph[maxn];\n\nvoid add_edge(int x, int y){\n\tgraph[++num].x = y;\n\tgraph[num].next = head[x];\n\thead[x] = num;\n}\n\nvoid dfs(){\n\tint top = 1, tot = 0;\n\tS[top] = make_pair(1, head[1]);\n\td[0] = 0;\n\td[1] = 1;\n\twhile (top){\n\t\tint u = S[top].first, i = S[top].second;\n\t\tif (head[u] == i){\n\t\t\tL[u] = ++tot;\n\t\t}\n\t\tif (i == 0){\n\t\t\tR[u] = tot;\n\t\t\t--top;\n\t\t\tcontinue;\n\t\t}\n\t\tS[top].second = graph[i].next;\n\t\tS[++top] = make_pair(graph[i].x, head[graph[i].x]);\n\t\td[graph[i].x] = d[u] + 1;\n\t}\n}\n\nvoid clear(int l, int r, int t){\n\tsgt[t] = 0;\n\tif (l == r) return;\n\tint mid = (l + r) >> 1;\n\tclear(l, mid, t * 2);\n\tclear(mid + 1, r, t * 2 + 1);\n}\n\nvoid cover(int l, int r, int u, int v, int key, int t){\n\tif (u == l && v == r){\n\t\tif (d[sgt[t]] < d[key]) sgt[t] = key;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (v <= mid) cover(l, mid, u, v, key, t * 2); else\n\t\tif (u > mid) cover(mid + 1, r, u, v, key, t * 2 + 1); else {\n\t\t\tcover(l, mid, u, mid, key, t * 2);\n\t\t\tcover(mid + 1, r, mid + 1, v, key, t * 2 + 1);\n\t\t}\n}\n\nint query(int l, int r, int u, int t){\n\tif (l == r)\treturn sgt[t];\n\tint mid =(l + r) >> 1;\n\tint tt;\n\tif (u <= mid) tt = query(l, mid, u, t * 2); else tt = query(mid + 1, r, u, t * 2 + 1);\n\tif (d[sgt[t]] > d[tt]) return sgt[t]; else return tt; \n}\n\n\nint main(){\n\twhile (scanf(\"%d%d\", &n, &m) == 2){\n\t\tif (n == 0) break;\n\t\tnum = 0;\n\t\tfor (int i = 1; i <= n; ++i){\n\t\t\thead[i] = 0;\n\t\t}\n\t\tfor (int i = 2; i <= n; ++i){\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tadd_edge(x, i);\n\t\t} \n\t\tdfs();\n\t\tclear(1, n, 1);\n\t\tcover(1, n, 1, n, 1, 1);\n\t\tLL ans = 0;\n\t\tfor (; m; --m){\n\t\t\tchar cc;\n\t\t\tint x;\n\t\t\tscanf(\" %c\", &cc);\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif (cc == 'Q'){\n\t\t\t\tans += query(1, n, L[x], 1);\n\t\t\t} else {\n\t\t\t\tif (L[x] < R[x]) cover(1, n, L[x], R[x], x, 1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%I64d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n\tint n,q;\n\twhile(cin >> n >> q,n||q){\n\t\tint a[100002];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tset<int> roots;\n\t\tvector<pair<char,int>> queries;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(roots.find(v) != roots.end()) continue;\n\t\t\tif(c == 'M') roots.insert(v);\n\t\t\tqueries.emplace_back(make_pair(c,v));\n\t\t}\n\t\tUnionFind uf(n+2);\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(roots.find(i) == roots.end()){\n\t\t\t\tuf.unionSet(a[i],i);\n\t\t\t}\n\t\t}\n\t\tlong long int sum = 0;\n\t\tfor(int i=(int)queries.size()-1;i>=0;i--){\n\t\t\tif(queries[i].first == 'M'){\n\t\t\t\tuf.unionSet(a[queries[i].second],queries[i].second);\n\t\t\t}\n\t\t\tif(queries[i].first == 'Q'){\n\t\t\t\tsum += uf.root(queries[i].second);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;//ノードの数\nint q;//操作回数\nint par[100010];\nint rank[100010];\nbool marked[100010];\nvoid init(int v){\n\tpar[1] = 1;\n\tfor(int i = 2;i <=n;i++){\n\t\tpar[i] = i;\n\t}\n}\nint getnode(int x){\n\tif(par[x]==x||marked[x])\n\t\treturn x;\n\telse\n\t\treturn getnode(par[x]);\n}\nint main(){\n\tint sum;\n\tinit(n);\n\twhile(cin>>n>>q,n||q){\n\t\tsum = 0;\n\t\tfor(int i = 2;i <=n;i++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tpar[i] =a;\n\t\t}\n\t\tfor(int i = 0;i < q;i++){\n\t\t\tchar op;\n\t\t\tint k;\n\t\t\tcin>>op>>k;\n\t\t\tif(op=='Q'){\n\t\t\t\tsum +=getnode(k);\n\t\t\t}\n\t\t\tif(op=='M'){\n\t\t\t\tmarked[k] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout <<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\nint ancestor[100000] = {}, ismarked[100000] = {}, is_doubleused[100000] = {};\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[y] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint tmp = outlog[i].second;\n\t\t\tif (outlog[i].first == 'M' && !is_doubleused[i])uf.unite(ancestor[tmp], tmp), is_doubleused[i] = true;\n\t\t\telse {\n\t\t\t\tans += (uf.getroot(tmp) + 1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false,is_doubleused[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P,P> PP;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nvector<ll> pa, query;\nset<ll> used;\nUnionFindTree g;\n\nint main() {\n    ll n, q;\n    while(cin >> n >> q, n){\n        bool marked[MAX_N]{};\n        pa.resize(n+5);\n        query.clear();\n        used.clear();\n        g.init(n+5);\n        REP(i,n-1){\n            cin >> pa[i+2];\n        }\n        used.insert(1);\n        REP(i,q){\n            string s;\n            ll k;\n            cin >> s >> k;\n            if(s==\"Q\")query.push_back(k);\n            else{\n                if(used.count(k)>0)continue; // すでにマークされた頂点はマークしない\n                used.insert(k);\n                query.push_back(-k);\n                marked[k] = true;\n            }\n        }\n        for(int i=2;i<=n;i++){\n            if(!marked[i]) g.unite(pa[i],i);\n        }\n        reverse(ALL(query)); // 逆順に操作\n        ll sum = 0;\n        for(auto k : query){\n            if(k<0){\n                k=abs(k);\n                g.unite(pa[k],k);\n            }\n            else{\n                sum += ll(g.find(k));\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N=2*1e5;\nconstexpr int Log=log2(MAX_N)+10;\nint main(){\n  int n,q;\n  while(cin>>n>>q,n){\n    vector<int> par(n);\n    par[0]=0;\n    for(int i=1;i<n;i++){\n      int p;\n      cin>>p;\n      p--;\n      par[i]=p;\n    }\n    vector<int> rootpar(n,0);\n    int r=max(sqrt(n),5.0)+10;\n    for(int i=0;i<n;i++){\n      int v=par[i];\n      for(int j=0;j<r;j++){\n\tv=par[v];\n      }\n      rootpar[i]=v;\n    }\n    vector<int> marked(n,0);\n    marked[0]=1;\n    vector<int> lowmark(n,0);\n    long long int res=0;\n    for(int i=0;i<q;i++){\n      char cmd;\n      int v;\n      cin>>cmd>>v;\n      v--;\n      if(cmd=='M'){\n\tmarked[v]=1;\n\tint nex=v;\n\tfor(int i=0;i<2*r;i++){\n\t  lowmark[nex]=1;\n\t  nex=par[nex];\n\t}\n      }\n      if(cmd=='Q'){\n\tint nex=par[v];\n\tbool ressed=false;\n\tfor(int i=0;i<2*r && !ressed;i++){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    ressed=true;\n\t  }\n\t  else{\n\t    nex=par[nex];\n\t  }\n\t}\n\tif(ressed)continue;\n\twhile(!lowmark[rootpar[nex]]) nex=rootpar[nex];\n\tfor(;;){\n\t  if(marked[nex]){\n\t    res+=nex+1;\n\t    break;\n\t  }\n\t  nex=par[nex];\n\t}\n      }\n      \n    }\n    cout<<res<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntemplate<typename T>\nclass SkewHeap {\nprivate:\n    struct Node {\n        Node *left, *right;\n        int dat;\n        Node(const T &x) : left(nullptr), right(nullptr), dat(x) {}\n        void *operator new(size_t) {\n            static int pos = 0;\n            static char mem[300010 * sizeof(Node)];\n            Node * res = (Node*)(mem + pos);\n            pos += sizeof(Node);\n            return res;\n        }\n    };\n    Node *root;\n    int sz;\n    Node *meld(Node *a, Node *b) {\n        if (a == nullptr) return b;\n        if (b == nullptr) return a;\n        if (a->dat < b->dat) swap(a, b);\n        a->right = meld(a->right, b);\n        swap(a->left, a->right);\n        return a;\n    }\n\npublic:\n    SkewHeap() : root(nullptr) {}\n    const T &top() const { return root->dat; }\n    int size() const { return sz; }\n    void meld(SkewHeap &other) { root = meld(root, other.root); }\n    void push(const T &x) {\n        root = meld(root, new Node(x));\n        ++sz;\n    }\n    void pop() {\n        Node *tmp = root;\n        root = meld(root->right, root->left);\n        delete tmp;\n        --sz;\n    }\n  \n};\n\nvector<int> children[100010];\nSkewHeap<int> query[100010];\nint markedAt[100010];\nusing ll = long long;\n\nll pull(int v) {\n    ll res = 0;\n    for (int c : children[v]) {\n        res += pull(c);\n        if (query[v].size() < query[c].size()) {\n            swap(query[v], query[c]);\n        }\n        while (query[c].size()) {\n            query[v].push(query[c].top());\n            query[c].pop();\n        }\n    }\n    while (query[v].size() && query[v].top() > markedAt[v]) {\n        res += v + 1;\n        query[v].pop();\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    while (cin >> n >> q && n) {\n        fill(children, children + n, vector<int>());\n        fill(markedAt, markedAt + n, 1e9);\n        for (int i = 1; i < n; ++i) {\n            int p;\n            cin >> p;\n            --p;\n            children[p].push_back(i);\n        }\n        markedAt[0] = -1;\n        for (int i = 0; i < q; i++) {\n            char c;\n            int v;\n            cin >> c >> v;\n            --v;\n            if (c == 'Q') {\n                query[v].push(i);\n            } else {\n                if (markedAt[v] == 1e9) {\n                    markedAt[v] = i;\n                }\n            }\n        }\n        cout << pull(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef tuple<int,int> P;\ntypedef vector<int> V;\ntypedef vector<V> Graph;\n#define PB push_back\n\nstruct INIT{INIT(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\n#define rep(i,n) for(auto i=(n)*0;i<n;i++)\n#define range(it,v) for(auto &it:v)\nvoid make_tree(int v,Graph& G,V& Par,V& D, Graph& C){\n    range(e,G[v]){\n\tif(e!=Par[v]){\n\t    C[v].PB(e);\n\t    D[e]=D[v]+1;\n\t    Par[e]=v;\n\t    make_tree(e,G,Par,D,C);\n\t}\n    }\n}\n\nvoid euler_tour(int v,Graph &C,vector<P>& seg,int &cnt){\n    int l=cnt++;\n    range(e,C[v])\n\teuler_tour(e,C,seg,cnt);\n    int r=cnt++;\n    seg[v]=P(l,r);\n}\n\n#define SIZE 1000000\n#define L(v) (v*2+1)\n#define R(v) (v*2+2)\n#define SET 0\n#define ADD 1\n#define GET 2\ntypedef P val;\nstruct node{\n    int bg,ed;\n    val v;\n    inline val getval(){\n\treturn v;\n    }\n    inline void init(int b,int e){\n\tbg =b,ed=e;\n\tv=val(-1,-1);\n    }\n    bool isleaf(){return bg==ed;}\n}mem[SIZE];\ninline val comb(val l,val r){\n\treturn max(l,r);\n    }\nclass segTree{\nprivate:node *t;\n    void make_tree(int bg,int ed,int v=0){\n\tnode *p=t+v;\n\tp->init(bg,ed);\n\tif(!p->isleaf()){\n\t    int m=(bg+ed)/2;\n\t    make_tree(bg,m,L(v));\n\t    make_tree(m+1,ed,R(v));\n\t}\n    }\npublic:\n    segTree(int bg,int ed):t(mem){make_tree(bg,ed);}\n    inline void lazy_update(int v){\n\tnode *p=t+v,*l=t+L(v),*r=t+R(v);\n\tif(p->isleaf())return;\n\tl->v=comb(p->v,l->v);\n\tr->v=comb(p->v,r->v);\n    }\n    val treat(int type,int bg,int ed,val x,int v=0){\n\tnode *p=t+v,*l=t+L(v),*r=t+R(v);\n\tlazy_update(v);\n\tif(P(bg,ed)==P(p->bg,p->ed)){\n\t    if(type==ADD)p->v=comb(p->v,x);\n\t    return p->v;\n\t}\n\tint m;\n\tval res=P(-1,-1);\n\tif(bg<=(m=min(ed,l->ed)))\n\t    res=comb(res,treat(type,bg,m,x,L(v)));\n\tif((m=max(bg,r->bg))<=ed)\n\t    res=comb(res,treat(type,m,ed,x,R(v)));\n\treturn res;\n    }\n    val get(int bg,int ed){\n\treturn treat(GET,bg,ed,val());\n    }\n    void add(int bg,int ed,val x){\n\ttreat(ADD,bg,ed,x);\n    }\n};\n\nconst int root=1;\nint main(){\n    for(int N,Q;cin>>N>>Q,N+Q;){\n\tGraph g(N+1),child(N+1);\n\tV depth(N+1,0),par(N+1,0);\n\tvector<P> seg(N+1);\n\tfor(int i=2;i<=N;i++){\n\t    int j;\n\t    cin>>j;\n\t    g[i].PB(j);\n\t    g[j].PB(i);\n\t}\n\tmake_tree(root,g,par,depth,child);\n\tint sz=0;\n\teuler_tour(root,child,seg,sz);\n\tsegTree tree(0,sz);\n\ttree.add(0,sz,P(0,root));\n\tlong long res=0;\n\twhile(Q--){\n\t    string op;int v;\n\t    cin>>op>>v;\n\t    int l,r;\n\t    tie(l,r)=seg[v];\n\t    if(op==\"M\"){\n\t\t    tree.add(l,r,P(depth[v],v));\n\t    }\n\t    else{\n\t\tint d,p;\n\t\ttie(d,p)=tree.get(l,l);\n\t\tres+=p;\n\t    }\n\t}\n\tcout<<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nconst int MAX_N=100000+16;\nint a[MAX_N*2];\nbool mark[MAX_N*2];\nint N,Q;\nint main(){\n    freopen(\"1.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&N,&Q)!=EOF){\n        if(N==0&&Q==0)break;\n        memset(mark,false,sizeof(bool)*(N+10));\n        a[1]=0;\n        mark[1]=1;\n        for(int i=2;i<=N;i++){\n            scanf(\"%d\",&a[i]);\n        }\n        int ans=0;\n        while(Q--){\n            char c[2];\n            int x;\n            scanf(\"%s %d\",c,&x);\n            if(c[0]=='Q'){\n                while(!mark[x]){\n                    x=a[x];\n                }\n                ans+=x;\n            }\n            else {\n                mark[x]=true;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)),(v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T,vector<T>,greater<T>>\n#define Pqza(T) priority_queue<T>\n#define ENJYU std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n//vector の中身を出力\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v)\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\ntypedef long long ll;\ntypedef pair<char, ll> query;\n\n\n\nll N, Q, ans;\n\n//parent, nearest marked ancestor, ismarked\nvector <ll> par, nma, ism;\nvector <query> q;\n\n//find nearest marked ancestor (keiroasshuku at the same time)\nll find_nma(ll x){\n\tif (nma[x] == x) return x;\n\telse return nma[x] = find_nma(par[x]);\n}\n\nvoid solve(void){\n\t//ENJYU;\n\twhile (cin >> N >> Q) {\n\t\tif (N == 0 && Q == 0) break;\n\t\t//init\n\t\tpar.clear(), ism.clear(), nma.clear(), q.clear();\n\t\tpar.resize(N), ism.resize(N), nma.resize(N), q.resize(Q);\n\t\tpar[0] = 0, ism[0] = 1, nma[0] = 0;\n\t\tans = 0LL;\n\t\trep(N-1, i) {\n\t\t\tcin >> par[i+1];\n\t\t\tpar[i+1]--;\n\t\t}\n\t\tnma = par;\n\n\t\t//クエリ受け取り\n\t\trep(Q, i) {\n\t\t\tcin >> q[i].fst >> q[i].snd;\n\t\t\tq[i].snd--;\n\t\t\t//先にMARKしておく\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd]++;\n\t\t\t\tnma[q[i].snd] = q[i].snd;\n\t\t\t}\n\t\t}\n\n\t\t//クエリを逆から見ていくと、頂点の更新は根の方向にのみ行われるので、前回の結果を使える\n\t\trepr(Q, i) {\n\t\t\tif (q[i].fst == 'M') {\n\t\t\t\tism[q[i].snd]--;\n\t\t\t\tif (ism[q[i].snd]) continue;\n\t\t\t\tnma[q[i].snd] = find_nma(par[q[i].snd]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += find_nma(q[i].snd) + 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(void){\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M;\nint par [100001];\nint root [100001];\n\nint find(int x)\n{\n\tif(root [x] == x) return x;\n\treturn root [x] = find(root [x]);\n}\n\nvoid unite(int x,int y)\n{\n\tx = find(x); y = find(y);\n\troot [y] = x;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&M) && N){\n\t\tFOR(i,2,N + 1){\n\t\t\tint u;\n\t\t\tscanf(\"%d\",&u);\n\t\t\tpar [i] = u;\n\t\t}\n\t\tpar [1] = 1;\n\t\tvector< pair<int,int> > qy(M);\n\t\tdeque<bool> d(N + 1);\n\t\tFOR(i,0,M){\n\t\t\tchar str [20];\n\t\t\tint x;\n\t\t\tscanf(\"%s%d\",str,&x);\n\t\t\tif(str [0] == 'M'){\n\t\t\t\td [x] = true;\n\t\t\t}\n\t\t\tqy [i] = make_pair(x,str [0] == 'Q');\n\t\t}\n\t\tFOR(i,2,N + 1) if(d [i] == false){\n\t\t\tqy.push_back(make_pair(i,0));\n\t\t}\n\t\treverse(qy.begin(),qy.end());\n\t\tll ans = 0;\n\t\tfor(int i = 1;i <= N;i++){\n\t\t\troot [i] = i;\n\t\t}\n\t\tFOR(i,0,qy.size()){\n\t\t\tif(qy [i].second == 0){\n\t\t\t\tunite(par [qy [i].first],qy [i].first);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += find(qy [i].first);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#define min(a,b)    (((a) < (b)) ? (a) : (b))\n#define max(a,b)    (((a) > (b)) ? (a) : (b))\n#define abs(x)    ((x) < 0 ? -(x) : (x))\n#define INF 0x3f3f3f3f\n#define delta 0.85\n#define eps 1e-3\n#define PI 3.14159265358979323846\n#define MAX_N 100005\nusing namespace std;\ntypedef long long ll;\nint N, Q;\nint par[MAX_N], mark[MAX_N];\nint qt[MAX_N], qv[MAX_N];\n\nint find(int t, int x){\n\treturn mark[x] < t ? x : par[x] = find(t, par[x]);\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &N, &Q) && N){\n\t\tfor(int i = 2; i <= N; i++){\n\t\t\tscanf(\"%d\", par + i);\n\t\t\tmark[i] = INF;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i = 1; i <= Q; i++){\n\t\t\tint x;\n\t\t\tchar c;\n\t\t\tscanf(\" %c%d\", &c, &x);\n\t\t\tif(c == 'M'){\n\t\t\t\tmark[x] = min(mark[x], i);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqt[cnt] = i, qv[cnt] = x;\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tll sum = 0;\n\t\tfor(int i = cnt - 1; i >=0 ; i--){\n\t\t\tsum += find(qt[i], qv[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<char, int> P;\n\nconst int MAX_N = 1000000, MAX_Q = 1000000;\nint N, Q;\n\nint par[MAX_N+5];\nint par2[MAX_N+5];\n\nvoid init(int N) {\n    for(int i = 0; i <= N; i++) {\n        par[i] = i;\n        par2[i] = i;\n    }\n}\n\nint find(int n) {\n    if(par[n] == n) return n;\n    par[n] = find(par[n]);\n    return par[n];\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n    // x is above\n    if(same(x, y)) return;\n    par[y] = x;\n}\n\nint main() {\n    while(true) {\n        // input\n        cin >> N >> Q;\n        if(!N && !Q) break;\n        init(N);\n        int p;\n        for(int i = 2; i <= N; i++) {\n            cin >> p;\n            par[i] = p;\n            par2[i] = p;\n        }\n        vector<P> v;\n        char c;\n        int t;\n        for(int i = 0; i < Q; i++) {\n            cin >> c >> t;\n            if(c == 'M') {\n                par[t] = t;\n            }\n            P q;\n            q.first = c;\n            q.second = t;\n            v.push_back(q);\n        }\n\n        // solve\n        int ans = 0;\n        for(int i = v.size()-1; i >= 0; i--) {\n            if(v[i].first == 'M') {\n                unite(par2[v[i].second], v[i].second);\n            } else {\n                ans += find(v[i].second);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\nint p[100010],N,Q,n;\n\nint find(int x)\n{\n\treturn p[x]==x?x:find(p[x]);\n}\n\nint main()\n{\n\twhile(~scanf(\"%d %d\",&N,&Q)&&N&&Q)\n\t{\n\t\tfor(int i=2;i<=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t}\n\t\tp[1]=1;\n\t\tlong long sum=0;\n\t\tchar ch[5];\n\t\twhile(Q--)\n\t\t{\n\t\t\tscanf(\"%s %d\",ch,&n);\n\t\t\tif(ch[0]=='Q')\n\t\t\t\tsum+=find(n);\n\t\t\telse if(ch[0]=='M')\n\t\t\t\tp[n]=n;\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<string>\n#include<cstdio>\n#include<stack>\n#include<cmath>\n#include<bitset>\n#include<functional>\n#include<memory>\n#include<utility>\nusing namespace std;\n#define FOR(i,m,n) for(i=m;i<n;i++)\n#define MIN(x,y) (x>y?y:x)\n#define ab(x,y) (x>y ?(x-y):(y-x))\n#define CLR(a,b) memset(a,b,sizeof(a))\n#define ROF(i,m,n) for(i=m;i>=n;i--)\n#define BUG cout<<\"debug\"<<endl;\n#define RT return\n#define BK break\n#define HEAP priority_queue\n#define SP \" \"\n#define lowf(a,b,c) lower_bound(a,b,c)\n#define upf(a,b,c) upper_bound(a,b,c)\n#define CP bool cmp(node A,node B)\n#define maxn 100000\ntypedef long long LL;\ntypedef vector<int> VI;\nconst int INF = 2147483647;\nconst int NEN = -INF - 1;\nconst LL LINF = 9223372036854775807;\nint fa[maxn+5];\nint node[maxn + 5];\nint N, Q;\nint main()\n{\n\twhile (1)\n\t{\n\t\tmemset(node, 0, sizeof(node));\n\t\tcin >> N >> Q; getchar(); getchar();\n\t\tif (N == 0 && Q == 0)break;\n\t\tint i;\n\t\tLL sum = 0;\n\t\tchar ope;\n\t\tint  a;\n\t\tFOR(i, 1, N + 1)\n\t\t{\n\t\t\tscanf(\"%d\", &fa[i + 1]);\n\t\t}\n\t\tnode[1] = 1;\n\t\twhile (getchar() != '\\n');\n\t\twhile (Q--)\n\t\t{\n\t\t\tscanf(\"%c\", &ope);\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (ope == 'M')node[a] = 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (node[fa[a]] != 1)\n\t\t\t\t{\n\t\t\t\t\ta = fa[a];\n\t\t\t\t}\n\t\t\t\tsum += fa[a];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int MAX = 100001;\n\nint par[MAX+1];\nint n;\n\nvoid init(){\n  for(int i = 0 ; i < MAX ; i++){\n    par[i] = i;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  } \n  else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n  par[x] = y;\n}\n\nint main(){\n  int q,c,num;\n  char ch;  \n\n  while(cin >> n >> q ,n){\n    long long sum = 0;\n    init();\n    par[1] = 1;\n    for(int i = 2 ; i <= n ; i++){\n      cin >> c;\n      par[i] = c;\n    }\n    for(int i = 0 ; i < q ; i++){\n      cin >> ch >> num;\n      if(ch == 'Q'){\n\tunite(num,par[num]);\n\tsum += par[num]+1;\n      }\n      else{\n\tpar[num] = num+1;\n      }\n    }\n    cout << sum << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int DEPTH = 18;\nclass RUQ\n{\n\tint value[1 << (DEPTH + 1)];\n\tint t[1 << (DEPTH + 1)];\npublic:\n\tRUQ() {\n\t\tfor (int i = 0; i < (1 << (DEPTH + 1)); i++) {\n\t\t\tvalue[i] = 0;\n\t\t\tt[i] = -1;\n\t\t}\n\t}\n\t\n\tvoid update(int l, int r, int v, int t, int a = 0, int b = (1 << DEPTH), int id = 0) {\n\t\tif (l >= b || r <= a) return;\n\t\tif (l <= a && b <= r) {\n\t\t\tvalue[id] = v;\n\t\t\tthis->t[id] = t;\n\t\t\treturn;\n\t\t}\n\t\tupdate(l, r, v, t, a, a + (b - a) / 2, id * 2 + 1);\n\t\tupdate(l, r, v, t, a + (b - a) / 2, b, id * 2 + 2);\n\t}\n\t\n\tint getValue(int id) {\n\t\tid = (1 << DEPTH) - 1 + id;\n\t\tint newestId = id;\n\t\twhile (id > 0) {\n\t\t\tid = (id - 1) / 2;\n\t\t\tif (t[id] > t[newestId]) newestId = id;\n\t\t}\n\t\treturn value[newestId];\n\t}\n};\n\nint n, q;\nvector<int> et[100000];\t\t//et[i][j] = ??????i??¨??????et[i][j]??????????????£?????????\nint ord[100000];\t\t\t//ord[i] = ??????i??????????????????(0-indexed)\nint Size[100000];\t\t\t//Size[i] = ??????i????????¨????????¨?????¨????????????\nint ordInv[100000];\t\t\t//ordInv[i] = ??????????????????i??????????????????\nRUQ seg;\n\nint dfs(int p, int v, int id) {\n\tint ret = 0;\n\t\n\tord[v] = id;\n\tfor (int i = 0; i < et[v].size(); i++) {\n\t\tif (et[v][i] == p) continue;\n\t\tint subSize = dfs(v, et[v][i], id + ret + 1);\n\t\tret += subSize;\n\t}\n\tret++;\n\treturn Size[v] = ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> q;\n\tfor (i = 1; i < n; i++) {\n\t\tint p; cin >> p; p--;\n\t\tet[p].push_back(i);\n\t}\n\tdfs(-1, 0, 0);\n\tfor (i = 0; i < n; i++) {\n\t\tordInv[ord[i]] = i;\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i < q; i++) {\n\t\tchar com; int v;\n\t\tcin >> com >> v; v--;\n\t\tif (com == 'Q') {\n\t\t\tans += ordInv[seg.getValue(ord[v])] + 1;\n\t\t}\n\t\telse {\n\t\t\tseg.update(ord[v], ord[v] + Size[v], ord[v], i);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &&x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstruct union_find {\n    vector<int> data;\n    union_find(int size) : data(size, -1) {}\n    // merge x to y\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            data[y] += data[x];\n            data[x] = y;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : (data[x] = root(data[x]));\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nsigned main() {\n    while (1) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 && Q == 0) break;\n\n        vector<vector<int>> ch(N);\n        vector<int> p(N);\n        REPF(i, 1, N) {\n            int v;\n            cin >> v;\n            v--;\n            p[i] = v;\n            ch[v].push_back(i);\n        }\n        vector<pair<char, int>> query(Q);\n        REP(i, Q) {\n            cin >> query[i].first >> query[i].second;\n            query[i].second--;\n        }\n        \n        union_find uf(N);\n        vector<int> marked(N);\n        marked[0]++;\n        REP(i, Q) {\n            if (query[i].first == 'M') marked[query[i].second]++;\n        }\n\n        {  // construct\n            stack<int> st;\n            st.push(0);\n            while (!st.empty()) {\n                int v = st.top(); st.pop();\n                if (marked[v] == 0) uf.unite(v, p[v]);\n                FORE(w, ch[v]) {\n                    st.push(w);\n                }\n            }\n        }\n\n        int ans = 0;\n        REPR(i, Q - 1) {\n            int v = query[i].second;\n            if (query[i].first == 'M') {\n                marked[v]--;\n                if (marked[v] == 0) uf.unite(v, p[v]);\n            } else {\n                ans += uf.root(v) + 1;\n            }\n        }\n        cout << ans << endl;\n    }\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\n//{{{ uf.hpp\n#ifndef INCLUDE_UF_HPP\n#define INCLUDE_UF_HPP\n#include <vector>\n#include <algorithm>\nnamespace orliv {\n//{{{ UF merge, same, root, size, count\nstruct UF {\n  std::vector<int> data;\n  int cnt;\n  UF(int n) : data(n, -1), cnt(n) {}\n  bool merge(int a, int b){\n    a = root(a);\n    b = root(b);\n    if (a != b){\n      cnt--;\n      data[a] += data[b];\n      data[b] = a;\n    }\n    return a != b;\n  }\n  bool same(int a, int b){ return root(a) == root(b); }\n  int root(int a){ return data[a] >= 0 ? data[a] = root(data[a]) : a; }\n  int size(int a){ return -data[root(a)]; }\n  int count(){ return cnt; }\n};\n//}}}\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orliv;\n\ntypedef long long ll;\ntypedef pair<char, int> QT;\n\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nint par[100100];\n\nint main()\n{\n  int N, Q;\n  while (N = in(), Q = in()){\n    for (int i = 2; i <= N; i++) par[i] = in();\n    UF uf(N + 1);\n    vector<QT> Qs;\n    Qs.reserve(Q);\n    for (int i = 0; i < Q; i++){\n      char S[4];\n      int v;\n      scanf(\"%s %d\", S, &v);\n      Qs.push_back(QT(*S, v));\n      par[v] = -par[v];\n    }\n    for (int i = 2; i <= N; i++){\n      if (par[i] < 0) par[i] = -par[i];\n      else uf.merge(par[i], i);\n    }\n    reverse(Qs.begin(), Qs.end());\n    ll ans = 0;\n    for (const auto& q : Qs){\n      int v = q.second;\n      if (q.first == 'Q') ans += uf.root(v);\n      else uf.merge(par[v], v);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> G[100000];\nbool vis[100000];\nint qtype[100000], vertex[100000], marked[100000];\n\nint par[100000], pp[100000];\n\nvoid init()\n{\n\tfor (int i = 0; i < 100000; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return (x);\n\treturn (par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif (x != y){\n\t\tpar[y] = x;\n\t}\n}\n\nvoid dfs(int v, int p, int m)\n{\n\tint nm = m;\n\tif (marked[v]) nm = v;\n\tpp[v] = p;\n\t\n\tmerge(nm, v);\n\t\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tdfs(G[v][i], v, nm);\n\t}\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\twhile (scanf(\"%d %d\", &N, &Q) && N){\n\t\tfor (int i = 0; i < N; i++) G[i].clear();\n\t\t\n\t\tfor (int i = 1; i < N; i++){\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tG[--v].push_back(i);\n\t\t}\n\t\t\n\t\tinit();\n\t\t\n\t\tmemset(marked, 0, sizeof(marked));\n\t\tmarked[0]++;\n\t\tfor (int i = 0; i < Q; i++){\n\t\t\tchar t[10];\n\t\t\tscanf(\"%s %d\", t, vertex + i);\n\t\t\tqtype[i] = (t[0] == 'Q');\n\t\t\t--vertex[i];\n\t\t\tif (!qtype[i]) ++marked[vertex[i]];\n\t\t}\n\t\t\n\t\tdfs(0, -1, -1);\n\t\t\n\t\tlong long int ans = 0;\n\t\tfor (int i = Q - 1; i >= 0; i--){\n\t\t\tif (qtype[i]){\n\t\t\t\tans += find(vertex[i]) + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t--marked[vertex[i]];\n\t\t\t\tif (!marked[vertex[i]]) merge(pp[vertex[i]], vertex[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nstruct uni {\n  int p[111111];\n  uni(){memset(p,-1,sizeof(p));}\n  int root(int a){return p[a]<0?a:(p[a]=root(p[a]));}\n  bool find(int a,int b){return root(a)==root(b);}\n  // aをbの親に\n  void merge(int a,int b){if(!find(a,b))p[root(b)]=root(a);}\n};\n\nint p[111111];\nint m[111111];\nint Q[111111];\nint Qm[111111];\nint Qi[111111];\nint Qc,Qmc;\nint main(void)\n{\n  int n,q;\n  long long res;\n  for(;;) {\n    scanf(\"%d%d\",&n,&q); if(n+q==0)return 0;\n    uni u;\n    memset(m,-1,sizeof(m));\n    res = 0;\n    Qc = 0;\n    Qmc = 0;\n    m[1] = 0;\n    for(int i = 0; i < n-1; i++) {\n      int a; scanf(\"%d\",&a);\n      p[i+1] = a-1;\n    }\n    for(int i = 0; i < q; i++) {\n      char c;int a; scanf(\" %c%d\",&c,&a);\n      --a;\n      Qi[Qc] = i;\n      if(c=='Q')Q[Qc++] = a;\n      else {\n        if(m[a] < 0) {\n          m[a] = i;\n          Qm[Qmc++] = i;\n        }\n      }\n    }\n    for(int i = 0; i < n; i++) {\n      if(m[i]<0) u.merge(p[i],i);\n    }\n    printf(\"%d %d\\n\",Qmc,Qc);\n    while(Qmc--) {\n      while( Qc && Qi[Qc-1] > Qm[Qmc] ) {\n        Qc--;\n        res += u.root(Q[Qc])+1;\n      }\n      u.merge(p[Qm[Qmc]],Qm[Qmc]);\n    }\n    \n    res += Qc;\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX (1<<17)\n#define INF (1<<29)\ntypedef long long ll;\n\nstruct SegmetTree {\n    ll n, dat[2*MAX-1];    \n    \n    SegmetTree(int n_, vector<int> &d)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = 1;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n - 1;\n        dat[k] = max(dat[k], a);\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n    \n    int get_max(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return -INF;\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            int vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n            int vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }    \n};\n\nint child[MAX];\nvector<int> G[MAX], vec;\n\nvoid init(int N)\n{\n    vec.clear();\n    for (int i = 0; i < N; i++) {\n        G[i].clear();\n        child[i] = 0;\n    }\n}\n\nint dfs(int v)\n{\n    int c = 0;\n    vec.push_back(v);\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        c += dfs(G[v][i]) + 1;\n    }\n    return (child[v] = c);\n}\n\nint main()\n{\n    int N, Q, x;\n    while (cin >> N >> Q, N) {\n        init(N);\n        for (int i = 1; i < N; i++) {\n            cin >> x; x--;\n            G[x].push_back(i);\n        }\n\n        dfs(0);\n\n        vector<int> num(N);\n        for (int i = 0; i < (int)vec.size(); i++) {\n            num[vec[i]] = i;\n        }\n        \n        SegmetTree st(N, vec);\n        \n        char m;\n        ll v, res = 0;\n        while (Q--) {\n            cin >> m >> v; v--;\n            if (m == 'M') {\n                st.update(num[v], v + 1);\n                for (int i = num[v] + 1; i <= num[v] + child[v]; i++) {\n                    st.dat[i+st.n-1] = max(st.dat[i+st.n-1], v+1);\n                }\n            } else {\n                int n = num[v];\n                res += st.get_max(n, n + child[v] + 1, 0, 0, st.n);\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\nvector<int> par,Rank,mark;\nvoid init(int n){\n\tpar.resize(n,0);\n\tRank.resize(n,0);\n\tmark.resize(n,0);\n\tmark[0] = 1;\n\tREP(i,n)par[i] = i;\n}\n\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\n\nint mark_find(int x){\n\tif(mark[x])return x;\n\telse if(par[x] == x)return -1;\n\telse return mark_find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\tif(Rank[x] > Rank[y])par[y] = x;\n\telse{\n\t\tpar[x] = y;\n\t\tif(Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x,int y){return find(x) == find(y);}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n||m){\n\t\tinit(n);\n\t\tREP(i,n-1){cin >> par[i];par[i]--;}\n\t\tint ans = 0;\n\t\tREP(i,m){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\tcin >> c >> v;\n\t\t\tif(c == 'M'){\n\t\t\t\tmark[v-1] = 1;\n\t\t\t}else if(c == 'Q'){\n\t\t\t\tans += mark_find(v-1) + 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nvi d;\nvector<vi> g;\n\nvoid dfs(int now, int a, int old){\n    if(d[now] == old)d[now] = a;\n    else return;\n    rep(i,g[now].size())dfs(g[now][i],a,old);\n}\n\nsigned main(void) {\n    int n,q;\n    while(1){\n        scanf(\"%lld %lld\",&n,&q);\n        if(n == 0)return 0;\n        g = vector<vi>(n);\n        loop(i,1,n){\n            int a;\n            scanf(\"%lld\",&a);\n            a--;\n            g[a].push_back(i);\n        }\n        d = vi(n,1);\n        int ans = 0;\n        while(q--){\n            char s[5];\n            scanf(\"%s\",s);\n            int v;\n            scanf(\"%lld\",&v);\n            v--;\n            if(s[0] == 'M'){\n                dfs(v,v+1,d[v]);\n            }else{\n                ans += d[v];\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 100000;\n\nint N, Q;\nint parent[MAX_N];\nbool marked[MAX_N];\nvector<pair<char, int> > va;\n\nint par[MAX_N];\nint rnk[MAX_N];\n\nint rec(int v){\n\tif(v == 0) return 0;\n\tif(rnk[v] != -1) return rnk[v];\n\treturn rnk[v] = rec(parent[v]) + 1;\n}\nvoid init(int N){\n\tfor(int i = 0; i < N; i++){\n\t\tpar[i] = i;\n\t}\n}\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] > rnk[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint main(){\n\tfor(;;){\n\t\tcin >> N >> Q;\n\t\tif(N == 0 && Q == 0) break;\n\t\tfor(int i = 1; i < N; i++){\n\t\t\tcin >> parent[i];\n\t\t\tparent[i]--;\n\t\t}\n\t\tfill(marked, marked + N, false);\n\t\tfill(rnk, rnk + N, -1);\n\t\tfor(int i = 0; i < Q; i++){\n\t\t\tchar ch; int v;\n\t\t\tcin >> ch >> v;\n\t\t\tv--;\n\t\t\tif(ch == 'M'){\n\t\t\t\tif(marked[v]) continue;\n\t\t\t\tmarked[v] = true;\n\t\t\t}\n\t\t\tva.push_back(make_pair(ch, v));\n\t\t}\n\t\treverse(va.begin(), va.end());\n\t\tinit(N);\n\t\tfor(int i = 0; i < N; i++) rnk[i] = rec(i);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(!marked[i]) unite(parent[i], i);\n\t\t}\n\t\tll res = 0LL;\n\t\tfor(int i = 0; i < va.size(); i++){\n\t\t\tif(va[i].first == 'M'){\n\t\t\t\tunite(parent[va[i].second], va[i].second);\n\t\t\t}else{\n\t\t\t\tres += (ll)(find(va[i].second) + 1);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t\tva.clear();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n \nlong long  n, q, root[105000], res;\nbool r[105000];\npair<char, int> query[105000];\n\nint solve(int x){\n    if(r[x])return x;\n    else return root[x] = solve(root[x]);\n}\n \nint main(){\n    while(true){\n\tcin >> n >> q;\n\tif(n == 0 && q == 0)return 0;\n\tres = 0;\n\tfill(r, r + n + 2,false);\n\tr[1] = true;\n\tr[0] = true;\n\troot[0] = 0;\n\troot[1] = 1;\n\tfor(int i = 2;i <= n;i++){\n\t    cin >> root[i];\n\t}\n\tfor(int i = 0;i < q;i++){\n\t    cin >> query[i].first >> query[i].second;\n\t    if(query[i].first == 'M')\n\t\tr[query[i].second] = true;\n\t}\n\tfor(int i = q;i--;){\n\t    int num = query[i].second;\n\t    if(query[i].first == 'M'){\n\t\tr[num] = false;\n\t    }\n\t    else{\n\t\tres += solve(num);\nreturn 0;\n\t    }\n\t}\n\tcout << res << endl;\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000,MAX_Q=100000;\n\nint N,Q;\nint p[MAX_N];\nchar q[MAX_Q+1];\nint v[MAX_Q];\n\nint colored[MAX_N];\t//?????????????????°\n\nvector<int> out;\n\nint find(int i){\n\t//?????????i?????????????????????????????????????????????\n\tif (colored[i]){\n\t\treturn i;\n\t}\n\treturn p[i]=find(p[i]);\n}\n\nint solve(){\n\t//?????¨?????????????????????\n\tfill(colored,colored+N,0);\n\tcolored[0]=1;\t//????????????????????????????????????\n\tfor (int i=0;i<Q;i++){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]++;\n\t\t}\n\t}\n\tint sum=0;\n\tfor (int i=Q-1;i>=0;i--){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]--;\n\t\t}\n\t\telse{\n\t\t\tsum+=(p[v[i]]=find(p[v[i]]))+1;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif (N || Q){\n\t\t\tp[0]=0;\n\t\t\tfor (int i=0;i<N-1;i++){\n\t\t\t\tscanf(\"%d\",&p[i+1]);\n\t\t\t\tp[i+1]--;\n\t\t\t}\n\t\t\tfor (int i=0;i<Q;i++){\n\t\t\t\tscanf(\" %c %d\",&q[i],&v[i]);\n\t\t\t\tv[i]--;\n\t\t\t}\n\t\t\tout.push_back(solve());\n\t\t}\n\t}while(N || Q);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%d\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<bool, int> bi;\nint T[100000];\nbool marked[100000];\nint N;\nint dfs(int v){\n    if(marked[v])\n      return v;\n    else\n      return dfs(T[v]);\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ifstream ifs(\"2170_input.txt\");\n    int Q, _t;\n    char _c;\n    while(ifs >> N >> Q && N){\n        vector<bi> query;\n        memset(marked, 0, sizeof(marked));\n        REP(i, 1, N){\n            ifs >> _t; _t--;\n            T[i] = _t;\n        }\n        marked[0] = true;\n        ll sum = 0;\n        rep(i, Q){\n            ifs >> _c >> _t; _t--;\n            if(_c == 'Q')\n                sum += dfs(_t) + 1;\n            else\n              marked[_t] = true;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\ntypedef pair<char, int> P;\ntypedef long long ll;\n\nint marked_ancestor[100000];\nint n, q;\nP outlog[100000];\nint ancestor[100000] = {}, ismarked[100000] = {}, is_doubleused[100000] = {};\n\n//Union_Find??¨???\nstruct UnionFind {\n\n\tint size;\n\tstd::vector<int> root, high;\n\n\tUnionFind() = default;\n\n\t//??????????????????????????????\n\tUnionFind(int vsize) {\n\n\t\troot.resize(vsize), high.resize(vsize);\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tUnionFind& operator= (UnionFind &ru) {\n\n\t\troot.resize(ru.root.size()), high.resize(ru.high.size());\n\t\tfor (auto i = 0; i < root.size(); i++) {\n\t\t\troot[i] = i, high[i] = 0;\n\t\t}\n\n\t}\n\n\tint getroot(int vx) {\n\n\t\tif (vx == root[vx])return vx;\n\t\treturn root[vx] = getroot(root[vx]);\n\n\t}\n\n\tvoid unite(int vx, int vy) {\n\n\t\tint x = getroot(vx), y = getroot(vy);\n\t\tif (x == y)return;\n\t\troot[vy] = x;\n\n\t}\n\n\tbool issame(int vx, int vy) {\n\n\t\treturn getroot(vx) == getroot(vy);\n\n\t}\n\n};\n\nint main() {\n\twhile (cin >> n >> q, n + q) {\n\t\tUnionFind uf(n);\n\t\tancestor[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tcin >> ancestor[i], ancestor[i]--;\n\t\t}\n\t\tismarked[0] = true;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tcin >> outlog[i].first >> outlog[i].second;\n\t\t\toutlog[i].second--;\n\t\t\tif (outlog[i].first == 'M')ismarked[outlog[i].second] = true;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!ismarked[i]) {\n\t\t\t\tuf.unite(ancestor[i], i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = q - 1; i >= 0; i--) {\n\t\t\tint tmp = outlog[i].second;\n\t\t\tif (outlog[i].first == 'M' && !is_doubleused[i])uf.unite(ancestor[tmp], tmp), is_doubleused[i] = true;\n\t\t\telse {\n\t\t\t\tans += (uf.getroot(tmp) + 1);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++)ancestor[i] = 0, marked_ancestor[i] = 0, ismarked[i] = false,is_doubleused[i] = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N=100000,MAX_Q=100000;\n\nint N,Q;\nint p[MAX_N];\nchar q[MAX_Q+1];\nint v[MAX_Q];\n\nint colored[MAX_N];\t//?????????????????°\n\nvector<int> out;\n\nint find(int i){\n\t//?????????i?????????????????????????????????????????????\n\tif (colored[i]){\n\t\treturn i;\n\t}\n\treturn p[i]=find(p[i]);\n}\n\nint solve(){\n\t//?????¨?????????????????????\n\tfill(colored,colored+N,0);\n\tcolored[0]=1;\t//????????????????????????????????????\n\tfor (int i=0;i<Q;i++){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]++;\n\t\t}\n\t}\n\tint sum=0;\n\tfor (int i=Q-1;i>=0;i--){\n\t\tif (q[i]=='M'){\n\t\t\tcolored[v[i]]--;\n\t\t}\n\t\telse{\n\t\t\tsum+=find(v[i])+1;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\tdo{\n\t\tscanf(\"%d %d\",&N,&Q);\n\t\tif (N || Q){\n\t\t\tp[0]=0;\n\t\t\tfor (int i=0;i<N-1;i++){\n\t\t\t\tscanf(\"%d\",&p[i+1]);\n\t\t\t\tp[i+1]--;\n\t\t\t}\n\t\t\tfor (int i=0;i<Q;i++){\n\t\t\t\tscanf(\" %c %d\",&q[i],&v[i]);\n\t\t\t\tv[i]--;\n\t\t\t}\n\t\t\tout.push_back(solve());\n\t\t}\n\t}while(N || Q);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%d\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nstruct seg_rangemin_getmin{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<18);\n\tint inff=inf*1000000ll;\n\tpa e={inf+1,inf+1};\n\tvector<pa> vec;\n\tvector<pa> lazy;\n\tvoid shoki1(){\n\t\t\tvec.resize(2*cor+3, {inf,inf});\n\t\tlazy.resize(2*cor+3, e);\n\t}\n\tvoid shoki2(){\n\t\t\n\t\t//初期値\n\t}\n\t\t\n\tvoid chien(int k,int l,int r){\n\t\tif(lazy[k]==e) return;\n\t\tif(l+1<r){\n\t\t\tvec[k]=min(vec[k],lazy[k]);\n\t\t\tlazy[2*k]=min(lazy[k],lazy[2*k]);\n\t\t\tlazy[2*k+1]=min(lazy[k],lazy[2*k+1]);\n\t\t\tlazy[k]=e;\n\t\t}\n\t\telse {\n\t\t\tvec[k]=min(lazy[k],vec[k]);\n\t\t\tlazy[k]=e;\n\t\t}\n\t}\n\t\n\tpa rangemin(int a,int b,pa w, int k=1,int l=0,int r=-3){\n\t\t//[a,b)を wに変更\n\t\tif(r<0) r=cor;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\t\n\t\t\t lazy[k]=min(lazy[k],w);\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\t\n\t\tchien(k,l,r);\n//\tcout<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\tpa w1=rangemin(a,b,w,k*2,l,(l+r)/2);\n\t\tpa w2=rangemin(a,b,w,k*2+1,(l+r)/2,r);\n\t\tvec[k]=min(w1,w2);\n\t\treturn vec[k];\n\t}\n\t\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\t\n\tpa getmin(int a,int b,int k=1,int l=0,int r=-1){\n\t\t//[a,b)のminを取得\n\t\tif(r<0) r=cor;\n\t\tchien(k,l,r);\n\t\tif(r<=a || b<=l){// 区間外\n\t\t\treturn {inf,inf};\n\t\t}\n\t\t\n\t\tif(a<=l && r<=b){// 完全含む\n\t\t\t\n\t\t\treturn vec[k];\n\t\t}\n\t\tpa w1=getmin(a,b,k*2,l,(l+r)/2);\n\t\tpa w2=getmin(a,b,k*2+1,(l+r)/2,r);\n\t\treturn min(w1,w2);\n\t}\n\t/*\n\tvoid pre(){\n\t\tfor(int i=1;i<2*cor;i++){\n\t\t\tcout<<vec[i]<<\" \";\n\t\t\tif(((i+1)&(-(i+1)))==i+1) cout<<endl;\n\t\t}\n\t}\n\t*/\n\t\n};\n\nvector<int> G[100020];\nvector<int> ve;\nint l[100020][2];\nint dep[100020];\nvoid dfs(int r,int d){\n//\tcout<<r<<\" \"<<d<<endl;\n\tve.pb(r);\n\tdep[r]=d;\n\tl[r][0]=ve.size()-1;\n\tfor(auto v:G[r])dfs(v,d-1);\n\tve.pb(r);\n\tl[r][1]=ve.size()-1;\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \t\n \twhile(1){\n \tint n,m;\n \t\tcin>>n>>m;\n \t//\tcout<<n<<\" \"<<m<<endl;\n \t\tif(n==0&& m==0) return 0;\n \t\tfor(int i=1;i<=n;i++)G[i].clear();\n \t\tfor(int i=2;i<=n;i++){\n \t\t\tint y;\n \t\t\tcin>>y;\n \t\t\tG[y].pb(i);\n \t\t}\n \t\tve.clear();\n \t\tdfs(1,10000000);\n \t\tseg_rangemin_getmin SE;\n \t\tSE.shoki1();\n \t\tSE.shoki2();\n \t//\tfor(int i=1;i<=n;i++)cout<<dep[i]<<endl;\n \t\tint ans=0;\n \t\tassert(l[1][0]==0);\n \t\tassert(l[1][1]+1==2*n);\n \t\tSE.rangemin(l[1][0],l[1][1]+1,{dep[1],1});\n \t\t\n \t\tfor(int er=0;er<m;er++){\n \t\t\tstring s;\n \t\t\tint y;\n \t\t\tcin>>s;\n \t\t\tcin>>y;\n \t\t\tif(s==\"Q\"){\n \t\t\t\tpa z=SE.getmin(l[y][0],l[y][0]+1);\n \t\t//\t\tcout<<l[y][0]<<endl;\n \t\t//\t\tcout<<z.first<<\" \"<<z.second<<endl;\n \t\t\t//\tcout<<z.second<<endl;\n \t\t\t\tassert(z.second<inf);\n \t\t\t\tans+=z.second;\n \t\t\t}\n \t\t\telse{\n \t\t\t\t\tSE.rangemin(l[y][0],l[y][1]+1,(pa){dep[y],y});\n \t\t\t}\n \t\t}\n \t\tcout<<ans<<endl;\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#define lowbit(x) (x & (-x))\n#define root 1, n, 1\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1  1\n#define ll long long\n#define pr(x) cout << #x << \" = \" << (x) << '\\n';\nusing namespace std;\n\nconst int INF = 0x7f7f7f7f;\nconst int MAXN = 1e5 + 111;\n\nll p[MAXN];\nll ans;\n\nint find(int x) {\n    return p[x] == x ? x : find(p[x]);\n}\n\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"C:\\\\Users\\\\apple\\\\Desktop\\\\in.txt\", \"r\", stdin);\n    #endif\n    int n, q;\n    while (~scanf(\"%d%d\", &n, &q) && (n && q)) {\n        for (int i = 1; i <= n; ++i) {\n            scanf(\"%lld\", &p[i]);\n        }\n\n        ans = 0;\n        int x;\n        char op[2];\n        while (q --) {\n            scanf(\"%s%d\", op, &x);\n            if (op[0] == 'Q') {\n                ans += find(x);\n            }\n            else p[x] = x;\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <alloca.h>\nusing namespace std;\n\n#define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n\n#define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nmap<int,int> near; \n\nvector<int> M[100010];\nvector<int> Q[100010];\nvector<int> ch[100010];\nint chk[100010];\nlong long ans;\n\nlong long esp_org, esp_new;\n\nvector<int> memo;\nint dfs(int x){\n\tstack<int> S;\n\tS.push(x);\n\twhile( S.size() ){\n\t\tx = S.top(); S.pop();\n\t\tif( chk[x] == 0 ){\n\t\t\tmemo.push_back(x);\n\t\t\tS.push(x);\n\t\t\tfor( auto c : ch[x] ) S.push(c);\n\t\t\tchk[x] = true;\n\t\t}else{\n\t\t\tmemo.push_back(x);\n\t\t\tchk[x] = false;\n\t\t}\n\t}\n}\nint dfs2(int x){\n\tfor( auto x : memo ){\n\t\tif( chk[x] ){\n\t\t\tfor( int i : M[x] ) near.erase(i);\n\t\t}else{\n\t\t\tfor( int i : M[x] ) near[i] = x;\n\t\t\tfor( int i : Q[x] ){\n\t\t\t\tint a = (*(--near.lower_bound(i))).second;\n\t\t\t\tans += a+1;\n\t\t\t}\n\t\t\tchk[x] = true;\n\t\t}\n\t}\n}\nint main(){\n\tint N,Qq;\n\twhile(cin >> N >> Qq && N){\n\t\tans = 0;\n\t\tmemo.clear();\n\t\tfor(int i = 0 ; i < 100010 ; i++)\n\t\t\tM[i].clear(),Q[i].clear(),ch[i].clear(),chk[i]=0;\n\t\tassert( near.size() == 0 );\n\t\tnear.clear();\n\t\trep(i,N-1){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tch[--x].push_back(i+1);\n\t\t}\n\t\tM[0].push_back(-1);\n\t\trep(i,Qq){\n\t\t\tchar c;\n\t\t\tint v;\n\t\t\t\n\t\t\tcin >> c >> v;\n\t\t\t--v;\n\t\t\tif( c == 'Q' ) Q[v].push_back(i);\n\t\t\tif( c == 'M' ) M[v].push_back(i);\n\t\t}\n\t\tdfs(0);\n\t\t//for( auto i : memo ) cout << i << endl;\n\t\tdfs2(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Tree {\n    vector<int> par;\n    vector<char> mark;\n    Tree(int n) : par(n, -1), mark(n, false) { }\n\n    void unmark(int k) {\n        mark[k] = false;\n    }\n\n    int query(int k) {\n        if(mark[k]) return k;\n        return par[k] = query(par[k]);\n    }\n};\n\nint main() {\n    for(int N, Q; cin >> N >> Q, N + Q > 0; ) {\n        Tree tree(N);\n        tree.mark[0] = true;\n        for(int i = 0; i < N - 1; i++) {\n            int p; cin >> p; p--;\n            tree.par[i + 1] = p;\n        }\n        vector<int> type;\n        vector<int> node;\n        for(int i = 0; i < Q; i++) {\n            char t; int n; cin >> t >> n; n--;\n            type.push_back(t == 'Q');\n            node.push_back(n);\n            if(t == 'M') tree.mark[n] = true;\n        }\n        reverse(type.begin(), type.end());\n        reverse(node.begin(), node.end());\n        int res = 0;\n        for(int i = 0; i < Q; i++) {\n            if(type[i]) {\n                res += tree.query(node[i]) + 1;\n            }\n            else {\n                tree.unmark(node[i]);\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef long long lint;\n\nstruct UnionFind {\nprivate:\n\tvector< int > data;\n\t\npublic:\n\tUnionFind(int _size) : data(_size, -1) {}\n\t\n\tbool unite(int _x, int _y) {\n\t\t_x = root(_x); _y = root(_y);\n\t\tif (_x != _y) data[_x] += data[_y]; data[_y] = _x;\n\t\treturn _x != _y;\n\t}\n\t\n\tbool same(int _x, int _y) { return root(_x) == root(_y); }\n\t\n\tint root(int _x) { return data[_x] < 0 ? _x : data[_x] = root(data[_x]); }\n\t\n\tint size(int _x) { return -data[root(_x)]; }\n};\n\nint N, Q, p[100010];\nchar q[100010];\nint mark[100010], v[100010];\n\nvoid solve() {\n\tUnionFind uf(N+1);\n\t\n\tfor_(i,1,N+1) if (!mark[i]) uf.unite(p[i], i);\n\t\n\tlint ans = 0;\n\t\n\tfor_rev(i,Q-1,0) {\n\t\tif (q[i] == 'M') {\n\t\t\t--mark[ v[i] ];\n\t\t\tif (!mark[ v[i] ]) uf.unite(p[ v[i] ], v[i]);\n\t\t} else {\n\t\t\tans += uf.root(v[i]);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (scanf(\"%d %d\", &N, &Q), N) {\n\t\tfor_(i,2,N+1) {\n\t\t\tscanf(\"%d\", &p[i]);\n\t\t}\n\t\t\n\t\tminit(mark, 0);\n\t\tmark[1] = 1;\n\t\t\n\t\tfor_(i,0,Q) {\n\t\t\tscanf(\"%s %d\", &q[i], &v[i]);\n\t\t\tif (q[i] == 'M') ++mark[ v[i] ];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n     \nconst int MAX_N = 100000;\n     \nint N, Q, ans;\nint Node[MAX_N];\nchar Ope[MAX_N];\nint Openum[MAX_N];\nint par[MAX_N];\n\nvoid init() {\n  for (int i = 0; i <= N; i++) {\n    par[i] = i;\n  }\n}\n     \nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n  par[find(x)] = find(y);\n}\n     \nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid solve() {\n  init();\n  for (int i = 0; i < Q; i++) {\n    char ope = Ope[i];\n    int num = Openum[i];\n    int nodeNum = Node[num];\n    \n    if (ope == 'M') {\n      unite(1,num);\n    }\n    \n    else if(ope == 'Q'){\n      while(1){\n        if(same(1,nodeNum)){\n          ans += nodeNum;\n          break;\n        }\n        nodeNum = Node[nodeNum];\n      }\n    }\n    \n  }\n  \n  printf(\"%d\\n\", ans);\n}\n  \nint main()\n{\n  Node[1] = 1;\n  while(1){\n    scanf(\"%d %d\", &N, &Q);\n    if(N == 0 && Q == 0) break;\n    for(int i = 2; i <= N; i++){\n      scanf(\"%d\", &Node[i]);\n    }\n    for(int i = 0; i < Q; i++){\n      scanf(\"  %c\", &Ope[i]);\n      scanf(\"%d\", &Openum[i]);\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<stack>\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define IO ios::sync_with_stdio(false);cin.tie(0);\n#define INF 0x3f3f3f3f\ntypedef unsigned long long ll;\nusing namespace std;\nint n, q, m, pre[100010];\nchar c;\nint find(int x)\n{\n\twhile(x != pre[x]){\n\t\tx = pre[x];\n\t}\n\treturn x;\n}\nint main()\n{\n\tIO;\n\twhile(cin >> n >> q){ \n\t\tif(!n&&!q) break;\n\t\tll sum=0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tpre[i] = i;\n\t\t}\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tcin >> pre[i];\n\t\t}\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tcin >> c >> m;\n\t\t\tif(c == 'Q') \n\t\t\t\tsum += find(m);\n\t\t\telse {\n\t\t\t\tpre[m] = m;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nconstexpr int MAX_N = (int)1e5 + 1;\n\nint n, q;\nint p[MAX_N];\nbool isMarked[MAX_N];\n\nint find(int x) {\n\tif (isMarked[x])\n\t\treturn x;\n\treturn find(p[x]);\n}\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n >> q;\n\t\tif (n + q == 0)\n\t\t\tbreak;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t\tstd::cin >> p[i];\n\t\tstd::memset(isMarked, false, sizeof(isMarked));\n\t\tisMarked[1] = true;\n\t\tp[1] = 1;\n\t\tchar in;\n\t\tint tar, ans = 0;\n\t\tfor (int i = 0; i < q; ++i) {\n\t\t\tstd::cin >> in >> tar;\n\t\t\tif (in == 'M')\n\t\t\t\tisMarked[tar] = true;\n\t\t\telse\n\t\t\t\tans += find(tar);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        g.addEdge(s, to);\n        make_dfs(to, g_, g, visited);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        vector<int> parent(N, 0);\n        for (int i = 0; i < N - 1; i++) {\n            int to;\n            cin >> to;\n            to--;\n            parent[i] = to;\n            g_.addEdge(to, i);\n            g_.addEdge(i, to);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        make_dfs(0, g_, g, visited);\n\n\n        using P = pair<char, int>;\n        vector<P> query;\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = 0;\n        }\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            if (c == 'M') {\n                if (marked[n]) {\n                    continue;\n                }\n                comp[n] = n;\n                marked[n] = true;\n            }\n            query.push_back(make_pair(c, n));\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        int sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n                const int s = q.second;\n                const int par = parent[s];\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n    }\n    vector<vector<int>> edge;\n};\n\nvoid dfs(const int s, const Graph& g, const vector<bool>& marked, DisjointSets& uf, vector<int>& comp)\n{\n    for (const int to : g.edge[s]) {\n        if (not marked[to]) {\n            uf.unite(s, to);\n            comp[uf.find(s)] = comp[s];\n        }\n        dfs(to, g, marked, uf, comp);\n    }\n}\n\nvoid make_dfs(const int s, const Graph& g_, Graph& g, vector<bool>& visited)\n{\n    visited[s] = true;\n    for (const int to : g_.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        g.addEdge(s, to);\n        make_dfs(to, g_, g, visited);\n    }\n}\n\nint main()\n{\n    while (true) {\n        int N, Q;\n        cin >> N >> Q;\n        if (N == 0 and Q == 0) {\n            break;\n        }\n        Graph g_(N);\n        vector<bool> marked(N, false);\n        marked[0] = true;\n        vector<int> parent(N, 0);\n        for (int i = 0; i < N - 1; i++) {\n            int to;\n            cin >> to;\n            to--;\n            parent[i] = to;\n            g_.addEdge(to, i);\n            g_.addEdge(i, to);\n        }\n\n        vector<bool> visited(N, false);\n        Graph g(N);\n        make_dfs(0, g_, g, visited);\n\n\n        using P = pair<char, int>;\n        vector<P> query;\n        vector<int> comp(N);\n        for (int i = 0; i < N; i++) {\n            comp[i] = 0;\n        }\n        for (int q = 0; q < Q; q++) {\n            char c;\n            int n;\n            cin >> c >> n;\n            n--;\n            if (c == 'M') {\n                if (marked[n]) {\n                    continue;\n                }\n                comp[n] = n;\n                marked[n] = true;\n            }\n            query.push_back(make_pair(c, n));\n        }\n\n        DisjointSets uf(N);\n        dfs(0, g, marked, uf, comp);\n\n        reverse(query.begin(), query.end());\n        long long sum = 0;\n        for (const auto& q : query) {\n            if (q.first == 'M') {\n                const int s = q.second;\n                const int par = parent[s];\n                uf.unite(par, s);\n                comp[uf.find(s)] = comp[par];\n            } else {\n                sum += (comp[uf.find(q.second)] + 1);\n            }\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> G[100000];\nbool isMarked[100000];\nint parent[100000];\nusing P = pair<char,int>;\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n        init(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(isMarked[x]){\n            par[y]=x;\n        }else{\n            par[x]=y;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\nvoid dfs1(int v, int pre, union_find &UF){\n    if(!isMarked[v]) UF.unite(pre,v);\n    for(auto to:G[v]){\n        if(to!=pre) dfs1(to,v,UF);\n    }\n    return;\n}\n\nint main(){\n    int N,Q;\n    while(cin>>N>>Q,N){\n        for(auto &g:G) g.clear();\n        fill(isMarked,isMarked+100000,false);\n        fill(parent,parent+100000,-1);\n        parent[0]=-1;\n        for(int i=1;i<N;i++){\n            int p;\n            cin>>p; p--;\n            parent[i]=p;\n            G[p].push_back(i);\n            G[i].push_back(p);\n        }\n        isMarked[0]=true;\n        vector<P> V;\n        for(int i=0;i<Q;i++){\n            char C;\n            int v;\n            cin>>C>>v; v--;\n            if(C=='M') isMarked[v]=true;\n            V.emplace_back(C,v);\n        }\n        reverse(V.begin(), V.end());\n        union_find UF(N);\n        dfs1(0,-1,UF);\n        int64_t ans = 0;\n        for(auto p:V){\n            char C; int v;\n            tie(C,v)=p;\n            if(C=='Q'){\n                ans+=UF.find(v)+1;\n                // cout<<UF.find(v)+1<<endl;\n            }else{\n                isMarked[v]=false;\n                UF.unite(v,parent[v]);\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ONLINE_JUDGE\n#pragma warning(disable : 4996)\n#endif\n#include <iostream>\nusing namespace std;\n #include<stdio.h>\n#define MAX_N 100005\ntypedef long long ll;\ntypedef pair<ll,bool> p;\np fa[MAX_N];\nint main(){\n    int n,q;\n    fa[1].first = 1;\n    fa[1].second = true;\n    while(~scanf(\"%d%d\",&n,&q)&&n>0){\n        int ans = 0;\n        for(int i = 2;i <= n;i++){\n            scanf(\"%lld\",&fa[i].first);\n            fa[i].second = false;\n        }\n        getchar();\n        for(int i = 0;i<q;i++){\n            char ch;int a;\n            scanf(\"%c%d\",&ch,&a);\n            getchar();\n            if(ch =='Q'){\n                while(fa[a].second==false){\n                    a = fa[a].first;\n                }\n                ans += a;\n            }\n            else{\n                fa[a].second = true;\n            }\n\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<cstring>\nusing namespace std;\nconst int num = 1e5+1;\nint n,q,ask[num][2],time[num]={},askl=0;\nint father[num];\nbool mark[num]={};\nlong long getF(int t)\n{\n    if(mark[t]&&time[t]<=ask[askl][1])\n        return (long long)t;\n    return (long long)(father[t]=getF(father[t]));\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&q);\n    char c;\n    int x,i,j,fax,t;\n    long long ans=0;\n    for(i=2;i<=n;++i)\n        scanf(\"%d\",&father[i]);\n    getchar();\n    bool flag=false;\n    time[1]=0;\n    mark[1]=true;\n    while(scanf(\"%c\",&c)&&c!='0'){\n        scanf(\"%d\",&x);\n        if(c=='M'){\n            if(!flag){\n                ++t;\n                flag=true;\n            }\n            mark[x]=true;\n            time[x]=t;\n        }\n        else{\n            flag=false;\n            ++askl;\n            ask[askl][0]=x;\n            ask[askl][1]=t;\n        }\n        getchar();\n    }\n    while(askl>0){\n        ans+=getF(ask[askl][0]);\n        --askl;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(int a=a;i<=int(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\nstruct HeavyLightDecomposition {\n    int size;\n    vector<vector<int>> g;\n    vector<int> parent, subtreeSize, depth;\n    vector<int> head, next;\n    vector<int> chain, at;\n    vector<vector<int>> chains;\n\n    template<class Graph>\n    HeavyLightDecomposition(const Graph &g_){\n        size = g_.size();\n        g.resize(size);\n        vector<int64_t> es;\n        for(size_t i = 0; i < g_.size(); i++){\n            for(auto &e : g_[i]){\n                int a = e.src, b = e.dst;\n                if(a > b) swap(a,b);\n                es.eb((int64_t)a << 32 | b);\n            }\n        }\n        sort(es.begin(), es.end());\n        es.erase(unique(es.begin(), es.end()), es.end());\n        for(int64_t & e : es){\n            addEdge(e >> 32, e & 0xFFFFFFFF);\n        }\n    }\n\n    HeavyLightDecomposition(int n_) : size(n_), g(n_) {}\n\n    void addEdge(int a, int b){\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    int goUp(int & v) const {\n        return parent[head[v]];\n    }\n\n    void decompose(const int root = 0){\n        parent.assign(size, 0);\n        subtreeSize.assign(size, 0);\n        depth.assign(size, -1);\n        head.assign(size, 0);\n        next.assign(size, -1);\n        chain.assign(size, -1);\n        at.assign(size, 0);\n        static int stk[600010], k = 0;\n        stk[k++] = root;\n        parent[root] = -1;\n        depth[root] = 0;\n        while(k){\n            const int v = stk[--k];\n            if(v >= 0){\n                stk[k++] = ~v;\n                for(const int ch : g[v]){\n                    if(depth[ch] != -1) continue;\n                    depth[ch] = depth[v] + 1;\n                    parent[ch] = v;\n                    stk[k++] = ch;\n                }\n            } else {\n                const int u = ~v;\n                subtreeSize[u] = 1;\n                int m = 0;\n                for(const int ch : g[u]){\n                    if(parent[u] == ch) continue;\n                    subtreeSize[u] += subtreeSize[ch];\n                    if(m < subtreeSize[ch]){\n                        m = subtreeSize[ch];\n                        next[u] = ch;\n                    }\n                }\n            }\n        }\n\n        k = 0;\n        stk[k++] = root;\n        while(k){\n            const int head_ = stk[--k];\n            for(const int ch : g[head_]){\n                if(parent[head_] == ch) continue;\n                stk[k++] = ch;\n            }\n            if(chain[head_] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> & path = chains.back();\n            int cur = head_;\n            while(cur != -1){\n                path.push_back(cur);\n                cur = next[cur];\n            }\n            for(size_t i = 0; i < path.size(); i++){\n                const int v = path[i];\n                head[v] = path.front();\n                next[v] = i+1 != path.size() ? path[i+1] : -1;\n                chain[v] = chains.size() - 1;\n                at[v] = i;\n            }\n        }\n    }\n\n    vector<map<int,int>> marks; // -depth, node\n    void prepare(){\n        marks.assign(chains.size(), { {inf, inf} });\n    }\n    void mark(int v){\n        marks[chain[v]][-depth[v]] = v;\n    }\n    int query(int v){\n        while(1){\n            auto ms = marks[chain[v]];\n            auto it = ms.lower_bound(-depth[v]);\n            if(it->first != inf){\n                return it->second;\n            } else {\n                v = goUp(v);\n            }\n        }\n        assert(false);\n    }\n};\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Edge(int src_, int dst_) :\n        src(src_), dst(dst_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nint n,q;\nGraph g;\nchar qt[100010];\nint qv[100010];\n\nll solve(){\n    ll ans = 0;\n    HeavyLightDecomposition h(g);\n    h.decompose();\n    if(h.chains.size()==1){\n        // なぜか構造体の中でやると激重\n        map<int,int> marks;\n        marks.insert(make_pair(0,0));\n        marks.insert(make_pair(inf,inf));\n        rep(i,q){\n            int d = h.depth[qv[i]];\n            if(qt[i] == 'Q') ans += marks.lower_bound(-d)->second + 1;\n            else marks.insert(mp(-d, qv[i]));\n        }\n    } else {\n        h.prepare();\n        h.mark(0);\n        rep(i,q){\n            if(qt[i] == 'Q') ans += h.query(qv[i]) + 1;\n            else h.mark(qv[i]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    fastios();\n    while(cin >> n >> q && n){\n        g.assign(n, {});\n        rep(i,n-1){\n            int par;\n            cin >> par;\n            par--;\n            g[par].eb(par,i+1);\n        }\n        rep(i,q){\n            cin >> qt[i] >> qv[i];\n            qv[i]--;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n    struct Node{\n        Node *l,*r,*p;\n        size_t sz;// tree size (only for root)\n        int idx;\n        bool rev;\n        T val,dat;\n        E laz;\n        Node():sz(1){}\n        Node(int idx,T val,E laz):\n        sz(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n        bool is_root(){\n            return !p||(p->l!=this&&p->r!=this);\n        }\n    };\n    \n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using S = function<T(T)>;\n    F f;\n    G g;\n    H h;\n    S s;\n    T ti;\n    E ei;\n    \n    const size_t LIM = 1e6;\n    vector<Node> pool;\n    size_t ptr;\n    \n    \n    LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n        s=[](T a){return a;};\n    }\n    \n    LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n    \n    inline Node* create(){\n        return &pool[ptr++];\n    }\n    \n    inline Node* create(int idx,T v){\n        return &(pool[ptr++]=Node(idx,v,ei));\n    }\n    \n    void propagate(Node *t,E v){\n        t->laz=h(t->laz,v);\n        t->val=g(t->val,v);\n        t->dat=g(t->dat,v);\n    }\n    \n    void toggle(Node *t){\n        swap(t->l,t->r);\n        t->dat=s(t->dat);\n        t->rev^=1;\n    }\n    \n    void eval(Node *t){\n        if(t->laz!=ei){\n            if(t->l) propagate(t->l,t->laz);\n            if(t->r) propagate(t->r,t->laz);\n            t->laz=ei;\n        }\n        if(t->rev){\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev=false;\n        }\n    }\n    \n    void recalc(Node *t){\n        t->dat=t->val;\n        if(t->l) t->dat=f(t->l->dat,t->dat);\n        if(t->r) t->dat=f(t->dat,t->r->dat);\n    }\n    \n    void rotR(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->l=t->r)) t->r->p=x,x->sz+=x->l->sz;\n        t->r=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void rotL(Node *t){\n        Node *x=t->p,*y=x->p;\n        x->sz-=t->sz;\n        t->sz+=x->sz;\n        if((x->r=t->l)) t->l->p=x,x->sz+=x->r->sz;\n        t->l=x;x->p=t;\n        recalc(x);recalc(t);\n        if((t->p=y)){\n            if(y->l==x) y->l=t;\n            if(y->r==x) y->r=t;\n            recalc(y);\n        }\n    }\n    \n    void splay(Node *t){\n        eval(t);\n        while(!t->is_root()){\n            Node *q=t->p;\n            if(q->is_root()){\n                eval(q);eval(t);\n                if(q->l==t) rotR(t);\n                else rotL(t);\n            }else{\n                auto *r=q->p;\n                eval(r);eval(q);eval(t);\n                if(r->l==q){\n                    if(q->l==t) rotR(q),rotR(t);\n                    else rotL(t),rotR(t);\n                }else{\n                    if(q->r==t) rotL(q),rotL(t);\n                    else rotR(t),rotL(t);\n                }\n            }\n        }\n    }\n    \n    Node* expose(Node *t){\n        Node *rp=nullptr;\n        for(Node *c=t;c;c=c->p){\n            splay(c);\n            c->r=rp;\n            recalc(c);\n            rp=c;\n        }\n        splay(t);\n        return rp;\n    }\n    \n    void link(Node *par,Node *c){\n        expose(c);\n        expose(par);\n        c->p=par;\n        par->r=c;\n        par->sz+=c->sz;\n    }\n    \n    void cut(Node *c){\n        expose(c);\n        Node *par=c->l;\n        c->l=nullptr;\n        par->p=nullptr;\n        c->sz-=par->sz;\n    }\n    \n    void evert(Node *t){\n        expose(t);\n        toggle(t);\n        eval(t);\n    }\n    \n    bool is_connected(Node *a,Node *b){\n        expose(a);\n        while(a->l) a=a->l;\n        expose(b);\n        while(b->l) b=b->l;\n        return expose(a)==expose(b);\n    }\n    \n    Node *lca(Node *a,Node *b){\n        expose(a);\n        return expose(b);\n    }\n    \n    T query(Node *t){\n        expose(t);\n        return t->dat;\n    }\n    \n    void update(Node *t,E v){\n        expose(t);\n        propagate(t,v);\n        eval(t);\n    }\n};\n\n//END CUT HERE\n\ntemplate<typename T>\nstruct BIT{\n    int n;\n    vector<T> bit;\n    //1-indexed\n    BIT():n(-1){}\n    BIT(int n_,T d):n(n_),bit(n_+1,d){}\n    \n    T sum(int i){\n        T s=bit[0];\n        for(int x=i;x>0;x-=(x&-x))\n            s+=bit[x];\n        return s;\n    }\n    void add(int i,T a){\n        if(i==0) return;\n        for(int x=i;x<=n;x+=(x&-x))\n            bit[x]+=a;\n    }\n    \n    int lower_bound(int w){\n        if(w<=0) return 0;\n        int x=0,r=1;\n        while(r<n) r<<=1;\n        for(int k=r;k>0;k>>=1){\n            if(x+k<=n&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n    \n    T sum0(int i){\n        return sum(i+1);\n    }\n    void add0(int i,T a){\n        add(i+1,a);\n    }\n    \n    T query(int l,int r){\n        return sum(r-1)-sum(l-1);\n    }\n    \n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\n\nclass LCA{\nprivate:\n    typedef pair<ll,vector<ll>> node; //depth,parents\n    ll root;\n    ll v;\n    vector<node> tree;\n    vector<vector<ll>> E;\n    ll High; //高さのlog\n    \n    void bfs(){\n        tree[root]={0,{root}};\n        queue<ll> q;\n        q.push(root);\n        vector<bool> done(v,false);\n        while(!q.empty()){\n            ll where=q.front();\n            q.pop();\n            if(done[where]){continue;}\n            done[where]=true;\n            for(int i=0;i<E[where].size();i++){\n                if(!done[E[where][i]]){\n                    tree[E[where][i]].F=tree[where].F+1;\n                    tree[E[where][i]].S={where};\n                    q.push(E[where][i]);\n                }\n            }\n        }\n    }\n    \npublic:\n    LCA(ll v,ll root):v(v),root(root){\n        tree.resize(v);\n        E.resize(v);\n    }\n    \n    //双方向のエッジでもよい\n    void add_edge(ll from,ll to){\n        E[from].push_back(to);\n    }\n    \n    //searchの前に行う\n    void mk_tree(){\n        bfs();\n        bool j=true;\n        for(int i=0;j;i++){\n            j=false;\n            for(int t=0;t<v;t++){\n                ll P=tree[t].S[i];\n                P=tree[P].S[i];\n                tree[t].S.push_back(P);\n                if(P!=root){j=true;}\n            }\n        }\n        High=tree[root].S.size();\n    }\n    \n    ll search_parent(ll a,ll h){\n        if(tree[a].F<=h){return root;}\n        for(ll i=High-1;i>=0;i--){\n            if((1<<i)&h){a=tree[a].S[i];}\n        }\n        return a;\n    }\n    \n    ll search_lca(ll a,ll b){\n        ll dif=tree[a].F-tree[b].F;\n        if(0>dif){swap(a,b); dif=abs(dif);}\n        a=search_parent(a,dif);\n        for(ll i=High-1;i>=0;i--){\n            if(tree[a].S[i]!=tree[b].S[i]){\n                a=tree[a].S[i];\n                b=tree[b].S[i];\n            }\n        }\n        while(a!=b){\n            a=tree[a].S[0];\n            b=tree[b].S[0];\n        }\n        return a;\n    }\n    \n    ll high(ll a){\n        return tree[a].F;\n    }\n};\n\n\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        if(n==0){break;}\n    int q;\n    cin>>q;\n    using LCT = LinkCutTree<int,int>;\n    LCT::F f=[](int a,int b){return a+b;};\n    LCT lc(f,f,f,0,0);\n    vector<int> P(n);\n    vector<LCT::Node*> v(n);\n    LCA lca(n,0);\n    for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n    ll ans=0;\n    for(int i=1;i<n;i++){\n        int k;\n        cin>>k;\n        k--;\n        lc.link(v[k],v[i]);\n        P[i]=k;\n        lca.add_edge(k,i);\n    }\n    lca.mk_tree();\n    for(int i=0;i<q;i++){\n        char c;\n        cin>>c;\n        if(c=='M'){\n            int a;\n            cin>>a;\n            a--;\n            lc.expose(v[a]);\n            v[a]->val=f(v[a]->val,1);\n        }\n        else{\n            int a;\n            cin>>a;\n            if(a==1){assert(false);}\n            a=P[a-1];\n            lc.expose(v[a]);\n            int D=v[a]->dat;\n            if(D==0 || a==0){ans++; continue;}\n            int l=1,r=n;\n            while(r-l>1){\n                int m=l+(r-l)/2;\n                ll p=lca.search_parent(a,m);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){r=m;}\n                else{l=m+1;}\n            }\n            for(int i=l;i<=r;i++){\n                ll p=lca.search_parent(a,i);\n                lc.expose(v[p]);\n                if(D-v[p]->dat>0){ans+=lca.search_parent(a,i-1)+1; break;}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nvector<vector<int>> g;\nvector<int> dep, in, out, res;\n\nvoid eur(int cur, int pre, int& idx) {\n    in[cur] = idx++;\n    for (auto nxt : g[cur]) {\n        if (nxt == pre) continue;\n        eur(nxt, cur, idx);\n    }\n    out[cur] = idx;\n}\nvoid dfs_dep(int cur, int pre) {\n    if (pre != -1) dep[cur] = dep[pre] + 1;\n    for (auto nxt : g[cur]) {\n        if (nxt == pre) continue;\n        dfs_dep(nxt, cur);\n    }\n}\n\nvoid bfs(vector<int>& st) {\n    queue<int> q;\n    for (auto e : st) q.emplace(e), res[e] = e;\n    while (!q.empty()) {\n        int cur= q.front();\n        q.pop();\n        for (auto nxt : g[cur]) {\n            if (dep[cur] < dep[nxt]) {\n                if (dep[res[nxt]] < dep[res[cur]]) {\n                    res[nxt] = res[cur];\n                    q.emplace(nxt);\n                }\n            }\n        }\n    }\n}\n\nvoid init(int n) {\n    g.clear(); dep.clear(); in.clear(); out.clear(); res.clear();\n    g.resize(n); dep.resize(n), in.resize(n), out.resize(n), res.resize(n);\n}\n\nvoid solve() {\n    int n, kkt; cin >> n >> kkt; if (n == 0) exit(0);\n    init(n);\n    for (int i = 1; i < n; i++) {\n        int p; cin >> p; p--;\n        g[p].emplace_back(i);\n        g[i].emplace_back(p);\n    }\n    {\n        int idx = 0;\n        eur(0, -1, idx);\n        dfs_dep(0, -1);\n    }\n\n    int b = sqrt(n);\n    vector<int> t;\n    ll r = 0;\n    while (kkt--) {\n        char c;\n        int v;\n        cin >> c >> v; v--;\n        if (c == 'Q') {\n            int ans = res[v];\n            for (auto e : t) {\n                if (in[e] <= in[v] and in[v] < out[e]) {\n                    if (ans == -1 or dep[ans] < dep[e]) {\n                        ans = e;\n                    }\n                }\n            }\n            r += ans + 1;\n        }\n        else {\n            t.emplace_back(v);\n        }\n        if (t.size() >= b) {\n            bfs(t);\n            t.clear();\n        }\n    }\n    cout << r << \"\\n\";\n}\nint main()\n{\n    \n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n\n    int kkt = 89;\n    while (kkt) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX_N 200000\nint par[MAX_N];\nint rank[MAX_N];\nint original_par[MAX_N];\nint query_list[MAX_N][2];\n\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    memset(marked_list,0,sizeof(int)*N);\n    //for(i=0;i<N;i++){ marked_list[i]=0; }\n    marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n        if(marked_list[query_list[i][1]]==1){\n          query_list[i][0]='N';\n        }\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i ==0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            if(par[current]  == current ) break;\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 100001\nint par[MAX_N];\nint rank[MAX_N];\n\nstruct operate{char op;int num;};\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n//x????????????????????????????????????????\\?????????¢???\nint M_find(int x,int mark[]){\n\tif(mark[x]==1){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = M_find(par[x],mark);\n\t}\n}\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint main(){\n\n\t//??????:?????¨?????????????????????????????????????????°???????????§??????\n\tint i,n,num_q,p_node;\n\tint mark[MAX_N];\n\tstruct operate ope;\n\tlong long int sum=0;\n\n\tscanf(\"%d %d\",&n,&num_q);\n\tinit(n);\n\n\tfor(i=1;i<=n;i++){\n\t\tmark[i]=0;\n\t\tscanf(\"%d\",&p_node);\n\t\tunite(i,p_node);\n\t}\n\tope.op='A'; ope.num=0; mark[1]=1;\n\twhile(1){\n\t\tscanf(\"%c %d\",&ope.op,&ope.num);\n\t\tif(ope.op=='0')break;\n\t\tif(ope.op=='Q')sum+=M_find(ope.num,mark);\n\t\tif(ope.op=='M')mark[ope.num]=1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint P[100005],M[100005],i,j,N,Q,r,t;\nchar q;\nint p(int n)\n{\n\treturn P[n]==n?n:p(P[n]);\n}\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)\n\t{\n\t\tfor(i=r=0;i<N;P[i]=i,M[i]=0,i++);\n\t\tM[1]=1;\n\t\tfor(i=1;i<=N;P[i+1]=t,i++)\n\t\t\tscanf(\"%d\\n\",&t);\n\t\tfor(i=0;i<Q;i++)\n\t\t{\n\t\t\tscanf(\"%c %d\\n\",&q,&t);\n\t\t\tif(q=='M')\n\t\t\t\tM[t]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(;!M[t];t=P[t]);\n\t\t\t\tr+=t;\n\t\t\t\t//printf(\"%d\\n\",t);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2170: Marked Ancestor\n// 2018.1.2 bal4u@uu\n\n#include <stdio.h>\n\nint p[100003];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n, c;\n\n//\twhile ((c = getchar_unlocked()) < '0');\n\tc = getchar_unlocked();\n\tn = 0;\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint find(int v)\n{\n\tif (v == p[v]) return v;\n\treturn find(p[v]);\n}\n\nint main()\n{\n\tint N, Q, i, cmd, v;\n\tlong long ans;\n\n\twhile (N = in()) {\n\t\tQ = in();\n\t\tp[1] = 1; for (i = 2; i <= N; i++) p[i] = in();\n\n\t\tans = 0;\n\t\tfor (i = 0; i < Q; i++) {\n\t\t\tcmd = getchar_unlocked(); getchar_unlocked();\n\t\t\tv = in();\n\t\t\tif (cmd == 'M') p[v] = v;\n\t\t\telse ans += find(v);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define N 100005\nint tree[N];\nchar  mark[N];\nint n, q;\nint _find(int x)\n{\n    if(mark[x])\n        return x;\n    else return _find(tree[x]);\n}\n\nint main()\n{\n    int i;\n   long long sum;\n\n     while(scanf(\"%d%d\",&n,&q)!=EOF)\n    {\n        if(!n&&!q)break;\n        memset(mark, 0, sizeof(mark));\n        for(i=1;i<=n;i++)\n        {\n            tree[i]=i;\n        }\n        mark[1] = tree[1] = 1;\n        sum = 0;\n        for(i = 1; i < n; ++i)\n            scanf(\"%d\", &tree[i +  1]);\n\n         for(i=1;i<=q;i++)\n        {\n            char ch[20];\n            scanf(\"%s\",ch);\n             int t;\n            scanf(\"%d\",&t);\n            if(ch[0]=='Q')\n            {\n                sum += _find(t);\n            }\n            else\n                mark[t] = 1;\n        }\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n#include <string>\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    memset(temp,0, sizeof(temp));\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    //Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i == 0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            if(par[current]  == current ) break;\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%lld\\n\",ans);\n    //printf(\"%d %d\\n \",n,o);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define maxn 100005\nint f[maxn];\nchar  vis[maxn];\nint n, q;\nint _find(int x)\n{\n    if(vis[x])\n        return x;\n    else return _find(f[x]);\n}\n\nint main()\n{\n    int i;\n  \n\n     while(scanf(\"%d%d\",&n,&q)!=EOF)\n    {\n         long long sum;\n        if(!n&&!q)break;\n        memset(vis, 0, sizeof(vis));\n        for(i=1;i<=n;i++)\n        {\n            f[i]=i;\n        }\n        vis[1] = 1;\n        sum = 0;\n        for(i = 1; i < n; ++i)\n            scanf(\"%d\", &f[i +  1]);\n\n         for(i=1;i<=q;i++)\n        {\n            char ch[20];\n            scanf(\"%s\",ch);\n            \n            if(ch[0]=='Q')\n            {\n                int t;\n                scanf(\"%d\",&t);\n                sum += _find(t);\n            }\n            else{\n                 int t;\n            scanf(\"%d\",&t);\n                vis[t] = 1;\n            }\n        }\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q,ans;\n  int i,j,k;\n  int markd_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<Q;i++){\n      markd_list[i]=0;\n    }markd_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      scanf(\"%c %d\\n\",&query_list[i][0],&query_list[i][1]);\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n        markd_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==markd_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      }else{\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 100001\nint par[MAX_N];\nint rank[MAX_N];\n\nstruct operate{char op;int num;};\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint M_find(int x,int mark[]){\n\tif(mark[x]==1){\n\t\treturn x;\n\t}else{\n\t\treturn M_find(par[x],mark);\n\t}\n}\n\nvoid make_tree(int x,int y){\n\tif(x==y){\n\t\treturn ;\n\t}\n\telse par[x]=y;\n}\n\nint main(){\n\tint i,n,num_q,p_node;\n\tint mark[MAX_N];\n\tstruct operate ope;\n\tlong long int sum=0;\n\n\tscanf(\"%d %d\",&n,&num_q);\n\tinit(MAX_N);\n\n\tfor(i=2;i<=n;i++){\n\t\tmark[i]=0;\n\t\tscanf(\"%d\",&p_node);\n\t\tmake_tree(i,p_node);\n\t}\n\tgetchar();\n\tmark[1]=1; i=0;\n\tfor(i=0;i<=num_q;i++){\n\t\tscanf(\"%c %d\",&ope.op,&ope.num);\n\t\tgetchar();\n\t\tif(ope.op=='Q')sum+=M_find(ope.num,mark);\n\t\tif(ope.op=='M')mark[ope.num]=1;\n\t}\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\nusing namespace std;\nint n,q;\nint par[110],Rank[110];\nvoid init()\n{\n\tint i;\n    for(i=0;i<110;i++)\n    {\n        par[i]=i;\n        Rank[i]=0;\n    }\n    Rank[1]=1;\n}\nint MV(int t)\n{\n    if(t==1)\n        return 1;\n    else\n        return(t+MV(par[t]));\n}\nvoid QV(int t)\n{\n    cout<<par[t]<<endl;\n}\nint main()\n{\n    char f;\n    init();\n\t//freopen(\"text.txt\",\"r\",stdin);\n\tcin>>n>>q;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t    cin>>par[i];\n\t    Rank[i]=Rank[par[i]]+1;\n\t}\n\tfor(int i=1;i<=q;i++)\n\t{\n\t    int a;\n\t    cin>>f>>a;\n\t    if(f=='Q')\n            QV(a);\n        else if(f=='M')\n            cout<<MV(a)<<endl;\n\t}\n\tcout<<\"0 0\"<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#define mem(name,value) memset(name,value,sizeof(name))\n#define loop(i,from,to) for(int i=from;i<to;i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn=100000+5;\nint par[maxn*2],n,q,ans,v;\nchar op;\nbool marked[maxn];\n\nvoid init(int N)\n{\n    loop(i,0,N)\n        par[i]=i;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&n,&q)!=EOF){\n        if(n==0 && q==0) break;\n        init(n+1);\n        mem(marked,false);\n        marked[1]=true;\n        ans=0;\n        loop(i,2,n+1){\n            scanf(\"%d\",&v);\n            par[i]=v;\n        }\n        loop(i,0,q){\n            getchar();\n            scanf(\"%c%d\",&op,&v);\n            if(op=='M') marked[v]=true;\n            if(op=='Q'){\n                do v=par[v];\n                while(!marked[v]);\n                ans+=v;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n#include <string>\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    memset(temp,0, sizeof(temp));\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    //Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i == 0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            if(par[current]  == current ) break;\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%lld\\n\",ans);\n    //printf(\"%d %d\\n \",n,o);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define N 100004\nint tree[N];\nchar  mark[N];\nint _find(int x)\n{\n    if(mark[x])\n        return x;\n    else return _find(tree[x]);\n}\n\nint main(void)\n{\n    int n, q, i;\n    unsigned long long sum;\n\n     while(scanf(\"%d%d\",&n,&q)!=EOF)\n    {\n        if(!n&&!q)break;\n        memset(mark, 0, sizeof(mark));\n        for(i=1;i<=n;i++)\n        {\n            tree[i]=i;\n        }\n        mark[1] = tree[1] = 1;\n        sum = 0;\n        for(i = 2; i <= n; ++i)\n            scanf(\"%d\", &tree[i]);\n\n         for(i=1;i<=q;i++)\n        {\n            char ch[20];\n            scanf(\"%s\",ch);\n             int t;\n            scanf(\"%d\",&t);\n            if(ch[0]=='Q')\n            {\n                sum += _find(t);\n            }\n            else\n                mark[t] = 1;\n        }\n        printf(\"%llu\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 100000\nint par[MAX_N];\nint rank[MAX_N];\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return find(par[x]);\n    return par[x] = find(par[x]);\n  }\n}\n\n//x?????????????´?????±??????????????????£??¨????????????\nint depth(int x){\n  if(par[x]==x){\n    return 0;\n  }else {\n    return depth(par[x])+1;\n  }\n}\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\n\nint main(){\n  int N,Q;\n  char s[16];\n  int i,d;\n  long long int res;\n  while(1){\n    if(!gets(s))break;\n    sscanf(s,\"%d %d\",&N,&Q);\n    if(N==0)break;\n    res=0;\n    init(N);\n    for(i=1;i<N;i++){\n      gets(s);\n      sscanf(s,\"%d\",&par[i]);\n      par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      gets(s);\n      sscanf(s+2,\"%d\",&d);\n      //printf(s);\n      //return;\n      switch(s[0]){\n      case 'Q':\n        res+=find(d-1)+1;\n        //printf(\"%d\\n\",find(d-1)+1);\n        break;\n      case 'M':\n        par[d-1]=d-1;\n        //printf(\"%d\\n\",d-1);\n        break;\n      }\n      //return 0;\n    }\n    //for(i=0;i<N;i++)printf(\"%d \",par[i]);\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<N;i++){\n      marked_list[i]=0;\n    }marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n\t\t\t\tif(marked_list[query_list[i][1]]==1){\n\t\t\t\t\tquery_list[i][0]='N';\n\t\t\t\t}\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  \n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    memset(temp,0, sizeof(temp));\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    //Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i == 0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            if(par[current]  == current ) break;\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%lld\\n\",ans);\n    //printf(\"%d %d\\n \",n,o);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2170: Marked Ancestor\n// 2018.1.2 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF 0x01010101\ntypedef struct { int i, v; } T;\nT tbl[100003]; int sz;\nint p[100003];\nint mk[100003];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n, c;\n\n\twhile ((c = getchar_unlocked()) < '0');\n\tn = 0;\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint find(int v, int i)\n{\n\tif (mk[v] < i) return v;\n\treturn p[v] = find(p[v], i);\n}\n\nint main()\n{\n\tint N, Q, i, cmd, v;\n\tlong long ans;\n\n\twhile (N = in()) {\n\t\tQ = in();\n\t\tp[1] = 1; for (i = 2; i <= N; i++) p[i] = in();\n\n\t\tmemset(mk, INF, sizeof(mk));\n\t\tmk[1] = 0;\n\n\t\tsz = 0;\n\t\tfor (i = 1; i <= Q; i++) {\n\t\t\tif ((cmd = getchar_unlocked()) < ' ') cmd = getchar_unlocked();\n\t\t\tv = in();\n\t\t\tif (cmd == 'M') { if (mk[v] == INF) mk[v] = i; }\n\t\t\telse tbl[sz].i = i, tbl[sz++].v = v;\n\t\t}\n\n\t\tans = 0;\n\t\twhile (sz--) ans += find(tbl[sz].v, tbl[sz].i);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct q\n{\n\tchar Op;\n\tint n;\n}q;\n\nint t[100001],pa[100001],mark[100001],N,Q,j;\nlong long int ans;\nq query[100001];\nvoid i(int n)\n{\n\tfor(j=0;j<=n;j++)\n\t{\n\t\tt[j]=j;\n\t\tpa[j]=mark[j]=0;\n\t}\n\tpa[1]=mark[1]=1;\n}\n\nint p(int n)\n{\n\tif(t[n]==n)\n\t\treturn n;\n\telse\n\t\treturn t[n]=p(t[n]);\n}\n\nvoid u(int a,int b)\n{\n\tint x=p(a),y=p(b);\n\tif(x!=y)\n\t\tt[x]=y;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0)\n\t{\n\t\tans=0;\n\t\tfor(i(N),j=0;j<N;j++)\n\t\t\tscanf(\"%d\\n\",&pa[j+2]);\n\t\tfor(j=0;j<Q;j++)\n\t\t{\n\t\t\tscanf(\"%c%d\\n\",&query[j].Op,&query[j].n);\n\t\t\tif(query[j].Op=='M')\n\t\t\t{\n\t\t\t\tif(mark[query[j].n])\n\t\t\t\t\tquery[j].Op='X';\n\t\t\t\telse\n\t\t\t\t\tmark[query[j].n]=1;\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=N;j++)\n\t\t\tif(!mark[j])\n\t\t\t\tu(j,pa[j]);\n\t\tfor(j=Q-1;j>=0;j--)\n\t\t{\n\t\t\tif(query[j].Op=='M')\n\t\t\t\tu(query[j].n,pa[query[j].n]);\n\t\t\telse if(query[j].Op=='Q')\n\t\t\t\tans+=p(query[j].n);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 100001\nint par[MAX_N];\nint rank[MAX_N];\n\nstruct operate{char op;int num;};\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint M_find(int x,int mark[]){\n\tif(mark[x]==1){\n\t\treturn x;\n\t}else{\n\t\treturn M_find(par[x],mark);\n\t}\n}\n\nvoid make_tree(int x,int y){\n\tif(x==y){\n\t\treturn ;\n\t}\n\telse par[x]=y;\n}\n\nint main(){\n\tint i,n,num_q,p_node;\n\tint mark[MAX_N];\n\tstruct operate ope;\n\tlong long int sum;\n\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&num_q);\n\t\tif(n==0)break;\n\t\tinit(MAX_N);\n\t\tsum=0;\n\n\t\tfor(i=2;i<=n;i++){\n\t\t\tmark[i]=0;\n\t\t\tscanf(\"%d\",&p_node);\n\t\t\tmake_tree(i,p_node);\n\t\t}\n\t\tgetchar();\n\t\tmark[1]=1; i=0;\n\t\tfor(i=0;i<num_q;i++){\n\t\t\tscanf(\"%c %d\",&ope.op,&ope.num);\n\t\t\tgetchar();\n\t\t\tif(ope.op=='Q')sum+=M_find(ope.num,mark);\n\t\t\tif(ope.op=='M')mark[ope.num]=1;\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int MAX_N = 100000 + 10;\nint N, Q;\nint P[MAX_N];\nint vis[MAX_N];\n\nvoid build(int N) {\n    for (int i = 0; i <= N; i++)\n        P[i] = i;\n}\n\nint find(int x) {\n    if (vis[P[x]])\n        return P[x];\n    else\n        return find(P[x]);\n}\n\nvoid Unite(int parent, int child) {\n    P[child] = parent;\n}\n\nint main() {\n    while (~scanf(\"%d %d\", &N, &Q) && (N || Q)) {\n        memset(vis, 0, sizeof(vis));\n        vis[1] = 1;\n        build(N);\n        int x;\n        for (int i = 2; i <= N; i++) {\n            scanf(\"%d\", &x);\n            Unite(x, i);\n        }\n        char s;\n        long long sum = 0;\n        getchar();\n        for (int i = 0; i < Q; i++) {\n            scanf(\"%c %d\", &s, &x);\n            getchar();\n            if (s == 'M')\n                vis[x] = 1;\n            else\n                sum += find(x);\n        }\n        printf(\"%lld\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2170\nTitle Marked Ancestor\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define NO_OF_NODES 100000\nint n,q;\nint node[NO_OF_NODES+1];\nint mark[NO_OF_NODES+1];\n//\nint nearest_marked_anscestor(int n)\n{\n  int a;\n  if(mark[n])\n    return(n);\n  do {\n    a=node[n];\n    //printf(\"A:%d\\n\",n);\n    if(mark[a])\n      return(a);\n    n=a;\n\n  }while(a!=1);\n}\nvoid mark_node(int n)\n{\n  mark[n]=-1;\n  //printf(\"M:%d\\n\",n);\n}\nmain()\n{ \n  int i,r,sum,arg;\n  char op;\n\n  while(EOF!=scanf(\"%d %d\",&n,&q) && (n||q))\n    {\n      sum=0;\n      for(i=2;i<=n;i++)\n\tmark[i]=0;\n      mark[1]=1;\n      for(i=2;i<=n;i++)\n\t{\n\t  scanf(\"%d \",&node[i]);\n\t}\n      for(i=0;i<q;i++)\n\t{\n\t  scanf(\"%c %d\\n\",&op,&arg);\n\t  if(op=='M')\n\t    mark_node(arg);\n\t  else if(op=='Q')\n\t    {\n\t      r= nearest_marked_anscestor(arg);\n\t      sum += r;\n\t    }\n\t}\n     \n      printf(\"%d\\n\",sum);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint P[100005],M[100005],i,j,N,Q,t;\nlong long r;\nchar q;\nint p(int n)\n{\n\treturn P[n]==n?n:p(P[n]);\n}\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)\n\t{\n\t\tfor(i=r=0;i<N;P[i]=i,M[i]=0,i++);\n\t\tM[1]=1;\n\t\tfor(i=2;i<=N;P[i]=t,i++)\n\t\t\tscanf(\"%d\\n\",&t);\n\t\tfor(i=0;i<Q;i++)\n\t\t{\n\t\t\tscanf(\"%c %d\\n\",&q,&t);\n\t\t\tif(q=='M')\n\t\t\t\tM[t]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(;!M[t];t=P[t]);\n\t\t\t\tr+=t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "P[100005],M[100005],v[100005],i,j,N,Q,t;long long r;char q[100005];int main(){for(;scanf(\"%d%d\",&N,&Q),N;){for(i=r=0,M[1]=1;i<N;P[i]=i,M[i]=0,i++);for(i=2;i<=N;P[i]=t,i++)scanf(\"%d\\n\",&t);for(i=0;i<Q;i++){scanf(\"%c %d\\n\",&q[i],&v[i]);if(q[i]=='M')M[v[i]]++;}for(i=Q-1;i>=0;i--){if(q[i]=='M')M[v[i]]--;else{for(t=v[i];!M[t];)t=P[t];r+=t;}}printf(\"%lld\\n\",r);}return 0;}"
  },
  {
    "language": "C",
    "code": " #include<iostream>\n\n/**************\n * @Math\n **************/\n#include<cmath>\n#include<algorithm>\n\n/**************\n * @String\n **************/\n\n#include<cstring>\n#include<string>\n#include<string.h>\n\n/**************\n * @container\n **************/\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n#define maxSize 100001\nbool mark[maxSize];\nint p[maxSize] , f[maxSize];\nvector<int> v[maxSize];\npair<char, int> query[maxSize];\nvoid init()\n{\n\tfor (int i = 0; i < maxSize; ++i)\n\t{\n\t\t p[i] = i;\n\t}\n}\n \nint parent(int i)\n{\n\tif(p[i] == i) return i;\n\treturn p[i] = parent(p[i]);\n }\n\nvoid u(int a, int b) \n{\n\tp[parent(a)] =  parent(b);\n\treturn ;\n}\n\nvoid Bfs() \n{\n\tqueue<int> que;\n\tque.push (1);\n\tp[1] = 1;\n\twhile(!que.empty())\n\t{\n\t\tint cur  = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < v[cur].size(); ++i)\n\t\t{\n\t\t\tif(mark[v[cur][i]] == true) {p[v[cur][i]] = v[cur][i];}\n\t\t\telse  p[v[cur][i]] = p[cur];\t\t \n\t\t\tque.push(v[cur][i]);\n\t\t\t// cout << v[cur][i] << endl;\n\t\t}\t\n\t}\n\treturn ;\n}\n\nint main( )\n{\n\tint  a, N, Q;\t\n\twhile ( cin >>  N >> Q  && N && Q) {\n\t\tmemset(mark,0,sizeof(mark));\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t{\n\t\t\t if(i == 1) { f[1] = 1; continue;}\n\t\t\t cin >> a;\n\t\t\t v[a].push_back(i);\n\t\t\t f[i] = a;\n\t\t}\n\t\tmark[1] = true;\n\t\tfor (int i = 1; i <= Q; ++i)\n\t\t{\n\t\t\t  cin >> query[i].first  >> query[i].second ;\n\t\t\t  if(query[i].first == 'M') mark[query[i].second] = true;\n\t\t}\n\t\t \n\t\tBfs();\n\t\t \n\t\tstack<int> ans ;\n\t\tfor (int i = Q; i >= 1; --i)\n\t\t{\n\t\t\t if(query[i].first == 'Q') { ans.push(parent(query[i].second)) ; continue;}\n\t\t\t mark[query[i].second] = false;\n\t\t\t p[query[i].second] = p[f[query[i].second]];\n\t\t\t for (int i = 0; i < v[query[i].second].size(); ++i) \n\t\t\t {\n\t\t\t \tp[v[query[i].second][i]] = p[f[query[i].second]];\n\t\t\t }\n\t\t}\n\t\tint num =0;\n\t\twhile(!ans.empty()) {\n\t \t\tnum += ans.top();\n\t \t    \tans.pop();\n\t\t}\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint t[100001],m[100001],N,Q,ans,j;\n\nvoid init(int n)\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tt[i]=i;\n\t\tm[i]=i==1?1:0;\n\t}\n}\n\nint p(int n)\n{\n\treturn m[n]?n:p(t[n]);\n}\n\nvoid u(int a,int b)\n{\n\tt[p(a)]=p(b);\n}\n\nint main()\n{\n\tchar Op;\n\tfor(;scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0;printf(\"%d\\n\",ans))\n\t{\n\t\tinit(N);\n\t\tfor(j=2;j<=N;j++)\n\t\t\tscanf(\"%d\",&t[j]);\n\t\tfor(ans=0,getchar();Q>0;getchar(),Q--)\n\t\t{\n\t\t\tscanf(\"%c%d\",&Op,&N);\n\t\t\tif(Op=='M')\n\t\t\t\tm[N]=1;\n\t\t\telse\n\t\t\t\tans+=p(N);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#define ti printf(\"YES\\n\");\ntypedef long long ll;\nconst int maxn=100005;\nconst int INF=0x3f3f3f3f;\nconst int mod=1e6;\n\nusing namespace std;\n\nint pre[maxn];\n\nint Find(int x)\n{\n    return x==pre[x]?x:Find(pre[x]);\n}\n\nint main()\n{\n    int n,m,x;\n    char s[2];\n    while(scanf(\"%d%d\",&n,&m)&&(n+m))\n    {\n        pre[1]=1;\n        for(int i=2; i<=n; i++)\n            scanf(\"%d\",&pre[i]);\n        int ans=0;\n        while(m--)\n        {\n            scanf(\"%s%d\",s,&x);\n            if(s[0]=='Q')\n                ans+=Find(pre[x]);\n            else\n                pre[x]=x;\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint P[100005],M[100005],v[100005],i,j,N,Q,t;\nlong long r;\nchar q[100005];\n\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)\n\t{\n\t\tfor(i=r=0;i<N;P[i]=i,M[i]=0,i++);\n\t\tM[1]=1;\n\t\tfor(i=2;i<=N;P[i]=t,i++)\n\t\t\tscanf(\"%d\\n\",&t);\n\t\tfor(i=0;i<Q;i++)\n\t\t{\n\t\t\tscanf(\"%c %d\\n\",&q[i],&v[i]);\n\t\t\tif(q[i]=='M')M[v[i]]++;\n\t\t}\n\t\tfor(i=Q-1;i>=0;i--)\n\t\t{\n\t\t\tif(q[i]=='M')\n\t\t\t\tM[v[i]]--;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(t=v[i];!M[t];)\n\t\t\t\t\tt=P[t];\n\t\t\t\tr+=t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 100000\n#define MAX_Q 100000\n\nint N;\nchar marked[MAX_N];\nint parent[MAX_N];\n\nint Q;\nchar qtype[MAX_Q];\nint qindex[MAX_Q];\n\nint par[MAX_N];\n\nvoid uf_init() {\n  int i;\n  for (i = 0; i < N; i++) par[i] = i;\n}\n\nint uf_find(int x) {\n  if (x == par[x]) return x;\n  else return par[x] = uf_find(par[x]);\n}\n\nvoid uf_unite(int x, int y) {\n  int rx = uf_find(x), ry = uf_find(y);\n  if (rx != ry) par[ry] = rx;\n}\n\nint main() {\n  int i;\n  for (;;) {\n    scanf(\"%d %d\", &N, &Q);\n    if (N == 0 && Q == 0) break;\n\n    for (i = 1; i < N; i++) {\n      int n; scanf(\"%d\", &n);\n      parent[i] = n-1;\n    }\n\n    memset(marked, 0, sizeof(marked));\n    marked[0] = 1;\n    \n    int qnum = 0;\n    for (i = 0; i < Q; i++) {\n      int n; char t[2]; scanf(\"%s %d\", t, &n);\n      if (!(t[0] == 'M' && marked[n-1] == 1)) {\n        if (t[0] == 'M') marked[n-1] = 1;\n        qtype[qnum] = t[0];\n        qindex[qnum] = n-1;\n        qnum++;\n      } \n    }\n    Q = qnum;\n\n    uf_init();\n    for (i = 0; i < N; i++) {\n      if (marked[i] == 0) uf_unite(parent[i], i);\n    }\n\n    long long ans = 0;\n    for (i = Q - 1; i >= 0; i--) {\n      if (qtype[i] == 'M') {\n        uf_unite(parent[qindex[i]], qindex[i]);\n      } else {\n        ans += uf_find(qindex[i]) + 1;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    //Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i ==0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(x < y){\n    par[y] = x;\n    rank[y] +=rank[x];\n  }else {\n    par[x] = y;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n    //Tree_print();\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n\n\n    for ( i= 0;  i < o; ++i) {\n      if(i ==0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(x < y){\n    par[y] = x;\n    rank[y] +=rank[x];\n  }else {\n    par[x] = y;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,ans ,current;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n    //Tree_print();\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n\n\n    for ( i= 0;  i < o; ++i) {\n      if(i ==0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 100000\nint par[MAX_N];\nint rank[MAX_N];\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return find(par[x]);\n    return par[x] = find(par[x]);\n  }\n}\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\n\nint main(){\n  int N,Q;\n  char s[16];\n  int i,d;\n  long long int res;\n  while(1){\n    if(!gets(s))break;\n    sscanf(s,\"%d %d\",&N,&Q);\n    if(N==0)break;\n    res=0;\n    init(N);\n    for(i=1;i<N;i++){\n      gets(s);\n      sscanf(s,\"%d\",&par[i]);\n      par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      gets(s);\n      sscanf(s+2,\"%d\",&d);\n      switch(s[0]){\n      case 'Q':\n        res+=find(d-1)+1;\n        break;\n      case 'M':\n        par[d-1]=d-1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2170\nTitle Marked Ancestor\n5/20 WA\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define NO_OF_NODES 100000\nint n,q;\nint node[NO_OF_NODES+1];\nint mark[NO_OF_NODES+1];\n//\nint nearest_marked_anscestor(int n)\n{\n  int a;\n  /*\n  if(mark[n])\n    return(n);\n  */\n  do {\n    a=node[n];\n#ifdef DEBUG\n    printf(\"A:%d <=%d\\n\",a,n);\n#endif\n    if(mark[a])\n      return(a);\n    n=a;\n\n  }while(a!=1);\n}\nvoid mark_node(int n)\n{\n  mark[n]=-1;\n#ifdef DEBUG\n  printf(\"M:%d\\n\",n);\n#endif\n}\nmain()\n{ \n  int i,r,sum,arg;\n  char op;\n\n  while(EOF!=scanf(\"%d %d\",&n,&q) && (n||q))\n    {\n      sum=0;\n      for(i=2;i<=n;i++)\n\tmark[i]=0;\n      mark[1]=1;\n      for(i=2;i<=n;i++)\n\t{\n\t  scanf(\"%d \",&node[i]);\n\t}\n      for(i=0;i<q;i++)\n\t{\n\t  scanf(\"%c %d\\n\",&op,&arg);\n\t  if(op=='M')\n\t    mark_node(arg);\n\t  else if(op=='Q')\n\t    {\n\t      r= nearest_marked_anscestor(arg);\n\t      sum += r;\n\t    }\n\t}\n     \n      printf(\"%d\\n\",sum);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint tree[100012];\nchar  mark[100012];\n\nint main(void)\n{\n    int n, q, t, i;\n    char ch;\n    unsigned long long sum;\n\n    while(scanf(\"%d%d\", &n, &q), n != 0 && q != 0) {\n        memset(mark, 0, sizeof(mark));\n        mark[1] = tree[1] = 1;\n        sum = 0;\n        for(i = 2; i <= n; ++i) scanf(\"%d\", tree + i);\n\n        for(i = 0; i < q; ++i) {\n            scanf(\" %c%d\", &ch, &t);\n\n            if(ch == 'M')\n                mark[t] = 1;\n            else {\n                for(; !mark[t]; t = tree[t])     ;\n\n                sum += t;\n            }\n        }\n        printf(\"%llu\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define maxn 100005\nint n,m;\nint f[maxn];\nchar vis[maxn];\nint _find(int x)\n{\n    if(vis[x])\n        return x;\n    else return _find(f[x]);\n}\nint main()\n{\n\n    \n    int i;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        if(!n&&!m)break;\n        long long sum=0;\n        for(i=1;i<=n;i++)\n        {\n            f[i]=i;\n        }\n        memset(vis,0,sizeof(vis));\n        vis[1]=1;\n        for(i=1;i<n;i++)\n        {\n            int ch;\n            scanf(\"%d\",&ch);\n            f[i+1]=ch;\n        }\n        for(i=1;i<=m;i++)\n        {\n            char ch[20];\n            scanf(\"%s\",ch);\n            if(ch[0]=='Q')\n            {\n                int t;\n                scanf(\"%d\",&t);\n縲??縲??縲??縲??縲??縲??for(; !vis[t]; t = f[t]) ;\n                sum+=t;\n            }\n            else\n            {\n                int t;\n                scanf(\"%d\",&t);\n                vis[t]=1;\n\n            }\n        }\n        printf(\"%lld\\n\",sum);\n\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    memset(temp,0, sizeof(temp));\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    //Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i == 0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            if(par[current]  == current ) break;\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%lld\\n\",ans);\n    //printf(\"%d %d\\n \",n,o);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q,ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<Q;i++){\n      marked_list[i]=0;\n    }marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      scanf(\"%c %d\\n\",&query_list[i][0],&query_list[i][1]);\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n\t\t\t\tif(marked_list[query_list[i][1]]==1){\n\t\t\t\t\tquery_list[i][0]='N';\n\t\t\t\t}\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2170: Marked Ancestor\n// 2018.1.2 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF 0x01010101\ntypedef struct { int i, v; } T;\nT tbl[100003]; int sz;\nint p[100003];\nint mk[100003];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n, c;\n\n//\twhile ((c = getchar_unlocked()) < '0');\n\tc = getchar_unlocked();\n\tn = 0;\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint find(int v, int i)\n{\n\tif (mk[v] < i) return v;\n\treturn p[v] = find(p[v], i);\n}\n\nint main()\n{\n\tint N, Q, i, cmd, v;\n\tlong long ans;\n\n\twhile (N = in()) {\n\t\tQ = in();\n\t\tp[1] = 1; for (i = 2; i <= N; i++) p[i] = in();\n\n\t\tmemset(mk, INF, sizeof(mk));\n\t\tmk[1] = 0;\n\n\t\tsz = 0;\n\t\tfor (i = 1; i <= Q; i++) {\n\t\t\tcmd = getchar_unlocked(); getchar_unlocked();\n\t\t\tv = in();\n\t\t\tif (cmd == 'M') { if (mk[v] == INF) mk[v] = i; }\n\t\t\telse tbl[sz].i = i, tbl[sz++].v = v;\n\t\t}\n\n\t\tans = 0;\n\t\twhile (sz--) ans += find(tbl[sz].v, tbl[sz].i);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 100001\nint par[MAX_N];\nint rank[MAX_N];\n\nstruct operate{char op;int num;};\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint M_find(int x,int mark[]){\n\tif(mark[x]==1){\n\t\treturn x;\n\t}else{\n\t\treturn M_find(par[x],mark);\n\t}\n}\n\nvoid make_tree(int x,int y){\n\tif(x==y){\n\t\treturn ;\n\t}\n\telse par[x]=y;\n}\n\nint main(){\n\tint i,n,num_q,p_node;\n\tint mark[MAX_N];\n\tstruct operate ope;\n\tlong long int sum=0;\n\n\tscanf(\"%d %d\",&n,&num_q);\n\tinit(MAX_N);\n\n\tfor(i=2;i<=n;i++){\n\t\tmark[i]=0;\n\t\tscanf(\"%d\",&p_node);\n\t\tmake_tree(i,p_node);\n\t}\n\tgetchar();\n\tmark[1]=1; i=0;\n\tfor(i=0;i<=num_q;i++){\n\t\tscanf(\"%c %d\",&ope.op,&ope.num);\n\t\tgetchar();\n\t\tif(ope.op=='Q')sum+=M_find(ope.num,mark);\n\t\tif(ope.op=='M')mark[ope.num]=1;\n\t}\n\tfor(i=0;i<=n;i++)printf(\"%d %d\\n\",par[i],mark[i]);\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint tree[100012];\nchar  mark[100012];\n\nint main()\n{\n    int n, q, sum, t, i;\n    char ch;\n\n    while(scanf(\"%d%d\", &n, &q), n != 0 && q != 0) {\n        memset(mark, 0, sizeof(mark));\n        mark[1] = tree[1] = 1;\n        sum = 0;\n        for(i = 2; i <= n; ++i) scanf(\"%d\", tree + i);\n\n        for(i = 0; i < q; ++i) {\n            scanf(\" %c%d\", &ch, &t);\n\n            if(ch == 'M')\n                mark[t] = 1;\n            else {\n                for(; !mark[t]; t = tree[t])     ;\n\n                sum += t;\n            }\n        }\n        printf(\"%d\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint P[100005],M[100005],v,i,j,N,Q,t;\nlong long r;\nchar q;\n\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)\n\t{\n\t\tfor(i=r=0;i<N;P[i]=i,M[i]=0,i++);\n\t\tM[1]=1;\n\t\tfor(i=2;i<=N;P[i]=t,i++)scanf(\"%d\\n\",&t);\n\t\tfor(i=0;i<Q;i++)\n\t\t{\n\t\t\tscanf(\"%c %d\\n\",&q,&v);\n\t\t\tif(q=='M')M[v]++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(t=v;!M[t];t=P[t]);\n\t\t\t\tr+=t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define N 1001\n\nint par[N];\nint rank[N];\n\nstruct state{\n  int x;\n  int y;\n  int check;\n};\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\n//2??????????????¢????±???????\ndouble distance(int x1,int x2,int y1,int y2){\n  return ((x1-x2)*(x1-x2))+((y1-y2)*(y1-y2));\n}\n\nint main(){\n  //???????????????????????\\??????????????????????????????????????¢d??\\?????????????????\\???????????¨?????????\n  int n,d;\n  int i,count;\n  int n1,n2;\n  struct state s[N];  \n  char c;\n  \n  scanf(\"%d%d\",&n,&d);\n\n  init(n);\n\n  for(i=1;i<=n;i++){\n    scanf(\"%d%d\",&s[i].x,&s[i].y);\n    s[i].check=0;\n  }\n  count=0;\n  while(scanf(\"%c\",&c)!=EOF){\n    if(c=='O'){\n      scanf(\"%d\",&n1);\n      s[n1].check=1;//??????????????°\n      for(i=1;i<=n;i++){\n\tif(s[i].check==1&&n1!=i&&distance(s[i].x,s[n1].x,s[i].y,s[n1].y)<=d*d){\n\t  unite(i,n1);\n\t}\n      \n      }\n  }else if(c=='S'){\n      scanf(\"%d%d\",&n1,&n2);\n      if(same(n1,n2))printf(\"SUCCESS\\n\");\n      else printf(\"FAIL\\n\");\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2170\nTitle Marked Ancestor\n5/20 WA\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define NO_OF_NODES 100000\nint n,q;\nint node[NO_OF_NODES+1];\nint mark[NO_OF_NODES+1];\n//\nint nearest_marked_anscestor(int n)\n{\n  int a;\n  if(mark[n])\n    return(n);\n  do {\n    a=node[n];\n#ifdef DEBUG\n    printf(\"A:%d <=%d\\n\",a,n);\n#endif\n    if(mark[a])\n      return(a);\n    n=a;\n\n  }while(a!=1);\n}\nvoid mark_node(int n)\n{\n  mark[n]=-1;\n#ifdef DEBUG\n  printf(\"M:%d\\n\",n);\n#endif\n}\nmain()\n{ \n  int i,r,sum,arg;\n  char op;\n\n  while(EOF!=scanf(\"%d %d\",&n,&q) && (n||q))\n    {\n      sum=0;\n      for(i=2;i<=n;i++)\n\tmark[i]=0;\n      mark[1]=1;\n      for(i=2;i<=n;i++)\n\t{\n\t  scanf(\"%d \",&node[i]);\n\t}\n      for(i=0;i<q;i++)\n\t{\n\t  scanf(\"%c %d\\n\",&op,&arg);\n\t  if(op=='M')\n\t    mark_node(arg);\n\t  else if(op=='Q')\n\t    {\n\t      r= nearest_marked_anscestor(arg);\n\t      sum += r;\n\t    }\n\t}\n     \n      printf(\"%d\\n\",sum);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100002\nint par[MAX_N];\nint rank[MAX_N];\nint n,o,temp[MAX_N];\n\nstruct  node {\n   int parent,mark;\n} ;\nstruct node p[MAX_N];\n\n\nvoid node_init(int n){\n  int i;\n  for (i = 0; i <= n; ++i) {\n    p[i].parent = temp[i];\n    if (i == 1) p[i].mark = 1;\n    else p[i].mark = 0;\n  }\n}\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n\n    par[y] = x;\n\n}\n\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\nvoid Tree_print(){\n  int i;\n  for (i = 1 ;i <= n;i++) printf(\"%d\",par[i]);\n  printf(\"\\n\");\n}\n\nint main() {\n  int i,ob,current;\n  long long int ans;\n  char str[16],op;\n\n  while(1){\n    ans = 0;\n    scanf(\"%d %d\",&n,&o);\n    //printf(\"%d %d\\n\",n,o);\n    if( n == 0 && o == 0) break;\n    init(n+1);\n\n    for (i = 2; i <= n; ++i) {\n      scanf(\"%d\",&temp[i]);\n      //printf(\"%d get\\n\",i);\n    }\n\n    node_init(n);\n\n    for (i = n; i > 1 ; --i) {\n      unite(p[i].parent,i);\n      //Tree_print();\n    }\n    //Tree_print();\n\n    for ( i= 0;  i < o; ++i) {\n      if(i == 0 )getchar();\n      fgets(str,16,stdin);\n      sscanf(str,\"%c %d\",&op,&ob);\n      //printf(\"%c %d\\n\",op,ob);\n      if (op == 'M'){\n        p[ob].mark = 1;\n      }\n      else{\n        if (p[ob].mark == 1) ans += ob;\n        else{\n          current = par[ob];\n          //printf(\"%d\\n\",current);\n          while(p[current].mark != 1){\n            if(par[current]  == current ) break;\n            current =par[current];\n          }\n          ans+= current;\n\n        }\n      }\n    }\n    printf(\"%lld\\n\",ans);\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\ntypedef long long ll;\nint pre[1000000];\nint finds(int x)\n{\n    return x == pre[x] ? x : finds(pre[x]);//注意与 pre[x] = finds(pre[x]);的区别。\n}\nint main()\n{\n    int Q, N;\n    while (~scanf(\"%d%d\", &Q, &N) && Q && N) {\n        pre[1] = 1;\n        for (int i = 2; i <= Q; i++) {\n            scanf(\"%d\", &pre[i]);\n        }\n        ll ans = 0;\n        for (int i = 0; i < N; i++) {\n            char c;\n            int x;\n            scanf(\" %c%d\", &c, &x);\n            if (c == 'Q') ans += finds(x);\n            else pre[x] = x;\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string>\n#include<cstring>\nusing namespace std;\nconst int num = 1e5+1;\nint n,q,ask[num][2],time[num]={},askl=0;\nint father[num];\nbool mark[num]={};\nlong long getF(int t)\n{\n    if(mark[t]&&time[t]<=ask[askl][1])\n        return (long long)t;\n    return (long long)(father[t]=getF(father[t]));\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&q);\n    char c;\n    int x,i,j,fax,t;\n    long long ans=0;\n    for(i=2;i<=n;++i)\n        scanf(\"%d\",&father[i]);\n    getchar();\n    bool flag=false;\n    time[1]=0;\n    mark[1]=true;\n    while(scanf(\"%c\",&c)&&c!='0'){\n        scanf(\"%d\",&x);\n        if(c=='M'){\n            if(!flag){\n                ++t;\n                flag=true;\n            }\n            mark[x]=true;\n            time[x]=t;\n        }\n        else{\n            flag=false;\n            ++askl;\n            ask[askl][0]=x;\n            ask[askl][1]=t;\n        }\n        getchar();\n    }\n    while(askl>0){\n        ans+=getF(ask[askl][0]);\n        --askl;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 100000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q,ans;\n  int i,j,k;\n  int markd_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<Q;i++){\n      markd_list[i]=0;\n    }markd_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      scanf(\"%c %d\\n\",&query_list[i][0],&query_list[i][1]);\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n        markd_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==markd_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      }else{\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define N 100004\nint tree[N];\nchar  mark[N];\nint _find(int x)\n{\n    if(mark[x])\n        return x;\n    else return _find(tree[x]);\n}\n\nint main(void)\n{\n    int n, q, i;\n   long long sum;\n\n     while(scanf(\"%d%d\",&n,&q)!=EOF)\n    {\n        if(!n&&!q)break;\n        memset(mark, 0, sizeof(mark));\n        for(i=1;i<=n;i++)\n        {\n            tree[i]=i;\n        }\n        mark[1] = tree[1] = 1;\n        sum = 0;\n        for(i = 2; i <= n; ++i)\n            scanf(\"%d\", &tree[i]);\n\n         for(i=1;i<=q;i++)\n        {\n            char ch[20];\n            scanf(\"%s\",ch);\n             int t;\n            scanf(\"%d\",&t);\n            if(ch[0]=='Q')\n            {\n                sum += _find(t);\n            }\n            else\n                mark[t] = 1;\n        }\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n\n    memset(marked_list,0,sizeof(int)*N);\n    marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n        if(marked_list[query_list[i][1]]==1){\n          query_list[i][0]='N';\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define maxn 100005\nint f[maxn];\nchar  vis[maxn];\nint n, q;\nint _find(int x)\n{\n    if(vis[x])\n        return x;\n    else return _find(f[x]);\n}\n\nint main()\n{\n    int i;\n  \n\n     while(scanf(\"%d%d\",&n,&q)!=EOF)\n    {\n         long long sum;\n        if(!n&&!q)break;\n        memset(vis, 0, sizeof(vis));\n        for(i=1;i<=n;i++)\n        {\n            f[i]=i;\n        }\n        vis[1] = 1;\n        sum = 0;\n        for(i = 1; i < n; ++i)\n            scanf(\"%d\", &f[i +  1]);\n\n         for(i=1;i<=q;i++)\n        {\n            char ch[20];\n            scanf(\"%s\",ch);\n             int t;\n            scanf(\"%d\",&t);\n            if(ch[0]=='Q')\n            {\n                sum += _find(t);\n            }\n            else\n                vis[t] = 1;\n        }\n        printf(\"%lld\\n\", sum);\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint P[100005],M[100005],v[100005],i,j,N,Q,t;\nlong long r;\nchar q[100005];\nint p(int n)\n{\n\treturn P[n]==n?n:p(P[n]);\n}\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)\n\t{\n\t\tfor(i=r=0;i<N;P[i]=i,M[i]=0,i++);\n\t\tM[1]=1;\n\t\tfor(i=2;i<=N;P[i]=t,i++)\n\t\t\tscanf(\"%d\\n\",&t);\n\t\tfor(i=0;i<Q;i++)\n\t\t\tscanf(\"%c %d\\n\",&q[i],&v[i]);\n\t\tfor(i=Q-1;i>=0;i--)\n\t\t{\n\t\t\tif(q[i]=='M')\n\t\t\t\tM[v[i]]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(;!M[v[i]];v[i]=P[v[i]]);\n\t\t\t\tr+=v[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct q\n{\n\tchar Op;\n\tint n;\n}q;\n\nint t[100001],pa[100001],N,Q,ans,j;\nq query[100001];\nvoid i(int n)\n{\n\tint i;\n\tfor(j=0;j<=n;j++)\n\t\tt[j]=j;\n}\n\nint p(int n)\n{\n\tif(t[n]==n)\n\t\treturn n;\n\telse\n\t\treturn t[n]=p(t[n]);\n}\n\nvoid u(int a,int b)\n{\n\tt[p(a)]=p(b);\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0)\n\t{\n\t\tans=0;\n\t\tfor(i(N),j=2;j<=N;j++)\n\t\t{\n\t\t\tscanf(\"%d\\n\",&pa[j]);\n\t\t\tt[j]=pa[j];\n\t\t}\n\t\tfor(j=0;j<Q;j++)\n\t\t{\n\t\t\tscanf(\"%c%d\\n\",&query[j].Op,&query[j].n);\n\t\t\tif(query[j].Op=='M')\n\t\t\t\tt[query[j].n]=query[j].n;\n\t\t}\n\t\tfor(j=Q-1;j>=0;j--)\n\t\t{\n\t\t\tif(query[j].Op=='M')\n\t\t\t\tu(query[j].n,pa[query[j].n]);\n\t\t\telse\n\t\t\t\tans+=p(query[j].n);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct q\n{\n\tchar Op;\n\tint n;\n}q;\n\nint t[100001],pa[100001],mark[100001],N,Q,ans,j;\nq query[100001];\nvoid i(int n)\n{\n\tfor(j=0;j<=n;j++)\n\t{\n\t\tt[j]=j;\n\t\tpa[j]=mark[j]=0;\n\t}\n\tpa[1]=mark[1]=1;\n}\n\nint p(int n)\n{\n\tif(t[n]==n)\n\t\treturn n;\n\telse\n\t\treturn t[n]=p(t[n]);\n}\n\nvoid u(int a,int b)\n{\n\tt[p(a)]=p(b);\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0)\n\t{\n\t\tans=0;\n\t\tfor(i(N),j=0;j<N;j++)\n\t\t\tscanf(\"%d\\n\",&pa[j+2]);\n\t\tfor(j=0;j<Q;j++)\n\t\t{\n\t\t\tscanf(\"%c%d\\n\",&query[j].Op,&query[j].n);\n\t\t\tif(query[j].Op=='M')\n\t\t\t{\n\t\t\t\tif(mark[query[j].n])\n\t\t\t\t\tquery[j].Op='X';\n\t\t\t\telse\n\t\t\t\t\tmark[query[j].n]=1;\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=N;j++)\n\t\t\tif(!mark[j])\n\t\t\t\tu(j,pa[j]);\n\t\tfor(j=Q-1;j>=0;j--)\n\t\t{\n\t\t\tif(query[j].Op=='M')\n\t\t\t\tu(query[j].n,pa[query[j].n]);\n\t\t\telse if(query[j].Op=='Q')\n\t\t\t\tans+=p(query[j].n);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXN 100010\nint par[MAXN];\nint mark[MAXN];\nvoid init(int N){\n\tint i;\n\tpar[1]=1;\n\tfor(i=2;i<=N;i++){\n\t\tscanf(\"%d\",&par[i]);\n\t\tmark[i]=0;\n\t}\n\tmark[1]=1;\n}\nint query(int i){\n\twhile(par[i]!=i){\n\t\tif(mark[i])\n\t\t\tbreak;\n\t\ti=par[i];\n\t}\n\tif(mark[i])\n\t\treturn i;\n\telse\n\t\treturn 0;\n}\nint main(){\n\tint N,Q;\n\tchar x;\n\tint y;\n\tint sum;\n\twhile(~scanf(\"%d%d\",&N,&Q)){\n\t\tif(N==0&&Q==0){\n\t\t\tbreak;\n\t\t}\n\t\tinit(N);\n\t\tsum=0;\n\t\twhile(Q--){\n\t\t\tscanf(\"\\n%c%d\",&x,&y);\n\t\t\tif(x=='M'){\n\t\t\t\tmark[y]=1;\t\n\t\t\t}\n\t\t\telse if(x=='Q'){\n\t\t\t\tsum+=query(y);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint t[100001],m[100001],N,Q,ans,j;\n\nvoid init(int n)\n{\n\tint i;\n\tfor(i=0;i<=n;i++)\n\t\tm[i]=i==1?1:0;\n}\n\nint p(int n)\n{\n\treturn m[n]?n:p(t[n]);\n}\n\nint main()\n{\n\tchar Op;\n\tfor(;scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0;printf(\"%d\\n\",ans))\n\t{\n\t\tinit(N);\n\t\tfor(j=1;j<=N;j++)\n\t\t\tscanf(\"%d\",&t[j+1]);\n\t\tfor(ans=0,getchar();Q>0;getchar(),Q--)\n\t\t{\n\t\t\tscanf(\"%c%d\",&Op,&N);\n\t\t\tif(Op=='M')\n\t\t\t\tm[N]=1;\n\t\t\telse\n\t\t\t\tans+=p(N);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint A[100010],B[100010];\nint n,q,i,j;\nint Find(int a)\n{    \n\tif(B[a]==1)\n\treturn a;\n\telse return Find(A[a]);\n}\nint main(){\n\twhile(scanf(\"%d%d\",&n,&q)&&(n!=0||q!=0))\n\t{\n\t\tmemset(B,0,sizeof(B));\n\t\tlong long int sum=0;\n\t\tB[1]=1;\n\t\tfor(i=2;i<=n;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\tA[i]=a;\n\t\t}\t\n\t\tchar ss[5];\n\t\twhile(q--)\n\t\t{\n\t\t\tscanf(\"%s\",ss);\n\t\t\tif(ss[0]=='Q')\n\t\t\t{\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tsum+=(long long)Find(b);\n\t\t\t}\n\t\t\telse if(ss[0]=='M')\n\t\t\t{\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tB[b]=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",sum);\n\t}\n\t\n}\n\n"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cmath>\n#include <queue>\n#include <vector>\n#define SIZE 100010\n\ntypedef struct Node\n{\n\tint father;\n\tint ancester;\n\tstd::vector<int> childs;\n} Node;\n\nNode node[SIZE];\n\nvoid mark(int num)\n{\n\tstd::queue<int> q;\n\tq.push(num);\n\twhile (!q.empty())\n\t{\n\t\tint n = q.front();\n\t\tq.pop();\n\t\tif (node[n].ancester == n)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tnode[n].ancester = num;\n\t\tfor (std::vector<int>::iterator it = node[n].childs.begin(); it != node[n].childs.end(); ++it)\n\t\t{\n\t\t\tq.push(*it);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint count, order_count;\n\twhile (scanf(\"%d%d\", &count, &order_count), !(count == 0 && order_count == 0))\n\t{\n\t\tint sum = 0;\n\t\tint father;\n\t\tfor (int i = 1; i <= count; ++i)\n\t\t{\n\t\t\tscanf(\"%d\", &father);\n\t\t\tnode[i].father = father;\n\t\t\tnode[i].ancester = 1;\n\t\t\tnode[father].childs.push_back(i);\n\t\t\tnode[i].childs.clear();\n\t\t}\n\t\tchar ch;\n\t\tint num;\n\t\twhile (order_count--)\n\t\t{\n\t\t\tscanf(\"%c %d\", &ch, &num);\n\t\t\tgetchar();\n\t\t\tif (ch == 'Q')\n\t\t\t{\n\t\t\t\tsum += node[num].ancester;\n\t\t\t}\n\t\t\telse if (ch == 'M')\n\t\t\t{\n\t\t\t\tmark(num);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n // x =find(x);\n//  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<N;i++){\n      marked_list[i]=0;\n    }marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n\t\t\t\tif(marked_list[query_list[i][1]]==1){\n\t\t\t\t\tquery_list[i][0]='N';\n\t\t\t\t}\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 100001\nint par[MAX_N];\nint rank[MAX_N];\n\nstruct operate{char op;int num;};\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\n//x????????????????????????????????????????\\?????????¢???\nint M_find(int x,int mark[]){\n\tif(mark[x]==1){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = M_find(par[x],mark);\n\t}\n}\n\nvoid make_tree(int x,int y){\n\tif(x==y){\n\t\treturn ;\n\t}\n\telse par[x]=y;\n}\n\nint main(){\n\n\t//??????:?????¨?????????????????????????????????????????°???????????§??????\n\tint i,n,num_q,p_node;\n\tint mark[MAX_N];\n\tstruct operate ope;\n\tlong long int sum=0;\n\n\tscanf(\"%d %d\",&n,&num_q);\n\tinit(MAX_N);\n\n\tfor(i=2;i<=n;i++){\n\t\tmark[i]=0;\n\t\tscanf(\"%d\",&p_node);\n\t\tmake_tree(i,p_node);\n\t}\n\n\tmark[1]=1; i=0;\n\tfor(i=0;i<=num_q;i++){\n\t\tscanf(\"%c %d\",&ope.op,&ope.num);\n\t\tgetchar();\n\t\tif(ope.op=='Q')sum+=M_find(ope.num,mark);\n\t\tif(ope.op=='M')mark[ope.num]=1;\n\t}\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "P[100005],M[100005],v[100005],i,j,N,Q,t;long long r;char q[100005];\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&Q),N;)\n\t{\n\t\tfor(i=r=0;i<N;P[i]=i,M[i]=0,i++);\n\t\tM[1]=1;\n\t\tfor(i=2;i<=N;P[i]=t,i++)scanf(\"%d\\n\",&t);\n\t\tfor(i=0;i<Q;i++)\n\t\t{\n\t\t\tscanf(\"%c %d\\n\",&q[i],&v[i]);\n\t\t\tif(q[i]=='M')M[v[i]]++;\n\t\t}\n\t\tfor(i=Q-1;i>=0;i--)\n\t\t{\n\t\t\tif(q[i]=='M')M[v[i]]--;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(t=v[i];!M[t];t=P[t]);\n\t\t\t\tr+=t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2170: Marked Ancestor\n// 2018.1.2 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF 0x01010101\ntypedef struct { int i, v; } T;\nT tbl[100003]; int sz;\nint p[100003];\nint mk[100003];\n\n#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n, c;\n\n\twhile ((c = getchar_unlocked()) < '0');\n\tn = 0;\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint find(int v, int i)\n{\n\tif (mk[v] < i) return v;\n\treturn p[v] = find(p[v], i);\n}\n\nint main()\n{\n\tint N, Q, i, cmd, v;\n\tlong long ans;\n\n\twhile (N = in()) {\n\t\tQ = in();\n\t\tp[1] = 1; for (i = 2; i <= N; i++) p[i] = in();\n\n\t\tmemset(mk, INF, sizeof(mk));\n\t\tmk[1] = 0;\n\n\t\tsz = 0;\n\t\tfor (i = 1; i <= Q; i++) {\n\t\t\tif ((cmd = getchar_unlocked()) < ' ') cmd = getchar_unlocked();\n\t\t\tv = in();\n\t\t\tif (cmd == 'M') { if (mk[v] == INF) mk[v] = i; }\n\t\t\telse tbl[sz].i = i, tbl[sz++].v = v;\n\t\t}\n\n\t\tans = 0;\n\t\twhile (sz--) ans += find(tbl[sz].v, tbl[sz].i);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXN 100010\nint par[MAXN];\nint mark[MAXN];\nvoid init(int N){\n\tint i;\n\tpar[1]=1;\n\tfor(i=2;i<=N;i++){\n\t\tscanf(\"%d\",&par[i]);\n\t\tmark[i]=0;\n\t}\n\tmark[1]=1;\n}\nint query(int i){\n\twhile(par[i]!=i){\n\t\ti=par[i];\n\t\tif(mark[i])\n\t\t\tbreak;\n\t}\n\tif(mark[i])\n\t\treturn i;\n\telse\n\t\treturn 0;\n}\nint main(){\n\tint N,Q;\n\tchar x;\n\tint y;\n\tint sum;\n\twhile(~scanf(\"%d%d\",&N,&Q)){\n\t\tif(N==0&&Q==0){\n\t\t\tbreak;\n\t\t}\n\t\tinit(N);\n\t\tsum=0;\n\t\twhile(Q--){\n\t\t\tscanf(\"\\n%c%d\",&x,&y);\n\t\t\tif(x=='M'){\n\t\t\t\tmark[y]=1;\t\n\t\t\t}\n\t\t\telse if(x=='Q'){\n\t\t\t\tsum+=query(y);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<N;i++){\n      marked_list[i]=0;\n    }marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n\t\t\t\tif(marked_list[query_list[i][1]]==1){\n\t\t\t\t\tquery_list[i][0]='N';\n\t\t\t\t}\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct q\n{\n\tchar Op;\n\tint n;\n}q;\n\nint t[100001],pa[100001],mark[100001],N,Q,ans,j;\nq query[100001];\nvoid i(int n)\n{\n\tfor(j=0;j<=n;j++)\n\t{\n\t\tt[j]=j;\n\t\tpa[j]=mark[j]=0;\n\t}\n\tpa[1]=mark[1]=1;\n}\n\nint p(int n)\n{\n\tif(t[n]==n)\n\t\treturn n;\n\telse\n\t\treturn t[n]=p(t[n]);\n}\n\nvoid u(int a,int b)\n{\n\tt[p(a)]=p(b);\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&N,&Q)&&N!=0&&Q!=0)\n\t{\n\t\tans=0;\n\t\tfor(i(N),j=2;j<=N;j++)\n\t\t\tscanf(\"%d\\n\",&pa[j]);\n\t\tfor(j=0;j<Q;j++)\n\t\t{\n\t\t\tscanf(\"%c%d\\n\",&query[j].Op,&query[j].n);\n\t\t\tif(query[j].Op=='M')\n\t\t\t{\n\t\t\t\tif(mark[query[j].n])\n\t\t\t\t\tquery[j].Op='X';\n\t\t\t\telse\n\t\t\t\t\tmark[query[j].n]=1;\n\t\t\t}\n\t\t}\n\t\tfor(j=1;j<=N;j++)\n\t\t\tif(!mark[j])\n\t\t\t\tu(j,pa[j]);\n\t\tfor(j=Q-1;j>=0;j--)\n\t\t{\n\t\t\tif(query[j].Op=='M')\n\t\t\t\tu(query[j].n,pa[query[j].n]);\n\t\t\telse if(query[j].Op=='Q')\n\t\t\t\tans+=p(query[j].n);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\nint n,q,f[100005],ans;\nbool mkd[100005];\nchar c[5],d;\nint main()\n{\n\tint i,a;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&n,&q);\n\t\tif(!n) break;\n\t\tmemset(mkd,0,sizeof(mkd));ans=0;\n\t\tmkd[1]=true;\n\t\tfor(i=2;i<=n;i++) scanf(\"%d\",&f[i]);\n\t\tfor(i=1;i<=q;i++)\n\t\t{\n\t\t\tscanf(\"%s\",c);d=c[0];\n\t\t\tscanf(\"%d\",&a);\n\t\t\tif(d=='M') mkd[a]=true;\n\t\t\tif(d=='Q')\n\t\t\t{\n\t\t\t\tfor(;!mkd[a];a=f[a]);\n\t\t\t\tans+=a;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX_N 200000\nint par[MAX_N];\nint original_par[MAX_N];\nint rank[MAX_N];\nint query_list[MAX_N][2];\n\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  par[y] = x;\n  /*\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n  */\n}\nint same(int x,int y){\n  return find(x)==find(y);\n}\nint main(){\n  int N,Q;\n  long long int ans;\n  int i,j,k;\n  int marked_list[MAX_N];\n  puts(\"hoge\");\n//??¨??¨????????§?????????????????§1?????¬???\n  while(1){\n    scanf(\"%d %d\",&N,&Q);\n    if(N==0&&Q==0)break;\n    for(i=0;i<N;i++){\n      marked_list[i]=0;\n    }marked_list[0]=1;\n    original_par[0]=0;\n    ans=0;\n\n    for(i=1;i<N;i++){\n      scanf(\"%d\\n\",&original_par[i]);\n      original_par[i]--;\n    }\n    for(i=0;i<Q;i++){\n      char bc;\n      scanf(\"%c %d\\n\",&bc,&query_list[i][1]);\n      query_list[i][0] = bc;\n      query_list[i][1]--;\n    }\n\n    init(N);\n    for(i=0;i<Q;i++){\n      if(query_list[i][0]=='M'){\n\t\t\t\tif(marked_list[query_list[i][1]]==1){\n\t\t\t\t\tquery_list[i][0]='N';\n\t\t\t\t}\n        marked_list[query_list[i][1]]=1;\n      }\n    }\n    for(i=0;i<N;i++){\n      if(0==marked_list[i]){\n        unite(original_par[i],i);\n      }\n    }\n    for(i=Q-1;i>=0;i--){\n      if(query_list[i][0]=='Q'){\n        int q_a = find(query_list[i][1])+1;\n        ans += q_a;\n      //  printf(\":%d\\n\",ans);\n      }else if(query_list[i][0]=='M'){\n        int m = query_list[i][1];\n        unite(original_par[m],m);\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] parent = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tparent[0] = 0;\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = parent[i + 1] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tif (IN.next().charAt(0) == 'Q') {\n\t\t\t\t\t\n\t\t\t\t\tisQuery[i] = true;\n\t\t\t\t}\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif (!isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tparent[v[i]] = v[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinitialize();\n\t\t\t\n\t\t\tint summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += find(v[i]) + 1;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tprivate final int[] rank = new int[MAX_N];\n\t\n\tprivate void initialize() {\n\t\t\n\t\tArrays.fill(rank, 0);\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\n\t\t\tinitialize(i, 0);\n\t\t}\n\t}\n\t\n\tprivate void initialize(int i, int r) {\n\t\t\n\t\tif (i == parent[i]) {\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ti = parent[i];\n\t\tr ++;\n\t\tif (rank[i] < r) {\n\t\t\t\n\t\t\trank[i] = r;\n\t\t\tinitialize(i,r);\n\t\t}\n\t}\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] == x) {\n\t\t\t\n\t\t\treturn x;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\ty = find(y);\n\t\t\n\t\tif (rank[x] < rank[y]) {\n\t\t\t\n\t\t\tparent[x] = y;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tparent[y] = x;\n\t\t\t\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\n\t\t\t\trank[x] ++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 1024L * 1024 * 48).start();\n\t}\n\t\n\tpublic void run() {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tint n;\n\tint q;\n\tint[] parent;\n\tArrayList<Integer>[] child;\n\tboolean[] marked;\n\tint[] ma;\n\tArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tmarked = new boolean[n];\n\t\tmarked[0] = true;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tmarked[qVal[i]] = true;\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tUnionFind uf = new UnionFind(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.union(ma[i], i);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tif (parent[qVal[i]] >= 0) {\n\t\t\t\t\tuf.union(parent[qVal[i]], qVal[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic void dfs(int v) {\n\t\tif (marked[v]) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (marked[v]) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind {\n\tprivate int[] parent;\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tparent = new int[size];\n\t\tdata = new int[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tdata[i] = i;\n\t\t}\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tint nData = data[x];\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] = nData;\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic int get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(parent);\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n//\t\tif (a.val > b.val)\n\t\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n//\t\t\tdebug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tdebug(vs[i].id);\n//\t\t\tfor (V v : vs[i]) {\n//\t\t\t\tdebug(\"\\t\", v.id);\n//\t\t\t}\n//\t\t\tdebug(vs[i].markedTime);\n//\t\t\tdebug(vs[i].askedTimes);\n//\t\t}\n//\t\tdebug(\"aaaaaaaaaaaaa\");\n\t\t\n\t\t\n\t\t\n\t\t\t// vが答えになる\n//\t\t\tfor (int t : v.askedTimes) {\n//\t\t\t\th = meld(h, new Heap(t));\n//\t\t\t}\n//\t\t\tfor (V u : v) {\n//\t\t\t\th = meld(h, rec(u));\n//\t\t\t}\n//\t\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n//\t\t\t\tans += v.id;\n////\t\t\t\tdebug(\"vid\",v.id);\n//\t\t\t}\n//\t\t\treturn h;\n\t\t\n\t\tStack<V>stackV=new Stack<V>();\n\t\tStack<Integer>stackS=new Stack<Integer>();\n\t\t\n\t\tstackV.push(vs[0]);\n\t\tstackS.push(0);\n\t\t\n\t\tfor(;!stackV.isEmpty();){\n\t\t\tV v=stackV.pop();\n\t\t\tint state=stackS.pop();\n//\t\t\tdebug(v.id, \"state\",state);\n\t\t\tif(state==0){\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tstackS.push(1);\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n\t\t\t\t\tstackS.push(0);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h=meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n//\t\t\t\t\tdebug(\"vid\",v.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n//\t\trec(vs[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2170.Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tstatic class Union{\n\t\tint[] id;\n\t\tint[] sz;\n\t\t\n\t\tpublic Union(int size){\n\t\t\tid = new int[size];\n\t\t\tsz = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i){\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int i){\n\t\t\twhile(id[i] != i){\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\tpublic boolean same(int i, int j){\n\t\t\treturn find(i) == find(j);\n\t\t}\n\t\t\n\t\tpublic void union(int i, int j){\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\t\n\t\t\tif (p == q) return;\n\t\t\t\n\t\t\tif (sz[p] < sz[q]){\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[q];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true){\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\t\n\t\t\tint[] id = new int[N];\n\t\t\tfor (int i = 1; i < N; ++i){\n\t\t\t\tint p = in.nextInt() - 1;\n\t\t\t\tid[i] = p;\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 0; i < Q; ++i){\n\t\t\t\tString opera = in.next();\n\t\t\t\tint c = in.nextInt() - 1;\n\t\t\t\tif (opera.equals(\"Q\")){\n\t\t\t\t\twhile (c != id[c]){\n\t\t\t\t\t\tc = id[c];\n\t\t\t\t\t}\n\t\t\t\t\tsum += (c + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tid[c] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static IO io = new IO();\n    static int p[] = new int[100001];   // p[i]: parent of i-th node\n    static char ope[] = new char[100001];\n    static int v[] = new int[100001];\n    public static void main(String[] args) {\n\n        while (true) {\n\n            int n = io.nextInt();\n            int q = io.nextInt();\n            if (n==0 && q==0) break;\n            p = io.arrayInt(n-1);\n            UnionFind uni = new UnionFind(n);\n            int ans = 0;\n            for (int i=0; i<q; i++) {\n                ope[i] = io.nextChar();\n                v[i] = io.nextInt();\n                if (ope[i]=='M') {\n                    uni.mark(v[i]);\n                    //System.out.println(v[i] + \"?????????????????????\");\n                } else {\n                    ans += uni.find(v[i]);\n                }\n            }\n            System.out.println(ans);\n            //System.out.println(\"ope: \" + Arrays.toString(ope));\n            //System.out.println(\"v: \" + Arrays.toString(v));\n\n        }\n\n    }\n\n    static class UnionFind {\n        int par[];\t// i??????(parent)\n        int rank[];\t// i?????±???\n        boolean mark[]; // i??????????????????????????????\n\n        // ????????????????????? n????´???§?????????\n        UnionFind(int n) {\n            par = new int[n+1];\n            rank = new int[n+1];\n            mark = new boolean[n+1];\n            mark[1] = true;\n            par[1] = 1;\n            for (int i=2; i<=n; i++) par[i]=p[i-2];\n        }\n\n        // ??¨??????????±???????\n        int find(int x) {\n            if (par[x] == x || mark[x]) return x;\n            //System.out.println(x + \"????????????????????????????????§\" + par[x] + \"?????????\");\n            return find(par[x]);\n        }\n\n        // x??¨y???????????????????±????????????????\n        Boolean same(int x,int y) {\n            return find(x)==find(y);\n        }\n\n        // x??¨y????±??????????????????????\n        void unite(int x,int y) {\n            x = find(x);\n            y = find(y);\n            if (x==y) return;\n            if (rank[x]<rank[y]) par[x] = y;\n            else {\n                par[y]=x;\n                if (rank[x]==rank[y]) rank[x]++;\n            }\n        }\n\n        // x??????????????????\n        void mark(int x) {\n            mark[x] = true;\n        }\n\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean isNewLine(int c) {\n            return c == '\\n' || c == '\\r';\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        void skipNewLine() {\n            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        boolean hasNextLine() {\n            skipNewLine();\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        char[] nextCharArray(int len) {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                if (i == len) {\n                    throw new InputMismatchException();\n                }\n                s[i++] = (char) b;\n                b = readByte();\n            }\n            return s;\n        }\n\n        String nextLine() {\n            if (!hasNextLine()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isNewLine(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] arrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] arrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        double[] arrayDouble(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        void arrayInt(int[]... a) {\n            for (int i = 0; i < a[0].length; i++) for (int j = 0; j < a.length; j++) a[j][i] = nextInt();\n        }\n\n        int[][] matrixInt(int n, int m) {\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) a[i] = arrayInt(m);\n            return a;\n        }\n\n        char[][] charMap(int n, int m) {\n            char[][] a = new char[n][];\n            for (int i = 0; i < n; i++) a[i] = nextCharArray(m);\n            return a;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass UnionFindTree {\n\t\tint[] parent;\n\t\t\n\t\tpublic UnionFindTree(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < parent.length; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (parent[x] == x) return x;\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x, int y) {\n\t\t\tint xx = find(x), yy = find(y);\n\t\t\tif (xx == yy) return;\n\t\t\tparent[xx] = yy;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(parent);\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), Q = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint[] par = new int[N];\n\t\t\tfor (int i = 1; i < N; i++) {\n\t\t\t\tpar[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] count = new int[N];\n\t\t\tchar[] command = new char[Q];\n\t\t\tint[] id = new int[Q];\n\t\t\tfor (int i = 0; i < Q; i++) {\n\t\t\t\tcommand[i] = in.next().charAt(0);\n\t\t\t\tid[i] = in.nextInt() - 1;\n\t\t\t\tif (command[i] == 'M') {\n\t\t\t\t\tcount[id[i]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFindTree uft = new UnionFindTree(N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (count[i] == 0)\n\t\t\t\t\tuft.unite(i, par[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\t\tif (command[i] == 'M') {\n\t\t\t\t\tcount[id[i]]--;\n\t\t\t\t\tif (count[id[i]] == 0) \n\t\t\t\t\t\tuft.unite(id[i], par[id[i]]);\n\t\t\t\t} else {\n\t\t\t\t\tres += uft.find(id[i]) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(t[q] == q){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = v-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tans += 1+uf(t,Query[ii]-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\npublic class Main{\n\tstatic int N,Q;\n\tstatic Node[] ns;\n\tstatic boolean type[];\n\tstatic int no[];\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString input[] = br.readLine().split(\" +\");\n\t\t\tN = new Integer(input[0]);\n\t\t\tQ = new Integer(input[1]);\n\t\t\tif(N==0 & Q==0) break;\n\n\t\t\tns = new Node[N+1];\n\t\t\ttype = new boolean[Q];\n\t\t\tno = new int[Q];\n\n\t\t\tns[1] = new Node(1,0);\n\t\t\tns[1].marked = true;\n\t\t\tfor(int i = 2; i <= N; i++){\n\t\t\t\tns[i] = new Node(i, new Integer(br.readLine()));\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < Q; i++){\n\t\t\t\tinput = br.readLine().split(\" +\");\n\t\t\t\tif(input[0].equals(\"Q\")){\n\t\t\t\t\ttype[i] = true;\n\t\t\t\t}else{\n\t\t\t\t\ttype[i] = false;\n\t\t\t\t}\n\t\t\t\tno[i] = new Integer(input[1]);\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0 ; i < Q; i++){\n\t\t\t\tif(type[i]){\n\t\t\t\t\tsum += findmark(no[i]);\n\t\t\t\t}else{\n\t\t\t\t\tns[no[i]].marked = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tstatic int findmark(int no){\n\t\tif(ns[no].marked) return no;\n\t\telse return findmark(ns[no].father);\n\t}\n}\n\nclass Node{\n\tint no, father;\n\tboolean marked = false;\n\tNode(int no, int father){\n\t\tthis.no = no;\n\t\tthis.father = father;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n \n \npublic class Main{\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void init(){\n\t\t\tfor(int i = 0; i < par.length; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args) throws IOException{\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tint[] par = new int[MAX];\n    \tUnionFind uf = new UnionFind(MAX);\n    \tboolean[] q_mark = new boolean[MAX];\n    \tint[] q_value = new int[MAX];\n    \tboolean[] marked = new boolean[MAX];\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int Q = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && Q == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tArrays.fill(marked, false);\n    \t\tuf.init();\n    \t\tpar[0] = 1;\n    \t\tfor(int i = 1; i < N; i++){\n    \t\t\tpar[i] = sc.nextInt() - 1;\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < Q; i++){\t\n    \t\t\tq_mark[i] = sc.next().equals(\"M\");\n    \t\t\tq_value[i] = sc.nextInt() - 1;\n    \t\t\t\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmarked[q_value[i]] = true;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tif(!marked[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong sum = 0;\n    \t\tfor(int i = Q - 1; i >= 0; i--){\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tuf.unite(q_value[i], par[q_value[i]]);\n    \t\t\t}else{\n    \t\t\t\tsum += uf.find(q_value[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(sum);\n    \t}\n    }\n    \n    public static class Scanner {\n\t\t\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n//\t\tif (a.val > b.val)\n\t\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tint id;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n//\t\t\tdebug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tdebug(vs[i].id);\n//\t\t\tfor (V v : vs[i]) {\n//\t\t\t\tdebug(\"\\t\", v.id);\n//\t\t\t}\n//\t\t\tdebug(vs[i].markedTime);\n//\t\t\tdebug(vs[i].askedTimes);\n//\t\t}\n//\t\tdebug(\"aaaaaaaaaaaaa\");\n\t\trec(vs[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t, int q) {\n\t\tif (q < 0 || q >= t.length) {\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif (t[q] == q) {\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t, t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tm = sc.nextInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tt[i] = sc.nextInt() - 1;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\n\t\t\tint Query[] = new int[m];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tchar c = 0;\n\t\t\t\tint v = 0;\n\t\t\t\ttry {\n\t\t\t\t\tc = sc.next().charAt(0);\n\t\t\t\t\tv = sc.nextInt();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c == 'Q') {\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t} else {\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tif(v-1 < 0 || v>= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v - 1] = -v + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\td[0] = 0;\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint ii = m - i - 1;\n\n\t\t\t\tif (Query[ii] > 0) {\n\t\t\t\t\tint u = uf(t, Query[ii] - 1);\n\t\t\t\t\tif (u == -1234) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1 + u;\n\n\t\t\t\t} else {\n\t\t\t\t\tint v = -Query[ii] - 1;\n\t\t\t\t\tif( v < 0 || v >= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] marked = new int[MAX_N];\n\tprivate final int[] parent = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tArrays.fill(marked, 0, n, - 1);\n\t\t\tmarked[0] = q;\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tisQuery[i] = IN.next().charAt(0) == 'Q';\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif(!isQuery[i] && marked[v[i]] < 0) {\n\t\t\t\t\t\n\t\t\t\t\tmarked[v[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinitialize();\n\t\t\t\n\t\t\tlong summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += find(v[i]) + 1;\n\t\t\t\t\t\n\t\t\t\t} else if (marked[v[i]] == i) {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate void initialize() {\n\t\t\n\t\tArrays.fill(parent, 0, n, -1);\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\n\t\t\tinitialize(i);\n\t\t}\n\t}\n\t\n\tprivate int initialize(int x) {\n\t\t\n\t\tif (parent[x] == - 1) parent[x] = (marked[x] >= 0) ? x: initialize(p[x - 1]);\n\t\treturn parent[x];\n\t}\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] != x) parent[x] = find(parent[x]);\n\t\treturn parent[x];\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\tparent[x] = find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N, Q;\n    static int[] A, B;\n    static char[] T;\n    static int[] V;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n\n        while(true) {\n            N = sc.nextInt();\n            Q = sc.nextInt();\n            if( N == 0 ) break;\n\n            int[] P = sc.nextIntArray(N-1, -1);\n            A = new int[N-1];\n            B = new int[N-1];\n            for (int i = 0; i < N - 1; i++) {\n                A[i] = P[i];\n                B[i] = i+1;\n            }\n\n            T = new char[Q];\n            V = new int[Q];\n            for (int i = 0; i < Q; i++) {\n                T[i] = sc.next().charAt(0);\n                V[i] = sc.nextInt()-1;\n            }\n\n            System.out.println( solve() );\n        }\n    }\n\n    static long solve() {\n        int[][] G = adjB(N, A, B);\n        int[][] LR = eularPath(N, G, 0);\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            map.put(LR[i][0], i);\n        }\n        RangeUpdate seg = new RangeUpdate(N*2, RangeUpdate.MAX);\n        long ans = 0;\n        for (int i = 0; i < Q; i++) {\n            char t = T[i];\n            int v = V[i];\n            int l = LR[v][0];\n            int r = LR[v][1];\n            if( t == 'Q' ) {\n                int mal = (int)seg.get(l);\n                int ma = map.get(mal);\n                ans += (ma+1);\n\n            } else {\n                seg.update(l, r+1, l);\n            }\n        }\n        return ans;\n    }\n\n    static int[][] eularPath(int N, int[][] G, int root) {\n        ArrayDeque<int[]> q = new ArrayDeque<>();\n        int[][] ret = new int[N][2];\n        int idx = 0;\n        q.add(new int[]{-1, root, 0});\n        while (!q.isEmpty()) {\n            int[] s = q.poll();\n            int p = s[0];\n            int a = s[1];\n            int lr = s[2];\n\n            ret[a][lr] = idx++;\n            if (lr == 0) { // left\n                q.addFirst(new int[]{p, a, 1});\n                for (int b : G[a]) {\n                    if (b == p) continue;\n\n                    q.addFirst(new int[]{a, b, 0});\n                }\n            }\n        }\n        return ret;\n    }\n\n    static int[][] adjB(int n, int[] from, int[] to) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n        for (int f : from) {\n            cnt[f]++;\n        }\n        for (int t : to) {\n            cnt[t]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (int i = 0; i < from.length; i++) {\n            adj[from[i]][--cnt[from[i]]] = to[i];\n            adj[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return adj;\n    }\n\n    static class RangeUpdate {\n        interface Monoid {\n            long identity();\n            long apply(long a, long b);\n        }\n\n        static Monoid SUM = new Monoid() {\n            public long identity() { return 0; }\n            public long apply(long a, long b) { return a + b; }\n        };\n\n        static Monoid MAX = new Monoid() {\n            public long identity() { return 0; }\n            public long apply(long a, long b) { return Math.max(a, b); }\n        };\n\n        static Monoid MIN = new Monoid() {\n            public long identity() { return Long.MAX_VALUE / 2; }\n            public long apply(long a, long b) { return Math.min(a, b); }\n        };\n\n        int size;\n        long[] tree;\n        Monoid m;\n        long identity;\n\n        RangeUpdate(int size, Monoid m) {\n            this.size = 1;\n            while( this.size < size ) this.size *= 2;\n            this.tree = new long[this.size*2];\n            this.m = m;\n            this.identity = m.identity();\n            if( this.identity != 0 ) {\n                Arrays.fill(this.tree, this.identity);\n            }\n        }\n\n        // [from, to)\n        void update(int from, int to, long v) {\n            _update(from, to, 1, 0, size, v);\n        }\n\n        void _update(int from, int to, int idx, int l, int r, long v) {\n            if (from <= l && r <= to) {\n                tree[idx] = m.apply(tree[idx], v);\n                return;\n            }\n\n            int mid = (l+r)/2;\n            if (from < mid) _update(from, to, idx*2, l, mid, v);\n            if (mid < to) _update(from, to, idx*2+1, mid, r, v);\n        }\n\n        long get(int idx) {\n            long ret = identity;\n            idx += size;\n            while( idx > 0 ) {\n                ret = m.apply(tree[idx], ret);\n                idx /= 2;\n            }\n            return ret;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(t[q] == q){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = v-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tans += 1+uf(t,Query[ii]-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] marked = new int[MAX_N];\n\tprivate final int[] parent = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tArrays.fill(marked, 0, n, - 1);\n\t\t\tmarked[0] = - 2;\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tisQuery[i] = IN.next().charAt(0) == 'Q';\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif(!isQuery[i] && marked[v[i]] == - 1) {\n\t\t\t\t\t\n\t\t\t\t\tmarked[v[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinitialize();\n\t\t\t\n\t\t\tlong summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += find(v[i]) + 1;\n\t\t\t\t\t\n\t\t\t\t} else if (marked[v[i]] == i) {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tprivate void initialize() {\n\t\t\n\t\tfor (int i = 0; i < n; i ++) parent[i] = (marked[i] == - 1) ? find(p[i - 1]): i;\n\t}\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] == x) {\n\t\t\t\n\t\t\treturn x;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\tparent[x] = find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tlong ans;\n\t\n\tclass Heap{\n\t\tHeap left, right;\n\t\tint value;\n\t\t\n\t\tHeap(int v){\n\t\t\tvalue = v;\n\t\t\tleft = right = null;\n\t\t}\n\t\t\n\t\tint top(){\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tHeap push(int v){\n\t\t\treturn meld(new Heap(v), this);\n\t\t}\n\t\t\n\t\tHeap pop(){\n\t\t\treturn meld(left, right);\n\t\t}\n\t}\n\t\n\tHeap meld(Heap a, Heap b){\n\t\tif(a == null){\n\t\t\treturn b;\n\t\t}\n\t\tif(b == null){\n\t\t\treturn a;\n\t\t}\n\t\tif(a.value < b.value){\n\t\t\tHeap t = a; a = b; b = t;\n\t\t}\n\t\ta.right = meld(a.right, b);\n\t\tHeap t = a.left; a.left = a.right; a.right = t;\n\t\t\n\t\treturn a;\n\t}\n\t\n\tclass Vert extends ArrayList<Integer>{\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTime;\n\t}\n\t\n\tHeap rec(Vert vs[], int vid){\n\t\tVert v = vs[vid];\n\t\tHeap h = null;\n\t\tfor(Integer t : v.askedTime){\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor(Integer u : v){\n\t\t\th = meld(h, rec(vs, u));\n\t\t}\n\t\t\n\t\tfor(;h!=null && h.top() > v.markedTime ;h = h.pop()){\n\t\t\tans += vid;\n\t\t}\n\t\treturn h;\n\t}\n\t\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint N = in.nextInt(), Q = in.nextInt();\n\t\t\tif(N == 0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tVert[] vs = new Vert[N + 1];\n\t\t\tfor(int i=0; i<vs.length; i++){\n\t\t\t\tvs[i] = new Vert();\n\t\t\t\tvs[i].markedTime = Integer.MAX_VALUE;\n\t\t\t\tvs[i].askedTime = new ArrayList<Integer>();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=2; i<=N; i++){\n\t\t\t\tint p = in.nextInt();\n\t\t\t\tvs[p].add(i);\n\t\t\t}\n\t\t\t\n\t\t\tvs[1].markedTime = 0;\n\t\t\tfor(int t=1; t<=Q; t++){\n\t\t\t\tString cmd = in.next();\n\t\t\t\tint v = in.nextInt();\n\t\t\t\tif(cmd.equals(\"M\")){\n\t\t\t\t\tif(vs[v].markedTime == Integer.MAX_VALUE){\n\t\t\t\t\t\tvs[v].markedTime = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvs[v].askedTime.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = 0;\n\t\t\trec(vs, 1);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tif (n != 1) {\n\t\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tuf.par[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[1] = true;\n\t\tpar[1] = 1;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[par[x]]) {\n\t\t\t\treturn par[x];\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static int find(int cur_v, int cur_t, int[] time, int[] parent){\n        if(time[cur_v] < cur_t) return cur_v;\n        if(parent[cur_v] == cur_v) return cur_v;\n        return parent[cur_v] = find(parent[cur_v], cur_t, time, parent);\n    }\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext()) {\n            int n = sc.nextInt();\n            int q = sc.nextInt();\n            if (n == 0 && q == 0) return;\n            int[] parent = new int[n+1];\n            int[] time = new int[n+1];\n            Arrays.fill(time, Integer.MAX_VALUE);\n            List<Integer> qt = new ArrayList<Integer>();\n            List<Integer> vt = new ArrayList<Integer>();\n            for (int i = 2; i <= n; i++) {\n                int v = sc.nextInt();\n                parent[i] = v;\n            }\n            parent[1] = 1;\n            long sum = 0;\n            for (int i = 1; i <= q; i++) {\n                String s = sc.next();\n                int v = sc.nextInt();\n                if (s.equals(\"M\"))\n                    time[v] = Math.min(time[v], i);\n                else\n                {\n                    qt.add(i);\n                    vt.add(v);\n                }\n            }\n            int q_ct = qt.size();\n            for(int i=q_ct-1; i>=0; i--){\n                int cur_v = vt.get(i);\n                int cur_t = qt.get(i);\n                sum += find(cur_v, cur_t, time, parent);\n            }\n            System.out.println(sum);\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString input = br.readLine();\n\n\t\t\tif(input == null){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString[] tmpArray = input.split(\" \");\n\n\t\t\tint n = Integer.parseInt(tmpArray[0]);\n\t\t\tint q = Integer.parseInt(tmpArray[1]);\n\n\t\t\tif(n == 0 && q == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNode[] nodes = new Node[n + 1];\n//\t\t\tnodes[0] = new Node(0, -1);\n//\t\t\tnodes[0].marked = true;\n\n\t\t\tnodes[1] = new Node(1, 0);\n\t\t\tnodes[1].marked = true;\n\n\t\t\tfor(int i = 2; i <= n; i++){\n\t\t\t\tint num = Integer.parseInt(br.readLine());\n\n\t\t\t\tnodes[i] = new Node(i, num);\n\t\t\t}\n\n\t\t\tlong sum = 0;\n\n\t\t\tfor(int i = 0; i < q; i++){\n\t\t\t\ttmpArray = br.readLine().split(\" \");\n\t\t\t\tint tmp = Integer.parseInt(tmpArray[1]);\n\t\t\t\tif(tmpArray[0].equals(\"M\")){\n\t\t\t\t\tnodes[tmp].marked = true;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tsum += nearest(nodes, tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tstatic int nearest(Node[] nodes, int id){\n\t\twhile(true){\n\n//\t\t\tSystem.out.println(\"id = \"+id);\n\n\t\t\tif(nodes[id].marked){\n\t\t\t\treturn id;\n\t\t\t}\n\n\t\t\tid = nodes[id].parent;\n\t\t}\n\t}\n\n}\n\nclass Node {\n\tint id;\n\tint parent;\n\tboolean marked = false;\n\n\tpublic Node(int id, int parent){\n\t\tthis.id = id;\n\t\tthis.parent = parent;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(q < 0 || q>=t.length){\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif(t[q] == q){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = v-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tint u = uf(t,Query[ii]-1);\n\t\t\t\t\tif(u==-1234){\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1+u;\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tclass Heap{\n\t\tHeap left, right;\n\t\tint value;\n\t\t\n\t\tHeap(int v){\n\t\t\tvalue = v;\n\t\t\tleft = right = null;\n\t\t}\n\t\t\n\t\tint top(){\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tHeap push(int v){\n\t\t\treturn meld(new Heap(v), this);\n\t\t}\n\t\t\n\t\tHeap pop(){\n\t\t\treturn meld(left, right);\n\t\t}\n\t}\n\t\n\tHeap meld(Heap a, Heap b){\n\t\tif(a == null){\n\t\t\treturn b;\n\t\t}\n\t\tif(b == null){\n\t\t\treturn a;\n\t\t}\n\t\tif(a.value < b.value){\n\t\t\tHeap t = a; a = b; b = t;\n\t\t}\n\t\ta.right = meld(a.right, b);\n\t\tHeap t = a.left; a.left = a.right; a.right = t;\n\t\t\n\t\treturn a;\n\t}\n\t\n\tclass Vert extends ArrayList<Integer>{\n\t\tint markedTime;\n\t\tint parent;\n\t\tint degree;\n\t\tHeap hp;\n\t\tArrayList<Integer> askedTime;\n\t}\n\t\n\t/*\n\tHeap rec(Vert vs[], int vid){\n\t\tVert v = vs[vid];\n\t\tHeap h = null;\n\t\tfor(Integer t : v.askedTime){\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor(Integer u : v){\n\t\t\th = meld(h, rec(vs, u));\n\t\t}\n\t\t\n\t\tfor(;h!=null && h.top() > v.markedTime ;h = h.pop()){\n\t\t\tans += vid;\n\t\t}\n\t\treturn h;\n\t}\n\t*/\n\t\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint N = in.nextInt(), Q = in.nextInt();\n\t\t\tif(N == 0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tVert[] vs = new Vert[N + 1];\n\t\t\tfor(int i=0; i<vs.length; i++){\n\t\t\t\tvs[i] = new Vert();\n\t\t\t\tvs[i].markedTime = Integer.MAX_VALUE;\n\t\t\t\tvs[i].askedTime = new ArrayList<Integer>();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=2; i<=N; i++){\n\t\t\t\tint p = in.nextInt();\n\t\t\t\tvs[p].degree++;\n\t\t\t\tvs[i].parent = p;\n\t\t\t\tvs[p].add(i);\n\t\t\t}\n\t\t\t\n\t\t\tvs[1].markedTime = 0;\n\t\t\tfor(int t=1; t<=Q; t++){\n\t\t\t\tString cmd = in.next();\n\t\t\t\tint v = in.nextInt();\n\t\t\t\tif(cmd.equals(\"M\")){\n\t\t\t\t\tif(vs[v].markedTime == Integer.MAX_VALUE){\n\t\t\t\t\t\tvs[v].markedTime = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvs[v].askedTime.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tArrayList<Integer> stack = new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tif(vs[i].degree == 0){\n\t\t\t\t\tstack.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(;!stack.isEmpty();){\n\t\t\t\tint vid = stack.get(stack.size()-1);\n\t\t\t\tstack.remove(stack.size()-1);\n\t\t\t\tVert v = vs[vid];\n\t\t\t\tHeap h = null;\n\t\t\t\tfor(Integer t : v.askedTime){\n\t\t\t\t\th = meld(h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tfor(Integer u : v){\n\t\t\t\t\th = meld(h, vs[u].hp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(;h!=null && h.top() > v.markedTime ;h = h.pop()){\n\t\t\t\t\tans += vid;\n\t\t\t\t}\n\t\t\t\tv.hp = h;\n\t\t\t\tif(--vs[v.parent].degree == 0){\n\t\t\t\t\tstack.add(v.parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic final int POP = 10000000;\n\tstatic final int INF = 1 << 30;\n\tstatic int N, Q;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tQ = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> child = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> query = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchild.add(new ArrayList<Integer>());\n\t\t\tquery.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tchild.get(p).add(i);\n\t\t}\n\t\tArrayList<Integer> node = new ArrayList<Integer>();\n\t\tArrayList<Integer> sort = new ArrayList<Integer>();\n\t\tnode.add(0);\n\t\twhile (!node.isEmpty()) {\n\t\t\tint cur = node.get(node.size() - 1);\n\t\t\tnode.remove(node.size() - 1);\n\t\t\tsort.add(cur);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnode.add(POP + cur);\n\t\t\tfor (int i = child.get(cur).size() - 1; i >= 0; --i) {\n\t\t\t\tnode.add(child.get(cur).get(i));\n\t\t\t}\n\t\t}\n\n\t\tint[] mark = new int[N];\n\t\tArrays.fill(mark, INF);\n\t\tmark[0] = -1;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar type = sc.nextChar();\n\t\t\tint n = sc.nextInt() - 1;\n\t\t\tif (type == 'Q') {\n\t\t\t\tquery.get(n).add(i);\n\t\t\t} else {\n\t\t\t\tmark[n] = Math.min(i, mark[n]);\n\t\t\t}\n\t\t}\n\n\t\tint[] time = new int[N];\n\t\tint[] markedNode = new int[N];\n\t\tint[] pos = new int[N];\n\t\tint[] prevTime = new int[N];\n\t\tint[] prevMarkedNode = new int[N];\n\t\tint[] prevSize = new int[N];\n\t\ttime[0] = 0;\n\t\tmarkedNode[0] = 0;\n\t\tint size = 0;\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tint cur = sort.get(i);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcur -= POP;\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\ttime[pos[cur]] = prevTime[cur];\n\t\t\t\t\tmarkedNode[pos[cur]] = prevMarkedNode[cur];\n\t\t\t\t\tsize = prevSize[cur];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\tprevSize[cur] = size;\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = size;\n\t\t\t\t\twhile (left + 1 < right) {\n\t\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\t\tif (mark[cur] < time[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[cur] = right;\n\t\t\t\t\tprevTime[cur] = time[right];\n\t\t\t\t\tprevMarkedNode[cur] = markedNode[right];\n\t\t\t\t\ttime[right] = mark[cur];\n\t\t\t\t\tmarkedNode[right] = cur;\n\t\t\t\t\tsize = right + 1;\n\t\t\t\t}\n\t\t\t\tfor (int q : query.get(cur)) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = size;\n\t\t\t\t\twhile (lo + 1 < hi) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (q < time[mi]) {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += markedNode[lo] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint b = input.read();\n\t\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tif (b == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tb = input.read();\n\t\t\t\t} else if (b == '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tint ret = b - '0';\n\t\t\t\twhile (true) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += b - '0';\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\ttry {\n\t\t\t\tint b = input.read();\n\t\t\t\twhile (Character.isWhitespace(b)) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\treturn (char) b;\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(t[q] == -1){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = -1;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tans += 1+uf(t,Query[ii]-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n \n \npublic class Main{\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void init(){\n\t\t\tfor(int i = 0; i < par.length; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args) throws IOException{\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tint[] par = new int[MAX];\n    \tUnionFind uf = new UnionFind(MAX);\n    \tboolean[] q_mark = new boolean[MAX];\n    \tint[] q_value = new int[MAX];\n    \tboolean[] marked = new boolean[MAX];\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int Q = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && Q == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tArrays.fill(marked, false);\n    \t\tuf.init();\n    \t\tpar[0] = 1;\n    \t\tfor(int i = 1; i < N; i++){\n    \t\t\tpar[i] = sc.nextInt() - 1;\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < Q; i++){\t\n    \t\t\tq_mark[i] = sc.next().equals(\"M\");\n    \t\t\tq_value[i] = sc.nextInt() - 1;\n    \t\t\t\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmarked[q_value[i]] = true;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tif(!marked[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong sum = 0;\n    \t\tfor(int i = Q - 1; i >= 0; i--){\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}else{\n    \t\t\t\tsum += uf.find(q_value[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(sum);\n    \t}\n    }\n    \n    public static class Scanner {\n\t\t\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2170.Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tstatic class Union{\n\t\tint[] id;\n\t\tint[] sz;\n\t\t\n\t\tpublic Union(int size){\n\t\t\tid = new int[size];\n\t\t\tsz = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i){\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int i){\n\t\t\twhile(id[i] != i){\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\tpublic boolean same(int i, int j){\n\t\t\treturn find(i) == find(j);\n\t\t}\n\t\t\n\t\tpublic void union(int i, int j){\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\t\n\t\t\tif (p == q) return;\n\t\t\t\n\t\t\tif (sz[p] < sz[q]){\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[q];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true){\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\t\n\t\t\tint[] id = new int[N];\n\t\t\tfor (int i = 1; i < N; ++i){\n\t\t\t\tint p = in.nextInt() - 1;\n\t\t\t\tid[i] = p;\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 0; i < Q; ++i){\n\t\t\t\tString opera = in.next();\n\t\t\t\tint c = in.nextInt() - 1;\n\t\t\t\tif (opera.equals(\"Q\")){\n\t\t\t\t\twhile (c != id[c]){\n\t\t\t\t\t\tc = id[c];\n\t\t\t\t\t}\n\t\t\t\t\tsum += (c + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tid[c] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    int q = scan.nextInt();\n    Node[] nodes = new Node[n];\n    nodes[0] = new Node();\n    nodes[0].mark = true;\n    nodes[0].num = 0;\n    for(int i = 1; i < n; i++) {\n      nodes[i] = new Node();\n      nodes[i].num = i;\n      nodes[scan.nextInt()-1].setChild(nodes[i]);\n    }\n    int result = 0;\n    for(int i = 0; i < q; i++) {\n      switch(scan.next()) {\n        case \"Q\":\n          result += nodes[scan.nextInt()-1].saiki()+1;\n          break;\n        case \"M\":\n          nodes[scan.nextInt()-1].mark = true;\n          break;\n      }\n    }\n    System.out.println(result);\n  }\n}\n\nclass Node{\n  Node parent;\n  boolean mark;\n  int num;\n  Node() {\n  }\n  void setChild(Node _node) {\n    _node.parent = this;\n  }\n  int saiki() {\n    return (mark)?num:parent.saiki();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n    private static final int MAX_N = 100000 + 16;\n    private static int[] id = new int[MAX_N];   // ??¨??\\????????¶??\\????????????\n    private static int[] sz = new int[MAX_N];   // ??¨??\\????????¶??\\???????????§?°?\n    private static int[] parentTree = new int[MAX_N];   // ??¨??\\????????¶??????\n    private static int[] ancestors = new int[MAX_N];     // ??¨??\\??????????????????????????¶??????\n    private static boolean[] marked = new boolean[MAX_N];   // ??¨??\\???????????????????????¶???\n    private static ArrayList<ArrayList<Integer>> childrenTree = new ArrayList<>();    // ??¨??\\???????????????\n    private static Stack<String> ops = new Stack<String>();                     // ??¨??\\????????????\n    private static Stack<Integer> point = new Stack<Integer>();                 // ??¨??\\???????¢????????????°\n\n    //======================================================\n    // ??¶??\\?????¨??°?????????\n    private static void init(int n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            id[i] = i;\n            sz[i] = 0;\n            childrenTree.add(new ArrayList<Integer>());\n        }\n    }\n\n    private static int find(int p)\n    {\n        if (id[p] == p) return p;\n        return  id[p] = find(id[p]);\n    }\n\n    private static void union(int p, int q)\n    {\n        int pRoot = find(p);\n        int qRoot = find(q);\n\n        if (pRoot == qRoot) return;\n\n        if (sz[pRoot] > sz[qRoot])\n        {\n            id[qRoot] = pRoot;\n        }\n        else\n        {\n            id[pRoot] = qRoot;\n            if (sz[pRoot] == sz[qRoot]) sz[qRoot]++;\n        }\n    }\n    //====================================================\n\n    // ?????¨??????????????´??°???????????¶??????\n    private static void bsf(int index, int ancestor)\n    {\n        Queue<Integer> qIndex = new LinkedList<Integer>();\n        Queue<Integer> qAncestor = new LinkedList<Integer>();\n\n        qIndex.add(index);\n        qAncestor.add(ancestor);\n\n        while (!qIndex.isEmpty())\n        {\n            index = qIndex.poll();\n            ancestor = qAncestor.poll();\n\n            if (marked[index])\n            {\n                ancestor = index;   // ????????\\???????????????????????´??°??¶??¶??????\n            }\n            ancestors[index] = ancestor;\n            for (int i: childrenTree.get(index))\n            {\n                qIndex.add(i);\n                qAncestor.add(ancestor);\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            if (n == m && n == 0) break;\n\n            // ?????????\n            init(n);\n            for (int i = 1; i < n; i++)\n            {\n                int q = in.nextInt();\n                q--;\n\n                childrenTree.get(q).add(i);\n                parentTree[i] = q;\n            }\n            marked[0] = true;\n            for (int i = 0; i < m; i++)\n            {\n                String q = in.next();\n                int k = in.nextInt(); k--;\n\n                if (q.equals(\"M\"))\n                {\n                    if (marked[k]) continue;\n                    marked[k] = true;\n                }\n\n                ops.push(q);\n                point.push(k);\n            }\n            bsf(0, 0);\n            for (int i = 0; i < n; i++)\n            {   // ?°??????????????????¶??¶???????????\\???????????\\???\n                union(i, ancestors[i]);\n            }\n            long sum = 0;\n            while (!ops.isEmpty())\n            {\n                String q = ops.pop();\n                int k = point.pop();\n                if (q.equals(\"Q\"))\n                {   // ?????°??¶?????????\n                    sum += ancestors[find(k)] + 1;  // ?¢????????§??????????1\n                }\n                else\n                {   // ??????????¨?????°???¶?\\????????????¶??¶??????????\\????\n                    int p = ancestors[find(parentTree[k])];\n                    union(k, parentTree[k]);\n                    ancestors[find(k)] = p;\n                }\n            }\n            System.out.println(sum);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n//\t\tif (a.val > b.val)\n\t\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n//\t\t\tdebug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tdebug(vs[i].id);\n//\t\t\tfor (V v : vs[i]) {\n//\t\t\t\tdebug(\"\\t\", v.id);\n//\t\t\t}\n//\t\t\tdebug(vs[i].markedTime);\n//\t\t\tdebug(vs[i].askedTimes);\n//\t\t}\n//\t\tdebug(\"aaaaaaaaaaaaa\");\n\t\t\n\t\t\n\t\t\n\t\t\t// vが答えになる\n//\t\t\tfor (int t : v.askedTimes) {\n//\t\t\t\th = meld(h, new Heap(t));\n//\t\t\t}\n//\t\t\tfor (V u : v) {\n//\t\t\t\th = meld(h, rec(u));\n//\t\t\t}\n//\t\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n//\t\t\t\tans += v.id;\n////\t\t\t\tdebug(\"vid\",v.id);\n//\t\t\t}\n//\t\t\treturn h;\n\t\t\n\t\tStack<V>stackV=new Stack<V>();\n\t\tStack<Integer>stackS=new Stack<Integer>();\n\t\t\n\t\tstackV.push(vs[0]);\n\t\tstackS.push(0);\n\t\t\n\t\tfor(;!stackV.isEmpty();){\n\t\t\tV v=stackV.pop();\n\t\t\tint state=stackS.pop();\n//\t\t\tdebug(v.id, \"state\",state);\n\t\t\tif(state==0){\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tstackS.push(1);\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n\t\t\t\t\tstackS.push(0);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h=meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n//\t\t\t\t\tdebug(\"vid\",v.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n//\t\trec(vs[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(q < 0 || q>=t.length){\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif(t[q] == q){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry{\n\t\t\t n = sc.nextInt();\n\t\t\t m = sc.nextInt();\n\t\t\t}catch (Exception e){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = v-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tint u = uf(t,Query[ii]-1);\n\t\t\t\t\tif(u==-1234){\n\t\t\t\t\t\treturn ;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1+u;\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2170.Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main {\n\t\n\tstatic class Union{\n\t\tint[] id;\n\t\tint[] sz;\n\t\t\n\t\tpublic Union(int size){\n\t\t\tid = new int[size];\n\t\t\tsz = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i){\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int i){\n\t\t\twhile(id[i] != i){\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\tpublic boolean same(int i, int j){\n\t\t\treturn find(i) == find(j);\n\t\t}\n\t\t\n\t\tpublic void union(int i, int j){\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\t\n\t\t\tif (p == q) return;\n\t\t\t\n\t\t\tif (sz[p] < sz[q]){\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[q];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true){\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\t\n\t\t\tint[] id = new int[N];\n\t\t\tfor (int i = 1; i < N; ++i){\n\t\t\t\tint p = in.nextInt() - 1;\n\t\t\t\tid[i] = p;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < Q; ++i){\n\t\t\t\tString opera = in.next();\n\t\t\t\tint c = in.nextInt() - 1;\n\t\t\t\tif (opera.equals(\"Q\")){\n\t\t\t\t\twhile (c != id[c]){\n\t\t\t\t\t\tc = id[c];\n\t\t\t\t\t}\n\t\t\t\t\tsum += (c + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tid[c] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static IO io = new IO();\n    private static int p[] = new int[100001];   // p[i]: parent of i-th node\n    private static boolean mark[] = new boolean[100001];\n    public static void main(String[] args) {\n\n        p[1] = 1;\n        while (true) {\n\n            int n = io.nextInt();\n            int q = io.nextInt();\n            if (n==0) break;\n            for (int i=2; i<=n; i++) p[i] = io.nextInt();\n            long ans = 0;\n            for (int i=0; i<q; i++) {\n                char ope = io.nextChar();\n                int v = io.nextInt();\n                if (ope=='M') mark[v] = true;\n                else ans += find(v);\n            }\n            System.out.println(ans);\n            Arrays.fill(mark, false);\n\n        }\n\n    }\n\n    private static int find(int x) {\n        Deque<Integer> que = new ArrayDeque<>();\n        que.offer(x);\n        int ans = 0;\n        while (!que.isEmpty()) {\n            int poll = que.poll();\n            if (p[poll] == poll || mark[poll]) ans = poll;\n            else que.offer(p[poll]);\n        }\n        return ans;\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile (true) {\n\t\t\tString[] s = in.readLine().split(\" \");\n\t\t\tint N = Integer.parseInt(s[0]);\n\t\t\tint Q = Integer.parseInt(s[1]);\n\t\t\tif (N == 0 && Q == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] p = new int[N + 1];\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tp[i] = Integer.parseInt(in.readLine());\n\t\t\t}\n\t\t\t\n\t\t\tchar[] c = new char[Q + 1];\n\t\t\tint[] v = new int[Q + 1];\n\t\t\tboolean[] marked = new boolean[N + 1];\n\t\t\tmarked[1] = true;\n\t\t\tfor (int j = 1; j <= Q; j++) {\n\t\t\t\ts = in.readLine().split(\" \");\n\t\t\t\tc[j] = s[0].charAt(0);\n\t\t\t\tv[j] = Integer.parseInt(s[1]);\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tmarked[v[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] parent = new int[N + 1];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tparent[i] = marked[i] ? -1 : p[i];\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int j = Q; j >= 1; j--) {\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tparent[v[j]] = p[v[j]];\n\t\t\t\t}\n\t\t\t\tif (c[j] == 'Q') {\n\t\t\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\tint i = v[j];\n\t\t\t\t\twhile (parent[i] != -1) {\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t\ti = parent[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int _i: list) {\n\t\t\t\t\t\tparent[_i] = i;\n\t\t\t\t\t}\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2170.Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tstatic class Union{\n\t\tint[] id;\n\t\tint[] sz;\n\t\t\n\t\tpublic Union(int size){\n\t\t\tid = new int[size];\n\t\t\tsz = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i){\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int i){\n\t\t\twhile(id[i] != i){\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\tpublic boolean same(int i, int j){\n\t\t\treturn find(i) == find(j);\n\t\t}\n\t\t\n\t\tpublic void union(int i, int j){\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\t\n\t\t\tif (p == q) return;\n\t\t\t\n\t\t\tif (sz[p] < sz[q]){\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[q];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static int find(int i){\n\t\twhile (i != id[i]) i = id[i];\n\t\treturn i;\n\t}\n\t\n\tstatic int[] id;\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true){\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\tid = new int[N];\n\t\t\t\n\t\t\tfor (int i = 1; i < N; ++i){\n\t\t\t\tint p = in.nextInt() - 1;\n\t\t\t\tid[i] = p;\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 0; i < Q; ++i){\n\t\t\t\tString opera = in.next();\n\t\t\t\tint c = in.nextInt() - 1;\n\t\t\t\tif (opera.equals(\"Q\")){\n\t\t\t\t\tsum += (find(c) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tid[c] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic final int INF = Integer.MAX_VALUE / 10;\n\tstatic final double EPS = 1e-10;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint n = si(), q = si();\n\t\t\tif(n==0) break;\n\t\t\tUnionFind1 uft = new UnionFind1(n);\n\t\t\tint[] parrem = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint p = si()-1;\n\t\t\t\tuft.par[i]=p;\n\t\t\t\tparrem[i]=p;\n\t\t\t}\n\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString string = scan.next();\n\t\t\t\tint v = si()-1;\n\t\t\t\tif(string.equals(\"M\")){\n\t\t\t\t\tuft.par[v]=v;\n\t\t\t\t}\n\t\t\t\tstack.push(string.equals(\"M\")? 0 : 1);\n\t\t\t\tstack.push(v);\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint v = stack.pop();\n\t\t\t\tint ope = stack.pop();\n\n\t\t\t\tif(ope==1){\n\t\t\t\t\tans += uft.root(v)+1;\n\t\t\t\t}else{\n\t\t\t\t\tuft.par[v] = parrem[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic int si() {\n\t\treturn Integer.parseInt(scan.next());\n\t}\n}\n\nclass UnionFind1 {\n\n\t//フィールド\n\tint[] par;\n\tint[] rank;\n\n\t//コンストラクタ\n\tUnionFind1(int n){\n\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\t//木の根を求める\n\tint root(int x){\n\t\tif(par[x]==x)\t\t//xが根の要素ならそれを返す\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = root(par[x]);\t\t//xが根でなければ一つ上のpar[]を求めて返す＆経路圧縮\n\t}\n\n\t//xとyの属する集合を併合\n\tvoid unite(int x,int y){\n\t\tx=root(x);\n\t\ty=root(y);\n\t\tif(x==y) return;\t\t//同じ集合なら併合済み\n\n\t\tif(rank[x]<rank[y])\t\t//yの方が高い木ならxの根の部分をyの根から繋げる\n\t\t\tpar[x]=y;\n\t\telse{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y])\t\t//おなじ高さならyを一つ下げて繋げる（その結果、xの木は高さが１増える）\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tboolean isSame(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n//\t\tif (a.val > b.val)\n\t\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n//\t\t\tdebug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\t\t\n\t\tps=null;\n\t\tqueryNode=null;\n\t\tqueryType=null;\n\t\t\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tdebug(vs[i].id);\n//\t\t\tfor (V v : vs[i]) {\n//\t\t\t\tdebug(\"\\t\", v.id);\n//\t\t\t}\n//\t\t\tdebug(vs[i].markedTime);\n//\t\t\tdebug(vs[i].askedTimes);\n//\t\t}\n//\t\tdebug(\"aaaaaaaaaaaaa\");\n\t\t\n\t\t\n\t\t\n\t\t\t// vが答えになる\n//\t\t\tfor (int t : v.askedTimes) {\n//\t\t\t\th = meld(h, new Heap(t));\n//\t\t\t}\n//\t\t\tfor (V u : v) {\n//\t\t\t\th = meld(h, rec(u));\n//\t\t\t}\n//\t\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n//\t\t\t\tans += v.id;\n////\t\t\t\tdebug(\"vid\",v.id);\n//\t\t\t}\n//\t\t\treturn h;\n\t\t\n\t\tStack<V>stackV=new Stack<V>();\n\t\tStack<Integer>stackS=new Stack<Integer>();\n\t\t\n\t\tstackV.push(vs[0]);\n\t\tstackS.push(0);\n\t\t\n\t\tfor(;!stackV.isEmpty();){\n\t\t\tV v=stackV.pop();\n\t\t\tint state=stackS.pop();\n//\t\t\tdebug(v.id, \"state\",state);\n\t\t\tif(state==0){\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tstackS.push(1);\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n\t\t\t\t\tstackS.push(0);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h=meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n//\t\t\t\t\tdebug(\"vid\",v.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n//\t\trec(vs[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] marked = new int[MAX_N];\n\tprivate final int[] parent = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tArrays.fill(marked, 0, n, - 1);\n\t\t\tmarked[0] = - 2;\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tisQuery[i] = IN.next().charAt(0) == 'Q';\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif(!isQuery[i] && marked[v[i]] == - 1) {\n\t\t\t\t\t\n\t\t\t\t\tmarked[v[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\t\n\t\t\t\tif (marked[i] == - 1) {\n\t\t\t\t\t\n\t\t\t\t\tparent[i] = p[i - 1];\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tparent[i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += find(v[i]) + 1;\n\t\t\t\t\t\n\t\t\t\t} else if (marked[v[i]] == i) {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] == x) {\n\t\t\t\n\t\t\treturn x;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\ty = find(y);\n\t\tparent[x] = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] marked = new int[MAX_N];\n\tprivate final int[] value = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tArrays.fill(marked, 0, n, - 1);\n\t\t\tmarked[0] = q;\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tisQuery[i] = IN.next().charAt(0) == 'Q';\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif(!isQuery[i] && marked[v[i]] < 0) {\n\t\t\t\t\t\n\t\t\t\t\tmarked[v[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinitialize();\n\t\t\tfor (int i = 0; i < n; i ++) if (marked[i] < 0) union(i, p[i - 1]);\n\t\t\t\n\t\t\tlong summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += value[find(v[i])];\n\t\t\t\t\t\n\t\t\t\t} else if (marked[v[i]] == i) {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate final int[] parent = new int[MAX_N];\n\tprivate final int[] rank = new int[MAX_N];\n\t\n\tprivate void initialize() {\n\t\t\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tvalue[i] = i + 1;\n\t\t}\n\t}\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] != x) parent[x] = find(parent[x]);\n\t\treturn parent[x];\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) {\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (rank[x] < rank[y]) {\n\t\t\t\n\t\t\tparent[x] = y;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tparent[y] = x;\n\t\t\tvalue[x] = value[y];\n\t\t\t\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\n\t\t\t\trank[x] ++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[]args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve(in,out);\n\tin.close();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tvoid dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d\",a[i]);out.println();}\n\tvoid dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tvoid dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tlong pow(long a,long n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tString itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tvoid sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tvoid m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a,j,j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tvoid swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tint binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=0,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return a[s]>v?-1:s;}\n\tvoid solve(ContestScanner in,Writer out)throws NumberFormatException,IOException{\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint q = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\ttree = new List[n];\n\t\t\tms = new int[n];\n\t\t\tqs = new Queue[n];\n\t\t\thmap = new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ttree[i] = new ArrayList<>();\n\t\t\t\tms[i] = -1;\n\t\t\t\tqs[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tms[0] = 0;\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tint par = in.nextInt()-1;\n\t\t\t\ttree[par].add(i);\n\t\t\t}\n\t\t\tfor(int i=0; i<q; i++){\n\t\t\t\tchar c = in.nextToken().charAt(0);\n\t\t\t\tint v = in.nextInt()-1;\n\t\t\t\tif(c=='M'){\n\t\t\t\t\tif(ms[v]==-1) ms[v] = i+1;\n\t\t\t\t}else{\n\t\t\t\t\tqs[v].add(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst = new RangeMaximumSegTree(q+1);\n\t\t\tsum = 0;\n\t\t\tdfs(0, 0);\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tList<Integer>[] tree;\n\tint[] ms;\n\tint[] hmap;\n\tQueue<Integer>[] qs;\n\tRangeMaximumSegTree st;\n\tint sum;\n\tvoid dfs(int v, int dep){\n\t\tif(ms[v]>=0){\n\t\t\tst.set(ms[v], dep);\n\t\t\thmap[dep] = v+1;\n\t\t}\n\t\tfor(int q: qs[v]){\n\t\t\tsum += hmap[st.max(0, q)];\n\t\t}\n\t\tfor(int nv: tree[v]){\n\t\t\tdfs(nv, dep+1);\n\t\t}\n\t\tif(ms[v]>=0){\n\t\t\tst.set(ms[v], -1);\n\t\t}\n\t}\n}\n\nclass RangeMaximumSegTree{\n\tint[] tree;\n\tint size;\n\tint len;\n\tint n;\n\tpublic RangeMaximumSegTree(int n){\n\t\tint beki = 1;\n\t\twhile(beki < n) beki <<= 1;\n\t\tlen = beki<<1;\n\t\tthis.n = n;\n\t\ttree = new int[len];\n\t\tArrays.fill(tree, -1);\n\t\tsize = beki;\n\t}\n\tpublic void set(int id, int x){\n\t\tint i = id | size; tree[i] = x;\n\t\tfor(i>>=1; i>0; i>>=1) tree[i] = Math.max(tree[i<<1], tree[(i<<1)+1]);\n\t}\n\tpublic int get(int id){\n\t\treturn tree[id|size];\n\t}\n\t// in idx: left to right\n\tpublic int max(int left, int right){\n\t\tint res = -1;\n\t\tleft |= size;\n\t\tright|= size;\n\t\tright++;\n\t\twhile(left < right){\n\t\t\tif((right&1) == 1) res = Math.max(res, tree[--right]);\n\t\t\tif((left&1) == 1) res = Math.max(res, tree[left++]);\n\t\t\tright >>= 1;\n\t\t\tleft >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic String output(int idx){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=size; i<=size+idx; i++) sb.append(tree[i]+\" \");\n\t\treturn sb.toString();\n\t}\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int e=2, s=1; e<=len; e<<=1){\n\t\t\tfor(;s<e; s++) sb.append(tree[s]).append(\" \");\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n\tpublic String toString() {return String.format(\"(%d, %d)\", a, b);}\n}\nclass Timer{\n\tlong time;\n\tpublic void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print()\n\t{System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.function.BinaryOperator;\n\npublic class Main implements Runnable {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 1024L * 1024 * 16).start();\n\t}\n\t\n\tpublic void run() {\n\t\twhile(solve());\n\t}\n\t\n\tint n;\n\tint q;\n\tint[] parent;\n\tArrayList<Integer>[] child;\n\tboolean[] marked;\n\tint[] ma;\n\tArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tmarked = new boolean[n];\n\t\tmarked[0] = true;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tmarked[qVal[i]] = true;\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tInteger[] init = new Integer[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tinit[i] = i;\n\t\t}\n\t\tUnionFind<Integer> uf = new UnionFind<Integer>(init,Math::min);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.merge(i, ma[i]);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tif (parent[qVal[i]] >= 0) {\n\t\t\t\t\tuf.merge(qVal[i], parent[qVal[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic void dfs(int v) {\n\t\tif (marked[v]) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (marked[v]) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind<T> {\n\tprivate int[] parent;\n\tprivate T[] data;\n\tBinaryOperator<T> mergeFunction;\n\n\t/**\n\t * @param mergeFunction (larger,smaller) -> merged\n\t */\n\tpublic UnionFind(T[] data,BinaryOperator<T> mergeFunction) {\n\t\tint n = data.length;\n\t\tthis.data = data;\n\t\tthis.mergeFunction = mergeFunction;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean merge(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tdata[x] = mergeFunction.apply(data[x], data[y]);\n\t\t\tparent[y] = x;\n\t\t\tdata[y] = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic T get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic int groupSize(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic ArrayList<T> datas() {\n\t\tArrayList<T> ret = new ArrayList<>();\n\t\tfor(T x:data) {\n\t\t\tif (x != null) {\n\t\t\t\tret.add(x);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn datas().toString();\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2170.Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tstatic class Union{\n\t\tint[] id;\n\t\tint[] sz;\n\t\t\n\t\tpublic Union(int size){\n\t\t\tid = new int[size];\n\t\t\tsz = new int[size];\n\t\t\tfor (int i = 0; i < size; ++i){\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int i){\n\t\t\twhile(id[i] != i){\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t\t\n\t\tpublic boolean same(int i, int j){\n\t\t\treturn find(i) == find(j);\n\t\t}\n\t\t\n\t\tpublic void union(int i, int j){\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\t\n\t\t\tif (p == q) return;\n\t\t\t\n\t\t\tif (sz[p] < sz[q]){\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[q];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true){\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\t\n\t\t\tint[] id = new int[N];\n\t\t\tfor (int i = 1; i < N; ++i){\n\t\t\t\tint p = in.nextInt() - 1;\n\t\t\t\tid[i] = p;\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 0; i < Q; ++i){\n\t\t\t\tString opera = in.next();\n\t\t\t\tint c = in.nextInt() - 1;\n\t\t\t\tif (opera.equals(\"Q\")){\n\t\t\t\t\twhile (c != id[c]){\n\t\t\t\t\t\tc = id[c];\n\t\t\t\t\t}\n\t\t\t\t\tsum += (c + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tid[c] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n \n \npublic class Main{\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void init(){\n\t\t\tfor(int i = 0; i < par.length; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args) throws IOException{\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tint[] par = new int[MAX];\n    \tUnionFind uf = new UnionFind(MAX);\n    \tboolean[] q_mark = new boolean[MAX];\n    \tint[] q_value = new int[MAX];\n    \tboolean[] marked = new boolean[MAX];\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int Q = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && Q == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tArrays.fill(marked, false);\n    \t\tuf.init();\n    \t\tpar[0] = 0;\n    \t\tfor(int i = 1; i < N; i++){\n    \t\t\tpar[i] = sc.nextInt() - 1;\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < Q; i++){\t\n    \t\t\tq_mark[i] = sc.next().equals(\"M\");\n    \t\t\tq_value[i] = sc.nextInt() - 1;\n    \t\t\t\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmarked[q_value[i]] = true;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\t//System.out.println(i + \" \" + par[i] + \" \" + marked[i]);\n    \t\t\tif(!marked[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong sum = 0;\n    \t\tfor(int i = Q - 1; i >= 0; i--){\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tuf.unite(q_value[i], par[q_value[i]]);\n    \t\t\t}else{\n    \t\t\t\tsum += uf.find(q_value[i]) + 1;\n    \t\t\t}\n    \t\t\t\n    \t\t\t//for(int j = 0; j < N; j++){\n    \t\t\t//\tSystem.out.print(uf.find(j) + \" \");\n    \t\t\t//}\n    \t\t\t//System.out.println();\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(sum);\n    \t}\n    }\n    \n    public static class Scanner {\n\t\t\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\tint n=sc.nextInt();//the number of nodes\n\t\tint q=sc.nextInt();//the number of operations\n\t\tif(n==0&&q==0)break;\n\t\tint[] d=new int[n];\n\t\tint[] marked=new int[n];\n\t\tmarked[0]++;\n\t\tDJSet ds=new DJSet(n);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint parent=sc.nextInt()-1;\n\t\t\td[i]=parent;\n\t\t}\n\t\tint[] memo=new int[q];\n\t\tchar[] j=new char[q];\n\t\tfor(int i=0;i<q;i++){\n\t\t\tString str=sc.next();\n\t\t\tj[i]=str.charAt(0);\n\t\t\tint v=sc.nextInt()-1;\n\t\t\tmemo[i]=v;\n\t\t\tif(str.equals(\"M\"))marked[v]++;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(marked[i]>0)continue;\n\t\t\tds.setUnion(i, d[i]);\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(j[i]=='Q'){\n\t\t\t\tans+=ds.root(memo[i])+1;\n\t\t\t}else if(j[i]=='M'){\n\t\t\t\tmarked[memo[i]]--;\n\t\t\t\tif(marked[memo[i]]==0){\n\t\t\t\t\tds.setUnion(memo[i],d[memo[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n\tclass DJSet{\n\t\tint n;//the number of vertices\n\t\tint[] d;\n\t\tDJSet(int n){\n\t\t\tthis.n=n;\n\t\t\td=new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn d[x]<0?x:root(d[x]);\n\t\t}\n\t\tboolean setUnion(int x,int y){\n\t\t\tint rootx=root(x);\n\t\t\tint rooty=root(y);\n\t\t\tif(rootx!=rooty){\n//\t\t\t\tif(x<y){\n//\t\t\t\t\tint d=x;\n//\t\t\t\t\tx=y;\n//\t\t\t\t\ty=d;\n//\t\t\t\t}\n\t\t\t\t//x>y\n\t\t\t\td[rooty]+=d[rootx];\n\t\t\t\td[x]=y;\n\t\t\t}\n\t\t\treturn rootx!=rooty;\n\t\t}\n\t\tboolean same(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint size(int x){\n\t\t\treturn d[root(x)]*(-1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic final int POP = 10000000;\n\tstatic int N, Q;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tQ = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> child = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> query = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchild.add(new ArrayList<Integer>());\n\t\t\tquery.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tchild.get(p).add(i);\n\t\t}\n\t\tArrayList<Integer> node = new ArrayList<Integer>();\n\t\tArrayList<Integer> sort = new ArrayList<Integer>();\n\t\tnode.add(0);\n\t\twhile (!node.isEmpty()) {\n\t\t\tint cur = node.get(node.size() - 1);\n\t\t\tnode.remove(node.size() - 1);\n\t\t\tsort.add(cur);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnode.add(POP + cur);\n\t\t\tfor (int i = child.get(cur).size() - 1; i >= 0; --i) {\n\t\t\t\tnode.add(child.get(cur).get(i));\n\t\t\t}\n\t\t}\n\n\t\tint[] mark = new int[N];\n\t\tmark[0] = -1;\n\t\tArrays.fill(mark, 1 << 30);\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar type = sc.nextChar();\n\t\t\tint n = sc.nextInt() - 1;\n\t\t\tif (type == 'Q') {\n\t\t\t\tquery.get(n).add(i);\n\t\t\t} else {\n\t\t\t\tmark[n] = Math.min(i, mark[n]);\n\t\t\t}\n\t\t}\n\n\t\tint[] time = new int[N];\n\t\tint[] markedNode = new int[N];\n\t\tint[] pos = new int[N];\n\t\tint[] prevTime = new int[N];\n\t\tint[] prevMarkedNode = new int[N];\n\t\tint[] prevSize = new int[N];\n\t\ttime[0] = -1;\n\t\tmarkedNode[0] = 0;\n\t\tint size = 1;\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tint cur = sort.get(i);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcur -= POP;\n\t\t\t\ttime[pos[cur]] = prevTime[cur];\n\t\t\t\tmarkedNode[pos[cur]] = prevMarkedNode[cur];\n\t\t\t\tsize = prevSize[cur];\n\t\t\t} else {\n\t\t\t\tfor (int q : query.get(cur)) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = size;\n\t\t\t\t\twhile (lo + 1 < hi) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (q < time[mi]) {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += markedNode[lo] + 1;\n\t\t\t\t}\n\t\t\t\tprevSize[cur] = size;\n\t\t\t\tint left = 0;\n\t\t\t\tint right = size;\n\t\t\t\twhile (left + 1 < right) {\n\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\tif (mark[cur] < time[mid]) {\n\t\t\t\t\t\tright = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos[cur] = right;\n\t\t\t\tprevTime[cur] = time[right];\n\t\t\t\tprevMarkedNode[cur] = markedNode[right];\n\t\t\t\ttime[right] = mark[cur];\n\t\t\t\tmarkedNode[right] = cur;\n\t\t\t\tsize = right + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint b = input.read();\n\t\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tif (b == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tb = input.read();\n\t\t\t\t} else if (b == '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tint ret = b - '0';\n\t\t\t\twhile (true) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += b - '0';\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\ttry {\n\t\t\t\tint b = input.read();\n\t\t\t\twhile (Character.isWhitespace(b)) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\treturn (char) b;\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * \n * @author DemonSong\n * \n *         2170. Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile (true){\n\t\t\tString[] line = in.nextLine().trim().split(\" \");\n\t\t\tint N = Integer.parseInt(line[0]);\n\t\t\tint Q = Integer.parseInt(line[1]);\n\t\t\tint[] union = new int[N];\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\tunion[0] = 0;\n\t\t\tfor (int i = 1; i <N; i++){\n\t\t\t\tunion[i] = Integer.parseInt(in.nextLine())-1;\n\t\t\t}\n\t\t\tString[][] ops = new String[Q][2];\n\t\t\tfor (int i = 0; i < Q; i++){\n\t\t\t\tline = in.nextLine().trim().split(\" \");\n\t\t\t\tops[i][0] = line[0];\n\t\t\t\tops[i][1] = line[1];\n\t\t\t}\n\t\t\tSystem.out.println(solve(union, ops));\n\t\t\t\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tprivate static int solve(int[] union, String[][] ops){\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < ops.length; i++){\n\t\t\tif (ops[i][0].equals(\"M\")){\n\t\t\t\tint id = Integer.parseInt(ops[i][1])-1;\n\t\t\t\tunion[id] = - union[id];\n\t\t\t}\n\t\t\t\n\t\t\tif (ops[i][0].equals(\"Q\")){\n\t\t\t\tint id = Integer.parseInt(ops[i][1])-1;\n\t\t\t\tres += find(union, id);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate static int find(int[] union, int id){\n\t\tint next = union[id];\n\t\twhile (next < 0){\n\t\t\tnext = union[-next];\n\t\t}\n\t\treturn next;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.function.BinaryOperator;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tstatic int n;\n\tstatic int q;\n\tstatic int[] parent;\n\tstatic ArrayList<Integer>[] child;\n\tstatic boolean[] marked;\n\tstatic int[] ma;\n\tstatic ArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tmarked = new boolean[n];\n\t\tmarked[0] = true;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tmarked[qVal[i]] = true;\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tInteger[] init = new Integer[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tinit[i] = i;\n\t\t}\n\t\tUnionFind<Integer> uf = new UnionFind<Integer>(init,Math::min);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.merge(i, ma[i]);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tif (parent[qVal[i]] >= 0) {\n\t\t\t\t\tuf.merge(qVal[i], parent[qVal[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic static void dfs(int v) {\n\t\tif (marked[v]) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (marked[v]) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind<T> {\n\tprivate int[] parent;\n\tprivate T[] data;\n\tBinaryOperator<T> mergeFunction;\n\n\t/**\n\t * @param mergeFunction (larger,smaller) -> merged\n\t */\n\tpublic UnionFind(T[] data,BinaryOperator<T> mergeFunction) {\n\t\tint n = data.length;\n\t\tthis.data = data;\n\t\tthis.mergeFunction = mergeFunction;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean merge(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tdata[x] = mergeFunction.apply(data[x], data[y]);\n\t\t\tparent[y] = x;\n\t\t\tdata[y] = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic T get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic int groupSize(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic ArrayList<T> datas() {\n\t\tArrayList<T> ret = new ArrayList<>();\n\t\tfor(T x:data) {\n\t\t\tif (x != null) {\n\t\t\t\tret.add(x);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn datas().toString();\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n \n \npublic class Main{\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void init(){\n\t\t\tfor(int i = 0; i < par.length; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args) throws IOException{\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tint[] par = new int[MAX];\n    \tUnionFind uf = new UnionFind(MAX);\n    \tboolean[] q_mark = new boolean[MAX];\n    \tint[] q_value = new int[MAX];\n    \tint[] mark_count = new int[MAX];\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int Q = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && Q == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tArrays.fill(mark_count, 0);\n    \t\tuf.init();\n    \t\tpar[0] = 0;\n    \t\tfor(int i = 1; i < N; i++){\n    \t\t\tpar[i] = sc.nextInt() - 1;\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < Q; i++){\t\n    \t\t\tq_mark[i] = sc.next().equals(\"M\");\n    \t\t\tq_value[i] = sc.nextInt() - 1;\n    \t\t\t\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmark_count[q_value[i]]++;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\t//System.out.println(i + \" \" + par[i] + \" \" + marked[i]);\n    \t\t\tif(mark_count[i] == 0){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong sum = 0;\n    \t\tfor(int i = Q - 1; i >= 0; i--){\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmark_count[q_value[i]]--;\n    \t\t\t\t\n    \t\t\t\tif(mark_count[q_value[i]] == 0){\n    \t\t\t\t\tuf.unite(q_value[i], par[q_value[i]]);\n    \t\t\t\t}\n    \t\t\t\t//uf.unite(par[q_value[i]], q_value[i]);\n    \t\t\t}else{\n    \t\t\t\tsum += uf.find(q_value[i]) + 1;\n    \t\t\t}\n    \t\t\t\n    \t\t\t//for(int j = 0; j < N; j++){\n    \t\t\t//\tSystem.out.print(uf.find(j) + \" \");\n    \t\t\t//}\n    \t\t\t//System.out.println();\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(sum);\n    \t}\n    }\n    \n    public static class Scanner {\n\t\t\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n \n    int uf(int[] t , int q){\n        if(t[q] == q){\n            return q;\n        }\n        int v = uf(t,t[q]);\n        t[q] = v;\n        return v;\n    }\n     \n    void run() {\n        for(;;){\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n             \n            if((n|m)==0){\n                break;\n            }\n             \n            int[] t = new int[n];\n            int[] d = new int[n];\n            for(int i =1 ; i< n ;i++){\n                t[i] = sc.nextInt()-1;\n                d[i] = t[i];\n            }\n             \n             \n            int Query[] = new int[m];\n             \n            for(int i = 0; i< m; i++){\n                char c = sc.next().charAt(0);\n                int v = sc.nextInt();\n                if(c=='Q'){\n                    Query[i] = v;\n                }else{\n                    Query[i] = -v;\n                    t[v-1] = -v+1;\n                }\n            }\n            t[0] = 0;\n             \n            int ans = 0;\n            for(int i = 0; i < m; i++){\n                int ii = m-i-1;\n                 \n                if(Query[ii] > 0){\n                    ans += 1+uf(t,Query[ii]-1);\n                }else{\n                    int v = -Query[ii]-1;\n                    t[v] = d[v];\n                }\n            }\n            System.out.println(ans);\n        }\n    }\n \n    public static void main(String[] args) {\n        Main m = new Main();\n        m.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[]args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve(in,out);\n\tin.close();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tvoid dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d\",a[i]);out.println();}\n\tvoid dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tvoid dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tlong pow(long a,long n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tString itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tvoid sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tvoid m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a,j,j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tvoid swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tint binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=0,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return a[s]>v?-1:s;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(ContestScanner in,Writer out)throws NumberFormatException,IOException{\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint q = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tList<Integer>[] tree = new List[n];\n\t\t\tint[] ms = new int[n];\n\t\t\tQueue<Integer>[] qs = new Queue[n];\n\t\t\tint[] hmap = new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ttree[i] = new ArrayList<>();\n\t\t\t\tms[i] = -1;\n\t\t\t\tqs[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tms[0] = 0;\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tint par = in.nextInt()-1;\n\t\t\t\ttree[par].add(i);\n\t\t\t}\n\t\t\tfor(int i=0; i<q; i++){\n\t\t\t\tchar c = in.nextToken().charAt(0);\n\t\t\t\tint v = in.nextInt()-1;\n\t\t\t\tif(c=='M'){\n\t\t\t\t\tif(ms[v]==-1) ms[v] = i+1;\n\t\t\t\t}else{\n\t\t\t\t\tqs[v].add(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRangeMaximumSegTree st = new RangeMaximumSegTree(q+1);\n\t\t\tlong sum = 0;\n\t\t\tStack<Long> sk = new Stack<>();\n\t\t\tsk.add(0L);\n\t\t\tfinal int mask = (1<<20)-1;\n\t\t\twhile(!sk.isEmpty()){\n\t\t\t\tlong p = sk.pop();\n\t\t\t\tint v = (int)(p&mask);\n\t\t\t\tint dep = (int)((p>>20)&mask);\n\t\t\t\tint flag = (int)(p>>40);\n\t\t\t\tif(flag==0){\n\t\t\t\t\tif(ms[v]>=0){\n\t\t\t\t\t\tst.set(ms[v], dep);\n\t\t\t\t\t\thmap[dep] = v+1;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int t: qs[v]){\n\t\t\t\t\t\tsum += hmap[st.max(0, t)];\n\t\t\t\t\t}\n\t\t\t\t\tsk.add(1L<<40|p);\n\t\t\t\t\tfor(int nv: tree[v]){\n\t\t\t\t\t\tsk.add((long)(dep+1)<<20|nv);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(ms[v]>=0){\n\t\t\t\t\t\tst.set(ms[v], -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t/*\n\tList<Integer>[] tree;\n\tint[] ms;\n\tint[] hmap;\n\tQueue<Integer>[] qs;\n\tRangeMaximumSegTree st;\n\tint sum;\n\tvoid dfs(int v, int dep){\n\t\tif(ms[v]>=0){\n\t\t\tst.set(ms[v], dep);\n\t\t\thmap[dep] = v+1;\n\t\t}\n\t\tfor(int q: qs[v]){\n\t\t\tsum += hmap[st.max(0, q)];\n\t\t}\n\t\tfor(int nv: tree[v]){\n\t\t\tdfs(nv, dep+1);\n\t\t}\n\t\tif(ms[v]>=0){\n\t\t\tst.set(ms[v], -1);\n\t\t}\n\t}*/\n}\n\nclass RangeMaximumSegTree{\n\tint[] tree;\n\tint size;\n\tint len;\n\tint n;\n\tpublic RangeMaximumSegTree(int n){\n\t\tint beki = 1;\n\t\twhile(beki < n) beki <<= 1;\n\t\tlen = beki<<1;\n\t\tthis.n = n;\n\t\ttree = new int[len];\n\t\tArrays.fill(tree, -1);\n\t\tsize = beki;\n\t}\n\tpublic void set(int id, int x){\n\t\tint i = id | size; tree[i] = x;\n\t\tfor(i>>=1; i>0; i>>=1) tree[i] = Math.max(tree[i<<1], tree[(i<<1)+1]);\n\t}\n\tpublic int get(int id){\n\t\treturn tree[id|size];\n\t}\n\t// in idx: left to right\n\tpublic int max(int left, int right){\n\t\tint res = -1;\n\t\tleft |= size;\n\t\tright|= size;\n\t\tright++;\n\t\twhile(left < right){\n\t\t\tif((right&1) == 1) res = Math.max(res, tree[--right]);\n\t\t\tif((left&1) == 1) res = Math.max(res, tree[left++]);\n\t\t\tright >>= 1;\n\t\t\tleft >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic String output(int idx){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=size; i<=size+idx; i++) sb.append(tree[i]+\" \");\n\t\treturn sb.toString();\n\t}\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int e=2, s=1; e<=len; e<<=1){\n\t\t\tfor(;s<e; s++) sb.append(tree[s]).append(\" \");\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n\tpublic String toString() {return String.format(\"(%d, %d)\", a, b);}\n}\nclass Timer{\n\tlong time;\n\tpublic void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print()\n\t{System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic final int POP = 10000000;\n\tstatic final int INF = 1 << 30;\n\tstatic int N, Q;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tQ = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> child = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> query = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchild.add(new ArrayList<Integer>());\n\t\t\tquery.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tchild.get(p).add(i);\n\t\t}\n\t\tArrayList<Integer> node = new ArrayList<Integer>();\n\t\tArrayList<Integer> sort = new ArrayList<Integer>();\n\t\tnode.add(0);\n\t\twhile (!node.isEmpty()) {\n\t\t\tint cur = node.get(node.size() - 1);\n\t\t\tnode.remove(node.size() - 1);\n\t\t\tsort.add(cur);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnode.add(POP + cur);\n\t\t\tfor (int i = child.get(cur).size() - 1; i >= 0; --i) {\n\t\t\t\tnode.add(child.get(cur).get(i));\n\t\t\t}\n\t\t}\n\n\t\tint[] mark = new int[N];\n\t\tArrays.fill(mark, INF);\n\t\tmark[0] = -1;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar type = sc.nextChar();\n\t\t\tint n = sc.nextInt() - 1;\n\t\t\tif (type == 'Q') {\n\t\t\t\tquery.get(n).add(i);\n\t\t\t} else {\n\t\t\t\tmark[n] = Math.min(i, mark[n]);\n\t\t\t}\n\t\t}\n\n\t\tint[] time = new int[N];\n\t\tint[] markedNode = new int[N];\n\t\tint[] pos = new int[N];\n\t\tint[] prevTime = new int[N];\n\t\tint[] prevMarkedNode = new int[N];\n\t\tint[] prevSize = new int[N];\n\t\ttime[0] = -1;\n\t\tmarkedNode[0] = 0;\n\t\tint size = 1;\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tint cur = sort.get(i);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcur -= POP;\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\ttime[pos[cur]] = prevTime[cur];\n\t\t\t\t\tmarkedNode[pos[cur]] = prevMarkedNode[cur];\n\t\t\t\t\tsize = prevSize[cur];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int q : query.get(cur)) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = size;\n\t\t\t\t\twhile (lo + 1 < hi) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (q < time[mi]) {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += markedNode[lo] + 1;\n\t\t\t\t}\n\t\t\t\tif (mark[cur] != INF && mark[cur] != -1) {\n\t\t\t\t\tprevSize[cur] = size;\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = size;\n\t\t\t\t\twhile (left + 1 < right) {\n\t\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\t\tif (mark[cur] < time[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[cur] = right;\n\t\t\t\t\tprevTime[cur] = time[right];\n\t\t\t\t\tprevMarkedNode[cur] = markedNode[right];\n\t\t\t\t\ttime[right] = mark[cur];\n\t\t\t\t\tmarkedNode[right] = cur;\n\t\t\t\t\tsize = right + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint b = input.read();\n\t\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tif (b == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tb = input.read();\n\t\t\t\t} else if (b == '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tint ret = b - '0';\n\t\t\t\twhile (true) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += b - '0';\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\ttry {\n\t\t\t\tint b = input.read();\n\t\t\t\twhile (Character.isWhitespace(b)) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\treturn (char) b;\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(t[q] == q){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = v-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tans += 1+uf(t,Query[ii]-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;;){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\t\t}\n//\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tsc.nextLine();\n\n\t\t\tStack<int[]> op = new Stack<int[]>();\n\t\t\tStack<int[]> mkdnd = new Stack<int[]>();\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = new Integer(d[2] - '0');\n\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tint[] t = {0, n, getParent(n)};\n\t\t\t\t\t\top.push(t);\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tint[] f = {1, n};\n\t\t\t\t\t\top.push(f);\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\twhile(!op.empty()){\n\t\t\t\tint[] o = op.pop();\n\t\t\t\tswitch(o[0]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t//case 'M':\n\t\t\t\t\t\tsetParent(o[1], o[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t//case 'Q':\n\t\t\t\t\t\tres = res + gmRoot(o[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic int gmRoot(int node){\n\t\tint res = -2;\n\t\tint p = getParent(node);\n\n\t\tif(p == 0){\n\t\t\tres = node;\t\t\t\n\t\t}else{\n\t\t\tres = gmRoot(p);\n\t\t\tsetParent(node, res);\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Marked Ancestor\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N, Q;\n\t\t\tN = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tQ = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((N | Q) == 0) break;\n\n\t\t\tNode[] nodes = new Node[N + 1];\n\n\t\t\tnodes[1] = main.new Node(1);\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tint p = parseInt(br.readLine());\n\t\t\t\tnodes[i] = main.new Node(i);\n\t\t\t\tnodes[i].p = nodes[p];\n\t\t\t\tif (nodes[p].cs == null) {\n\t\t\t\t\tnodes[p].cs = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tnodes[p].cs.add(nodes[i]);\n\t\t\t}\n\n\t\t\tlong sum = 0;\n\t\t\tnodes[1].marked = true;\n\t\t\tfor (int i = 0; i < Q; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tchar o = line.charAt(0);\n\t\t\t\tint v = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tif (o == 'M') {\n\t\t\t\t\tnodes[v].marked = true;\n\t\t\t\t} else {\n\t\t\t\t\tNode node = nodes[v];\n\t\t\t\t\twhile (!node.p.marked) {\n\t\t\t\t\t\tnode = node.p;\n\t\t\t\t\t}\n\t\t\t\t\tsum += node.p.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t} //end while\n\t} //end main\n\n\tclass Node {\n\t\tint id;\n\t\tboolean marked;\n\t\tNode p;\n\t\tList<Node> cs;\n\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main2{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tsc.nextLine();\n\n\t\t\tStack<int[]> op = new Stack<int[]>();\n\t\t\tStack<int[]> mkdnd = new Stack<int[]>();\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = new Integer(d[2] - '0');\n\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tint[] t = {0, n, getParent(n)};\n\t\t\t\t\t\top.push(t);\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tint[] f = {1, n};\n\t\t\t\t\t\top.push(f);\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\twhile(!op.empty()){\n\t\t\t\tint[] o = op.pop();\n\t\t\t\tswitch(o[0]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t//case 'M':\n\t\t\t\t\t\tsetParent(o[1], o[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t//case 'Q':\n\t\t\t\t\t\tres = res + gmRoot(o[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic int gmRoot(int node){\n\t\tint res = -2;\n\t\tint p = getParent(node);\n\n\t\tif(p == 0){\n\t\t\tres = node;\t\t\t\n\t\t}else{\n\t\t\tres = gmRoot(p);\n\t\t\tsetParent(node, res);\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\npublic class Main{\n\tstatic int N,Q;\n\tstatic Node[] ns;\n\tstatic boolean type[];\n\tstatic int no[];\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString input[] = br.readLine().split(\" +\");\n\t\t\tN = new Integer(input[0]);\n\t\t\tQ = new Integer(input[1]);\n\t\t\tif(N==0 & Q==0) break;\n\n\t\t\tns = new Node[N+1];\n\t\t\ttype = new boolean[Q];\n\t\t\tno = new int[Q];\n\n\t\t\tns[1] = new Node(0);\n\t\t\tns[1].marked = true;\n\t\t\tfor(int i = 2; i <= N; i++){\n\t\t\t\tns[i] = new Node(new Integer(br.readLine()));\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < Q; i++){\n\t\t\t\tinput = br.readLine().split(\" +\");\n\t\t\t\tif(input[0].equals(\"Q\")){\n\t\t\t\t\ttype[i] = true;\n\t\t\t\t}else{\n\t\t\t\t\ttype[i] = false;\n\t\t\t\t}\n\t\t\t\tno[i] = new Integer(input[1]);\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor(int i = 0 ; i < Q; i++){\n\t\t\t\tif(type[i]){\n\t\t\t\t\tsum += findmark(no[i]);\n\t\t\t\t}else{\n\t\t\t\t\tns[no[i]].marked = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tstatic int findmark(int no){\n\t\twhile(true){\n\t\t\tif(ns[no].marked) return no;\n\t\t\telse no = ns[no].par;\n\t\t}\n\t}\n}\n\nclass Node{\n\tint par;\n\tboolean marked = false;\n\tNode(int par){\n\t\tthis.par = par;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile (true) {\n\t\t\tString[] s = in.readLine().split(\" \");\n\t\t\tint N = Integer.parseInt(s[0]);\n\t\t\tint Q = Integer.parseInt(s[1]);\n\t\t\tif (N == 0 && Q == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] p = new int[N + 1];\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tp[i] = Integer.parseInt(in.readLine());\n\t\t\t}\n\t\t\t\n\t\t\tchar[] c = new char[Q + 1];\n\t\t\tint[] v = new int[Q + 1];\n\t\t\tboolean[] marked = new boolean[N + 1];\n\t\t\tmarked[1] = true;\n\t\t\tfor (int j = 1; j <= Q; j++) {\n\t\t\t\ts = in.readLine().split(\" \");\n\t\t\t\tc[j] = s[0].charAt(0);\n\t\t\t\tv[j] = Integer.parseInt(s[1]);\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tif (marked[v[j]]) {\n\t\t\t\t\t\tc[j] = ' ';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarked[v[j]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] parent = new int[N + 1];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tparent[i] = marked[i] ? -1 : p[i];\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int j = Q; j >= 1; j--) {\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tparent[v[j]] = p[v[j]];\n\t\t\t\t}\n\t\t\t\tif (c[j] == 'Q') {\n\t\t\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\tint i = v[j];\n\t\t\t\t\twhile (parent[i] != -1) {\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t\ti = parent[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int _i: list) {\n\t\t\t\t\t\tparent[_i] = i;\n\t\t\t\t\t}\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static IO io = new IO();\n    private static int p[] = new int[100001];   // p[i]: parent of i-th node\n    private static boolean mark[] = new boolean[100001];\n    public static void main(String[] args) {\n\n        p[1] = 1;\n        while (true) {\n\n            Arrays.fill(mark, false);\n            int n = io.nextInt();\n            int q = io.nextInt();\n            if (n==0 && q==0) break;\n            for (int i=2; i<=n; i++) p[i] = io.nextInt();\n            long ans = 0;\n            for (int i=0; i<q; i++) {\n                char ope = io.nextChar();\n                int v = io.nextInt();\n                if (ope=='M') {\n                    mark[v] = true;\n                    //System.out.println(v[i] + \"?????????????????????\");\n                } else {\n                    ans += find(v);\n                }\n            }\n            System.out.println(ans);\n            //System.out.println(\"ope: \" + Arrays.toString(ope));\n            //System.out.println(\"v: \" + Arrays.toString(v));\n\n        }\n\n    }\n\n    static int find(int x) {\n        if (p[x] == x || mark[x]) return x;\n        //System.out.println(x + \"????????????????????????????????§\" + p[x] + \"?????????\");\n        return find(p[x]);\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean isNewLine(int c) {\n            return c == '\\n' || c == '\\r';\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        void skipNewLine() {\n            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        boolean hasNextLine() {\n            skipNewLine();\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        char[] nextCharArray(int len) {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                if (i == len) {\n                    throw new InputMismatchException();\n                }\n                s[i++] = (char) b;\n                b = readByte();\n            }\n            return s;\n        }\n\n        String nextLine() {\n            if (!hasNextLine()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isNewLine(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] arrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] arrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        double[] arrayDouble(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        void arrayInt(int[]... a) {\n            for (int i = 0; i < a[0].length; i++) for (int j = 0; j < a.length; j++) a[j][i] = nextInt();\n        }\n\n        int[][] matrixInt(int n, int m) {\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) a[i] = arrayInt(m);\n            return a;\n        }\n\n        char[][] charMap(int n, int m) {\n            char[][] a = new char[n][];\n            for (int i = 0; i < n; i++) a[i] = nextCharArray(m);\n            return a;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n\t\t// if (a.val > b.val)\n\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id,state;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n\t\t\t// debug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\n\t\tps = null;\n\t\tqueryNode = null;\n\t\tqueryType = null;\n\n\t\tStack<V> stackV = new Stack<V>();\n\n\t\tstackV.push(vs[0]);\n\n\t\tfor (; !stackV.isEmpty();) {\n\t\t\tV v = stackV.pop();\n\t\t\tif (v.state == 0) {\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tv.state=1;\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h = meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintln(ans + \"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tuf.par[i] = p;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[1] = true;\n\t}\n\n\tpublic int find(int x) {\n\t\tif (mark[par[x]]) {\n\t\t\treturn par[x];\n\t\t} else {\n\t\t\treturn find(par[x]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic final int POP = 10000000;\n\tstatic final int INF = 1 << 30;\n\tstatic int N, Q;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tQ = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> child = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> query = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchild.add(new ArrayList<Integer>());\n\t\t\tquery.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tchild.get(p).add(i);\n\t\t}\n\t\tArrayList<Integer> node = new ArrayList<Integer>();\n\t\tArrayList<Integer> sort = new ArrayList<Integer>();\n\t\tnode.add(0);\n\t\twhile (!node.isEmpty()) {\n\t\t\tint cur = node.get(node.size() - 1);\n\t\t\tnode.remove(node.size() - 1);\n\t\t\tsort.add(cur);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnode.add(POP + cur);\n\t\t\tfor (int i = child.get(cur).size() - 1; i >= 0; --i) {\n\t\t\t\tnode.add(child.get(cur).get(i));\n\t\t\t}\n\t\t}\n\n\t\tint[] mark = new int[N];\n\t\tmark[0] = -1;\n\t\tArrays.fill(mark, INF);\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar type = sc.nextChar();\n\t\t\tint n = sc.nextInt() - 1;\n\t\t\tif (type == 'Q') {\n\t\t\t\tquery.get(n).add(i);\n\t\t\t} else {\n\t\t\t\tmark[n] = Math.min(i, mark[n]);\n\t\t\t}\n\t\t}\n\n\t\tint[] time = new int[N];\n\t\tint[] markedNode = new int[N];\n\t\tint[] pos = new int[N];\n\t\tint[] prevTime = new int[N];\n\t\tint[] prevMarkedNode = new int[N];\n\t\tint[] prevSize = new int[N];\n\t\ttime[0] = -1;\n\t\tmarkedNode[0] = 0;\n\t\tint size = 1;\n\t\tlong ans = 0;\n\t\tfor (int i = 1; i < 2 * N; ++i) {\n\t\t\tint cur = sort.get(i);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcur -= POP;\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\ttime[pos[cur]] = prevTime[cur];\n\t\t\t\t\tmarkedNode[pos[cur]] = prevMarkedNode[cur];\n\t\t\t\t\tsize = prevSize[cur];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int q : query.get(cur)) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = size;\n\t\t\t\t\twhile (lo + 1 < hi) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (q < time[mi]) {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += markedNode[lo] + 1;\n\t\t\t\t}\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\tprevSize[cur] = size;\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = size;\n\t\t\t\t\twhile (left + 1 < right) {\n\t\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\t\tif (mark[cur] < time[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[cur] = right;\n\t\t\t\t\tprevTime[cur] = time[right];\n\t\t\t\t\tprevMarkedNode[cur] = markedNode[right];\n\t\t\t\t\ttime[right] = mark[cur];\n\t\t\t\t\tmarkedNode[right] = cur;\n\t\t\t\t\tsize = right + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint b = input.read();\n\t\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tif (b == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tb = input.read();\n\t\t\t\t} else if (b == '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tint ret = b - '0';\n\t\t\t\twhile (true) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += b - '0';\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\ttry {\n\t\t\t\tint b = input.read();\n\t\t\t\twhile (Character.isWhitespace(b)) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\treturn (char) b;\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n    private static final int MAX_N = 100000 + 16;\n    private static int[] id = new int[MAX_N];   // ??¨??\\????????¶??\\????????????\n    private static int[] sz = new int[MAX_N];   // ??¨??\\????????¶??\\???????????§?°?\n    private static int[] parentTree = new int[MAX_N];   // ??¨??\\????????¶??????\n    private static int[] ancestors = new int[MAX_N];     // ??¨??\\??????????????????????????¶??????\n    private static boolean[] marked = new boolean[MAX_N];   // ??¨??\\???????????????????????¶???\n    private static ArrayList<ArrayList<Integer>> childrenTree = new ArrayList<>(MAX_N);    // ??¨??\\???????????????\n    private static Stack<String> ops = new Stack<String>();                     // ??¨??\\????????????\n    private static Stack<Integer> point = new Stack<Integer>();                 // ??¨??\\???????¢????????????°\n\n    //======================================================\n    // ??¶??\\?????¨??°?????????\n    private static void init(int n)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            id[i] = i;\n            sz[i] = 0;\n            childrenTree.add(new ArrayList<>());\n        }\n    }\n\n    private static int find(int p)\n    {\n        if (id[p] == p) return p;\n        return  id[p] = find(id[p]);\n    }\n\n    private static void union(int p, int q)\n    {\n        int pRoot = find(p);\n        int qRoot = find(q);\n\n        if (pRoot == qRoot) return;\n\n        if (sz[pRoot] > sz[qRoot])\n        {\n            id[qRoot] = pRoot;\n        }\n        else\n        {\n            id[pRoot] = qRoot;\n            if (sz[pRoot] == sz[qRoot]) sz[qRoot]++;\n        }\n    }\n    //====================================================\n\n    // ?????¨??????????????´??°???????????¶??????\n    private static void bsf(int index, int ancestor)\n    {\n        Queue<Integer> qIndex = new LinkedList<Integer>();\n        Queue<Integer> qAncestor = new LinkedList<Integer>();\n\n        qIndex.add(index);\n        qAncestor.add(ancestor);\n\n        while (!qIndex.isEmpty())\n        {\n            index = qIndex.poll();\n            ancestor = qAncestor.poll();\n\n            if (marked[index])\n            {\n                ancestor = index;   // ????????\\???????????????????????´??°??¶??¶??????\n            }\n            ancestors[index] = ancestor;\n            for (int i: childrenTree.get(index))\n            {\n                qIndex.add(i);\n                qAncestor.add(ancestor);\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            if (n == m && n == 0) break;\n\n            // ?????????\n            init(n);\n            for (int i = 1; i < n; i++)\n            {\n                int q = in.nextInt();\n                q--;\n\n                childrenTree.get(q).add(i);\n                parentTree[i] = q;\n\n            }\n            marked[0] = true;\n            for (int i = 0; i < m; i++)\n            {\n                String q = in.next();\n                int k = in.nextInt(); k--;\n\n                if (q.equals(\"M\"))\n                {\n                    if (marked[k]) continue;\n                    marked[k] = true;\n                }\n\n                ops.push(q);\n                point.push(k);\n            }\n            bsf(0, 0);\n            for (int i = 0; i < n; i++)\n            {   // ?°??????????????????¶??¶???????????\\???????????\\???\n                union(i, ancestors[i]);\n            }\n            long sum = 0;\n            while (!ops.isEmpty())\n            {\n                String q = ops.pop();\n                int k = point.pop();\n                if (q.equals(\"Q\"))\n                {   // ?????°??¶?????????\n                    sum += ancestors[find(k)] + 1;  // ?¢????????§??????????1\n                }\n                else\n                {   // ??????????¨?????°???¶?\\????????????¶??¶??????????\\????\n                    int p = ancestors[find(parentTree[k])];\n                    union(k, parentTree[k]);\n                    ancestors[find(k)] = p;\n                }\n            }\n            System.out.println(sum);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tstatic int INF = 1 << 29;\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 1024L * 1024 * 48).start();\n\t}\n\t\n\tpublic void run() {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tint n;\n\tint q;\n\tint[] parent;\n\tArrayList<Integer>[] child;\n\tint[] firstMarked;\n\tint[] ma;\n\tArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i+1] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tfirstMarked = new int[n];\n\t\tArrays.fill(firstMarked, INF);\n\t\tfirstMarked[0] = -1;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tfirstMarked[qVal[i]] = Math.min(firstMarked[qVal[i]], i);\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tUnionFind uf = new UnionFind(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.union(ma[i], i);\n\t\t}\n\t\tlong sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tif (parent[qVal[i]] >= 0 && firstMarked[qVal[i]] == i) {\n\t\t\t\t\tuf.union(parent[qVal[i]], qVal[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic void dfs(int v) {\n\t\tif (firstMarked[v] < INF) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (firstMarked[v] < INF) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind {\n\tprivate int[] parent;\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tparent = new int[size];\n\t\tdata = new int[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tdata[i] = i;\n\t\t}\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tint nData = data[x];\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] = nData;\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic int get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(parent);\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * \n * @author DemonSong\n * \n *         2170. Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile (true){\n\t\t\tString[] line = in.nextLine().trim().split(\" \");\n\t\t\tint N = Integer.parseInt(line[0]);\n\t\t\tint Q = Integer.parseInt(line[1]);\n\t\t\tint[] union = new int[N];\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\tunion[0] = 0;\n\t\t\tfor (int i = 1; i <N; i++){\n\t\t\t\tunion[i] = Integer.parseInt(in.nextLine())-1;\n\t\t\t}\n\t\t\tString[][] ops = new String[Q][2];\n\t\t\tfor (int i = 0; i < Q; i++){\n\t\t\t\tline = in.nextLine().trim().split(\" \");\n\t\t\t\tops[i][0] = line[0];\n\t\t\t\tops[i][1] = line[1];\n\t\t\t}\n\t\t\tSystem.out.println(solve(union, ops));\n\t\t\t\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tprivate static int solve(int[] union, String[][] ops){\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < ops.length; i++){\n\t\t\tif (ops[i][0].equals(\"M\")){\n\t\t\t\tint pid = Integer.parseInt(ops[i][1])-1;\n\t\t\t\tmark(union, pid);\n\t\t\t}\n\t\t\t\n\t\t\tif (ops[i][0].equals(\"Q\")){\n\t\t\t\tint id = Integer.parseInt(ops[i][1])-1;\n\t\t\t\tres += find(union, id)+1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate static void mark(int[] union, int pid){\n\t\tfor (int i = 0; i < union.length; i++){\n\t\t\tif (union[i] == pid){\n\t\t\t\tunion[i] = -pid;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static int find(int[] union, int id){\n\t\tint next = union[id];\n\t\twhile (next < 0){\n\t\t\tnext = union[-next];\n\t\t}\n\t\treturn next;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    while(true) {\n      int n = scan.nextInt();\n      int q = scan.nextInt();\n      if((n|q) == 0) return;\n      Node[] nodes = new Node[n];\n      nodes[0] = new Node();\n      nodes[0].mark = true;\n      nodes[0].num = 0;\n      for(int i = 1; i < n; i++) {\n        nodes[i] = new Node();\n        nodes[i].num = i;\n      }\n      for(int i = 1; i < n; i++) {\n        nodes[scan.nextInt()-1].setChild(nodes[i]);\n      }\n      long result = 0;\n      for(int i = 0; i < q; i++) {\n        switch(scan.next()) {\n          case \"Q\":\n            result += (long)(nodes[scan.nextInt()-1].saiki()+1);\n            break;\n          case \"M\":\n            nodes[scan.nextInt()-1].mark = true;\n            break;\n        }\n      }\n      System.out.println(result);\n    }\n  }\n}\n\nclass Node{\n  Node parent;\n  boolean mark;\n  int num;\n  Node() {\n  }\n  void setChild(Node _node) {\n    _node.parent = this;\n  }\n  int saiki() {\n    return (mark)?num:parent.saiki();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tif (n != 1) {\n\t\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tuf.par[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[0]=true;\n\t\tmark[1] = true;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[par[x]]) {\n\t\t\t\treturn par[x];\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    int q = scan.nextInt();\n    Node[] nodes = new Node[n];\n    nodes[0] = new Node();\n    nodes[0].mark = true;\n    nodes[0].num = 0;\n    for(int i = 1; i < n; i++) {\n      nodes[i] = new Node();\n      nodes[i].num = i;\n    }\n    for(int i = 1; i < n; i++) {\n      nodes[scan.nextInt()-1].setChild(nodes[i]);\n    }\n    long result = 0;\n    for(int i = 0; i < q; i++) {\n      switch(scan.next()) {\n        case \"Q\":\n          result += (long)(nodes[scan.nextInt()-1].saiki()+1);\n          break;\n        case \"M\":\n          nodes[scan.nextInt()-1].mark = true;\n          break;\n      }\n    }\n    System.out.println(result);\n  }\n}\n\nclass Node{\n  Node parent;\n  boolean mark;\n  int num;\n  Node() {\n  }\n  void setChild(Node _node) {\n    _node.parent = this;\n  }\n  int saiki() {\n    return (mark)?num:parent.saiki();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic int[] parent;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] p = new int[N + 1];\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tp[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tchar[] c = new char[Q + 1];\n\t\t\tint[] v = new int[Q + 1];\n\t\t\tboolean[] marked = new boolean[N + 1];\n\t\t\tmarked[1] = true;\n\t\t\tfor (int j = 1; j <= Q; j++) {\n\t\t\t\tc[j] = in.next().charAt(0);\n\t\t\t\tv[j] = in.nextInt();\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tmarked[v[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = new int[N + 1];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tparent[i] = marked[i] ? -1 : p[i];\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int j = Q; j >= 1; j--) {\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tparent[v[j]] = p[v[j]];\n\t\t\t\t}\n\t\t\t\tif (c[j] == 'Q') {\n\t\t\t\t\tsum += find(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tstatic int find(int i) {\n\t\tif (parent[i] == -1) {\n\t\t\treturn i;\n\t\t} else {\n\t\t\treturn parent[i] = find(parent[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tif (n != 1) {\n\t\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tuf.par[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[1] = true;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[par[x]]) {\n\t\t\t\treturn par[x];\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]) throws Exception{\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint N = sc.nextInt();\n\t\t\tint Q = sc.nextInt();\n\t\t\tif((N|Q)==0) break;\n\t\t\tUnionfind uf = new Unionfind(N);\n\t\t\tfor(int i=2;i<=N;i++){\n\t\t\t\tuf.parent[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int mm =0;mm<Q;mm++){\n\t\t\t\tString operation = sc.next();\n\t\t\t\tif(operation.equals(\"Q\")){\n\t\t\t\t\tans += uf.find(sc.nextInt());\n\t\t\t\t}else{\n\t\t\t\t\t//operationがMのとき\n\t\t\t\t\tuf.mark[sc.nextInt()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\nclass Unionfind{\n\tpublic int parent[];\n\tpublic boolean mark[];\n\n\tUnionfind(int n){\n\t\tparent = new int[n+1];\n\t\tmark = new boolean[n+1];\n\t\tmark[1] = true;\n\t\tparent[1] = 1;\n\t}\n\n\t//木の根を求める\n\tpublic int find(int x){\n\t\tfor(;;){\n\t\t\tif(mark[x]){\n\t\t\t\treturn  x;\n\t\t\t}else{\n\t\t\t\tx = parent[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tbackup();\n\t\t\tsc.nextLine();\n\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = new Integer(d[2] - '0');\n\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tres = res + gmRoot(n);\n\t\t\t\t\t\trestore();\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic int gmRoot(int node){\n\t\tint res = -2;\n\t\tint p = getParent(node);\n\n\t\tif(p == 0){\n\t\t\tres = node;\t\t\t\n\t\t}else{\n\t\t\tres = gmRoot(p);\n\t\t\tsetParent(node, res);\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n\tstatic int[] backup;\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic void backup(){\n\t\tbackup = data.clone();\n\t}\n\tstatic void restore(){\n\t\tdata = backup.clone();\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tsc.nextLine();\n\n\t\t\tStack<int[]> op = new Stack<int[]>();\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = 0;\n\t\t\t\tfor(int j = d.length - 1; j >= 2; j--){\n\t\t\t\t\tint power = 1;\n\t\t\t\t\tfor(int k = j ; k < d.length - 1; k++){\n\t\t\t\t\t\tpower = power * 10;\n\t\t\t\t\t}\n\t\t\t\t\tn = n + (new Integer(d[j] - '0')) * power;\n\t\t\t\t}\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tint[] t = {0, n, getParent(n)};\n\t\t\t\t\t\top.push(t);\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tint[] f = {1, n};\n\t\t\t\t\t\top.push(f);\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\twhile(!op.empty()){\n\t\t\t\tint[] o = op.pop();\n\t\t\t\tswitch(o[0]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t//case 'M':\n\t\t\t\t\t\tsetParent(o[1], o[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t//case 'Q':\n\t\t\t\t\t\tres = res + gmRoot(o[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\n\tstatic int gmRoot(int node){\n\t\tint nodes[] = new int[100100];\n\t\t\n\t\tint p = getParent(node);\n\t\tint posnode = node;\n\t\tint i = 0;\n\t\twhile(p != 0){\n\t\t\tnodes[i] = posnode;\n\t\t\ti++;\n\t\t\tposnode = p;\n\t\t\tp = getParent(posnode);\n\t\t}\n\t\tfor(int k = 0; k < i; k++){\n\t\t\tsetParent(nodes[k], posnode);\n\t\t}\n\n\t\treturn posnode;\n\n\t}\n\t\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void init(){\n\t\t\tfor(int i = 0; i < par.length; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args){\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tint[] par = new int[MAX];\n    \tUnionFind uf = new UnionFind(MAX);\n    \tboolean[] q_mark = new boolean[MAX];\n    \tint[] q_value = new int[MAX];\n    \t\n    \tboolean[] marked = new boolean[MAX];\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int Q = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && Q == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tArrays.fill(marked, false);\n    \t\tuf.init();\n    \t\tpar[0] = 1;\n    \t\tfor(int i = 1; i < N; i++){\n    \t\t\tpar[i] = sc.nextInt() - 1;\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < Q; i++){\t\n    \t\t\tq_mark[i] = sc.next().equals(\"M\");\n    \t\t\tq_value[i] = sc.nextInt() - 1;\n    \t\t\t\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmarked[q_value[i]] = true;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tif(!marked[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong sum = 0;\n    \t\tfor(int i = Q - 1; i >= 0; i--){\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}else{\n    \t\t\t\tsum += uf.find(q_value[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(sum);\n    \t}\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n \n \npublic class Main{\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\t\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t\t\n\t\tpublic void init(){\n\t\t\tfor(int i = 0; i < par.length; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static final int MAX = 100000;\n\t\n    public static void main(String[] args) throws IOException{\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tint[] par = new int[MAX];\n    \tUnionFind uf = new UnionFind(MAX);\n    \tboolean[] q_mark = new boolean[MAX];\n    \tint[] q_value = new int[MAX];\n    \tboolean[] marked = new boolean[MAX];\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tfinal int Q = sc.nextInt();\n    \t\t\n    \t\tif(N == 0 && Q == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tArrays.fill(marked, false);\n    \t\tuf.init();\n    \t\tpar[0] = 0;\n    \t\tfor(int i = 1; i < N; i++){\n    \t\t\tpar[i] = sc.nextInt() - 1;\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < Q; i++){\t\n    \t\t\tq_mark[i] = sc.next().equals(\"M\");\n    \t\t\tq_value[i] = sc.nextInt() - 1;\n    \t\t\t\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tmarked[q_value[i]] = true;\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\t//System.out.println(i + \" \" + par[i] + \" \" + marked[i]);\n    \t\t\tif(!marked[i]){\n    \t\t\t\tuf.unite(i, par[i]);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong sum = 0;\n    \t\tfor(int i = Q - 1; i >= 0; i--){\n    \t\t\tif(q_mark[i]){\n    \t\t\t\tuf.unite(q_value[i], par[q_value[i]]);\n    \t\t\t}else{\n    \t\t\t\tsum += uf.find(q_value[i]) + 1;\n    \t\t\t}\n    \t\t\t\n    \t\t\t//for(int j = 0; j < N; j++){\n    \t\t\t//\tSystem.out.print(uf.find(j) + \" \");\n    \t\t\t//}\n    \t\t\t//System.out.println();\n    \t\t}\n    \t\t\n    \t\tSystem.out.println(sum);\n    \t}\n    }\n    \n    public static class Scanner {\n\t\t\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tif (n != 1) {\n\t\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tuf.par[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[0] = true;\n\t\tmark[1] = true;\n\t\tpar[1] = 1;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[par[x]]) {\n\t\t\t\treturn par[x];\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n\t\t// if (a.val > b.val)\n\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id,state;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n\t\t\t// debug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\n\t\tps = null;\n\t\tqueryNode = null;\n\t\tqueryType = null;\n\n\t\t// for (int i = 0; i < n; i++) {\n\t\t// debug(vs[i].id);\n\t\t// for (V v : vs[i]) {\n\t\t// debug(\"\\t\", v.id);\n\t\t// }\n\t\t// debug(vs[i].markedTime);\n\t\t// debug(vs[i].askedTimes);\n\t\t// }\n\t\t// debug(\"aaaaaaaaaaaaa\");\n\n\t\t// vが答えになる\n\t\t// for (int t : v.askedTimes) {\n\t\t// h = meld(h, new Heap(t));\n\t\t// }\n\t\t// for (V u : v) {\n\t\t// h = meld(h, rec(u));\n\t\t// }\n\t\t// for (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t// ans += v.id;\n\t\t// // debug(\"vid\",v.id);\n\t\t// }\n\t\t// return h;\n\n\t\tStack<V> stackV = new Stack<V>();\n//\t\tStack<Integer> stackS = new Stack<Integer>();\n\n\t\tstackV.push(vs[0]);\n//\t\tstackS.push(0);\n\n\t\tfor (; !stackV.isEmpty();) {\n\t\t\tV v = stackV.pop();\n//\t\t\tint state = stackS.pop();\n\t\t\t// debug(v.id, \"state\",state);\n\t\t\tif (v.state == 0) {\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tv.state=1;\n//\t\t\t\tstackS.push(1);\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n//\t\t\t\t\tstackS.push(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h = meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n\t\t\t\t\t// debug(\"vid\",v.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// rec(vs[0]);\n\t\tprintln(ans + \"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main\n{\n    private static int[] id;   // ??¨??\\????????¶??\\????????????\n    private static int[] sz;   // ??¨??\\????????¶??\\???????????§?°?\n    private static int[] parentTree;   // ??¨??\\????????¶??????\n    private static int[] ancestors;     // ??¨??\\??????????????????????????¶??????\n    private static boolean[] marked;   // ??¨??\\???????????????????????¶???\n    private static ArrayList<ArrayList<Integer>> childrenTree = new ArrayList<>();    // ??¨??\\???????????????\n    private static Stack<String> ops = new Stack<String>();                     // ??¨??\\????????????\n    private static Stack<Integer> point = new Stack<Integer>();                 // ??¨??\\???????¢????????????°\n\n    //======================================================\n    // ??¶??\\?????¨??°?????????\n    private static void init(int n)\n    {\n        id = new int[n];\n        sz = new int[n];\n        parentTree = new int[n];\n        ancestors = new int[n];\n        marked = new boolean[n];\n        \n        for (int i = 0; i < n; i++)\n        {\n            id[i] = i;\n            sz[i] = 0;\n            childrenTree.add(new ArrayList<Integer>());\n        }\n    }\n\n    private static int find(int p)\n    {\n        if (id[p] == p) return p;\n        return  id[p] = find(id[p]);\n    }\n\n    private static void union(int p, int q)\n    {\n        int pRoot = find(p);\n        int qRoot = find(q);\n\n        if (pRoot == qRoot) return;\n\n        if (sz[pRoot] > sz[qRoot])\n        {\n            id[qRoot] = pRoot;\n        }\n        else\n        {\n            id[pRoot] = qRoot;\n            if (sz[pRoot] == sz[qRoot]) sz[qRoot]++;\n        }\n    }\n    //====================================================\n\n    // ?????¨??????????????´??°???????????¶??????\n    private static void bsf(int index, int ancestor)\n    {\n        Queue<Integer> qIndex = new LinkedList<Integer>();\n        Queue<Integer> qAncestor = new LinkedList<Integer>();\n\n        qIndex.add(index);\n        qAncestor.add(ancestor);\n\n        while (!qIndex.isEmpty())\n        {\n            index = qIndex.poll();\n            ancestor = qAncestor.poll();\n\n            if (marked[index])\n            {\n                ancestor = index;   // ????????\\???????????????????????´??°??¶??¶??????\n            }\n            ancestors[index] = ancestor;\n            for (int i: childrenTree.get(index))\n            {\n                qIndex.add(i);\n                qAncestor.add(ancestor);\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            if (n == m && n == 0) break;\n\n            // ?????????\n            init(n);\n            for (int i = 1; i < n; i++)\n            {\n                int q = in.nextInt();\n                q--;\n\n                childrenTree.get(q).add(i);\n                parentTree[i] = q;\n            }\n            marked[0] = true;\n            for (int i = 0; i < m; i++)\n            {\n                String q = in.next();\n                int k = in.nextInt(); k--;\n\n                if (q.equals(\"M\"))\n                {\n                    if (marked[k]) continue;\n                    marked[k] = true;\n                }\n\n                ops.push(q);\n                point.push(k);\n            }\n            bsf(0, 0);\n            for (int i = 0; i < n; i++)\n            {   // ?°??????????????????¶??¶???????????\\???????????\\???\n                union(i, ancestors[i]);\n            }\n            long sum = 0;\n            while (!ops.isEmpty())\n            {\n                String q = ops.pop();\n                int k = point.pop();\n                if (q.equals(\"Q\"))\n                {   // ?????°??¶?????????\n                    sum += ancestors[find(k)] + 1;  // ?¢????????§??????????1\n                }\n                else\n                {   // ??????????¨?????°???¶?\\????????????¶??¶??????????\\????\n                    int p = ancestors[find(parentTree[k])];\n                    union(k, parentTree[k]);\n                    ancestors[find(k)] = p;\n                }\n            }\n            System.out.println(sum);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t, int q) {\n\t\tif (q < 0 || q >= t.length) {\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif (t[q] == q) {\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t, t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tm = sc.nextInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tt[i] = sc.nextInt() - 1;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\n\t\t\tint Query[] = new int[m];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tchar c = 0;\n\t\t\t\tint v = 0;\n\t\t\t\ttry {\n\t\t\t\t\tc = sc.next().charAt(0);\n\t\t\t\t\tv = sc.nextInt();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c == 'Q') {\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t} else {\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tif(v-1 < 0 || v-1>= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v - 1] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\td[0] = 0;\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint ii = m - i - 1;\n\n\t\t\t\tif (Query[ii] > 0) {\n\t\t\t\t\tint u = uf(t, Query[ii] - 1);\n\t\t\t\t\tif (u == -1234) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1 + u;\n\n\t\t\t\t} else {\n\t\t\t\t\tint v = -Query[ii] - 1;\n\t\t\t\t\tif( v < 0 || v >= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n\t\t// if (a.val > b.val)\n\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id,state;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n\t\t\t// debug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\n\t\tps = null;\n\t\tqueryNode = null;\n\t\tqueryType = null;\n\n\t\tStack<V> stackV = new Stack<V>();\n\n\t\tstackV.push(vs[0]);\n\n\t\tfor (; !stackV.isEmpty();) {\n\t\t\tV v = stackV.pop();\n\t\t\tif (v.state == 0) {\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tv.state=1;\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h = meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.gc();\n\n\t\tprintln(ans + \"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint N = sc.nextInt();\n\t\t\tint Q = sc.nextInt();\n\t\t\tif((N|Q)==0) break;\n\t\t\tUnionfind uf = new Unionfind(N);\n\t\t\tfor(int i=2;i<=N;i++){\n\t\t\t\tuf.parent[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int mm =0;mm<Q;mm++){\n\t\t\t\tString operation = sc.next();\n\t\t\t\tif(operation.equals(\"Q\")){\n\t\t\t\t\tans += uf.find(sc.nextInt());\n\t\t\t\t}else{\n\t\t\t\t\t//operationがMのとき\n\t\t\t\t\tuf.mark[sc.nextInt()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\nclass Unionfind{\n\tpublic int parent[];\n\tpublic boolean mark[];\n\n\tUnionfind(int n){\n\t\tparent = new int[n+1];\n\t\tmark = new boolean[n+1];\n\t\tmark[1] = true;\n\t\tparent[1] = 1;\n\t}\n\n\t//木の根を求める\n\tpublic int find(int x){\n\t\tfor(;;){\n\t\t\tif(mark[x]){\n\t\t\t\treturn  x;\n\t\t\t}else{\n\t\t\t\tx = parent[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int n = sc.nextInt();\n            int q = sc.nextInt();\n            if ((n | q) == 0)\n                break;\n            UnionFind uf = new UnionFind(n);\n            if (n != 1) {\n                for (int i = 2; i <= n; i++) {\n                    int p = sc.nextInt();\n                    uf.par[i] = p;\n                }\n            }\n            long ans = 0;\n            for (int i = 0; i < q; i++) {\n                String t = sc.next();\n                int v = sc.nextInt();\n                if (t.equals(\"M\"))\n                    uf.mark[v] = true;\n                else\n                    ans += uf.find(v);\n            }\n            System.out.println(ans);\n        }\n    }\n}\n \nclass UnionFind {\n    public int par[];\n    public boolean mark[];\n \n    UnionFind(int n) {\n        par = new int[n + 1];\n        mark = new boolean[n + 1];\n        mark[0] = true;\n        mark[1] = true;\n        par[1] = 1;\n    }\n \n    public int find(int x) {\n        while (true) {\n            if (mark[x]) {\n                return x;\n            } else {\n                x = par[x];\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main implements Runnable {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 1024L * 1024 * 48).start();\n\t}\n\t\n\tpublic void run() {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tint n;\n\tint q;\n\tint[] parent;\n\tArrayList<Integer>[] child;\n\tboolean[] marked;\n\tint[] ma;\n\tArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tmarked = new boolean[n];\n\t\tmarked[0] = true;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tmarked[qVal[i]] = true;\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tUnionFind uf = new UnionFind(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.union(ma[i], i);\n\t\t}\n\t\tlong sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tif (parent[qVal[i]] >= 0) {\n\t\t\t\t\tuf.union(parent[qVal[i]], qVal[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic void dfs(int v) {\n\t\tif (marked[v]) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (marked[v]) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind {\n\tprivate int[] parent;\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tparent = new int[size];\n\t\tdata = new int[size];\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tdata[i] = i;\n\t\t}\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tint nData = data[x];\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] = nData;\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic int get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(parent);\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = in.nextInt();\n\t\t\tint Q = in.nextInt();\n\t\t\tif (N == 0 && Q == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] p = new int[N + 1];\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tp[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tchar[] c = new char[Q + 1];\n\t\t\tint[] v = new int[Q + 1];\n\t\t\tboolean[] marked = new boolean[N + 1];\n\t\t\tmarked[1] = true;\n\t\t\tfor (int j = 1; j <= Q; j++) {\n\t\t\t\tc[j] = in.next().charAt(0);\n\t\t\t\tv[j] = in.nextInt();\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tmarked[v[j]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] parent = new int[N + 1];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tparent[i] = marked[i] ? -1 : p[i];\n\t\t\t}\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor (int j = Q; j >= 1; j--) {\n\t\t\t\tif (c[j] == 'M') {\n\t\t\t\t\tparent[v[j]] = p[v[j]];\n\t\t\t\t}\n\t\t\t\tif (c[j] == 'Q') {\n\t\t\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\tint i = v[j];\n\t\t\t\t\twhile (parent[i] != -1) {\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t\ti = parent[i];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int _i: list) {\n\t\t\t\t\t\tparent[_i] = i;\n\t\t\t\t\t}\n\t\t\t\t\tsum += i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tuf.par[i] = p;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[1] = true;\n\t\tpar[1] = 1;\n\t}\n\n\tpublic int find(int x) {\n\t\tif (mark[par[x]]) {\n\t\t\treturn par[x];\n\t\t} else {\n\t\t\treturn find(par[x]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;public static void main(String[]args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve(in,out);\n\tin.close();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid dump(int[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tvoid dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d\",a[i]);out.println();}\n\tvoid dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tvoid dump(char[]a){for(int i=0;i<a.length;i++)out.print(a[i]);out.println();}\n\tlong pow(long a,long n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tString itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tvoid sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tvoid m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a,j,j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int idx=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[idx++]=a[r++];else b[idx++]=a[l++];}\n\twhile(r<re)b[idx++]=a[r++];while(l<le)b[idx++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tvoid swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tint binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=0,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return a[s]>v?-1:s;}\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solve(ContestScanner in,Writer out)throws NumberFormatException,IOException{\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint q = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\ttree = new List[n];\n\t\t\tms = new int[n];\n\t\t\tqs = new Queue[n];\n\t\t\thmap = new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ttree[i] = new ArrayList<>();\n\t\t\t\tms[i] = -1;\n\t\t\t\tqs[i] = new ArrayDeque<>();\n\t\t\t}\n\t\t\tms[0] = 0;\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tint par = in.nextInt()-1;\n\t\t\t\ttree[par].add(i);\n\t\t\t}\n\t\t\tfor(int i=0; i<q; i++){\n\t\t\t\tchar c = in.nextToken().charAt(0);\n\t\t\t\tint v = in.nextInt()-1;\n\t\t\t\tif(c=='M'){\n\t\t\t\t\tif(ms[v]==-1) ms[v] = i+1;\n\t\t\t\t}else{\n\t\t\t\t\tqs[v].add(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst = new RangeMaximumSegTree(q+1);\n\t\t\tsum = 0;\n\t\t\tdfs(0, 0);\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\tList<Integer>[] tree;\n\tint[] ms;\n\tint[] hmap;\n\tQueue<Integer>[] qs;\n\tRangeMaximumSegTree st;\n\tint sum;\n\tvoid dfs(int v, int dep){\n\t\tif(ms[v]>=0){\n\t\t\tst.set(ms[v], dep);\n\t\t\thmap[dep] = v+1;\n\t\t}\n\t\tfor(int q: qs[v]){\n\t\t\tsum += hmap[st.max(0, q)];\n\t\t}\n\t\tfor(int nv: tree[v]){\n\t\t\tdfs(nv, dep+1);\n\t\t}\n\t\tif(ms[v]>=0){\n\t\t\tst.set(ms[v], -1);\n\t\t}\n\t}\n}\n\nclass RangeMaximumSegTree{\n\tint[] tree;\n\tint size;\n\tint len;\n\tint n;\n\tpublic RangeMaximumSegTree(int n){\n\t\tint beki = 1;\n\t\twhile(beki < n) beki <<= 1;\n\t\tlen = beki<<1;\n\t\tthis.n = n;\n\t\ttree = new int[len];\n\t\tArrays.fill(tree, -1);\n\t\tsize = beki;\n\t}\n\tpublic void set(int id, int x){\n\t\tint i = id | size; tree[i] = x;\n\t\tfor(i>>=1; i>0; i>>=1) tree[i] = Math.max(tree[i<<1], tree[(i<<1)+1]);\n\t}\n\tpublic int get(int id){\n\t\treturn tree[id|size];\n\t}\n\t// in idx: left to right\n\tpublic int max(int left, int right){\n\t\tint res = -1;\n\t\tleft |= size;\n\t\tright|= size;\n\t\tright++;\n\t\twhile(left < right){\n\t\t\tif((right&1) == 1) res = Math.max(res, tree[--right]);\n\t\t\tif((left&1) == 1) res = Math.max(res, tree[left++]);\n\t\t\tright >>= 1;\n\t\t\tleft >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic String output(int idx){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=size; i<=size+idx; i++) sb.append(tree[i]+\" \");\n\t\treturn sb.toString();\n\t}\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int e=2, s=1; e<=len; e<<=1){\n\t\t\tfor(;s<e; s++) sb.append(tree[s]).append(\" \");\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key)\n\t{final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n\tpublic String toString() {return String.format(\"(%d, %d)\", a, b);}\n}\nclass Timer{\n\tlong time;\n\tpublic void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print()\n\t{System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint[] par = new int[100001];\n\t\n\tint find(int i) {\n\t\tif (i == par[i])return i;\n\t\treturn find(par[i]);\n\t}\n\t\n\tvoid mark(int i) {\n\t\tpar[i] = i;\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), q = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tpar[1] = 1;\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\tpar[i+1] = sc.nextInt();\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tif (sc.next().equals(\"Q\")) {\n\t\t\t\t\tres += find(sc.nextInt());\n\t\t\t\t} else {\n\t\t\t\t\tmark(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.print(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic final int POP = 10000000;\n\tstatic final int INF = 1 << 30;\n\tstatic int N, Q;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tQ = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> child = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> query = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchild.add(new ArrayList<Integer>());\n\t\t\tquery.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tchild.get(p).add(i);\n\t\t}\n\t\tArrayList<Integer> node = new ArrayList<Integer>();\n\t\tArrayList<Integer> sort = new ArrayList<Integer>();\n\t\tnode.add(0);\n\t\twhile (!node.isEmpty()) {\n\t\t\tint cur = node.get(node.size() - 1);\n\t\t\tnode.remove(node.size() - 1);\n\t\t\tsort.add(cur);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnode.add(POP + cur);\n\t\t\tfor (int i = child.get(cur).size() - 1; i >= 0; --i) {\n\t\t\t\tnode.add(child.get(cur).get(i));\n\t\t\t}\n\t\t}\n\n\t\tint[] mark = new int[N];\n\t\tmark[0] = -1;\n\t\tArrays.fill(mark, INF);\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar type = sc.nextChar();\n\t\t\tint n = sc.nextInt() - 1;\n\t\t\tif (type == 'Q') {\n\t\t\t\tquery.get(n).add(i);\n\t\t\t} else {\n\t\t\t\tmark[n] = Math.min(i, mark[n]);\n\t\t\t}\n\t\t}\n\n\t\tint[] time = new int[N];\n\t\tint[] markedNode = new int[N];\n\t\tint[] pos = new int[N];\n\t\tint[] prevTime = new int[N];\n\t\tint[] prevMarkedNode = new int[N];\n\t\tint[] prevSize = new int[N];\n\t\ttime[0] = -1;\n\t\tmarkedNode[0] = 0;\n\t\tint size = 1;\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tint cur = sort.get(i);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcur -= POP;\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\ttime[pos[cur]] = prevTime[cur];\n\t\t\t\t\tmarkedNode[pos[cur]] = prevMarkedNode[cur];\n\t\t\t\t\tsize = prevSize[cur];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int q : query.get(cur)) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = size;\n\t\t\t\t\twhile (lo + 1 < hi) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (q < time[mi]) {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += markedNode[lo] + 1;\n\t\t\t\t}\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\tprevSize[cur] = size;\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = size;\n\t\t\t\t\twhile (left + 1 < right) {\n\t\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\t\tif (mark[cur] < time[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[cur] = right;\n\t\t\t\t\tprevTime[cur] = time[right];\n\t\t\t\t\tprevMarkedNode[cur] = markedNode[right];\n\t\t\t\t\ttime[right] = mark[cur];\n\t\t\t\t\tmarkedNode[right] = cur;\n\t\t\t\t\tsize = right + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint b = input.read();\n\t\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tif (b == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tb = input.read();\n\t\t\t\t} else if (b == '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tint ret = b - '0';\n\t\t\t\twhile (true) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += b - '0';\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\ttry {\n\t\t\t\tint b = input.read();\n\t\t\t\twhile (Character.isWhitespace(b)) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\treturn (char) b;\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static IO io = new IO();\n    private static int p[] = new int[100001];   // p[i]: parent of i-th node\n    private static boolean mark[] = new boolean[100001];\n    public static void main(String[] args) {\n\n        p[1] = 1;\n        while (true) {\n\n            int n = io.nextInt();\n            int q = io.nextInt();\n            if (n==0) break;\n            for (int i=2; i<=n; i++) p[i] = io.nextInt();\n            long ans = 0;\n            for (int i=0; i<q; i++) {\n                char ope = io.nextChar();\n                int v = io.nextInt();\n                if (ope=='M') {\n                    mark[v] = true;\n                } else {\n                    ans += find(v);\n                }\n            }\n            System.out.println(ans);\n            Arrays.fill(mark, false);\n\n        }\n\n    }\n\n    static int find(int x) {\n        Deque<Integer> que = new ArrayDeque<Integer>();\n        que.offer(x);\n        int ans = 0;\n        while (!que.isEmpty()) {\n            int poll = que.poll();\n            if (p[poll] == poll || mark[poll]) ans = poll;\n            else que.offer(p[poll]);\n        }\n        return ans;\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean isNewLine(int c) {\n            return c == '\\n' || c == '\\r';\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        void skipNewLine() {\n            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        boolean hasNextLine() {\n            skipNewLine();\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        char[] nextCharArray(int len) {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                if (i == len) {\n                    throw new InputMismatchException();\n                }\n                s[i++] = (char) b;\n                b = readByte();\n            }\n            return s;\n        }\n\n        String nextLine() {\n            if (!hasNextLine()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isNewLine(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString input = br.readLine();\n\n\t\t\tif(input == null){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString[] tmpArray = input.split(\" \");\n\n\t\t\tint n = Integer.parseInt(tmpArray[0]);\n\t\t\tint q = Integer.parseInt(tmpArray[1]);\n\n\t\t\tif(n == 0 && q == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNode[] nodes = new Node[n + 1];\n\t\t\tnodes[0] = new Node(0, -1);\n\t\t\tnodes[0].marked = true;\n\n\t\t\tnodes[1] = new Node(1, 0);\n\t\t\tnodes[1].marked = true;\n\n\t\t\tfor(int i = 2; i <= n; i++){\n\t\t\t\tint num = Integer.parseInt(br.readLine());\n\n\t\t\t\tnodes[i] = new Node(i, num);\n\t\t\t}\n\n\t\t\tlong sum = 0;\n\n\t\t\tfor(int i = 0; i < q; i++){\n\t\t\t\ttmpArray = br.readLine().split(\" \");\n\t\t\t\tint tmp = Integer.parseInt(tmpArray[1]);\n\t\t\t\tif(tmpArray[0].equals(\"M\")){\n\t\t\t\t\tnodes[tmp].marked = true;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tsum += nearest(nodes, tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tstatic int nearest(Node[] nodes, int id){\n\t\twhile(true){\n\n//\t\t\tSystem.out.println(\"id = \"+id);\n\n\t\t\tif(nodes[id].marked){\n\t\t\t\treturn id;\n\t\t\t}\n\n\t\t\tid = nodes[id].parent;\n\t\t}\n\t}\n\n}\n\nclass Node {\n\tint id;\n\tint parent;\n\tboolean marked = false;\n\n\tpublic Node(int id, int parent){\n\t\tthis.id = id;\n\t\tthis.parent = parent;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tsc.nextLine();\n\n\t\t\tStack<int[]> op = new Stack<int[]>();\n\t\t\tStack<int[]> mkdnd = new Stack<int[]>();\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = new Integer(d[2] - '0');\n\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tint[] t = {0, n, getParent(n)};\n\t\t\t\t\t\top.push(t);\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tint[] f = {1, n};\n\t\t\t\t\t\top.push(f);\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\twhile(!op.empty()){\n\t\t\t\tint[] o = op.pop();\n\t\t\t\tswitch(o[0]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t//case 'M':\n\t\t\t\t\t\tsetParent(o[1], o[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t//case 'Q':\n\t\t\t\t\t\tres = res + gmRoot(o[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic int gmRoot(int node){\n\t\tint res = -2;\n\t\tint p = getParent(node);\n\n\t\tif(p == 0){\n\t\t\tres = node;\t\t\t\n\t\t}else{\n\t\t\tres = gmRoot(p);\n\t\t\tsetParent(node, res);\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint[] par;\n\t\n\tint find(int i) {\n\t\tif (i == par[i])return i;\n\t\treturn find(par[i]);\n\t}\n\t\n\tvoid mark(int i) {\n\t\tpar[i] = i;\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), q = sc.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tpar = new int[n+1];\n\t\t\tpar[1] = 1;\n\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\tpar[i+1] = sc.nextInt();\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tif (sc.next().equals(\"Q\")) {\n\t\t\t\t\tres += find(sc.nextInt());\n\t\t\t\t} else {\n\t\t\t\t\tmark(sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.print(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Marked Ancestor\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N, Q;\n\t\t\tN = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tQ = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((N | Q) == 0) break;\n\n\t\t\tNode[] nodes = new Node[N + 1];\n\t\t\tfor (int i = 0; i < nodes.length; i++) {\n\t\t\t\tnodes[i] = main.new Node(i);\n\t\t\t}\n\n\t\t\tnodes[1].p = nodes[0];\n\t\t\tfor (int i = 2; i <= N; i++) {\n\t\t\t\tint p = parseInt(br.readLine());\n\t\t\t\tnodes[i].p = nodes[p];\n\t\t\t}\n\n\t\t\tnodes[1].marked = true;\n\t\t\tlong sum = 0;\n\t\t\tfor (int i = 0; i < Q; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tchar o = line.charAt(0);\n\t\t\t\tint v = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\t\tif (o == 'M') {\n\t\t\t\t\tnodes[v].marked = true;\n\t\t\t\t} else {\n\t\t\t\t\tNode node = nodes[v];\n\t\t\t\t\twhile (node.id != 0 && !node.marked) {\n\t\t\t\t\t\tnode = node.p;\n\t\t\t\t\t}\n\t\t\t\t\tsum += node.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t} //end while\n\t} //end main\n\n\tclass Node {\n\t\tint id;\n\t\tboolean marked = false;\n\t\tNode p;\n\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tuf.par[i] = p;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[1] = true;\n\t\tpar[1] = 1;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[par[x]]) {\n\t\t\t\treturn par[x];\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\npublic class Main {\n\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint N = sc.nextInt();\n\t\t\tint Q = sc.nextInt();\n\t\t\tif((N|Q)==0) break;\n\t\t\tUnionfind uf = new Unionfind(N);\n\t\t\tfor(int i=2;i<=N;i++){\n\t\t\t\tuf.parent[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int mm =0;mm<Q;mm++){\n\t\t\t\tString operation = sc.next();\n\t\t\t\tif(operation.equals(\"Q\")){\n\t\t\t\t\tans += uf.find(sc.nextInt());\n\t\t\t\t}else{\n\t\t\t\t\t//operationがMのとき\n\t\t\t\t\tuf.mark[sc.nextInt()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\nclass Unionfind{\n\tpublic int parent[];\n\tpublic boolean mark[];\n\n\tUnionfind(int n){\n\t\tparent = new int[n+1];\n\t\tmark = new boolean[n+1];\n\t\tmark[1] = true;\n\t\tparent[1] = 1;\n\t}\n\n\t//木の根を求める\n\tpublic int find(int x){\n\t\tif(mark[x]){\n\t\t\treturn  x;\n\t\t}else{\n\t\t\treturn x = find(parent[x]);\n\t\t}\n\t}\n}\n\n/*//xとyの属する属性の併合\n\t\tstatic void unite(int x, int y){\n\t\t\tx = find(x);//xの親ノードが属性だから\n\t\t\ty = find(y);\n\t\t\tif(x==y){\n\t\t\t\t//OK\n\t\t\t}else{\n\t\t\t\tif(rank[x]<rank[y]){\n\t\t\t\t\tparent[x] = y;\n\t\t\t\t}else{\n\t\t\t\t\tparent[y] = x;\n\t\t\t\t\tif(rank[x]==rank[y]){\n\t\t\t\t\t\trank[x]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//xとyが同じ属性に属するかどうか\n\t\tstatic boolean isSame(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}*/"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t, int q) {\n\t\tif (q < 0 || q >= t.length) {\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif (t[q] == q) {\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t, t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tm = sc.nextInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tt[i] = sc.nextInt() - 1;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\n\t\t\tint Query[] = new int[m];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tchar c = 0;\n\t\t\t\tint v = 0;\n\t\t\t\ttry {\n\t\t\t\t\tc = sc.next().charAt(0);\n\t\t\t\t\tv = sc.nextInt();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c == 'Q') {\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t} else {\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v - 1] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint ii = m - i - 1;\n\n\t\t\t\tif (Query[ii] > 0) {\n\t\t\t\t\tint u = uf(t, Query[ii] - 1);\n\t\t\t\t\tif (u == -1234) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1 + u;\n\n\t\t\t\t} else {\n\t\t\t\t\tint v = -Query[ii] - 1;\n\t\t\t\t\tif( v < 0 || v >= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tsc.nextLine();\n\n\t\t\tStack<int[]> op = new Stack<int[]>();\n\t\t\tStack<int[]> mkdnd = new Stack<int[]>();\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = new Integer(d[2] - '0');\n\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tint[] t = {0, n, getParent(n)};\n\t\t\t\t\t\top.push(t);\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tint[] f = {1, n};\n\t\t\t\t\t\top.push(f);\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\twhile(!op.empty()){\n\t\t\t\tint[] o = op.pop();\n\t\t\t\tswitch(o[0]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t//case 'M':\n\t\t\t\t\t\tsetParent(o[1], o[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t//case 'Q':\n\t\t\t\t\t\tres = res + gmRoot(o[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic int gmRoot(int node){\n\t\tint res = -2;\n\t\tint p = getParent(node);\n\n\t\tif(p == 0){\n\t\t\tres = node;\t\t\t\n\t\t}else{\n\t\t\tres = gmRoot(p);\n\t\t\tsetParent(node, res);\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass UnionFindTree {\n\t\tint[] parent;\n\t\t\n\t\tpublic UnionFindTree(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < parent.length; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (parent[x] == x) return x;\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x, int y) {\n\t\t\tint xx = find(x), yy = find(y);\n\t\t\tif (xx == yy) return;\n\t\t\tparent[xx] = yy;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(parent);\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), Q = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint[] par = new int[N];\n\t\t\tfor (int i = 1; i < N; i++) {\n\t\t\t\tpar[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tint[] count = new int[N];\n\t\t\tchar[] command = new char[Q];\n\t\t\tint[] id = new int[Q];\n\t\t\tfor (int i = 0; i < Q; i++) {\n\t\t\t\tcommand[i] = in.next().charAt(0);\n\t\t\t\tid[i] = in.nextInt() - 1;\n\t\t\t\tif (command[i] == 'M') {\n\t\t\t\t\tcount[id[i]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFindTree uft = new UnionFindTree(N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (count[i] == 0)\n\t\t\t\t\tuft.unite(i, par[i]);\n\t\t\t}\n\t\t\t\n\t\t\tlong res = 0;\n\t\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\t\tif (command[i] == 'M') {\n\t\t\t\t\tcount[id[i]]--;\n\t\t\t\t\tif (count[id[i]] == 0) \n\t\t\t\t\t\tuft.unite(id[i], par[id[i]]);\n\t\t\t\t} else {\n\t\t\t\t\tres += uft.find(id[i]) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t, int q) {\n\t\tif (q < 0 || q >= t.length) {\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif (t[q] == q) {\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t, t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tm = sc.nextInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tt[i] = sc.nextInt() - 1;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\n\t\t\tint Query[] = new int[m];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tchar c = 0;\n\t\t\t\tint v = 0;\n\t\t\t\ttry {\n\t\t\t\t\tc = sc.next().charAt(0);\n\t\t\t\t\tv = sc.nextInt();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c == 'Q') {\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t} else {\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tif(v-1 < 0 || v>= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v - 1] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\td[0] = 0;\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint ii = m - i - 1;\n\n\t\t\t\tif (Query[ii] > 0) {\n\t\t\t\t\tint u = uf(t, Query[ii] - 1);\n\t\t\t\t\tif (u == -1234) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1 + u;\n\n\t\t\t\t} else {\n\t\t\t\t\tint v = -Query[ii] - 1;\n\t\t\t\t\tif( v < 0 || v >= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] marked = new int[MAX_N];\n\tprivate final int[] parent = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tArrays.fill(marked, 0, n, - 1);\n\t\t\tmarked[0] = - 2;\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tisQuery[i] = IN.next().charAt(0) == 'Q';\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif(!isQuery[i] && marked[v[i]] == - 1) {\n\t\t\t\t\t\n\t\t\t\t\tmarked[v[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\t\n\t\t\t\tif (marked[i] == - 1) {\n\t\t\t\t\t\n\t\t\t\t\tparent[i] = p[i - 1];\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tparent[i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += find(v[i]) + 1;\n\t\t\t\t\t\n\t\t\t\t} else if (marked[v[i]] == i) {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] == x) {\n\t\t\t\n\t\t\treturn x;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\ty = find(y);\n\t\tparent[x] = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n/** @see http://d.hatena.ne.jp/komiyam/20120402/1333373895 */\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint INF = 1 << 28;\n\tdouble EPS = 1e-12;\n\n\tint n, q;\n\tint[] ps;\n\tint[] queryType, queryNode;\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tq = sc.nextInt();\n\t\t\tif ((n | q) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tps = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tps[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tqueryType = new int[q];\n\t\t\tqueryNode = new int[q];\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tqueryType[i] = sc.next().charAt(0) == 'M' ? 0 : 1;\n\t\t\t\tqueryNode[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tclass Heap {\n\t\tHeap l, r;\n\t\tint val;\n\n\t\tHeap(int _val) {\n\t\t\tval = _val;\n\t\t}\n\n\t\tint top() {\n\t\t\treturn val;\n\t\t}\n\n\t\tHeap push(int val) {\n\t\t\treturn meld(this, new Heap(val));\n\t\t}\n\n\t\tHeap pop() {\n\t\t\treturn meld(l, r);\n\t\t}\n\t}\n\n\tHeap meld(Heap a, Heap b) {\n\t\tif (a == null)\n\t\t\treturn b;\n\t\tif (b == null)\n\t\t\treturn a;\n\t\t// if (a.val > b.val)\n\t\tif (-a.val > -b.val)\n\t\t\treturn meld(b, a);\n\t\ta.r = meld(a.r, b);\n\t\tHeap t = a.l;\n\t\ta.l = a.r;\n\t\ta.r = t;\n\t\t// swap(a.l, a.r);\n\t\treturn a;\n\t}\n\n\tclass V extends ArrayList<V> {\n\t\tHeap h;\n\t\tint id,state;\n\t\tint markedTime;\n\t\tArrayList<Integer> askedTimes = new ArrayList<Integer>();\n\n\t\tV(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tlong ans;\n\n\tHeap rec(V v) {\n\t\t// vが答えになる\n\t\tHeap h = null;\n\t\tfor (int t : v.askedTimes) {\n\t\t\th = meld(h, new Heap(t));\n\t\t}\n\t\tfor (V u : v) {\n\t\t\th = meld(h, rec(u));\n\t\t}\n\t\tfor (; h != null && h.top() > v.markedTime; h = h.pop()) {\n\t\t\tans += v.id;\n\t\t\t// debug(\"vid\",v.id);\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid solve() {\n\t\tans = 0;\n\t\tV[] vs = new V[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tvs[i] = new V(i + 1);\n\t\t\tvs[i].markedTime = INF;\n\t\t}\n\t\t// root = 1(0)\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\t// ps[i]\n\t\t\tvs[ps[i]].add(vs[i]);\n\t\t}\n\t\tvs[0].markedTime = -1;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint v = queryNode[i], tick = i + 1;\n\t\t\tif (queryType[i] == 0) {\n\t\t\t\t// mark\n\t\t\t\tvs[v].markedTime = min(vs[v].markedTime, tick);\n\t\t\t} else {\n\t\t\t\t// query\n\t\t\t\tvs[v].askedTimes.add(tick);\n\t\t\t}\n\t\t}\n\n\t\tps = null;\n\t\tqueryNode = null;\n\t\tqueryType = null;\n\n\t\tSystem.gc();\n\n\t\tStack<V> stackV = new Stack<V>();\n\n\t\tstackV.push(vs[0]);\n\n\t\tfor (; !stackV.isEmpty();) {\n\t\t\tV v = stackV.pop();\n\t\t\tif (v.state == 0) {\n\t\t\t\t// 最初\n\t\t\t\tfor (int t : v.askedTimes) {\n\t\t\t\t\tv.h = meld(v.h, new Heap(t));\n\t\t\t\t}\n\t\t\t\tstackV.push(v);\n\t\t\t\tv.state=1;\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tstackV.push(u);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// さいき＼(^o^)／\n\t\t\t\tfor (V u : v) {\n\t\t\t\t\tv.h = meld(v.h, u.h);\n\t\t\t\t}\n\t\t\t\tfor (; v.h != null && v.h.top() > v.markedTime; v.h = v.h.pop()) {\n\t\t\t\t\tans += v.id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.gc();\n\n\t\tprintln(ans + \"\");\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s) {\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s) {\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic final int POP = 10000000;\n\tstatic final int INF = 1 << 30;\n\tstatic int N, Q;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tQ = sc.nextInt();\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic long solve() {\n\t\tArrayList<ArrayList<Integer>> child = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> query = new ArrayList<ArrayList<Integer>>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchild.add(new ArrayList<Integer>());\n\t\t\tquery.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tchild.get(p).add(i);\n\t\t}\n\t\tArrayList<Integer> node = new ArrayList<Integer>();\n\t\tArrayList<Integer> sort = new ArrayList<Integer>();\n\t\tnode.add(0);\n\t\twhile (!node.isEmpty()) {\n\t\t\tint cur = node.get(node.size() - 1);\n\t\t\tnode.remove(node.size() - 1);\n\t\t\tsort.add(cur);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnode.add(POP + cur);\n\t\t\tfor (int i = child.get(cur).size() - 1; i >= 0; --i) {\n\t\t\t\tnode.add(child.get(cur).get(i));\n\t\t\t}\n\t\t}\n\n\t\tint[] mark = new int[N];\n\t\tArrays.fill(mark, INF);\n\t\tmark[0] = -1;\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tchar type = sc.nextChar();\n\t\t\tint n = sc.nextInt() - 1;\n\t\t\tif (type == 'Q') {\n\t\t\t\tquery.get(n).add(i);\n\t\t\t\tif (n == 0) throw new RuntimeException(\"haaaaa??\");\n\t\t\t} else {\n\t\t\t\tmark[n] = Math.min(i, mark[n]);\n\t\t\t}\n\t\t}\n\n\t\tint[] time = new int[N];\n\t\tint[] markedNode = new int[N];\n\t\tint[] pos = new int[N];\n\t\tint[] prevTime = new int[N];\n\t\tint[] prevMarkedNode = new int[N];\n\t\tint[] prevSize = new int[N];\n\t\ttime[0] = -1;\n\t\tmarkedNode[0] = 0;\n\t\tint size = 1;\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < 2 * N; ++i) {\n\t\t\tint cur = sort.get(i);\n\t\t\tif (cur >= POP) {\n\t\t\t\tcur -= POP;\n\t\t\t\tif (mark[cur] != INF) {\n\t\t\t\t\ttime[pos[cur]] = prevTime[cur];\n\t\t\t\t\tmarkedNode[pos[cur]] = prevMarkedNode[cur];\n\t\t\t\t\tsize = prevSize[cur];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int q : query.get(cur)) {\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = size;\n\t\t\t\t\twhile (lo + 1 < hi) {\n\t\t\t\t\t\tint mi = (lo + hi) / 2;\n\t\t\t\t\t\tif (q < time[mi]) {\n\t\t\t\t\t\t\thi = mi;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlo = mi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans += markedNode[lo] + 1;\n\t\t\t\t}\n\t\t\t\tif (mark[cur] != INF && mark[cur] != -1) {\n\t\t\t\t\tprevSize[cur] = size;\n\t\t\t\t\tint left = 0;\n\t\t\t\t\tint right = size;\n\t\t\t\t\twhile (left + 1 < right) {\n\t\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\t\tif (mark[cur] < time[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos[cur] = right;\n\t\t\t\t\tprevTime[cur] = time[right];\n\t\t\t\t\tprevMarkedNode[cur] = markedNode[right];\n\t\t\t\t\ttime[right] = mark[cur];\n\t\t\t\t\tmarkedNode[right] = cur;\n\t\t\t\t\tsize = right + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint b = input.read();\n\t\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tif (b == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tb = input.read();\n\t\t\t\t} else if (b == '+') {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\tint ret = b - '0';\n\t\t\t\twhile (true) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += b - '0';\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\ttry {\n\t\t\t\tint b = input.read();\n\t\t\t\twhile (Character.isWhitespace(b)) {\n\t\t\t\t\tb = input.read();\n\t\t\t\t}\n\t\t\t\treturn (char) b;\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.lang.ArrayIndexOutOfBoundsException;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\tpublic static ArrayList<ArrayList<Integer>> g;\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\twhile(true){\n\t\t\tint in[] = readIntMap();\n\t\t\tint n = in[0], q = in[1];\n\t\t\tif(n == 0 && q == 0) return;\n\t\t\t\n\t\t\tboolean[] color = new boolean[n];\n\t\t\tcolor[0] = true;\n\t\t\tint[] parent = new int[n];\n\t\t\t\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint p = readInt();\n\t\t\t\tparent[i] = p-1;\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i < q; i++){\n\t\t\t\tString[] ins = readLine().split(\" \");\n\t\t\t\tchar op = ins[0].charAt(0);\n\t\t\t\tint node = parseInt(ins[1]) - 1;\n\t\t\t\tif(op == '0' && node == -1) return;\n\t\t\t\tif(op == 'M'){\n\t\t\t\t\tcolor[node] = true;\n\t\t\t\t}else{\n\t\t\t\t\tint j = node;\n\t\t\t\t\twhile(!color[j]) j = parent[j];\n\t\t\t\t\tans += j + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp(ans);\n\t\t}\n\t}\n}\n\n\n/**\n * Set周りは未実装\n * @author yoshikyoto\n */\nclass UnionFindTree{\n    public int[] parent, rank;\n    public int n;\n    public Set<Integer> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n        \tparent = new int[n];\n        \trank = new int[n];\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n        }else{\n            parent[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    boolean same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\n\n/**\n * 整数を数え上げたりするクラス\n * new Prime(int n) でnまでエラトステネスの篩を実行。\n * @author yoshikyoto\n * @param a[i] iが素数の時true\n * @param count[i] i以下の素数の数\n */\nclass Prime{\n\tboolean[] a;\n\tint[] count;\n\tPrime(int n){\n\t\ta = new boolean[n+1];\n\t\ta[0] = false; a[1] = false;\n\t\tfor(int i = 2; i <= n; i++) a[i] = true;\n\t\t// ふるい\n\t\tfor(int i = 2; i < (n - 3) / 2; i++)\n\t\t\tif(a[i]) for(int j = 2; j * i <= n; j++)\n\t\t\t\t\ta[j * i] = false;\n\t\t\n\t\t// 数え上げ\n\t\tcount = new int[n+1];\n\t\tcount[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint gain = 0;\n\t\t\tif(a[i]) gain = 1;\n\t\t\tcount[i] = count[i-1] + gain;\n\t\t}\n\t}\n}\n\nclass AI extends ArrayList<Integer>{}\nclass SI extends Stack<Integer>{}\n\nclass HMI<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n\nclass HMSI extends HMI<String>{}\nclass Q<E> extends ArrayDeque<E>{\n\tpublic void push(E item){add(item);}\n\tpublic E pop(){return poll();}\n}\nclass QS extends Q<String>{}\nclass QI extends Q<Integer>{}\n\nclass MyUtil extends MyIO{\n\tpublic static long start_time = 0;\n\tpublic static void start(){start_time = System.currentTimeMillis();}\n\tpublic static void end(){\n\t\tif(start_time == 0) return;\n\t\tlong time = System.currentTimeMillis() - start_time;\n\t\tif(DEBUG) p(time + \"ms\");\n\t}\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){\n\t\tStringBuffer sb = new StringBuffer(s);\n\t\treturn sb.reverse().toString();\n\t}\n\tpublic static void sort(int[] a){Arrays.sort(a);}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n}\n\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static boolean DEBUG = false;\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static void p(Object o){System.out.println(o.toString());}\n\tpublic static void pr(Object o){System.out.print(o.toString());}\n\tpublic static void d(Object o){if(DEBUG)System.out.println(o.toString());}\n\tpublic static void dr(Object o){if(DEBUG)System.out.print(o.toString());}\n\tpublic static void da(Object[] o){if(DEBUG)System.out.println(Arrays.toString(o));}\n\tpublic static void da(int[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(double[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static void da(boolean[] arr){if(DEBUG)System.out.println(Arrays.toString(arr));}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n\nclass MyMath{\n\t/**\n\t * 弧度法の角度を入力してsinの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double sin(int r){return Math.sin(Math.toRadians(r));}\n\n\t/**\n\t * 弧度法の角度を入力してcosの値を返す（Math.sin の入力はラジアン）\n\t */\n\tpublic static double cos(int r){return Math.cos(Math.toRadians(r));}\n\tpublic static int max(int a, int b){return Math.max(a, b);}\n\tpublic static int min(int a, int b){return Math.min(a, b);}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    // 並行な場合\n\t    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t    if(m == 0) return false;\n\t    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t    return (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t    if((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t    else return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){\n\t\treturn sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){\n\t\treturn Math.sqrt(sqdist(x1, y1, x2, y2));}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t, int q) {\n\t\tif (q < 0 || q >= t.length) {\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif (t[q] == q) {\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t, t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tm = sc.nextInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tt[i] = sc.nextInt() - 1;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\n\t\t\tint Query[] = new int[m];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tchar c = 0;\n\t\t\t\tint v = 0;\n\t\t\t\ttry {\n\t\t\t\t\tc = sc.next().charAt(0);\n\t\t\t\t\tv = sc.nextInt();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c == 'Q') {\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t} else {\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v - 1] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint ii = m - i - 1;\n\n\t\t\t\tif (Query[ii] > 0) {\n\t\t\t\t\tint u = uf(t, Query[ii] - 1);\n\t\t\t\t\tif (u == -1234) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1 + u;\n\n\t\t\t\t} else {\n\t\t\t\t\tint v = -Query[ii] - 1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.function.BinaryOperator;\n\npublic class Main {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tstatic int n;\n\tstatic int q;\n\tstatic int[] parent;\n\tstatic ArrayList<Integer>[] child;\n\tstatic boolean[] marked;\n\tstatic int[] ma;\n\tstatic ArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tmarked = new boolean[n];\n\t\tmarked[0] = true;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tmarked[qVal[i]] = true;\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tInteger[] init = new Integer[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tinit[i] = i;\n\t\t}\n\t\tUnionFind<Integer> uf = new UnionFind<Integer>(init,Math::min);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.merge(i, ma[i]);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tuf.merge(qVal[i], parent[qVal[i]]);\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic static void dfs(int v) {\n\t\tif (marked[v]) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (marked[v]) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind<T> {\n\tprivate int[] parent;\n\tprivate T[] data;\n\tBinaryOperator<T> mergeFunction;\n\n\t/**\n\t * @param mergeFunction (larger,smaller) -> merged\n\t */\n\tpublic UnionFind(T[] data,BinaryOperator<T> mergeFunction) {\n\t\tint n = data.length;\n\t\tthis.data = data;\n\t\tthis.mergeFunction = mergeFunction;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean merge(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tdata[x] = mergeFunction.apply(data[x], data[y]);\n\t\t\tparent[y] = x;\n\t\t\tdata[y] = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic T get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic int groupSize(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic ArrayList<T> datas() {\n\t\tArrayList<T> ret = new ArrayList<>();\n\t\tfor(T x:data) {\n\t\t\tif (x != null) {\n\t\t\t\tret.add(x);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn datas().toString();\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\n/**\n * \n * @author DemonSong\n * \n *         2170. Marked Ancestor\n * \n *         Problem F: Marked Ancestor You are given a tree T that consists of N\n *         nodes. Each node is numbered from 1 to N, and node 1 is always the\n *         root node of T. Consider the following two operations on T:\n * \n *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest\n *         marked ancestor of node v which is nearest to it. Initially, only the\n *         root node is marked. Your job is to write a program that performs a\n *         sequence of these operations on a given tree and calculates the value\n *         that each Q operation will print. To avoid too large output file,\n *         your program is requested to print the sum of the outputs of all\n *         query operations. Note that the judges confirmed that it is possible\n *         to calculate every output of query operations in a given sequence.\n * \n *         Input The input consists of multiple datasets. Each dataset has the\n *         following format:\n * \n *         The first line of the input contains two integers N and Q, which\n *         denotes the number of nodes in the tree T and the number of\n *         operations, respectively. These numbers meet the following\n *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.\n * \n *         The following N - 1 lines describe the configuration of the tree T.\n *         Each line contains a single integer pi (i = 2, ... , N), which\n *         represents the index of the parent of i-th node.\n * \n *         The next Q lines contain operations in order. Each operation is\n *         formatted as \"M v\" or \"Q v\", where v is the index of a node.\n * \n *         The last dataset is followed by a line containing two zeros. This\n *         line is not a part of any dataset and should not be processed.\n * \n *         Output For each dataset, print the sum of the outputs of all query\n *         operations in one line.\n * \n *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample\n *         Input 4\n *\n */\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\t\n\t\twhile (true){\n\t\t\tString[] line = in.nextLine().trim().split(\" \");\n\t\t\tint N = Integer.parseInt(line[0]);\n\t\t\tint Q = Integer.parseInt(line[1]);\n\t\t\tint[] union = new int[N];\n\t\t\tif (N == 0 && Q == 0) break;\n\t\t\tunion[0] = 0;\n\t\t\tfor (int i = 1; i <N; i++){\n\t\t\t\tunion[i] = Integer.parseInt(in.nextLine())-1;\n\t\t\t}\n\t\t\tString[][] ops = new String[Q][2];\n\t\t\tfor (int i = 0; i < Q; i++){\n\t\t\t\tline = in.nextLine().trim().split(\" \");\n\t\t\t\tops[i][0] = line[0];\n\t\t\t\tops[i][1] = line[1];\n\t\t\t}\n\t\t\tSystem.out.println(solve(union, ops));\n\t\t\t\n\t\t}\n\t\tin.close();\n\t}\n\t\n\tprivate static int solve(int[] union, String[][] ops){\n\t\t\n\t\tint res = 0;\n\t\tfor (int i = 0; i < ops.length; i++){\n\t\t\tif (ops[i][0].equals(\"M\")){\n\t\t\t\tint id = Integer.parseInt(ops[i][1])-1;\n\t\t\t\tunion[id] = - union[id];\n\t\t\t}\n\t\t\t\n\t\t\tif (ops[i][0].equals(\"Q\")){\n\t\t\t\tint id = Integer.parseInt(ops[i][1])-1;\n\t\t\t\tres += find(union, id);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate static int find(int[] union, int id){\n\t\tint next = union[id];\n\t\twhile (next < 0){\n\t\t\tnext = union[-next];\n\t\t}\n\t\treturn next;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\tint n=sc.nextInt();//the number of nodes\n\t\tint q=sc.nextInt();//the number of operations\n\t\tif(n==0&&q==0)break;\n\t\tint[] d=new int[n];\n\t\tint[] marked=new int[n];\n\t\tmarked[0]++;\n\t\tDJSet ds=new DJSet(n);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint parent=sc.nextInt()-1;\n\t\t\td[i]=parent;\n\t\t}\n\t\tint[] memo=new int[q];\n\t\tchar[] j=new char[q];\n\t\tfor(int i=0;i<q;i++){\n\t\t\tString str=sc.next();\n\t\t\tj[i]=str.charAt(0);\n\t\t\tint v=sc.nextInt()-1;\n\t\t\tmemo[i]=v;\n\t\t\tif(str.equals(\"M\"))marked[v]++;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tif(marked[i]>0)continue;\n\t\t\tds.setUnion(i, d[i]);\n\t\t}\n\t\tlong ans=0;\n\t\tfor(int i=q-1;i>=0;i--){\n\t\t\tif(j[i]=='Q'){\n\t\t\t\tans+=find_ancestor(memo[i],d,marked)+1;\n\t\t\t}else if(j[i]=='M'){\n\t\t\t\tmarked[memo[i]]--;\n\t\t\t\tif(marked[memo[i]]==0){\n\t\t\t\t\tds.setUnion(memo[i],d[memo[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tint find_ancestor(int x,int[] d,int[] marked){\n\t\twhile(marked[x]==0){\n\t\t\tx=d[x];\n\t\t}\n\t\treturn x;\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n\tclass DJSet{\n\t\tint n;//the number of vertices\n\t\tint[] d;\n\t\tDJSet(int n){\n\t\t\tthis.n=n;\n\t\t\td=new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn d[x]<0?x:root(d[x]);\n\t\t}\n\t\tboolean setUnion(int x,int y){\n\t\t\tx=root(x);\n\t\t\ty=root(y);\n\t\t\tif(x!=y){\n\t\t\t\tif(x<y){\n\t\t\t\t\tint d=x;\n\t\t\t\t\tx=y;\n\t\t\t\t\ty=d;\n\t\t\t\t}\n//\t\t\t\tx>y\n\t\t\t\td[y]+=d[x];\n\t\t\t\td[x]=y;\n\t\t\t}\n\t\t\treturn x!=y;\n\t\t}\n\t\tboolean same(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint size(int x){\n\t\t\treturn d[root(x)]*(-1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\n\npublic class Main {\n\t//union-find treeの生成\n\tstatic int parent[] = new int[100001];//親ノード,indexの0番目は考えない\n\tstatic int rank[] = new int[100001];//木の深さ\n\t//n要素で初期化\n\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tparent[1] = 1;\n\t\trank[1] = 1;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tparent[i] = sc.nextInt();\n\t\t\trank[i] = rank[parent[i]]+1;\n\t\t}\n\t\tint[] ini_parent = parent.clone();\n\t\tint[] ini_rank = rank.clone();\n\t\tint ans=0;\n\t\tList<Integer> mark = new ArrayList<Integer>();\n\t\tmark.add(1);\n\t\tfor(int mm =0;mm<Q;mm++){\n\t\t\tString operation = sc.next();\n\t\t\tif(operation.equals(\"Q\")){\n\t\t\t\tparent = ini_parent.clone();\n\t\t\t\trank = ini_rank.clone();\n\t\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\t\tif(mark.contains(i)){\n\t\t\t\t\t\tparent[i]=i;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tunite(i,parent[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += find(sc.nextInt());\n\t\t\t}else{\n\t\t\t\t//operationがMのとき\n\t\t\t\tmark.add(sc.nextInt());\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic void init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\n\t//木の根を求める\n\tstatic int find(int x){\n\t\tif(parent[x] ==x){\n\t\t\treturn  x;\n\t\t}else{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\t//xとyの属する属性の併合\n\tstatic void unite(int x, int y){\n\t\tx = find(x);//xの親ノードが属性だから\n\t\ty = find(y);\n\t\tif(x==y){\n\t\t\t//OK\n\t\t}else{\n\t\t\tif(rank[x]<rank[y]){\n\t\t\t\tparent[x] = y;\n\t\t\t}else{\n\t\t\t\tparent[y] = x;\n\t\t\t\tif(rank[x]==rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//xとyが同じ属性に属するかどうか\n\tstatic boolean isSame(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass UnionFindTree {\n\t\tint[] parent;\n\t\t\n\t\tpublic UnionFindTree(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < parent.length; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (parent[x] == x) return x;\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x, int y) {\n\t\t\tint xx = find(x), yy = find(y);\n\t\t\tif (xx == yy) return;\n\t\t\tparent[xx] = yy;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(parent);\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), Q = in.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\t\n\t\t\tint[] par = new int[N];\n\t\t\tfor (int i = 1; i < N; i++) {\n\t\t\t\tpar[i] = in.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint[] count = new int[N];\n\t\t\tchar[] command = new char[Q];\n\t\t\tint[] id = new int[Q];\n\t\t\tfor (int i = 0; i < Q; i++) {\n\t\t\t\tcommand[i] = in.next().charAt(0);\n\t\t\t\tid[i] = in.nextInt();\n\t\t\t\tif (command[i] == 'M') {\n\t\t\t\t\tcount[id[i]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFindTree uft = new UnionFindTree(N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (count[i] == 0)\n\t\t\t\t\tuft.unite(i, par[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tfor (int i = Q - 1; i >= 0; i--) {\n\t\t\t\tif (command[i] == 'M') {\n\t\t\t\t\tcount[id[i]]--;\n\t\t\t\t\tif (count[id[i]] == 0) \n\t\t\t\t\t\tuft.unite(id[i], par[id[i]]);\n\t\t\t\t} else {\n\t\t\t\t\tres += uft.find(id[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tif (n != 1) {\n\t\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tuf.par[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[0] = true;\n\t\tmark[1] = true;\n\t\tpar[1] = 1;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[x]) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    int q = scan.nextInt();\n    Node[] nodes = new Node[n];\n    nodes[0] = new Node();\n    nodes[0].mark = true;\n    nodes[0].num = 0;\n    for(int i = 1; i < n; i++) {\n      nodes[i] = new Node();\n      nodes[i].num = i;\n      nodes[scan.nextInt()-1].setChild(nodes[i]);\n    }\n    long result = 0;\n    for(int i = 0; i < q; i++) {\n      switch(scan.next()) {\n        case \"Q\":\n          result += (long)(nodes[scan.nextInt()-1].saiki()+1);\n          break;\n        case \"M\":\n          nodes[scan.nextInt()-1].mark = true;\n          break;\n      }\n    }\n    System.out.println(result);\n  }\n}\n\nclass Node{\n  Node parent;\n  boolean mark;\n  int num;\n  Node() {\n  }\n  void setChild(Node _node) {\n    _node.parent = this;\n  }\n  int saiki() {\n    return (mark)?num:parent.saiki();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.function.BinaryOperator;\n\npublic class Main implements Runnable {\n\tstatic IO io = new IO();\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 1024L * 1024 * 48).start();\n\t}\n\t\n\tpublic void run() {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tint n;\n\tint q;\n\tint[] parent;\n\tArrayList<Integer>[] child;\n\tboolean[] marked;\n\tint[] ma;\n\tArrayDeque<Integer> stack;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic boolean solve() {\n\t\tn = io.nextInt();\n\t\tq = io.nextInt();\n\t\tif (n == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tchild = new ArrayList[n];\n\t\tparent = new int[n];\n\t\tparent[0] = -1;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tchild[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tparent[i] = p;\n\t\t\tchild[p].add(i+1);\n\t\t}\n\t\tchar[] qType = new char[q];\n\t\tint[] qVal = new int[q];\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tqType[i] = io.nextChar();\n\t\t\tqVal[i] = io.nextInt() - 1;\n\t\t}\n\t\tmarked = new boolean[n];\n\t\tmarked[0] = true;\n\t\tfor(int i=0;i<q;i++) {\n\t\t\tif (qType[i] == 'M') {\n\t\t\t\tmarked[qVal[i]] = true;\n\t\t\t}\n\t\t}\n\t\tstack = new ArrayDeque<>();\n\t\tma = new int[n];\n\t\tdfs(0);\n\t\tInteger[] init = new Integer[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tinit[i] = i;\n\t\t}\n\t\tUnionFind<Integer> uf = new UnionFind<Integer>(init,Math::min);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tuf.merge(i, ma[i]);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=q-1;i>=0;i--) {\n\t\t\tif (qType[i] == 'Q') {\n\t\t\t\tsum += uf.get(qVal[i]) + 1;\n\t\t\t}else{\n\t\t\t\tif (parent[qVal[i]] >= 0) {\n\t\t\t\t\tuf.merge(qVal[i], parent[qVal[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.println(sum);\n\t\treturn true;\n\t}\n\t\n\n\tpublic void dfs(int v) {\n\t\tif (marked[v]) {\n\t\t\tstack.push(v);\n\t\t}\n\t\tma[v] = stack.peek();\n\t\tfor(int c: child[v]) {\n\t\t\tdfs(c);\n\t\t}\n\t\tif (marked[v]) {\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n}\nclass UnionFind<T> {\n\tprivate int[] parent;\n\tprivate T[] data;\n\tBinaryOperator<T> mergeFunction;\n\n\t/**\n\t * @param mergeFunction (larger,smaller) -> merged\n\t */\n\tpublic UnionFind(T[] data,BinaryOperator<T> mergeFunction) {\n\t\tint n = data.length;\n\t\tthis.data = data;\n\t\tthis.mergeFunction = mergeFunction;\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t}\n\tpublic boolean merge(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (parent[y] < parent[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tparent[x] += parent[y];\n\t\t\tdata[x] = mergeFunction.apply(data[x], data[y]);\n\t\t\tparent[y] = x;\n\t\t\tdata[y] = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tpublic int root(int x) {\n\t\treturn parent[x] < 0 ? x : (parent[x] = root(parent[x]));\n\t}\n\tpublic T get(int x) {\n\t\treturn data[root(x)];\n\t}\n\tpublic int groupSize(int x) {\n\t\treturn -parent[root(x)];\n\t}\n\tpublic ArrayList<ArrayList<Integer>> groups() {\n\t\tint n = parent.length;\n\t\tArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>();\n\t\tHashMap<Integer,Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint r = root(i);\n\t\t\tif (!hm.containsKey(r)) {\n\t\t\t\thm.put(r, g.size());\n\t\t\t\tg.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tg.get(hm.get(r)).add(i);\n\t\t}\n\t\treturn g;\n\t}\n\tpublic ArrayList<T> datas() {\n\t\tArrayList<T> ret = new ArrayList<>();\n\t\tfor(T x:data) {\n\t\t\tif (x != null) {\n\t\t\t\tret.add(x);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic String toString() {\n\t\treturn datas().toString();\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint nodenum = sc.nextInt();\n\t\t\tint qnum = sc.nextInt();\n\t\t\tif(nodenum == 0 && qnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinitData(nodenum);\n\n\t\t\tfor(int i = 2; i <= nodenum; i++){\n\t\t\t\tsetParent(i, sc.nextInt());\n\t\t\t}\n\t\t\tsc.nextLine();\n\n\t\t\tStack<int[]> op = new Stack<int[]>();\n\t\t\tfor(int i = 0; i < qnum; i++){\n\t\t\t\tchar[] d = sc.nextLine().toCharArray();\n\t\t\t\tint n = 0;\n\t\t\t\tfor(int j = d.length - 2; j >= 2; j--){\n\t\t\t\t\tint power = 1;\n\t\t\t\t\tfor(int k = j ; k < d.length - 1; k++){\n\t\t\t\t\t\tpower = power * 10;\n\t\t\t\t\t}\n\t\t\t\t\tn = n + (new Integer(d[j] - '0')) * power;\n\t\t\t\t}\n\t\t\t\tswitch(d[0]){\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tint[] t = {0, n, getParent(n)};\n\t\t\t\t\t\top.push(t);\n\t\t\t\t\t\tmark(n);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tint[] f = {1, n};\n\t\t\t\t\t\top.push(f);\n\t\t\t\t\t\tbreak;\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint res = 0;\n\t\t\twhile(!op.empty()){\n\t\t\t\tint[] o = op.pop();\n\t\t\t\tswitch(o[0]){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t//case 'M':\n\t\t\t\t\t\tsetParent(o[1], o[2]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t//case 'Q':\n\t\t\t\t\t\tres = res + gmRoot(o[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tstatic int gmRoot(int node){\n\t\tint res = -2;\n\t\tint p = getParent(node);\n\n\t\tif(p == 0){\n\t\t\tres = node;\t\t\t\n\t\t}else{\n\t\t\tres = gmRoot(p);\n\t\t\tsetParent(node, res);\n\t\t}\n\n\t\treturn res;\n\t}\n\t\n\tstatic int[] data;\n\tstatic void initData(int nodenum){\n\t\tdata = new int[nodenum];\n\t\tdata[0] = -1;\n\t}\n\tstatic int getParent(int node){\n\t\treturn data[node - 1] + 1;\n\t}\n\tstatic void setParent(int node, int parent){\n\t\tdata[node - 1] = parent - 1;\n\t}\n\tstatic void mark(int node){\n\t\tdata[node - 1] = -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tif ((n | q) == 0)\n\t\t\t\tbreak;\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tif (n != 1) {\n\t\t\t\tfor (int i = 2; i <= n; i++) {\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tuf.par[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < q; i++) {\n\t\t\t\tString t = sc.next();\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif (t.equals(\"M\"))\n\t\t\t\t\tuf.mark[v] = true;\n\t\t\t\telse\n\t\t\t\t\tans += uf.find(v);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic boolean mark[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n + 1];\n\t\tmark = new boolean[n + 1];\n\t\tmark[0] = true;\n\t\tmark[1] = true;\n\t\tpar[1] = 1;\n\t}\n\n\tpublic int find(int x) {\n\t\twhile (true) {\n\t\t\tif (mark[x]) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\tx = par[x];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tnew Main().run();\n\t}\n\t\n\tprivate static final int MAX_N = 100000;\n\tprivate static final int MAX_Q = 100000;\n\t\n\tprivate int n;\n\tprivate int q;\n\t\n\tprivate final int[] p = new int[MAX_N - 1];\n\tprivate final boolean[] isQuery = new boolean[MAX_Q];\n\tprivate final int[] v = new int[MAX_Q];\n\t\n\tprivate final int[] parent = new int[MAX_N];\n\t\n\tprivate void run() {\n\t\t\n\t\twhile(((n = IN.nextInt()) | (q = IN.nextInt())) != 0) {\n\t\t\t\n\t\t\tparent[0] = 0;\n\t\t\tfor (int i = 0; i < n - 1; i ++) {\n\t\t\t\t\n\t\t\t\tp[i] = parent[i + 1] = IN.nextInt() - 1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < q; i ++) {\n\t\t\t\t\n\t\t\t\tif (IN.next().charAt(0) == 'Q') {\n\t\t\t\t\t\n\t\t\t\t\tisQuery[i] = true;\n\t\t\t\t}\n\t\t\t\tv[i] = IN.nextInt() - 1;\n\t\t\t\tif (!isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tparent[v[i]] = v[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinitialize();\n\t\t\t\n\t\t\tint summation = 0;\n\t\t\tfor (int i = q - 1; i >= 0; i --) {\n\t\t\t\t\n\t\t\t\tif (isQuery[i]) {\n\t\t\t\t\t\n\t\t\t\t\tsummation += find(v[i]) + 1;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tunion(v[i], p[v[i] - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(summation);\n\t\t}\n\t}\n\t\n\tprivate static final Scanner IN = new Scanner(System.in);\n\t\n\tprivate final int[] rank = new int[MAX_N];\n\t\n\tprivate void initialize() {\n\t\t\n\t\tArrays.fill(rank, 0);\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\t\n\t\t\tinitialize(i, 0);\n\t\t}\n\t}\n\t\n\tprivate void initialize(int i, int r) {\n\t\t\n\t\tif (i == parent[i]) {\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ti = parent[i];\n\t\tr ++;\n\t\tif (rank[i] < r) {\n\t\t\t\n\t\t\trank[i] = r;\n\t\t\tinitialize(i,r);\n\t\t}\n\t}\n\t\n\tprivate int find(int x) {\n\t\t\n\t\tif (parent[x] == x) {\n\t\t\t\n\t\t\treturn x;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tprivate void union(int x, int y) {\n\t\t\n\t\ty = find(y);\n\t\t\n\t\tif (rank[x] < rank[y]) {\n\t\t\t\n\t\t\tparent[x] = y;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tparent[y] = x;\n\t\t\t\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\n\t\t\t\trank[x] ++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t , int q){\n\t\tif(t[q] == q){\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t,t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\t\n\tvoid run() {\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor(int i =1 ; i< n ;i++){\n\t\t\t\tt[i] = sc.nextInt()-1;\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint Query[] = new int[m];\n\t\t\t\n\t\t\tfor(int i = 0; i< m; i++){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tint v = sc.nextInt();\n\t\t\t\tif(c=='Q'){\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t}else{\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tt[v-1] = v-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint ii = m-i-1;\n\t\t\t\t\n\t\t\t\tif(Query[ii] > 0){\n\t\t\t\t\tans += 1+uf(t,Query[ii]-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v = -Query[ii]-1;\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint uf(int[] t, int q) {\n\t\tif (q < 0 || q >= t.length) {\n\t\t\tSystem.out.println(\"assertion\");\n\t\t\treturn -1234;\n\t\t}\n\t\tif (t[q] == q) {\n\t\t\treturn q;\n\t\t}\n\t\tint v = uf(t, t[q]);\n\t\tt[q] = v;\n\t\treturn v;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = 0;\n\t\t\tint m = 0;\n\t\t\ttry {\n\t\t\t\tn = sc.nextInt();\n\t\t\t\tm = sc.nextInt();\n\t\t\t} catch (Exception e) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[] t = new int[n];\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tt[i] = sc.nextInt() - 1;\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\td[i] = t[i];\n\t\t\t}\n\n\t\t\tint Query[] = new int[m];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tchar c = 0;\n\t\t\t\tint v = 0;\n\t\t\t\ttry {\n\t\t\t\t\tc = sc.next().charAt(0);\n\t\t\t\t\tv = sc.nextInt();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (c == 'Q') {\n\t\t\t\t\tQuery[i] = v;\n\t\t\t\t} else {\n\t\t\t\t\tQuery[i] = -v;\n\t\t\t\t\tif(v-1 < 0 || v-1>= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v - 1] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt[0] = 0;\n\t\t\td[0] = 0;\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint ii = m - i - 1;\n\t\t\t\tif(ii < 0 || ii >= t.length){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (Query[ii] > 0) {\n\t\t\t\t\tint u = uf(t, Query[ii] - 1);\n\t\t\t\t\tif (u == -1234) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tans += 1 + u;\n\n\t\t\t\t} else {\n\t\t\t\t\tint v = -Query[ii] - 1;\n\t\t\t\t\tif( v < 0 || v >= t.length){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tt[v] = d[v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    bool[] marked;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            marked = new bool[N + 1];\n            parent = new int[N + 1];\n            marked[1] = true;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var type = new string[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                type[i] = read.String();\n                index[i] = read.Int();\n                if (type[i] == \"M\") { marked[index[i]] = true; }\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (type[i] == \"M\") { marked[index[i]] = false; }\n                else { ans += GetParent(index[i]); }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        int p = parent[i];\n        while (!marked[p]) { p = parent[p]; }\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = parent[i];\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            if (N == 100000) throw new Exception();\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        int p = parent[i];\n        while (markCount[p] == 0) { p = parent[p]; }\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    bool[] marked;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            marked = new bool[N + 1];\n            parent = new int[N + 1];\n            marked[1] = true;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var type = new string[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                type[i] = read.String();\n                index[i] = read.Int();\n                if (type[i] == \"M\") { marked[index[i]] = true; }\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (type[i] == \"M\") { marked[index[i]] = false; }\n                else { ans += DFS(index[i]); }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int DFS(int i)\n    {\n        return parent[i] = (marked[parent[i]]) ? parent[i] : DFS(parent[i]);\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        int count = 0;\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            if (++count == 5) Console.WriteLine(\"yey!\");\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        int p = parent[i];\n        while (markCount[p] == 0) { p = parent[p]; }\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) break;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n    }\n\n    private void Calc()\n    {\n        for (int i = 1; i < N; i++)\n            MarkedAncestor[i] = Parent[i];\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M')\n                if (MarkedAncestor[Qwho[i]] == Qwho[i]) Qtype[i] = '-';\n                else MarkedAncestor[Qwho[i]] = Qwho[i];\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + Rec(Qwho[i]);\n            else if (Qtype[i] == 'M')\n                MarkedAncestor[Qwho[i]] = MarkedAncestor[Parent[Qwho[i]]];\n        Console.WriteLine(ans);\n    }\n\n    int Rec(int v)\n    {\n        if (MarkedAncestor[v] == v) return v;\n        return MarkedAncestor[v] = Rec(MarkedAncestor[v]);\n    }\n\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        if (markCount[i] > 0) return i;\n        int p = i;\n        var list = new List<int>();\n        while (markCount[p] == 0)\n        {\n            list.Add(p);\n            p = parent[p];\n        }\n        list.ForEach(x => parent[x] = p);\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        int p = i;\n        var list = new List<int>();\n        while (markCount[p] == 0)\n        {\n            list.Add(p);\n            p = parent[p];\n        }\n        list.ForEach(x => parent[x] = p);\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    static readonly int Unknown = -1;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        new Thread(Solve2, 64 * 1000 * 1000).Start();\n    }\n\n    public void Solve2()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) return;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n    }\n\n    private void Calc()\n    {\n        MarkedAncestor[0] = 0;\n        for (int i = 1; i < N; i++)\n            MarkedAncestor[i] = Unknown;\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M') MarkedAncestor[Qwho[i]] = Qwho[i];\n\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + WhoMarked(Qwho[i]);\n            else\n                MarkedAncestor[Qwho[i]] = Unknown;\n        Console.WriteLine(ans);\n    }\n\n    private int WhoMarked(int v)\n    {\n        int a = MarkedAncestor[v];\n        if (a != Unknown && MarkedAncestor[a] == a) return a;\n        return MarkedAncestor[v] = WhoMarked(Parent[v]);\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\n\nnamespace Program\n{\n\n    public class Solver\n    {\n        public void Solve()\n        {\n            while (true)\n            {\n                var n = sc.Integer();\n                var m = sc.Integer();\n                if (n == 0 || m == 0) return;\n                var par = new int[n];\n                par[0] = -1;\n                var marked = new bool[n];\n                marked[0] = true;\n                for (int i = 1; i < n; i++)\n                {\n                    var p = sc.Integer() - 1;\n                    par[i] = p;\n                }\n                var type = new int[m];\n                var vertex = new int[m];\n                for (int i = 0; i < m; i++)\n                {\n                    type[i] = sc.Char() == 'Q' ? 1 : 2;\n                    vertex[i] = sc.Integer() - 1;\n                    if (type[i] == 2)\n                    {\n                        if (marked[vertex[i]])\n                            vertex[i] = -1;\n                        else marked[vertex[i]] = true;\n                    }\n                }\n                var set = new DisjointSet(n);\n                var root = Enumerate(n, x => -114514);\n                for (int i = 0; i < n; i++)\n                {\n                    if (marked[i])\n                    {\n                        root[set[i]] = i;\n                        continue;\n                    }\n                    var r = root[set[par[i]]];\n                    set.Unite(i, par[i]);\n                    root[set[i]] = r;\n                }\n                var ans = 0L;\n                for (int i = m - 1; i >= 0; i--)\n                {\n                    if (type[i] == 1)\n                    {\n                        var r = root[set[vertex[i]]];\n                        ans += r + 1;\n                    }\n                    else\n                    {\n                        if (vertex[i] == -1) continue;\n                        var v = vertex[i];\n                        var p = par[v];\n                        var r = root[set[p]];\n                        set.Unite(v, p);\n                        root[set[v]] = r;\n                    }\n                }\n                IO.Printer.Out.WriteLine(ans);\n            }\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n\n\n}\n\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer : StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(Scan(), CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region DisjointSet\npublic class DisjointSet\n{\n    int[] par, ranks, count;\n    public DisjointSet(int n)\n    {\n        par = new int[n];\n        count = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            par[i] = i;\n            count[i] = 1;\n        }\n        ranks = new int[n];\n    }\n    public int this[int id] { get { return (par[id] == id) ? id : this[par[id]]; } }\n    public bool Unite(int x, int y)\n    {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (ranks[x] < ranks[y])\n        {\n            par[x] = y;\n            count[y] += count[x];\n        }\n        else\n        {\n            par[y] = x;\n            count[x] += count[y];\n            if (ranks[x] == ranks[y])\n                ranks[x]++;\n        }\n        return true;\n    }\n    public int Size(int x) { return count[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    bool[] marked;\n    List<int>[] child;\n    int[] nearestParent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            child = Enumerable.Range(0, N + 1).Select(i => new List<int>()).ToArray();\n            marked = new bool[N + 1];\n            nearestParent = new int[N + 1];\n\n            for (int i = 2; i <= N; i++)\n            {\n                child[read.Int()].Add(i);\n                nearestParent[i] = 1;\n            }\n            int ans = 0;\n            while (Q-- > 0)\n            {\n                string s = read.String();\n                int i = read.Int();\n                if (s == \"M\") { marked[i] = true; DFS(i, i); }\n                else { ans += nearestParent[i]; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    void DFS(int i, int parent)\n    {\n        foreach (var c in child[i])\n        {\n            if (!marked[c] && nearestParent[c] != parent) DFS(c, parent);\n            nearestParent[c] = parent;\n        }\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        Console.WriteLine(\"hello\");\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { Console.WriteLine(\"hello\"); new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        int p = i;\n        int count = 0;\n        while (markCount[p] == 0)\n        {\n            if (++count > N) Console.WriteLine(\"hello\");\n            p = parent[p];\n        }\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        \n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read(Console.In);\n    class Read\n    {\n        private readonly TextReader reader;\n        public Read(TextReader r)\n        {\n            Console.WriteLine(\"hello\");\n            reader = r;\n        }\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        int count = 0;\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            if (++count == 10) Console.WriteLine(\"yey!\");\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        if (markCount[i] > 0) return i;\n        return parent[i] = GetParent(parent[i]);\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read(Console.In);\n    class Read\n    {\n        private readonly TextReader reader;\n        public Read(TextReader r) { reader = r; }\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            Console.WriteLine(\"hello\");\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read(Console.In);\n    class Read\n    {\n        private readonly TextReader reader;\n        public Read(TextReader r) { reader = r; }\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    static readonly int Unknown = -1;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkCount = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        new Thread(Solve2, 64 * 1000 * 1000).Start();\n    }\n\n    public void Solve2()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) break;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n    }\n\n    private void Calc()\n    {\n        MarkCount[0] = 1;\n        MarkedAncestor[0] = 0;\n        for (int i = 1; i < N; i++)\n        {\n            MarkCount[i] = 0;\n            MarkedAncestor[i] = Unknown;\n        }\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M')\n            {\n                MarkCount[Qwho[i]]++;\n                MarkedAncestor[Qwho[i]] = Qwho[i];\n            }\n\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + WhoMarked(Qwho[i]);\n            else\n                MarkCount[Qwho[i]]--;\n        Console.WriteLine(ans);\n    }\n\n    private int WhoMarked(int v, int depth = 1)\n    {\n        int a = MarkedAncestor[v];\n        if (a != Unknown && MarkCount[a] > 0) return a;\n        return MarkedAncestor[v] = WhoMarked(Parent[v], depth + 1);\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        Console.WriteLine(\"hello\");\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        Console.WriteLine(\"hello\");\n\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read(Console.In);\n    class Read\n    {\n        private readonly TextReader reader;\n        public Read(TextReader r) { reader = r; }\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        int count = 0;\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            if (++count == 1) Console.WriteLine(\"yey!\");\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    bool[] marked;\n    List<int>[] child;\n    int[] nearestParent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            child = Enumerable.Range(0, N + 1).Select(i => new List<int>()).ToArray();\n            marked = new bool[N + 1];\n            nearestParent = new int[N + 1];\n\n            for (int i = 2; i <= N; i++)\n            {\n                child[read.Int()].Add(i);\n                nearestParent[i] = 1;\n            }\n            long ans = 0;\n            while (Q-- > 0)\n            {\n                string s = read.String();\n                int i = read.Int();\n                if (s == \"M\") { marked[i] = true; BFS(i); }\n                else { ans += nearestParent[i]; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    void BFS(int parent)\n    {\n        marked[parent] = true;\n        Queue<int> que = new Queue<int>();\n        que.Enqueue(parent);\n        while (que.Count > 0)\n        {\n            int i = que.Dequeue();\n            foreach (int j in child[i])\n            {\n                if (!marked[j] && nearestParent[j] != parent)\n                    que.Enqueue(j);\n                nearestParent[j] = parent;\n            }\n        }\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        int count = 0;\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            if (++count == 2) Console.WriteLine(\"yey!\");\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main() { Console.WriteLine(\"hello\"); }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    static readonly int Unknown = -1;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkCount = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        //Reader.Set(@\"D:\\DL\\2170-input.txt\");\n        new Thread(Solve2, 10 * 1000 * 1000).Start();\n    }\n\n    public void Solve2()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) break;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n        Console.ReadLine();\n    }\n\n    private void Calc()\n    {\n        MarkCount[0] = 1;\n        MarkedAncestor[0] = 0;\n        for (int i = 1; i < N; i++)\n        {\n            MarkCount[i] = 0;\n            MarkedAncestor[i] = Unknown;\n        }\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M')\n            {\n                MarkCount[Qwho[i]]++;\n                MarkedAncestor[Qwho[i]] = Qwho[i];\n            }\n\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + WhoMarked(Qwho[i]);\n            else\n                MarkCount[Qwho[i]]--;\n        Console.WriteLine(ans);\n    }\n\n    private int WhoMarked(int v, int depth = 1)\n    {\n        int a = MarkedAncestor[v];\n        if (a != Unknown && MarkCount[a] > 0) return a;\n        return MarkedAncestor[v] = WhoMarked(Parent[v], depth + 1);\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read(Console.In);\n    class Read\n    {\n        private readonly TextReader reader;\n        public Read(TextReader r) { reader = r; }\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { } // { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    static readonly int Unknown = -1;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkCount = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        //Reader.Set(@\"D:\\DL\\2170-input.txt\");\n        new Thread(Solve2, 256 * 1000 * 1000).Start();\n    }\n\n    public void Solve2()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) break;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n        Console.ReadLine();\n    }\n\n    private void Calc()\n    {\n        MarkCount[0] = 1;\n        MarkedAncestor[0] = 0;\n        for (int i = 1; i < N; i++)\n        {\n            MarkCount[i] = 0;\n            MarkedAncestor[i] = Unknown;\n        }\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M')\n            {\n                MarkCount[Qwho[i]]++;\n                MarkedAncestor[Qwho[i]] = Qwho[i];\n            }\n\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + WhoMarked(Qwho[i]);\n            else\n                MarkCount[Qwho[i]]--;\n        Console.WriteLine(ans);\n    }\n\n    private int WhoMarked(int v, int depth = 1)\n    {\n        int a = MarkedAncestor[v];\n        if (a != Unknown && MarkCount[a] > 0) return a;\n        return MarkedAncestor[v] = WhoMarked(Parent[v], depth + 1);\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        int p = i;\n        int[] a = new int[N];\n        int ai = 0;\n        while (markCount[p] == 0)\n        {\n            a[ai++] = p;\n            p = parent[p];\n        }\n        for (int j = 0; j < ai; j++) parent[a[j]] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while (true)\n        {\n            N = read.Int();\n            Q = read.Int();\n            if (N == 0) break;\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            Console.WriteLine(\"yey!\");\n            //long ans = 0;\n            //for (int i = Q - 1; i >= 0; i--)\n            //{\n            //    if (isQuery[i]) { ans += GetParent(index[i]); }\n            //    else { markCount[index[i]]--; }\n            //}\n            //Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    static readonly int Unknown = -1;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkCount = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) break;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n        Console.ReadLine();\n    }\n\n    private void Calc()\n    {\n        MarkCount[0] = 1;\n        MarkedAncestor[0] = 0;\n        for (int i = 1; i < N; i++)\n        {\n            MarkCount[i] = 0;\n            MarkedAncestor[i] = Unknown;\n        }\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M')\n            {\n                MarkCount[Qwho[i]]++;\n                MarkedAncestor[Qwho[i]] = Qwho[i];\n            }\n\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + WhoMarked(Qwho[i]);\n            else\n                MarkCount[Qwho[i]]--;\n        Console.WriteLine(ans);\n    }\n\n    private int WhoMarked(int v, int depth = 1)\n    {\n        int a = MarkedAncestor[v];\n        if (a != Unknown && MarkCount[a] > 0) return a;\n        return MarkedAncestor[v] = WhoMarked(Parent[v], depth + 1);\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\nusing System.Threading;\n\npublic class Program\n{\n    static readonly int MaxN = (int)1e5;\n    static readonly int MaxQ = (int)1e5;\n    static readonly int Unknown = -1;\n    int N, Q;\n    int[] Parent = new int[MaxN];\n    int[] MarkedAncestor = new int[MaxN];\n    char[] Qtype = new char[MaxQ];\n    int[] Qwho = new int[MaxQ];\n\n    public void Solve()\n    {\n        new Thread(Solve2, 64 * 1000 * 1000).Start();\n    }\n\n    public void Solve2()\n    {\n        while (true)\n        {\n            N = Reader.Int();\n            Q = Reader.Int();\n            if (N == 0) return;\n            for (int i = 1; i < N; i++)\n                Parent[i] = Reader.Int() - 1;\n            for (int i = 0; i < Q; i++)\n            {\n                Qtype[i] = Reader.String()[0];\n                Qwho[i] = Reader.Int() - 1;\n            }\n            Calc();\n        }\n    }\n\n    private void Calc()\n    {\n        MarkedAncestor[0] = 0;\n        for (int i = 1; i < N; i++)\n            MarkedAncestor[i] = Unknown;\n        for (int i = 0; i < Q; i++)\n            if (Qtype[i] == 'M') MarkedAncestor[Qwho[i]] = Qwho[i];\n\n        long ans = 0;\n        for (int i = Q - 1; i >= 0; i--)\n            if (Qtype[i] == 'Q')\n                ans += 1 + WhoMarked(Qwho[i]);\n            else\n                MarkedAncestor[Qwho[i]] = Unknown;\n        Console.WriteLine(ans);\n    }\n\n    private int WhoMarked(int v)\n    {\n        int a = MarkedAncestor[v];\n        if (a != Unknown && MarkedAncestor[a] == a) return a;\n        return MarkedAncestor[v] = WhoMarked(Parent[v]);\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static T[] Range<T>(int N, Func<T> f) { return Enu.Range(0, N).Select(i => f()).ToArray(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst int MAX_N = 100010;\nstruct UnionFind {\n    int node[MAX_N];\n    UnionFind() {}\n    void init() {\n        memset(node, -1, sizeof(node));\n    }\n\n    int find(int x) {\n        return (node[x] < 0 ? x : node[x] = find(node[x]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -node[find(x)];\n    }\n\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(same(x, y)) return;\n        // y を x に統合\n        node[x] += node[y];\n        node[y] = x;\n    }\n};\n\nstruct Query {\n    // q: mark -> 0, query -> 1\n    int q, v;\n    Query() {}\n    Query(int a, int b) : q(a), v(b) {}\n};\n\nvector< vector<int> > G;\nint N, Q, mark[100010], parent[100010];\nQuery qs[100010];\nUnionFind uf;\n\nint main() {\n    while(1) {\n        // init\n        uf.init();\n        memset(mark, 0, sizeof(mark));\n        memset(parent, -1, sizeof(parent));\n        G.clear();\n\n        scanf(\"%d%d\", &N, &Q);\n        if(N == Q && Q == 0) break;\n        G.resize(N);\n\n        for(int i=1; i<N; i++) {\n            int par; scanf(\"%d\", &par); par--;\n            G[par].push_back(i);\n            parent[i] = par;\n        }\n\n        for(int i=0; i<Q; i++) {\n            char mode; int v;\n            scanf(\" %c%d\", &mode, &v); v--;\n            qs[i] = Query(mode == 'Q', v);\n            if(mode == 'M') mark[v]++;\n        }\n\n        for(int i=1; i<N; i++) {\n            if(!mark[i]) {\n                uf.unite(parent[i], i);\n            }\n        }\n\n        ll ans = 0;\n        for(int i=Q-1; i>=0; i--) {\n            // mark\n            if(qs[i].q == 0) {\n                if(--mark[qs[i].v] == 0) {\n                    int par = parent[qs[i].v];\n                    if(par < 0) continue;\n                    uf.unite(par, qs[i].v);\n                }\n            }\n            // query\n            else {\n                ans += uf.find(qs[i].v) + 1;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    int N, Q;\n    int[] markCount;\n    int[] parent;\n\n    void Solve()\n    {\n        while ((N = read.Int()) > 0)\n        {\n            Q = read.Int();\n            markCount = new int[N + 1];\n            parent = new int[N + 1];\n            markCount[1] = 1;\n\n            for (int i = 2; i <= N; i++)\n            {\n                parent[i] = read.Int();\n            }\n            var isQuery = new bool[Q];\n            var index = new int[Q];\n            for (int i = 0; i < Q; i++)\n            {\n                isQuery[i] = read.String() == \"Q\";\n                index[i] = read.Int();\n                if (!isQuery[i]) markCount[index[i]]++;\n            }\n            long ans = 0;\n            for (int i = Q - 1; i >= 0; i--)\n            {\n                if (isQuery[i]) { ans += GetParent(index[i]); }\n                else { markCount[index[i]]--; }\n            }\n            Console.WriteLine(ans);\n        }\n    }\n\n    int GetParent(int i)\n    {\n        var stack = new Stack<int>();\n        int p = i;\n        while (markCount[p] == 0)\n        {\n            stack.Push(p);\n            p = parent[p];\n        }\n        while (stack.Count > 0) parent[stack.Pop()] = p;\n        return parent[i] = p;\n    }\n\n\n    static void Main() { new Program().Solve(); }\n    static Read read = new Read();\n    class Read\n    {\n        private Queue<string> que = new Queue<string>();\n        public string String() { return Dequeue(); }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return Console.ReadLine().Trim(); }\n        private string Dequeue()\n        {\n            if (que.Count == 0) foreach (var s in Line().Split()) que.Enqueue(s);\n            return que.Dequeue();\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "class Module\n  def tco(name)\n    continue = []\n    first = true\n    arguments = nil\n\n    private_name = \"private_\" + name.to_s\n    alias_method private_name, name\n    private private_name\n\n    define_method(name) do |*args|\n      if first\n        first = false\n        while true\n          result = send(private_name, *args)\n          if result.equal? continue\n            args = arguments\n          else\n            first = true\n            return result\n          end\n        end\n      else\n        arguments = args\n        continue\n      end\n    end\n  end\nend\n\n\nclass Solve\n  def parent(x)\n    return x if $mark[x]\n    parent($arr[x])\n  end\n  tco :parent\nend\n\nloop do\n  n, q = gets.split.map(&:to_i)\n  break if n == 0\n  $arr = Array.new(n+1)\n  (2..n).each{ |i| $arr[i] = gets.to_i }\n  $mark = Array.new(n+1)\n  $mark[1] = true\n\n  sum = 0\n  s = Solve.new\n  q.times do\n    cmd, n = gets.split\n    if cmd == 'M'\n      $mark[n.to_i] = true\n    else\n      sum += s.parent(n.to_i)\n    end\n  end\n  p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "def query(x)\n  return x if $mark[x]\n  query($arr[x])\nend\nloop do\n  n, q = gets.split.map(&:to_i)\n  break if n == 0\n  $arr = Array.new(n+1)\n  (2..n).each{ |i| $arr[i] = gets.to_i }\n  $mark = Array.new(n+1)\n  $mark[1] = true\n  sum = 0\n  q.times do\n    cmd, n = gets.split\n    if cmd == 'Q'\n      ans = query(n.to_i)\n      sum += ans\n    else\n      $mark[n.to_i] = true\n    end\n  end\n  p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n\tdef initialize(i)\n\t\t@index = i\n\t\t@children = []\n\tend\n\n\tdef euler(n)\n\t\tif @children.empty?\n\t\t\t@l = n\n\t\t\t@r = n + 1\n\t\t\treturn n + 2\n\t\tend\t\n\t\t@l = n\n\t\tn += 1\n\t\t@children.each do |c|\n\t\t\tn = c.euler(n)\n\t\tend\n\t\t@r = n\n\t\treturn n + 1\n\tend\n\n\tdef compute_depth(d = 0)\n\t\t@depth = d\n\t\t@children.each {|c| c.compute_depth(d+1)}\n\tend\n\n\tattr_accessor :index, :children, :l, :r, :depth\nend\n\nclass SegTree\n\tdef initialize(a, l = 0, r = a.size-1)\n\t\t@l = l\n\t\t@r = r\n\t\tif l == r\n\t\t\t@value = a[l]\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@children = [SegTree.new(a, l, c), SegTree.new(a, c + 1, r)]\t\n\t\tend\n\tend\n\n\tdef update(marked, l = @l, r = @r)\n\t\tforce if @lazy\n\t\tif @l == l && @r == r\n\t\t\t@lazy = marked\n\t\telsif r <= @children[0].r\n\t\t\t@children[0].update(marked, l, r)\n\t\telsif @children[1].l <= l\n\t\t\t@children[1].update(marked, l, r)\n\t\telse\n\t\t\t@children[0].update(marked, l, @children[0].r)\n\t\t\t@children[1].update(marked, @children[1].l, r)\n\t\tend\n\tend\n\n\tdef query(i)\n\t\tforce if @lazy\n\t\tif @l == @r && @l == i\n\t\t\t@value.index\n\t\telsif i <= @children[0].r\n\t\t\t@children[0].query(i)\n\t\telse\n\t\t\t@children[1].query(i)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @l == @r\n\t\t\t@value = @lazy if @lazy.depth > @value.depth\n\t\telse\n\t\t\t@children.each {|c| c.update(@lazy)}\n\t\tend\n\n\t\t@lazy = nil\n\tend\n\n\tattr_reader :l, :r\nend\n\nloop do\n\tn, q = gets.split.map(&:to_i)\t\t\n\tbreak if n == 0\n\tsum = 0\n\tnodes = (0..n).map{|i| Tree.new(i) }\n\t(n-1).times do |i|\n\t\tj = gets.to_i\n\t\tnodes[j].children << nodes[i+2]\n\tend\n\tnodes[1].euler(0)\n\tnodes[1].compute_depth\n\n\tseg = SegTree.new((0..2*n-1).map { nodes[1] })\n\n\tq.times do\n\t\tquery, i = gets.chomp.split\n\t\ttarget = nodes[i.to_i]\n\t\tif query == ?Q\n\t\t \tsum += seg.query(target.l)\n\t\telse\n\t\t\tseg.update(target, target.l, target.r)\n\t\tend\n\tend\n\tputs sum\nend"
  },
  {
    "language": "Ruby",
    "code": "class Module\n  def tco(name)\n    continue = []\n    first = true\n    arguments = nil\n\n    private_name = \"private_\" + name.to_s\n    alias_method private_name, name\n    private private_name\n\n    define_method(name) do |*args|\n      if first\n        first = false\n        while true\n          result = send(private_name, *args)\n          if result.equal? continue\n            args = arguments\n          else\n            first = true\n            return result\n          end\n        end\n      else\n        arguments = args\n        continue\n      end\n    end\n  end\nend\n\n\nclass Solve\n  def parent(x)\n    return x if $mark[x]\n    parent($arr[x])\n  end\n  tco :parent\nend\n\nloop do\n  n, q = gets.split.map(&:to_i)\n  break if n == 0\n  $arr = Array.new(n+1)\n  (2..n).each{ |i| $arr[i] = gets.to_i }\n  $mark = Array.new(n+1)\n  $mark[1] = true\n  sum = 0\n  qs = []\n  q.times do\n    qs << gets.split\n  end\n  s = Solve.new\n  qs.each do |cmd, n|\n    if cmd == 'M'\n      $mark[n.to_i] = true\n    else\n      sum += s.parent(n.to_i)\n    end\n  end\n  p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nclass Path\n\tdef initialize(root)\n\t\t@nodes = [root]\n\t\t@marked = 0\n\t\t@parent = nil\n\t\t@index = {root => 0}\n\tend\n\n\tdef add(node)\n\t\t@nodes << node\t\n\t\t@index[node] = @index.size\n\t\t@marked <<= 1\n\tend\n\n\tdef query(v)\n\t\ti = @index[v]\n\t\tx = (@marked >> @nodes.size-i-1)\n\t\tif x == 0\n\t\t\tp_path, p_node = @parent\n\t\t\treturn nil if !p_path\n\t\t\tp_path.query(p_node)\n\t\telse\n\t\t\tj = (x ^ (x - 1)).to_s(2).size\n\t\t\t@nodes[i - j + 1]\n\t\tend\n\tend\n\n\tdef mark(v)\n\t\ti = @index[v]\n\t\t@marked |= (1 << @nodes.size-i-1)\n\tend\n\n\tdef to_s\n\t\t@nodes.to_s\n\tend\n\n\tattr_accessor :parent\n\tattr_reader :nodes\nend\n\nn, q = gets.split.map &:to_i\ng = Digraph.new\n\nnodes = (0..n).map{|i| g.add_node({:name => i, :tree_size => 1})}\n(2..n).each{|j|\n\ti = gets.to_i\n\tg.add_edge(nodes[i], nodes[j])\n}\n\nnodes.reverse.each{|v|\n\tv.in_edges.each{|e|\n\t\tu = e.from\n\t\tu.property[:tree_size] += v.property[:tree_size]\n\t}\n}\n\ndef decompose(start)\n\tu = start\n\tpaths = [Path.new(u)]\n\twhile u.out_edges.size > 0\n\t\te0 = u.out_edges.max_by{|e| e.to.property[:tree_size]}\n\t\tu.out_edges.each{|e|\n\t\t\tnext if e == e0\n\t\t\tsub_paths = decompose(e.to)\n\t\t\tsub_paths[0].parent = [paths[0], u] \n\t\t\tpaths += sub_paths\n\t\t}\n\t\tpaths[0].add(e0.to)\n\t\tu = e0.to\n\tend\n\tpaths\nend\n\npaths = decompose(nodes[1])\nbelong = {}\npaths.each{|path|\n\tpath.nodes.each{|v|\n\t\tbelong[v] = path\n\t}\n}\npaths[0].mark(nodes[1])\n\nsum = 0\nq.times {\n\tc, i = gets.chomp.split\n\ti = i.to_i\n\tif c == ?Q\n\t\tv = belong[nodes[i]].query(nodes[i])\n\t\tsum += v.property[:name]\n\telse\n\t\tbelong[nodes[i]].mark(nodes[i])\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "def query(x)\n  return x if $mark[x]\n  return query($arr[x])\nend\nloop do\n  n, q = gets.split.map(&:to_i)\n  break if n == 0\n  $arr = Array.new(n+1)\n  (2..n).each{ |i| $arr[i] = gets.to_i }\n  $mark = Array.new(n+1)\n  $mark[1] = true\n  sum = 0\n  q.times do\n    cmd, n = gets.split\n    if cmd == 'Q'\n      ans = query(n.to_i)\n      sum += ans\n    else\n      $mark[n.to_i] = true\n    end\n  end\n  p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "def root(x)\n  if $Tree[x] == x\n    x\n  else\n    $Tree[x] = root($Tree[x])\n  end\nend\n\n# $Tree[1] がroot\ndef initTree\n  $Tree = Array.new(100002)\n  0.upto(100002) do |i|\n    $Tree[i] = i\n  end\nend\n\n# 1 if marked, otherwise 0\ndef initMarked\n  $Marked = Array.new(100001, 0)\n  $Marked[1] = 1\nend\n\ndef mark(x)\n  $Marked[x] = 1\nend\n\ndef printMarked(x)\n  $Marked[$Tree[x]] == 1 ? $Tree[x] : printMarked($Tree[x])\nend\n\nif __FILE__ == $0\n  loop do\n    n, q = gets.split.map(&:to_i)\n    break if n.zero? && q.zero?\n\n    initTree\n    initMarked\n    count = 0\n\n    (n-1).times do |i|\n      m = gets.to_i\n      $Tree[i+2] = m\n    end\n\n    q.times do |i|\n      op, m = gets.chomp.split\n      m = m.to_i\n      op == \"M\" ? mark(m) : count += printMarked(m)\n    end\n    p count\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\treturn dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nclass Path\n\tdef initialize(root)\n\t\t@nodes = [root]\n\t\t@marked = 0\n\t\t@parent = nil\n\t\t@index = {root => 0}\n\tend\n\n\tdef add(node)\n\t\t@nodes << node\t\n\t\t@index[node] = @index.size\n\t\t@marked <<= 1\n\tend\n\n\tdef query(v)\n\t\ti = @index[v]\n\t\tx = (@marked >> @nodes.size-i-1)\n\t\tif x == 0\n\t\t\tp_path, p_node = @parent\n\t\t\treturn nil if !p_path\n\t\t\tp_path.query(p_node)\n\t\telse\n\t\t\tj = (x ^ (x - 1)).to_s(2).size\n\t\t\t@nodes[i - j + 1]\n\t\tend\n\tend\n\n\tdef mark(v)\n\t\ti = @index[v]\n\t\t@marked |= (1 << @nodes.size-i-1)\n\tend\n\n\tdef to_s\n\t\t@nodes.to_s\n\tend\n\n\tattr_accessor :parent\n\tattr_reader :nodes\nend\n\ndef decompose(start)\n\tu = start\n\tpaths = [Path.new(u)]\n\twhile u.out_edges.size > 0\n\t\te0 = u.out_edges.max_by{|e| e.to.property[:tree_size]}\n\t\tu.out_edges.each{|e|\n\t\t\tnext if e == e0\n\t\t\tsub_paths = decompose(e.to)\n\t\t\tsub_paths[0].parent = [paths[0], u] \n\t\t\tpaths += sub_paths\n\t\t}\n\t\tpaths[0].add(e0.to)\n\t\tu = e0.to\n\tend\n\tpaths\nend\n\nloop {\n\tn, q = gets.split.map &:to_i\n\tbreak if n == 0\n\tg = Digraph.new\n\t\n\tnodes = (0..n).map{|i| g.add_node({:name => i, :tree_size => 1})}\n\t(2..n).each{|j|\n\t\ti = gets.to_i\n\t\tg.add_edge(nodes[i], nodes[j])\n\t}\n\t\n\tnodes.reverse.each{|v|\n\t\tv.in_edges.each{|e|\n\t\t\tu = e.from\n\t\t\tu.property[:tree_size] += v.property[:tree_size]\n\t\t}\n\t}\n\t\n\t\n\tpaths = decompose(nodes[1])\n\tbelong = {}\n\tpaths.each{|path|\n\t\tpath.nodes.each{|v|\n\t\t\tbelong[v] = path\n\t\t}\n\t}\n\tpaths[0].mark(nodes[1])\n\t\n\tsum = 0\n\tq.times {\n\t\tc, i = gets.chomp.split\n\t\ti = i.to_i\n\t\tif c == ?Q\n\t\t\tv = belong[nodes[i]].query(nodes[i])\n\t\t\tsum += v.property[:name]\n\t\telse\n\t\t\tbelong[nodes[i]].mark(nodes[i])\n\t\tend\n\t}\n\tp sum\n}"
  },
  {
    "language": "Ruby",
    "code": "class Node\n    attr_accessor :parent, :rank\n    def initialize(n)\n        @parent = n\n        @rank = 0\n    end\nend\n\nclass UnionFindTree\n    attr_accessor :nodes\n    def initialize(n)\n        @nodes = (0..n).to_a.map { |i| Node.new(i) }\n    end\n    def find(x)\n        return x if @nodes[x].parent == x\n        return @nodes[x].parent = find(@nodes[x].parent)\n    end\n    def unite(a, b)\n        a = find(a)\n        b = find(b)\n        return if a == b\n        if @nodes[a].rank < @nodes[b].rank\n            @nodes[a].parent = b\n        else\n            @nodes[b].parent = a\n            @nodes[b].rank += 1 if @nodes[a].rank == @nodes[b].rank\n        end\n    end\n    def same?(a, b)\n        find(a) == find(b)\n    end\nend\nloop do\n    n, q = gets.split.map(&:to_i)\n    break if n == 0 && q == 0\n    p = UnionFindTree.new(n)\n    pp = Array.new(n+1,-1)\n    pp[1] = 1\n    m = Array.new(n+1,0)\n    m[1] = 1\n    (n-1).times do |i|\n        temp = gets.to_i\n        pp[i+2] = temp\n    end\n    qs = q.times.map{gets.split}.map{|t, k| [t,k.to_i]}\n    qs.each do |qr|\n        if qr[0] == \"M\"\n            m[qr[1]] += 1\n        end\n    end\n    1.upto(n) do |i|\n        p.unite(pp[i], i) if m[i] == 0\n    end\n    ans = 0\n    qs.reverse.each do |qr|\n        case qr[0]\n        when \"M\"\n            m[qr[1]] -= 1\n            p.unite(pp[qr[1]], qr[1]) if m[qr[1]] == 0\n        when \"Q\"\n            ans += p.find(qr[1])\n        end\n    end\n    puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "class Module\n  def tco(name)\n    continue = []\n    called = false\n    arguments = nil\n\n    private_name = \"private_\" + name.to_s\n    alias_method private_name, name\n    private private_name\n\n    define_method(name) do |*args|\n      unless called\n        called = true\n        while true\n          result = send(private_name, *args)\n          if result.equal? continue\n            args = arguments\n          else\n            called = false\n            return result\n          end\n        end\n      else\n        arguments = args\n        continue\n      end\n    end\n  end\nend\n\n\nclass Solve\n  def parent(x)\n    return x if $mark[x] >= 1\n    parent($arr[x])\n  end\n  tco :parent\nend\n\nloop do\n  n, q = gets.split.map(&:to_i)\n  break if n == 0\n  $arr = Array.new(n+1)\n  (2..n).each{ |i| $arr[i] = gets.to_i }\n  $mark = Array.new(n+1, 0)\n  $mark[1] = 1\n  sum = 0\n  s = Solve.new\n  qs = []\n  q.times do\n    qs << gets.split\n  end\n  qs.each do |cmd, n|\n    if cmd == 'M'\n      $mark[n.to_i] += 1\n    end\n  end\n  qs.reverse.each do |cmd, n|\n    if cmd == 'M'\n      $mark[n.to_i] -= 1\n    else\n      sum += s.parent(n.to_i)\n    end\n  end\n  p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "class Node\n    attr_accessor :parent, :rank\n    def initialize(n)\n        @parent = n\n        @rank = 0\n    end\nend\n\nclass UnionFindTree\n    attr_accessor :nodes\n    def initialize(n)\n        @nodes = (0..n).to_a.map { |i| Node.new(i) }\n    end\n    def find(x, m)\n        return x if @nodes[x].parent == x || m[x] > 0\n        return @nodes[x].parent = find(@nodes[x].parent, m)\n    end\n    def unite(a, b, m)\n        a = find(a, m)\n        b = find(b, m)\n        return if a == b\n        if @nodes[a].rank < @nodes[b].rank\n            @nodes[a].parent = b\n        else\n            @nodes[b].parent = a\n            @nodes[b].rank += 1 if @nodes[a].rank == @nodes[b].rank\n        end\n    end\n    def same?(a, b)\n        find(a) == find(b)\n    end\nend\ndef dfs(v, k, m, pp, ch)\n    k = v if m[v] > 0\n    pp[v] = k\n    ch[v].each do |c|\n        pp = dfs(c,k,m,pp,ch)\n    end\n    return pp\nend\nloop do\n    n, q = gets.split.map(&:to_i)\n    break if n == 0 && q == 0\n    p = UnionFindTree.new(n)\n    pp = Array.new(n+1,-1)\n    ch = Array.new(n+1).map{Array.new}\n    m = Array.new(n+1,0)\n    m[1] = 1\n    (n-1).times do |i|\n        temp = gets.to_i\n        p.nodes[i+2].parent = temp\n        pp[i+2] = temp\n        ch[temp].push(i+2)\n    end\n    qs = q.times.map{gets.split}.map{|t, k| [t,k.to_i]}\n    qs.each do |qr|\n        if qr[0] == \"M\"\n            m[qr[1]] += 1\n        end\n    end\n    pp = dfs(1,-1,m,pp,ch)\n    ans = 0\n    qs.reverse.each do |qr|\n        case qr[0]\n        when \"M\"\n            m[qr[1]] -= 1\n            p.unite(qr[1], pp[qr[1]], m) if m[qr[1]] == 0\n        when \"Q\"\n            ans += p.find(qr[1], m)\n        end\n    end\n    puts ans\nend"
  },
  {
    "language": "Ruby",
    "code": "def root(x)\n  if $Tree[x] == x\n    x\n  else\n    $Tree[x] = root($Tree[x])\n  end\nend\n\n# $Tree[1] がroot\ndef initTree\n  $Tree = Array.new(100001)\n  0.upto(100001) do |i|\n    $Tree[i] = i\n  end\nend\n\n# 1 if marked, otherwise 0\ndef initMarked\n  $Marked = Array.new(100001, 0)\n  $Marked[1] = 1\nend\n\ndef mark(x)\n  $Marked[x] = 1\nend\n\ndef printMarked(x)\n  $Marked[$Tree[x]] == 1 ? $Tree[x] : printMarked($Tree[x])\nend\n\nif __FILE__ == $0\n  loop do\n    n, q = gets.split.map(&:to_i)\n    break if n.zero? && q.zero?\n\n    initTree\n    initMarked\n    count = 0\n\n    (n-1).times do |i|\n      m = gets.to_i\n      $Tree[i+2] = m\n    end\n\n    q.times do |i|\n      op, m = gets.chomp.split\n      m = m.to_i\n      op == \"M\" ? mark(m) : count += printMarked(m)\n    end\n    p count\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "MaxN = 100000\n\n# $Tree[1] がroot\ndef initTree\n  $Tree = Array.new(MaxN+1)\n  0.upto(MaxN+1) do |i|\n    $Tree[i] = i\n  end\nend\n\n# if $Marked[x] == x, then it is marked.\ndef initMarked\n  $Marked = Array.new(MaxN+1, 0)\n  $Marked[1] = 1\nend\n\ndef mark(x)\n  $Marked[x] = x\nend\n\ndef isMarked(x)\n  $Marked[x] == x\nend\n\ndef nearestMarked(x)\n  reservedX = x\n\n  # x is marked.\n  if isMarked(x)\n    x\n  # find the nearest marked ancestor, then connect the nodes above x to\n  # the nearest marked ancestor.\n  else\n    $Marked[x] = nearestMarked($Tree[x])\n  end\nend\n\nif __FILE__ == $0\n  loop do\n    n, q = gets.split.map(&:to_i)\n    break if n.zero? && q.zero?\n\n    initTree\n    initMarked\n    count = 0\n\n    (n-1).times do |i|\n      m = gets.to_i\n      $Tree[i+2] = m\n    end\n\n    q.times do |i|\n      op, m = gets.chomp.split\n      m = m.to_i\n      op == \"M\" ? mark(m) : count += nearestMarked(m)\n    end\n    # p $Tree[0,n]\n    #  p $Marked[0,n]\n    p count\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n\tdef initialize(i)\n\t\t@index = i\n\t\t@children = []\n\tend\n\n\tdef compute_euler_index\n\t\tstack = [[self, 0]]\n\t\t@l = 0\n\t\tn = 0\n\t\tuntil stack.empty? do\n\t\t\tv, i = stack[-1]\n\t\t\tif i >= v.children.size\n\t\t\t\tv.r = (n += 1)\n\t\t\t\tstack.pop\n\t\t\t\tstack[-1][1] += 1 unless stack.empty?\n\t\t\t\tnext\n\t\t\tend\n\t\t\tc = v.children[i]\n\t\t\tc.l = (n += 1)\n\t\t\tstack << [c, 0]\n\t\tend\n\tend\n\n\tdef compute_depth\n\t\tstack = [[self, 0]]\n\t\td = 0\n\t\tuntil stack.empty? do\n\t\t\tv, i = stack[-1]\n\t\t\tif i >= v.children.size\n\t\t\t\tv.depth = d\n\t\t\t\td -= 1\n\t\t\t\tstack.pop\n\t\t\t\tstack[-1][1] += 1 unless stack.empty?\n\t\t\t\tnext\n\t\t\tend\n\t\t\tc = v.children[i]\n\t\t\tstack << [c, 0]\n\t\t\td += 1\n\t\tend\n\tend\n\n\tattr_accessor :index, :children, :l, :r, :depth\nend\n\nclass SegTree\n\tdef initialize(a, l = 0, r = a.size-1)\n\t\t@l = l\n\t\t@r = r\n\t\tif l == r\n\t\t\t@value = a[l]\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@children = [SegTree.new(a, l, c), SegTree.new(a, c + 1, r)]\t\n\t\tend\n\tend\n\n\tdef update(marked, l = @l, r = @r)\n\t\tif @l == l && @r == r\n\t\t\tif @lazy\n\t\t\t\t@lazy = marked if marked.depth > @lazy.depth\n\t\t\telse\n\t\t\t\t@lazy = marked\n\t\t\tend\n\t\t\treturn\n\t\tend\n\n\t\tforce if @lazy\n\t\tif r <= @children[0].r\n\t\t\t@children[0].update(marked, l, r)\n\t\telsif @children[1].l <= l\n\t\t\t@children[1].update(marked, l, r)\n\t\telse\n\t\t\t@children[0].update(marked, l, @children[0].r)\n\t\t\t@children[1].update(marked, @children[1].l, r)\n\t\tend\n\tend\n\n\tdef query(i)\n\t\tforce if @lazy\n\t\tif @l == @r && @l == i\n\t\t\t@value.index\n\t\telsif i <= @children[0].r\n\t\t\t@children[0].query(i)\n\t\telse\n\t\t\t@children[1].query(i)\n\t\tend\n\tend\n\n\tdef force\n\t\tif @l == @r\n\t\t\t@value = @lazy if @lazy.depth > @value.depth\n\t\telse\n\t\t\t@children.each {|c| c.update(@lazy)}\n\t\tend\n\n\t\t@lazy = nil\n\tend\n\n\tattr_reader :l, :r\nend\n\nloop do\n\tn, q = gets.split.map(&:to_i)\t\t\n\tbreak if n == 0\n\tsum = 0\n\tnodes = (0..n).map{|i| Tree.new(i) }\n\t(n-1).times do |i|\n\t\tj = gets.to_i\n\t\tnodes[j].children << nodes[i+2]\n\tend\n\tnodes[1].compute_euler_index\n\tnodes[1].compute_depth\n\n\tseg = SegTree.new((0..2*n-1).map { nodes[1] })\n\n\tq.times do\n\t\tquery, i = gets.chomp.split\n\t\ttarget = nodes[i.to_i]\n\t\tif query == ?Q\n\t\t \tsum += seg.query(target.l)\n\t\telse\n\t\t\tseg.update(target, target.l, target.r)\n\t\tend\n\tend\n\tputs sum\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nbool solve() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto Q = s[1];\n    if (N == 0) return false;\n\n    auto G = new int[][](N);\n    auto D = new int[](N);\n    auto P = new int[](N);\n    P[0] = -1;\n\n    foreach (i; 1..N) {\n        auto n = readln.chomp.to!int;\n        P[i] = n-1;\n        G[i] ~= n-1;\n        G[n-1] ~= i;\n    }\n\n    void dfs(int n, int p, int d) {\n        D[n] = d;\n        foreach (m; G[n]) if (m != p) dfs(m, n, d+1);\n    }\n\n    dfs(0, -1, 0);\n\n    Tuple!(int, int)[] queries;\n    auto marked = new int[](N);\n\n    foreach (i; 1..Q+1) {\n        auto t = readln.split;\n        auto n = t[1].to!int - 1;\n        if (t[0] == \"M\" && !marked[n]) {\n            queries ~= tuple(0, n);\n            marked[n] = i;\n        } else if (t[0] == \"Q\") {\n            queries ~= tuple(1, n);\n        }\n    }\n\n    auto uf = new UnionFind(N, D);\n    foreach (i; 0..N) if (!marked[i]) uf.unite(i, P[i]);\n    long ans = 0;\n\n    foreach_reverse (q; queries) {\n        if (q[0] == 0) {\n            uf.unite(q[1], P[q[1]]);\n        } else {\n            ans += uf.find(q[1]) + 1;\n        }\n    }\n\n    ans.writeln;\n\n    return true;\n}\n\nvoid main() {\n    while (solve()) {}\n}\n\n\nclass UnionFind {\n    int N;\n    int[] table;\n    int[] depth;\n\n    this(int n, int[] d) {\n        N = n;\n        table = new int[](N);\n        fill(table, -1);\n        depth = d.dup;\n    }\n\n    int find(int x) {\n        return table[x] < 0 ? x : (table[x] = find(table[x]));\n    }\n\n    void unite(int x, int y) {\n        if (x == -1 || y == -1) return;\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (depth[x] > depth[y]) swap(x, y);\n        table[x] += table[y];\n        table[y] = x;\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto Q = s[1];\n\n    auto parent = new int[](N);\n    auto hld = new HeavyLightDecomposition(N);\n    \n    foreach (i; 1..N) {\n        auto p = readln.chomp.to!int - 1;\n        parent[i] = p;\n        hld.add_edge(p, i);\n    }\n    parent[0] = -1;\n\n    \n    hld.run;\n    int M = hld.subtrees.length.to!int;\n    \n    auto rbts = new RedBlackTree!(int, \"a < b\", false)[](M);\n    foreach (i; 0..M) rbts[i] = new RedBlackTree!(int, \"a < b\", false);\n    rbts[0].insert(0);\n    \n    int ans = 0;\n\n    while (Q--) {\n        auto q = readln.split;\n        auto n = q[1].to!int - 1;\n        if (q[0] == \"M\") {\n            int subt = hld.n_subtree[n];\n            int i = hld.n_subtree_ind[n];\n            rbts[subt].insert(i);\n        } else {\n            while (n != -1) {\n                int subt = hld.n_subtree[n];\n                int i = hld.n_subtree_ind[n];\n                \n                auto lb = rbts[subt].lowerBound(i);\n                if (lb.empty) {\n                    int subroot = hld.subtrees[subt][0];\n                    n = parent[subroot];\n                } else {\n                    int j = lb.back;\n                    ans += hld.subtrees[subt][j] + 1;\n                    break;\n                }\n            }\n        }\n    }\n\n\n    ans.writeln;\n    \n}\n\n\nclass HeavyLightDecomposition {\n    int N;\n    int[] children;\n    int[][] edges;\n    int[][] subtrees;\n    int[] n_subtree;\n    int[] n_subtree_ind;\n    int[] subt_parent;\n\n    this (int n) {\n        N = n;\n        edges = new int[][](N);\n        children = new int[](N);\n        n_subtree = new int[](N);\n        n_subtree_ind = new int[](N);\n    }\n    \n    void run() {\n        dfs1(0, -1);\n        dfs2(0, -1, -1, true);\n    }\n\n    void add_edge(int u, int v) {\n        edges[u] ~= v;\n        edges[v] ~= u;\n    }\n\n    \n    int dfs1(int n, int prev) {\n        children[n] = 1;\n        foreach (m; edges[n]) if (m != prev) children[n] += dfs1(m, n);\n        return children[n];\n    }\n    \n    void dfs2(int n, int prev, int prev_subt, bool subroot) {\n        int subt;\n        if (subroot) {\n            subtrees ~= [n];\n            subt = subtrees.length.to!int - 1;\n            subt_parent ~= prev_subt;\n        } else {\n            subtrees[prev_subt] ~= n;\n            subt = prev_subt;\n        }\n        n_subtree[n] = subt;\n        n_subtree_ind[n] = subtrees[subt].length.to!int - 1;\n        \n        int maxi = -1;\n        int maxv = -1;\n        foreach (m; edges[n]) {\n            if (m == prev) continue;\n            if (children[m] > maxv) maxv = children[m], maxi = m;\n        }\n        foreach (m; edges[n]) {\n            if (m == prev) continue;\n            dfs2(m, n, subt, m != maxi);\n        }\n    }\n\n}\n\nunittest {\n    auto hld = new HeavyLightDecomposition(11);\n    hld.add_edge(0, 1);\n    hld.add_edge(0, 2);\n    hld.add_edge(1, 3);\n    hld.add_edge(1, 4);\n    hld.add_edge(1, 5);\n    hld.add_edge(2, 6);\n    hld.add_edge(4, 7);\n    hld.add_edge(4, 8);\n    hld.add_edge(8, 9);\n    hld.add_edge(6, 10);\n    hld.run;\n    hld.subtrees.sort();\n    assert(hld.subtrees == [[0, 1, 4, 8, 9], \n                            [2, 6, 10],\n                            [3],\n                            [5],\n                            [7]]);\n    hld.subt_parent.writeln;\n}"
  },
  {
    "language": "D",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\n\tinline void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\t}\n\n\tinline bool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, q; cin >> n >> q, n | q;) {\n\t\tvector<int> parent(n, -1);\n\t\tfor(int i = 1; i < n; ++i) {\n\t\t\tint input;\n\t\t\tcin >> input;\n\t\t\tparent[i] = --input;\n\t\t}\n\n\t\tstack<int> mark, query;\n\t\tvector<bool> is_mark(q, false);\n\t\tvector<bool> is_root(n, false);\n\t\tis_root[0] = true;\n\n\t\tfor(int i = 0; i < q; ++i) {\n\t\t\tchar ope;\n\t\t\tint v;\n\t\t\tcin >> ope >> v;\n\t\t\tif(ope == 'Q')\n\t\t\t\tquery.push(v);\n\t\t\telse {\n\t\t\t\tis_mark[i] = true;\n\t\t\t\tis_root[v] = true;\n\t\t\t\tmark.push(v);\n\t\t\t}\n\t\t}\n\n\t\tunion_find uf(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!is_root[i])\n\t\t\t\tuf.unite(i, parent[i]);\n\n\t\tint ans = 0;\n\t\tfor(int i = q - 1; i >= 0; --i) {\n\t\t\tif(is_mark[i]) {\n\t\t\t\tint v = mark.top();\n\t\t\t\tmark.pop();\n\t\t\t\tuf.unite(v, parent[v]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint v = query.top();\n\t\t\t\tquery.pop();\n\t\t\t\tans += uf.find(v) + 1;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\n\nvoid main() {\n    while (solve) {};\n}\n\nbool solve() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto Q = s[1];\n    if (N == 0) return false;\n\n    auto parent = new int[](N);\n    auto hld = new HeavyLightDecomposition(N);\n    \n    foreach (i; 1..N) {\n        auto p = readln.chomp.to!int - 1;\n        parent[i] = p;\n        hld.add_edge(p, i);\n    }\n    parent[0] = -1;\n\n    \n    hld.run;\n    int M = hld.subtrees.length.to!int;\n    \n    auto rbts = new RedBlackTree!(int, \"a < b\", false)[](M);\n    foreach (i; 0..M) rbts[i] = new RedBlackTree!(int, \"a < b\", false);\n    rbts[0].insert(0);\n    \n    long ans = 0;\n\n    while (Q--) {\n        auto q = readln.split;\n        auto n = q[1].to!int - 1;\n        if (q[0] == \"M\") {\n            int subt = hld.n_subtree[n];\n            int i = hld.n_subtree_ind[n];\n            rbts[subt].insert(i);\n        } else {\n            while (n != -1) {\n                int subt = hld.n_subtree[n];\n                int i = hld.n_subtree_ind[n];\n                \n                auto lb = rbts[subt].lowerBound(i);\n                if (lb.empty) {\n                    int subroot = hld.subtrees[subt][0];\n                    n = parent[subroot];\n                } else {\n                    int j = lb.back;\n                    ans += hld.subtrees[subt][j] + 1;\n                    break;\n                }\n            }\n        }\n    }\n\n\n    ans.writeln;\n\n    return true;\n}\n\n\nclass HeavyLightDecomposition {\n    int N;\n    int[] children;\n    int[][] edges;\n    int[][] subtrees;\n    int[] n_subtree;\n    int[] n_subtree_ind;\n    int[] subt_parent;\n\n    this (int n) {\n        N = n;\n        edges = new int[][](N);\n        children = new int[](N);\n        n_subtree = new int[](N);\n        n_subtree_ind = new int[](N);\n    }\n    \n    void run() {\n        dfs1(0, -1);\n        dfs2(0, -1, -1, true);\n    }\n\n    void add_edge(int u, int v) {\n        edges[u] ~= v;\n        edges[v] ~= u;\n    }\n\n    \n    int dfs1(int n, int prev) {\n        children[n] = 1;\n        foreach (m; edges[n]) if (m != prev) children[n] += dfs1(m, n);\n        return children[n];\n    }\n    \n    void dfs2(int n, int prev, int prev_subt, bool subroot) {\n        int subt;\n        if (subroot) {\n            subtrees ~= [n];\n            subt = subtrees.length.to!int - 1;\n            subt_parent ~= prev_subt;\n        } else {\n            subtrees[prev_subt] ~= n;\n            subt = prev_subt;\n        }\n        n_subtree[n] = subt;\n        n_subtree_ind[n] = subtrees[subt].length.to!int - 1;\n        \n        int maxi = -1;\n        int maxv = -1;\n        foreach (m; edges[n]) {\n            if (m == prev) continue;\n            if (children[m] > maxv) maxv = children[m], maxi = m;\n        }\n        foreach (m; edges[n]) {\n            if (m == prev) continue;\n            dfs2(m, n, subt, m != maxi);\n        }\n    }\n}\n\nunittest {\n    auto hld = new HeavyLightDecomposition(11);\n    hld.add_edge(0, 1);\n    hld.add_edge(0, 2);\n    hld.add_edge(1, 3);\n    hld.add_edge(1, 4);\n    hld.add_edge(1, 5);\n    hld.add_edge(2, 6);\n    hld.add_edge(4, 7);\n    hld.add_edge(4, 8);\n    hld.add_edge(8, 9);\n    hld.add_edge(6, 10);\n    hld.run;\n    hld.subtrees.sort();\n    assert(hld.subtrees == [[0, 1, 4, 8, 9], \n                            [2, 6, 10],\n                            [3],\n                            [5],\n                            [7]]);\n    hld.subt_parent.writeln;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\nmarked = []\npar = []\nrank = []\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        if marked[x]:\n            return x\n        return find(par[x])\n\ndef main():\n    global marked, par, rank\n    n,q = [int(i) for i in input().split()]\n    marked = [False for i in range(n+1)]\n    par = [ i for i in range(n+1)]\n    rank = [ 0 for i in range(n+1)]\n    ans = 0\n    for i in range(2,n+1):\n        par[i] = int(input())\n    for i in range(q):\n        s = input().split()\n        if s[0] == 'Q':\n            ans += find(int(s[1]))\n        else:\n            marked[int(s[1])]=True\n    print(ans)\n    input()\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\nmarked = []\npar = []\nrank = []\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        if marked[x]:\n            return x\n        return find(par[x])\n\ndef main():\n    global marked, par, rank\n    n,q = [int(i) for i in input().split()]\n    marked = [False for i in range(n+1)]\n    par = [ i for i in range(n+1)]\n    rank = [ 0 for i in range(n+1)]\n    ans = 0\n    for i in range(2,n+1):\n        par[i] = int(input())\n    for i in range(q):\n        s = input().split()\n        if s[0] == 'Q':\n            print(find(int(s[1])))\n        else:\n            marked[int(s[1])]=True\n    input()\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            self.table[s2] += self.table[s1]\n            self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef main():\n    rr = []\n\n    def f(n,q):\n        ps = [0, 1] + [I() for _ in range(n-1)]\n        qs = []\n        ms = set()\n        for i in range(q):\n            s,t = LS()\n            t = int(t)\n            if s == 'M':\n                if t in ms:\n                    continue\n                ms.add(t)\n            qs.append((s,t))\n        uf = UnionFind(n+1)\n        for i in range(2,n+1):\n            if i in ms:\n                continue\n            uf.union(i, ps[i])\n\n        r = 0\n        for s,t in qs[::-1]:\n            if s == 'Q':\n                r += uf.find(t)\n            else:\n                uf.union(t, ps[t])\n\n        return r\n\n    while 1:\n        n,q = LI()\n        if n == 0 and q == 0:\n            break\n        rr.append(f(n,q))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        self.parent[x] = y\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parent = [0, 1] + [int(input()) for i in range(2, N+1)]\n    queries = []\n    marked = set([1])\n    for i in range(Q):\n        o, v = input().split()\n        v = int(v)\n        if o == 'M':\n            if v in marked:\n                continue\n            marked.add(v)\n        queries.append((o, v))\n\n    uf = UnionFind(N+1)\n    for i in range(1, N+1):\n        if i not in marked:\n            uf.unite(i, parent[i])\n\n    ans = 0\n    for o, v in reversed(queries):\n        if o == 'M':\n            uf.unite(v, parent[v])\n        else:\n            ans += uf.find(v)\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    while P[x] != x:\n        x = P[x]\n    return x\ndef mark(x):\n    P[x-1] = x-1\ndef query(x):\n    v = root(x-1) +1\n    return v\n\nwhile True:\n    N,Q = map(int,input().strip().split(\" \"))\n    if N == Q == 0:\n        break\n    P = []\n    P.append(0)\n    for i in range(N-1):\n        p_i = int(input().strip()) -1\n        P.append(p_i)\n    s = 0\n    for j in range(Q):\n        op = input().strip().split(\" \")\n        if op[0] == \"M\":\n            mark(int(op[1]))\n        else:\n            s += query(int(op[1]))\n    print(s)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    file_input = sys.stdin\n    \n    def marked_ancestor(v):\n        if v == ancestor[v]:\n            return v\n        else:\n            ancestor[v] = marked_ancestor(parent[v])\n            return ancestor[v]\n    \n    def line_ans(line):\n        v = int(line[2:])\n        if line[0] == 'M':\n            ancestor[v] = v\n            return 0\n        else:\n            return marked_ancestor(v)\n    \n    while True:\n        N, Q = map(int, file_input.readline().split())\n        if N == 0:\n            break\n        parent = [None, None]\n        parent += [int(file_input.readline()) for _ in range(N - 1)]\n        ancestor = [1] * (N + 1)\n        ans = (line_ans(file_input.readline()) for _ in range(Q))\n        print(sum(ans))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    file_input = sys.stdin\n    while True:\n        N, Q = map(int, file_input.readline().split())\n        if N == 0:\n            break\n        parent = [None, None]\n        parent += [int(file_input.readline()) for _ in range(N - 1)]\n        unmarked = [True] * (N + 1)\n        unmarked[1] = False\n        ans = 0\n        for _ in range(Q):\n            line = file_input.readline()\n            v = int(line[2:])\n            if line[0] == 'M':\n                unmarked[v] = False\n            else:\n                while unmarked[v]:\n                    v = parent[v]\n                ans += v\n        print(ans)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nclass UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parents = [-1] + [int(input()) - 1 for _ in range(N - 1)]\n    queries = []\n    marked = set()\n    for _ in range(Q):\n        k, v = input().split()\n        v = int(v) - 1\n        queries.append((k, v))\n        if k == \"M\":\n            marked.add(v)\n    uf = UnionFindTree(N)\n    for i in range(1, N):\n        if i not in marked:\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    ans = 0\n    for k, v in reversed(queries):\n        if k == \"Q\":\n            ans += uf.find(v) + 1\n        elif not uf.same(v, parents[v]):\n            p_root = uf.find(parents[v])\n            uf.par[v] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[v] + 1)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "marked = []\npar = []\nrank = []\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        if marked[x]:\n            return x\n        return find(par[x])\n\ndef main():\n    global marked, par, rank\n    n,q = [int(i) for i in input().split()]\n    marked = [False for i in range(n+1)]\n    par = [ i for i in range(n+1)]\n    rank = [ 0 for i in range(n+1)]\n    ans = 0\n    for i in range(2,n+1):\n        par[i] = int(input())\n    for i in range(q):\n        s = input().split()\n        if s[0] == 'Q':\n            ans += find(int(s[1]))\n        else:\n            marked[int(s[1])]=True\n    input()\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parents = [-1] + [int(input()) - 1 for _ in range(N - 1)]\n    queries = []\n    marked = set()\n    for _ in range(Q):\n        k, v = input().split()\n        v = int(v) - 1\n        queries.append((k, v))\n        if k == \"M\":\n            marked.add(v)\n    uf = UnionFindTree(N)\n    for i in range(1, N):\n        if i not in marked:\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    ans = 0\n    for k, v in reversed(queries):\n        if k == \"Q\":\n            ans += uf.find(v) + 1\n        elif not uf.same(v, parents[v]):\n            p_root = uf.find(parents[v])\n            uf.par[v] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[v] + 1)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000000)\nMOD = 10 ** 9 + 7\nINF = 10 ** 15\n\nclass UnionFind():\n    def __init__(self,n):\n        self.n = n\n        self.parents = [-1]*n\n\n    def find(self,x): #根を見つける、繋ぎ直す\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def unite(self,x,y):\n        y = self.find(y)\n        x = self.find(x)\n        self.parents[y] += self.parents[x]\n        self.parents[x] = y\n    \n    def same(self,x,y):#xとyが同じグループにいるか判定\n        return self.find(x) == self.find(y)\n\n\ndef solve(N,Q):\n    parents = [-1] * N\n    for i in range(1,N):\n        p = int(input()) - 1\n        parents[i] = p\n    \n    query = []\n    mark = [0] * N\n    mark[0] = 1\n    for _ in range(Q):\n        q = input().split()\n        v = int(q[1]) - 1\n        if q[0] == 'M':\n            mark[v] += 1\n            query.append((0,v))\n        else:\n            query.append((1,v))\n    \n    uf = UnionFind(N)\n    for i in range(N):\n        if mark[i] == 0:\n            uf.unite(i,parents[i])\n    \n    ans = 0\n    for ty,v in query[::-1]:\n        if ty == 0:\n            mark[v] -= 1\n            if mark[v] == 0:\n                uf.unite(v,parents[v])\n        else:\n            ans += uf.find(v) + 1\n    print(ans)\n\ndef main():\n    while True:\n        N,M = map(int,input().split())\n        if N == 0:\n            return\n        solve(N,M)\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [None] * size\n\n    def find(self, x):\n        if self.table[x] == None:\n            return x\n        else:\n            # compression of the path\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n    \n    def union(self, parent, child):\n        p_root = self.find(parent)\n        c_root = self.find(child)\n        if p_root != c_root:\n            self.table[c_root] = p_root\n        \ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    while True:\n        N, Q = map(int, input_lines[0].split())\n        if N == 0:\n            break\n        \n        unmarked = [True] * (N + 1)\n        unmarked[1] = False\n        operation = []\n        for o in input_lines[N:N+Q]:\n            mq, v = o.split()\n            v = int(v)\n            if mq == 'M':\n                if unmarked[v]:\n                    unmarked[v] = False\n                    operation.append((mq, v))\n            else:\n                operation.append((mq, v))\n        \n        uf = UnionFind(N + 1)\n        parent = [None, 1] + list(map(int, input_lines[1:N]))\n        for v, p in enumerate(parent[2:], start=2):\n            if unmarked[v]:\n                uf.union(p, v)\n        \n        ans = 0\n        for o, v in reversed(operation):\n            if o == 'M':\n                uf.union(parent[v], v)\n            else:\n                ans += uf.find(v)\n        \n        print(ans)\n        \n        del input_lines[:N+Q]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [None] * size\n\n    def find(self, x):\n        if self.table[x] == None:\n            return x\n        else:\n            # compression of the path\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n    \n    def union(self, parent, child):\n        p_root = self.find(parent)\n        c_root = self.find(child)\n        if p_root != c_root:\n            self.table[c_root] = p_root\n        \ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    while True:\n        N, Q = map(int, input_lines[0].split())\n        if N == 0:\n            break\n        \n        parent = [0, 1] + list(map(int, input_lines[1:N]))\n        \n        unmarked = [True] * (N + 1)\n        unmarked[1] = False\n        operation = []\n        for o in input_lines[N:N+Q]:\n            mq, v = o.split()\n            v = int(v)\n            if mq == 'M':\n                if unmarked[v]:\n                    unmarked[v] = False\n                    operation.append((mq, v))\n            else:\n                operation.append((mq, v))\n        \n        uf = UnionFind(N + 1)\n        for v, p in enumerate(parent[2:], start=2):\n            if unmarked[v]:\n                uf.union(p, v)\n        \n        ans = 0\n        for mq, v in reversed(operation):\n            if mq == 'M':\n                uf.union(parent[v], v)\n            else:\n                ans += uf.find(v)\n        \n        print(ans)\n        \n        del input_lines[:N+Q]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nclass UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parents = [0] + [int(input()) - 1 for _ in range(N - 1)]\n    queries = []\n    marked = set()\n    for _ in range(Q):\n        k, v = input().split()\n        v = int(v) - 1\n        queries.append((k, v))\n        if k == \"M\":\n            marked.add(v)\n    uf = UnionFindTree(N)\n    for i in range(1, N):\n        if i not in marked:\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    ans = 0\n    for k, v in reversed(queries):\n        if k == \"Q\":\n            ans += uf.find(v) + 1\n        elif not uf.same(v, parents[v]):\n            p_root = uf.find(parents[v])\n            uf.par[v] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[v] + 1)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "class UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parents = [-1] + [int(input()) - 1 for _ in range(N - 1)]\n    queries = []\n    marked = set()\n    for _ in range(Q):\n        k, v = input().split()\n        v = int(v) - 1\n        queries.append((k, v))\n        if k == \"M\":\n            marked.add(v)\n    uf = UnionFindTree(N)\n    for i in range(1, N):\n        if i not in marked:\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    ans = 0\n    for k, v in reversed(queries):\n        if k == \"Q\":\n            ans += uf.find(v)\n        elif not uf.same(v, parents[v]):\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 6)\n\n\nclass UnionFindTree:\n    \"\"\"Disjoint-Set Data Structure\n       Union-Find Tree\n       complexity:\n          init: O(n)\n          find, unite, same: O(alpha(n))\n       used in SRM505 div.2 900, ATC001 A, DSL1A(AOJ)\n    \"\"\"\n    def __init__(self, n):\n        self.par = list(range(n))  # parent\n        self.rank = [0] * n  # depth of tree\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nwhile True:\n    N, Q = map(int, input().split())\n    if N == Q == 0:\n        break\n    parents = [0] + [int(input()) - 1 for _ in range(N - 1)]\n    queries = []\n    marked = set()\n    for _ in range(Q):\n        k, v = input().split()\n        v = int(v) - 1\n        if k == \"Q\":\n            queries.append((k, v))\n        elif k == \"M\" and v not in marked:\n            marked.add(v)\n            queries.append((k, v))\n\n    uf = UnionFindTree(N)\n    for i in range(1, N):\n        if i not in marked:\n            p_root = uf.find(parents[i])\n            uf.par[i] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[i] + 1)\n    ans = 0\n    for k, v in reversed(queries):\n        if k == \"Q\":\n            ans += uf.find(v) + 1\n        elif not uf.same(v, parents[v]):\n            p_root = uf.find(parents[v])\n            uf.par[v] = p_root\n            uf.rank[p_root] = max(uf.rank[p_root], uf.par[v] + 1)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    while P[x-1]!=x:\n        x = P[x-1]\n    return x\n\ndef mark(x):\n    P[x-1] = x\n\nwhile True:\n    n,q = map(int,input().split())\n    res = 0\n    if n==0:\n        break\n    P = [1]\n    for _ in range(n-1):\n        P.append(int(input()))\n    \n    for _ in range(q):\n        com,num=map(str,input().split())\n        if com == \"Q\":\n            res += root(int(num))\n        else:\n            mark(int(num))\n    print(res)\n\n"
  },
  {
    "language": "Python",
    "code": "marked = []\npar = []\nrank = []\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        if marked[x]:\n            return x\n        return find(par[x])\n\ndef main():\n    global marked, par, rank\n    n,q = [int(i) for i in input().split()]\n    marked = [False for i in range(n+1)]\n    par = [ i for i in range(n+1)]\n    rank = [ 0 for i in range(n+1)]\n    ans = 0\n    for i in range(2,n+1):\n        par[i] = int(input())\n    for i in range(q):\n        s = input().split()\n        if s[0] == 'Q':\n            ans += find(int(s[1]))\n        else:\n            marked[int(s[1])]=True\n    print(ans)\n    input()\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n\nfn read_line() -> String {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    s.trim().to_string()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read_line()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\nfn read_tuple<T: std::str::FromStr + Copy>() -> (T, T) {\n    let v: Vec<T> = read_vec();\n    (v[0], v[1])\n}\n\nfn read_col<T: std::str::FromStr>(n: usize) -> Vec<T> {\n    (0..n).map(|_| read_line().parse().ok().unwrap()).collect()\n}\n\nstruct UnionFind {\n    par: Vec<usize>,\n    rank: Vec<usize>\n}\n\nimpl UnionFind {\n    fn new(size: usize) -> UnionFind {\n        UnionFind {\n            par: (0..size).collect(),\n            rank: vec![0; size]\n        }\n    }\n\n    fn find(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let p = self.par[x];\n            let p = self.find(p);\n            self.par[x] = p;\n            self.par[x]\n        }\n    }\n\n    fn unite(&mut self, x: usize, y: usize) {\n        let x = self.find(x);\n        let y = self.find(y);\n        if x == y {\n            return;\n        }\n\n        self.par[x] = y;\n        // if self.rank[x] < self.rank[y] {\n        //     self.par[x] = y;\n        // } else {\n        //     self.par[y] = x;\n        //     if self.rank[x] == self.rank[y] {\n        //         self.rank[x] += 1;\n        //     }\n        // }\n    }\n\n    fn same(&mut self, x: usize, y: usize) -> bool {\n        self.find(x) == self.find(y)\n    }\n}\n\nfn main() {\n    loop {\n        let (N, Q) = read_tuple::<usize>();\n        if N == 0 && Q == 0 {\n            break;\n        }\n        let mut parent: Vec<usize> = read_col(N-1);\n        parent.insert(0, 0);\n        parent.insert(0, 1);\n        let mut queries = Vec::<(char, usize)>::new();\n        let mut marked = vec![1];\n        for i in 0..Q {\n            let vec: Vec<String> = read_vec();\n            let o = vec[0].chars().next().unwrap();\n            let v: usize = vec[1].parse().unwrap();\n            if o == 'M' {\n                if marked.contains(&v) {\n                    continue;\n                }\n                marked.push(v);\n            }\n            queries.push((o, v));\n        }\n\n        let mut uf = UnionFind::new(N+1);\n        for i in 1..N+1 {\n            if !marked.contains(&i) {\n                uf.unite(i, parent[i]);\n            }\n        }\n\n        let mut ans = 0;\n        queries.reverse();\n        for (o, v) in queries {\n            if o == 'M' {\n                uf.unite(v, parent[v]);\n            } else {\n                ans += uf.find(v);\n            }\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\n"
  }
]