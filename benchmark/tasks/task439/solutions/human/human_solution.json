[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n\n  val target = readLine.trim.split('.').tail\n  var lines = Nil: List[String]\n  var line = readLine\n  while (line != null){\n    lines ::= line\n    line = readLine\n  }\n  val mapping = new Mapping(new Indented(0))\n  lines.reverse.mkString(\"\", \"\\n\", \"\\n\").toList match {\n    case m mapping Nil ⇒\n      var result :List[YamlObject] = m\n      for (key ← target){\n        result = result.flatMap{\n          case o: YamlClass if o.key == key ⇒ o.properties\n          case _ ⇒ None\n        }\n      }\n      result match {\n        case Nil ⇒ println(\"no such property\")\n        case (h:YamlClass)::_ ⇒ println(\"object\")\n        case (h:Value)::_ ⇒ println(s\"\"\"string \"${h.string}\"\"\"\")\n      }\n    case _ ⇒ ???\n  }\n  sealed trait YamlObject\n  class YamlClass(val key: String, var properties: List[YamlObject]) extends YamlObject\n  class Value(val string: String) extends YamlObject\n\n\n  class Mapping(val indented: Indented) {\n    def unapply(arg: List[Char]): Option[(List[YamlClass], List[Char])] = {\n      val mappingItem = new MappingItem(indented)\n      val mapping = this\n      arg match {\n        case mi mappingItem xs ⇒\n          xs match {\n            case m mapping rest ⇒ Some(mi::m, rest)\n            case _ ⇒ Some(List(mi), xs)\n          }\n        case _ ⇒ None\n      }\n    }\n  }\n  class MappingOver(val indented: Indented) {\n    def unapply(arg: List[Char]): Option[(List[YamlClass], List[Char])] = {\n      val indentedOver = new IndentedOver(indented)\n      arg match {\n        case m indentedOver _ ⇒\n          val mapping = new Mapping(m)\n          arg match {\n            case l mapping rest ⇒ Some(l, rest)\n            case _ ⇒ None\n          }\n        case _ ⇒ None\n      }\n    }\n  }\n  class MappingItem(val indented: Indented) {\n    def unapply(arg: List[Char]): Option[(YamlClass, List[Char])] = {\n      arg match {\n        case indented(key Key ':'::rest) ⇒ rest match {\n          case ' '::(value Strings '\\n'::xs) ⇒ Some(new YamlClass(key, List(value)), xs)\n          case '\\n'::xs ⇒\n            val mapping = new MappingOver(indented)\n            xs match {\n              case l mapping t ⇒ Some(new YamlClass(key, l), t)\n              case _ ⇒ ???\n            }\n          case _ ⇒ ???\n        }\n        case _ ⇒ None\n      }\n    }\n  }\n  class IndentedOver(val indented: Indented) {\n    def unapply(arg: List[Char]): Option[(Indented, List[Char])] = {\n      arg.span(_.isSpaceChar) match {\n        case (x, xs) if x.length > indented.n ⇒ Some(new Indented(x.length), xs)\n        case _ ⇒ None\n      }\n    }\n  }\n  class Indented(val n: Int) extends AnyVal {\n    def unapply(arg: List[Char]): Option[List[Char]] = {\n      arg.span(_.isSpaceChar) match {\n        case (x, xs) if x.length == n ⇒ Some(xs)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Key {\n    def unapply(arg: List[Char]): Option[(String, List[Char])] = {\n      arg.span(_.isLetterOrDigit) match {\n        case (Nil, _) ⇒ None\n        case (key, xs) ⇒ Some(key.mkString, xs)\n      }\n    }\n  }\n  object Strings {\n    def unapply(arg: List[Char]): Option[(Value, List[Char])] = {\n      arg.span(c ⇒ c.isLetterOrDigit || c.isSpaceChar) match {\n        case (Nil, _) ⇒ None\n        case (words, rest) ⇒ Some(new Value(words.mkString), rest)\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nstring key;\nint pos;\n\nbool check(string a,string b){\n  int ima=pos,i=0,j=0;\n  while(a[i]==' ')i++;\n  while(b[i]==' ')j++;\n  if(i<j) return 0;\n  while((key[ima]!='.'&&a[i]!=':'&&key[ima]==a[i]))ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  string par;\n  while(pos<(int)key.size()){\n    while(idx<(int)str.size()&&!check(str[idx],par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=str[idx];\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nconst int N=50001;\nvector<string> key;\nvector<int> nindent;\nvector<string> mapping_item;\nint lx;\n\nbool dfs(int ni,int vx){\n  while(lx<mapping_item.size()){\n    const char *p=mapping_item[lx].c_str();\n    if(nindent[lx]==ni){\n      char b[N];\n      sscanf(p,\"%[^:]\",b);\n      if(key[vx]==b){\n\tif(vx+1==key.size()){\n\t  char s[N];\n\t  if(sscanf(p,\"%*[^:]: %[^\\n]\",s)==1){\n\t    printf(\"string \\\"%s\\\"\\n\",s);\n\t  }else{\n\t    puts(\"object\");\n\t  }\n\t  return true;\n\t}else if(++lx<nindent.size()&&nindent[lx]>ni){\n\t  if(dfs(nindent[lx],vx+1))return true;\n\t}\n      }else{\n\tlx++;\n      }\n    }else{\n      lx++;\n    }\n  }\n  return false;\n}\n\nint main(){\n  for(char b[N];scanf(\".%[^.\\n]\",b)==1;){\n    key.push_back(b);\n  }\n  getchar();\n  int ni;\n  for(;;){\n    int ni=0;\n    int d=getchar();\n    if(d==EOF)break;\n    for(;d==' ';d=getchar()){\n      ni++;\n    }\n    ungetc(d,stdin);\n    char b[N];\n    scanf(\"%[^\\n]%*c\",b);\n    nindent.push_back(ni);\n    mapping_item.push_back(b);\n  }\n  if(!dfs(0,0)){\n    puts(\"no such property\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<string>sts;\nvector<int>indnums;\nint a = 0;\nstruct yaml {\n\tbool is_dir;\n\tmap<string, yaml>mp;\n\tstring prop;\n\tvoid operator =(const yaml yaml_) {\n\t\tis_dir = yaml_.is_dir;\n\t\tmp = yaml_.mp;\n\t\tprop = yaml_.prop;\n\t}\n};\nyaml getmap(const int ind);\npair<string,yaml> getmapitem(const int ind) {\n\tyaml ayaml;\n\t\n\tconst int n = sts[a].find(':');\n\tstring key = sts[a].substr(indnums[a], n-indnums[a]);\n\tif (n == sts[a].size()-1) {\n\t\tayaml.is_dir = true;\n\t\ta++;\n\t\tayaml = getmap(indnums[a]);\n\t}\n\telse {\n\t\tayaml.is_dir = false;\n\t\tstring name = sts[a].substr(n + 2);\n\t\tayaml.prop = name;\n\t\ta++;\n\t}\n\treturn make_pair(key,ayaml);\n}\nyaml getmap(const int ind) {\n\tyaml ayaml;\n\tayaml.is_dir = true;\n\tayaml.mp.emplace(getmapitem(ind));\n\twhile (1) {\n\t\tif (a >= sts.size() || indnums[a] != ind)break;\n\t\tayaml.mp.emplace(getmapitem(ind));\n\t}\n\treturn ayaml;\n}\n\nint main() {\n\tstring st; cin >> st;\n\tint now = 1;\n\tvector<string>keys;\n\twhile (1) {\n\t\tint n = st.find('.',now);\n\t\tif (n == string::npos) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tkeys.emplace_back(st.substr(now, n-now));\n\t\t}\n\t\tnow = n+1;\n\t}\n\tkeys.emplace_back(st.substr(now));\n\tstring ast;\n\tgetline(cin, ast);\n\twhile (getline(cin,ast)) {\n\t\tint n = ast.find_first_not_of(' ');\n\t\tsts.push_back(ast);\n\t\tindnums.emplace_back(n);\n\t}\n\tyaml y=getmap(0);\n\tint anstype=0;\n\tstring ans;\n\tyaml nyaml = y;\n\t\n\tfor (int i = 0; i < keys.size(); ++i) {\n\t\tauto it = nyaml.mp.find(keys[i]);\n\t\tif (it == nyaml.mp.end()) {\n\t\t\tanstype = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tnyaml = it->second;\n\t\t}\n\t}\n\tif (anstype == -1) {\n\t\tcout << \"no such property\" << endl;\n\t}\n\telse {\n\t\tif (nyaml.is_dir) {\n\t\t\tcout << \"object\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"string \\\"\" << nyaml.prop << \"\\\"\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nstring req;\nvector<string> props;\nmain(){\n\tchar c;\n\tcin >> c >> req;\n\tREP(i, req.size()) if(req[i] == '.') req[i] = ' ';\n\tstringstream ss;\n\tss << req;\n\twhile(ss >> req){\n\t\tprops.push_back(req);\n\t}\n\t\n\tcin.ignore();\n\tint level = 0;\n\tint depth = 0;\n\tint prevsp = 0;\n\twhile(getline(cin, req)){\n\t\tint sp = 0, p = 0;\n\t\tstring prop;\n\t\tfor(;req[p] == ' ';p++);\n\t\tif(p < prevsp) depth --;\n\t\tif(p > prevsp) depth ++;\n\t\tprevsp = p;\n\t\tif(level > depth) break;\n\t\tif(level < depth) continue;\n\t\twhile(req[p] != ':') prop.push_back(req[p++\t]);\n\t\tif(props[level] == prop){\n\t\t\tlevel ++;\n\t\t}else continue;\n\t\tif(level == props.size()){\n\t\t\tif(p+1 == req.size()){\n\t\t\t\tputs(\"object\");\n\t\t\t}else{\n\t\t\t\tcout << \"string \\\"\" << req.substr(p+2) << \"\\\"\" << endl;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"no such property\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char deliter){\n  vector<string> res;\n  int prev_split_point = 0;\n  for (int i = 0; i < s.length(); i++) {\n    while(s[i] != deliter && i < s.length())i++;\n    while(s[i] == ' ')i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nstring slove(vector<string> &query,\n             map<string, string> &hash,\n             string s,\n             int i){\n  string res;\n  if(hash.find(s) == hash.end()){\n    return \"no such property\";\n  }\n  if(i == query.size() - 1){\n    return \"string \\\"\" + hash[s] + \"\\\"\";\n  }else if(hash.find(s) != hash.end() && hash[s] != \"\"){\n    res = slove(query, hash, query[i + 1], i + 1);\n  }else{\n    return \"object\";\n  }\n  return res;\n}\n\n\nint main(int argc, char *argv[]){\n  map<string, string> hash;\n  string s;\n  cin >> s;\n  vector<string> query = split(s, '.');\n  cin.ignore();\n  while(getline(cin, s)){\n    vector<string> vs = split(s, ':');\n    // for (int i = 0; i < vs.size(); i++) {\n    //   std::cout << vs[i] << std::endl;\n    // }\n    if(vs.size() > 1)hash[vs[0]] = vs[1];\n    else hash[vs[0]] = \"\";\n  }\n  std::cout << slove(query, hash, query[0], 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50001\n#define INF 1e9\n\nclass YAML{\npublic:\n  string s;\n  int state;\n  vector<string> next;\n};\n\nvector<int> space;\nYAML yaml[MAX];\n\nint getState(string &str,int d,vector<string> &v){\n  string now = str.substr(d);\n  string s,t;\n  int x = -1;\n  for(int i = 0 ; i < (int)now.size() ; i++){\n    if(now[i] == ':'){ x = d+i+2; break; }\n    s += now[i];\n  }\n  v.push_back(s);\n  if(x < (int)str.size()){\n    t = str.substr(x);\n    v.push_back(t);\n    return 1;\n  }\n  return 0;\n}\n\nvector<string> make_graph(int cur,int sp){\n  int len = space.size();\n  vector<string> res;\n  if(cur == len || yaml[cur].state == 1){ return res; }\n  int now = cur;\n  while(true){\n    if(now == len || sp > space[now]){ break; }\n    if(space[now] == INF){ now++; continue; }\n    if(sp == space[now]){\n      res.push_back(yaml[now].s);\n      cur = now;\n    }else if(sp < space[now]){\n      if(yaml[cur].next.size() == 0){\n        yaml[cur].next = make_graph(now,space[now]);\n      }\n    }\n    now++;\n  }\n  return res;\n}\n\nint main(){\n  int idx = 1;\n  string order,in;\n  map<string,int> mp;\n  space.push_back(-1);\n  yaml[0].s = \"->\";\n  cin >> order; cin.ignore();\n  while(getline(cin,in)){\n    int cnt = 0;\n    for(int i = 0 ; i < (int)in.size() ; i++){\n      if(in[i] == ' '){\n        cnt++;\n      }else{ break; }\n    }\n    space.push_back(cnt);\n    vector<string> v;\n    yaml[idx].state = getState(in,cnt,v);\n    yaml[idx].s = v[0];\n    mp[yaml[idx].s] = idx;\n    if(yaml[idx].state == 1){\n      yaml[idx].state = 0;\n      yaml[idx].next.push_back(v[1]);\n      idx++;\n      yaml[idx].s = v[1];\n      yaml[idx].state = 1;\n      mp[yaml[idx].s] = idx;\n      space.push_back(INF);\n    }\n    idx++;\n  }\n  /*\n  for(int i = 0 ; i < idx ; i++){\n    cout << yaml[i].s << \" \" << yaml[i].state << \" \";\n    for(auto x : yaml[i].next){\n      cout << x << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n  yaml[0].next = make_graph(1,space[1]);\n  /*\n  for(int i = 0 ; i < idx ; i++){\n    cout << yaml[i].s << \": \";\n    for(auto x : yaml[i].next){\n      cout << x << \" \";\n    }\n    cout << endl;\n  }\n  */\n  string t;\n  vector<string> strs;\n  for(int i = 0 ; i < (int)order.size() ; i++){\n    if(order[i] == '.'){\n      if(!t.empty()){ strs.push_back(t); }\n      t.clear();\n    }else{\n      t += order[i];\n    }\n  }\n  strs.push_back(t);\n  int now = 0,len = strs.size();\n  bool found = true;\n  for(int i = 0 ; i < len ; i++){\n    vector<string> vec = yaml[now].next;\n    bool ok = false;\n    for(int j = 0 ; j < (int)vec.size() ; j++){\n      if(vec[j] == strs[i]){\n        ok = true;\n        break;\n      }\n    }\n    now = mp[strs[i]];\n    if(!ok){\n      found = false;\n      break;\n    }\n  }\n  int size = yaml[now].next.size();\n  if(!found || size == 0){\n    cout << \"no such property\" << endl;;\n  }else{\n    if(size != 1){\n      cout << \"object\" << endl;\n    }else{\n      string ans = yaml[now].next[0];\n      cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  getline(cin, s);\n\n  vector<string> key;\n  string t = \"\";\n  int n = 0;\n  FOR(i, 1, s.size()) {\n    if(s[i] == '.') {\n      key.PB(t);\n      t = \"\";\n      n++;\n    } else {\n      t += s[i];\n    }\n  }\n  n++;\n  key.PB(t);\n  // cout << key << endl;\n\n  string ans = \"no such property\";\n  bool able = true;\n  int idx = 0, prev = 0, depth = 0;\n  while(getline(cin, t)) {\n    if(!able) continue;\n    int indent = 0;\n    string prop = \"\", str = \"\";\n    int flag = 0;\n    REP(i, t.size()) {\n      if(flag == 0 && t[i] != ' ') flag = 1;\n      if(flag == 1 && t[i] == ':') {flag = 2; i++; continue;}\n      if(flag == 0) indent++;\n      if(flag == 1) prop += t[i];\n      if(flag == 2) str += t[i];\n      // cout << \"i:\" << i << \" \" << prop << \" \" << str << endl;\n    }\n\n    if(prev < indent) depth++;\n    else if(prev > indent) {\n      depth--;\n      if(depth < idx) {\n        able = false;\n      }\n    }\n\n    if(idx < depth || !able) continue;\n\n    if(idx < n && prop == key[idx]) {\n      idx++;\n      if(idx == n) {\n        if(str == \"\") ans = \"object\";\n        else ans = \"string \\\"\" + str + \"\\\"\";\n        // break;\n      }\n    }\n    // cout << indent << \" \" << prop << \" \" << str << endl;\n    prev = indent;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nstruct Node{\n  string str;\n  string property;\n  vector<Node*> nodes;\n};\nvector<Node*> tree;\nvector<string> yaml;\n\nvector<Node*> dfs(int &pos,const int nowWsp){\n  vector<Node*> res;\n  int cnt=0;\n  while(pos<(int)yaml.size()){\n    cnt++;\n    Node *now=new Node();\n    int wsp=0;\n    string &s=yaml[pos];\n    for(int i=0;i<(int)s.size();i++)\n      if(s[i]==' ')wsp++;\n      else break;\n    int ps=0;\n    for(int i=0;i<(int)s.size();i++){\n      if(s[i]==':'){\n\tps=i+1;\n\tbreak;\n      }\n    }\n    string name=s.substr(wsp,ps-wsp-1);\n    string property=\"\";\n    if(ps!=(int)s.size())property=s.substr(ps+1);\n    now->str=name;\n    now->property=property;\n    if(wsp<nowWsp){\n      return res;\n    }\n    else if(property==\"\"){\n      pos++;\n      int p=0;\n      for(int i=0;i<(int)yaml[pos].size();i++)\n\tif(yaml[pos][i]==' ')p++;\n\telse break;\n      now->nodes=dfs(pos,p);\n    }\n    else pos++;\n    res.push_back(now);\n  }\n  return res;\n}\nconst string nsp=\"no such property\";\nconst string obj=\"object\";\nstring search(Node *now,int pos,vector<string>&vs){\n  for(int i=0;i<(int)now->nodes.size();i++){\n    //cout<<now->nodes[i]->str<<endl;\n    if(now->nodes[i]->str==vs[pos]){\n      if((int)vs.size()-1==pos){\n\tif(now->nodes[i]->property==\"\")return obj;\n\treturn now->nodes[i]->property;\n      }\n      return search(now->nodes[i],pos+1,vs);\n    }\n  }\n  return nsp;\n}\n\nint main(){\n  string order;\n  getline(cin,order);\n  order=order.substr(1);\n  vector<string> os;\n  int spos=0;\n  for(int i=0;i<(int)order.size();i++){\n    if(order[i]=='.'){\n      os.push_back(order.substr(spos,i-spos));\n      spos=i+1;\n    }\n  }\n  os.push_back(order.substr(spos));\n  string st;\n  while(getline(cin,st))\n    yaml.push_back(st);\n  int a=0;\n  vector<Node*> root=dfs(a,0);\n  Node *rt=new Node();\n  rt->nodes=root;\n  string s=search(rt,0,os);\n  if(s==obj||s==nsp)cout<<s<<endl;\n  else cout<<\"string \\\"\"<<s<<\"\\\"\"<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  getline(cin, s);\n\n  vector<string> key;\n  string t = \"\";\n  int n = 0;\n  FOR(i, 1, s.size()) {\n    if(s[i] == '.') {\n      key.PB(t);\n      t = \"\";\n      n++;\n    } else {\n      t += s[i];\n    }\n  }\n  n++;\n  key.PB(t);\n  // cout << key << endl;\n\n  string ans = \"no such property\";\n  int idx = 0;\n  while(getline(cin, t)) {\n    string prop = \"\", str = \"\";\n    int flag = 0;\n    REP(i, t.size()) {\n      if(flag == 0 && t[i] != ' ') flag = 1;\n      if(flag == 1 && t[i] == ':') {flag = 2; i++; continue;}\n      if(flag == 1) prop += t[i];\n      if(flag == 2) str += t[i];\n      // cout << \"i:\" << i << \" \" << prop << \" \" << str << endl;\n    }\n\n    if(idx < n && prop == key[idx]) {\n      idx++;\n      if(idx == n) {\n        if(str == \"\") ans = \"object\";\n        else ans = \"string \\\"\" + str + \"\\\"\";\n        // break;\n      }\n    }\n    // cout << idx << endl << prop << endl << str << endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring prop[32];\n\nint main()\n{\n    rep(i,32) prop[i] = \"\";\n    string in;\n    cin >> in;\n    int sz = 0;\n    rep(i,in.size()){\n\tif(in[i] == '.') sz++;\n\telse prop[sz-1] += in[i];\n    }\n    int pos = 0;\n    int depth = 0;\n    int prev = 0;\n    bool flag = false;\n    cin.ignore();\n    while(getline(cin,in)){\n\tif(in.size() == 0) break;\n\tint cur = 0;\n\twhile(in[cur] == ' ') cur++;\n\tstring tag = \"\", str = \"\";\n\tint t = cur;\n\twhile(in[t] != ':') tag += in[t++];\n\tt += 2;\n\twhile(t < in.size()) str += in[t++];\n\tif(cur > prev) depth++;\n\tif(cur < prev) depth--;\n\tif(depth < pos) break;\n\tif(depth == pos && prop[pos] == tag){\n\t    pos++;\n\t    if(pos == sz){\n\t\tif(str.size() == 0) cout << \"object\\n\";\n\t\telse cout << \"string \\\"\" << str << \"\\\"\\n\";\n\t\treturn 0;\n\t    }\n\t}\n\tprev = cur;\n    }\n    cout << \"no such property\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nstring yaml[50010];\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tvector<string> keys;\n\n\twhile(s!=\"\"){\n\t\tint cur=1;\n\t\twhile(cur<s.size()&&s[cur]!='.') cur++;\n\t\tkeys.push_back(s.substr(1,cur-1));\n\t\ts=s.substr(cur);\n\t}\n\n\tcin.ignore();\n\t\n\tint n=0;\n\twhile(1){\n\t\tgetline(cin,yaml[n++]);\n\t\tif(cin.eof()) break;\n\t}\n\n\tbool not_found=false;\n\n\tint cur=0,pos=0;\n\twhile(1){\n\t\tconst int len=keys[pos].size();\n\t\twhile(cur<n){\n\t\t\tif(keys[pos]==yaml[cur].substr(pos,len))\n\t\t\t\tbreak;\n\t\t\tcur++;\n\t\t}\n\t\t\n\t\t//cout << cur << \" \" << pos << endl;\n\n\t\tif(cur==n){\n\t\t\tnot_found=true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(pos/2+1==keys.size()) break;\n\t\tcur++,pos+=2;\n\t}\n\n\tif(not_found){\n\t\tcout << \"no such property\" << endl;\n\t\treturn 0;\n\t}\n\n\tstring elem=yaml[cur].substr(pos+1+keys[keys.size()-1].size());\n\tif(elem==\"\")\n\t\tcout << \"object\" << endl;\n\telse{\n\t\telem=elem.substr(1,elem.size()-1);\n\t\tcout << \"string \\\"\"  << elem << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char deliter){\n  vector<string> res;\n  int prev_split_point = 0;\n  for (int i = 0; i < s.length(); i++) {\n    while(s[i] != deliter && i < s.length() && s[i] != ' ')i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nstring slove(vector<string> &query,\n             map<string, string> &hash,\n             string s,\n             int i){\n  string res;\n  if(hash.find(s) == hash.end()){\n    return \"no such property\";\n  }\n  if(i == query.size() - 1){\n    return \"string \\\"\" + hash[s] + \"\\\"\";\n  }else if(hash.find(s) != hash.end() && hash[s] != \"\"){\n    res = slove(query, hash, query[i + 1], i + 1);\n  }else{\n    return \"object\";\n  }\n  return res;\n}\n\n\nint main(int argc, char *argv[]){\n  map<string, string> hash;\n  string s;\n  cin >> s;\n  vector<string> query = split(s, '.');\n  cin.ignore();\n  while(getline(cin, s)){\n    vector<string> vs = split(s, ':');\n    // for (int i = 0; i < vs.size(); i++) {\n    //   std::cout << vs[i] << std::endl;\n    // }\n    if(vs.size() > 1)hash[vs[0]] = vs[1];\n    else hash[vs[0]] = \"\";\n  }\n  std::cout << slove(query, hash, query[0], 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstd::vector<std::string> properties;\nstd::string yaml;\nint p_i{};\n\nstd::string calcProperty(int);\nint calcDepth(std::string&);\nvoid readThrough(int);\nstd::string calcString(int&);\nstd::string getString(std::string&, int&);\n\nint main()\n{\n\tstd::string tmp;\n\tstd::getline(std::cin, tmp);\n\tfor (int p_i{1}; p_i < (int)tmp.size(); p_i++)\n\t{\n\t\tproperties.push_back({});\n\t\twhile (p_i < (int)tmp.size() && tmp[p_i] != '.')\n\t\t{\n\t\t\tproperties.back().push_back(tmp[p_i]);\n\t\t\tp_i++;\n\t\t}\n\t}\n\t\n\tstd::getline(std::cin, yaml);\n\tstd::cout << calcProperty(0) << std::endl;\n\n\treturn 0;\n}\n\nstd::string calcProperty(int depth)\n{\n\tif (p_i == (int)properties.size())\n\t\treturn \"object\";\n\n\twhile (!std::cin.eof() && calcDepth(yaml) == depth)\n\t{\n\t\tint s_i{depth};\n\t\tstd::string key{getString(yaml, s_i)};\n\t\tif (key != properties[p_i])\n\t\t\treadThrough(depth);\n\t\telse\n\t\t{\n\t\t\tp_i++;\n\t\t\tif (s_i == (int)yaml.size())\n\t\t\t{\n\t\t\t\tstd::getline(std::cin, yaml);\n\t\t\t\treturn calcProperty(calcDepth(yaml));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts_i++;\n\t\t\t\treturn calcString(s_i);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"no such property\";\n}\n\nint calcDepth(std::string& str)\n{\n\tfor (int i{}; i < (int)str.size(); i++)\n\t\tif (str[i] != ' ')\n\t\t\treturn i;\n\treturn -1;\n}\n\nstd::string getString(std::string& yaml, int& s_i)\n{\n\tstd::string ret;\n\twhile (s_i < (int)yaml.size() && yaml[s_i] != ':')\n\t{\n\t\tret += yaml[s_i];\n\t\ts_i++;\n\t}\n\ts_i++;\n\treturn std::move(ret);\n}\n\nstd::string calcString(int& s_i)\n{\n\tif (p_i < (int)properties.size())\n\t\treturn \"no such property\";\n\telse\n\t\treturn \"string \\\"\" + getString(yaml, s_i) + \"\\\"\";\n}\n\nvoid readThrough(int depth)\n{\n\tstd::getline(std::cin, yaml);\n\twhile (!std::cin.eof() && calcDepth(yaml) > depth)\n\t\tstd::getline(std::cin, yaml);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nstring yaml[50010];\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tvector<string> keys;\n\n\twhile(s!=\"\"){\n\t\tint cur=1;\n\t\twhile(cur<s.size()&&s[cur]!='.') cur++;\n\t\tkeys.push_back(s.substr(1,cur-1));\n\t\ts=s.substr(cur);\n\t}\n\n\tcin.ignore();\n\t\n\tint n=0;\n\twhile(1){\n\t\tgetline(cin,yaml[n++]);\n\t\tif(cin.eof()) break;\n\t}\n\n\t//cout << n << endl;\n\tbool not_found=false;\n\n\tint cur=0,idx=0,pos=0;\n\twhile(1){\n\t\tconst int len=keys[idx].size();\n\t\twhile(cur<n){\n\t\t\tif(pos+len<=yaml[cur].size()&&keys[idx]==yaml[cur].substr(pos,len))\n\t\t\t\tbreak;\n\t\t\tcur++;\n\t\t}\n\t\t\n\t\t//cout << cur << \" \" << idx << \" \" << pos << endl;\n\n\t\tif(cur==n){\n\t\t\tnot_found=true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(idx+1==keys.size()) break;\n\t\tcur++,idx++;\n\n\t\tif(cur==n || yaml[cur][pos]!=' '){\n\t\t\tnot_found=true;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile(pos<yaml[cur].size() && yaml[cur][pos]==' ') pos++;\n\t}\n\n\tif(not_found){\n\t\tcout << \"no such property\" << endl;\n\t\treturn 0;\n\t}\n\n\tstring elem=yaml[cur].substr(pos+1+keys[keys.size()-1].size());\n\tif(elem==\"\")\n\t\tcout << \"object\" << endl;\n\telse{\n\t\telem=elem.substr(1,elem.size()-1);\n\t\tcout << \"string \\\"\"  << elem << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<string> lines;\nvector<string> v;\nstring ans;\n\nvoid solve(int &id, int indent, int now) {\n  while(id<lines.size()) {\n    int ind = 0;\n    while(lines[id][ind] == ' ') ++ind;\n    if (ind < indent) {\n      return;\n    }\n    int t = lines[id].find(':');\n    string a = lines[id].substr(ind,t-ind);\n    string b = \"\";\n    if (t+2<lines[id].size()) b = lines[id].substr(t+2);\n    id++;\n    if (a == v[now]) {\n      if (now == v.size()-1) {\n        ans = b;\n      } else {\n        solve(id, ind+1, now+1);\n      }\n    } else {\n      // 違ったらそれより下位のものを飛ばす\n      while(id<lines.size()) {\n        int tmp = 0;\n        while(lines[id][tmp] == ' ') ++tmp;\n        if (tmp <= ind) {\n          break;\n        }\n        id++;\n      }\n    }\n  }\n}\n\nint main() {\n  string in;\n  cin >> in;\n  FOR(it, in) if (*it == '.') *it = ' ';\n  stringstream ss(in);\n  string t;\n  while(ss >> t) {\n    v.push_back(t);\n  }\n  string line;\n  getline(cin,line);\n  while(getline(cin,line)) {\n    lines.push_back(line);\n  }\n  int id = 0;\n  ans = \"*\";\n  solve(id, 0, 0);\n  if (ans == \"*\") {\n    puts(\"no such property\");\n  } else if (ans == \"\") {\n    puts(\"object\");\n  } else {\n    printf(\"string \\\"%s\\\"\\n\", ans.c_str());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nstring key;\nint pos;\n\nbool check(string a,string b){\n  int ima=pos,i=0,j=0;\n   while(a[i]==' ')i++;\n  while(b[i]==' ')j++;\n  if(pos!=1&&i<=j) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  string par;\n  while(pos<(int)key.size()){\n    idx=0;\n    while(idx<(int)str.size()&&!check(str[idx],par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=str[idx];\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\n\nclass Input{\n\tpublic:\n\tbool isObject;\n\tint space;\n\tstring key;\n\tstring data;\n\t\n\tInput(string str){\n\t\tint nspace = 0;\n\t\tfor(;;nspace++)if(str[nspace]!=' ')break;\n\t\t\n\t\tint colon = nspace;\n\t\tfor(;;colon++)if(str[colon-1]==':')break;\n\t\t\n\t\tint lspace =  colon+1;\n\t\t\n\t\tspace = nspace;\n\t\tkey = str.substr(nspace, colon-nspace-1);\n\t\t\n\t\tif(lspace+1 <= str.size()){\n\t\t\tdata = str.substr(lspace, str.size()-lspace);\n\t\t\tisObject = false;\n\t\t}else{\n\t\t\tisObject = true;\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tcout<<\"sp = \"<<space<<\" key=\"<<key<<\" data=\"<<data<<endl;\n\t}\n};\n\n\nstring query;\nvector<Input> in;\n\n\nbool input(){\n\tgetline(cin, query);\n\twhile(!cin.eof()){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif(s==\"\")break;\n\t\tin.pb(Input(s));\n\t}\n\treturn true;\n}\n\nclass Data{\n\tpublic:\n\tbool isprop;\n\tstring prop;\n\tstring key;\n\tvector<Data> data;\n\t\n\tData(string key){\n\t\tisprop = false;\n\t\tthis->key = key;\n\t}\n\tData(string key, string prop){\n\t\tisprop = true;\n\t\tthis->key = key;\n\t\tthis->prop = prop;\n\t}\n\t\n\tvoid print(int index){\n\t\tstring space = \"\";\n\t\trep(i,index)space += ' ';\n\t\t\n\t\tcout<<space; puts(\"----------------------\");\n\t\tcout<<space; cout<<\"key    : '\"<<key<<\"'\"<<endl;\n\t\tcout<<space; cout<<\"isprop : \"<<isprop<<endl;\n\t\tcout<<space; cout<<\"prop   : '\"<<prop<<\"'\"<<endl;\n\t\trep(i,data.size()){\n\t\t\tdata[i].print(index+2);\n\t\t}\n\t}\n};\n\n\nData kaiseki(int st, int en){\n\t\n\t//printf(\"st=%d  en=%d\\n\",st,en);\n\tif(st+1==en){\n\t\treturn Data(in[st].key,  in[st].data);\n\t}\n\t\n\t\n\tData ret(in[st].key);\n\tint head = st+1;\n\tint stspace = in[st+1].space;\n\treps(i,st+2, en+1){\n\t\tif(i==en || in[i].space==stspace){\n\t\t\tret.data.pb(kaiseki(head, i));\n\t\t\thead = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstring calc(Data& data, string& q){\n\t\n\t\n\tif(q==\"\"){\n\t\tif(data.isprop){\n\t\t\tstringstream sst;\n\t\t\treturn \"string \\\"\"+data.prop+\"\\\"\";\n\t\t}\n\t\treturn \"object\";\n\t}\n\t\n\tint en = 1;\n\tfor(;en<q.size();en++){\n\t\tif(q[en]=='.')break;\n\t}\n\tstring key = q.substr(1, en-1);\n\tstring nq = q.substr(en, q.size()-(en));\n\t\n\t//cout<<\"q:\"<<q<<\"   nq:\"<<nq<<\"   key:\"<<key<<endl;\n\trep(i,data.data.size()){\n\t\tif(data.data[i].key==key){\n\t\t\treturn calc(data.data[i], nq);\n\t\t}\n\t}\n\t\n\treturn \"no such property\";\n}\n\n\nvoid solve(){\n\tData parent(\"parent\");\n\t\n\tint head = 0;\n\treps(i,1,in.size()+1){\n\t\tif(i==in.size() || in[i].space==0){\n\t\t\tparent.data.pb(kaiseki(head, i));\n\t\t\thead=i;\n\t\t}\n\t}\n\tstring ans = calc(parent, query);\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <cctype>\n#include <sstream>\nusing namespace std;\ntypedef string::const_iterator State;\nint len;\nstring inpro;\nstring in[50];\nstring str;\nvector<string> property;\n\nvoid split(const string &str,char delim){\n\tistringstream iss(str);\n\tstring tmp;\n\tgetline(iss,tmp,delim);\n\twhile(getline(iss,tmp,delim))property.push_back(tmp);\n\tlen=property.size();\n}\n\nstring func(State &begin,int depth,int indent){\n\tif(begin==str.end())return \"no such property\";\n\tint cnt=0;\n\twhile(*begin==' '){\n\t\tbegin++;\n\t\tcnt++;\n\t}\n\tif(indent==-1)indent=cnt;\n\telse if(indent!=cnt){\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(cnt<indent || begin!=str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n\tstring key=\"\";\n\twhile(*begin!=':'){\n\t\tkey+=*begin;\n\t\tbegin++;\n\t}\n\tbegin++;\n\tif(key==property[depth]){\n\t\tif(depth==len-1){\n\t\t\tif(*begin=='\\n')return \"object\";\n\t\t\telse{\n\t\t\t\tstring res=\"\";\n\t\t\t\tbegin++;\n\t\t\t\twhile(*begin!='\\n'){\n\t\t\t\t\tres+=*begin;\n\t\t\t\t\tbegin++;\n\t\t\t\t}\n\t\t\t\tstring ans=\"string \";\n\t\t\t\tans+='\"';\n\t\t\t\tans+=res;\n\t\t\t\tans+='\"';\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}else{\n\t\t\tif(*begin=='\\n'){\n\t\t\t\treturn func(++begin,++depth,-1);\n\t\t\t}else return \"no such property\";\n\t\t}\n\t}else{\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(begin==str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n}\n\nint main(void){\n\tgetline(cin,inpro);\n\tsplit(inpro,'.');\n\tint cnt=0;\n\twhile(getline(cin,in[cnt]))cnt++;\n\tfor(int i=0;i<cnt;i++){\n\t\tstr+=in[i];\n\t\tstr+='\\n';\n\t}\n\tState begin=str.begin();\n\tcout << func(begin,0,-1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct dat{\n\tstring value;\n\tmap<string, dat> p;\n};\n\ndat mapping(){\n\tstring s;\n\tdat res;\n\twhile (getline(cin, s)){\n\t\tint l = 0;\n\t\twhile (s[l] == ' ') ++l;\n\t\tint idx = s.find(':');\n\t\tstring t = s.substr(idx);\n\t\tdat d;\n\t\tif (t.size() > 2) d.value = t.substr(2);\n\t\telse d = mapping();\n\n\t\tres.p[s.substr(l, idx-l)] = d;\n\t}\n\treturn res;\n}\n\nint main(){\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\n\tdat d = mapping();\n\n\tfor (auto &c : query) if (c == '.') c = ' ';\n\n\tstringstream ss(query);\n\tstring s;\n\tdat *p = &d;\n\twhile (ss >> s){\n\t\tif (!p->p.count(s)) goto NG;\n\t\tp = &(p->p[s]);\n\t}\n\n\tif (p->value.empty()) cout << \"object\" << endl;\n\telse cout << \"string \\\"\" << p->value << \"\\\"\" << endl;\n\n\treturn 0;\nNG:\n\tcout << \"no such property\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2438&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nstring YAML[50010];\n\nvector<string> split(const string &s, char delim) {\n\tvector<string> elems;\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, delim)) {\n\t\tif (!item.empty()) {\n\t\t\telems.push_back(item);\n\t\t}\n\t}\n\treturn elems;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring k; cin >> k;\n\tauto key = split(k, '.');\n\tint key_cnt = key.size();\n\tcin.ignore();\n\tint cnt = 0;\n\twhile (getline(cin, YAML[cnt++]));\n\tint pre_space = 0;\n\tint key_at = 0;\n\tbool next_flag = false;\n\tbool through = false;\n\tfor (int i = 0; i < cnt;i++) {\n\t\tauto yaml = split(YAML[i], ':');\n\t\tint space;\n\t\tfor (int l = 0; l < yaml[0].length(); l++) if (yaml[0][l] != ' ') { space = l; break; }\n\n\t\tif (through & (space != pre_space)) continue;\n\t\telse through = false;\n\n\t\tif (next_flag) { pre_space = space; next_flag = false; }\n\t\tif (yaml[0].substr(space) == key[key_at]) {\n\t\t\tkey_at++;\n\t\t\tif (key_at == key_cnt) {\n\t\t\t\tif (yaml.size() == 2) {\n\t\t\t\t\tyaml[1][0] = '\"';\n\t\t\t\t\tcout << \"string \" << yaml[1] << '\"' << endl; return 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"object\" << endl; return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (yaml.size() == 2)break;\n\t\t\t\telse {\n\t\t\t\t\tnext_flag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (yaml.size() == 1)through = true;\n\t\t\telse continue;\n\t\t}\n\t}\n\tcout << \"no such property\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nvector <int> cnt;\nstring key;\nint pos;\n\nbool check(string a,int x,int y){\n  int ima=pos,i=0,j=0;\n  if(cnt[x]<cnt[y]) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  int par;\n  while(pos<(int)key.size()){\n    while(idx<(int)str.size()&&!check(str[idx],idx,par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=idx;\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  for(int i=0;i<str.size();i++){\n    int j=0;\n    while(str[i][j]==' ') j++;\n    cnt.push_back(j+1);\n    str[i]=str[i].substr(j,str[i].size()-j);\n  }\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 50000\n \nstring s;\nint size=0;\nmap<string,int> mp[MAX];\nstring name[MAX];\nint cnt[MAX];\n \nint main(){\n  string str;\n  getline(cin,str);\n  stack<P> st;\n  st.push(P(-1,0));\n   \n  while(getline(cin,s)){\n    size++;\n    string a=\"\",b=\"\";\n    int i,len=s.size(),ra=0;\n    for(i=0;s[i]==' ';i++)ra++;\n    for(;s[i]!=':';i++)a.push_back(s[i]);\n    if(i+1<len&&s[i+1]==' '){\n      for(i=i+2;i<len;i++)b.push_back(s[i]);\n    }\n    //cout<<ra<<' '<<a<<' '<<b<<endl;\n \n    P p;\n    while(1){\n      p=st.top();\n      if(p.first >= ra){\n        st.pop();\n      }else{\n        break;\n      }\n    }\n \n    mp[p.second][a]=size;\n    // cout<<p.second<<' '<<a<<' '<<size<<endl;\n \n    if(b==\"\")name[size]=\"object\";\n    else name[size]=b;\n \n    cnt[p.second]++;\n    st.push(P(ra,size));\n  }\n   \n \n  for(int i=0;i<(int)str.size();i++){\n    if(str[i]=='.')str[i]=' ';\n  }\n \n  stringstream ss(str);\n  string tmp;\n  int p=0;\n  vector<string> vec;\n  while(ss>>tmp)vec.push_back(tmp);\n   \n  for(int i=0;i<(int)vec.size();i++){\n    if(mp[p][vec[i]]==0){\n      cout<<\"no such property\"<<endl;\n      return 0;\n    }\n    p=mp[p][vec[i]];\n  }\n  if(cnt[p]==0)cout<<\"string \\\"\"<<name[p]<<\"\\\"\"<<endl;\n  else cout<<name[p]<<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=50005,INF=1<<30;\nstruct dat{\n    int space;\n    string A;\n    string B;\n};\nstring X;\nvector<dat> T;\nmap<string,set<string>> G;\n\nvoid bunkai(string S){\n    int space=0,i=0;\n    string A,B;\n    while(i<si(S)&&S[i]==' '){\n        i++;\n        space++;\n    }\n    while(i<si(S)&&S[i]!=':'){\n        A+=S[i];\n        i++;\n    }\n    i+=2;\n    while(i<si(S)){\n        B+=S[i];\n        i++;\n    }\n    \n    T.push_back({space,A,B});\n}\n\nvoid DFS(int u,int p){\n    if(p!=-1){\n        G[T[p].A].insert(T[u].A);\n    }\n    if(si(T[u].B)){\n        G[T[u].A].insert(T[u].B);\n        return;\n    }\n    \n    int d=T[u+1].space;\n    if(d<=T[u].space) return;\n    \n    for(int k=u+1;k<si(T);k++){\n        if(T[k].space==d){\n            DFS(k,u);\n        }else if(T[k].space<=T[u].space) return;\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    getline(cin,X);\n    \n    T.push_back({-1,\"\",\"\"});\n    while(1){\n        string x;\n        getline(cin,x);\n        if(x==\"\") break;\n        bunkai(x);\n    }\n    \n    DFS(0,-1);\n    \n    int i=0;\n    string now=\"\";\n    \n    bool ok=true;\n    \n    while(i<si(X)){\n        if(X[i]=='.') i++;\n        string S;\n        while(i<si(X)&&X[i]!='.'){\n            S+=X[i];\n            i++;\n        }\n        \n        if(G[now].count(S)){\n            now=S;\n        }else{\n            ok=false;\n            break;\n        }\n    }\n    if(!ok){\n        cout<<\"no such property\"<<endl;\n    }else{\n        if(si(G[now])==1){\n            string to=*G[now].begin();\n            if(si(G[to])) cout<<\"object\"<<endl;\n            else cout<<\"string \"<<'\"'<<*G[now].begin()<<'\"'<<endl;\n        }else if(si(G[now])) cout<<\"object\"<<endl;\n        else cout<<\"no such property\"<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct value{\n\tvirtual string get_prop(vs &keys,int pos)=0;\n};\n\nstruct mapping_item{\n\tstring key;\n\tvalue *v;\n};\n\nstruct text:public value{\n\tstring s;\n\tvirtual string get_prop(vs &keys,int pos){\n\t\tif(pos==keys.size()){\n\t\t\treturn \"string \\\"\" + s + \"\\\"\";\n\t\t}else{\n\t\t\treturn \"no such property\";\n\t\t}\n\t}\n};\n\nstruct mapping:public value{\n\tvector<mapping_item> mapping_items;\n\tvirtual string get_prop(vs &keys,int pos){\n\t\tif(pos==keys.size()){\n\t\t\treturn \"object\";\n\t\t}\n\t\tREP(i,mapping_items.size()){\n\t\t\tif(mapping_items[i].key==keys[pos]){\n\t\t\t\treturn mapping_items[i].v->get_prop(keys,pos+1);\n\t\t\t}\n\t\t}\n\t\treturn \"no such property\";\n\t}\n};\n\n\nmapping *read_mapping(string &s,int &pos,int n);\n\n//mapping-item(n): indent(n) key ':' ' ' string '\\n'\n//                 | indent(n) key ':' '\\n' mapping(m) (ただしm>n)\nmapping_item read_mapping_item(string &s,int &pos,int n){\n\tmapping_item m;\n\t//indent(0): \"\" (※空文字列)\n\t//indent(n+1): ' ' indent(n) (※スペースをn+1個並べた文字列)\n\tREP(i,n){\n\t\tassert(s[pos]==' ');\n\t\tpos++;\n\t}\n\t//key: [a-z0-9]+ (※英字小文字または数字からなる1文字以上の文字列)\n\twhile(s[pos]!=':'){\n\t\tm.key+=s[pos];\n\t\tpos++;\n\t}\n\tassert(s[pos]==':');\n\tpos++;\n\tif(s[pos]==' '){\n\t\tpos++;\n\t\t//string: [a-z0-9 ]+ (※英字小文字または数字またはスペースからなる1文字以上の文字列)\n\t\ttext *t=new text;\n\t\twhile(s[pos]!='\\n'){\n\t\t\tt->s+=s[pos];\n\t\t\tpos++;\n\t\t}\n\t\tassert(s[pos]=='\\n');\n\t\tpos++;\n\t\tm.v=t;\n\t}else{\n\t\tassert(s[pos]=='\\n');\n\t\tpos++;\n\t\tint cnt=0;\n\t\twhile(s[pos+cnt]==' '){\n\t\t\tcnt++;\n\t\t}\n\t\tm.v=read_mapping(s,pos,cnt);\n\t}\n\treturn m;\n}\n\n//mapping(n): mapping-item(n) | mapping-item(n) mapping(n)\nmapping *read_mapping(string &s,int &pos,int n){\n\tmapping* m=new mapping;\n\twhile(pos<s.size()){\n\t\tint cnt=0;\n\t\twhile(s[pos+cnt]==' '){\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt!=n)break;\n\t\tm->mapping_items.push_back(read_mapping_item(s,pos,n));\n\t}\n\treturn m;\n}\n\n//yaml: mapping(0)\nmapping *read_yaml(string &s){\n\tint pos=0;\n\treturn read_mapping(s,pos,0);\n}\n\nint main(){\n\tstring key_str;\n\tcin>>key_str;\n\tstring yaml_str;\n\tstring line;\n\tgetline(cin,line);\n\twhile(getline(cin,line)){\n\t\tyaml_str+=line+'\\n';\n\t}\n\tstring s;\n\tvs keys;\n\tFOR(i,1,key_str.size()){\n\t\tif(key_str[i]=='.'){\n\t\t\tkeys.push_back(s);\n\t\t\ts=\"\";\n\t\t}else{\n\t\t\ts.push_back(key_str[i]);\n\t\t}\n\t}\n\tif(s.size()){\n\t\tkeys.push_back(s);\n\t}\n\tmapping* yaml=read_yaml(yaml_str);\n\tcout<<yaml->get_prop(keys,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvector< string > split(string s, string cc)\n{\n  s += cc;\n  int tail = 0;\n  string buff;\n  vector< string > ret;\n  while(tail < s.size()) {\n    if(cc.find(s[tail]) != string::npos) {\n      if(buff.size()) ret.push_back(buff);\n      buff.clear();\n    } else {\n      buff += s[tail];\n    }\n    ++tail;\n  }\n  return (ret);\n}\n\nint main()\n{\n  string K, S;\n  vector< string > data;\n  cin >> K;\n  cin.ignore();\n  while(getline(cin, S)) data.push_back(S);\n\n  auto latte = split(K, \".\");\n\n  bool flag = false;\n  vector< pair< string, int > > vs;\n\n  auto ismatch = [&]\n  {\n    if(vs.size() != latte.size()) return (false);\n    for(int i = 0; i < vs.size(); i++) if(vs[i].first != latte[i]) return (false);\n    return (true);\n  };\n\n  for(auto &s : data) {\n    auto malta = split(s, \" :\");\n\n\n    int indent = 0;\n    while(s[indent] == ' ') ++indent;\n    while(vs.size() && indent <= vs.back().second) vs.pop_back();\n    vs.emplace_back(malta[0], indent);\n    if(ismatch()) {\n      if(malta.size() == 1) cout << \"object\" << endl;\n      else cout << \"string \\\"\" << s.substr(s.find(':') + 2) << \"\\\"\" << endl;\n      flag = true;\n      break;\n    }\n  }\n\n  if(!flag) cout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nvector <int> cnt;\nstring key;\nint pos;\n \nbool check(string a,int x,int y){\n  int ima=pos,i=0,j=0;\n  if(cnt[x]<=cnt[y]&&pos!=1) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n \nstring bnf(){\n  int idx=0;\n  int par=0;\n  while(pos<(int)key.size()){\n    while(idx<(int)str.size()&&!check(str[idx],idx,par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=idx;\n  }\n \n \n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n \nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  for(int i=0;i<str.size();i++){\n    int j=0;\n    while(str[i][j]==' ') j++;\n    cnt.push_back(j+1);\n    str[i]=str[i].substr(j,str[i].size()-j);\n  }\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint main() {\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\tvector<pair<int, string>> cn;\n\tmap<string, string> obj;\n\tstring buf;\n\twhile (getline(cin, buf)) {\n\t\tint i = 0,j;\n\t\tfor (; buf[i] == ' '; i++);\n\t\tif (buf.back() == ':') {\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tcn.push_back(make_pair(i, ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(cn.back().second,\"*\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tcn.push_back(make_pair(i, cn.back().second + ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(cn.back().second,\"*\"));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (j = i; buf[j] != ':'; j++);\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tobj.insert(make_pair(((string)\".\").append(buf.begin() + i, buf.begin() +j), ((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tobj.insert(make_pair(cn.back().second + ((string)\".\").append(buf.begin() + i, buf.begin()+j),((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t}\n\t}\n\tauto res = obj[query];\n\tif (res==\"\")res == \"no such property\";\n\telse if(res == \"*\")res = \"object\";\n\telse res = \"string \\\"\" + res + \"\\\"\";\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  getline(cin, s);\n\n  vector<string> key;\n  string t = \"\";\n  int n = 0;\n  FOR(i, 1, s.size()) {\n    if(s[i] == '.') {\n      key.PB(t);\n      t = \"\";\n      n++;\n    } else {\n      t += s[i];\n    }\n  }\n  n++;\n  key.PB(t);\n  // cout << key << endl;\n\n  string ans = \"no such property\";\n  int idx = 0;\n  while(getline(cin, t)) {\n    string prop = \"\", str = \"\";\n    int flag = 0;\n    REP(i, t.size()) {\n      if(flag == 0 && t[i] != ' ') flag = 1;\n      if(flag == 1 && t[i] == ':') {flag = 2; i++; continue;}\n      if(flag == 1) prop += t[i];\n      if(flag == 2) str += t[i];\n      // cout << \"i:\" << i << \" \" << prop << \" \" << str << endl;\n    }\n\n    if(prop == key[idx]) {\n      idx++;\n      if(idx == n) {\n        if(str == \"\") ans = \"object\";\n        else ans = \"string \\\"\" + str + \"\\\"\";\n      }\n    }\n    // cout << idx << endl << prop << endl << str << endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nstring yaml[50010];\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tvector<string> keys;\n\n\twhile(s!=\"\"){\n\t\tint cur=1;\n\t\twhile(cur<s.size()&&s[cur]!='.') cur++;\n\t\tkeys.push_back(s.substr(1,cur-1));\n\t\ts=s.substr(cur);\n\t}\n\n\tcin.ignore();\n\t\n\tint n=0;\n\twhile(1){\n\t\tgetline(cin,yaml[n++]);\n\t\tif(cin.eof()) break;\n\t}\n\n\t//cout << n << endl;\n\tbool not_found=false;\n\n\tint cur=0,pos=0;\n\twhile(1){\n\t\tconst int len=keys[pos/2].size();\n\t\twhile(cur<n){\n\t\t\tif(pos+len<=yaml[cur].size()&&keys[pos/2]==yaml[cur].substr(pos,len))\n\t\t\t\tbreak;\n\t\t\tcur++;\n\t\t}\n\t\t\n\t\t//cout << cur << \" \" << pos << endl;\n\n\t\tif(cur==n){\n\t\t\tnot_found=true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(pos/2+1==keys.size()) break;\n\t\tcur++,pos+=2;\n\t}\n\n\tif(not_found){\n\t\tcout << \"no such property\" << endl;\n\t\treturn 0;\n\t}\n\n\tstring elem=yaml[cur].substr(pos+1+keys[keys.size()-1].size());\n\tif(elem==\"\")\n\t\tcout << \"object\" << endl;\n\telse{\n\t\telem=elem.substr(1,elem.size()-1);\n\t\tcout << \"string \\\"\"  << elem << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvector<string> get_keys(){\n  string key;\n  string tmp;  \n  vector<string> keys;\n  \n  getline(cin, key);\n  REP(i, key.size()) if(key[i] == '.') key[i] = ' ';\n  istringstream in(key);\n  while(in >> tmp) keys.push_back(tmp);\n  return keys;\n  \n}\n\nvector<string> get_yaml(){\n  string tmp;\n  vector<string> yaml;\n  while(getline(cin, tmp)){\n    yaml.push_back(tmp);\n  }\n  return yaml;\n}\n\n\nbool prefix(string s, string t){\n  return s.size() <= t.size() && t.substr(0, s.size()) == s;\n}\n\nint main(){\n  vector<string> keys = get_keys();\n  vector<string> yaml = get_yaml();\n\n  REP(i, keys.size()){\n    bool ok = false;\n    REP(j, yaml.size())if(!ok && prefix(keys[i] + \":\", yaml[j])){\n      string val = yaml[j].substr(min(yaml[j].size(), keys[i].size() + 2));\n      if(i + 1 == (int)keys.size()){\n        if(val == \"\"){\n          cout << \"object\" << endl;\n        }else{\n          cout << \"string \\\"\" + val << \"\\\"\" << endl;\n        }\n        return 0;\n      }\n      if(j + 1 == (int)yaml.size()) goto no_such_property;\n      int wcount = 0;\n      vector<string> next;\n      \n      while(yaml[j+1][wcount] == ' ') wcount++;\n      while(++j < (int)yaml.size() && prefix(string(wcount, ' '), yaml[j])){\n        next.push_back(yaml[j].substr(wcount));\n      }\n      \n      yaml = next;\n      ok = true;\n    }\n    \n    if(!ok) goto no_such_property;\n  }\n no_such_property:\n  cout << \"no such property\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct obj{\n\tvector<string> key;\n\tvector<string> property;\n\tvector<obj*> obj;\n};\nint n, p;\n\nstring ks, in[50000];\nobj* parse(int pid = -1){\n\tobj* res = new obj;\n\twhile(p < n){\n\t\tint id = 0;\n\t\tfor(; isspace(in[p][id]); id++);\n\t\tif(id <= pid) break;\n\t\t\n\t\tint pos = in[p].find(\":\");\n\t\tstring key = in[p].substr(id, pos - id);\n\t\tif(pos == in[p].size() - 1){\n\t\t\tres->key.pb(key);\n\t\t\tres->property.pb(\"\");\n\t\t\tp++;\n\t\t\tres->obj.pb(parse(id));\n\t\t}\n\t\telse{\n\t\t\tres->key.pb(key);\n\t\t\tres->property.pb(in[p].substr(pos + 2));\n\t\t\tres->obj.pb(NULL);\n\t\t\tp++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tgetline(cin, ks);\n\twhile(getline(cin, in[n])) n++;\n\t\n\tobj *root = parse();\n\t\n\teach(i, ks) if(*i == '.') *i = ' ';\n\tstringstream ss(ks);\n\tvector<string> v;\n\twhile(ss >> ks) v.pb(ks);\n\t\n\trep(i, v.size() - 1){\n\t\tbool ok = 0;\n\t\trep(j, root->key.size()) if(root->key[j] == v[i]){\n\t\t\tif(root->property[j] != \"\") break;\n\t\t\t\n\t\t\troot = root->obj[j];\n\t\t\tok = 1;\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"no such property\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\trep(j, root->key.size()) if(root->key[j] == v.back()){\n\t\tif(root->property[j] != \"\") cout << \"string \\\"\" << root->property[j] << \"\\\"\" << endl;\n\t\telse cout << \"object\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"no such property\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct item{\n    vector<item*> ptr;\n    string val;\n    bool is_str;\n};\n\nbool isalphabet(char ch){\n    return 'a'<=ch and ch<='z';\n}\n\nvoid yaml(string &s,int &i,item &itm);\nvoid mapping(string &s,int &i,item &itm,int n);\nvoid mapping_item(string &s,int &i,item &itm,int n);\nstring key(string &s,int &i);\nstring string_(string &s,int &i);\nvoid indent(int &i,int n);\n\nvoid yaml(string &s,int &i,item &itm){\n    mapping(s,i,itm,0);\n}\n\nvoid mapping(string &s,int &i,item &itm,int n){\n    mapping_item(s,i,itm,n);\n    if(i!=s.size()) mapping(s,i,itm,n);\n}\n\nvoid mapping_item(string &s,int &i,item &itm,int n){\n    indent(i,n);\n    item* itm_=new item();\n    itm_->val=key(s,i);\n    itm.ptr.push_back(itm_);\n    assert(s[i]==':');\n    ++i;\n    if(s[i]==' '){\n        ++i;\n        item* str=new item();\n        str->is_str=true;\n        str->val=string_(s,i);\n        itm_->ptr.push_back(str);\n        assert(s[i]=='\\n');\n        ++i;\n    }else{\n        assert(s[i]=='\\n');\n        ++i;\n        int j=i;\n        while(s[j]==' ') ++j;\n        mapping(s,i,*itm_,j-i);\n    }\n}\n\nstring key(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i])){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nstring string_(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i]) or s[i]==' '){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nvoid indent(int &i,int n){\n    if(n==0) return;\n    ++i;\n    indent(i,n-1);\n}\n\nvoid solve(){\n    string qry,yaml_str;\n    cin >> qry;\n    cin.ignore();\n    {\n        string buf;\n        while(getline(cin,buf)){\n            yaml_str+=buf;\n            yaml_str+='\\n';\n        }\n    }\n\n    item root;\n    root.val=\"root\";\n    {\n        int idx=0;\n        yaml(yaml_str,idx,root);\n    }\n\n    {\n        item* itm=&root;\n        int idx=1;\n        while(true){\n            string str=string_(qry,idx);\n            bool ok=false;\n            rep(i,0,itm->ptr.size()) if(!itm->ptr[i]->is_str and itm->ptr[i]->val==str){\n                itm=itm->ptr[i];\n                ok=true;\n                break;\n            }\n            if(!ok){\n                cout << \"no such property\" << endl;\n                return;\n            }\n            if(idx==qry.size()){\n                item *obj=itm->ptr.front();\n                if(obj->is_str) cout << \"string \\\"\" << obj->val << \"\\\"\" << endl;\n                else cout << \"object\" << endl;\n                return;\n            }\n            ++idx;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct obj{\n\tvector<string> key;\n\tvector<string> property;\n\tvector<obj> obj;\n};\nint n, p;\nobj null;\n\nstring ks, in[20];\nobj parse(int pid = -1){\n\tobj res;\n\twhile(p < n){\n\t\tint id = 0;\n\t\tfor(; isspace(in[p][id]); id++);\n\t\tif(id <= pid) break;\n\t\t\n\t\tint pos = in[p].find(\":\");\n\t\tstring key = in[p].substr(id, pos - id);\n\t\tif(pos == in[p].size() - 1){\n\t\t\tres.key.pb(key);\n\t\t\tres.property.pb(\"\");\n\t\t\tp++;\n\t\t\tres.obj.pb(parse(id));\n\t\t}\n\t\telse{\n\t\t\tres.key.pb(key);\n\t\t\tres.property.pb(in[p].substr(pos + 2));\n\t\t\tres.obj.pb(null);\n\t\t\tp++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tgetline(cin, ks);\n\twhile(getline(cin, in[n])) n++;\n\t\n\tobj root = parse();\n\t\n\teach(i, ks) if(*i == '.') *i = ' ';\n\tstringstream ss(ks);\n\tvector<string> v;\n\twhile(ss >> ks) v.pb(ks);\n\t\n\trep(i, v.size() - 1){\n\t\tbool ok = 0;\n\t\trep(j, root.key.size()) if(root.key[j] == v[i]){\n\t\t\tif(root.property[j] != \"\") break;\n\t\t\t\n\t\t\troot = root.obj[j];\n\t\t\tok = 1;\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"no such property\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\trep(j, root.key.size()) if(root.key[j] == v.back()){\n\t\tif(root.property[j] != \"\") cout << \"string \\\"\" << root.property[j] << \"\\\"\" << endl;\n\t\telse cout << \"object\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"no such property\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Mapping{\n\tstring key,value;\n\tvector<Mapping> children;\n\tMapping(string k):key(k){}\n\tMapping(string k,string v):key(k),value(v){}\n};\n\npair<Mapping,int> Parse(const vs& yaml,int i)\n{\n\tint indent=yaml[i].find_first_not_of(' ');\n\t\n\tstring key;\n\tint j=indent;\n\tfor(;yaml[i][j]!=':';j++) key+=yaml[i][j];\n\tj+=2;\n\t\n\tif(j<=yaml[i].size()){ // string\n\t\tstring value=yaml[i].substr(j);\n\t\treturn mp(Mapping(key,value),i+1);\n\t}\n\telse{\n\t\tMapping m(key);\n\t\tfor(i++;i<yaml.size() && yaml[i].find_first_not_of(' ')>indent;){\n\t\t\tauto p=Parse(yaml,i);\n\t\t\tm.children.push_back(p.first);\n\t\t\ti=p.second;\n\t\t}\n\t\treturn mp(m,i);\n\t}\n}\nMapping Parse(const vs& yaml)\n{\n\tMapping m(\"(root)\");\n\tfor(int i=0;i<yaml.size();){\n\t\tauto p=Parse(yaml,i);\n\t\tm.children.push_back(p.first);\n\t\ti=p.second;\n\t}\n\treturn m;\n}\n\nvoid print(const Mapping& m,int i=0)\n{\n\tif(i) cout<<string(i,' ');\n\tcout<<m.key<<\"(\"<<m.children.size()<<\"): \";\n\tif(m.children.empty())\n\t\tcout<<m.value<<endl;\n\telse{\n\t\tcout<<endl;\n\t\tfor(const auto& c:m.children)\n\t\t\tprint(c,i+1);\n\t}\n}\n\nstring query(const Mapping& m,const string& q)\n{\n\tvs keys;\n\tfor(int i=0;i<q.size();){\n\t\tint j=q.find('.',i+1);\n\t\tkeys.push_back(q.substr(i+1,j-(i+1)));\n\t\ti=j;\n\t}\n\t\n\tconst Mapping* x=&m;\n\tstring res=\"no such property\";\n\tfor(int i=0;i<keys.size();i++){\n\t\tbool found=false;\n\t\tfor(const auto& c:x->children)\n\t\t\tif(c.key==keys[i]){\n\t\t\t\tx=&c;\n\t\t\t\tfound=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(!found) return \"no such property\";\n\t}\n\t\n\tif(x->children.empty())\n\t\treturn \"string \\\"\"+x->value+\"\\\"\";\n\telse\n\t\treturn \"object\";\n}\n\nint main()\n{\n\tfor(string q;getline(cin,q);){\n\t\tvs yaml;\n\t\tfor(string s;getline(cin,s) && s!=\"\";)\n\t\t\tyaml.push_back(s);\n\t\t\n\t\tMapping m=Parse(yaml);\n\t\tcout<<query(m,q)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Node\n{\npublic:\n    int h;\n    string key;\n    Node* parent;\n    vector<Node*> child;\n    string s;\n    Node(int h0, Node* parent0){\n        h = h0;\n        parent = parent0;\n    }\n    ~Node(){\n        for(unsigned i=0; i<child.size(); ++i)\n            delete child[i];\n    }\n};\n\nint main()\n{\n    string key;\n    getline(cin, key);\n\n    Node* root = new Node(INT_MIN, NULL);\n    Node* curr = root;\n\n    for(;;){\n        string s;\n        if(!getline(cin, s))\n            break;\n\n        int h = s.find_first_not_of(' ');\n        while(h <= curr->h)\n            curr = curr->parent;\n        curr->child.push_back(new Node(h, curr));\n        curr = curr->child.back();\n\n        int i = s.find(':');\n        curr->key = s.substr(h, i-h);\n\n        if(i != s.size() - 1)\n            curr->s = s.substr(i+2);\n    }\n\n    curr = root;\n    unsigned i = 0;\n    while(i < key.size()){\n        int j = key.find('.', i+1);\n        string s = key.substr(i+1, j-i-1);\n        i = j;\n\n        int k = 0;\n        while(k < curr->child.size() && curr->child[k]->key != s)\n            ++ k;\n\n        if(k == curr->child.size()){\n            cout << \"no such property\" << endl;\n            return 0;\n        }\n        curr = curr->child[k];\n    }\n\n    if(curr->child.size() == 0)\n        cout << \"string \\\"\" << curr->s << '\\\"' << endl;\n    else\n        cout << \"object\" << endl;\n\n    delete root;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct item{\n    vector<item*> ptr;\n    string val;\n    bool is_str;\n};\n\nbool isalphabet(char ch){\n    return 'a'<=ch and ch<='z';\n}\n\nbool is_indent_n(string &s,int i,int n){\n    if(n==0) return true;\n    if(i==s.size() or s[i]!=' ') return false;\n    return is_indent_n(s,i+1,n-1);\n}\n\nvoid yaml(string &s,int &i,item &itm);\nvoid mapping(string &s,int &i,item &itm,int n);\nvoid mapping_item(string &s,int &i,item &itm,int n);\nstring key(string &s,int &i);\nstring string_(string &s,int &i);\nvoid indent(string &s,int &i,int n);\n\nvoid yaml(string &s,int &i,item &itm){\n    mapping(s,i,itm,0);\n}\n\nvoid mapping(string &s,int &i,item &itm,int n){\n    mapping_item(s,i,itm,n);\n    if(i!=s.size() and is_indent_n(s,i,n)) mapping(s,i,itm,n);\n}\n\nvoid mapping_item(string &s,int &i,item &itm,int n){\n    indent(s,i,n);\n    item* itm_=new item();\n    itm_->val=key(s,i);\n    itm.ptr.push_back(itm_);\n    assert(s[i]==':');\n    ++i;\n    if(s[i]==' '){\n        ++i;\n        item* str=new item();\n        str->is_str=true;\n        str->val=string_(s,i);\n        itm_->ptr.push_back(str);\n        assert(s[i]=='\\n');\n        ++i;\n    }else{\n        assert(s[i]=='\\n');\n        ++i;\n        int j=i;\n        while(j!=s.size() and s[j]==' ') ++j;\n        assert(n<j-i);\n        mapping(s,i,*itm_,j-i);\n    }\n}\n\nstring key(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i])){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nstring string_(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i]) or s[i]==' '){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nvoid indent(string &s,int &i,int n){\n    if(n==0) return;\n    assert(s[i]==' ');\n    ++i;\n    indent(s,i,n-1);\n}\n\nvoid solve(){\n    string qry,yaml_str;\n    cin >> qry;\n    cin.ignore();\n    {\n        string buf;\n        while(getline(cin,buf)){\n            yaml_str+=buf;\n            yaml_str+='\\n';\n        }\n    }\n\n    item root;\n    root.val=\"root\";\n    {\n        int idx=0;\n        yaml(yaml_str,idx,root);\n    }\n\n    {\n        item* itm=&root;\n        int idx=1;\n        while(true){\n            string str=string_(qry,idx);\n            bool ok=false;\n            rep(i,0,itm->ptr.size()) if(!itm->ptr[i]->is_str and itm->ptr[i]->val==str){\n                itm=itm->ptr[i];\n                ok=true;\n                break;\n            }\n            if(!ok){\n                cout << \"no such property\" << endl;\n                return;\n            }\n            if(idx==qry.size()){\n                item *obj=itm->ptr.front();\n                if(obj->is_str) cout << \"string \\\"\" << obj->val << \"\\\"\" << endl;\n                else cout << \"object\" << endl;\n                return;\n            }\n            ++idx;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_indent,int arg_address){\n\t\tindent = arg_indent;\n\t\taddress = arg_address;\n\t}\n\n\tint indent,address;\n};\n\nstruct Obj{\n\tvoid allocate(int n){\n\t\tname = new char[n+1];\n\t}\n\n\tchar* name;\n\tvector<int> children;\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint main(){\n\n\tchar* query = new char[50001];\n\tchar* buf = new char[50001];\n\tchar* work = new char[50001];\n\n\tscanf(\"%s\",query);\n\tgetchar();\n\n\tObj obj[15000];\n\n\tint ob_index = 0,work_index,calc_index,indent_num;\n\tstack<Info> S;\n\n\tchar ch;\n\n\tint buf_index;\n\tbool breakFLG;\n\n\twhile(true){\n\n\t\tbuf_index = 0;\n\t\tch = getchar();\n\n\t\twhile(ch != '\\n' && ch != '\\0' && ch != EOF){\n\t\t\tbuf[buf_index++] = ch;\n\t\t\tch = getchar();\n\t\t}\n\t\tbuf[buf_index] = '\\0';\n\n\t\tbreakFLG = true;\n\n\t\tfor(int z = 0; z < buf_index; z++){\n\t\t\tif(buf[z] == ':'){\n\t\t\t\tbreakFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(breakFLG){\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(calc_index = 0;buf[calc_index] == ' ';calc_index++);\n\t\tindent_num = calc_index;\n\n\t\twork_index = 0;\n\n\t\tfor(;buf[calc_index] != ':';calc_index++){\n\t\t\twork[work_index++] = buf[calc_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tobj[ob_index].allocate(work_index);\n\t\tstrcpy(obj[ob_index].name,work);\n\n\t\twhile(S.empty() == false && S.top().indent >= indent_num)S.pop();\n\t\tif(S.empty()){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tobj[S.top().address].children.push_back(ob_index);\n\t\t}\n\n\t\tif(buf[calc_index+1] == '\\n' || buf[calc_index+1] == '\\0'){\n\t\t\tS.push(Info(indent_num,ob_index));\n\t\t\tob_index++;\n\t\t}else{\n\n\t\t\tobj[ob_index].children.push_back(ob_index+1);\n\n\t\t\tob_index++;\n\t\t\twork_index = 0;\n\t\t\tcalc_index += 2;\n\t\t\tfor(;buf[calc_index] != '\\n' && buf[calc_index] != '\\0';calc_index++){\n\t\t\t\twork[work_index++] = buf[calc_index];\n\t\t\t}\n\t\t\twork[work_index] = '\\0';\n\n\t\t\tobj[ob_index].allocate(work_index);\n\t\t\tstrcpy(obj[ob_index].name,work);\n\n\t\t\tob_index++;\n\t\t}\n\t}\n\n\tbool FLG = false;\n\n\tint parse_index = 0,parse_address = -1,next_address,ans_index = 0;\n\tchar* ans = new char[50001];\n\tchar const_object[7] = \"object\";\n\n\twhile(true){\n\n\t\tif(query[parse_index] == '.'){\n\t\t\tparse_index++;\n\t\t}\n\t\twork_index = 0;\n\t\tfor(;query[parse_index] != '.' && query[parse_index] != '\\n' && query[parse_index] != '\\0';parse_index++){\n\t\t\twork[work_index++] = query[parse_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tif(work_index == 0){\n\t\t\tif(ans_index == 0){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tif(strCmp(ans,const_object)){\n\t\t\t\t\tprintf(\"%s\\n\",const_object);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",ans);\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}else{\n\t\t\tif(parse_address == -1){\n\t\t\t\tfor(int i = 0; i < ob_index;i++){\n\t\t\t\t\tif(strCmp(work,obj[i].name)){\n\t\t\t\t\t\tparse_address = i;\n\t\t\t\t\t\tif(obj[i].children.size() == 0){\n\t\t\t\t\t\t\tparse_address = -1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(obj[i].children.size() == 1 && obj[obj[i].children[0]].children.size() == 0){\n\t\t\t\t\t\t\t\tstrcpy(ans,obj[obj[i].children[0]].name);\n\t\t\t\t\t\t\t\tans_index = 50;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tstrcpy(ans,const_object);\n\t\t\t\t\t\t\t\tans_index = 7;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(parse_address == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnext_address = -1;\n\t\t\t\tfor(int i = 0; i < obj[parse_address].children.size();i++){\n\t\t\t\t\tif(strCmp(obj[obj[parse_address].children[i]].name,work)){\n\t\t\t\t\t\tnext_address = obj[parse_address].children[i];\n\n\t\t\t\t\t\tif(obj[next_address].children.size() == 0){\n\t\t\t\t\t\t\tnext_address = -1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(obj[next_address].children.size() == 1 && obj[obj[next_address].children[0]].children.size() == 0){\n\t\t\t\t\t\t\t\tstrcpy(ans,obj[obj[next_address].children[0]].name);\n\t\t\t\t\t\t\t\tans_index = 50;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tstrcpy(ans,const_object);\n\t\t\t\t\t\t\t\tans_index = 7;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next_address == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tparse_address = next_address;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"no such property\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nvector< string > split(string s, string cc)\n{\n  s += cc;\n  int tail = 0;\n  string buff;\n  vector< string > ret;\n  while(tail < s.size()) {\n    if(cc.find(s[tail]) != string::npos) {\n      if(buff.size()) ret.push_back(buff);\n      buff.clear();\n    } else {\n      buff += s[tail];\n    }\n    ++tail;\n  }\n  return (ret);\n}\n\nint main()\n{\n  string K, S;\n  vector< string > data;\n  cin >> K;\n  cin.ignore();\n  while(getline(cin, S)) data.push_back(S);\n\n  auto latte = split(K, \".\");\n\n  bool flag = false;\n  vector< pair< string, int > > vs;\n\n  auto ismatch = [&]\n  {\n    if(vs.size() != latte.size()) return (false);\n    for(int i = 0; i < vs.size(); i++) if(vs[i].first != latte[i]) return (false);\n    return (true);\n  };\n\n  for(auto &s : data) {\n    auto malta = split(s, \" :\");\n    int indent = 0;\n    while(s[indent] == ' ') ++indent;\n    while(vs.size() && indent <= vs.back().second) vs.pop_back();\n    vs.emplace_back(malta[0], indent);\n    if(ismatch()) {\n      auto p = s.substr(s.find(':') + 1);\n      if(p.empty()) cout << \"object\" << endl;\n      else cout << \"string \\\"\" << p.substr(1) << \"\\\"\" << endl;\n      flag = true;\n      break;\n    }\n  }\n\n  if(!flag) cout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<tuple>\n#include<stack>\nusing namespace std;\n\nint main() {\n\tstring q; cin >> q;\n\tvector<string> qs;\n\tstring tmp;\n\tfor (auto c : q) {\n\t\tif (c == '.') {\n\t\t\tif (tmp.size())\n\t\t\t\tqs.push_back(tmp);\n\t\t\ttmp.clear();\n\t\t}\n\t\telse\n\t\t\ttmp.push_back(c);\n\t}\n\tif (tmp.size())qs.push_back(tmp);\n\n\t//for (auto x : qs)\n\t//\tcerr << x << endl;\n\n\tusing T = tuple<int, string, string>;\n\tvector<T> v;\n\tcin.ignore();\n\tfor (string s; getline(cin, s) && s != \"$\";) {\n\t\tint indent = 0;\n\t\tstring key;\n\t\tstring str;\n\n\t\tbool k = true;\n\t\tbool isobj = s.back() == ':';\n\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tchar c = s[i];\n\t\t\tif (c == ' ' && key.empty())\n\t\t\t\tindent++;\n\t\t\telse if (c != ':' && k)\n\t\t\t\tkey.push_back(c);\n\t\t\telse if (c == ':') {\n\t\t\t\tif (!isobj)i++;\n\t\t\t\tk = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstr = s.substr(i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tv.emplace_back(indent, key, str);\n\t}\n\n\tusing P = pair<int, int>;\n\tstack<P> st;\n\n\tint qi = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tint indent; string key; string str;\n\t\ttie(indent, key, str) = v[i];\n\t\tif (st.size() && indent <= st.top().second) {\n\t\t\tbreak;\n\t\t}\n\t\tif (key == qs[qi]) {\n\t\t\tif (qi == qs.size() - 1) {\n\t\t\t\tif (str.size())\n\t\t\t\t\tcout << \"string \" << '\"' << str << '\"' << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << \"object\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.emplace(i, indent);\n\t\t\t\tqi++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (str.size() == 0) {\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile (j < v.size() && get<0>(v[j]) > indent) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\ti = j - 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << \"no such property\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\n\nclass Input{\n\tpublic:\n\tbool isObject;\n\tint space;\n\tstring key;\n\tstring data;\n\t\n\tInput(string str){\n\t\tint nspace = 0;\n\t\tfor(;;nspace++)if(str[nspace]!=' ')break;\n\t\t\n\t\tint colon = nspace;\n\t\tfor(;;colon++)if(str[colon-1]==':')break;\n\t\t\n\t\tint lspace =  colon+1;\n\t\t\n\t\tspace = nspace;\n\t\tkey = str.substr(nspace, colon-nspace-1);\n\t\t\n\t\tif(lspace+1 < str.size()){\n\t\t\tdata = str.substr(lspace, str.size()-lspace);\n\t\t\tisObject = false;\n\t\t}else{\n\t\t\tisObject = true;\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tcout<<\"sp = \"<<space<<\" key=\"<<key<<\" data=\"<<data<<endl;\n\t}\n};\n\n\nstring query;\nvector<Input> in;\n\n\nbool input(){\n\tgetline(cin, query);\n\twhile(!cin.eof()){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif(s==\"\")break;\n\t\tin.pb(Input(s));\n\t}\n\treturn true;\n}\n\nclass Data{\n\tpublic:\n\tbool isprop;\n\tstring prop;\n\tstring key;\n\tvector<Data> data;\n\t\n\tData(string key){\n\t\tisprop = false;\n\t\tthis->key = key;\n\t}\n\tData(string key, string prop){\n\t\tisprop = true;\n\t\tthis->key = key;\n\t\tthis->prop = prop;\n\t}\n\t\n\tvoid print(int index){\n\t\tstring space = \"\";\n\t\trep(i,index)space += ' ';\n\t\t\n\t\tcout<<space; puts(\"----------------------\");\n\t\tcout<<space; cout<<\"key    : '\"<<key<<\"'\"<<endl;\n\t\tcout<<space; cout<<\"isprop : \"<<isprop<<endl;\n\t\tcout<<space; cout<<\"prop   : '\"<<prop<<\"'\"<<endl;\n\t\trep(i,data.size()){\n\t\t\tdata[i].print(index+2);\n\t\t}\n\t}\n};\n\n\nData kaiseki(int st, int en){\n\t\n\t//printf(\"st=%d  en=%d\\n\",st,en);\n\tif(st+1==en){\n\t\treturn Data(in[st].key,  in[st].data);\n\t}\n\t\n\t\n\tData ret(in[st].key);\n\tint head = st+1;\n\tint stspace = in[st+1].space;\n\treps(i,st+2, en+1){\n\t\tif(i==en || in[i].space==stspace){\n\t\t\tret.data.pb(kaiseki(head, i));\n\t\t\thead = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstring calc(Data& data, string& q){\n\t\n\t\n\tif(q==\"\"){\n\t\tif(data.isprop){\n\t\t\tstringstream sst;\n\t\t\treturn \"string \\\"\"+data.prop+\"\\\"\";\n\t\t}\n\t\treturn \"object\";\n\t}\n\t\n\tint en = 1;\n\tfor(;en<q.size();en++){\n\t\tif(q[en]=='.')break;\n\t}\n\tstring key = q.substr(1, en-1);\n\tstring nq = q.substr(en, q.size()-(en));\n\t\n\t//cout<<\"q:\"<<q<<\"   nq:\"<<nq<<\"   key:\"<<key<<endl;\n\trep(i,data.data.size()){\n\t\tif(data.data[i].key==key){\n\t\t\treturn calc(data.data[i], nq);\n\t\t}\n\t}\n\t\n\treturn \"no such property\";\n}\n\n\nvoid solve(){\n\tData parent(\"parent\");\n\t\n\tint head = 0;\n\treps(i,1,in.size()+1){\n\t\tif(i==in.size() || in[i].space==0){\n\t\t\tparent.data.pb(kaiseki(head, i));\n\t\t\thead=i;\n\t\t}\n\t}\n\tstring ans = calc(parent, query);\n\tcout<<ans;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring prop[32];\n\nint main()\n{\n    rep(i,32) prop[i] = \"\";\n    string in;\n    cin >> in;\n    int sz = 0;\n    rep(i,in.size()){\n\tif(in[i] == '.') sz++;\n\telse prop[sz-1] += in[i];\n    }\n    int pos = 0;\n    int depth = 0;\n    int prev = 0;\n    bool flag = false;\n    int indents[32];\n    cin.ignore();\n    while(getline(cin,in)){\n\tif(in.size() == 0) break;\n\tint cur = 0;\n\twhile(in[cur] == ' ') cur++;\n\n\tstring tag = \"\", str = \"\";\n\tint t = cur;\n\twhile(in[t] != ':') tag += in[t++];\n\tt += 2;\n\twhile(t < in.size()) str += in[t++];\n\n\tif(cur > prev) {\n\t    depth++;\n\t    indents[depth] = cur;\n\t}\n\tif(cur < prev) {\n\t    while(indents[depth] > cur) depth--;\n\t}\n\tif(depth < pos){\n\t    pos = depth;\n\t}\n\n\tif(depth == pos && prop[pos] == tag){\n\t    pos++;\n\t    if(pos == sz){\n\t\tif(str.size() == 0) cout << \"object\\n\";\n\t\telse cout << \"string \\\"\" << str << \"\\\"\\n\";\n\t\treturn 0;\n\t    }\n\t}\n\tprev = cur;\n    }\n    cout << \"no such property\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef pair<int,string> P;\n\nstring str, s;\nvector<string> x;\n\nint main(){\n\tcin >> str;\n\tfor(int i = 1; i < str.size(); i++){\n\t\tif(str[i] == '.'){\n\t\t\tx.push_back(s);\n\t\t\ts.clear();\n\t\t\tcontinue;\n\t\t}\n\t\ts.push_back(str[i]);\n\t}\n\tx.push_back(s);\n\tvector<P> y;\n\twhile(getline(cin,s)){\n\t\tint cnt = 0;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] != ' '){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\twhile(y.size() > 0){\n\t\t\tif(y[y.size()-1].first < cnt) break;\n\t\t\ty.pop_back();\n\t\t}\n\t\tstring tmp;\n\t\tfor(int i = cnt; i < s.size(); i++){\n\t\t\tif(s[i] == ':') break;\n\t\t\ttmp.push_back(s[i]);\n\t\t}\n\t\ty.push_back(P(cnt,tmp));\n\t\tif(y.size() != x.size()) continue;\n\t\tbool ok = true;\n\t\trep(i,x.size()) if(y[i].second != x[i]) ok = false;\n\t\tif(ok){\n\t\t\tif(s[s.size()-1] != ':'){\n\t\t\t\tstring tmpp;\n\t\t\t\tfor(int i = cnt+tmp.size()+2; i < s.size(); i++) tmpp.push_back(s[i]);\n\t\t\t\tprintf(\"string \\\"\");\n\t\t\t\tcout << tmpp;\n\t\t\t\tprintf(\"\\\"\\n\");\n\t\t\t} else{\n\t\t\t\tcout << \"object\" << endl;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50001\n\nclass YAML{\npublic:\n  string s,t;\n  int state;\n  vector<string> next;\n};\n\nclass Line{\npublic:\n  string s;\n  int space;\n};\n\nvector<Line> line;\nYAML yaml[MAX];\n\nint getState(int idx,vector<string> &v){\n  string now = line[idx].s.substr(line[idx].space);\n  string s,t;\n  int x = -1;\n  for(int i = 0 ; i < (int)now.size() ; i++){\n    if(now[i] == ':'){ x = line[idx].space+i+2; break; }\n    s += now[i];\n  }\n  v.push_back(s);\n  if(x < (int)line[idx].s.size()){\n    t = line[idx].s.substr(x);\n    v.push_back(t);\n    return 1;\n  }\n  return 0;\n}\n\nvector<string> make_graph(int cur,int sp){\n  int len = line.size();\n  vector<string> res;\n  if(cur == len){ return res; }\n  int now = cur;\n  while(true){\n    if(now == len || sp > line[now].space){ break; }\n    if(yaml[now].state == 1){\n      now++; continue;\n    }\n    if(sp == line[now].space){\n      res.push_back(yaml[now].s);\n    }else if(sp < line[now].space){\n      yaml[cur].next = make_graph(now,line[now].space);\n    }\n    now++;\n  }\n  return res;\n}\n\nint main(){\n  int idx = 1;\n  string order,in;\n  map<string,int> mp;\n  line.push_back((Line){\"->\",0});\n  cin >> order; cin.ignore();\n  while(getline(cin,in)){\n    int cnt = 0;\n    for(int i = 0 ; i < (int)in.size() ; i++){\n      if(in[i] == ' '){\n        cnt++;\n      }else{ break; }\n    }\n    line.push_back((Line){in,cnt});\n    vector<string> v;\n    yaml[idx].state = getState(idx,v);\n    yaml[idx].s = v[0];\n    if(yaml[idx].state == 1){\n      yaml[idx].t = v[1];\n    }\n    mp[yaml[idx].s] = idx;\n    idx++;\n  }\n  yaml[0].s = \"->\";\n  yaml[0].next = make_graph(1,line[1].space);\n  string t;\n  vector<string> strs;\n  for(int i = 0 ; i < (int)order.size() ; i++){\n    if(order[i] == '.'){\n      if(!t.empty()){ strs.push_back(t); }\n      t.clear();\n    }else{\n      t += order[i];\n    }\n  }\n  strs.push_back(t);\n  int now = 0,len = strs.size();\n  bool found = true;\n  for(int i = 0 ; i < len ; i++){\n    vector<string> vec = yaml[now].next;\n    bool ok = false;\n    for(int j = 0 ; j < (int)vec.size() ; j++){\n      if(vec[j] == strs[i]){\n        ok = true;\n        break;\n      }\n    }\n    now = mp[strs[i]];\n    if(!ok && yaml[now].state == 0){\n      found = false;\n      break;\n    }\n  }\n  if(!found){\n    cout << \"no such property\" << endl;;\n  }else{\n    if(yaml[now].state == 0){\n      cout << \"object\" << endl;;\n    }else{\n      cout << \"string \\\"\" << yaml[now].t << \"\\\"\" << endl;;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2438&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nstring YAML[50010];\n\nvector<string> split(const string &s, char delim) {\n\tvector<string> elems;\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, delim)) {\n\t\tif (!item.empty()) {\n\t\t\telems.push_back(item);\n\t\t}\n\t}\n\treturn elems;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring k; cin >> k;\n\tauto key = split(k, '.');\n\tint key_cnt = key.size();\n\tcin.ignore();\n\tint cnt = 0;\n\twhile (getline(cin, YAML[cnt++]));\n\tcnt--;\n\tint pre_space = 0;\n\tint key_at = 0;\n\tbool next_flag = false;\n\tbool through = false;\n\tfor (int i = 0; i < cnt;i++) {\n\t\tauto yaml = split(YAML[i], ':');\n\t\tint space;\n\t\tfor (int l = 0; l < yaml[0].length(); l++) if (yaml[0][l] != ' ') { space = l; break; }\n\n\t\tif (through & (space != pre_space)) continue;\n\t\telse through = false;\n\n\t\tif (next_flag) { pre_space = space; next_flag = false; }\n\t\tif (yaml[0].substr(space) == key[key_at]) {\n\t\t\tkey_at++;\n\t\t\tif (key_at == key_cnt) {\n\t\t\t\tif (yaml.size() == 2) {\n\t\t\t\t\tyaml[1][0] = '\"';\n\t\t\t\t\tcout << \"string \" << yaml[1] << '\"' << endl; return 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"object\" << endl; return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (yaml.size() == 2)break;\n\t\t\t\telse {\n\t\t\t\t\tnext_flag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (yaml.size() == 1)through = true;\n\t\t\telse continue;\n\t\t}\n\t}\n\tcout << \"no such property\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\n\nusing namespace std;\n\nstring in[50000];\nint lineNum, lineMax;\n\nstruct object {\n  vector<string> key;\n  vector<string> property;\n  vector<object*> child;\n};\n\nobject* parse_yaml(int parentIndent = -1) {\n  object* obj = new object;\n\n  while( lineNum < lineMax ) {\n    int indent = 0;\n    for( ;isspace(in[lineNum][indent]); indent++ );\n\n    if( indent <= parentIndent ) break;\n    \n    int colon = in[lineNum].find(\":\");\n    string key = in[lineNum].substr(indent, colon-indent);\n    if( colon == in[lineNum].size()-1 ) {\n      // object\n      obj->key.push_back(key);\n      obj->property.push_back(\"__ymobj\");\n      \n      lineNum ++;\n      // parse children\n      obj->child.push_back(parse_yaml(indent));\n    } else {\n      // has property\n      obj->key.push_back(key);\n      obj->property.push_back(in[lineNum].substr(colon+2));\n      obj->child.push_back(NULL); // NULLポインタを代入しないとセグフォ\n      \n      lineNum ++;\n    }\n  }\n  \n  return obj;\n}\n\nbool search( const object* root, const vector<string>vecQ, string& ans ) {\n  \n  // find object\n  for(unsigned i=0; i<vecQ.size()-1; i++) { // \"-1\" means object(not string)\n    bool ok = 0;\n    for(unsigned j=0; j<root->key.size(); j++) {\n      if(root->key[j] == vecQ[i]) {\n\tif(root->property[j] != \"__ymobj\") break; // found same string key with query object\n\troot = root->child[j];\n\tok = 1;\n\tbreak;\n      }\n    }\n    if(!ok) return false;\n  }\n  \n  // find property\n  for(unsigned i=0; i<root->key.size(); i++) {\n    if(root->key[i]==vecQ.back()) {\n      \n      if(root->property[i] == \"__ymobj\") {\n\tans = \"object\";\n\treturn true;\n      } else {\n\tans = \"string \\\"\" + root->property[i] + \"\\\"\";\n\treturn true;\n      }\n    }\n  }\n  \n  return false;\n}\n\nvoid input_yaml() {\n  lineMax = 0;\n  for(int i=0; getline(cin, in[i]); i++, lineMax++);\n}\n\nint main() {\n  \n  string query;\n  getline(cin, query);\n  //replaceAll( query, \".\", \" \" );\n  for(unsigned i=0; i<query.size(); i++) if(query[i]=='.') query[i] = ' ';\n  stringstream ss( query );\n  vector<string> vecQuery;\n  while( ss >> query ) vecQuery.push_back( query );\n  \n  input_yaml();\n  \n  lineNum = 0;\n  object* yaml = parse_yaml();\n  \n  string ans;\n  if( search( yaml, vecQuery, ans ) ) {\n    cout << ans << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\npair<int, size_t> indent(const string& s, size_t i) {\n  int cnt = 0;\n  while (i < s.size() && s[i] == ' ') {\n    ++i; ++cnt;\n  }\n  return make_pair(cnt, i);\n}\n\npair<string, size_t> get_str(const string& s, size_t i) {\n  string res;\n  while (isalnum(s[i]) || s[i] == ' ') {\n    res += s[i];\n    ++i;\n  }\n  return make_pair(res, i);\n}\n\nstruct Item {\n  int depth;\n  string key;\n  int type;\n  string obj_str;\n  vector<Item> obj_map;\n};\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i);\n\npair<Item, size_t> mapping_item(const string& s, size_t i) {\n  int depth;\n  tie(depth, i) = indent(s, i);\n  string key;\n  tie(key, i) = get_str(s, i);\n  ++i;\n  if (s[i] == '\\n') { // mapping\n    vector<Item> mapping_child;\n    tie(mapping_child, i) = mapping(s, i+1);\n    return make_pair((Item){depth, key, 1, \"\", mapping_child}, i);\n  } else { // string\n    string obj;\n    tie(obj, i) = get_str(s, i+1);\n    return make_pair((Item){depth, key, 0, obj, vector<Item>()}, i+1);\n  }\n}\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i) {\n  vector<Item> res;\n  Item front;\n  tie(front, i) = mapping_item(s, i);\n  res.push_back(front);\n  while(i < s.size()) {\n    Item next;\n    size_t next_i;\n    tie(next, next_i) = mapping_item(s, i);\n    if (next.depth != front.depth) break;\n    res.push_back(next);\n    i = next_i;\n  }\n  return make_pair(res, i);\n}\n\nstring query(const vector<Item>& obj, const string& s, size_t i) {\n  string key_name;\n  tie(key_name, i) = get_str(s, i+1);\n  for (auto& item : obj) {\n    if (item.key == key_name) {\n      if (item.type == 0) {\n        if (i == s.size()) {\n          return \"string \\\"\" + item.obj_str + \"\\\"\";\n        } else {\n          return \"no such property\";\n        }\n      } else {\n        if (i == s.size()) {\n          return \"object\";\n        } else {\n          return query(item.obj_map, s, i);\n        }\n      }\n    }\n  }\n  return \"no such property\";\n}\n\nint main() {\n  string q;\n  getline(cin, q);\n  string yaml;\n  string line;\n  while (getline(cin, line)) yaml += line + \"\\n\";\n  auto res = mapping(yaml, 0).first;\n  cout << query(res, q, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\npair<int, size_t> indent(const string& s, size_t i) {\n  int cnt = 0;\n  while (i < s.size() && s[i] == ' ') {\n    ++i; ++cnt;\n  }\n  return make_pair(cnt, i);\n}\n\npair<string, size_t> get_str(const string& s, size_t i) {\n  string res;\n  while (isalnum(s[i]) || s[i] == ' ') {\n    res += s[i];\n    ++i;\n  }\n  return make_pair(res, i);\n}\n\nstruct Item {\n  int depth;\n  string key;\n  int type;\n  string obj_str;\n  vector<Item> obj_map;\n};\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i);\n\npair<Item, size_t> mapping_item(const string& s, size_t i) {\n  int depth;\n  tie(depth, i) = indent(s, i);\n  string key;\n  tie(key, i) = get_str(s, i);\n  ++i;\n  if (s[i] == '\\n') { // mapping\n    vector<Item> mapping_child;\n    tie(mapping_child, i) = mapping(s, i+1);\n    return make_pair((Item){depth, key, 1, \"\", std::move(mapping_child)}, i);\n  } else { // string\n    string obj;\n    tie(obj, i) = get_str(s, i+1);\n    return make_pair((Item){depth, key, 0, obj, vector<Item>()}, i+1);\n  }\n}\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i) {\n  vector<Item> res;\n  Item front;\n  tie(front, i) = mapping_item(s, i);\n  res.push_back(front);\n  while(i < s.size()) {\n    Item next;\n    size_t next_i;\n    tie(next, next_i) = mapping_item(s, i);\n    if (next.depth != front.depth) break;\n    res.push_back(next);\n    i = next_i;\n  }\n  return make_pair(res, i);\n}\n\nstring query(const vector<Item>& obj, const string& s, size_t i) {\n  string key_name;\n  tie(key_name, i) = get_str(s, i+1);\n  for (auto& item : obj) {\n    if (item.key == key_name) {\n      if (item.type == 0) {\n        if (i == s.size()) {\n          return \"string \\\"\" + item.obj_str + \"\\\"\";\n        } else {\n          return \"no such property\";\n        }\n      } else {\n        if (i == s.size()) {\n          return \"object\";\n        } else {\n          return query(item.obj_map, s, i);\n        }\n      }\n    }\n  }\n  return \"no such property\";\n}\n\nint main() {\n  string q;\n  getline(cin, q);\n  string yaml;\n  string line;\n  while (getline(cin, line)) yaml += line + \"\\n\";\n  auto res = mapping(yaml, 0).first;\n  cout << query(res, q, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nstruct Obj{\n  int lv;\n  map<string,string> strs;\n  map<string,Obj*> objs;\n};\n\nint N;\nvector<int> level;\nvector<string> vs;\nvoid dfs(int& idx, int lv, Obj* obj){\n  for(;idx<N;){\n\tif(idx == N || level[idx] <= lv) return;\n\tint lv_c = level[idx];\n\tint p = vs[idx].find(\":\");\n\n\tstring key = vs[idx].substr(level[idx], p-level[idx]);\n\tif(p+1 == vs[idx].size()){\n\t  Obj* c = new Obj();\n\t  c->lv = lv_c;\n\t  ++idx;\n\t  dfs(idx, lv_c, c);\n\t  obj->objs[key] = c;\n\t}\n\telse{\n\t  string str = vs[idx].substr(p+2);\n\t  obj->strs[key] = str;\n\t  ++idx;\n\t}\n  }\n}\n\n\nvoid debug(Obj* obj){\n  cout << obj->lv << \": \" << endl;\n  for(auto& ss: obj->strs)\n\tcout << ss.first << \" -> \" << ss.second << endl;\n  for(auto& ss: obj->objs){\n\tcout << ss.first << \" -> *\" << endl;\n\tdebug(ss.second);\n  }\n}\n\nint main(){\n  string query; cin >> query; cin.ignore();\n\n  string line;\n  N = 0;\n  while(getline(cin, line)){\n\tint lv = 0;\n\tfor(;line[lv]==' ';++lv);\n\tlevel.push_back(lv);\n\tvs.push_back(line);\n\t++N;\n  }\n  Obj* yaml = new Obj();\n  yaml->lv = -1;\n  int idx = 0;\n  dfs(idx,-1,yaml);\n\n  //  debug(yaml);\n\n  int i;\n  Obj* cur = yaml;\n  for(i=1;;){\n\tint p = query.find(\".\", i);\n\tif(p == string::npos) break;\n\tstring item = query.substr(i,p-i);\n\tcur = cur->objs[item];\n\ti = p+1;\n\tif(!cur) break;\n  }\n\n  if(cur){\n\tstring item = query.substr(i);\n\tif(cur->strs.count(item))\n\t  cout << \"string \\\"\" << cur->strs[item] << \"\\\"\" << endl;\n\telse if(cur->objs.count(item))\n\t  cout << \"object\" << endl;\n\telse\n\t  cur = 0;\n  }\n  if(!cur)\n\tcout << \"no such property\" << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nstring in[100000];\nint idx;\nint pos;\nstruct obj_{\n  map<string,string> key;\n  map<string,struct obj_*> mem;\n}obj;\n\nint getindent(int p){\n  int ret=0;\n  while(ret<SZ(in[p]) && in[p][ret]==' ')++ret;\n  return ret;\n}\n\nstruct obj_* get(){\n  struct obj_ *ret= new obj_();\n  int ind=getindent(pos);\n  while(pos < idx && ind==getindent(pos)){\n    int p=in[pos].find(':');\n    string key=in[pos].substr(ind,p-ind);\n    //cout << ind << ' ' << key << endl;\n    if(p+2>SZ(in[pos])){\n      ++pos;\n      ret->mem[key]=get();\n    }else{\n      ret->key[key]=in[pos].substr(p+2);\n    }\n    ++pos;\n  }\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  string pro;\n  cin >> pro;cin.get();\n  while(getline(cin,in[idx++]));\n  struct obj_ *r=get();\n  FOR(it,pro) if(*it=='.') *it=' ';\n  stringstream ss(pro);\n  while(ss >> pro){\n    if(r->mem.count(pro)) r=r->mem[pro];\n    else if(r->key.count(pro)){\n      string ans=r->key[pro];\n      if(ss >> pro) cout << \"no such property\" << endl;\n      else cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n      return 0;\n    }else{\n      cout << \"no such property\" << endl;\n      return 0;\n    }\n  }\n  cout << \"object\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    vector<string> dir;\n    {\n        string str; cin >> str;\n        str.push_back('.');\n        int p = 1;\n        int np;\n        while((np = str.find('.', p)) != string::npos){\n            dir.push_back(str.substr(p, np - p));\n            p = np + 1;\n        }\n    }\n    int len = dir.size();\n\n    cin.ignore();\n\n    int depth = 0;\n    string in;\n    int correct = -1;\n    int pbcnt = 0;\n    vi brs = {0};\n    while(getline(cin, in)){\n        int bcnt = 0;\n        while(in[bcnt] == ' ') bcnt++;\n        if(bcnt > brs.back()) depth++, brs.push_back(bcnt);\n        while(bcnt < brs.back()){\n            brs.pop_back();\n            depth--;\n        }\n\n        if(correct >= depth) correct = depth - 1;\n\n        stringstream ss(in);\n        string obj; ss >> obj;\n\n        obj.pop_back();\n        if(correct == depth - 1 and dir[depth] == obj){\n            correct = depth;\n            if(correct == len - 1){\n                string name = in.substr(in.find(':') + 2);\n                if(name == \"\"){\n                    cout << \"object\" << endl;\n                }\n                else {\n                    cout << \"string \\\"\" << name << \"\\\"\" << endl;\n                }\n                return 0;\n            }\n        }\n    }\n\n    cout << \"no such property\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <cctype>\n#include <sstream>\nusing namespace std;\ntypedef string::const_iterator State;\nint len;\nstring inpro;\nstring in[50];\nstring str;\nvector<string> property;\n\nvoid split(const string &str,char delim){\n\tistringstream iss(str);\n\tstring tmp;\n\tgetline(iss,tmp,delim);\n\twhile(getline(iss,tmp,delim))property.push_back(tmp);\n\tlen=property.size();\n}\n\nstring func(State &begin,int depth,int indent){\n\tif(begin==str.end())return \"no such property\";\n\tint cnt=0;\n\twhile(*begin==' '){\n\t\tbegin++;\n\t\tcnt++;\n\t}\n\tif(indent==-1)indent=cnt;\n\telse if(indent!=cnt){\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(cnt<indent || begin!=str.end())return \"no such property\";\n\t\treturn func(begin,depth,indent);\n\t}\n\tstring key=\"\";\n\twhile(*begin!=':'){\n\t\tkey+=*begin;\n\t\tbegin++;\n\t}\n\tbegin++;\n\tif(key==property[depth]){\n\t\tif(depth==len-1){\n\t\t\tif(*begin=='\\n')return \"object\";\n\t\t\telse{\n\t\t\t\tstring res=\"\";\n\t\t\t\tbegin++;\n\t\t\t\twhile(*begin!='\\n'){\n\t\t\t\t\tres+=*begin;\n\t\t\t\t\tbegin++;\n\t\t\t\t}\n\t\t\t\tstring ans=\"string \";\n\t\t\t\tans+='\"';\n\t\t\t\tans+=res;\n\t\t\t\tans+='\"';\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}else{\n\t\t\tif(*begin=='\\n'){\n\t\t\t\treturn func(++begin,++depth,-1);\n\t\t\t}else return \"no such property\";\n\t\t}\n\t}else{\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(begin==str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n}\n\nint main(void){\n\tgetline(cin,inpro);\n\tsplit(inpro,'.');\n\tint cnt=0;\n\twhile(getline(cin,in[cnt]))cnt++;\n\tfor(int i=0;i<cnt;i++){\n\t\tstr+=in[i];\n\t\tstr+='\\n';\n\t}\n\tState begin=str.begin();\n\tcout << func(begin,0,-1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define int long long\nusing namespace std;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct node{\n\tstring key;\n\tstring value;\n\tint depth;\n\tvector<int> child;\n};\n\nsigned main(){\n\tvector<string> str;\n\tstring q;\n\t{\n\t\tgetline(cin, q);\n\t\tstring s;\n\t\twhile(getline(cin, s)){\n\t\t\tstr.emplace_back(s);\n\t\t}\n\t}\n\n\tvector<node> t;\n\tt.emplace_back(node{\"root\", \"\", -1, vector<int>()});\n\n\tvector<int> parent;\n\tparent.emplace_back(0);\n\tfor(auto& s : str){\n\t\tint depth = 0;\n\t\tfor(auto c : s){\n\t\t\tif(c != ' ') break;\n\t\t\tdepth++;\n\t\t}\n\t\ts = s.substr(depth);\n\n\t\twhile(depth <= t[parent.back()].depth){\n\t\t\tparent.pop_back();\n\t\t}\n\n\t\tint c;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] == ':'){\n\t\t\t\tc = i;\n\t\t\t}\n\t\t}\n\t\tstring key = s.substr(0, c);\n\t\tstring value = c + 1 == s.size() ? \"\" : s.substr(c + 2);\n\n\t\tt[parent.back()].child.emplace_back(t.size());\n\t\tt.emplace_back(node{key, value, depth, vector<int>()});\n\t\tif(c + 1 == s.size()){\n\t\t\tparent.emplace_back(t.size() - 1);\n\t\t}\n\t}\n\n\t//for(auto i:t){ cout << i.key << ' ' << i.value << endl; cout << i.child << endl; }\n\n\tauto search = [&](int cur, string& word){\n\t\tfor(auto to : t[cur].child){\n\t\t\tif(t[to].key == word){\n\t\t\t\treturn to;\n\t\t\t}\n\t\t}\n\t\treturn -1LL;\n\t};\n\n\tstring word;\n\tint idx = 0;\n\tq += '.';\n\trange(i,1,q.size()){\n\t\tif(q[i] == '.'){\n\t\t\tidx = search(idx, word);\n\t\t\tif(idx == -1){\n\t\t\t\tcout << \"no such property\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tword = \"\";\n\t\t}else{\n\t\t\tword += q[i];\n\t\t}\n\t}\n\n\tif(t[idx].value.empty()){\n\t\tcout << \"object\" << endl;\n\t}else{\n\t\tcout << \"string \\\"\" << t[idx].value << \"\\\"\" << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstruct Obj {\n  bool isStr;\n  string str;\n  map<string, Obj*> pro;\n};\n\nstring p;\nvector<pair<int,string> > v;\nint pos;\n\nvoid make(Obj *obj) {\n  for(int i = 0; pos < v.size(); ++i) {\n    if(i && v[pos-1].first != v[pos].first) break;\n    Obj *nobj = new Obj();\n    string &target = v[pos].second;\n    ++pos;\n    int j;\n    for(j = 0; j < target.size(); ++j) {\n      if(target[j] == ':') break;\n    }\n    string key = target.substr(0,j);\n\n    if(j+1 == target.size()) {\n      nobj->isStr = false;\n      make(nobj);\n    } else {\n      nobj->isStr = true;\n      nobj->str = target.substr(j+2);\n    }\n    obj->pro[key] = nobj;\n  }\n}\n\nint main() {\n  getline(cin, p);\n  while(!cin.eof()) {\n    string line;\n    getline(cin, line);\n    int sp = 0;\n    while(line[0] == ' ') {\n      ++sp;\n      line = line.substr(1);\n    }\n    v.push_back(make_pair(sp, line));\n  }\n\n  Obj *root = new Obj();\n  make(root);\n\n  vector<string> ps;\n  {\n    replace(p.begin(), p.end(), '.', ' ');\n    stringstream ss(p);\n    while(!ss.eof()) {\n      string s;\n      ss >> s;\n      ps.push_back(s);\n    }\n  }\n\n  Obj *obj = root;\n  for(int i = 0; i < ps.size(); ++i) {\n    if(obj->pro.count(ps[i])) {\n      obj = obj->pro[ps[i]];\n    } else {\n      obj = 0;\n      break;\n    }\n  }\n  if(obj) {\n    if(obj->isStr) cout << \"string \\\"\" << obj->str << \"\\\"\" << endl;\n    else cout << \"object\" << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct obj{\n  bool isobj;\n  string name;\n  string value;\n  vector<obj*> ob;\n  obj* par;\n};\n  \nint main(){\n  string query;\n  vector<string> yaml;\n  string buf;\n  for(int i=0;getline(cin,buf);i++){\n    if(i==0){\n      query=buf;\n    }\n    else{\n      yaml.push_back(buf);\n    }\n  }\n  \n\n\n  obj* base=new obj();\n  base->isobj=true;\n  base->name=\"#####\";\n  base->par=nullptr;\n  int depth=0;\n  obj* now=base;\n  vector<int> indent(1,0);\n  for(int i=0;i<yaml.size();i++){\n    //cout<<i<<endl;\n    int tabcnt=0;\n    int p=0;\n    while(yaml[i][p]==' '){\n      tabcnt++;\n      p++;\n    }\n\n    for(int j=0;j<depth-1;j++){\n      if(indent[j]==tabcnt){\n\tfor(int k=0;k<depth-j;k++){\n\t  now=now->par;\n\t}\n\tdepth=j;\n\tbreak;\n      }\n    }\n    if(indent.size()<=depth){\n      indent.push_back(tabcnt);\n    }\n    else{\n      indent[depth]=tabcnt;\n    }\n    string name=\"\";\n    while(yaml[i][p]!=':'){\n      name+=yaml[i][p];\n      p++;\n    }\n\n    obj *next=new obj();\n\n    next->par=now;\n    if(yaml[i].size()==p+1){\n      next->isobj=true;\n      next->name=name;\n      next->value=\"###\";\n      (now->ob).push_back(next);\n      now=next;\n      depth++;\n    }\n    else{\n      string value;\n      p+=2;\n      while(p<yaml[i].size()){\n\tvalue+=yaml[i][p];\n\tp++;\n      }\n      next->isobj=false;\n      next->name=name;\n      next->value=value;\n      (now->ob).push_back(next);\n    }\n    \n  }\n\n  obj objec=*base;\n\n  int p=0;\n  p++;\n  auto get_name=[](string &q,int &p){\n    string res=\"\";\n    while(p<q.size() && q[p]!='.'){\n      res+=q[p];\n      p++;\n    }\n    return res;\n  };\n  \n  while(p<query.size()){\n\n\n    string name=get_name(query,p);\n    \n    obj* res=nullptr;\n    for(int j=0;j<objec.ob.size();j++){\n\n      if(objec.ob[j]->name==name){\n\tres=objec.ob[j];\n      }\n    }\n    if(res==nullptr){\n      cout<<\"no such property\"<<endl;\n      return 0;\n    }\n    objec=*res;\n    p++;\n  }\n  if(objec.isobj){\n    cout<<\"object\"<<endl;\n  }\n  else{\n    cout<<\"string \"<<\"\\\"\"<<objec.value<<\"\\\"\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct value{\n\tvirtual string get_prop(vs &keys,int pos)=0;\n};\n\nstruct mapping_item{\n\tstring key;\n\tvalue *value;\n};\n\nstruct text:public value{\n\tstring s;\n\tvirtual string get_prop(vs &keys,int pos){\n\t\tif(pos==keys.size()){\n\t\t\treturn \"string \\\"\" + s + \"\\\"\";\n\t\t}else{\n\t\t\treturn \"no such property\";\n\t\t}\n\t}\n};\n\nstruct mapping:public value{\n\tvector<mapping_item> mapping_items;\n\tvirtual string get_prop(vs &keys,int pos){\n\t\tif(pos==keys.size()){\n\t\t\treturn \"object\";\n\t\t}\n\t\tREP(i,mapping_items.size()){\n\t\t\tif(mapping_items[i].key==keys[pos]){\n\t\t\t\treturn mapping_items[i].value->get_prop(keys,pos+1);\n\t\t\t}\n\t\t}\n\t\treturn \"no such property\";\n\t}\n};\n\n\nmapping *read_mapping(string &s,int &pos,int n);\n\n//mapping-item(n): indent(n) key ':' ' ' string '\\n'\n//                 | indent(n) key ':' '\\n' mapping(m) (ただしm>n)\nmapping_item read_mapping_item(string &s,int &pos,int n){\n\tmapping_item m;\n\t//indent(0): \"\" (※空文字列)\n\t//indent(n+1): ' ' indent(n) (※スペースをn+1個並べた文字列)\n\tREP(i,n){\n\t\tassert(s[pos]==' ');\n\t\tpos++;\n\t}\n\t//key: [a-z0-9]+ (※英字小文字または数字からなる1文字以上の文字列)\n\twhile(s[pos]!=':'){\n\t\tm.key+=s[pos];\n\t\tpos++;\n\t}\n\tassert(s[pos]==':');\n\tpos++;\n\tif(s[pos]==' '){\n\t\tpos++;\n\t\t//string: [a-z0-9 ]+ (※英字小文字または数字またはスペースからなる1文字以上の文字列)\n\t\ttext *t=new text;\n\t\twhile(s[pos]!='\\n'){\n\t\t\tt->s+=s[pos];\n\t\t\tpos++;\n\t\t}\n\t\tassert(s[pos]=='\\n');\n\t\tpos++;\n\t\tm.value=t;\n\t}else{\n\t\tassert(s[pos]=='\\n');\n\t\tpos++;\n\t\tint cnt=0;\n\t\twhile(s[pos+cnt]==' '){\n\t\t\tcnt++;\n\t\t}\n\t\tm.value=read_mapping(s,pos,cnt);\n\t}\n\treturn m;\n}\n\n//mapping(n): mapping-item(n) | mapping-item(n) mapping(n)\nmapping *read_mapping(string &s,int &pos,int n){\n\tmapping* m=new mapping;\n\twhile(pos<s.size()){\n\t\tint cnt=0;\n\t\twhile(s[pos+cnt]==' '){\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt!=n)break;\n\t\tm->mapping_items.push_back(read_mapping_item(s,pos,n));\n\t}\n\treturn m;\n}\n\n//yaml: mapping(0)\nmapping *read_yaml(string &s){\n\tint pos=0;\n\treturn read_mapping(s,pos,0);\n}\n\nint main(){\n\tstring key_str;\n\tcin>>key_str;\n\tstring yaml_str;\n\tstring line;\n\tgetline(cin,line);\n\twhile(getline(cin,line)){\n\t\tyaml_str+=line+'\\n';\n\t}\n\tstring s;\n\tvs keys;\n\tFOR(i,1,key_str.size()){\n\t\tif(key_str[i]=='.'){\n\t\t\tkeys.push_back(s);\n\t\t\ts=\"\";\n\t\t}else{\n\t\t\ts.push_back(key_str[i]);\n\t\t}\n\t}\n\tif(s.size()){\n\t\tkeys.push_back(s);\n\t}\n\tmapping* yaml=read_yaml(yaml_str);\n\tcout<<yaml->get_prop(keys,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef string::const_iterator State;\n\nint space(State &beg){\n    int ret = 0;\n    while(*beg==' '){\n        ret++;\n        beg++;\n    }\n    return ret;\n}\n\n\nstring str(State &beg){\n    string ret = \"\";\n    while( *beg!=':' && *beg!=';' ){\n        assert( isdigit(*beg) || 'a'<=*beg && *beg<='z' || *beg==' ' );\n        ret+=*beg;\n        beg++;\n    }\n    return ret;\n}\n\n\nvoid eval(State &beg, int &ind, string &key, string &val){\n    ind = 0;\n    val = \"*\";\n    bool colon = false;\n    if(*beg==' ')ind = space(beg);\n    if(colon==false){\n        key = str(beg);\n        assert(*beg==':');\n        colon = true;\n        beg++;\n        \n        if(*beg==';')return ;\n        \n        assert(*beg==' ');\n        beg++;\n        \n        \n        \n    }\n    val = str(beg);\n    assert(*beg==';');\n    beg++;\n}\n\nint main(){\n    string s;\n    cin>>s;\n    cin.ignore();\n    \n    vector<string> vs;\n    string t;\n    while(getline(cin,t))vs.pb(t);\n    \n    map<vector<string>,string> mp;\n    vector<string> obj;\n    vector<int> indent;\n    for(auto str: vs){\n        str+=\";\";\n        State beg = str.begin();\n        int ind;\n        string key,val;\n        eval(beg,ind,key,val);\n        \n        while( indent.size() && indent[indent.size()-1]>=ind ){\n            obj.pop_back();\n            indent.pop_back();\n        }\n        \n        if(val==\"*\"){\n            obj.push_back(key);\n            indent.push_back(ind);\n            mp[obj] = \"*obj\";\n        }else{\n            obj.push_back(key);\n            \n            mp[obj] = val;\n            \n            obj.pop_back();\n        }\n    }\n    \n    vector<string> query;\n    s+='.';\n    string buf = \"\";\n    rep(i,s.size()){\n        if( s[i]=='.' ){\n            if(buf.size()==0)continue;\n            query.pb(buf);\n            buf = \"\";\n        }else{\n            buf+=s[i];\n        }\n    }\n    \n    if( mp.count(query)==0 )cout<<\"no such property\"<<endl;\n    else if(mp[query]==\"*obj\")cout<<\"object\"<<endl;\n    else cout<<\"string \\\"\"<<mp[query]<<\"\\\"\"<<endl;\n}\n\n\n//indent[ indent.size()-1 ] != the indent -> pop_back\n//hoge:\\n -> obj & indent push(hoge,ind)\n//map<obj+key> = string"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\n\nusing namespace std;\n\nstring in[50000];\nint lineNum, lineMax;\n\nstruct object {\n  vector<string> key;\n  vector<string> property;\n  vector<object*> child;\n};\n\nobject* parse_yaml(int parentIndent = -1) {\n  object* obj = new object;\n\n  while( lineNum < lineMax ) {\n    int indent = 0;\n    for( ;isspace(in[lineNum][indent]); indent++ );\n\n    if( indent <= parentIndent ) break;\n    \n    int colon = in[lineNum].find(\":\");\n    string key = in[lineNum].substr(indent, colon-indent);\n    if( colon == in[lineNum].size()-1 ) {\n      // object\n      obj->key.push_back(key);\n      obj->property.push_back(\"__ymobj\");\n      \n      lineNum ++;\n      // parse children\n      obj->child.push_back(parse_yaml(indent));\n    } else {\n      // has property\n      obj->key.push_back(key);\n      obj->property.push_back(in[lineNum].substr(colon+2));\n      obj->child.push_back(NULL); // NULLポインタを代入しないとセグフォ\n      \n      lineNum ++;\n    }\n  }\n  \n  return obj;\n}\n\nbool search( const object* root, const vector<string>vecQ, string& ans ) {\n  \n  // find object\n  for(unsigned i=0; i<vecQ.size()-1; i++) { // \"-1\" means object(not string)\n    bool ok = 0;\n    for(unsigned j=0; j<root->key.size(); j++) {\n      if(root->key[j] == vecQ[i]) {\n\tif(root->property[j] != \"__ymobj\") break; // found same string key with query object\n\troot = root->child[j];\n\tok = 1;\n\tbreak;\n      }\n    }\n    if(!ok) return false;\n  }\n  \n  // find property\n  for(unsigned i=0; i<root->key.size(); i++) {\n      if(root->key[i]==vecQ.back()) {\n\n      if(root->key[i] == \"__ymobj\") {\n\tans = \"object\";\n\treturn true;\n      } else {\n\tans = \"string \\\"\" + root->property[i] + \"\\\"\";\n\treturn true;\n      }\n    }\n  }\n  \n  return false;\n}\n\nvoid input_yaml() {\n  lineMax = 0;\n  for(int i=0; getline(cin, in[i]); i++, lineMax++);\n}\n\nint main() {\n  \n  string query;\n  getline(cin, query);\n  //replaceAll( query, \".\", \" \" );\n  for(unsigned i=0; i<query.size(); i++) if(query[i]=='.') query[i] = ' ';\n  stringstream ss( query );\n  vector<string> vecQuery;\n  while( ss >> query ) vecQuery.push_back( query );\n  \n  input_yaml();\n  \n  lineNum = 0;\n  object* yaml = parse_yaml();\n  \n  string ans;\n  if( search( yaml, vecQuery, ans ) ) {\n    cout << ans << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct dat{\n\tstring value;\n\tmap<string, dat> p;\n};\n\ndat mapping(){\n\tstring s;\n\tdat res;\n\twhile (getline(cin, s)){\n\t\tstringstream ss(s);\n\t\tss >> s;\n\t\tstring t, tmp;\n\t\twhile (ss >> tmp) t += \" \" + tmp;\n\t\tdat d;\n\t\tif (t.size()) d.value = t.substr(1);\n\t\telse d = mapping();\n\n\t\tres.p[s.substr(0, s.size()-1)] = d;\n\t}\n\treturn res;\n}\n\nint main(){\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\n\tdat d = mapping();\n\n\tfor (auto &c : query) if (c == '.') c = ' ';\n\n\tstringstream ss(query);\n\tstring s;\n\tdat *p = &d;\n\twhile (ss >> s){\n\t\tif (!p->p.count(s)) goto NG;\n\t\tp = &(p->p[s]);\n\t}\n\n\tif (p->value.empty()) cout << \"object\" << endl;\n\telse cout << \"string \\\"\" << p->value << \"\\\"\" << endl;\n\n\treturn 0;\nNG:\n\tcout << \"no such property\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char delimiter){\n  vector<string> res;\n  int prev_split_point = 0;\n  for (int i = 0; i < s.length(); i++) {\n    while(s[i] != delimiter && i < s.length())i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  string s;\n  cin >> s;\n  vector<string> key = split(s, '.');\n  vector<string> yaml;\n  cin.ignore();\n  int indent = 0, p = 0;\n  while(getline(cin, s))yaml.push_back(s);\n  for (int i = 0; i < key.size() && p < yaml.size(); i++) {\n    while(p < yaml.size() &&\n          key[i] != yaml[p].substr(indent, key[i].length())){\n      p++;\n    }\n    while(i < key.size() - 1 &&\n          p + 1 < yaml.size() && yaml[p + 1][indent] == ' ')indent++;\n    if(i < key.size() - 1 && p < yaml.size())p++;\n  }\n  int len = key[key.size() - 1].length()+ 2;\n  if(p == yaml.size()){\n    std::cout << \"no such property\" << std::endl;\n  }else if(yaml[p].length() <= indent + len){\n    std::cout << \"object\" << std::endl;\n  }else{\n    std::cout << \"string \\\"\" << yaml[p].substr(indent + len) << \"\\\"\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cctype>\n#include <deque>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct yaml\n{\n  string str;\n  map<string, yaml> obj;\n  yaml(const string& s) : str(s) {}\n  yaml(const map<string, yaml>& m) : obj(m) {}\n\n  string query(deque<string>& q) const\n  {\n    if (q.empty()) {\n      if (str.empty()) {\n        return \"object\";\n      } else {\n        return \"string \\\"\" + str + \"\\\"\";\n      }\n    } else {\n      if (str.empty()) {\n        map<string, yaml>::const_iterator it = obj.find(q.front());\n        if (it == obj.end()) {\n          return \"no such property\";\n        } else {\n          q.pop_front();\n          return it->second.query(q);\n        }\n      } else {\n        return \"no such property\";\n      }\n    }\n  }\n};\n\ntypedef string::const_iterator Iterator;\n\nint indent(Iterator& it, const Iterator& last)\n{\n  int n = 0;\n  while (it != last && *it == ' ') {\n    ++n;\n    ++it;\n  }\n  return n;\n}\n\nstring key(Iterator& it, const Iterator& last)\n{\n  string s;\n  while (it != last && (islower(*it) || isdigit(*it))) {\n    s += *it;\n    ++it;\n  }\n  return s;\n}\n\nstring string_(Iterator& it, const Iterator& last)\n{\n  string s;\n  while (it != last && (islower(*it) || isdigit(*it) || *it == ' ')) {\n    s += *it;\n    ++it;\n  }\n  return s;\n}\n\nyaml mapping(Iterator& it, const Iterator& last);\n\npair<string, yaml> mapping_item(Iterator& it, const Iterator& last)\n{\n  string k = key(it, last);\n  if (*it != ':') {\n    throw __LINE__;\n  }\n  ++it;\n  if (*it == ' ') {\n    ++it;\n    string s = string_(it, last);\n    if (*it != '\\n') {\n      throw __LINE__;\n    }\n    ++it;\n    return make_pair(k, yaml(s));\n  } else if (*it == '\\n') {\n    ++it;\n    const yaml y = mapping(it, last);\n    return make_pair(k, y);\n  } else {\n    throw __LINE__;\n  }\n}\n\nyaml mapping(Iterator& it, const Iterator& last)\n{\n  map<string, yaml> obj;\n  const int n = indent(it, last);\n  obj.insert(mapping_item(it, last));\n  while (it != last) {\n    const Iterator saved = it;\n    if (n != indent(it, last)) {\n      it = saved;\n      break;\n    }\n    obj.insert(mapping_item(it, last));\n  }\n  return yaml(obj);\n}\n\nint main()\n{\n  string q;\n  getline(cin, q);\n  deque<string> v;\n  replace(q.begin(), q.end(), '.', ' ');\n  for (istringstream iss(q); iss >> q;) {\n    v.push_back(q);\n  }\n\n  string src;\n  for (string s; getline(cin, s);) {\n    src += s + \"\\n\";\n  }\n\n  Iterator it = src.begin(), last = src.end();\n  try {\n    yaml y = mapping(it, last);\n    cout << y.query(v) << endl;\n  } catch (int n) {\n    cerr << \"Error at \" << n << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    // READ\n    string pat;\n    getline(cin,pat);\n\n    vector<string> y;\n    string tttt;\n    while(getline(cin,tttt)){\n        y.pb(tttt);\n    }\n    int n = y.size();\n\n    // SOLVE\n    map<string,string> m;\n    vector<string> property(n);\n    vector<int> indent(n);\n    rep(i,n){\n        int ct = 0;\n        while(y[i][ct]==' ') ++ct;\n        indent[i] = ct;\n\n        string t = y[i].substr(ct);\n        int cl = 0;\n        while(t[cl]!=':') ++cl;\n\n        string p = t.substr(0,cl);\n        string parent = \"\";\n        if(ct>0){\n            int par = i;\n            while(par>=0 && indent[i]<=indent[par]) --par;\n            assert(par>=0);\n            parent = property[par];\n        }\n        property[i] = parent+\".\"+p;\n\n        // object\n        if(cl != t.size()-1){\n            string name = t.substr(cl+2);\n            m[property[i]] = (\"string \\\"\" + name + \"\\\"\");\n        }\n        else m[property[i]] = \"object\";\n    }\n\n    string ans = \"no such property\";\n    if(m.count(pat)) ans = m[pat];\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\npair<int, pair<string, string>> split(string s) {\n  string key, val;\n  int indent = 0;\n\n  int state = 0;\n\n  for(char c : s) {\n    if (state == 0 && c == ' ') {\n      indent++; continue;\n    }\n    if (c == ':') { state = 1; continue; }\n    if (c == ' ' && state == 1) { state = 2; continue; }\n\n    if (state == 0) key += c;\n    else val += c;\n  }\n\n  return {indent, {key, val}};\n}\n\nstruct Node {\n  string val;\n  map<string, int> obj;\n};\n\nvector<Node> dic;\n\nint main(){\n  string query;\n\n  getline(cin, query);\n\n  stack<pair<int, int>> st;\n  int prevIndent = 0;\n\n  dic.push_back(Node());\n  st.push({0, -1});\n\n  while(1) {\n    string str;\n    getline(cin, str);\n    if (!str.size()) break;\n\n    auto res = split(str);\n\n    int indent = res.first;\n    string key = res.second.first;\n    string val = res.second.second;\n\n    Node node;\n    node.val = val;\n    int id = dic.size();\n    dic.push_back(node);\n\n    if (st.top().second == indent) {\n      st.pop();\n      dic[st.top().first].obj[key] = id;\n      st.push({id, indent});\n    } else if (prevIndent < indent){\n      dic[st.top().first].obj[key] = id;\n      st.push({id, indent});\n    } else {\n      while(st.top().second >= indent) st.pop();\n      dic[st.top().first].obj[key] = id;\n      st.push({id, indent});\n    }\n\n    prevIndent = indent;\n  }\n\n  int now = 0;\n  query += \".\";\n\n  string key;\n  for(char c : query) {\n    if (c == '.') {\n      if (key.empty()) continue;\n      if (dic[now].obj.find(key) == dic[now].obj.end()) {\n        puts(\"no such property\");\n        return 0;\n      }\n      now = dic[now].obj[key];\n      key = \"\";\n    } else {\n      key += c;\n    }\n    debug(now);\n    debug(key);\n  }\n\n  if (dic[now].obj.size()) {\n    puts(\"object\");\n  } else {\n    cout << \"string \\\"\" << dic[now].val << \"\\\"\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n;\n\nvector<string> key;\nstring s, t[50000], name[50000], str[50000];\nint space[50000];\nbool object[50000];\n\nint line;\nstring ans;\n\nbool solve(int keyIdx, int preIndent){\n  if(keyIdx == key.size()){\n    if(object[line - 1]) ans = \"object\";\n    else                 ans = \"string \\\"\" + str[line - 1] + \"\\\"\";\n\n    return true;\n  }\n  if(n <= line){\n    return false;\n  }\n\n  int indent = space[line];\n\n  if(indent <= preIndent){\n    return false;\n  }\n\n  while(line < n && space[line] == indent){\n    if(key[keyIdx] == name[line++]){\n      return solve(keyIdx + 1, indent);\n    }\n\n    while(line < n && space[line] > indent){\n      line++;\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  string keys;\n  getline(cin, keys);\n  keys += \".\";\n\n  int idx = 1;\n\n  while(idx < keys.length()){\n    int nextPeriod = keys.find('.', idx);\n    string tmp = keys.substr(idx, nextPeriod - idx);\n    key.push_back(tmp);\n    idx += tmp.length() + 1;\n  }\n\n  n = 0;\n\n  while(getline(cin, t[n])){\n    space[n] = 0;\n    for(int i = 0; t[n][i] == ' '; i++, space[n]++);\n\n    for(int i = space[n]; t[n][i] != ':'; i++){\n      name[n] += t[n][i];\n    }\n\n    if(t[n][t[n].length() - 1] == ':'){\n      object[n] = true;\n    }\n    else{\n      str[n] = t[n].substr(space[n] + name[n].length() + 2);\n    }\n\n    n++;\n  }\n\n  line = 0;\n  bool flg = solve(0, -1);\n\n  if(flg){\n    cout << ans << endl;\n  }\n  else{\n    cout << \"no such property\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<string>sts;\nvector<int>indnums;\nint a = 0;\nstruct yaml {\n\tbool is_dir;\n\tmap<string, yaml>mp;\n\tstring prop;\n\tvoid operator =(const yaml yaml_) {\n\t\tis_dir = yaml_.is_dir;\n\t\tmp = yaml_.mp;\n\t\tprop = yaml_.prop;\n\t}\n};\nyaml getmap(const int ind);\npair<string,yaml> getmapitem(const int ind) {\n\tyaml ayaml;\n\t\n\tconst int n = sts[a].find(':');\n\tstring key = sts[a].substr(indnums[a], n-indnums[a]);\n\tif (n == sts[a].size()-1) {\n\t\tayaml.is_dir = true;\n\t\ta++;\n\t\tayaml = getmap(indnums[a]);\n\t}\n\telse {\n\t\tayaml.is_dir = false;\n\t\tstring name = sts[a].substr(n + 2);\n\t\tayaml.prop = name;\n\t}\n\treturn make_pair(key,ayaml);\n}\nyaml getmap(const int ind) {\n\tyaml ayaml;\n\tayaml.is_dir = true;\n\twhile (a != sts.size()&&indnums[a]==ind) {\n\t\tayaml.mp.insert(getmapitem(ind));\n\t\tif (a == sts.size())break;\n\t\ta++;\n\t}\n\treturn ayaml;\n}\n\nint main() {\n\tstring st; cin >> st;\n\tint now = 1;\n\tvector<string>keys;\n\twhile (1) {\n\t\tint n = st.find('.',now);\n\t\tif (n == string::npos) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tkeys.emplace_back(st.substr(now, n-now));\n\t\t}\n\t\tnow = n+1;\n\t}\n\tkeys.emplace_back(st.substr(now));\n\tstring ast;\n\tgetline(cin, ast);\n\twhile (getline(cin,ast)) {\n\t\tint n = ast.find_first_not_of(' ');\n\t\tsts.push_back(ast);\n\t\tindnums.emplace_back(n);\n\t}\n\tyaml y=getmap(0);\n\tint anstype=0;\n\tstring ans;\n\tyaml nyaml = y;\n\t\n\tfor (int i = 0; i < keys.size(); ++i) {\n\t\tauto it = nyaml.mp.find(keys[i]);\n\t\tif (it == nyaml.mp.end()) {\n\t\t\tanstype = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tnyaml = it->second;\n\t\t}\n\t}\n\tif (anstype == -1) {\n\t\tcout << \"no such property\" << endl;\n\t}\n\telse {\n\t\tif (nyaml.is_dir) {\n\t\t\tcout << \"object\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"string \\\"\" << nyaml.prop << \"\\\"\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\nusing namespace std;\n\nchar buf[50010];\n\nint main(){\n\tstring s;\n\tgetline(cin, s);\n\tconst char *ptr = s.c_str();\n\t\n\tvector<string> key;\n\tint d = 0;\n\twhile( sscanf(ptr, \".%[^.]%n\", buf, &d) > 0 ){\n\t\tptr += d;\n\t\tkey.push_back(buf);\n\t}\n\t\n\tint m = 0;\n\tint prev = -1;\n\tint indent = -1;\n\tint k = 0;\n\twhile(true){\n\t\tgetline(cin, s);\n\t\tif( s.size() < 2 ) break;\n\n\t\tptr = s.c_str();\n\t\tsscanf(ptr, \" %n%[^:]:%n\", &indent, buf, &d);\n\n\t\tif( indent <= prev ) break;\n\t\t\n\t\tif( m == -1 ) m = indent;\n\t\t\n\t\tif( m == indent && key[k] == buf ){\n\t\t\tm = -1;\n\t\t\tprev = indent;\n\t\t\t\n\t\t\tif( ++k == key.size() ){\n\t\t\t\tif( s[d] == ' ' ){\n\t\t\t\t\tcout << \"string \\\"\" << s.substr(d + 1) << \"\\\"\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << \"object\\n\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << \"no such property\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nvector<string> parse_query(string s) {\n    for(int i = 0; i < (int)s.length(); ++i) if(s[i] == '.') s[i] = ' ';\n    istringstream iss(s);\n    vector<string> res;\n    for(string t; iss >> t; res.push_back(t)) ;\n    return res;\n}\n\nstring first_element(const string &s) {\n    istringstream iss(s);\n    string res;\n    iss >> res;\n    return res;\n}\n\nstring get_string_element(const string &s) {\n    istringstream iss(s);\n    string t;\n    iss >> t;\n\n    string res;\n    iss >> t;\n    res += t;\n    while(iss >> t) {\n        res.push_back(' ');\n        res += t;\n    }\n    return res;\n}\n\nint get_element_size(const string &s) {\n    int i;\n    istringstream iss(s);\n    string t;\n    for(i = 0; iss >> t; i++) ;\n    return i;\n}\n\nint count_indent(const string &s) {\n    int i = 0;\n    while(i < (int)s.length() && s[i] == ' ') i++;\n    return i;\n}\n\nint main() {\n    string Q;\n    getline(cin, Q);\n    vector<string> YAML;\n    for(string s; getline(cin, s); YAML.push_back(s)) ;\n\n    vector<string> query = parse_query(Q);\n\n    string ans;\n    for(int i = 0; i < (int)query.size(); i++) {\n        int begin = -1, end = -1;\n#if 0\n        for(int j = 0; j < (int)YAML.size(); j++) DEBUG(YAML[j]);\n#endif\n        if(i == (int)query.size() - 1) {\n            for(int j = 0; j < (int)YAML.size(); j++) {\n                if(first_element(YAML[j]) == query[i] + \":\") {\n                    string t = YAML[j];\n                    YAML.clear();\n                    YAML.push_back(t);\n                    begin = 0, end = 0;\n                    break;\n                }\n            }\n        }\n        else {\n            for(int j = 0; j < (int)YAML.size(); j++) {\n#if 0\n                DEBUG(YAML[j]);\n                DEBUG(count_indent(YAML[j]));\n                DEBUG(first_element(YAML[j]));\n                DEBUG(query[i]);\n#endif\n                int ind = count_indent(YAML[0]);\n                if(ind == count_indent(YAML[j]) && first_element(YAML[j]) == query[i] + \":\") {\n                    begin = j + 1;\n                    for(end = j + 2; end < (int)YAML.size(); end++) {\n                        if(count_indent(YAML[end]) == ind) {\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n#if 0\n        DEBUG(begin);\n        DEBUG(end);\n#endif\n        if(begin == -1 && end == -1) {\n            ans = \"no such property\";\n            break;\n        }\n        else {\n            vector<string> YAML2;\n            for(int j = begin; j < end; j++) {\n                YAML2.push_back(YAML[j]);\n            }\n            YAML = YAML2;\n        }\n    }\n    if(ans != \"\") {\n        cout << ans << endl;\n        exit(EXIT_SUCCESS);\n    }\n\n    int size = get_element_size(*YAML.begin());\n    if(size == 1) {\n        cout << \"object\" << endl;\n    }\n    else {\n        cout << \"string \\\"\" << get_string_element(*YAML.begin()) << \"\\\"\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass yaml {\npublic:\n    yaml() : name_(\"invalid\")\n    {}\n    yaml(string const& n) : name_(n)\n    {}\n\n    yaml get(string const& key) {\n        if(child.count(key) == 0) {\n            throw std::runtime_error(\"no such property\");\n        }\n        return child[key];\n    }\n\n    void add(string const& key, yaml y) {\n        child[key] = move(y);\n    }\n\n    string name() const {\n        return name_;\n    }\n\nprivate:\n    string name_;\n    map<string, yaml> child;\n};\n\n\nyaml create_impl(vector<string> const& v, string name, int& l) {\n    const int L = v.size();\n    yaml res(name);\n    int indent = 0;\n    while(v[l][indent] == ' ') {\n        indent++;\n    }\n    while(l < L) {\n        int indent2 = 0;\n        while(v[l][indent2] == ' ') {\n            indent2++;\n        }\n        if(indent2 < indent) {\n            break;\n        }\n        if(indent2 == indent) {\n            int col = v[l].find(':');\n            if(col == v[l].size()-1) {\n                string key = v[l].substr(indent2);\n                key.pop_back();\n                res.add(key, create_impl(v, \"object\", ++l));\n            } else {\n                string key = v[l].substr(indent2, col-indent2);\n                string name = v[l].substr(col+2);\n                res.add(key, yaml{name});\n                ++l;\n            }\n        }\n    }\n    return res;\n}\n\nyaml create(vector<string> const& v) {\n    int l = 0;\n    return create_impl(v, \"object\", l);\n}\n\nstring proc(yaml y, string const& query) {\n    int p = 1;\n    while(p < query.size()) {\n        int np = query.find('.', p);\n        string key;\n        if(np == string::npos) {\n            key = query.substr(p);\n            p = query.size();\n        } else {\n            key = query.substr(p, np-p);\n            p = np + 1;\n        }\n        y = y.get(key);\n    }\n    return y.name();\n}\n\nint main() {\n    string query;\n    getline(cin, query);\n    query.pop_back();\n    vector<string> v;\n    string line;\n    while(getline(cin, line)) {\n        v.push_back(line);\n    }\n    for(int i=0; i<v.size()-1; ++i) {\n        v[i].pop_back();\n    }\n    return 0;\n    yaml y = create(v);\n    try {\n        string res = proc(y, query);\n        if(res == \"object\") {\n            cout << res << endl;\n        } else {\n            cout << \"string \\\"\" << res << \"\\\"\" << endl;\n        }\n    } catch(std::exception& ex) {\n        cout << ex.what() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstruct Obj {\n  bool isStr;\n  string str;\n  map<string, Obj*> pro;\n};\n\nstring p;\nvector<pair<int,string> > v;\nint pos;\n\nvoid make(Obj *obj) {\n  for(int i = 0; pos < v.size(); ++i) {\n    if(i && v[pos-1].first != v[pos].first) break;\n    Obj *nobj = new Obj();\n    string &target = v[pos].second;\n    ++pos;\n\n    int j;\n    for(j = 0; target[j] != ':'; ++j);\n    string key = target.substr(0,j);\n\n    if(j+2 >= target.size()) {\n      nobj->isStr = false;\n      make(nobj);\n    } else {\n      nobj->isStr = true;\n      nobj->str = target.substr(j+2);\n    }\n    obj->pro[key] = nobj;\n  }\n}\n\nint main() {\n  getline(cin, p);\n  string line;\n  while(getline(cin, line)) { \n    int sp = 0;\n    while(line[0] == ' ') {\n      ++sp;\n      line = line.substr(1);\n    }\n    v.push_back(make_pair(sp, line));\n  }\n\n  Obj *root = new Obj();\n  root->isStr = false;\n  pos = 0;\n  make(root);\n\n  vector<string> ps;\n  {\n    replace(p.begin(), p.end(), '.', ' ');\n    stringstream ss(p);\n    string s;\n    while(ss >> s) ps.push_back(s);\n  }\n\n  Obj *obj = root;\n  for(int i = 0; i < ps.size(); ++i) {\n    if(obj->pro.count(ps[i])) {\n      obj = obj->pro[ps[i]];\n    } else {\n      obj = 0;\n      break;\n    }\n  }\n  if(obj) {\n    if(obj->isStr) cout << \"string \\\"\" << obj->str << \"\\\"\" << endl;\n    else cout << \"object\" << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint main(){\n\tstring s;\n\tgetline(cin,s);\n\tstring keys[20];\n\tint N=0;\n\twhile(!s.empty()){\n\t\tstring t;\n\t\tint i;\n\t\tfor(i=1;i<s.size();i++){\n\t\t\tif(s[i]=='.') break;\n\t\t\tt+=s[i];\n\t\t}\n\t\tkeys[N++]=t;\n\t\ts=s.substr(i);\n\t}\n\tint now=0,S=-1;\n\tbool loaded=0;\n\twhile(true){\n\t\tif(!loaded){\n\t\t\tif(!getline(cin,s)) break;\n\t\t}\n\t\tloaded=0;\n\t\tstring key;\n\t\tint i=0;\n\t\twhile(s[i]==' ') i++;\n\t\tint sp=i;\n\t\tif(S>=sp){\n\t\t\tputs(\"no such property\");\n\t\t\treturn 0;\n\t\t}\n\t\twhile(s[i]!=':') key+=s[i++];\n\t\tbool nxt=0;\n\t\tif(i==s.size()-1) nxt=1;\n//\t\tshow(key);\n\t\tif(key==keys[now]){\n\t\t\tnow++;\n//\t\t\tshow(now);\n\t\t\tif(now==N){\n\t\t\t\tif(nxt){\n\t\t\t\t\tputs(\"object\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\tcout<<\"string \\\"\"<<s.substr(i+2)<<\"\\\"\"<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!nxt){\n\t\t\t\tputs(\"no such property\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tS=sp;\n\t\t}else{\n\t\t\tif(S>=sp){\n\t\t\t\tputs(\"no such property\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!nxt) continue;\n\t\t\twhile(true){\n\t\t\t\tstring t;\n\t\t\t\tif(!getline(cin,t)){\n\t\t\t\t\tputs(\"no such property\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tint i=0;\n\t\t\t\twhile(t[i]==' ') i++;\n\t\t\t\tif(i<=sp){\n\t\t\t\t\tloaded=1;\n\t\t\t\t\ts=t;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"no such property\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nvector<string> key;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tstring q;\n\tgetline(cin,q);\n\tstring s;\n\trep(i,sz(q)+1){\n\t\tif(i==sz(q) || q[i]=='.'){\n\t\t\tif(i)key.pb(s);\n\t\t\ts=\"\";\n\t\t}else s+=q[i];\n\t}\n\tint cur=0,indent=0;\n\tint wait=0;\n\twhile(getline(cin,s)){\n\t\tint space=0;\n\t\twhile(space<sz(s) && s[space]==' ')space++;\n\t\tif(wait==1){\n\t\t\tindent=space;\n\t\t\twait=0;\n\t\t}\n\t\tif(space < indent){\n\t\t\tbreak;\n\t\t}\n\t\tif(space > indent){\n\t\t\tcontinue;\n\t\t}\n\t\tint colon=s.find(\":\");\n\t\tstring t=s.substr(indent,colon-indent);\n\t\tif(t!=key[cur]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(colon==sz(s)-1){\n\t\t\tif(cur==sz(key)-1){\n\t\t\t\tcout<<\"object\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse cur++,wait=1;\n\t\t}\n\t\telse{\n\t\t\tif(cur==sz(key)-1){\n\t\t\t\tcout<<\"string \\\"\"<<s.substr(colon+2)<<\"\\\"\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tcout<<\"no such property\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2438.cc: YAML\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nenum { T_OBJ, T_STR };\n\nstruct Obj {\n  int t;\n  string v;\n  map<string,struct Obj> props;\n  Obj() {}\n  Obj(string &s): t(T_STR), v(s) {}\n\n  void print(int ind = 0) {\n    if (t == T_STR) {\n      cout << v << endl;\n      return;\n    }\n    for (map<string,struct Obj>::iterator mit = props.begin();\n\t mit != props.end(); mit++) {\n      for (int i = 0; i < ind; i++) putchar(' ');\n      cout << mit->first << ':';\n      if (mit->second.t == T_STR) cout << ' ' << mit->second.v << endl;\n      else {\n\tcout << endl;\n\tmit->second.print(ind + 1);\n      }\n    }\n  }\n};\n\ntypedef map<string,struct Obj> mso;\n\n/* global variables */\n\nvs lines, keys;\nvi idts;\n\n/* subroutines */\n\nvoid parse(Obj &o, int &k, int idt) {\n  o.t = T_OBJ;\n\n  while (k < lines.size() && idts[k] == idt) {\n    string &s = lines[k];\n    int pos = idt;\n    string key;\n    while (s[pos] != ':') key += s[pos++];\n    pos++; // ':'\n\n    if (pos >= s.size()) {\n      k++;\n      Obj co;\n      parse(co, k, idts[k]);\n      o.props[key] = co;\n    }\n    else {\n      pos++; // ' '\n      string val;\n      while (pos < s.size()) val += s[pos++];\n      o.props[key] = Obj(val);\n      k++;\n    }\n  }\n}\n\n/* main */\n\nint main() {\n  string keystr;\n  getline(cin, keystr);\n\n  for (int pos = 0; pos < keystr.size();) {\n    string key;\n    pos++; // '.'\n    while (pos < keystr.size() && keystr[pos] != '.')\n      key += keystr[pos++];\n    keys.push_back(key);\n  }\n  \n  for (;;) {\n    string line;\n    getline(cin, line);\n    if (cin.eof()) break;\n\n    lines.push_back(line);\n\n    int idt = 0;\n    while (line[idt] == ' ') idt++;\n    idts.push_back(idt);\n    //printf(\"idt=%d\\n\", idt);\n  }\n\n  Obj yaml;\n  int k = 0;\n  parse(yaml, k, 0);\n  //yaml.print();\n\n  Obj *opt = &yaml;\n  for (int k = 0; k < keys.size(); k++) {\n    mso::iterator mit = opt->props.find(keys[k]);\n    if (mit == opt->props.end()) {\n      opt = NULL;\n      break;\n    }\n\n    Obj *copt = &(mit->second);\n    if (k < keys.size() - 1 && copt->t == T_STR) {\n      opt = NULL;\n      break;\n    }\n\n    opt = copt;\n  }\n\n  if (opt == NULL) cout << \"no such property\" << endl;\n  else if (opt->t == T_OBJ) cout << \"object\" << endl;\n  else cout << \"string \\\"\" << opt->v << \"\\\"\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstruct Obj {\n  bool isStr;\n  string str;\n  map<string, Obj*> pro;\n};\n\nstring p;\nvector<pair<int,string> > v;\nint pos;\n\nvoid make(Obj *obj) {\n  for(int i = 0; pos < v.size(); ++i) {\n    if(i && v[pos-1].first != v[pos].first) break;\n    Obj *nobj = new Obj();\n    string &target = v[pos].second;\n    ++pos;\n    int j;\n    for(j = 0; target[j] != ':'; ++j);\n\n    string key = target.substr(0,j);\n\n    if(j+1 == target.size()) {\n      nobj->isStr = false;\n      make(nobj);\n    } else {\n      nobj->isStr = true;\n      nobj->str = target.substr(j+2);\n    }\n    obj->pro[key] = nobj;\n  }\n}\n\nint main() {\n  getline(cin, p);\n  string line;\n  while(getline(cin, line)) { \n    int sp = 0;\n    while(line[0] == ' ') {\n      ++sp;\n      line = line.substr(1);\n    }\n    v.push_back(make_pair(sp, line));\n  }\n\n  Obj *root = new Obj();\n  root->isStr = false;\n  make(root);\n\n  vector<string> ps;\n  {\n    replace(p.begin(), p.end(), '.', ' ');\n    stringstream ss(p);\n    string s;\n    while(ss >> s) ps.push_back(s);\n  }\n\n  Obj *obj = root;\n  for(int i = 0; i < ps.size(); ++i) {\n    if(obj->pro.count(ps[i])) {\n      obj = obj->pro[ps[i]];\n    } else {\n      obj = 0;\n      break;\n    }\n  }\n  if(obj) {\n    if(obj->isStr) cout << \"string \\\"\" << obj->str << \"\\\"\" << endl;\n    else cout << \"object\" << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    vector<string> dir;\n    {\n        string str; cin >> str;\n        str.push_back('.');\n        int p = 1;\n        int np;\n        while((np = str.find('.', p)) != string::npos){\n            dir.push_back(str.substr(p, np - p));\n            p = np + 1;\n        }\n    }\n    int len = dir.size();\n\n    cin.ignore();\n\n    int depth = 0;\n    string in;\n    int correct = -1;\n    int pbcnt = 0;\n    vi brs = {0};\n    while(getline(cin, in)){\n        int bcnt = 0;\n        while(in[bcnt] == ' ') bcnt++;\n        if(bcnt > brs.back()) depth++, brs.push_back(bcnt);\n        while(bcnt < brs.back()){\n            brs.pop_back();\n            depth--;\n        }\n\n        if(correct >= depth) correct = depth - 1;\n\n        stringstream ss(in);\n        string obj, name; ss >> obj >> name;\n\n        obj.pop_back();\n        if(correct == depth - 1 and dir[depth] == obj){\n            correct = depth;\n            if(correct == len - 1){\n                if(name == \"\"){\n                    cout << \"object\" << endl;\n                }\n                else {\n                    cout << \"string \\\"\" << in.substr(in.find(':') + 2) << \"\\\"\" << endl;\n                }\n                return 0;\n            }\n        }\n    }\n\n    cout << \"no such property\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 50001\n#define INF 1e9\n \nclass YAML{\npublic:\n    string s;\n    int state;\n    vector<string> next;\n};\n \nvector<int> space;\nYAML yaml[MAX];\n \nint getState(string &str,int d,vector<string> &v){\n    string now = str.substr(d);\n    string s,t;\n    int x = -1;\n    for(int i = 0 ; i < (int)now.size() ; i++){\n\tif(now[i] == ':'){ x = d+i+2; break; }\n\ts += now[i];\n    }\n    v.push_back(s);\n    if(x < (int)str.size()){\n\tt = str.substr(x);\n\tv.push_back(t);\n\treturn 1;\n    }\n    return 0;\n}\n \nvector<string> make_graph(int cur,int sp){\n    int len = space.size();\n    vector<string> res;\n    if(cur == len || yaml[cur].state == 1) return res;\n    int now = cur;\n    while(true){\n\tif(now == len || sp > space[now]) break;\n\tif(space[now] == INF){ now++; continue; }\n\tif(sp == space[now]){\n\t    res.push_back(yaml[now].s);\n\t    cur = now;\n\t}else if(sp < space[now]){\n\t    if(yaml[cur].next.size() == 0){\n\t\tyaml[cur].next = make_graph(now,space[now]);\n\t    }\n\t}\n\tnow++;\n    }\n    return res;\n}\n \nint main(){\n    int idx = 1;\n    string order,in;\n    map<string,int> mp;\n    space.push_back(-1);\n    yaml[0].s = \"->\";\n    cin >> order; cin.ignore();\n    while(getline(cin,in)){\n\tint cnt = 0;\n\tfor(int i = 0 ; i < (int)in.size() ; i++){\n\t    if(in[i] == ' '){\n\t\tcnt++;\n\t    }else{ break; }\n\t}\n\tspace.push_back(cnt);\n\tvector<string> v;\n\tyaml[idx].state = getState(in,cnt,v);\n\tyaml[idx].s = v[0];\n\tmp[yaml[idx].s] = idx;\n\tif(yaml[idx].state == 1){\n\t    yaml[idx].state = 0;\n\t    yaml[idx].next.push_back(v[1]);\n\t    idx++;\n\t    yaml[idx].s = v[1];\n\t    yaml[idx].state = 1;\n\t    mp[yaml[idx].s] = idx;\n\t    space.push_back(INF);\n\t}\n\tidx++;\n    }\n    yaml[0].next = make_graph(1,space[1]);\n    string t;\n    vector<string> strs;\n    for(int i = 0 ; i < (int)order.size() ; i++){\n\tif(order[i] == '.'){\n\t    if(!t.empty()){ strs.push_back(t); }\n\t    t.clear();\n\t}else{\n\t    t += order[i];\n\t}\n    }\n    strs.push_back(t);\n    int now = 0,len = strs.size();\n    bool found = true;\n    for(int i = 0 ; i < len ; i++){\n\tvector<string> vec = yaml[now].next;\n\tbool ok = false;\n\tfor(int j = 0 ; j < (int)vec.size() ; j++){\n\t    if(vec[j] == strs[i]){\n\t\tok = true;\n\t\tbreak;\n\t    }\n\t}\n\tnow = mp[strs[i]];\n\tif(!ok){\n\t    found = false;\n\t    break;\n\t}\n    }\n    int size = yaml[now].next.size();\n    if(!found || size == 0){\n\tcout << \"no such property\" << endl;\n    }else{\n\tif(size != 1){\n\t    cout << \"object\" << endl;\n\t}else{\n\t    string ans = yaml[now].next[0];\n\t    if(yaml[mp[ans]].state == 1){\n\t\tcout << \"string \\\"\" << ans << \"\\\"\" << endl;\n\t    }else{\n\t\tcout << \"object\" << endl;\n\t    }\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring in[50000];\nint linum, N;\n\nstruct object {\n  vector<string> key;\n  vector<string> property;\n  vector<object *>child;\n};\n\nobject *parse(int pindent = -1) {\n  object *res = new object;\n  \n  while(linum<N) {\n    int indent = 0;\n    for(;in[linum][indent]==' ';) indent++;\n    if( indent<=pindent ) break;\n    \n    int colon = in[linum].find(\":\");\n    string key = in[linum].substr(indent, colon-indent);\n    if(colon==in[linum].size()-1){\n      res->key.push_back(key);\n      res->property.push_back(\"__object\");\n      \n      linum++;\n      res->child.push_back(parse(indent));\n    } else {\n      res->key.push_back(key);\n      res->property.push_back(in[linum].substr(colon+2));\n      res->child.push_back(NULL);\n\n      linum++;\n    }\n  }\n  return res;\n}\n\nconst string NG = \"no such property\";\n\nstring find(const object* root, const vector<string>v) {\n  for(int i=0; i<v.size()-1; i++) {\n    bool ok = 0;\n    for(int j=0; j<root->key.size(); j++) {\n      if(root->key[j]==v[i]) {\n\tif(root->property[j]!=\"__object\") break;\n\troot=root->child[j];\n\tok = 1;\n\tbreak;\n      }\n    }\n    if(!ok) return NG;\n  }\n  \n  for(int i=0; i<root->key.size(); i++) {\n    if(root->key[i]==v.back()) {\n      if(root->property[i]==\"__object\") return \"object\";\n      else return \"string \\\"\" + root->property[i] + \"\\\"\";\n    }\n  }\n  return NG;\n}\n\nint main() {\n  \n  vector<string> Query;\n  string query;\n  getline(cin, query);\n  for(int i=0; i<query.size(); i++) if(query[i] == '.') query[i] = ' ';\n  stringstream ss(query);\n  while(ss>>query) Query.push_back(query);\n  \n  linum = 0;\n  N = 0;\n  while(getline(cin, in[N])) N++;\n  object *yaml = parse();\n  \n  cout << find(yaml, Query) << endl;\n  \n  return 0;\n}\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define ASSERT(c, m) if(!(c)){cerr << (m) << endl;exit(1);}\n\nint count_spaces(string s) {\n    int ret = 0;\n    rep(i, 0, s.size()) {\n        if (s[i] != ' ') break;\n        ret++;\n    }\n    return ret;\n}\n\npair<string, string> read_line(string line) {\n    string key, cont;\n    int st = 0;\n    while (line[st] == ' ') {\n        ASSERT(st < line.size(), \"error1\");\n        st++;\n    }\n    bool f = false;\n    rep(i, st, line.size()) {\n        if (line[i] == ':') {\n            f = true;\n            i++;\n            continue;\n        }\n        if (!f) {\n            key += line[i];\n        } else {\n            cont += line[i];\n        }\n    }\n    return make_pair(key, cont);\n}\n\nsigned main() {\n    string line;\n    getline(cin, line);\n    deque<string> keys;\n    rep(i, 0, line.size()) {\n        if (line[i] == '.') {\n            keys.push_back(\"\");\n        } else {\n            keys.back() += line[i];\n        }\n    }\n    assert(!keys.empty());\n\n    bool found = false;\n    string ans;\n    int indent = -1;\n    while (getline(cin, line)) {\n        int tmp = count_spaces(line);\n        if (indent == -1) indent = tmp;\n        if (indent != tmp) {\n            continue;\n        }\n\n        string key, cont;\n        tie(key, cont) = read_line(line);   \n        ASSERT(!keys.empty(), \"error2\");\n        if (key != keys.front()) {\n            continue;\n        }\n        keys.pop_front();\n      \n        indent = -1;\n        if (keys.empty()) {\n            ans = cont;\n            found = true;\n            break;\n        }\n    }\n    if (!found) {\n        cout << \"no such property\" << endl;\n    } else {\n        if (ans == \"\") cout << \"object\" << endl;\n        else cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstring key(string &s,int &i);\nstring string_(string &s,int &i);\nvoid indent(int &i,int n);\n\nstruct item{\n    map<string,item*> ptr;\n    string val;\n    bool is_str;\n    item(string val,bool is_str):val(val),is_str(is_str){}\n    string find(string &qry,int i){\n        if(i==qry.size()) return ptr.begin()->second->is_str?\"string \\\"\"+ptr.begin()->first+\"\\\"\":\"object\";\n        if(qry[i]=='.') ++i;\n        string tmp=string_(qry,i);\n        return ptr.count(tmp) and !ptr[tmp]->is_str?ptr[tmp]->find(qry,i):\"no such property\";\n    }\n};\n\nbool isalphabet(char ch){\n    return 'a'<=ch and ch<='z';\n}\n\nbool is_indent_n(string &s,int i,int n){\n    if(n==0) return true;\n    if(i==s.size() or s[i]!=' ') return false;\n    return is_indent_n(s,i+1,n-1);\n}\n\nvoid yaml(string &s,int &i,item &itm);\nvoid mapping(string &s,int &i,item &itm,int n);\nvoid mapping_item(string &s,int &i,item &itm,int n);\n\nvoid yaml(string &s,int &i,item &itm){\n    mapping(s,i,itm,0);\n}\n\nvoid mapping(string &s,int &i,item &itm,int n){\n    mapping_item(s,i,itm,n);\n    if(i!=s.size() and is_indent_n(s,i,n)) mapping(s,i,itm,n);\n}\n\nvoid mapping_item(string &s,int &i,item &itm,int n){\n    indent(i,n);\n    item* itm_=new item(key(s,i),false);\n    itm.ptr[itm_->val]=itm_;\n    ++i;\n    if(s[i]==' '){\n        ++i;\n        item* str=new item(string_(s,i),true);\n        itm_->ptr[str->val]=str;\n        ++i;\n    }else{\n        ++i;\n        int j=i;\n        while(j!=s.size() and s[j]==' ') ++j;\n        mapping(s,i,*itm_,j-i);\n    }\n}\n\nstring key(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i])){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nstring string_(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i]) or s[i]==' '){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nvoid indent(int &i,int n){\n    if(n==0) return;\n    ++i;\n    indent(i,n-1);\n}\n\nvoid solve(){\n    string qry,yaml_str;\n    cin >> qry;\n    cin.ignore();\n    {\n        string buf;\n        while(getline(cin,buf)){\n            yaml_str+=buf;\n            yaml_str+='\\n';\n        }\n    }\n\n    item root(\"\",false);\n    {\n        int idx=0;\n        yaml(yaml_str,idx,root);\n    }\n\n    cout << root.find(qry,0) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct obj{\n\tvector<string> key;\n\tvector<string> property;\n\tvector<obj> obj;\n};\nint n, p;\nobj null;\n\nstring ks, in[50000];\nobj parse(int pid = -1){\n\tobj res;\n\twhile(p < n){\n\t\tint id = 0;\n\t\tfor(; isspace(in[p][id]); id++);\n\t\tif(id <= pid) break;\n\t\t\n\t\tint pos = in[p].find(\":\");\n\t\tstring key = in[p].substr(id, pos - id);\n\t\tif(pos == in[p].size() - 1){\n\t\t\tres.key.pb(key);\n\t\t\tres.property.pb(\"\");\n\t\t\tp++;\n\t\t\tres.obj.pb(parse(id));\n\t\t}\n\t\telse{\n\t\t\tres.key.pb(key);\n\t\t\tres.property.pb(in[p].substr(pos + 2));\n\t\t\tres.obj.pb(null);\n\t\t\tp++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tgetline(cin, ks);\n\twhile(getline(cin, in[n])) n++;\n\t\n\tobj root = parse();\n\t\n\teach(i, ks) if(*i == '.') *i = ' ';\n\tstringstream ss(ks);\n\tvector<string> v;\n\twhile(ss >> ks) v.pb(ks);\n\t\n\trep(i, v.size() - 1){\n\t\tbool ok = 0;\n\t\trep(j, root.key.size()) if(root.key[j] == v[i]){\n\t\t\tif(root.property[j] != \"\") break;\n\t\t\t\n\t\t\troot = root.obj[j];\n\t\t\tok = 1;\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"no such property\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\trep(j, root.key.size()) if(root.key[j] == v.back()){\n\t\tif(root.property[j] != \"\") cout << \"string \\\"\" << root.property[j] << \"\\\"\" << endl;\n\t\telse cout << \"object\" << endl;\n\t\treturn 0;\n\t}\n\tcout << \"no such property\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<string, string> P;\n\nstruct Node{\n  string obj_name, property;\n  int indent;\n  Node* pre;\n  vector<Node*> next;\n  Node():obj_name(\"\"),property(\"\"),indent(0),pre(NULL){}\n};\n\nvector<string> input(){\n  vector<string> res;\n  string s;\n  while(getline(cin,s)) res.push_back(s);\n  return res;\n}\n\nint indent(const string& s){\n  int cnt = 0;\n  for(int i = 0; i < (int)s.length(); i++)\n    if(s[i] == ' ') cnt++;\n    else break;\n  return cnt;\n}\n\nstring erase(const string& s, char c){\n  string res = \"\";\n  bool up = false;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] != c || up){\n      res += s[i];\n      up = true;\n    }\n  }\n  return res;\n}\n\nNode* top = new Node();\n\nP divide(const string& s){\n  int pos = 0;\n  while(s[pos] != ':' && pos < (int)s.length()) pos++;\n  return P(s.substr(0,pos), s.substr(pos+1));\n}\n\n\nstring find(const string& q){\n  Node* node = top;\n  string now = q;\n  if(q == \".\") return \"object\";\n\n  while(now != \"\"){\n    now = now.substr(1);\n    int pos = 0;\n    while(now[pos] != '.' && pos < (int)now.size()) pos++;\n    string pro = now.substr(0, pos);\n    Node* next = NULL;\n    \n    for(int i = 0; i < (int)node->next.size(); i++){\n      if(node->next[i]->obj_name == pro) next = node->next[i];\n    }\n\n    //  cout << \"now \" << node->obj_name << endl;\n    \n    if(next == NULL) return \"no such property\";\n    node = next;\n    now = now.substr(pos);\n  }\n\n  if(node->property != \"\") return \"string \\\"\" + node->property + \"\\\"\";\n  return \"object\";\n}\n\nvoid solve(const vector<string>& v, const string& q){\n\n  Node* now = top;\n  bool refresh = false;\n\n  for(int i = 0; i < (int)v.size(); i++){\n    if(refresh){\n      now->indent = indent(v[i]);\n      refresh = false;\n    }else{\n      int idt = indent(v[i]);\n      while(idt < now->indent) now = now->pre;\n    }\n\n    P p = divide(v[i]);\n\n    p.first = erase(p.first, ' ');\n  \n    if(p.second == \"\"){\n      //object\n      Node* tmp = new Node();\n      tmp->obj_name = p.first;\n      tmp->pre = now;\n      now->next.push_back(tmp);\n      now = tmp;\n      refresh = true;\n    }else{\n      p.second = p.second.substr(1);\n\n      //cout << now->obj_name << \" \" << p.first << \" \" << p.second << endl;\n      Node* tmp = new Node();\n      tmp->obj_name = p.first;\n      tmp->property = p.second;\n      now->next.push_back(tmp);\n    }\n  }\n  cout << find(q) << endl;\n}\n\nint main(){\n  top->obj_name = \"top\";\n  string q;\n  getline(cin,q);\n  vector<string> in = input();\n  solve(in, q);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nstruct node_t {\n\tstring name;\n\tunordered_map<string, unique_ptr<node_t>> children;\n\n\tbool is_leaf() const {\n\t\treturn children.size() == 0;\n\t}\n\n\tvoid add_child(const string &key, unique_ptr<node_t> &&p) {\n\t\tchildren[key] = move(p);\n\t}\n\n\tstring find(const vector<string>& query, int depth = 0) const {\n\t\tif(depth == query.size()) return is_leaf() ? \"string \\\"\" + name + \"\\\"\" : \"object\";\n\t\tif(children.count(query[depth])) return children.at(query[depth])->find(query, depth + 1);\n\t\treturn \"no such property\";\n\t}\n\n\tstring to_string() const {\n\t\tif(is_leaf()) return name;\n\t\tstring res = \" \";\n\t\tfor(const auto &e : children) {\n\t\t\tres += e.first + \"(\" + e.second->to_string() + \") \";\n\t\t}\n\t\treturn res;\n\t}\n};\n\nvector<string> split(string s, const string &delim) {\n\tvector<string> res;\n\tint pos;\n\twhile((pos = s.find(delim)) != string::npos) {\n\t\tif(pos) res.emplace_back(s.substr(0, pos));\n\t\ts = s.substr(pos + 1);\n\t}\n\tif(s.size()) res.emplace_back(s);\n\treturn res;\n}\n\nint indent(const string &s) {\n\tfor(unsigned i = 0; i < s.size(); ++i) {\n\t\tif(s[i] != ' ') return i;\n\t}\n\treturn 0;\n}\n\nunique_ptr<node_t> mapping(const vector<string> &input, int &idx, int ind) {\n\tunique_ptr<node_t> res(new node_t);\n\twhile(idx < input.size()) {\n\t\tif(indent(input[idx]) < ind) break;\n\n\t\tconst int pos = input[idx].find(':');\n\t\tstring property = input[idx].substr(ind, pos - ind);\n\n\t\tif(pos + 1 == input[idx].size()) {\n\t\t\t++idx;\n\t\t\tres->add_child(property, mapping(input, idx, indent(input[idx])));\n\t\t}\n\t\telse {\n\t\t\tunique_ptr<node_t> child(new node_t);\n\t\t\tchild->name = input[idx++].substr(pos + 2);\n\t\t\tres->add_child(property, move(child));\n\t\t}\n\t}\n\treturn res;\n}\n\nunique_ptr<node_t> parse(const vector<string> &input) {\n\tint idx = 0;\n\treturn mapping(input, idx, 0);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tstring query;\n\tgetline(cin, query);\n\n\tvector<string> input;\n\tstring line;\n\twhile(getline(cin, line)) {\n\t\tinput.emplace_back(line);\n\t}\n\n\tconst auto root = parse(input);\n\tcout << root->find(split(query, \".\")) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\npair<int, size_t> indent(const string& s, size_t i) {\n  int cnt = 0;\n  while (i < s.size() && s[i] == ' ') {\n    ++i; ++cnt;\n  }\n  return make_pair(cnt, i);\n}\n\npair<string, size_t> get_str(const string& s, size_t i) {\n  string res;\n  while (isalnum(s[i]) || s[i] == ' ') {\n    res += s[i];\n    ++i;\n  }\n  return make_pair(res, i);\n}\n\nstruct Item {\n  int depth;\n  string key;\n  int type;\n  string obj_str;\n  vector<Item> obj_map;\n};\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i, int old_depth = -1);\n\npair<Item, size_t> mapping_item(const string& s, size_t i, int front_depth) {\n  int depth;\n  tie(depth, i) = indent(s, i);\n  if (front_depth != -1 && depth != front_depth) throw \"fail\";\n  string key;\n  tie(key, i) = get_str(s, i);\n  ++i;\n  if (s[i] == '\\n') { // mapping\n    vector<Item> mapping_child;\n    tie(mapping_child, i) = mapping(s, i+1, depth);\n    return make_pair((Item){depth, key, 1, \"\", std::move(mapping_child)}, i);\n  } else { // string\n    string obj;\n    tie(obj, i) = get_str(s, i+1);\n    return make_pair((Item){depth, key, 0, obj, vector<Item>()}, i+1);\n  }\n}\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i, int old_depth) {\n  vector<Item> res;\n  Item front;\n  tie(front, i) = mapping_item(s, i, -1);\n  if (front.depth < old_depth) throw \"fail\";\n  res.push_back(front);\n  while(i < s.size()) {\n    Item next;\n    size_t next_i;\n    try {\n      tie(next, next_i) = mapping_item(s, i, front.depth);\n    } catch (...) {\n      break;\n    }\n    res.push_back(std::move(next));\n    i = next_i;\n  }\n  return make_pair(std::move(res), i);\n}\n\nstring query(const vector<Item>& obj, const string& s, size_t i) {\n  string key_name;\n  tie(key_name, i) = get_str(s, i+1);\n  for (auto& item : obj) {\n    if (item.key == key_name) {\n      if (item.type == 0) {\n        if (i == s.size()) {\n          return \"string \\\"\" + item.obj_str + \"\\\"\";\n        } else {\n          return \"no such property\";\n        }\n      } else {\n        if (i == s.size()) {\n          return \"object\";\n        } else {\n          return query(item.obj_map, s, i);\n        }\n      }\n    }\n  }\n  return \"no such property\";\n}\n\nint main() {\n  string q;\n  getline(cin, q);\n  string yaml;\n  string line;\n  while (getline(cin, line)) yaml += line + \"\\n\";\n  auto res = mapping(yaml, 0).first;\n  cout << query(res, q, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nstruct Obj{\n  int lv;\n  map<string,string> strs;\n  map<string,Obj*> objs;\n\n  int find(vector<string>& path, string& res, int idx = 0){\n\tif(path.size() == idx+1){\n\t  if(strs.count(path[idx])){\n\t\tres = strs[path[idx]];\n\t\treturn 1;\n\t  }\n\t  else if(objs.count(path[idx]))\n\t\treturn 0;\n\t  return -1;\n\t}\n\telse{\n\t  if(!objs.count(path[idx])) return -1;\n\t  return objs[path[idx]]->find(path, res, idx+1);\n\t}\n  }\n};\n\nint N;\nvector<int> level;\nvector<string> vs;\n\nvector<string> split(string s, const string &delim) {\n    vector<string> res;\n    int pos;\n    while((pos = s.find(delim)) != string::npos) {\n        if(pos) res.emplace_back(s.substr(0, pos));\n        s = s.substr(pos + 1);\n    }\n    if(s.size()) res.emplace_back(s);\n    return res;\n}\n\nvoid dfs(int& idx, int lv, Obj* obj){\n  for(;idx<N;){\n\tif(idx == N || level[idx] <= lv) return;\n\tint lv_c = level[idx];\n\tint p = vs[idx].find(\":\");\n\n\tstring key = vs[idx].substr(level[idx], p-level[idx]);\n\tif(p+1 == vs[idx].size()){\n\t  Obj* c = new Obj();\n\t  c->lv = lv_c;\n\t  ++idx;\n\t  dfs(idx, lv_c, c);\n\t  obj->objs[key] = c;\n\t}\n\telse{\n\t  string str = vs[idx].substr(p+2);\n\t  obj->strs[key] = str;\n\t  ++idx;\n\t}\n  }\n}\n\nvoid debug(Obj* obj){\n  cout << obj->lv << \": \" << endl;\n  for(auto& ss: obj->strs)\n\tcout << ss.first << \" -> \" << ss.second << endl;\n  for(auto& ss: obj->objs){\n\tcout << ss.first << \" -> *\" << endl;\n\tdebug(ss.second);\n  }\n}\n\nint main(){\n  string query; cin >> query; cin.ignore();\n\n  string line;\n  N = 0;\n  while(getline(cin, line)){\n\tint lv = 0;\n\tfor(;line[lv]==' ';++lv);\n\tlevel.push_back(lv);\n\tvs.push_back(line);\n\t++N;\n  }\n  Obj* yaml = new Obj();\n  yaml->lv = -1;\n  int idx = 0;\n  dfs(idx,-1,yaml);\n\n  //  debug(yaml);\n\n  vector<string> path = split(query, \".\");\n\n  string res;\n  switch(yaml->find(path, res)){\n  case 1:\n\tcout << \"string \\\"\" << res << \"\\\"\" << endl;\n\tbreak;\n  case 0:\n\tcout << \"object\" << endl;\n\tbreak;\n  default:\n\tcout << \"no such property\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint main() {\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\tvector<pair<int, string>> cn;\n\tmap<string, string> obj;\n\tstring buf;\n\twhile (getline(cin, buf)) {\n\t\tint i = 0,j;\n\t\tfor (; buf[i] == ' '; i++);\n\t\tif (buf.back() == ':') {\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tcn.push_back(make_pair(i, ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(cn.back().second,\"*\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tcn.push_back(make_pair(i, cn.back().second + ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(cn.back().second,\"*\"));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (j = i; buf[j] != ':'; j++);\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tobj.insert(make_pair(((string)\".\").append(buf.begin() + i, buf.begin() +j), ((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tobj.insert(make_pair(cn.back().second + ((string)\".\").append(buf.begin() + i, buf.begin()+j),((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t}\n\t}\n\tauto res = obj[query];\n\tif (res==\"\")res = \"no such property\";\n\telse if(res == \"*\")res = \"object\";\n\telse res = \"string \\\"\" + res + \"\\\"\";\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  getline(cin, s);\n\n  vector<string> key;\n  string t = \"\";\n  int n = 0;\n  FOR(i, 1, s.size()) {\n    if(s[i] == '.') {\n      key.PB(t);\n      t = \"\";\n      n++;\n    } else {\n      t += s[i];\n    }\n  }\n  n++;\n  key.PB(t);\n  // cout << key << endl;\n\n  string ans = \"no such property\";\n  int idx = 0;\n  while(getline(cin, t)) {\n    string prop = \"\", str = \"\";\n    int flag = 0;\n    REP(i, t.size()) {\n      if(flag == 0 && t[i] != ' ') flag = 1;\n      if(flag == 1 && t[i] == ':') {flag = 2; i++; continue;}\n      if(flag == 1) prop += t[i];\n      if(flag == 2) str += t[i];\n      // cout << \"i:\" << i << \" \" << prop << \" \" << str << endl;\n    }\n\n    if(idx < n && prop == key[idx]) {\n      idx++;\n      if(idx == n) {\n        if(str == \"\") ans = \"object\";\n        else ans = \"string \\\"\" + str + \"\\\"\";\n        // break;\n      }\n    }\n    // cout << idx << endl << prop << endl << str << endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nstruct item{\n    vector<item*> ptr;\n    string val;\n    bool is_str;\n};\n\nbool isalphabet(char ch){\n    return 'a'<=ch and ch<='z';\n}\n\nbool is_indent_n(string &s,int i,int n){\n    if(n==0) return true;\n    if(i==s.size() or s[i]!=' ') return false;\n    return is_indent_n(s,i+1,n-1);\n}\n\nvoid yaml(string &s,int &i,item &itm);\nvoid mapping(string &s,int &i,item &itm,int n);\nvoid mapping_item(string &s,int &i,item &itm,int n);\nstring key(string &s,int &i);\nstring string_(string &s,int &i);\nvoid indent(string &s,int &i,int n);\n\nvoid yaml(string &s,int &i,item &itm){\n    mapping(s,i,itm,0);\n}\n\nvoid mapping(string &s,int &i,item &itm,int n){\n    mapping_item(s,i,itm,n);\n    if(i!=s.size() and is_indent_n(s,i,n)) mapping(s,i,itm,n);\n}\n\nvoid mapping_item(string &s,int &i,item &itm,int n){\n    indent(s,i,n);\n    item* itm_=new item();\n    itm_->val=key(s,i);\n    itm.ptr.push_back(itm_);\n    show(s[i]);\n    assert(i<s.size());\n    show(i);\n    show(s.size());\n    assert(s[i]==':');\n    ++i;\n    if(s[i]==' '){\n        ++i;\n        item* str=new item();\n        str->is_str=true;\n        str->val=string_(s,i);\n        itm_->ptr.push_back(str);\n        assert(s[i]=='\\n');\n        ++i;\n    }else{\n        assert(s[i]=='\\n');\n        ++i;\n        int j=i;\n        while(j!=s.size() and s[j]==' ') ++j;\n        assert(n<j-i);\n        show(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n        show(j-i);\n        mapping(s,i,*itm_,j-i);\n    }\n}\n\nstring key(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i])){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nstring string_(string &s,int &i){\n    string res;\n    while(isalphabet(s[i]) or isdigit(s[i]) or s[i]==' '){\n        res+=s[i];\n        ++i;\n    }\n    return res;\n}\n\nvoid indent(string &s,int &i,int n){\n    if(n==0) return;\n    show(n);\n    show(s[i]);\n    assert(s[i]==' ');\n    ++i;\n    indent(s,i,n-1);\n}\n\nvoid solve(){\n    string qry,yaml_str;\n    cin >> qry;\n    cin.ignore();\n    {\n        string buf;\n        while(getline(cin,buf)){\n            yaml_str+=buf;\n            yaml_str+='\\n';\n        }\n    }\n\n    item root;\n    root.val=\"root\";\n    {\n        int idx=0;\n        yaml(yaml_str,idx,root);\n    }\n\n    {\n        item* itm=&root;\n        int idx=1;\n        while(true){\n            string str=string_(qry,idx);\n            bool ok=false;\n            rep(i,0,itm->ptr.size()) if(!itm->ptr[i]->is_str and itm->ptr[i]->val==str){\n                itm=itm->ptr[i];\n                ok=true;\n                break;\n            }\n            if(!ok){\n                cout << \"no such property\" << endl;\n                return;\n            }\n            if(idx==qry.size()){\n                item *obj=itm->ptr.front();\n                if(obj->is_str) cout << \"string \\\"\" << obj->val << \"\\\"\" << endl;\n                else cout << \"object\" << endl;\n                return;\n            }\n            ++idx;\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nstring yaml[50010];\n\nint main(void){\n\tstring s;\n\tcin >> s;\n\tvector<string> keys;\n\n\twhile(s!=\"\"){\n\t\tint cur=1;\n\t\twhile(cur<s.size()&&s[cur]!='.') cur++;\n\t\tkeys.push_back(s.substr(1,cur-1));\n\t\ts=s.substr(cur);\n\t}\n\n\tcin.ignore();\n\t\n\tint n=0;\n\twhile(1){\n\t\tgetline(cin,yaml[n++]);\n\t\tif(cin.eof()) break;\n\t}\n\n\tbool not_found=false;\n\n\tint cur=0,pos=0;\n\twhile(1){\n\t\tconst int len=keys[pos].size();\n\t\twhile(cur<n){\n\t\t\tif(keys[pos]==yaml[cur].substr(pos,len))\n\t\t\t\tbreak;\n\t\t\tcur++;\n\t\t}\n\t\t\n\t\t//cout << cur << \" \" << pos << endl;\n\n\t\tif(cur==n){\n\t\t\tnot_found=true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(pos+1==keys.size()) break;\n\t\tcur++,pos++;\n\t}\n\n\tif(not_found){\n\t\tcout << \"no such property\" << endl;\n\t\treturn 0;\n\t}\n\n\tstring elem=yaml[cur].substr(pos+1+keys[keys.size()-1].size());\n\tif(elem==\"\")\n\t\tcout << \"object\" << endl;\n\telse{\n\t\tcout << \"string \\\"\"  << elem << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nstruct Node{\n  string str;\n  string property;\n  vector<Node*> nodes;\n};\nvector<Node*> tree;\nvector<string> yaml;\n\nvector<Node*> dfs(int &pos,const int nowWsp){\n  vector<Node*> res;\n  int cnt=0;\n  while(pos<(int)yaml.size()){\n    cnt++;\n    Node *now=new Node();\n    int wsp=0;\n    string &s=yaml[pos];\n    for(int i=0;i<(int)s.size();i++)\n      if(s[i]==' ')wsp++;\n      else break;\n    int ps=0;\n    for(int i=0;i<(int)s.size();i++){\n      if(s[i]==':'){\n\tps=i+1;\n\tbreak;\n      }\n    }\n    string name=s.substr(wsp,ps-wsp-1);\n    string property=\"\";\n    //cout<<wsp<<\" \"<<nowWsp<<\" \"<<name<<endl;\n    if(ps!=(int)s.size())property=s.substr(ps+1);\n    now->str=name;\n    now->property=property;\n    if(property==\"\"){\n      pos++;\n      int p=0;\n      for(int i=0;i<(int)yaml[pos].size();i++)\n\tif(yaml[pos][i]==' ')p++;\n\telse break;\n      //cout<<\"#\"<<name<<\" \"<<wsp<<endl;\n      now->nodes=dfs(pos,p);\n      cout<<\"#\"<<name<<\" \"<<wsp<<\" \"<<res.size()<<endl;\n    }\n    //else if(wsp>nowWsp)now->nodes=dfs(pos,wsp);\n    else if(wsp<nowWsp){\n      return res;\n    }\n    else pos++;\n    //cout<<pos<<endl;\n    cout<<\"#\"<<name<<\" \"<<wsp<<\" \"<<res.size()<<endl;\n    if(nowWsp==0&&name==\"c\")\n      cout<<\"ccc\"<<endl;\n    res.push_back(now);\n    cout<<\"#\"<<name<<\" \"<<wsp<<\" \"<<res.size()<<endl;\n    cout<<nowWsp<<endl;\n  }\n  if(nowWsp==0){\n    cout<<cnt<<\" \"<<res.size()<<endl;\n  }\n  cout<<\"ret\"<<endl;\n  // for(int i=0;i<(int)res.size();i++){\n  //   for(int j=0;j<(int)res.nodes->size();j++){\n  //     //cout<<res[i].nodes[j]->str<<endl;\n  //   }\n  // }\n  return res;\n}\nconst string nsp=\"no such property\";\nconst string obj=\"object\";\nstring search(Node *now,int pos,vector<string>&vs){\n  for(int i=0;i<(int)now->nodes.size();i++){\n    cout<<now->nodes[i]->str<<endl;\n    if(now->nodes[i]->str==vs[pos]){\n      if((int)vs.size()-1==pos){\n\tif(now->nodes[i]->property==\"\")return obj;\n\treturn now->nodes[i]->property;\n      }\n      return search(now->nodes[i],pos+1,vs);\n    }\n  }\n  return nsp;\n}\n\nint main(){\n  string order;\n  getline(cin,order);\n  order=order.substr(1);\n  vector<string> os;\n  int spos=0;\n  for(int i=0;i<(int)order.size();i++){\n    if(order[i]=='.'){\n      os.push_back(order.substr(spos,i-spos));\n      spos=i+1;\n    }\n  }\n  os.push_back(order.substr(spos));\n  string st;\n  while(getline(cin,st))\n    yaml.push_back(st);\n  int a=0;\n  vector<Node*> root=dfs(a,0);\n  Node *rt=new Node();\n  rt->nodes=root;\n  string s=search(rt,0,os);\n  if(s==obj||s==nsp)cout<<s<<endl;\n  else cout<<\"string \\\"\"<<s<<\"\\\"\"<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define all(a) (a).begin(),(a).end()\n\nvector<string> split(string s, char c) {\n    vector<string> vs;\n    string tmp = \"\";\n    rep(i, s.size()) {\n        if (s[i] == c) {\n            vs.emplace_back(tmp);\n            tmp = \"\";\n        } else {\n            tmp += s[i];\n        }\n    }\n    vs.emplace_back(tmp);\n    return vs;\n}\n\nint countSpace(string s) {\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            return i;\n        }\n    }\n    assert(false);\n}\n\ntuple<int, string, string> parseLine(string s) {\n    int indent;\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            indent = i;\n            break;\n        }\n    }\n    auto vs = split(s.substr(indent), ':');\n    string key = vs[0], value = vs[1].empty() ? \"\" : vs[1].substr(1);\n    return make_tuple(indent, key, value);\n}\n\nvoid answer(string value) {\n    if (value.empty()) {\n        cout << \"object\" << endl;\n    } else {\n        cout << \"string \\\"\" << value << \"\\\"\" << endl;\n    }\n}\n\nint main() {\n    string s;\n    getline(cin, s);\n    vector<string> keys = split(s, '.');\n    queue<string> que;\n    rep2(i, 1, keys.size()) {\n        que.push(keys[i]);\n    }\n    int indent_pre = 0;\n    while (getline(cin, s)) {\n        int indent;\n        string key, value;\n        tie(indent, key, value) = parseLine(s);\n        // cerr << num_sp << \" \" << key << \" \" << value << endl;\n        if (indent < indent_pre) break;\n        if (key == que.front()) {\n            que.pop();\n            if (que.empty()) {\n                answer(value);\n                return 0;\n            }\n        }\n        indent_pre = indent;\n    }\n    cout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nstring in[100000];\nint idx;\nint pos;\nstruct obj_{\n  map<string,string> key;\n  map<string,struct obj_*> mem;\n}obj;\n\nint getindent(int p){\n  int ret=0;\n  while(ret<SZ(in[p]) && in[p][ret]==' ')++ret;\n  return ret;\n}\n\nstruct obj_* get(){\n  struct obj_ *ret= new obj_();\n  int ind=getindent(pos);\n  while(pos < idx && ind==getindent(pos)){\n    int p=in[pos].find(':');\n    string key=in[pos].substr(ind,p-ind);\n    //cout << ind << ' ' << key << endl;\n    if(p+3>SZ(in[pos])){\n      ++pos;\n      ret->mem[key]=get();\n    }else{\n      ret->key[key]=in[pos].substr(p+2);\n    }\n    ++pos;\n  }\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  string pro;\n  cin >> pro;cin.get();\n  while(getline(cin,in[idx++]));\n  struct obj_ *r=get();\n  FOR(it,pro) if(*it=='.') *it=' ';\n  stringstream ss(pro);\n  while(ss >> pro){\n    if(r->mem.count(pro)) r=r->mem[pro];\n    else if(r->key.count(pro)){\n      string ans=r->key[pro];\n      if(ss >> pro) cout << \"no such property\" << endl;\n      else cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n      return 0;\n    }else{\n      cout << \"no such property\" << endl;\n      return 0;\n    }\n  }\n  cout << \"object\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvector<string> split(const string &s, char c){\n\tvector<string> vs;\n\tsize_t prev = 0, cur;\n\twhile((cur = s.find(c, prev)) != string::npos){\n\t\tvs.push_back(s.substr(prev, cur - prev));\n\t\tprev = cur + 1;\n\t}\n\tvs.push_back(s.substr(prev));\n\treturn vs;\n}\n\nint count_indent(const string &s){\n\tint answer = 0;\n\twhile(s[answer] == ' '){ ++answer; }\n\treturn answer;\n}\n\nstruct Node {\n\tbool has_child;\n\tstring name;\n\tstring value;\n\tvector<Node> children;\n\t// parse\n\tint row;\n\tNode() : has_child(false), name(), value(), children() { }\n};\n\nvector<Node> mapping(const vector<string> &s, int r, int indent){\n\tvector<Node> result;\n\twhile(r < s.size()){\n\t\tstring cur = s[r];\n\t\tif(count_indent(cur) != indent){ break; }\n\t\tcur = cur.substr(indent);\n\t\tvector<string> vs = split(cur, ':');\n\t\tNode n;\n\t\tn.name = vs[0];\n\t\tif(vs.size() == 2 && vs[1] == \"\"){\n\t\t\t// has child\n\t\t\tn.has_child = true;\n\t\t\tif(r + 1 < s.size()){\n\t\t\t\tint next_indent = count_indent(s[r + 1]);\n\t\t\t\tif(next_indent > indent){ n.children = mapping(s, r + 1, next_indent); }\n\t\t\t}\n\t\t\tn.row = r = n.children.back().row;\n\t\t}else if(vs.size() >= 2){\n\t\t\t// value\n\t\t\tn.value = cur.substr(vs[0].size() + 2);\n\t\t\tn.row = ++r;\n\t\t}\n\t\tresult.push_back(n);\n\t}\n\treturn result;\n}\n\nvoid recur(const vector<Node> &t, const vector<string> &q, int p);\nvoid recur(const Node &n, const vector<string> &q, int p){\n\tif(p == q.size()){\n\t\tif(n.has_child){\n\t\t\tcout << \"object\" << endl;\n\t\t}else{\n\t\t\tcout << \"string \\\"\" << n.value << \"\\\"\" << endl;\n\t\t}\n\t}else{\n\t\trecur(n.children, q, p);\n\t}\n}\nvoid recur(const vector<Node> &t, const vector<string> &q, int p){\n\tbool found = false;\n\tfor(int i = 0; i < t.size(); ++i){\n\t\tif(t[i].name == q[p]){\n\t\t\trecur(t[i], q, p + 1);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!found){\n\t\tcout << \"no such property\" << endl;\n\t}\n}\n\nint main(){\n\tstring q;\n\tgetline(cin, q);\n\tvector<string> yaml;\n\twhile(!cin.eof()){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif(s != \"\"){ yaml.push_back(s); }\n\t}\n\tvector<Node> tree = mapping(yaml, 0, 0);\n\tvector<string> query = split(q.substr(1), '.');\n\trecur(tree, query, 0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define all(a) (a).begin(),(a).end()\n\nvector<string> split(string s, char c) {\n    vector<string> vs;\n    string tmp = \"\";\n    rep(i, s.size()) {\n        if (s[i] == c) {\n            vs.emplace_back(tmp);\n            tmp = \"\";\n        } else {\n            tmp += s[i];\n        }\n    }\n    if (!tmp.empty()) vs.emplace_back(tmp);\n    return vs;\n}\n\nint countSpace(string s) {\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            return i;\n        }\n    }\n    assert(false);\n}\n\ntuple<int, string, string> parseLine(string s) {\n    int num_sp;\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            num_sp = i;\n            break;\n        }\n    }\n    auto vs = split(s.substr(num_sp), ':');\n    string key = vs[0], value = vs[1].empty() ? \"\" : vs[1].substr(1);\n    return make_tuple(num_sp, key, value);\n}\n\nvoid answer(string value) {\n    if (value.empty()) {\n        cout << \"object\" << endl;\n    } else {\n        cout << \"string \\\"\" << value << \"\\\"\" << endl;\n    }\n}\n\nint main() {\n    string s;\n    getline(cin, s);\n    vector<string> keys = split(s, '.');\n    queue<string> que;\n    rep2(i, 1, keys.size()) {\n        que.push(keys[i]);\n    }\n    int indent = 0;\n    while (getline(cin, s)) {\n        int num_sp;\n        string key, value;\n        tie(num_sp, key, value) = parseLine(s);\n        // cerr << num_sp << \" \" << key << \" \" << value << endl;\n        if (num_sp < indent) break;\n        if (key == que.front()) {\n            que.pop();\n            if (que.empty()) {\n                answer(value);\n                return 0;\n            }\n        }\n    }\n    cout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring prop[32];\n\nint main()\n{\n    rep(i,32) prop[i] = \"\";\n    string in;\n    cin >> in;\n    int sz = 0;\n    rep(i,in.size()){\n\tif(in[i] == '.') sz++;\n\telse prop[sz-1] += in[i];\n    }\n    int pos = 0;\n    int depth = 0;\n    int prev = 0;\n    bool flag = false;\n    int indents[50000] = {0};\n    cin.ignore();\n    while(getline(cin,in)){\n\tif(in.size() == 0) break;\n\tint cur = 0;\n\twhile(in[cur] == ' ') cur++;\n\n\tstring tag = \"\", str = \"\";\n\tint t = cur;\n\twhile(in[t] != ':') tag += in[t++];\n\tt += 2;\n\twhile(t < in.size()) str += in[t++];\n\n\tif(cur > prev) {\n\t    depth++;\n\t    indents[depth] = cur;\n\t}\n\tif(cur < prev) {\n\t    while(indents[depth] > cur) depth--;\n\t}\n\tif(depth < pos){\n\t    pos = depth;\n\t}\n\n\tif(depth == pos && prop[pos] == tag){\n\t    pos++;\n\t    if(pos == sz){\n\t\tif(str.size() == 0) cout << \"object\\n\";\n\t\telse cout << \"string \\\"\" << str << \"\\\"\\n\";\n\t\treturn 0;\n\t    }\n\t}\n\tprev = cur;\n    }\n    cout << \"no such property\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nvoid yaml();\nvoid mapping(int& i, int level, string key);\nint mapping_item(int& i, int& j, int level, string key);\nstring key_(int& i, int& j);\nstring string_(int& i, int& j);\nint indent(int& i, int& j);\n\nstring prop;\nvector<string> S;\n\nvoid yaml() {\n    int i = 0;\n    int level = 0;\n    string key = \"\";\n    mapping(i, level, key);\n}\n\nvoid mapping(int& i, int level, string key) {\n    for (; i < SZ(S); i++) {\n        int j = 0;\n        int lv = mapping_item(i, j, level, key);\n        if (lv == -1) {\n            i--;\n            break;\n        }\n        level = lv;\n    }\n}\n\nint mapping_item(int& i, int& j, int level, string key) {\n    int lv = indent(i, j);\n    if (level > lv) {\n        return -1;\n    }\n    string k = key + '.' + key_(i, j);\n    j++; // ':'\n    if (S[i][j] == ' ') {\n        j++;\n        string v = string_(i, j);\n        if (k == prop) {\n            throw \"string \\\"\" + v + \"\\\"\";\n        }\n    } else if (S[i][j] == '\\n') {\n        if (k == prop) {\n            throw string(\"object\");\n        }\n        i++;\n        mapping(i, lv, k);\n    }\n    return lv;\n}\n\nstring key_(int& i, int& j) {\n    string x;\n    while (isalnum(S[i][j])) {\n        x += S[i][j];\n        j++;\n    }\n    return x;\n}\n\nstring string_(int& i, int& j) {\n    string x;\n    while (isalnum(S[i][j]) || S[i][j] == ' ') {\n        x += S[i][j];\n        j++;\n    }\n    return x;\n}\n\nint indent(int& i, int& j) {\n    int level = 0;\n    while (S[i][j] == ' ') {\n        level++;\n        j++;\n    }\n    return level;\n}\n\nint main() {\n    cin >> prop;\n    cin.ignore(); // '\\n'\n    string s;\n    while (getline(cin, s)) S.push_back(s + '\\n');\n    try {\n        yaml();\n        cout << \"no such property\" << endl;\n    } catch (string res) {\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> key,str;\nstring t,s;\nint ind;\n\nvoid getkey(){\n  int x=0;\n  for(int i=1;i<t.size();i++)\n    if(!x&&t[i]!='.')x=i;\n    else if(t[i]=='.')\n      key.push_back(t.substr(x,i-x)),x=0;\n}\n\nvoid getstr(){\n  int f=0; ind=0;\n  string a;\n  for(int i=0;i<s.size();i++)\n    if(!f&&s[i]==' ')ind++;\n    else f=1;\n  for(int i=ind;i<s.size();i++){\n    if(s[i]!=' ')a+=s[i];\n    else{\n      if(a[a.size()-1]==':')str.push_back(a.substr(0,a.size()-1)),a=\"\";\n      else{\n\tstr.push_back(a+s.substr(i,s.size()-i));\n\ta=\"\";\n\tbreak;\n      }\n    }\n  }\n  if(a!=\"\"){\n    if(a[a.size()-1]!=':')str.push_back(a);\n    else str.push_back(a.substr(0,a.size()-1));\n  }\n}\n\nint main(){\n  cin>>t; t+='.';\n  getkey();\n  getline(cin,s);\n  int x=-1,y=0,f=0;\n  while(getline(cin,s)){\n    str.clear();\n    getstr();\n    if(x<ind&&y!=key.size()&&str[0]==key[y]){\n      x=ind;\n      y++;\n      if(y==key.size()){\n\tif(!f&&str.size()==2)cout<<\"string \\\"\"<<str[1]<<\"\\\"\"<<endl;\n\telse if(!f)cout<<\"object\"<<endl;\n\tf=1;\n      }\n    }\n  }\n  if(!f)cout<<\"no such property\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<string>sts;\nvector<int>indnums;\nint a = 0;\nstruct yaml {\n\tbool is_dir;\n\tmap<string, yaml>mp;\n\tstring prop;\n\tvoid operator =(const yaml yaml_) {\n\t\tis_dir = yaml_.is_dir;\n\t\tmp = yaml_.mp;\n\t\tprop = yaml_.prop;\n\t}\n};\nyaml getmap(const int ind);\npair<string,yaml> getmapitem(const int ind) {\n\tyaml ayaml;\n\t\n\tconst int n = sts[a].find(':');\n\tstring key = sts[a].substr(indnums[a], n-indnums[a]);\n\tif (n == sts[a].size()-1) {\n\t\tayaml.is_dir = true;\n\t\ta++;\n\t\tayaml = getmap(indnums[a]);\n\t}\n\telse {\n\t\tayaml.is_dir = false;\n\t\tstring name = sts[a].substr(n + 2);\n\t\tayaml.prop = name;\n\t\ta++;\n\t}\n\treturn make_pair(key,ayaml);\n}\nyaml getmap(const int ind) {\n\tyaml ayaml;\n\tayaml.is_dir = true;\n\tayaml.mp.emplace(getmapitem(ind));\n\twhile (1) {\n\t\tif (a == sts.size() || indnums[a] != ind)break;\n\t\tayaml.mp.emplace(getmapitem(ind));\n\t}\n\treturn ayaml;\n}\n\nint main() {\n\tstring st; cin >> st;\n\tint now = 1;\n\tvector<string>keys;\n\twhile (1) {\n\t\tint n = st.find('.',now);\n\t\tif (n == string::npos) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tkeys.emplace_back(st.substr(now, n-now));\n\t\t}\n\t\tnow = n+1;\n\t}\n\tkeys.emplace_back(st.substr(now));\n\tstring ast;\n\tgetline(cin, ast);\n\twhile (getline(cin,ast)) {\n\t\tint n = ast.find_first_not_of(' ');\n\t\tsts.push_back(ast);\n\t\tindnums.emplace_back(n);\n\t}\n\tyaml y=getmap(0);\n\tint anstype=0;\n\tstring ans;\n\tyaml nyaml = y;\n\t\n\tfor (int i = 0; i < keys.size(); ++i) {\n\t\tauto it = nyaml.mp.find(keys[i]);\n\t\tif (it == nyaml.mp.end()) {\n\t\t\tanstype = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tnyaml = it->second;\n\t\t}\n\t}\n\tif (anstype == -1) {\n\t\tcout << \"no such property\" << endl;\n\t}\n\telse {\n\t\tif (nyaml.is_dir) {\n\t\t\tcout << \"object\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"string \\\"\" << nyaml.prop << \"\\\"\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char deliter){\n  vector<string> res;\n  int prev_split_point = 0;\n  while(s[prev_split_point] == ' ')prev_split_point++;\n  for (int i = prev_split_point; i < s.length(); i++) {\n    while(s[i] == ' ')i++, prev_split_point++;\n    while(s[i] != deliter && i < s.length())i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nstring slove(vector<string> &query,\n             map<string, string> &hash,\n             string s,\n             int i){\n  string res;\n  if(hash.find(s) == hash.end()){\n    return \"no such property\";\n  }\n  if(i == query.size() - 1){\n    return \"string \\\"\" + hash[s] + \"\\\"\";\n  }else if(hash.find(s) != hash.end()){\n    res = slove(query, hash, query[i + 1], i + 1);\n  }else{\n    return \"object\";\n  }\n  return res;\n}\n\n\nint main(int argc, char *argv[]){\n  map<string, string> hash;\n  string s;\n  cin >> s;\n  vector<string> query = split(s, '.');\n  cin.ignore();\n  while(getline(cin, s)){\n    vector<string> vs = split(s, ':');\n    // for (int i = 0; i < vs.size(); i++) {\n    //   std::cout << vs[i] << std::endl;\n    // }\n    if(vs.size() > 1)hash[vs[0]] = vs[1];\n    else hash[vs[0]] = \"\";\n  }\n  std::cout << slove(query, hash, query[0], 0) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nstring s[1<<17];\nvector<string>A;\nint cnt[1<<17];\nint N;\nstring f(int id,int L,int R,int d)\n{\n\tA[id]+=':';\n\tfor(int i=L;i<R;i++)\n\t{\n\t\tif(s[i].substr(d,A[id].size())!=A[id])continue;\n\t\tif(id+1==A.size())\n\t\t{\n\t\t\tstring ret=s[i].substr(min(d+A[id].size()+1,s[i].size()));\n\t\t\tif(ret.size()>0)return \"string \\\"\"+ret+\"\\\"\";\n\t\t\telse return \"object\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l=i+1;\n\t\t\tint r=l;\n\t\t\twhile(r<R&&cnt[r]>=cnt[l])r++;\n\t\t\treturn f(id+1,l,r,cnt[l]);\n\t\t}\n\t}\n\treturn\"no such property\";\n}\nmain()\n{\n\tstring t;\n\tgetline(cin,t);\n\tfor(int i=0;i<t.size();i++)\n\t{\n\t\tif(t[i]=='.')A.push_back(\"\");\n\t\telse A.back().push_back(t[i]);\n\t}\n\twhile(getline(cin,s[N++]));\n\tfor(int i=0;i<N;i++)\n\t{\n\t\twhile(s[i][cnt[i]]==' ')cnt[i]++;\n\t}\n\tcout<<f(0,0,N,0)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<string> YAML;\n\nstruct Node{\n    string key, value;\n    vector<Node> children;\n    Node(string k,string v){\n        key=k;\n        value=v;\n    }\n};\n\nint line = 0;\nNode mapping(int n,string key);\nNode mapping_item(int n);\n\nint count_indent(string &s){\n    int ret=0;\n    while(s[ret]==' ') ret++;\n    return ret;\n}\n\nNode mapping(int n,string key=\"\"){\n    Node node(key,\"\");\n    while(line<YAML.size()&&n==count_indent(YAML[line])){\n        node.children.push_back(mapping_item(n));\n    }\n    return node;\n}\n\nNode mapping_item(int n){\n    string S = YAML[line++];\n    string key;\n    int i;\n    for(i=n;i<S.size();i++){\n        if(S[i]==':'){\n            key=S.substr(n,i-n);\n            // cout<<\"key: \"<<node.key<<endl;\n            break;\n        }\n    }\n    i+=2;\n    if(i<S.size()){\n        // node.value=S.substr(i,S.size()-i);\n        // cout<<\"value: \"<<node.value<<endl;\n        return Node(key,S.substr(i,S.size()-i));\n    }else{\n        return mapping(count_indent(YAML[line]),key);\n    }\n}\nvoid dfs(Node &node, int dep=0){\n    cout<<string(dep,' ')+\"key: \"+node.key+\" value: \"+node.value+\" children: \"<<int(node.children.size())<<endl;\n    for(auto c:node.children){\n        dfs(c,dep+1);\n    }\n    return;\n}\n\nint main(){\n    string s;\n    getline(cin,s);\n    vector<string> keys;\n    for(int i=1;i<s.size();i++){\n        int j=i+1;\n        while(s[j]!='.'&&j<s.size())j++;\n        keys.push_back(s.substr(i,j-i));\n        i=j;\n    }\n    while(getline(cin,s)) YAML.push_back(s);\n    Node root = mapping(0);\n    // dfs(root);\n    Node *p = &root;\n    string property;\n    for(auto k:keys){\n        bool found = false;\n        for(auto &c:p->children){\n            if(c.key==k){\n                found=true;\n                if(c.value!=\"\"){\n                    property=\"string \\\"\"+c.value+\"\\\"\";\n                }else{\n                    property=\"object\";\n                }\n                p=&c;\n                break;\n            }\n        }\n        if(!found){\n            cout<<\"no such property\"<<endl;\n            return 0;\n        }\n    }\n    cout<<property<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nvector<string> parse_query(string s) {\n    for(int i = 0; i < (int)s.length(); ++i) if(s[i] == '.') s[i] = ' ';\n    istringstream iss(s);\n    vector<string> res;\n    for(string t; iss >> t; res.push_back(t)) ;\n    return res;\n}\n\nstring first_element(const string &s) {\n    istringstream iss(s);\n    string res;\n    iss >> res;\n    return res;\n}\n\nstring get_string_element(const string &s) {\n    istringstream iss(s);\n    string t;\n    iss >> t;\n\n    string res;\n    iss >> t;\n    res += t;\n    while(iss >> t) {\n        res.push_back(' ');\n        res += t;\n    }\n    return res;\n}\n\nint count_indent(const string &s) {\n    int i = 0;\n    while(i < (int)s.length() && s[i] == ' ') i++;\n    return i;\n}\n\nint main() {\n    string Q;\n    getline(cin, Q);\n    vector<string> YAML;\n    for(string s; getline(cin, s); YAML.push_back(s)) ;\n\n    vector<string> query = parse_query(Q);\n\n    string ans;\n    int prev_indent = -1;\n    for(int i = 0; i < (int)query.size(); i++) {\n        int begin = -1, end = -1;\n#if 0\n        for(int j = 0; j < (int)YAML.size(); j++) DEBUG(YAML[j]);\n#endif\n        for(int j = 0; j < (int)YAML.size(); j++) {\n#if 0\n            DEBUG(YAML[j]);\n            DEBUG(count_indent(YAML[j]));\n            DEBUG(first_element(YAML[j]));\n            DEBUG(query[i]);\n#endif\n            int ind = count_indent(YAML[j]);\n            if(ind > prev_indent && first_element(YAML[j]) == query[i] + \":\") {\n                begin = j;\n                for(end = j + 1; end < (int)YAML.size(); end++) {\n                    if(count_indent(YAML[end]) == ind) {\n                        break;\n                    }\n                }\n                prev_indent = ind;\n                break;\n            }\n        }\n#if 0\n        DEBUG(begin);\n        DEBUG(end);\n#endif\n        if(begin == -1 && end == -1) {\n            ans = \"no such property\";\n            break;\n        }\n        else {\n            vector<string> YAML2;\n            for(int j = begin; j < end; j++) {\n                YAML2.push_back(YAML[j]);\n            }\n            YAML = YAML2;\n        }\n    }\n    if(ans != \"\") {\n        cout << ans << endl;\n        exit(EXIT_SUCCESS);\n    }\n    if(YAML.size() > 1) {\n        cout << \"object\" << endl;\n    }\n    else {\n        cout << \"string \\\"\" << get_string_element(*YAML.begin()) << \"\\\"\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char deliter){\n  vector<string> res;\n  int prev_split_point = 0;\n  while(s[prev_split_point] == ' ')prev_split_point++;\n  for (int i = prev_split_point; i < s.length(); i++) {\n    while(s[i] == ' ')i++, prev_split_point++;\n    while(s[i] != deliter && i < s.length())i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nstring slove(vector<string> &query,\n             map<string, string> &hash,\n             string s,\n             int i){\n  string res;\n  if(hash.find(s) == hash.end()){\n    return \"no such property\";\n  }\n  if(i == query.size() - 1){\n    return \"string \\\"\" + hash[s] + \"\\\"\";\n  }else if(hash.find(s) != hash.end()){\n    res = slove(query, hash, query[i + 1], i + 1);\n  }else{\n    return \"object\";\n  }\n  return res;\n}\n\n\nint main(int argc, char *argv[]){\n  map<string, string> hash;\n  string s;\n  cin >> s;\n  vector<string> query = split(s, '.');\n  cin.ignore();\n  while(getline(cin, s)){\n    vector<string> vs = split(s, ':');\n    // for (int i = 0; i < vs.size(); i++) {\n    //   std::cout << vs[i] << std::endl;\n    // }\n    if(vs.size() > 1)hash[vs[0]] = vs[1];\n    else hash[vs[0]] = \"\";\n  }\n  string ans = slove(query, hash, query[0], 0);\n  if(ans == \"string \\\"\\\"\"){\n    std::cout << \"object\" << std::endl;\n  }else{\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\n\nclass Input{\n\tpublic:\n\tbool isObject;\n\tint space;\n\tstring key;\n\tstring data;\n\t\n\tInput(string str){\n\t\tint nspace = 0;\n\t\tfor(;;nspace++)if(str[nspace]!=' ')break;\n\t\t\n\t\tint colon = nspace;\n\t\tfor(;;colon++)if(str[colon-1]==':')break;\n\t\t\n\t\tint lspace =  colon+1;\n\t\t\n\t\tspace = nspace;\n\t\tkey = str.substr(nspace, colon-nspace-1);\n\t\t\n\t\tif(lspace+1 < str.size()){\n\t\t\tdata = str.substr(lspace, str.size()-lspace);\n\t\t\tisObject = false;\n\t\t}else{\n\t\t\tisObject = true;\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tcout<<\"sp = \"<<space<<\" key=\"<<key<<\" data=\"<<data<<endl;\n\t}\n};\n\n\nstring query;\nvector<Input> in;\n\n\nbool input(){\n\tgetline(cin, query);\n\twhile(!cin.eof()){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif(s==\"\")break;\n\t\tin.pb(Input(s));\n\t}\n\treturn true;\n}\n\nclass Data{\n\tpublic:\n\tbool isprop;\n\tstring prop;\n\tstring key;\n\tvector<Data> data;\n\t\n\tData(string key){\n\t\tisprop = false;\n\t\tthis->key = key;\n\t}\n\tData(string key, string prop){\n\t\tisprop = true;\n\t\tthis->key = key;\n\t\tthis->prop = prop;\n\t}\n\t\n\tvoid print(int index){\n\t\tstring space = \"\";\n\t\trep(i,index)space += ' ';\n\t\t\n\t\tcout<<space; puts(\"----------------------\");\n\t\tcout<<space; cout<<\"key    : '\"<<key<<\"'\"<<endl;\n\t\tcout<<space; cout<<\"isprop : \"<<isprop<<endl;\n\t\tcout<<space; cout<<\"prop   : '\"<<prop<<\"'\"<<endl;\n\t\trep(i,data.size()){\n\t\t\tdata[i].print(index+2);\n\t\t}\n\t}\n};\n\n\nData kaiseki(int st, int en){\n\t\n\t//printf(\"st=%d  en=%d\\n\",st,en);\n\tif(st+1==en){\n\t\treturn Data(in[st].key,  in[st].data);\n\t}\n\t\n\t\n\tData ret(in[st].key);\n\tint head = st+1;\n\tint stspace = in[st+1].space;\n\treps(i,st+2, en+1){\n\t\tif(i==en || in[i].space==stspace){\n\t\t\tret.data.pb(kaiseki(head, i));\n\t\t\thead = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstring calc(Data& data, string& q){\n\t\n\t\n\tif(q==\"\"){\n\t\tif(data.isprop){\n\t\t\tstringstream sst;\n\t\t\treturn \"string \\\"\"+data.prop+\"\\\"\";\n\t\t}\n\t\treturn \"object\";\n\t}\n\t\n\tint en = 1;\n\tfor(;en<q.size();en++){\n\t\tif(q[en]=='.')break;\n\t}\n\tstring key = q.substr(1, en-1);\n\tstring nq = q.substr(en, q.size()-(en));\n\t\n\t//cout<<\"q:\"<<q<<\"   nq:\"<<nq<<\"   key:\"<<key<<endl;\n\trep(i,data.data.size()){\n\t\tif(data.data[i].key==key){\n\t\t\treturn calc(data.data[i], nq);\n\t\t}\n\t}\n\t\n\treturn \"no such property\";\n}\n\n\nvoid solve(){\n\tData parent(\"parent\");\n\t\n\tint head = 0;\n\treps(i,1,in.size()+1){\n\t\tif(i==in.size() || in[i].space==0){\n\t\t\tparent.data.pb(kaiseki(head, i));\n\t\t\thead=i;\n\t\t}\n\t}\n\tstring ans = calc(parent, query);\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint tabnum(string &s){\n\tint ret = 0;\n\tfor(; ret<(int)s.length() && s[ret]==' '; ret++);\n\treturn ret;\n}\n\nint main(){\n\tstring match;\n\tgetline(cin, match);\n\tvector<string> stc(1, \"\");\n\tvector<int> tnum(1, -1);\n\tmap<string, string> ext;\n\tstring input;\n\twhile(getline(cin, input)){\n\t\tint intab = tabnum(input);\n\t\twhile(tnum.back() >= intab){\n\t\t\tstc.pop_back();\n\t\t\ttnum.pop_back();\n\t\t}\n\t\tstring tmp = input.substr(intab, input.length() -intab);\n\t\tif(input.back() == ':'){\n\t\t\ttmp.pop_back();\n\t\t\text[stc.back() +\".\" +tmp] = \"object\";\n\t\t\tstc.push_back(stc.back() +\".\" +tmp);\n\t\t\ttnum.push_back(intab);\n\t\t}else{\n\t\t\tint pos = 0;\n\t\t\twhile(tmp[pos] != ':') pos++;\n\t\t\text[stc.back() +\".\" +tmp.substr(0, pos)] = tmp.substr(pos+2, tmp.length()-pos-2);\n\t\t}\n\t}\n\t\n\tif(ext.count(match) == 0){\n\t\tcout << \"no such property\" << endl;\n\t}else if(ext[match] == \"object\"){\n\t\tcout << \"object\" << endl;\n\t}else{\n\t\tcout << \"string \\\"\" << ext[match] << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define var auto\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;}\n\nvector<string> s{};\n\nstring solve(vector<string> keys, int ind, int depth){\n    int indent = INT_MAX;\n    while (true){\n        if (ind >= s.size())\n            return \"no such property\";\n        for (int i = 0; i < indent; i++)\n            if (s[ind][i] != ' '){\n                if (indent == INT_MAX) {\n                    indent = i;\n                    continue;\n                }\n                return \"no such property\";\n            }\n        string key = \"\";\n        if (s[ind][indent] == ' ') {\n            ind++;\n            continue;\n        }\n        int beginInd;\n        for (int i = indent; i < s[ind].size(); i++){\n            if (s[ind][i] == ':') {\n                beginInd = i + 2;\n                break;\n            }\n            key += s[ind][i];\n        }\n        if (keys[0] != key) {\n            ind++;\n            continue;\n        }\n        if (beginInd >= s[ind].size()){\n            if (keys.size() == 1) return \"object\";\n            vector<string> newkeys{};\n            for (int i = 1; i < keys.size(); i++)\n                newkeys.push_back(keys[i]);\n            return solve(newkeys, ind + 1, depth + 1);\n        }\n        if (keys.size() >= 2)\n            return \"no such property\";\n        string res = \"string \\\"\";\n        for (int i = beginInd; i < s[ind].size(); i++)\n            res += s[ind][i];\n        res += \"\\\"\";\n        return res;\n    }\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    //cout << setprecision(15) << fixed;\n    string query;\n    getline(cin, query);\n    string t;\n    while (getline(cin, t)){\n        var copied = t;\n        s.push_back(copied);\n    }\n    vector<string> keys;\n\n    string current = \"\";\n    for (int i = 1; i < query.size(); i++){\n        if (query[i] == '.'){\n            keys.push_back(current);\n            current = \"\";\n        }\n        else current += query[i];\n    }\n    keys.push_back(current);\n\n    cout << solve(keys, 0, 0) << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nvector<string> parse_query(string s) {\n    for(int i = 0; i < (int)s.length(); i++) if(s[i] == '.') s[i] = ' ';\n    istringstream iss(s);\n    vector<string> res;\n    for(string t; iss >> t; res.push_back(t)) ;\n    return res;\n}\n\nint count_indent(const string &s) {\n    int i;\n    for(i = 0; s[i] == ' '; i++);\n    return i;\n}\n\nstring first_element(const string &s) {\n    istringstream iss(s);\n    string res;\n    iss >> res;\n    return res;\n}\n\nstring get_string_element(const string &s) {\n    istringstream iss(s);\n    string t;\n    iss >> t;\n    iss >> t;\n    string res = t;\n    while(iss >> t) {\n        res.push_back(' ');\n        res += t;\n    }\n    return res;\n}\n\nint main() {\n    string Q; getline(cin, Q);\n    vector<string> query = parse_query(Q);\n    vector<string> YAML;\n    for(string t; getline(cin, t); YAML.push_back(t)) ;\n\n    // for(int i = 0; i < (int)query.size(); i++) DEBUG(query[i]);\n\n    bool missing = false;\n    for(int i = 0; i < (int)query.size() - 1; i++) {\n        int begin = -1, end = -1;\n#if 0\n        for(int j = 0; j < (int)YAML.size(); j++) DEBUG(YAML[j]);\n#endif\n        for(int j = 0; j < (int)YAML.size(); j++) {\n            int ind = count_indent(YAML[0]);\n            string fst = first_element(YAML[j]);\n            if(count_indent(YAML[j]) == ind && fst == query[i] + \":\") {\n                begin = j + 1;\n                for(end = j + 2; end < (int)YAML.size() && count_indent(YAML[end]) > ind; end++);\n                break;\n            }\n        }\n        if(begin == -1 && end == -1) {\n            missing = true;\n            break;\n        }\n        else {\n            vector<string> YAML2;\n            for(int j = begin; j < end; j++) {\n                YAML2.push_back(YAML[j]);\n            }\n            YAML = YAML2;\n        }\n    }\n\n    if(missing == false) {\n        int begin = -1, end = -1;\n        for(int i = 0; i < (int)YAML.size(); i++) {\n            int ind = count_indent(YAML[0]);\n            string fst = first_element(YAML[i]);\n            if(count_indent(YAML[i]) == ind && fst == *query.rbegin() + \":\") {\n                begin = i;\n                for(end = i + 1; end < (int)YAML.size() && count_indent(YAML[end]) > ind; end++);\n                break;\n            }\n        }\n        if(begin == -1 && end == -1) {\n            missing = true;\n        }\n        else {\n            vector<string> YAML2;\n            for(int j = begin; j < end; j++) {\n                YAML2.push_back(YAML[j]);\n            }\n            YAML = YAML2;\n\n            if(YAML.size() > 1) {\n                cout << \"object\" << endl;\n            }\n            else {\n                cout << \"string \\\"\" << get_string_element(*YAML.begin()) << \"\\\"\" << endl;\n            }\n        }\n    }\n    if(missing) {\n        cout << \"no such property\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// keyの列をパース\nvector<string> get_keys() {\n    string S;\n    getline(cin, S);\n    vector<string> ret;\n    for (int i = 0; i < S.length(); ++i) {\n        if (S[i] == '.') {\n            ret.push_back(\"\");\n        } else {\n            ret.back().push_back(S[i]);\n        }\n    }\n    return ret;\n}\n\n// YAMLの各行の情報\nstruct Line {\n    int n;  // spaceの数\n    string key, body;\n};\nvector<Line> inputs;\n\n// YAMLをLineの形式にパースしてinputsへ\nvoid get_inputs() {\n    string S;\n    while (getline(cin, S)) {\n        Line line;\n        int itr = 0;\n\n        // スペースを数える\n        line.n = 0;\n        while (S[itr] == ' ') {\n            ++line.n;\n            ++itr;\n        }\n\n        // keyを抽出\n        while (S[itr] != ':') {\n            line.key.push_back(S[itr]);\n            ++itr;\n        }\n        itr += 2;  // :とspace\n\n        while (itr < S.length()) {\n            line.body.push_back(S[itr]);\n            ++itr;\n        }\n        inputs.push_back(line);\n    }\n}\n\n\nstruct Obj {\n    string key, body;\n    vector<Obj> ch;\n};\n\nvector<Obj> mapping(int, int&);\n\nObj mapping_item(int n, int& itr) {\n    Obj ret;\n    ret.key = inputs[itr].key;\n    ret.body = inputs[itr].body;\n    ++itr;\n    if (!ret.body.empty()) return ret;  // string\n\n    ret.ch = mapping(inputs[itr].n, itr);  // object\n    return ret;\n}\n\nvector<Obj> mapping(int n, int& itr) {\n    vector<Obj> ret;\n    while (itr < inputs.size() && inputs[itr].n == n) {\n        ret.push_back(mapping_item(n, itr));\n    }\n    return ret;\n}\n\nint main() {\n    vector<string> keys = get_keys();\n    get_inputs();\n\n    int itr = 0;\n    vector<Obj> res = mapping(0, itr);\n\n    string ans = \"\";\n    for (auto k : keys) {\n        bool found = false;\n        for (auto obj : res) {\n            if (obj.key == k) {\n                // 1つ下へ潜る\n                ans = obj.body;\n                res = obj.ch;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            cout << \"no such property\" << endl;\n            return 0;\n        }\n    }\n\n    cout << (ans.empty() ? \"object\" : \"string \\\"\" + ans + \"\\\"\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  string query; getline(cin, query);\n  vector<string> queryv;\n  int pos = 1;\n  while(pos < (int)(query.size())) {\n    string now = \"\";\n    while(query[pos] != '.' && pos < (int)(query.size())) {\n      now.push_back(query[pos]);\n      pos++;\n    }\n    queryv.push_back(now);\n    pos++;\n  }\n  string line;\n  vector<int> prev = {-1};\n  vector<string> now;\n  vector<vector<string>> v;\n  while(getline(cin, line)) {\n    int cnt = 0;\n    int pos = 0;\n    while(line[pos] == ' ') {\n      cnt++;\n      pos++;\n    }\n    if(cnt == prev.back()) {\n      prev.pop_back();\n      now.pop_back();\n    } else if(cnt < prev.back()) {\n      while(cnt != prev.back()) {\n        prev.pop_back();\n        now.pop_back();\n      }\n      prev.pop_back();\n      now.pop_back();\n    }\n    if(line.back() == ':') {\n      string key = line.substr(pos, (int)(line.size())-pos-1);\n      prev.push_back(cnt);\n      now.push_back(key);\n    } else {\n      int colonpos = 0;\n      while(line[colonpos] != ':') colonpos++;\n      string key = line.substr(pos, colonpos - pos);\n      string val = line.substr(colonpos+2, (int)(line.size())-colonpos-2);\n      prev.push_back(cnt);\n      now.push_back(key);\n      now.push_back(val);\n      v.push_back(now);\n      now.pop_back();\n    }\n  }\n  bool ok = false;\n  for(int i=0;i<(int)(v.size());++i) {\n    if((int)(queryv.size()) > (int)(v[i].size())-1) continue;\n    bool same = true;\n    for(int j=0;j<(int)(queryv.size());++j) {\n      same &= v[i][j] == queryv[j];\n    }\n    if(!same) continue;\n    ok = true;\n    if((int)(v[i].size()) - (int)(queryv.size())== 1) {\n      cout << \"string \\\"\" << v[i].back() << \"\\\"\" << endl;\n    } else {\n      cout << \"object\" << endl;\n    }\n    break;\n  }\n  if(!ok) cout << \"no such property\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2438&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nstring YAML[50010];\n\nvector<string> split(const string &s, char delim) {\n\tvector<string> elems;\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, delim)) {\n\t\tif (!item.empty()) {\n\t\t\telems.push_back(item);\n\t\t}\n\t}\n\treturn elems;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring k; cin >> k;\n\tauto key = split(k, '.');\n\tint key_cnt = key.size();\n\tcin.ignore();\n\tint cnt = 0;\n\twhile (getline(cin, YAML[cnt++]));\n\tcnt--;\n\tint pre_space = 0;\n\tint key_at = 0;\n\tbool next_flag = false;\n\tbool through = false;\n\tfor (int i = 0; i < cnt;i++) {\n\t\tauto yaml = split(YAML[i], ':');\n\t\tint space;\n\t\tfor (int l = 0; l < yaml[0].length(); l++) if (yaml[0][l] != ' ') { space = l; break; }\n\t\tif (!through & space < pre_space)break;\n\t\tif (through & (space != pre_space)) continue;\n\t\telse through = false;\n\n\t\tif (next_flag) { pre_space = space; next_flag = false; }\n\t\tif (yaml[0].substr(space) == key[key_at]) {\n\t\t\tkey_at++;\n\t\t\tif (key_at == key_cnt) {\n\t\t\t\tif (yaml.size() == 2) {\n\t\t\t\t\tyaml[1][0] = '\"';\n\t\t\t\t\tcout << \"string \" << yaml[1] << '\"' << endl; return 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"object\" << endl; return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (yaml.size() == 2)break;\n\t\t\t\telse {\n\t\t\t\t\tnext_flag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (yaml.size() == 1)through = true;\n\t\t\telse continue;\n\t\t}\n\t}\n\tcout << \"no such property\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (ll i = (ll)(a); i < (ll)(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ll long long\n#define lld long double\n#define ALL(x) x.begin(), x.end()\n#ifdef DEBUG\n#define line() cerr << \"[\" << __LINE__ << \"] \";\n#define dump(i) cerr << #i \": \" << i << \" \";\n#define dumpl(i) cerr << #i \": \" << i << endl;\n#else\n#define line(i)\n#define dump(i)\n#define dumpl(i)\n#endif\nusing namespace std;\n\nvoid initquery(string &s, vector<string> &q)\n{\n    string t = \"\";\n    rep(i, 1, s.size())\n    {\n        if (s[i] != '.')\n        {\n            t += s[i];\n        }\n        else\n        {\n            q.push_back(t);\n            t = \"\";\n        }\n    }\n    q.push_back(t);\n}\n\nint getindent(string &s)\n{\n    int ret = 0;\n    while (s[ret] == ' ')\n        ret++;\n    return ret;\n}\n\nbool strcmpwithindent(string &s, string &line, int indent)\n{\n    rep(i, s.size())\n    {\n        if (s[i] != line[indent + i])\n        {\n            return false;\n        }\n    }\n    return line[indent + s.size()] == ':';\n}\n\nstring property(string &s)\n{\n    int i;\n    //cerr << \"*\" << s << endl;\n    string t = \"\";\n    while (s[i] != ':')\n    {\n        i++;\n    }\n    i += 2;\n    for (; i < s.size(); i++)\n    {\n        t += s[i];\n    }\n    return t;\n}\n\nint main(int argc, char const *argv[])\n{\n    string s;\n    getline(cin, s);\n    vector<string> query;\n    initquery(s, query);\n    vector<string> yaml;\n    while (getline(cin, s))\n    {\n        yaml.push_back(s);\n        //cerr << s << endl;\n        //cin >> s;\n    }\n    //cerr << query[1] << endl;\n    //cerr << \"ok\" << endl;\n    int cur = 0;\n    int curindent = 0;\n    rep(i, yaml.size())\n    {\n        string line = yaml[i];\n        int thislinesindent = getindent(line);\n        if (thislinesindent < curindent)\n        {\n            cout << \"no such property\" << endl;\n            return 0;\n        }\n        if (thislinesindent != curindent)\n        {\n            continue;\n        }\n        if (strcmpwithindent(query[cur], line, curindent))\n        {\n            if (cur == query.size() - 1)\n            {\n                string ans = property(line);\n                if (ans == \"\")\n                {\n                    cout << \"object\" << endl;\n                    return 0;\n                }\n                else\n                {\n                    cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n                    return 0;\n                }\n            }\n            else\n            {\n                cur++;\n                string tmp = property(line);\n                if (tmp != \"\")\n                {\n                    cout << \"no such property\" << endl;\n                    return 0;\n                }\n                else\n                {\n                    curindent = getindent(yaml[i + 1]);\n                }\n            }\n        }\n    }\n    cout << \"no such property\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <sstream>\n\nusing namespace std;\n\nstring in[50000];\nint lineNum, lineMax;\n\nstruct object {\n  vector<string> key;\n  vector<string> property;\n  vector<object*> child;\n};\n\nobject* parse_yaml(int parentIndent = -1) {\n  object* obj = new object;\n\n  while( lineNum < lineMax ) {\n    int indent = 0;\n    for( ;isspace(in[lineNum][indent]); indent++ );\n\n    if( indent <= parentIndent ) break;\n    \n    int colon = in[lineNum].find(\":\");\n    string key = in[lineNum].substr(indent, colon-indent);\n    if( colon == in[lineNum].size()-1 ) {\n      // object\n      obj->key.push_back(key);\n      obj->property.push_back(\"\");\n      \n      lineNum ++;\n      // parse children\n      obj->child.push_back(parse_yaml(indent));\n    } else {\n      // has property\n      obj->key.push_back(key);\n      obj->property.push_back(in[lineNum].substr(colon+2));\n      obj->child.push_back(NULL); // NULLポインタを代入しないとセグフォ\n      \n      lineNum ++;\n    }\n  }\n  \n  return obj;\n}\n\nbool search( const object* root, const vector<string>vecQ, string& ans ) {\n  \n  // find object\n  for(unsigned i=0; i<vecQ.size()-1; i++) { // \"-1\" means object(not string)\n    bool ok = 0;\n    for(unsigned j=0; j<root->key.size(); j++) {\n      if(root->key[j] == vecQ[i]) {\n\tif(root->property[j] != \"\") break; // found same string key with query object\n\troot = root->child[j];\n\tok = 1;\n\tbreak;\n      }\n    }\n    if(!ok) return false;\n  }\n  \n  // find property\n  for(unsigned i=0; i<root->key.size(); i++) {\n      if(root->key[i]==vecQ.back()) {\n\n      if(root->key[i] == \"\") {\n\tans = \"object\";\n\treturn true;\n      } else {\n\tans = \"string \\\"\" + root->property[i] + \"\\\"\";\n\treturn true;\n      }\n    }\n  }\n  \n  return false;\n}\n\nvoid input_yaml() {\n  lineMax = 0;\n  for(int i=0; getline(cin, in[i]); i++, lineMax++);\n}\n\nint main() {\n  \n  string query;\n  getline(cin, query);\n  //replaceAll( query, \".\", \" \" );\n  for(unsigned i=0; i<query.size(); i++) if(query[i]=='.') query[i] = ' ';\n  stringstream ss( query );\n  vector<string> vecQuery;\n  while( ss >> query ) vecQuery.push_back( query );\n  \n  input_yaml();\n  \n  lineNum = 0;\n  object* yaml = parse_yaml();\n  \n  string ans;\n  if( search( yaml, vecQuery, ans ) ) {\n    cout << ans << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) begin(x), end(x)\n\nstring inp;\nstring::iterator it;\n\nstruct Rec;\n\nstruct Yaml {\n  int ind;\n  vector<Rec> rec;\n};\n\nstruct Rec {\n  string key;\n  string val;\n  Yaml ch;\n};\n\nchar nxt(char c) { return *it == c ? *it++ : 0; }\nchar nxt(bool (*p)(char)) { return p(*it) ? *it++ : 0; }\ntemplate <class P>\nstring proc(P p) {\n  string res;\n  for (char c; (c = nxt(p));) res.push_back(c);\n  return res;\n}\nbool key_c(char c) { return islower(c) or isdigit(c); }\nbool val_c(char c) { return islower(c) or isdigit(c) or c == ' '; }\nstring key() { return proc(key_c); }\nstring val() { return proc(val_c); }\nvoid indent() { while (nxt(' ')); }\nint indent_forward() {\n  auto it0 = it;\n  int cnt = 0;\n  while (nxt(' ')) cnt++;\n  it = it0;\n  return cnt;\n}\n\nYaml yaml(int);\n\nRec rec() {\n  Rec ret;\n  indent();\n  ret.key = key();\n  assert(nxt(':'));\n  if (nxt('\\n'))\n    ret.ch = yaml(indent_forward());\n  else\n    nxt(' '), ret.val = val(), nxt('\\n');\n  return ret;\n}\n\nYaml yaml(int n) {\n  Yaml ret;\n  ret.ind = n;\n  while (*it != '$' and indent_forward() == n) ret.rec.push_back(rec());\n  return ret;\n}\n\nvector<string> member() {\n  vector<string> ret;\n  while (nxt('.')) ret.push_back(key());\n  return ret;\n}\n\nint main() {\n  string query;\n  getline(cin, query); query.push_back('$');\n  string s;\n  while (getline(cin, s)) inp.insert(inp.end(), all(s)), inp.push_back('\\n');\n  inp += \"$\\n\";\n  it = inp.begin();\n\n  Yaml result = yaml(0);\n  Yaml *y = &result;\n  string val;\n  swap(inp, query); it = inp.begin();\n  for (auto k : member()) {\n    auto iter = find_if(all(y->rec), [&](const Rec& rec) { return rec.key == k; });\n    if (iter == y->rec.end()) {\n      cout << \"no such property\\n\";\n      return 0;\n    }\n    val = move(iter->val);\n    y = &iter->ch;\n  }\n  if (val.empty()) {\n    cout << \"object\\n\";\n  } else {\n    cout << \"string \\\"\" << val << \"\\\"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint main() {\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\tvector<pair<int, string>> cn;\n\tmap<string, string> obj;\n\tstring buf;\n\twhile (getline(cin, buf)) {\n\t\tint i = 0,j;\n\t\tfor (; buf[i] == ' '; i++);\n\t\tif (buf.back() == ':') {\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tcn.push_back(make_pair(i, ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(((string)\".\").append(buf.begin() + i, buf.end() - 1),\"*\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tcn.push_back(make_pair(i, cn.back().second + ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(cn.back().second + ((string)\".\").append(buf.begin() + i, buf.end() - 1),\"*\"));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (j = i; buf[j] != ':'; j++);\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tobj.insert(make_pair(((string)\".\").append(buf.begin() + i, buf.begin() +j), ((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tobj.insert(make_pair(cn.back().second + ((string)\".\").append(buf.begin() + i, buf.begin()+j),((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t}\n\t}\n\tauto res = obj[query];\n\tif (res.empty())res == \"no such property\";\n\telse if(res == \"*\")res = \"obj\";\n\telse res = \"string \\\"\" + res + \"\\\"\";\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<sstream>\nusing namespace std;\n\nstring s,t;\nvector<string> yaml;\nvector<string> keys;\nint n,l;\n\nstring parse(void){\n  if(l==yaml.size())return \"\";\n\n  int ind = 0;\n  while(yaml[l][ind] == ' ')ind++;\n  int c = yaml[l].find(\":\",ind);\n  string key = yaml[l].substr(ind,c-ind);\n  if(key == keys[n]){\n    if(n+1==keys.size()){\n      if(c+1==yaml[l].size())return \"A\";\n      return yaml[l].substr(c+2);\n    }\n    if(c+1==yaml[l].size()){ n++; l++; return parse(); }\n    return \"\";\n  }else{\n    while(++l<yaml.size()){\n      int ind2 = 0;\n      while(yaml[l][ind2] == ' ')ind2++;\n      if(ind==ind2)break;\n      if(ind>ind2)return \"\";\n    }\n    return parse();\n  }\n}     \n  \nint main(){\n  cin >> s;\n  for(int i=0;i<s.size();i++)if(s[i]=='.')s[i] = ' ';\n  stringstream ss(s);\n  while(ss >> s)keys.push_back(s);\n\n  cin.ignore();\n  while(getline(cin,t))yaml.push_back(t);\n  n = l = 0;\n  string res = parse();\n  if(res.empty())cout << \"no such property\\n\";\n  else if(res == \"A\")cout << \"object\\n\";\n  else cout << \"string \\\"\" << res << \"\\\"\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\npair<int, size_t> indent(const string& s, size_t i) {\n  int cnt = 0;\n  while (i < s.size() && s[i] == ' ') {\n    ++i; ++cnt;\n  }\n  return make_pair(cnt, i);\n}\n\npair<string, size_t> get_str(const string& s, size_t i) {\n  string res;\n  while (isalnum(s[i]) || s[i] == ' ') {\n    res += s[i];\n    ++i;\n  }\n  return make_pair(res, i);\n}\n\nstruct Item {\n  int depth;\n  string key;\n  int type;\n  string obj_str;\n  vector<Item> obj_map;\n};\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i);\n\npair<Item, size_t> mapping_item(const string& s, size_t i) {\n  int depth;\n  tie(depth, i) = indent(s, i);\n  string key;\n  tie(key, i) = get_str(s, i);\n  ++i;\n  if (s[i] == '\\n') { // mapping\n    vector<Item> mapping_child;\n    tie(mapping_child, i) = mapping(s, i+1);\n    return make_pair((Item){depth, key, 1, \"\", std::move(mapping_child)}, i);\n  } else { // string\n    string obj;\n    tie(obj, i) = get_str(s, i+1);\n    return make_pair((Item){depth, key, 0, obj, vector<Item>()}, i+1);\n  }\n}\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i) {\n  vector<Item> res;\n  Item front;\n  tie(front, i) = mapping_item(s, i);\n  res.push_back(front);\n  while(i < s.size()) {\n    Item next;\n    size_t next_i;\n    tie(next, next_i) = mapping_item(s, i);\n    if (next.depth != front.depth) break;\n    res.push_back(std::move(next));\n    i = next_i;\n  }\n  return make_pair(res, i);\n}\n\nstring query(const vector<Item>& obj, const string& s, size_t i) {\n  string key_name;\n  tie(key_name, i) = get_str(s, i+1);\n  for (auto& item : obj) {\n    if (item.key == key_name) {\n      if (item.type == 0) {\n        if (i == s.size()) {\n          return \"string \\\"\" + item.obj_str + \"\\\"\";\n        } else {\n          return \"no such property\";\n        }\n      } else {\n        if (i == s.size()) {\n          return \"object\";\n        } else {\n          return query(item.obj_map, s, i);\n        }\n      }\n    }\n  }\n  return \"no such property\";\n}\n\nint main() {\n  string q;\n  getline(cin, q);\n  string yaml;\n  string line;\n  while (getline(cin, line)) yaml += line + \"\\n\";\n  auto res = mapping(yaml, 0).first;\n  cout << query(res, q, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<string, string> P;\n\nstruct Node{\n  string obj_name, property;\n  int indent;\n  Node* pre;\n  vector<Node*> next;\n  Node():obj_name(\"\"),property(\"\"),indent(0),pre(NULL){}\n};\n\nvector<string> input(){\n  vector<string> res;\n  string s;\n  while(getline(cin,s)) res.push_back(s);\n  return res;\n}\n\nint indent(const string& s){\n  int cnt = 0;\n  for(int i = 0; i < (int)s.length(); i++)\n    if(s[i] == ' ') cnt++;\n    else break;\n  return cnt;\n}\n\nstring erase(const string& s, char c){\n  string res = \"\";\n  bool up = false;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] != c || up){\n      res += s[i];\n      up = true;\n    }\n  }\n  return res;\n}\n\nNode* top = new Node();\n\nP divide(const string& s){\n  int pos = 0;\n  while(s[pos] != ':' && pos < (int)s.length()) pos++;\n  return P(s.substr(0,pos), s.substr(pos+1));\n}\n\n\nstring find(const string& q){\n  Node* node = top;\n  string now = q;\n  if(q == \".\") return \"object\";\n\n  while(now != \"\"){\n    now = now.substr(1);\n    int pos = 0;\n    while(now[pos] != '.' && pos < (int)now.size()) pos++;\n    string pro = now.substr(0, pos);\n    Node* next = NULL;\n    \n    for(int i = 0; i < (int)node->next.size(); i++){\n      if(node->next[i]->obj_name == pro) next = node->next[i];\n    }\n\n    //  cout << \"now \" << node->obj_name << endl;\n    \n    if(next == NULL) return \"no such property\";\n    node = next;\n    now = now.substr(pos);\n  }\n\n  if(node->property != \"\") return \"string \\\"\" + node->property + \"\\\"\";\n  return \"object\";\n}\n\nvoid solve(const vector<string>& v, const string& q){\n\n  Node* now = top;\n  bool refresh = false;\n\n  for(int i = 0; i < (int)v.size(); i++){\n    if(refresh){\n      now->indent = indent(v[i]);\n      refresh = false;\n    }else{\n      int idt = indent(v[i]);\n      while(idt < now->indent) now = now->pre;\n    }\n\n    P p = divide(v[i]);\n\n    p.first = erase(p.first, ' ');\n    p.second = erase(p.second, ' ');\n\n    if(p.second == \"\"){\n      //object\n      Node* tmp = new Node();\n      tmp->obj_name = p.first;\n      tmp->pre = now;\n      now->next.push_back(tmp);\n      now = tmp;\n      refresh = true;\n    }else{\n      //cout << now->obj_name << \" \" << p.first << \" \" << p.second << endl;\n      Node* tmp = new Node();\n      tmp->obj_name = p.first;\n      tmp->property = p.second;\n      now->next.push_back(tmp);\n    }\n  }\n  cout << find(q) << endl;\n}\n\nvoid test(){\n\n  Node* tmp = top;\n  cout << \"name \" << tmp->obj_name << endl;\n  for(int i = 0; i < tmp->next.size(); i++){\n    cout << tmp->next[i]->obj_name << endl;\n  }\n  \n}\n\nint main(){\n  top->obj_name = \"top\";\n  string q;\n  getline(cin,q);\n  vector<string> in = input();\n  solve(in, q);\n  // test();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nusing S = string::iterator ;\n\nstruct yaml {\n    string type;\n    string value;\n    map<string, yaml> data;\n\n    yaml() {}\n    yaml(string t): type(t) {}\n};\n\nstring query;\nstring data;\nint line = 0;\n\nyaml parse_yaml (S& it, int indent) {\n    int actual = 0;\n    S bak = it;\n    for (; it != end(data) && actual < indent; ++it, ++actual)\n        if (*it != ' ') break;\n    if (it == end(data) || actual < indent){\n        it = bak;\n        return yaml(\"object\");\n    }\n\n    S key_begin = it;\n    while (*it != ':') ++it;\n    string key = string(key_begin, it);\n    ++it; // \":\"\n\n    yaml prop;\n    if (*it == '\\n') {\n        ++it; // '\\n'\n        int new_indent = 0;\n        S bk = it;\n        while (*bk == ' ') {\n            ++bk; ++new_indent;\n        }\n        assert(new_indent > indent);\n        prop = parse_yaml(it, new_indent);\n    } else {\n        ++it; // \" \"\n        S s_begin = it;\n        while (*it != '\\n') ++it;\n        prop = yaml(\"yvalue\");\n        prop.value = string(s_begin, it);\n        ++it; // '\\n'\n    }\n\n    yaml wanted = parse_yaml(it, indent);\n    wanted.data[key] = prop;\n    return wanted;\n}\n\nconst string OBJECT = \"object\";\nconst string NO_SUCH_PROPERTY = \"no such property\";\n\nstring solve() {\n    S ittt = data.begin();\n    yaml current = parse_yaml(ittt, 0);\n\n    S it = query.begin();\n    while (it != end(query)) {\n        ++it; // \".\"\n        if (current.type == \"yvalue\") return NO_SUCH_PROPERTY;\n        S p_begin = it;\n        while (it != end(query) && *it != '.') {\n            ++it;\n        }\n        string key(p_begin, it);\n        if (current.data.find(key) == end(current.data)) {\n            return NO_SUCH_PROPERTY;\n        }\n        yaml temp = current.data[key];\n        current = temp;\n    }\n    if (current.type == \"object\") {\n        return OBJECT;\n    }\n    return \"string \\\"\" + current.value + \"\\\"\";\n}\n\n\nint main() {\n    cin >> query;\n    string line; getline(cin, line);\n    while (getline(cin, line)) {\n        data += line + \"\\n\";\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char delimiter){\n  vector<string> res;\n  int prev_split_point = 0;\n  for (int i = 0; i < s.length(); i++) {\n    while(s[i] != delimiter && i < s.length())i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  string s;\n  cin >> s;\n  vector<string> key = split(s, '.');\n  vector<string> yaml;\n  cin.ignore();\n  int indent = 0, p = 0;\n  while(getline(cin, s))yaml.push_back(s);\n  for (int i = 0; i < key.size() && p < yaml.size(); i++) {\n    while(p < yaml.size() &&\n          key[i] != yaml[p].substr(indent, key[i].length())){\n      p++;\n    }\n    while(i < key.size() &&\n          p + 1 < yaml.size() && yaml[p + 1][indent] == ' ')indent++;\n    if(i < key.size() - 1 && p < yaml.size())p++;\n  }\n  int len = key[key.size() - 1].length()+ 2;\n  if(p == yaml.size()){\n    std::cout << \"no such property\" << std::endl;\n  }else if(yaml[p].length() <= indent + len){\n    std::cout << \"object\" << std::endl;\n  }else{\n    std::cout << \"string \\\"\" << yaml[p].substr(indent + len) << \"\\\"\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> key,str;\nstring t,s;\nint ind;\n\nvoid getkey(){\n  int x=0;\n  for(int i=1;i<t.size();i++)\n    if(!x&&t[i]!='.')x=i;\n    else if(t[i]=='.')\n      key.push_back(t.substr(x,i-x)),x=0;\n}\n\nvoid getstr(){\n  int f=0; ind=0;\n  string a;\n  for(int i=0;i<s.size();i++)\n    if(!f&&s[i]==' ')ind++;\n    else f=1;\n  for(int i=ind;i<s.size();i++){\n    if(s[i]!=' ')a+=s[i];\n    else{\n      if(a[a.size()-1]==':')str.push_back(a.substr(0,a.size()-1)),a=\"\";\n      else{\n\tstr.push_back(a+s.substr(i,s.size()-i));\n\ta=\"\";\n\tbreak;\n      }\n    }\n  }\n  if(a!=\"\"){\n    if(a[a.size()-1]!=':')str.push_back(a);\n    else str.push_back(a.substr(0,a.size()-1));\n  }\n}\n\nint main(){\n  cin>>t; t+='.';\n  getkey();\n  getline(cin,s);\n  int x=0,y=0,f=0;\n  while(getline(cin,s)){\n    str.clear();\n    getstr();\n    if(x<=ind&&y!=key.size()&&str[0]==key[y]){\n      x=ind;\n      y++;\n      if(y==key.size()){\n\tif(!f&&str.size()==2)cout<<\"string \\\"\"<<str[1]<<\"\\\"\"<<endl;\n\telse if(!f)cout<<\"object\"<<endl;\n\tf=1;\n      }\n    }\n  }\n  if(!f)cout<<\"no such property\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\n\nclass Input{\n\tpublic:\n\tbool isObject;\n\tint space;\n\tstring key;\n\tstring data;\n\t\n\tInput(string str){\n\t\tint nspace = 0;\n\t\tfor(;;nspace++)if(str[nspace]!=' ')break;\n\t\t\n\t\tint colon = nspace;\n\t\tfor(;;colon++)if(str[colon-1]==':')break;\n\t\t\n\t\tint lspace =  colon+1;\n\t\t\n\t\tspace = nspace;\n\t\tkey = str.substr(nspace, colon-nspace-1);\n\t\t\n\t\tif(lspace+1 < str.size()){\n\t\t\tdata = str.substr(lspace, str.size()-lspace);\n\t\t\tisObject = false;\n\t\t}else{\n\t\t\tisObject = true;\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tcout<<\"sp = \"<<space<<\" key=\"<<key<<\" data=\"<<data<<endl;\n\t}\n};\n\n\nstring query;\nvector<Input> in;\n\n\nbool input(){\n\tgetline(cin, query);\n\twhile(!cin.eof()){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tin.pb(Input(s));\n\t}\n\treturn true;\n}\n\nclass Data{\n\tpublic:\n\tbool isprop;\n\tstring prop;\n\tstring key;\n\tvector<Data> data;\n\t\n\tData(string key){\n\t\tisprop = false;\n\t\tthis->key = key;\n\t}\n\tData(string key, string prop){\n\t\tisprop = true;\n\t\tthis->key = key;\n\t\tthis->prop = prop;\n\t}\n\t\n\tvoid print(int index){\n\t\tstring space = \"\";\n\t\trep(i,index)space += ' ';\n\t\t\n\t\tcout<<space; puts(\"----------------------\");\n\t\tcout<<space; cout<<\"key    : '\"<<key<<\"'\"<<endl;\n\t\tcout<<space; cout<<\"isprop : \"<<isprop<<endl;\n\t\tcout<<space; cout<<\"prop   : '\"<<prop<<\"'\"<<endl;\n\t\trep(i,data.size()){\n\t\t\tdata[i].print(index+2);\n\t\t}\n\t}\n};\n\n\nData kaiseki(int st, int en){\n\t\n\t//printf(\"st=%d  en=%d\\n\",st,en);\n\tif(st+1==en){\n\t\treturn Data(in[st].key,  in[st].data);\n\t}\n\t\n\t\n\tData ret(in[st].key);\n\tint head = st+1;\n\tint stspace = in[st+1].space;\n\treps(i,st+2, en+1){\n\t\tif(i==en || in[i].space==stspace){\n\t\t\tret.data.pb(kaiseki(head, i));\n\t\t\thead = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstring calc(Data& data, string& q){\n\t\n\t\n\tif(q==\"\"){\n\t\tif(data.isprop){\n\t\t\tstringstream sst;\n\t\t\treturn \"string \\\"\"+data.prop+\"\\\"\";\n\t\t}\n\t\treturn \"object\";\n\t}\n\t\n\tint en = 1;\n\tfor(;en<q.size();en++){\n\t\tif(q[en]=='.')break;\n\t}\n\tstring key = q.substr(1, en-1);\n\tstring nq = q.substr(en, q.size()-(en));\n\t\n\t//cout<<\"q:\"<<q<<\"   nq:\"<<nq<<\"   key:\"<<key<<endl;\n\trep(i,data.data.size()){\n\t\tif(data.data[i].key==key){\n\t\t\treturn calc(data.data[i], nq);\n\t\t}\n\t}\n\t\n\treturn \"no such propery\";\n}\n\n\nvoid solve(){\n\tData parent(\"parent\");\n\t\n\tint head = 0;\n\treps(i,1,in.size()+1){\n\t\tif(i==in.size() || in[i].space==0){\n\t\t\tparent.data.pb(kaiseki(head, i));\n\t\t\thead=i;\n\t\t}\n\t}\n\tstring ans = calc(parent, query);\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstruct Obj {\n  bool isStr;\n  string str;\n  map<string, Obj*> pro;\n};\n\n\nvector<pair<int,string> > v;\nint pos;\n\nvoid make(Obj *obj) {\n  for(int i = 0, ppos; pos < v.size(); ++i) {\n    if(i && v[ppos].first != v[pos].first) break;\n    Obj *nobj = new Obj();\n    string &target = v[pos].second;\n    ppos = pos++;\n\n    int j;\n    for(j = 0; target[j] != ':'; ++j);\n    string key = target.substr(0,j);\n\n    if(j+1== target.size()) {\n      nobj->isStr = false;\n      make(nobj);\n    } else {\n      nobj->isStr = true;\n      nobj->str = target.substr(j+2);\n    }\n    obj->pro[key] = nobj;\n  }\n}\n\nint main() {\n  string p;\n  getline(cin, p);\n  string line;\n  while(getline(cin, line)) { \n    int sp = 0;\n    while(line[0] == ' ') {\n      ++sp;\n      line = line.substr(1);\n    }\n    v.push_back(make_pair(sp, line));\n  }\n\n  Obj *root = new Obj();\n  root->isStr = false;\n  pos = 0;\n  make(root);\n\n  vector<string> ps;\n  {\n    replace(p.begin(), p.end(), '.', ' ');\n    stringstream ss(p);\n    string s;\n    while(ss >> s) ps.push_back(s);\n  }\n\n  Obj *obj = root;\n  for(int i = 0; i < ps.size(); ++i) {\n    if(obj->pro.count(ps[i])) {\n      obj = obj->pro[ps[i]];\n    } else {\n      obj = 0;\n      break;\n    }\n  }\n  if(obj) {\n    if(obj->isStr) cout << \"string \\\"\" << obj->str << \"\\\"\" << endl;\n    else cout << \"object\" << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nint main() {\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\tvector<pair<int, string>> cn;\n\tmap<string, string> obj;\n\tstring buf;\n\twhile (getline(cin, buf)) {\n\t\tint i = 0,j;\n\t\tfor (; buf[i] == ' '; i++);\n\t\tif (buf.back() == ':') {\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tcn.push_back(make_pair(i, ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(((string)\".\").append(buf.begin() + i, buf.end() - 1),\"*\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tcn.push_back(make_pair(i, cn.back().second + ((string)\".\").append(buf.begin() + i, buf.end() - 1)));\n\t\t\t\tobj.insert(make_pair(cn.back().second + ((string)\".\").append(buf.begin() + i, buf.end() - 1),\"*\"));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (j = i; buf[j] != ':'; j++);\n\t\t\tif (i == 0) {\n\t\t\t\tcn.clear();\n\t\t\t\tobj.insert(make_pair(((string)\".\").append(buf.begin() + i, buf.begin() +j), ((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (cn.back().first >= i)cn.pop_back();\n\t\t\t\tobj.insert(make_pair(cn.back().second + ((string)\".\").append(buf.begin() + i, buf.begin()+j),((string)\"\").assign(buf.begin() + j+2, buf.end())));\n\t\t\t}\n\t\t}\n\t}\n\tauto res = obj[query];\n\tif (res.empty())res == \"no such property\";\n\telse if(res == \"*\")res = \"object\";\n\telse res = \"string \\\"\" + res + \"\\\"\";\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvector<string> get_keys(){\n  string key;\n  string tmp;  \n  vector<string> keys;\n  \n  getline(cin, key);\n  REP(i, key.size()) if(key[i] == '.') key[i] = ' ';\n  istringstream in(key);\n  while(in >> tmp) keys.push_back(tmp);\n  return keys;\n  \n}\n\nvector<string> get_yaml(){\n  string tmp;\n  vector<string> yaml;\n  while(getline(cin, tmp)){\n    REP(i, tmp.size()) if(tmp[i] == ':') tmp[i] = ' ';\n    yaml.push_back(tmp);\n  }\n  return yaml;\n}\n\n\nbool prefix(string s, string t){\n  return s.size() <= t.size() && t.substr(0, s.size()) == s;\n}\n\nint main(){\n\n  vector<string> keys = get_keys();\n  vector<string> yaml = get_yaml();\n\n  REP(i, keys.size()){\n    bool ok = false;\n\n    vector<string> yaml_keys;\n    vector<string> yaml_vals;\n    REP(j, yaml.size()){\n      string tmp;\n      string tmp_key;\n      string tmp_val;\n      istringstream in(yaml[j]);\n      in >> tmp_key;\n      for(int k = 0; in >> tmp; k++) tmp_val += (k > 0 ? \" \" : \"\") + tmp;\n      yaml_keys.push_back(tmp_key);    \n      yaml_vals.push_back(tmp_val);\n    }\n    \n    REP(j, yaml.size())if(!ok && yaml_keys[j] == keys[i]){\n      if(i + 1 == (int)keys.size()){\n        if(yaml_vals[j] == \"\"){\n          cout << \"object\" << endl;\n        }else{\n          cout << \"string \\\"\" + yaml_vals[j] << \"\\\"\" << endl;\n        }\n        return 0;\n      }\n      if(j + 1 == (int)yaml.size()) goto no_such_property;\n      int wcount = 0;\n      vector<string> next;\n      \n      while(yaml[j+1][wcount] == ' ') wcount++;\n      while(++j < (int)yaml.size() && prefix(string(wcount, ' '), yaml[j])){\n        next.push_back(yaml[j].substr(wcount));\n      }\n      \n      yaml = next;\n      ok = true;\n    }\n    \n    if(!ok) goto no_such_property;\n  }\n no_such_property:\n  cout << \"no such property\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstruct Obj {\n  bool isStr;\n  string str;\n  map<string, Obj*> pro;\n};\n\nstring p;\nvector<pair<int,string> > v;\nint pos;\n\nvoid make(Obj *obj) {\n  for(int i = 0; pos < v.size(); ++i) {\n    if(i && v[pos-1].first != v[pos].first) break;\n    Obj *nobj = new Obj();\n    string &target = v[pos].second;\n    ++pos;\n    int j;\n    for(j = 0; target[j] != ':'; ++j);\n\n    string key = target.substr(0,j);\n\n    if(j+1 == target.size()) {\n      nobj->isStr = false;\n      make(nobj);\n    } else {\n      nobj->isStr = true;\n      nobj->str = target.substr(j+2);\n    }\n    obj->pro[key] = nobj;\n  }\n}\n\nint main() {\n  getline(cin, p);\n  string line;\n  while(getline(cin, line)) { \n    int sp = 0;\n    while(line[0] == ' ') {\n      ++sp;\n      line = line.substr(1);\n    }\n    v.push_back(make_pair(sp, line));\n  }\n\n  Obj *root = new Obj();\n  root->isStr = false;\n  make(root);\n\n  vector<string> ps;\n  {\n    replace(p.begin(), p.end(), '.', ' ');\n    stringstream ss(p);\n    while(!ss.eof()) {\n      string s;\n      ss >> s;\n      ps.push_back(s);\n    }\n  }\n\n  Obj *obj = root;\n  for(int i = 0; i < ps.size(); ++i) {\n    if(obj->pro.count(ps[i])) {\n      obj = obj->pro[ps[i]];\n    } else {\n      obj = 0;\n      break;\n    }\n  }\n  if(obj) {\n    if(obj->isStr) cout << \"string \\\"\" << obj->str << \"\\\"\" << endl;\n    else cout << \"object\" << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\nusing namespace std;\n\nchar buf[5010];\n\nint main(){\n\tstring s;\n\tgetline(cin, s);\n\tconst char *ptr = s.c_str();\n\t\n\tvector<string> key;\n\tint d = 0;\n\twhile( sscanf(ptr, \".%[^.]%n\", buf, &d) > 0 ){\n\t\tptr += d;\n\t\tkey.push_back(buf);\n\t}\n\t\n\tint m = 0;\n\tint prev = -1;\n\tint indent = -1;\n\tint k = 0;\n\twhile(true){\n\t\tbuf[0] = '\\0';\n\n\t\tgetline(cin, s);\n\t\tif( s.size() < 2 ) break;\n\n\t\tptr = s.c_str();\n\t\tif( sscanf(ptr, \" %n%[^:]:%n\", &indent, buf, &d) < 1 ) break;\n\n\t\tif( indent <= prev ) break;\n\t\t\n\t\tif( m == -1 ) m = indent;\n\t\t\n\t\tif( m == indent && key[k] == buf ){\n\t\t\tm = -1;\n\t\t\tprev = indent;\n\t\t\t\n\t\t\tif( ++k == key.size() ){\n\t\t\t\tif( s[d] == ' ' ){\n\t\t\t\t\tcout << \"string \\\"\" << s.substr(d + 1) << \"\\\"\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << \"object\\n\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << \"no such property\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint idx;\nstring s;\nstring yaml[100009];\nstruct tree{\n    map<string,tree*>child;\n    int is;\n    string name,val;\n};\nvoid make_tree(tree *root,int id,int &ln){\n    while( ln < idx ){\n        int cnt=0;\n        string nm=\"\";\n        tree *next = new tree();\n        string st =  yaml[ln];\n        while(st[cnt]==' ')cnt++;\n        if(cnt<=id)return;\n        int cur=cnt;\n        while(st[cur]!=':')nm+=st[cur++];\n        cur++;ln++;\n        next->name=nm;\n        if(cur==st.size())make_tree(next,cnt,ln);\n        else{\n            next->is=1;\n            next->val=st.substr(cur+1);\n        }\n        root->child[nm]=next;\n    }\n}\nstring sol(){\n    tree *root=new tree();\n    int ln=0,cur=0;\n    make_tree(root,-1,ln);\n    while( cur < s.size() ){\n        string obj=\"\";\n        cur++;\n        while(cur<s.size() && s[cur]!='.')obj+=s[cur++];\n        if(root->child.count(obj)==0)return \"no such property\";\n        root = root->child[obj];\n    }\n    if(root->is)return \"string \\\"\"+root->val+\"\\\"\";\n    return \"object\";\n}\nint main(){\n    getline(cin,s);\n    while(getline(cin,yaml[idx]))idx++;\n    cout<<sol()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  string q;\n  getline(cin, q);\n  vector<string> key;\n  for (char c : q){\n    if (c == '.'){\n      key.push_back(\"\");\n    } else {\n      key.back().push_back(c);\n    }\n  }\n  int M = key.size();\n  vector<string> yaml;\n  while (1){\n    string S;\n    getline(cin, S);\n    if (S == \"\"){\n      break;\n    }\n    yaml.push_back(S);\n  }\n  int N = yaml.size();\n  vector<int> space(N, 0);\n  for (int i = 0; i < N; i++){\n    while (yaml[i][space[i]] == ' '){\n      space[i]++;\n    }\n  }\n  vector<int> p(N, N);\n  for (int i = 0; i < N; i++){\n    if (space[i] > 0){\n      p[i] = i;\n      while (space[p[i]] >= space[i]){\n        p[i]--;\n      }\n    }\n  }\n  vector<vector<int>> c(N + 1);\n  for (int i = 0; i < N; i++){\n    c[p[i]].push_back(i);\n  }\n  int r = N;\n  bool ok = true;\n  for (int i = 0; i < M; i++){\n    int r2 = -1;\n    for (int j : c[r]){\n      string S;\n      for (char c : yaml[j]){\n        if (c == ':'){\n          break;\n        }\n        if (c != ' '){\n          S += c;\n        }\n      }\n      if (S == key[i]){\n        r2 = j;\n      }\n    }\n    if (r2 == -1){\n      ok = false;\n      break;\n    } else {\n      r = r2;\n    }\n  }\n  if (!ok){\n    cout << \"no such property\" << endl;\n  } else if (yaml[r].back() == ':'){\n    cout << \"object\" << endl;\n  } else {\n    int sz = yaml[r].size();\n    string ans;\n    for (int i = 0; i < sz; i++){\n      if (yaml[r][i] == ':'){\n        ans = yaml[r].substr(i + 2);\n        break;\n      }\n    }\n    cout << \"string \" << '\"' << ans << '\"' << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  getline(cin, s);\n\n  vector<string> key;\n  string t = \"\";\n  int n = 0;\n  FOR(i, 1, s.size()) {\n    if(s[i] == '.') {\n      key.PB(t);\n      t = \"\";\n      n++;\n    } else {\n      t += s[i];\n    }\n  }\n  n++;\n  key.PB(t);\n  // cout << key << endl;\n\n  string ans = \"no such property\";\n  bool able = true;\n  int idx = 0, prev = 0, depth = 0;\n  while(getline(cin, t)) {\n    if(!able) continue;\n    int indent = 0;\n    string prop = \"\", str = \"\";\n    int flag = 0;\n    REP(i, t.size()) {\n      if(flag == 0 && t[i] != ' ') flag = 1;\n      if(flag == 1 && t[i] == ':') {flag = 2; i++; continue;}\n      if(flag == 0) indent++;\n      if(flag == 1) prop += t[i];\n      if(flag == 2) str += t[i];\n      // cout << \"i:\" << i << \" \" << prop << \" \" << str << endl;\n    }\n\n    if(prev < indent) depth++;\n    else if(prev > indent) {\n      depth--;\n      if(depth < idx) {\n        able = false;\n      }\n    }\n\n    // cout << idx << \" \" << indent << \" \" << depth << endl;\n    if(idx < depth || !able) {prev = indent; continue;}\n\n    if(idx == depth && idx < n && prop == key[idx]) {\n      idx++;\n      if(idx == n) {\n        // cout << \"goal\" << endl;\n        if(str == \"\") ans = \"object\";\n        else ans = \"string \\\"\" + str + \"\\\"\";\n        // break;\n      }\n    }\n    // cout << idx << \" \" << indent << \" \" << prop << \" \" << str << endl;\n    prev = indent;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass yaml {\npublic:\n    yaml() : name_(\"invalid\")\n    {}\n    yaml(string const& n) : name_(n)\n    {}\n\n    yaml get(string const& key) {\n        if(child.count(key) == 0) {\n            throw std::runtime_error(\"no such property\");\n        }\n        return child[key];\n    }\n\n    void add(string const& key, yaml y) {\n        child[key] = move(y);\n    }\n\n    string name() const {\n        return name_;\n    }\n\nprivate:\n    string name_;\n    map<string, yaml> child;\n};\n\n\nyaml create_impl(vector<string> const& v, string name, int& l) {\n    const int L = v.size();\n    yaml res(name);\n    int indent = 0;\n    while(v[l][indent] == ' ') {\n        indent++;\n    }\n    while(l < L) {\n        int indent2 = 0;\n        while(v[l][indent2] == ' ') {\n            indent2++;\n        }\n        if(indent2 < indent) {\n            break;\n        }\n        if(indent2 == indent) {\n            int col = v[l].find(':');\n            if(col == v[l].size()-1) {\n                string key = v[l].substr(indent2);\n                key.pop_back();\n                res.add(key, create_impl(v, \"object\", ++l));\n            } else {\n                string key = v[l].substr(indent2, col-indent2);\n                string name = v[l].substr(col+2);\n                res.add(key, yaml{name});\n                ++l;\n            }\n        }\n    }\n    return res;\n}\n\nyaml create(vector<string> const& v) {\n    int l = 0;\n    return create_impl(v, \"object\", l);\n}\n\nstring proc(yaml y, string const& query) {\n    int p = 1;\n    while(p < query.size()) {\n        int np = query.find('.', p);\n        string key;\n        if(np == string::npos) {\n            key = query.substr(p);\n            p = query.size();\n        } else {\n            key = query.substr(p, np-p);\n            p = np + 1;\n        }\n        y = y.get(key);\n    }\n    return y.name();\n}\n\nint main() {\n    string query;\n    getline(cin, query);\n    vector<string> v;\n    string line;\n    while(getline(cin, line)) {\n        v.push_back(line);\n    }\n    yaml y = create(v);\n    try {\n        string res = proc(y, query);\n        if(res == \"object\") {\n            cout << res << endl;\n        } else {\n            cout << \"string \\\"\" << res << \"\\\"\" << endl;\n        }\n    } catch(std::exception& ex) {\n        cout << ex.what() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<string, string> P;\n\nvector<string> prop;\n\nint count(string& str){\n  int cnt = 0;\n  for(int i=0;i<str.size();i++){\n    if(str[i] == ' ') cnt++;\n    else break;\n  }\n  return cnt;\n}\n\npair<string, string> parse(string& str){\n  for(int i=0;i<str.size();i++){\n    if(str[i] == ':'){\n      if(i+2 >= str.size()) return P(str.substr(0, i), \"\");\n      else return P(str.substr(0, i), str.substr(i+2));\n    }\n  }\n}\n\nstring solve(){\n  string input;\n  int pre = 0;\n  int pos = 0;\n  while(getline(cin, input)){\n    CONT:;\n    int cnt = count(input);\n    if(cnt != pre) continue;\n    input = input.substr(cnt);\n    P val = parse(input);\n    if(val.first == prop[pos]){\n      if(pos+1 == prop.size()){\n        if(val.second == \"\") return \"object\";\n        else return \"string \\\"\" + val.second + \"\\\"\";\n      }else{\n        pos++;\n        getline(cin, input);\n        int cnt = count(input);\n        if(cnt <= pre) goto END;\n        else{\n          pre = cnt;\n          goto CONT;\n        }\n      }\n    }\n  }\n  END:;\n  return \"no such property\";\n}\n\nmain(){\n  string input;\n  getline(cin, input);\n  prop.clear();\n  int pre = 0;\n  for(int i=1;;i++){\n    if(i >= input.size()){\n      prop.push_back(input.substr(pre+1));\n      break;\n    }\n    if(input[i] == '.'){\n      prop.push_back(input.substr(pre+1, i-pre-1));\n      pre = i;\n    }\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define all(a) (a).begin(),(a).end()\n\nvector<string> split(string s, char c) {\n    vector<string> vs;\n    string tmp = \"\";\n    rep(i, s.size()) {\n        if (s[i] == c) {\n            vs.emplace_back(tmp);\n            tmp = \"\";\n        } else {\n            tmp += s[i];\n        }\n    }\n    if (!tmp.empty()) vs.emplace_back(tmp);\n    return vs;\n}\n\nint countSpace(string s) {\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            return i;\n        }\n    }\n}\n\ntuple<int, string, string> parseLine(string s) {\n    int num_sp;\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            num_sp = i;\n            break;\n        }\n    }\n    auto vs = split(s.substr(num_sp), ':');\n    string key = vs[0], value = vs[1].empty() ? \"\" : vs[1].substr(1);\n    return make_tuple(num_sp, key, value);\n}\n\nvoid answer(string value) {\n    if (value.empty()) {\n        cout << \"object\" << endl;\n    } else {\n        cout << \"string \\\"\" << value << \"\\\"\" << endl;\n    }\n}\n\nint main() {\n    string s;\n    getline(cin, s);\n    vector<string> keys = split(s, '.');\n    queue<string> que;\n    rep2(i, 1, keys.size()) {\n        que.push(keys[i]);\n    }\n    int indent = 0;\n    while (getline(cin, s)) {\n        int num_sp;\n        string key, value;\n        tie(num_sp, key, value) = parseLine(s);\n        if (num_sp < indent) break;\n        if (key == que.front()) {\n            que.pop();\n            if (que.empty()) {\n                answer(value);\n                return 0;\n            }\n        }\n    }\n    cout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n//    REP(i, SZ(mp)) {\n//        if (i) os << \", \";\n//        os << mp[i];\n//    }\n    for (auto e : mp) {\n        os << e << \", \";\n    }\n    return os << \"]\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\nusing State = string::const_iterator;\n\n//map<string, map<string, string>> tree; // first :\nvector<map<string, int>> tree;\n\nint indent(string s) {\n    int ret = 0;\n    while (s[ret] == ' ') {\n        ret++;\n    }\n    return ret;\n}\n\nbool key_only(string s) {\n    auto it = s.begin();\n    while (*it == ' ') it++;\n    while (*it != ':') {\n        it++;\n    }\n    it++;\n    return it == s.end();\n}\n\nstring get_key(string s) {\n    auto it = s.begin();\n    while (*it == ' ') it++;\n    string key;\n    while (*it != ':') {\n        key += *it;\n        it++;\n    }\n    return key;\n}\n\npair<string, string> get_kv(string s) {\n    auto it = s.begin();\n    while (*it == ' ') it++;\n    string key;\n    string val;\n    while (*it != ':') {\n        key += *it;\n        it++;\n    }\n    it++; // ':'\n    it++; // ' '\n\n    while (it != s.end()) {\n        val += *it;\n        it++;\n    }\n\n    return make_pair(key, val);\n}\n\nvector<string> split(string s, char c = '.') {\n    auto it = s.begin();\n    it++;\n    vector<string> ret(1);\n    while (it != s.end()) {\n        if (*it != '.') {\n            ret.back().push_back(*it);\n        } else {\n            ret.emplace_back(\"\");\n        }\n        it++;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    string query;\n    getline(cin, query);\n    string yaml;\n    string buf;\n\n    tree.resize(1);\n//    int level = 0;\n//    int idx = 0;\n    stack<pair<int, int>> st;\n    st.push(make_pair(-1, 0)); // level, idx\n\n\n    while (getline(cin, buf)) {\n\n//        int pre_level = st.top();\n        int cur_level = indent(buf);\n\n        while (cur_level <= st.top().first) {\n            st.pop();\n        }\n\n        int idx = st.top().second;\n\n//        st.push(make_pair(cur_level, idx));\n\n//        st.push(cur_level);\n\n        if (!key_only(buf)) {\n            string key, val;\n            tie(key, val) = get_kv(buf);\n\n            int next = SZ(tree);\n            tree.push_back(map<string, int>());\n            tree[idx][key] = next;\n            tree[next][val] = -1;\n\n        } else {\n            int next = SZ(tree);\n            tree.push_back(map<string, int>());\n            string key = get_key(buf);\n            tree[idx][key] = next;\n            idx = next;\n\n//            st.pop();\n            st.push(make_pair(cur_level, idx));\n        }\n\n    }\n\n//    cerr << tree << endl;\n\n//    cout << split(query) << endl;\n    vector<string> queries = split(query);\n\n    int idx = 0;\n    for (auto q : queries) {\n        if (idx == -1 || !tree[idx].count(q)) {\n            // not such property\n\n            cout << \"no such property\" << endl;\n            return;\n        }\n        idx = tree[idx][q];\n    }\n\n    if (idx == -1) {\n        cout << \"no such property\" << endl;\n        return;\n    }\n\n    if (tree[idx].size() == 1 && tree[idx].begin()->second == -1) {\n        cout << \"string \\\"\" << tree[idx].begin()->first << '\\\"' << endl;\n    } else {\n        cout << \"object\" << endl;\n    }\n\n\n\n//    cout << yaml << endl;\n//    cout << tree << endl;\n\n\n}\n//void mapping(int n, State &state);\n//void mapping_item(int n, State &state);\n//string key(State &state);\n//string str(State &state);\n//string indent(int n, State &state);\n//\n//\n//void mapping(int n, State &state) {\n//\n//}\n//\n//void mapping_item(int n, State &state) {\n//\n//}\n//\n//string key(State &state) {\n//\n//}\n//\n//string str(State &state) {\n//\n//}\n//\n//string indent(int n, State &state) {\n//\n//}\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"/Users/homesentinel/CLionProjects/CP_14/input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst int64_t LINF=8931145141919364364,LMOD=998244353;\n// const int dy[]={0,-1,0,1,1,-1,-1,1};\n// const int dx[]={1,0,-1,0,1,1,-1,-1};\n\nint main() {\n\tstring keys; cin >> keys;\n\tkeys = keys.substr(1);\n\tkeys += \".\";\n\tvector<string> key;\n\tstring tmp;\n\tfor(char c : keys) {\n\t\tif(c == '.') {\n\t\t\tkey.push_back(tmp);\n\t\t\ttmp = \"\";\n\t\t} else {\n\t\t\ttmp += c;\n\t\t}\n\t}\n\t// for(string s : key) cerr << s << endl;\n\tint indent = -1;\n\tint idx = 0;\n\tstring ans;\n\twhile(getline(cin, tmp)) {\n\t\tif(idx >= (int)key.size()) continue;\n\t\ttry {\n\t\t\tint ide = 0;\n\t\t\tfor(char c : tmp) {\n\t\t\t\tif(c == ' ') {\n\t\t\t\t\tide++;\n\t\t\t\t} else {\n\t\t\t\t\tif(ide <= indent) {\n\t\t\t\t\t\tthrow \"INDENT FALSE\";\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring tag;\n\t\t\tfor(int i = ide; i < (int)tmp.size(); ++i) {\n\t\t\t\tif(tmp[i] == ':') break;\n\t\t\t\ttag += tmp[i];\n\t\t\t}\n\t\t\tif(key[idx] == tag and tag != \"\") {\n\t\t\t\tindent = ide;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tcatch(const char* s) {\n\t\t\t// fprintf(stderr, \"%s\\n\", s);\n\t\t\tcontinue;\n\t\t}\n\t\tif(idx == (int)key.size()) {\n\t\t\tbool flg = 0;\n\t\t\tfor(int i = 0; i < (int)tmp.size(); ++i) {\n\t\t\t\tif(flg) {\n\t\t\t\t\tans += tmp[i];\n\t\t\t\t}\n\t\t\t\tif(tmp[i] == ':') {\n\t\t\t\t\ti++;\n\t\t\t\t\tflg = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans != \"\") {\n\t\t\t\tcout << \"string \\\"\" << ans << \"\\\"\" << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"object\" << endl;\n\t\t\t\tans = \"!\";\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tif(ans == \"\") {\n\t\tcout << \"no such property\" << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50001\n\nclass YAML{\npublic:\n  string s,t;\n  int state;\n  vector<string> next;\n};\n\nclass Line{\npublic:\n  string s;\n  int space;\n};\n\nvector<Line> line;\nYAML yaml[MAX];\n\nint getState(int idx,vector<string> &v){\n  string now = line[idx].s.substr(line[idx].space);\n  string s,t;\n  int x = -1;\n  for(int i = 0 ; i < (int)now.size() ; i++){\n    if(now[i] == ':'){ x = line[idx].space+i+2; break; }\n    s += now[i];\n  }\n  v.push_back(s);\n  if(x < (int)line[idx].s.size()){\n    t = line[idx].s.substr(x);\n    v.push_back(t);\n    return 1;\n  }\n  return 0;\n}\n\nvector<string> make_graph(int cur,int sp){\n  int len = line.size();\n  vector<string> res;\n  if(cur == len){ return res; }\n  int now = cur;\n  while(true){\n    if(now == len || sp > line[now].space){ break; }\n    if(sp == line[now].space){\n      res.push_back(yaml[now].s);\n    }else{\n      yaml[cur].next = make_graph(now,line[now].space);\n    }\n    now++;\n  }\n  return res;\n}\n\nint main(){\n  int idx = 1;\n  string order,in;\n  map<string,int> mp;\n  line.push_back((Line){\"->\",0});\n  cin >> order; cin.ignore();\n  while(getline(cin,in)){\n    int cnt = 0;\n    for(int i = 0 ; i < (int)in.size() ; i++){\n      if(in[i] == ' '){\n        cnt++;\n      }else{ break; }\n    }\n    line.push_back((Line){in,cnt});\n    vector<string> v;\n    yaml[idx].state = getState(idx,v);\n    yaml[idx].s = v[0];\n    if(yaml[idx].state == 1){\n      yaml[idx].t = v[1];\n    }\n    mp[yaml[idx].s] = idx;\n    idx++;\n  }\n  yaml[0].s = \"->\";\n  yaml[0].next = make_graph(1,line[1].space);\n  string t;\n  vector<string> strs;\n  for(int i = 0 ; i < (int)order.size() ; i++){\n    if(order[i] == '.'){\n      if(!t.empty()){ strs.push_back(t); }\n      t.clear();\n    }else{\n      t += order[i];\n    }\n  }\n  strs.push_back(t);\n  int now = 0,len = strs.size();\n  bool found = true;\n  for(int i = 0 ; i < len ; i++){\n    vector<string> vec = yaml[now].next;\n    now = mp[strs[i]];\n    if(yaml[now].s == \"->\"){\n      found = false;\n      break;\n    }\n  }\n  if(!found){\n    cout << \"no such property\" << endl;;\n  }else{\n    if(yaml[now].state == 0){\n      cout << \"object\" << endl;;\n    }else{\n      cout << \"string \\\"\" << yaml[now].t << \"\\\"\" << endl;;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tvs query, yaml;\n\tstring buf;\n\tgetline(cin, buf);\n\tint t = 1;\n\tFOR(i, 1, buf.size())\n\t{\n\t\tif (buf[i] == '.')\n\t\t{\n\t\t\tquery.push_back(buf.substr(t, i - t));\n\t\t\tt = i + 1;\n\t\t}\n\t}\n\tquery.push_back(buf.substr(t));\n\twhile (getline(cin, buf)) yaml.push_back(buf);\n\tint n = yaml.size();\n\tvi cntsp(n);\n\tREP(i, n)\n\t{\n\t\tREP(j, yaml[i].size())\n\t\t{\n\t\t\tif (yaml[i][j] != ' ')\n\t\t\t{\n\t\t\t\tcntsp[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tyaml[i].erase(0, cntsp[i]);\n\t}\n\n\n\tint top = -1, sp = 0;\n\tbool f = true;\n\tREP(i, query.size())\n\t{\n\t\tstring tar = query[i];\n\t\tFOR(j, top+1, yaml.size())\n\t\t{\n\t\t\tif (cntsp[j] < sp)\n\t\t\t{\n\t\t\t\tputs(\"no such property\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (cntsp[j] > sp) continue;\n\t\t\tif (yaml[j].substr(0, tar.size()) == tar)\n\t\t\t{\n\t\t\t\tif (i == query.size() - 1)\n\t\t\t\t{\n\t\t\t\t\tif (yaml[j].size() == tar.size() + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"object\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << \"string \\\"\" << yaml[j].substr(tar.size() + 2) << \"\\\"\" << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (j == yaml.size() - 1 || cntsp[j+1] <= cntsp[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tputs(\"no such property\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ttop = j;\n\t\t\t\t\tsp = cntsp[j + 1];\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tputs(\"no such property\");\n\t\t\treturn 0;\n\t\t}\n\t\tf = true;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct object{\n  string name;\n  int size;\n  object *desc[50010];\n  string attr;\n  object(){}\n  object(string s){\n    name = s;\n  }\n  object(string s, string t){\n    name = s;\n    attr = t;\n  }\n};\n\nobject* get(object* base, string query){\n  query += \".\";\n  int bf = 1;\n  for(int i = 1; i < query.size(); i++)if(query[i] == '.'){\n    string pro = query.substr(bf, i - bf);\n    //cout<<\"search: \"<<pro<<\"(\"<<pro.size()<<\")\"<<endl;\n    bf = i + 1;\n    bool f = false;\n    for(int j = 0; j < base->size; j++){\n      //cout<<\"compare: \"<<base->desc[j]->name<<endl;\n      if(base->desc[j]->name == pro){\n        //cout<<\"equal!!\"<<endl;\n        base = base->desc[j];\n        f = true;\n        break;\n      }\n    }\n    if(!f) return NULL;\n  }\n  return base;\n}\n\nint main(){\n  string query;\n  while(getline(cin, query)){\n    object base(\"yaml\");\n    string input;\n    object* lev_obj[50010];\n    lev_obj[0] = &base;\n    while(getline(cin, input)){\n      int lev = 0;\n      while(lev < input.size() && input[lev] == ' ') lev++;\n      lev ++;\n      input = input.substr(lev - 1);\n      //cout<<\"input: \"<<input<<endl;\n      //cout<<\"lev: \"<<lev<<endl;\n      object* current;\n      //\n      if(input[input.size() - 1] == ':'){\n        string name = input.substr(0, input.size() - 1);\n        //cout<<\"name: \"<<name<<endl;\n        current = new object(name);\n      }else{\n        REP(i, input.size()) if(input[i] == ':'){\n          string name = input.substr(0, i);\n          string attr = input.substr(i + 2);\n          //cout<<\"name: \"<<name<<endl;\n          //cout<<\"attr: \"<<attr<<endl;\n          current = new object(name, attr);\n          break;\n        }\n      }\n      //cout<<\"lev_obj[\"<<lev<<\"]\"<<\" is replaced\"<<endl;\n      lev_obj[lev] = current;\n      for(int l = lev + 1; l < 10000; l++) lev_obj[l] = NULL;\n      for(int l = lev - 1; l >= 0; l--){\n        if(lev_obj[l]){\n          lev_obj[l]->desc[lev_obj[l]->size++] = current;\n          //cout<<\"insert to \"<<lev_obj[l]->name<<\"(lev:\"<<l<<\")\"<<endl;\n          break;\n        }\n      }\n      //cout<<endl;\n    }\n    object* ans = get(lev_obj[0], query);\n    if(ans){\n      if(ans->attr == \"\"){\n        cout<<\"object\"<<endl;\n      }else{\n        cout<<\"string \\\"\"<<ans->attr<<\"\\\"\"<<endl;\n      }\n    }else{\n      cout<<\"no such property\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct dat{\n\tstring value;\n\tmap<string, dat> p;\n};\n\ndat mapping(){\n\tstring s;\n\tdat res;\n\twhile (getline(cin, s)){\n\t\tint idx = s.find(':');\n\t\tstring t = s.substr(idx+1);\n\t\tdat d;\n\t\tif (t.size()) d.value = t;\n\t\telse d = mapping();\n\n\t\tres.p[s.substr(0, idx)] = d;\n\t}\n\treturn res;\n}\n\nint main(){\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\n\tdat d = mapping();\n\n\tfor (auto &c : query) if (c == '.') c = ' ';\n\n\tstringstream ss(query);\n\tstring s;\n\tdat *p = &d;\n\twhile (ss >> s){\n\t\tif (!p->p.count(s)) goto NG;\n\t\tp = &(p->p[s]);\n\t}\n\n\tif (p->value.empty()) cout << \"object\" << endl;\n\telse cout << \"string \\\"\" << p->value << \"\\\"\" << endl;\n\n\treturn 0;\nNG:\n\tcout << \"no such property\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "hoge"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\nusing namespace std;\n\nstruct Obj {\n  bool isStr;\n  string str;\n  map<string, Obj*> pro;\n};\n\nstring p;\nvector<pair<int,string> > v;\nint pos;\n\nvoid make(Obj *obj) {\n  for(int i = 0; pos < v.size(); ++i) {\n    if(i && v[pos-1].first != v[pos].first) break;\n    Obj *nobj = new Obj();\n    string &target = v[pos].second;\n    ++pos;\n\n    int j;\n    for(j = 0; target[j] != ':'; ++j);\n    string key = target.substr(0,j);\n\n    if(j+1 == target.size()) {\n      nobj->isStr = false;\n      make(nobj);\n    } else {\n      nobj->isStr = true;\n      nobj->str = target.substr(j+2);\n    }\n    obj->pro[key] = nobj;\n  }\n}\n\nint main() {\n  getline(cin, p);\n  string line;\n  while(getline(cin, line)) { \n    int sp = 0;\n    while(line[0] == ' ') {\n      ++sp;\n      line = line.substr(1);\n    }\n    v.push_back(make_pair(sp, line));\n  }\n\n  Obj *root = new Obj();\n  root->isStr = false;\n  pos = 0;\n  make(root);\n\n  vector<string> ps;\n  {\n    replace(p.begin(), p.end(), '.', ' ');\n    stringstream ss(p);\n    string s;\n    while(ss >> s) ps.push_back(s);\n  }\n\n  Obj *obj = root;\n  for(int i = 0; i < ps.size(); ++i) {\n    if(obj->pro.count(ps[i])) {\n      obj = obj->pro[ps[i]];\n    } else {\n      obj = 0;\n      break;\n    }\n  }\n  if(obj) {\n    if(obj->isStr) cout << \"string \\\"\" << obj->str << \"\\\"\" << endl;\n    else cout << \"object\" << endl;\n  } else {\n    cout << \"no such property\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <cctype>\n#include <sstream>\nusing namespace std;\ntypedef string::const_iterator State;\nint len;\nstring inpro;\nstring in[50000];\nstring str;\nvector<string> property;\n\nvoid split(const string &str,char delim){\n\tistringstream iss(str);\n\tstring tmp;\n\tgetline(iss,tmp,delim);\n\twhile(getline(iss,tmp,delim))property.push_back(tmp);\n\tlen=property.size();\n}\n\nstring func(State &begin,int depth,int indent){\n\tif(begin==str.end())return \"no such property\";\n\tint cnt=0;\n\twhile(*begin==' '){\n\t\tbegin++;\n\t\tcnt++;\n\t}\n\tif(indent==-1)indent=cnt;\n\telse if(indent!=cnt){\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(cnt<indent || begin!=str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n\tstring key=\"\";\n\twhile(*begin!=':'){\n\t\tkey+=*begin;\n\t\tbegin++;\n\t}\n\tbegin++;\n\tif(key==property[depth]){\n\t\tif(depth==len-1){\n\t\t\tif(*begin=='\\n')return \"object\";\n\t\t\telse{\n\t\t\t\tstring res=\"\";\n\t\t\t\tbegin++;\n\t\t\t\twhile(*begin!='\\n'){\n\t\t\t\t\tres+=*begin;\n\t\t\t\t\tbegin++;\n\t\t\t\t}\n\t\t\t\tstring ans=\"string \";\n\t\t\t\tans+='\"';\n\t\t\t\tans+=res;\n\t\t\t\tans+='\"';\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}else{\n\t\t\tif(*begin=='\\n'){\n\t\t\t\treturn func(++begin,++depth,-1);\n\t\t\t}else return \"no such property\";\n\t\t}\n\t}else{\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(begin==str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n}\n\nint main(void){\n\tgetline(cin,inpro);\n\tsplit(inpro,'.');\n\tint cnt=0;\n\twhile(getline(cin,in[cnt]))cnt++;\n\tfor(int i=0;i<cnt;i++){\n\t\tstr+=in[i];\n\t\tstr+='\\n';\n\t}\n\tState begin=str.begin();\n\tcout << func(begin,0,-1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<string>sts;\nvector<int>indnums;\nint a = 0;\nstruct yaml {\n\tbool is_dir;\n\tmap<string, yaml>mp;\n\tstring prop;\n\tvoid operator =(const yaml yaml_) {\n\t\tis_dir = yaml_.is_dir;\n\t\tmp = yaml_.mp;\n\t\tprop = yaml_.prop;\n\t}\n};\nyaml getmap(const int ind);\npair<string,yaml> getmapitem(const int ind) {\n\tyaml ayaml;\n\t\n\tconst int n = sts[a].find(':');\n\tstring key = sts[a].substr(indnums[a], n-indnums[a]);\n\tif (n == sts[a].size()-1) {\n\t\tayaml.is_dir = true;\n\t\ta++;\n\t\tayaml = getmap(indnums[a]);\n\t}\n\telse {\n\t\tayaml.is_dir = false;\n\t\tstring name = sts[a].substr(n + 2);\n\t\tayaml.prop = name;\n\t}\n\treturn make_pair(key,ayaml);\n}\nyaml getmap(const int ind) {\n\tyaml ayaml;\n\tayaml.is_dir = true;\n\tayaml.mp.emplace(getmapitem(ind));\n\twhile (1) {\n\t\ta++;\n\t\tif (a >= sts.size() || indnums[a] != ind)break;\n\t\tayaml.mp.emplace(getmapitem(ind));\n\t}\n\treturn ayaml;\n}\n\nint main() {\n\tstring st; cin >> st;\n\tint now = 1;\n\tvector<string>keys;\n\twhile (1) {\n\t\tint n = st.find('.',now);\n\t\tif (n == string::npos) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tkeys.emplace_back(st.substr(now, n-now));\n\t\t}\n\t\tnow = n+1;\n\t}\n\tkeys.emplace_back(st.substr(now));\n\tstring ast;\n\tgetline(cin, ast);\n\twhile (getline(cin,ast)) {\n\t\tint n = ast.find_first_not_of(' ');\n\t\tsts.push_back(ast);\n\t\tindnums.emplace_back(n);\n\t}\n\tyaml y=getmap(0);\n\tint anstype=0;\n\tstring ans;\n\tyaml nyaml = y;\n\t\n\tfor (int i = 0; i < keys.size(); ++i) {\n\t\tauto it = nyaml.mp.find(keys[i]);\n\t\tif (it == nyaml.mp.end()) {\n\t\t\tanstype = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tnyaml = it->second;\n\t\t}\n\t}\n\tif (anstype == -1) {\n\t\tcout << \"no such property\" << endl;\n\t}\n\telse {\n\t\tif (nyaml.is_dir) {\n\t\t\tcout << \"object\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"string \\\"\" << nyaml.prop << \"\\\"\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }  \n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  string keys;\n  getline(cin,keys);\n\n  string str;\n  vector<string> vs;\n  while(getline(cin,str))\n    vs.emplace_back(\" \"+str);\n\n  vs.emplace(vs.begin(),\"base:\");\n  \n  Int n=vs.size();\n  vector<Int> ind(n,0);\n  for(Int i=0;i<n;i++)\n    while(vs[i][ind[i]]==' ') ind[i]++;\n\n  vector< map<string, Int> > pos(n);\n  vector<string> val(n);\n  \n  MFP([&](auto dfs,Int i,Int p)->Int{\n        // cout<<i<<\" \"<<p<<endl;\n        \n        string key;\n        Int j=ind[i];\n        while(vs[i][j]!=':') key+=vs[i][j++];        \n        if(~p) pos[p][key]=i;\n        \n        j++;        \n        val[i]=vs[i].substr(j);\n\n        Int res=i+1;\n        if(!val[i].empty()) return res;\n        \n        do{       \n          res=dfs(res,i);\n        }while(res<n&&ind[i]<ind[res]);\n\n        return res;\n      })(0,-1);\n  \n  Int cur=0;\n  for(Int i=0;i<(Int)keys.size();i++){\n    if(keys[i]!='.') continue;\n    string nxt;\n    Int j=i+1;\n    while(j<(Int)keys.size()&&keys[j]!='.')\n      nxt+=keys[j++];\n\n    if(!pos[cur].count(nxt)){\n      cout<<\"no such property\"<<endl;\n      return 0;\n    }\n    \n    cur=pos[cur][nxt];    \n  }\n  \n  if(val[cur].empty()) cout<<\"object\"<<endl;\n  else cout<<\"string \\\"\"<<val[cur].substr(1)<<\"\\\"\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nstring prop[32];\n\nint main()\n{\n    rep(i,32) prop[i] = \"\";\n    string in;\n    cin >> in;\n    int sz = 0;\n    rep(i,in.size()){\n\tif(in[i] == '.') sz++;\n\telse prop[sz-1] += in[i];\n    }\n    int pos = 0;\n    int depth = 0;\n    int prev = 0;\n    bool flag = false;\n    cin.ignore();\n    while(getline(cin,in)){\n\tif(in.size() == 0) break;\n\tint cur = 0;\n\twhile(in[cur] == ' ') cur++;\n\n\tstring tag = \"\", str = \"\";\n\tint t = cur;\n\twhile(in[t] != ':') tag += in[t++];\n\tt += 2;\n\twhile(t < in.size()) str += in[t++];\n\n\tif(cur > prev) depth++;\n\tif(cur < prev) depth--;\n\tif(depth < pos){\n\t    pos--;\n\t}\n\tif(depth == pos && prop[pos] == tag){\n\t    pos++;\n\t    if(pos == sz){\n\t\tif(str.size() == 0) cout << \"object\\n\";\n\t\telse cout << \"string \\\"\" << str << \"\\\"\\n\";\n\t\treturn 0;\n\t    }\n\t}\n\tprev = cur;\n    }\n    cout << \"no such property\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nstring key;\nint pos;\n\nbool check(string a,string b){\n  int ima=pos,i=0,j=0;\n   while(a[i]==' ')i++;\n  //while(b[i]==' ')j++;\n  if(i<j) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  string par;\n  while(pos<(int)key.size()){\n    idx=0;\n    while(idx<(int)str.size()&&!check(str[idx],par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=str[idx];\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50001\n#define INF 1e9\n\nclass YAML{\npublic:\n  string s;\n  int state;\n  vector<string> next;\n};\n\nvector<int> space;\nYAML yaml[MAX];\n\nint getState(string &str,int d,vector<string> &v){\n  string now = str.substr(d);\n  string s,t;\n  int x = -1;\n  for(int i = 0 ; i < (int)now.size() ; i++){\n    if(now[i] == ':'){ x = d+i+2; break; }\n    s += now[i];\n  }\n  v.push_back(s);\n  if(x < (int)str.size()){\n    t = str.substr(x);\n    v.push_back(t);\n    return 1;\n  }\n  return 0;\n}\n\nvector<string> make_graph(int cur,int sp){\n  int len = space.size();\n  vector<string> res;\n  if(cur == len || yaml[cur].state == 1){ return res; }\n  int now = cur;\n  while(true){\n    if(now == len || sp > space[now]){ break; }\n    if(space[now] == INF){ now++; continue; }\n    if(sp == space[now]){\n      res.push_back(yaml[now].s);\n      cur = now;\n    }else if(sp < space[now]){\n      if(yaml[cur].next.size() == 0){\n        yaml[cur].next = make_graph(now,space[now]);\n      }\n    }\n    now++;\n  }\n  return res;\n}\n\nint main(){\n  int idx = 1;\n  string order,in;\n  map<string,int> mp;\n  space.push_back(-1);\n  yaml[0].s = \"->\";\n  cin >> order; cin.ignore();\n  while(getline(cin,in)){\n    int cnt = 0;\n    for(int i = 0 ; i < (int)in.size() ; i++){\n      if(in[i] == ' '){\n        cnt++;\n      }else{ break; }\n    }\n    space.push_back(cnt);\n    vector<string> v;\n    yaml[idx].state = getState(in,cnt,v);\n    yaml[idx].s = v[0];\n    mp[yaml[idx].s] = idx;\n    if(yaml[idx].state == 1){\n      yaml[idx].state = 0;\n      yaml[idx].next.push_back(v[1]);\n      idx++;\n      yaml[idx].s = v[1];\n      yaml[idx].state = 1;\n      mp[yaml[idx].s] = idx;\n      space.push_back(INF);\n    }\n    idx++;\n  }\n  yaml[0].next = make_graph(1,space[1]);\n  string t;\n  vector<string> strs;\n  for(int i = 0 ; i < (int)order.size() ; i++){\n    if(order[i] == '.'){\n      if(!t.empty()){ strs.push_back(t); }\n      t.clear();\n    }else{\n      t += order[i];\n    }\n  }\n  strs.push_back(t);\n  int now = 0,len = strs.size();\n  bool found = true;\n  for(int i = 0 ; i < len ; i++){\n    vector<string> vec = yaml[now].next;\n    bool ok = false;\n    for(int j = 0 ; j < (int)vec.size() ; j++){\n      if(vec[j] == strs[i]){\n        ok = true;\n        break;\n      }\n    }\n    now = mp[strs[i]];\n    if(!ok){\n      found = false;\n      break;\n    }\n  }\n  int size = yaml[now].next.size();\n  if(!found || size == 0){\n    cout << \"no such property\" << endl;\n  }else{\n    if(size != 1){\n      cout << \"object\" << endl;\n    }else{\n      string ans = yaml[now].next[0];\n      if(yaml[mp[ans]].state == 1){\n        cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n      }else{\n        cout << \"object\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nusing S = string::iterator ;\n\nstruct yaml {\n    string type;\n    string value;\n    map<string, yaml> data;\n\n    yaml() {}\n    yaml(string t): type(t) {}\n};\n\nstring query;\nstring data;\nint line = 0;\n\nyaml parse_yaml (S& it, int indent) {\n    int actual = 0;\n    for (; it != end(data) && actual < indent; ++it, ++actual)\n        if (*it != ' ') break;\n    if (it == end(data) || actual < indent) return yaml(\"object\");\n\n    S key_begin = it;\n    while (*it != ':') ++it;\n    string key = string(key_begin, it);\n    ++it; // \":\"\n\n    yaml prop;\n    if (*it == '\\n') {\n        ++it; // '\\n'\n        int new_indent = 0;\n        S bk = it;\n        while (*bk == ' ') {\n            ++bk; ++new_indent;\n        }\n        assert(new_indent > indent);\n        prop = parse_yaml(it, new_indent);\n    } else {\n        ++it; // \" \"\n        S s_begin = it;\n        while (*it != '\\n') ++it;\n        prop = yaml(\"yvalue\");\n        prop.value = string(s_begin, it);\n        ++it; // '\\n'\n    }\n\n    yaml wanted = parse_yaml(it, indent);\n    wanted.data[key] = prop;\n    return wanted;\n}\n\nconst string OBJECT = \"object\";\nconst string NO_SUCH_PROPERTY = \"no such property\";\n\nstring solve() {\n    S ittt = data.begin();\n    yaml current = parse_yaml(ittt, 0);\n\n    S it = query.begin();\n    while (it != end(query)) {\n        ++it; // \".\"\n        if (current.type == \"yvalue\") return NO_SUCH_PROPERTY;\n        S p_begin = it;\n        while (it != end(query) && *it != '.') {\n            ++it;\n        }\n        string key(p_begin, it);\n        if (current.data.find(key) == end(current.data)) {\n            return NO_SUCH_PROPERTY;\n        }\n        yaml temp = current.data[key];\n        current = temp;\n    }\n    if (current.type == \"object\") {\n        return OBJECT;\n    }\n    return \"string \\\"\" + current.value + \"\\\"\";\n}\n\n\nint main() {\n    cin >> query;\n    string line; getline(cin, line);\n    while (getline(cin, line)) {\n        data += line + \"\\n\";\n    }\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i,a,b) for(ll i=(a);i<(b);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\ntypedef string::const_iterator State;\n\nint space(State &beg){\n    int ret = 0;\n    while(*beg==' '){\n        ret++;\n        beg++;\n    }\n    return ret;\n}\n\n\nstring str(State &beg){\n    string ret = \"\";\n    while( *beg!=':' && *beg!=';' ){\n        assert( isdigit(*beg) || 'a'<=*beg && *beg<='z' || *beg==' ' );\n        ret+=*beg;\n        beg++;\n    }\n    return ret;\n}\n\n\nvoid eval(State &beg, int &ind, string &key, string &val){\n    val = \"*\";\n    bool colon = false;\n    if(*beg==' ')ind = space(beg);\n    if(colon==false){\n        key = str(beg);\n        assert(*beg==':');\n        colon = true;\n        beg++;\n        \n        if(*beg==';')return ;\n        \n        assert(*beg==' ');\n        beg++;\n        \n        \n        \n    }\n    val = str(beg);\n    assert(*beg==';');\n    beg++;\n}\n\nint main(){\n    string s;\n    cin>>s;\n    cin.ignore();\n    \n    vector<string> vs;\n    string t;\n    while(getline(cin,t))vs.pb(t);\n    \n    map<vector<string>,string> mp;\n    vector<string> obj;\n    vector<int> indent;\n    for(auto str: vs){\n        str+=\";\";\n        State beg = str.begin();\n        int ind;\n        string key,val;\n        eval(beg,ind,key,val);\n        \n        \n        while( indent.size() && indent[indent.size()-1]>ind ){\n            obj.pop_back();\n            indent.pop_back();\n        }\n        \n        if(val==\"*\"){\n            obj.push_back(key);\n            indent.push_back(ind);\n            mp[obj] = \"*obj\";\n        }else{\n            obj.push_back(key);\n            \n            mp[obj] = val;\n            \n            obj.pop_back();\n        }\n    }\n    \n    vector<string> query;\n    s+='.';\n    string buf = \"\";\n    rep(i,s.size()){\n        if( s[i]=='.' ){\n            if(buf.size()==0)continue;\n            query.pb(buf);\n            buf = \"\";\n        }else{\n            buf+=s[i];\n        }\n    }\n    \n    if( mp.count(query)==0 )cout<<\"no such property\"<<endl;\n    else if(mp[query]==\"*obj\")cout<<\"object\"<<endl;\n    else cout<<\"string \\\"\"<<mp[query]<<\"\\\"\"<<endl;\n}\n\n\n//indent[ indent.size()-1 ] != the indent -> pop_back\n//hoge:\\n -> obj & indent push(hoge,ind)\n//map<obj+key> = string"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char delimiter){\n  vector<string> res;\n  int prev_split_point = 0;\n  for (int i = 0; i < s.length(); i++) {\n    while(s[i] != delimiter && i < s.length())i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  string s;\n  cin >> s;\n  vector<string> key = split(s, '.');\n  vector<string> yaml;\n  cin.ignore();\n  int indent = 0, p = 0;\n  while(getline(cin, s))yaml.push_back(s);\n  for (int i = 0; i < key.size() && p < yaml.size(); i++) {\n    while(p < yaml.size() &&\n          key[i] != yaml[p].substr(indent, key[i].length())){\n      p++;\n    }\n    while(p + 1 < yaml.size() && yaml[p + 1][indent] == ' ')indent++;\n    if(i < key.size() - 1 && p < yaml.size())p++;\n  }\n  int len = key[key.size() - 1].length()+ 2;\n  if(p == yaml.size()){\n    std::cout << \"no such property\" << std::endl;\n  }else if(yaml[p].length() <= indent + len){\n    std::cout << \"object\" << std::endl;\n  }else{\n    std::cout << \"string \\\"\" << yaml[p].substr(indent + len) << \"\\\"\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <cctype>\n#include <sstream>\nusing namespace std;\ntypedef string::const_iterator State;\nint len;\nstring inpro;\nstring in[50000];\nstring str;\nvector<string> property;\n\nvoid split(const string &str,char delim){\n\tistringstream iss(str);\n\tstring tmp;\n\tgetline(iss,tmp,delim);\n\twhile(getline(iss,tmp,delim))property.push_back(tmp);\n\tlen=property.size();\n}\n\nstring func(State &begin,int depth,int indent){\n\tif(begin==str.end())return \"no such property\";\n\tint cnt=0;\n\twhile(*begin==' '){\n\t\tbegin++;\n\t\tcnt++;\n\t}\n\tif(indent==-1)indent=cnt;\n\telse if(indent!=cnt){\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(cnt<indent || begin==str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n\tstring key=\"\";\n\twhile(*begin!=':'){\n\t\tkey+=*begin;\n\t\tbegin++;\n\t}\n\tbegin++;\n\tif(key==property[depth]){\n\t\tif(depth==len-1){\n\t\t\tif(*begin=='\\n')return \"object\";\n\t\t\telse{\n\t\t\t\tstring res=\"\";\n\t\t\t\tbegin++;\n\t\t\t\twhile(*begin!='\\n'){\n\t\t\t\t\tres+=*begin;\n\t\t\t\t\tbegin++;\n\t\t\t\t}\n\t\t\t\tstring ans=\"string \";\n\t\t\t\tans+='\"';\n\t\t\t\tans+=res;\n\t\t\t\tans+='\"';\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}else{\n\t\t\tif(*begin=='\\n'){\n\t\t\t\treturn func(++begin,++depth,-1);\n\t\t\t}else return \"no such property\";\n\t\t}\n\t}else{\n\t\twhile(*begin!='\\n' && begin!=str.end())begin++;\n\t\tif(begin==str.end())return \"no such property\";\n\t\treturn func(++begin,depth,indent);\n\t}\n}\n\nint main(void){\n\tgetline(cin,inpro);\n\tsplit(inpro,'.');\n\tint cnt=0;\n\twhile(getline(cin,in[cnt]))cnt++;\n\tfor(int i=0;i<cnt;i++){\n\t\tstr+=in[i];\n\t\tstr+='\\n';\n\t}\n\tState begin=str.begin();\n\tcout << func(begin,0,-1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nstring key;\nint pos;\n\nbool check(string a,string b){\n  int ima=pos,i=0,j=0;\n   while(a[i]==' ')i++;\n  while(b[i]==' ')j++;\n  if(pos!=1&&i<=j) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  string par;\n  while(pos<(int)key.size()){\n    // idx=0;\n    while(idx<(int)str.size()&&!check(str[idx],par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=str[idx];\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct obj{\n  bool isobj;\n  string name;\n  string value;\n  vector<obj*> ob;\n  obj* par;\n};\n  \nint main(){\n  string query;\n  vector<string> yaml;\n  string buf;\n  for(int i=0;getline(cin,buf);i++){\n    if(i==0){\n      query=buf;\n    }\n    else{\n      yaml.push_back(buf);\n    }\n  }\n  \n\n\n  obj* base=new obj();\n  base->isobj=true;\n  base->name=\"#####\";\n  base->par=nullptr;\n  int depth=0;\n  obj* now=base;\n  vector<int> indent(1,0);\n  for(int i=0;i<yaml.size();i++){\n    //cout<<i<<endl;\n    int tabcnt=0;\n    int p=0;\n    while(yaml[i][p]==' '){\n      tabcnt++;\n      p++;\n    }\n\n    for(int j=0;j<depth;j++){\n      if(indent[j]==tabcnt){\n\tfor(int k=0;k<depth-j;k++){\n\t  now=now->par;\n\t}\n\tdepth=j;\n\tbreak;\n      }\n    }\n    if(indent.size()<=depth){\n      indent.push_back(tabcnt);\n    }\n    else{\n      indent[depth]=tabcnt;\n    }\n    string name=\"\";\n    while(yaml[i][p]!=':'){\n      name+=yaml[i][p];\n      p++;\n    }\n\n    obj *next=new obj();\n\n    next->par=now;\n    if(yaml[i].size()==p+1){\n      next->isobj=true;\n      next->name=name;\n      next->value=\"###\";\n      (now->ob).push_back(next);\n      now=next;\n      depth++;\n    }\n    else{\n      string value;\n      p+=2;\n      while(p<yaml[i].size()){\n\tvalue+=yaml[i][p];\n\tp++;\n      }\n      next->isobj=false;\n      next->name=name;\n      next->value=value;\n      (now->ob).push_back(next);\n    }\n    \n  }\n\n  obj objec=*base;\n\n  int p=0;\n  p++;\n  \n  auto get_name=[](string &q,int &p){\n    string res=\"\";\n    while(p<q.size() && q[p]!='.'){\n      res+=q[p];\n      p++;\n    }\n    return res;\n  };\n  \n  while(p<query.size()){\n    string name=get_name(query,p);\n\n    obj* res=nullptr;\n    for(int j=0;j<objec.ob.size();j++){\n\n      if(objec.ob[j]->name==name){\n\tres=objec.ob[j];\n      }\n    }\n    if(res==nullptr){\n      cout<<\"no such property\"<<endl;\n      return 0;\n    }\n    objec=*res;\n    p++;\n  }\n  \n  if(objec.isobj){\n    cout<<\"object\"<<endl;\n    return 0;\n  }\n  else{\n    cout<<\"string \"<<\"\\\"\"<<objec.value<<\"\\\"\"<<endl;\n    return 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nvector<string> parse_query(string s) {\n    for(int i = 0; i < (int)s.length(); ++i) if(s[i] == '.') s[i] = ' ';\n    istringstream iss(s);\n    vector<string> res;\n    for(string t; iss >> t; res.push_back(t)) ;\n    return res;\n}\n\nstring first_element(const string &s) {\n    istringstream iss(s);\n    string res;\n    iss >> res;\n    return res;\n}\n\nstring get_string_element(const string &s) {\n    istringstream iss(s);\n    string t;\n    iss >> t;\n\n    string res;\n    iss >> t;\n    res += t;\n    while(iss >> t) {\n        res.push_back(' ');\n        res += t;\n    }\n    return res;\n}\n\nint get_element_size(const string &s) {\n    int i;\n    istringstream iss(s);\n    string t;\n    for(i = 0; iss >> t; i++) ;\n    return i;\n}\n\nint count_indent(const string &s) {\n    int i = 0;\n    while(i < (int)s.length() && s[i] == ' ') i++;\n    return i;\n}\n\nint main() {\n    string Q;\n    getline(cin, Q);\n    vector<string> YAML;\n    for(string s; getline(cin, s); YAML.push_back(s)) ;\n\n    vector<string> query = parse_query(Q);\n\n    string ans;\n    for(int i = 0; i < (int)query.size(); i++) {\n        int begin = -1, end = -1;\n#if 0\n        for(int j = 0; j < (int)YAML.size(); j++) DEBUG(YAML[j]);\n#endif\n        if(i == (int)query.size() - 1) {\n            for(int j = 0; j < (int)YAML.size(); j++) {\n                if(first_element(YAML[j]) == query[i] + \":\") {\n                    string t = YAML[j];\n                    YAML.clear();\n                    YAML.push_back(t);\n                    begin = 0, end = 0;\n                    break;\n                }\n            }\n        }\n        else {\n            for(int j = 0; j < (int)YAML.size(); j++) {\n#if 0\n                DEBUG(YAML[j]);\n                DEBUG(count_indent(YAML[j]));\n                DEBUG(first_element(YAML[j]));\n                DEBUG(query[i]);\n#endif\n                int ind = count_indent(YAML[0]);\n                if(ind == count_indent(YAML[j]) && first_element(YAML[j]) == query[i] + \":\") {\n                    begin = j + 1;\n                    for(end = j + 2; end < (int)YAML.size(); end++) {\n                        if(count_indent(YAML[end]) == ind) {\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n#if 0\n        DEBUG(begin);\n        DEBUG(end);\n#endif\n        if(begin == -1 && end == -1) {\n            ans = \"no such property\";\n            break;\n        }\n        else {\n            vector<string> YAML2;\n            for(int j = begin; j < end; j++) {\n                YAML2.push_back(YAML[j]);\n            }\n            YAML = YAML2;\n        }\n    }\n    if(ans != \"\") {\n        cout << ans << endl;\n        exit(EXIT_SUCCESS);\n    }\n\n    int size = get_element_size(*YAML.begin());\n    if(size == 1) {\n        cout << \"object\" << endl;\n    }\n    else {\n        cout << \"string \\\"\" << get_string_element(*YAML.begin()) << \"\\\"\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nconst int N=50001;\nvector<string> key;\nvector<int> nindent;\nvector<string> mapping_item;\nint lx;\n\nbool dfs(int ni,int vx){\n  while(lx<mapping_item.size()){\n    const char *p=mapping_item[lx].c_str();\n    if(nindent[lx]==ni){\n      char b[N];\n      sscanf(p,\"%[^:]\",b);\n      if(key[vx]==b){\n\tif(vx+1==key.size()){\n\t  char s[N];\n\t  if(sscanf(p,\"%*[^:]:%*c%[^\\n]\",s)==1){\n\t    printf(\"string \\\"%s\\\"\\n\",s);\n\t  }else{\n\t    puts(\"object\");\n\t  }\n\t  return true;\n\t}else if(++lx<nindent.size()&&nindent[lx]>ni){\n\t  if(dfs(nindent[lx],vx+1))return true;\n\t}\n      }else{\n\tlx++;\n      }\n    }else{\n      lx++;\n    }\n  }\n  return false;\n}\n\nint main(){\n  for(char b[N];scanf(\".%[^.\\n]\",b)==1;){\n    key.push_back(b);\n  }\n  getchar();\n  int ni;\n  for(;;){\n    int ni=0;\n    int d=getchar();\n    if(d==EOF)break;\n    for(;d==' ';d=getchar()){\n      ni++;\n    }\n    ungetc(d,stdin);\n    char b[N];\n    scanf(\"%[^\\n]%*c\",b);\n    nindent.push_back(ni);\n    mapping_item.push_back(b);\n  }\n  if(!dfs(0,0)){\n    puts(\"no such property\");\n  }\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nstring in[100000];\nint idx;\nint pos;\nstruct obj_{\n  map<string,string> key;\n  map<string,struct obj_*> mem;\n}obj;\n\nint getindent(int p){\n  int ret=0;\n  while(ret<SZ(in[p]) && in[p][ret]==' ')++ret;\n  return ret;\n}\n\nstruct obj_* get(){\n  struct obj_ *ret= new obj_();\n  int ind=getindent(pos);\n  while(pos < idx && ind==getindent(pos)){\n    int p=in[pos].find(':');\n    string key=in[pos].substr(ind,p-ind);\n    //cout << ind << ' ' << key << endl;\n    if(p+2>SZ(in[pos])){\n      ++pos;\n      ret->mem[key]=get();\n    }else{\n      ret->key[key]=in[pos].substr(p+2);\n      ++pos;      \n    }\n\n  }\n  return ret;\n}\n\nint main(int argc, char *argv[])\n{\n  string pro;\n  cin >> pro;cin.get();\n  pro=\"hoge\"+pro;\n  in[idx++]=\"hoge:\";\n  while(getline(cin,in[idx++]))in[idx-1]=' '+in[idx-1];\n  struct obj_ *r=get();\n  FOR(it,pro) if(*it=='.') *it=' ';\n  stringstream ss(pro);\n  while(ss >> pro){\n    //cout << pro << endl;\n    if(r->mem.count(pro)) r=r->mem[pro];\n    else if(r->key.count(pro)){\n      string ans=r->key[pro];\n      if(ss >> pro) cout << \"no such property\" << endl;\n      else cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n      return 0;\n    }else{\n      cout << \"no such property\" << endl;\n      return 0;\n    }\n  }\n  cout << \"object\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define all(a) (a).begin(),(a).end()\n\nvector<string> split(string s, char c) {\n    vector<string> vs;\n    string tmp = \"\";\n    rep(i, s.size()) {\n        if (s[i] == c) {\n            vs.emplace_back(tmp);\n            tmp = \"\";\n        } else {\n            tmp += s[i];\n        }\n    }\n    vs.emplace_back(tmp);\n    return vs;\n}\n\nint countSpace(string s) {\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            return i;\n        }\n    }\n    assert(false);\n}\n\ntuple<int, string, string> parseLine(string s) {\n    int num_sp;\n    rep(i, s.size()) {\n        if (s[i] != ' ') {\n            num_sp = i;\n            break;\n        }\n    }\n    auto vs = split(s.substr(num_sp), ':');\n    string key = vs[0], value = vs[1].empty() ? \"\" : vs[1].substr(1);\n    return make_tuple(num_sp, key, value);\n}\n\nvoid answer(string value) {\n    if (value.empty()) {\n        cout << \"object\" << endl;\n    } else {\n        cout << \"string \\\"\" << value << \"\\\"\" << endl;\n    }\n}\n\nint main() {\n    string s;\n    getline(cin, s);\n    vector<string> keys = split(s, '.');\n    queue<string> que;\n    rep2(i, 1, keys.size()) {\n        que.push(keys[i]);\n    }\n    int indent = 0;\n    while (getline(cin, s)) {\n        int num_sp;\n        string key, value;\n        tie(num_sp, key, value) = parseLine(s);\n        // cerr << num_sp << \" \" << key << \" \" << value << endl;\n        if (num_sp < indent) break;\n        if (key == que.front()) {\n            que.pop();\n            if (que.empty()) {\n                answer(value);\n                return 0;\n            }\n        }\n    }\n    cout << \"no such property\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<sstream>\nusing namespace std;\n\nstring s,t;\nvector<string> yaml;\nvector<string> keys;\nint n,l;\n\nstring parse(void){\n  if(l==yaml.size())return \"\";\n\n  int ind = 0;\n  while(yaml[l][ind] == ' ')ind++;\n  int c = yaml[l].find(\":\",ind);\n  string key = yaml[l].substr(ind,c-ind);\n  if(key == keys[n]){\n    if(n+1==keys.size()){\n      if(c+1==yaml[l].size())return \"A\";\n      return yaml[l].substr(c+2);\n    }\n    if(c+1==yaml[l].size()){ n++; l++; return parse(); }\n    return \"\";\n  }else{\n    while(++l<yaml.size()){\n      int ind2 = 0;\n      while(yaml[l][ind2] == ' ')ind2++;\n      if(ind>=ind2)break;\n    }\n    return parse();\n  }\n}     \n  \nint main(){\n  cin >> s;\n  for(int i=0;i<s.size();i++)if(s[i]=='.')s[i] = ' ';\n  stringstream ss(s);\n  while(ss >> s)keys.push_back(s);\n\n  cin.ignore();\n  while(getline(cin,t))yaml.push_back(t);\n  n = l = 0;\n  string res = parse();\n  if(res.empty())cout << \"no such property\\n\";\n  else if(res == \"A\")cout << \"object\\n\";\n  else cout << \"string \\\"\" << res << \"\\\"\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\n\nstring key,s,ans=\"no such property\";\nvector<pair<string,int> > yaml;\nvector<string> k;\n\nvoid dfs(int index,int indent,int s,int t){\n  if(k.size()==index){\n    ans=\"object\";\n    return;\n  }\n  for(int i=s;i<t;i++){\n    string subs=\"\";\n    for(int j=indent;j<yaml[i].f.size();j++){\n      if(yaml[i].f[j]==':')break;\n      if(yaml[i].f[j]==' ')break;\n      subs+=yaml[i].f[j];\n    }\n    if(k[index]!=subs)continue;\n    if(yaml[i].f[yaml[i].f.length()-1]!=':'){\n      if(index==k.size()-1){\n\tans=\"string \\\"\";\n\tfor(int j=indent;j<yaml[i].f.length();j++){\n\t  if(yaml[i].f[j]==' '){\n\t    ans+=yaml[i].f.substr(j+1,yaml[i].f.length()-j);\n\t    break;\n\t  }\n\t}\n\tans+=\"\\\"\";\n      }\n      return;\n    }\n    int last=i+1,k;\n    for(int j=i+1;j<yaml.size();j++){\n      if(indent>=yaml[j].s)break;\n      last=j;\n    }\n    dfs(index+1,yaml[i+1].s,i+1,last+1);\n  }\n}\n\n\nint main()\n{ \n  getline(cin,key);\n  while(getline(cin,s)){\n    int c=0;\n    for(int i=0;i<s.length();i++){\n      if(s[i]!=' ')break;\n      c++;\n    }\n    yaml.push_back(mp(s,c));\n  }\n\n  int start=1;\n  key+='.';\n  for(int i=1;i<key.size();i++){\n    if(key[i]=='.'){\n      k.push_back(key.substr(start,i-start));\n      start=i+1;\n    }\n  }\n\n  dfs(0,0,0,yaml.size());\n\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 50001\n#define INF 1e9\n\nclass YAML{\npublic:\n  string s;\n  int state;\n  vector<string> next;\n};\n\nvector<int> space;\nYAML yaml[MAX];\n\nint getState(string &str,int d,vector<string> &v){\n  string now = str.substr(d);\n  string s,t;\n  int x = -1;\n  for(int i = 0 ; i < (int)now.size() ; i++){\n    if(now[i] == ':'){ x = d+i+2; break; }\n    s += now[i];\n  }\n  v.push_back(s);\n  if(x < (int)str.size()){\n    t = str.substr(x);\n    v.push_back(t);\n    return 1;\n  }\n  return 0;\n}\n\nvector<string> make_graph(int cur,int sp){\n  int len = space.size();\n  vector<string> res;\n  if(cur == len || yaml[cur].state == 1){ return res; }\n  int now = cur;\n  while(true){\n    if(now == len || sp > space[now]){ break; }\n    if(space[now] == INF){ now++; continue; }\n    if(sp == space[now]){\n      res.push_back(yaml[now].s);\n      cur = now;\n    }else if(sp < space[now]){\n      if(yaml[cur].next.size() == 0){\n        yaml[cur].next = make_graph(now,space[now]);\n      }\n    }\n    now++;\n  }\n  return res;\n}\n\nint main(){\n  int idx = 1;\n  string order,in;\n  map<string,int> mp;\n  space.push_back(-1);\n  yaml[0].s = \"->\";\n  cin >> order; cin.ignore();\n  while(getline(cin,in)){\n    int cnt = 0;\n    for(int i = 0 ; i < (int)in.size() ; i++){\n      if(in[i] == ' '){\n        cnt++;\n      }else{ break; }\n    }\n    space.push_back(cnt);\n    vector<string> v;\n    yaml[idx].state = getState(in,cnt,v);\n    yaml[idx].s = v[0];\n    mp[yaml[idx].s] = idx;\n    if(yaml[idx].state == 1){\n      yaml[idx].state = 0;\n      yaml[idx].next.push_back(v[1]);\n      idx++;\n      yaml[idx].s = v[1];\n      yaml[idx].state = 1;\n      mp[yaml[idx].s] = idx;\n      space.push_back(INF);\n    }\n    idx++;\n  }\n  /*\n  for(int i = 0 ; i < idx ; i++){\n    cout << yaml[i].s << \" \" << yaml[i].state << \" \";\n    for(auto x : yaml[i].next){\n      cout << x << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n  yaml[0].next = make_graph(1,space[1]);\n  /*\n  for(int i = 0 ; i < idx ; i++){\n    cout << yaml[i].s << \": \";\n    for(auto x : yaml[i].next){\n      cout << x << \" \";\n    }\n    cout << endl;\n  }\n  */\n  string t;\n  vector<string> strs;\n  for(int i = 0 ; i < (int)order.size() ; i++){\n    if(order[i] == '.'){\n      if(!t.empty()){ strs.push_back(t); }\n      t.clear();\n    }else{\n      t += order[i];\n    }\n  }\n  strs.push_back(t);\n  int now = 0,len = strs.size();\n  bool found = true;\n  for(int i = 0 ; i < len ; i++){\n    vector<string> vec = yaml[now].next;\n    bool ok = false;\n    for(int j = 0 ; j < (int)vec.size() ; j++){\n      if(vec[j] == strs[i]){\n        ok = true;\n        break;\n      }\n    }\n    now = mp[strs[i]];\n    if(!ok){\n      found = false;\n      break;\n    }\n  }\n  int size = yaml[now].next.size();\n  if(!found || size == 0){\n    cout << \"no such property\" << endl;\n  }else{\n    if(size != 1){\n      cout << \"object\" << endl;\n    }else{\n      string ans = yaml[now].next[0];\n      if(yaml[mp[ans]].state == 1){\n        cout << \"string \\\"\" << ans << \"\\\"\" << endl;\n      }else{\n        cout << \"object\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n16:30\n */\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<sstream>\n#include<set>\n#include<cstdlib>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Tree{\n  int depth;// root -> -1\n  string key,str;\n  Tree* parent;\n  vector<Tree*> children;\n  Tree(int depth=IINF):depth(depth){}\n};\n\n\nvector<string> input;\nvector<int> depth;\n\npair<string,string> divide(string line){\n  string a = \"\",b = \"\";\n  int sp = -1;\n  bool coron = false;\n  rep(i,line.size()){\n    if(sp == -1 && line[i] != ' '){\n      sp = i;\n    }\n    if(line[i] == ':'){\n      a = line.substr(sp,i-sp);\n      coron = true;\n      sp = i + 2;\n    }\n    if(coron && i >= sp){\n      b += line[i];\n    }\n  }\n  return pair<string,string>(a,b);\n}\n\nvoid makeTree(Tree *tree){\n  tree->depth = -1;\n  rep(i,input.size()){\n    while((tree->depth) >= depth[i]){\n      tree = tree->parent;\n    }\n    pair<string,string> tmp = divide(input[i]);\n    //cout << \"input[\" << i << \"] = \"  << input[i] << endl;\n    //cout << \"divide = (\" << tmp.first << \",\" << tmp.second << \")\" << endl;\n    Tree* child = new Tree;\n    child->depth = depth[i];\n    child->parent = tree;\n    child->key = tmp.first;\n    child->str = tmp.second;\n    (tree->children).push_back(child);\n    tree = child;\n  }\n  while((tree->depth) != -1){\n    tree = tree->parent;\n  }\n}\n\nvoid Answer(vector<string> query,Tree* tree){\n  bool not_found = false;\n  rep(i,query.size()){\n    bool found = false;\n    rep(j,tree->children.size()){\n      if(tree->children[j]->key == query[i]){\n\ttree = tree->children[j];\n\tfound = true;\n\tbreak;\n      }\n    }\n    if(!found){\n      cout << \"no such property\" << endl;\n      return;\n    }\n  }\n  if(tree->str.empty()){\n    cout << \"object\" << endl;\n  } else {\n    cout << \"string \\\"\" << (tree->str) << \"\\\"\" << endl;\n  }\n}\n/*\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << \"cur : \" <<  (t->key) << \" depth = \" << (t->depth) << endl; \n  rep(i,t->children.size()){\n    cout << \"( \" << (t->children[i]->key) << \",\" << (t->children[i]->str) << \" )\" << endl;\n  }\n  rep(i,t->children.size()){\n    tree_walk(t->children[i],depth+1);\n  }\n}\n*/\nint main(){\n  string query;\n  getline(cin,query);\n  rep(i,query.size()){\n    if(query[i] == '.')query[i] = ' ';\n  }\n  stringstream ss;\n  ss << query;\n  vector<string> squery;\n  while(!(ss >> query).fail()){\n    squery.push_back(query);\n  }\n\n  string line;\n  while(getline(cin,line)){\n    input.push_back(line);\n    int cnt = 0, index = input.size()-1;\n    rep(i,input[index].size()){\n      if(input[index][i] != ' '){ \n\tbreak;\n      }\n      cnt++;\n    }\n    depth.push_back(cnt);\n  }\n\n  Tree tree;\n  makeTree(&tree);\n  //tree_walk(&tree,0);\n  Answer(squery,&tree);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct yaml{\n  bool obj;\n  string key,value;\n  vector<yaml> v;\n  yaml(){}\n};\n\nvector<string> vs;\nint p=0;\nyaml dfs(){\n  yaml tmp;\n  //cout<<p<<endl;\n  if((int)vs[p].find(\": \")!=-1){\n    tmp.obj=0;\n    int i;\n    for(i=0;i<(int)vs[p].size();i++){\n      if(vs[p][i]==' ') continue;\n      if(vs[p][i]==':') break;\n      tmp.key+=vs[p][i];\n    }\n    for(i+=2;i<(int)vs[p].size();i++)\n      tmp.value+=vs[p][i];\n    p++;\n  }else{\n    tmp.obj=1;\n    int i,d=0;\n    for(i=0;i<(int)vs[p].size();i++){\n      if(vs[p][i]==' '){\n\td++;\n\tcontinue;\n      }\n      if(vs[p][i]==':') break;\n      tmp.key+=vs[p][i];\n    }\n    p++;\n    while(p<(int)vs.size()){\n      int td=0;\n      for(i=0;i<(int)vs[p].size();i++){\n\tif(vs[p][i]==' '){\n\t  td++;\n\t  continue;\n\t}\n\tbreak;\n      }\n      if(d<td){\n\ttmp.v.push_back(dfs());\n      }else break;\n    }\n  }\n  return tmp;\n}\nstring key;\nvoid dfs2(yaml p,string tmp){\n  tmp+=\".\";\n  tmp+=p.key;\n  //cout<<tmp<<endl;\n  if(p.obj){\n    if(tmp==key){\n      cout<<\"object\"<<endl;\n      exit(0);\n    }\n    for(int i=0;i<(int)p.v.size();i++) dfs2(p.v[i],tmp);\n  }else{\n    if(tmp==key){\n      cout<<\"string \\\"\"<<p.value<<\"\\\"\"<<endl;\n      exit(0);\n    }\n  }\n}\nsigned main(){\n  string buf;\n  getline(cin,key);\n  key=\".root\"+key;\n  while(getline(cin,buf)) vs.push_back(buf);\n  yaml root;\n  root.obj=1;\n  root.key=\"root\";\n  while(p<(int)vs.size()) root.v.push_back(dfs());\n  //cout<<(int)vs.size()<<\" \"<<p<<endl;\n  dfs2(root,\"\");\n  cout<<\"no such property\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring in[50000];\nint linum, N;\n\nstruct object {\n  vector<string> key;\n  vector<string> property;\n  vector<object *>child;\n};\n\nobject *parse(int pindent = -1) {\n  object *res = new object;\n  \n  while(linum<N) {\n    int indent = 0;\n    for(;in[linum][indent]==' ';) indent++;\n    if( indent<=pindent ) break;\n    \n    int colon = in[linum].find(\":\");\n    string key = in[linum].substr(indent, colon-indent);\n    if(colon==in[linum].size()-1){\n      res->key.push_back(key);\n      res->property.push_back(\"__object\");\n      \n      linum++;\n      res->child.push_back(parse(indent));\n    } else {\n      res->key.push_back(key);\n      res->property.push_back(in[linum].substr(colon+2));\n      res->child.push_back(NULL);\n\n      linum++;\n    }\n  }\n  return res;\n}\n\nconst string NG = \"no such property\";\n\nstring find(const object* root, const vector<string>v) {\n  for(int i=0; i<v.size()-1; i++) {\n    bool ok = 0;\n    for(int j=0; j<root->key.size(); j++) {\n      if(root->key[j]==v[i]) {\n\tif(root->property[j]!=\"__object\") break;\n\troot=root->child[j];\n\tok = 1;\n\tbreak;\n      }\n    }\n    if(!ok) return NG;\n  }\n  \n  for(int i=0; i<root->key.size(); i++) {\n    if(root->key[i]==v.back()) {\n      if(root->property[i]==\"__object\") return \"object\";\n      else return \"string \\\"\" + root->property[i] + \"\\\"\";\n    }\n  }\n  return NG;\n}\n\nint main() {\n  \n  vector<string> Query;\n  string query;\n  getline(cin, query);\n  for(int i=0; i<query.size(); i++) if(query[i] == '.') query[i] = ' ';\n  stringstream ss(query);\n  while(ss>>query) Query.push_back(query);\n  \n  linum = 0;\n  N = 0;\n  while(getline(cin, in[N])) N++;\n  object *yaml = parse();\n  \n  cout << find(yaml, Query) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\npair<int, size_t> indent(const string& s, size_t i) {\n  int cnt = 0;\n  while (i < s.size() && s[i] == ' ') {\n    ++i; ++cnt;\n  }\n  return make_pair(cnt, i);\n}\n\npair<string, size_t> get_str(const string& s, size_t i) {\n  string res;\n  while (isalnum(s[i]) || s[i] == ' ') {\n    res += s[i];\n    ++i;\n  }\n  return make_pair(res, i);\n}\n\nstruct Item {\n  int depth;\n  string key;\n  int type;\n  string obj_str;\n  vector<Item> obj_map;\n};\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i);\n\npair<Item, size_t> mapping_item(const string& s, size_t i) {\n  int depth;\n  tie(depth, i) = indent(s, i);\n  string key;\n  tie(key, i) = get_str(s, i);\n  ++i;\n  if (s[i] == '\\n') { // mapping\n    vector<Item> mapping_child;\n    tie(mapping_child, i) = mapping(s, i+1);\n    return make_pair((Item){depth, key, 1, \"\", std::move(mapping_child)}, i);\n  } else { // string\n    string obj;\n    tie(obj, i) = get_str(s, i+1);\n    return make_pair((Item){depth, key, 0, obj, vector<Item>()}, i+1);\n  }\n}\n\npair<vector<Item>, size_t> mapping(const string& s, size_t i) {\n  vector<Item> res;\n  Item front;\n  tie(front, i) = mapping_item(s, i);\n  res.push_back(front);\n  while(i < s.size()) {\n    Item next;\n    size_t next_i;\n    tie(next, next_i) = mapping_item(s, i);\n    if (next.depth != front.depth) break;\n    res.push_back(std::move(next));\n    i = next_i;\n  }\n  return make_pair(std::move(res), i);\n}\n\nstring query(const vector<Item>& obj, const string& s, size_t i) {\n  string key_name;\n  tie(key_name, i) = get_str(s, i+1);\n  for (auto& item : obj) {\n    if (item.key == key_name) {\n      if (item.type == 0) {\n        if (i == s.size()) {\n          return \"string \\\"\" + item.obj_str + \"\\\"\";\n        } else {\n          return \"no such property\";\n        }\n      } else {\n        if (i == s.size()) {\n          return \"object\";\n        } else {\n          return query(item.obj_map, s, i);\n        }\n      }\n    }\n  }\n  return \"no such property\";\n}\n\nint main() {\n  string q;\n  getline(cin, q);\n  string yaml;\n  string line;\n  while (getline(cin, line)) yaml += line + \"\\n\";\n  auto res = mapping(yaml, 0).first;\n  cout << query(res, q, 0) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> key,str;\nstring t,s;\nint ind;\n\nvoid getkey(){\n  int x=0;\n  for(int i=1;i<t.size();i++)\n    if(!x&&t[i]!='.')x=i;\n    else if(t[i]=='.')\n      key.push_back(t.substr(x,i-x)),x=0;\n}\n\nvoid getstr(){\n  int f=0; ind=0;\n  string a;\n  for(int i=0;i<s.size();i++)\n    if(!f&&s[i]==' ')ind++;\n    else f=1;\n  for(int i=ind;i<s.size();i++){\n    if(s[i]!=' ')a+=s[i];\n    else{\n      if(a[a.size()-1]==':')str.push_back(a.substr(0,a.size()-1)),a=\"\";\n      else{\n\tstr.push_back(a+s.substr(i,s.size()-i));\n\ta=\"\";\n\tbreak;\n      }\n    }\n  }\n  if(a!=\"\"){\n    if(a[a.size()-1]!=':')str.push_back(a);\n    else str.push_back(a.substr(0,a.size()-1));\n  }\n}\n\nint main(){\n  cin>>t; t+='.';\n  getkey();\n  getline(cin,s);\n  int x=0,y=0,f=0;\n  while(getline(cin,s)){\n    str.clear();\n    getstr();\n    if(x<=ind&&y!=key.size()&&str[0]==key[y]){\n      x=ind;\n      y++;\n      if(y==key.size()){\n\tif(!f&&str.size()==2)cout<<\"string \\\"\"<<str[1]<<\"\\\"\"<<endl;\n\telse if(!f)cout<<\"object\"<<endl;\n\tf=1;\n      }\n    }\n  }\n  if(!f)cout<<\"no such property\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint tabnum(string &s){\n\tint ret = 0;\n\twhile(ret<(int)s.length() && s[ret]==' ') ret++;\n\treturn ret;\n}\n\nint main(){\n\tstring match;\n\tgetline(cin, match);\n\tstack<string> stc;\n\tstc.push(\"\");\n\tstack<int> tnum;\n\ttnum.push(-1);\n\tmap<string, string> ext;\n\t\n\tstring str;\n\twhile(getline(cin, str)){\n\t\tint intab = tabnum(str);\n\t\twhile(tnum.top() >= intab){\n\t\t\tstc.pop();\n\t\t\ttnum.pop();\n\t\t}\n\t\tstring tmp = str.substr(intab, str.length() -intab);\n\t\tif(str.back() == ':'){\n\t\t\ttmp.pop_back();\n\t\t\text[stc.top() +\".\" +tmp] = \"object\";\n\t\t\tstc.push(stc.top() +\".\" +tmp);\n\t\t\ttnum.push(intab);\n\t\t}else{\n\t\t\tint pos = 0;\n\t\t\twhile(tmp[pos] != ':') pos++;\n\t\t\text[stc.top() +\".\" +tmp.substr(0, pos)] = tmp.substr(pos+2, tmp.length()-pos-2);\n\t\t}\n\t}\n\t\n\tif(ext.count(match) == 0){\n\t\tcout << \"no such property\" << endl;\n\t}else if(ext[match] == \"object\"){\n\t\tcout << \"object\" << endl;\n\t}else{\n\t\tcout << \"string \\\"\" << ext[match] << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvector<string> yaml;\nint indent[50000];\n\nstring query(int l,int r,int i,const string &q){\n\ti++;\n\tint pos=q.find_first_of('.',i);\n\tstring s=q.substr(i,pos-i)+\":\";\n\tif(pos==-1){ // 終端\n\t\tfor(int y=l;y<r;y++){\n\t\t\tif(indent[y]==indent[l] && yaml[y]==s) return \"object\";\n\t\t\tif(indent[y]==indent[l] && yaml[y].substr(0,s.length())==s){\n\t\t\t\treturn \"string \\\"\"+yaml[y].substr(s.length()+1)+\"\\\"\";\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int y=l;y<r;y++){\n\t\t\tif(indent[y]==indent[l] && yaml[y]==s){\n\t\t\t\tint r_next;\n\t\t\t\tfor(r_next=y+1;r_next<yaml.size()&&indent[r_next]>indent[y];r_next++);\n\t\t\t\treturn query(y+1,r_next,pos,q);\n\t\t\t}\n\t\t}\n\t}\n\treturn \"no such property\";\n}\n\nint main(){\n\tstring q; getline(cin,q);\n\tfor(string s;getline(cin,s);yaml.push_back(s));\n\n\trep(i,yaml.size()){\n\t\tindent[i]=yaml[i].find_first_not_of(' ');\n\t\tyaml[i]=yaml[i].substr(indent[i]); // 先頭の空白を除去\n\t}\n\n\tcout<<query(0,yaml.size(),0,q)<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nstruct node {\n  map<string, node*> childs;\n  string value;\n  bool object;\n\n  node(): object(true) {}\n  node(string value): value(value), object(false) {}\n};\n\nvector<string> split(string s, string p) {\n  vector<string> ret;\n  ll h = 0;\n  REP(i, 0, s.size() - p.size() + 1) if(s.substr(i, p.size()) == p) {\n    ret.push_back(s.substr(h, i - h));\n    h = i + p.size();\n    i += (ll) p.size() - 1;\n  }\n  ret.push_back(s.substr(h, (ll) s.size() - h));\n  return ret;\n}\n\nint main(void) {\n  string target;\n  getline(cin, target);\n  vector<string> yaml;\n  string line;\n  while(getline(cin, line)) yaml.push_back(line);\n\n  ll p = 0;\n  function<node* (ll&)> parse = [&](ll &p) {\n    ll d = 0;\n    while(yaml[p][d] == ' ') d++;\n\n    node* n = new node();\n\n    while(p < yaml.size()) {\n      ll ld = 0;\n      while(yaml[p][ld] == ' ') ld++;\n      if(ld < d) break;\n\n      vector<string> tmp = split(yaml[p], \":\");\n      string key = tmp[0].substr(d, tmp[0].length() - d);\n      p++;\n\n      if(tmp[1].length() == 0) {\n        n->childs[key] = parse(p);\n      } else {\n        string val = tmp[1].substr(1, tmp[1].length() - 1);\n        n->childs[key] = new node(val);\n      }\n    }\n\n    return n;\n  };\n  node* object = parse(p);\n\n  vector<string> keys = split(target, \".\");\n  node* r = object;\n  REP(i, 1, keys.size()) {\n    string key = keys[i];\n    if(r->object && r->childs.count(key)) {\n      r = r->childs[key];\n    } else {\n      cout << \"no such property\" << endl;\n      return 0;\n    }\n  }\n  if(r->object) cout << \"object\" << endl;\n  else cout << \"string \\\"\" << r->value << \"\\\"\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct obj{\n  bool isobj;\n  string name;\n  string value;\n  vector<obj*> ob;\n  obj* par;\n};\n  \nint main(){\n  string query;\n  vector<string> yaml;\n  string buf;\n  for(int i=0;getline(cin,buf);i++){\n    if(i==0){\n      query=buf;\n    }\n    else{\n      yaml.push_back(buf);\n    }\n  }\n  \n\n\n  obj* base=new obj();\n  base->isobj=true;\n  base->name=\"#####\";\n  base->par=nullptr;\n  int depth=0;\n  obj* now=base;\n  vector<int> indent(1,0);\n  for(int i=0;i<yaml.size();i++){\n    //cout<<i<<endl;\n    int tabcnt=0;\n    int p=0;\n    while(yaml[i][p]==' '){\n      tabcnt++;\n      p++;\n    }\n\n    for(int j=0;j<depth-1;j++){\n      if(indent[j]==tabcnt){\n\tfor(int k=0;k<depth-j;k++){\n\t  now=now->par;\n\t}\n\tdepth=j;\n\tbreak;\n      }\n    }\n    if(indent.size()<=depth){\n      indent.push_back(tabcnt);\n    }\n    else{\n      indent[depth]=tabcnt;\n    }\n    string name=\"\";\n    while(yaml[i][p]!=':'){\n      name+=yaml[i][p];\n      p++;\n    }\n\n    obj *next=new obj();\n\n    next->par=now;\n    if(yaml[i].size()==p+1){\n      next->isobj=true;\n      next->name=name;\n      next->value=\"###\";\n      (now->ob).push_back(next);\n      now=next;\n      depth++;\n    }\n    else{\n      string value;\n      p+=2;\n      while(p<yaml[i].size()){\n\tvalue+=yaml[i][p];\n\tp++;\n      }\n      next->isobj=false;\n      next->name=name;\n      next->value=value;\n      (now->ob).push_back(next);\n    }\n    \n  }\n\n  obj objec=*base;\n\n  int p=0;\n  p++;\n  \n  auto get_name=[](string &q,int &p){\n    string res=\"\";\n    while(p<q.size() && q[p]!='.'){\n      res+=q[p];\n      p++;\n    }\n    return res;\n  };\n  \n  while(p<query.size()){\n    string name=get_name(query,p);\n    \n    obj* res=nullptr;\n    for(int j=0;j<objec.ob.size();j++){\n\n      if(objec.ob[j]->name==name){\n\tres=objec.ob[j];\n      }\n    }\n    if(res==nullptr){\n      cout<<\"no such property\"<<endl;\n      return 0;\n    }\n    objec=*res;\n    p++;\n  }\n  \n  if(objec.isobj){\n    cout<<\"object\"<<endl;\n    return 0;\n  }\n  else{\n    cout<<\"string \"<<\"\\\"\"<<objec.value<<\"\\\"\"<<endl;\n    return 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\n\nvoid solve() {\n\tstring s;\n\tgetline(cin, s);\n\tvector<string> v;\n\tint le = 1;\n\trep(i, s.length()) {\n\t\tif (s[i] == '.'&&i>0) {\n\t\t\tstring u = s.substr(le, i - le);\n\t\t\tv.push_back(u);\n\t\t\tle = i + 1;\n\t\t}\n\t}\n\tv.push_back(s.substr(le, s.length() - le));\n\tint cur = 0; int loc = -1;\n\tstring t;\n\twhile (getline(cin, t)) {\n\t\tint m = t.length();\n\t\tint le=-1, ri;\n\t\trep(i, m) {\n\t\t\tif (t[i] != ' '&&le<0) {\n\t\t\t\tle = i;\n\t\t\t}\n\t\t\tif (t[i] == ':') {\n\t\t\t\tri = i; break;\n\t\t\t}\n\t\t}\n\t\tif (loc >= le)continue;\n\t\tstring u = t.substr(le, ri - le);\n\t\t//cout << u << endl;\n\t\tif (u == v[cur]) {\n\t\t\tcur++; loc = le;\n\t\t\tif (cur == v.size()) {\n\t\t\t\tint cle = ri + 2;\n\t\t\t\tif (cle >= m) {\n\t\t\t\t\tcout << \"object\" << endl; return;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstring z = t.substr(cle, m - cle);\n\t\t\t\t\tcout << \"string \\\"\" << z << \"\\\"\" << endl; return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"no such property\" << endl; return;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\tstring t; while (cin >> t);\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, ksize;\nstring key, nosuchprop = \"no such property\", obj = \"object\";\nvector<string> s, keys;\n\nstring solve();\n\nint main() {\n  string tmp;\n  cin >> key;\n  cin.ignore();\n  while(getline(cin, tmp)) s.push_back(tmp);\n  n = s.size();\n  cout << solve() << endl;\n  return 0;\n}\n\nstring solve() {\n  int id = -1, nowdep = -1;\n  for(int i = 0; i < key.size();) {\n    assert(key[i] == '.');\n    ++i;\n    string tmp;\n    while(i < key.size() && key[i] != '.') tmp += key[i++];\n    keys.push_back(tmp);\n  }\n  ksize = keys.size();\n  for(int i = 0; i < ksize; ++i) {\n    int nextdep = -1;\n    while(++id < n) {\n      int dep = 0, j = 0, ssize = s[id].size();\n      string nowkey;\n      while(j < ssize && s[id][j] == ' ') ++dep, ++j;\n      // depth check\n      if(nextdep == -1 && dep == nowdep) continue;\n      if(dep > nowdep) {\n        if(nextdep != -1 && nextdep != dep) continue;\n        nextdep = dep;\n      }\n      if(dep < nowdep || (nextdep != -1 && dep == nowdep))\n        return nosuchprop;\n      while(j < ssize && s[id][j] != ':')\n        nowkey += s[id][j++];\n      if(keys[i] == nowkey) {\n        nowdep = dep;\n        break;\n      }\n    }\n    if(id == n) return nosuchprop;\n    if(i == ksize - 1) {\n      int j = 0, ssize = s[id].size();\n      string tmp = \"string \\\"\";\n      while(j < ssize && s[id][j] != ':') ++j;\n      if(++j == ssize) return obj;\n      ++j;\n      while(j < ssize) tmp += s[id][j++];\n      return tmp + \"\\\"\";\n    }\n  }\n  assert(0);\n  return \"-1\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 50000\n\nstring s;\nint size=0;\nmap<string,int> mp[MAX];\nstring name[MAX];\nint cnt[MAX];\n\nint main(){\n  string str;\n  getline(cin,str);\n  stack<P> st;\n  st.push(P(-1,0));\n  \n  while(getline(cin,s)){\n    size++;\n    string a=\"\",b=\"\";\n    int i,len=s.size(),ra=0;\n    for(i=0;s[i]==' ';i++)ra++;\n    for(;s[i]!=':';i++)a.push_back(s[i]);\n    if(i+1<len&&s[i+1]==' '){\n      for(i=i+2;i<len;i++)b.push_back(s[i]);\n    }\n    //cout<<ra<<' '<<a<<' '<<b<<endl;\n\n    P p;\n    while(1){\n      p=st.top();\n      if(p.first >= ra){\n        st.pop();\n      }else{\n        break;\n      }\n    }\n\n    mp[p.second][a]=size;\n    // cout<<p.second<<' '<<a<<' '<<size<<endl;\n\n    if(b==\"\")name[size]=\"object\";\n    else name[size]=b;\n\n    cnt[p.second]++;\n    st.push(P(ra,size));\n  }\n  \n\n  for(int i=0;i<(int)str.size();i++){\n    if(str[i]=='.')str[i]=' ';\n  }\n\n  stringstream ss(str);\n  string tmp;\n  int p=0;\n  vector<string> vec;\n  while(ss>>tmp)vec.push_back(tmp);\n  \n  for(int i=0;i<(int)vec.size();i++){\n    if(mp[p][vec[i]]==0){\n      cout<<\"no such property\"<<endl;\n      return 0;\n    }\n    p=mp[p][vec[i]];\n  }\n  if(cnt[p]==0)cout<<\"string \\\"\"<<name[p]<<\"\\\"\"<<endl;\n  else cout<<name[p]<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct dat{\n\tstring value;\n\tmap<string, dat> p;\n};\n\nstring buf[100000];\n\nint i;\ndat mapping(){\n\tstring s;\n\tdat res;\n\tint prv = -1;\n\twhile (!buf[i].empty()){\n\t\tstring &s = buf[i];\n\t\tint l = 0;\n\t\twhile (s[l] == ' ') ++l;\n\t\tif (prv < 0) prv = l;\n\t\tif (prv != l) break;\n\t\ti++;\n\t\tint idx = s.find(':');\n\t\tstring t = s.substr(idx);\n\t\tdat d;\n\t\tif (t.size() > 2) d.value = t.substr(2);\n\t\telse d = mapping();\n\n\t\tres.p[s.substr(l, idx-l)] = d;\n\t}\n\treturn res;\n}\n\nint main(){\n\tstring query;\n\tcin >> query;\n\tcin.ignore();\n\tint len = 0;\n\twhile (getline(cin, buf[len++]));\n\n\tdat d = mapping();\n\n\tfor (auto &c : query) if (c == '.') c = ' ';\n\n\tstringstream ss(query);\n\tstring s;\n\tdat *p = &d;\n\twhile (ss >> s){\n\t\tif (!p->p.count(s)) goto NG;\n\t\tp = &(p->p[s]);\n\t}\n\n\tif (p->value.empty()) cout << \"object\" << endl;\n\telse cout << \"string \\\"\" << p->value << \"\\\"\" << endl;\n\n\treturn 0;\nNG:\n\tcout << \"no such property\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> split(string &s, char deliter){\n  vector<string> res;\n  int prev_split_point = 0;\n  while(s[prev_split_point] == ' ')prev_split_point++;\n  for (int i = prev_split_point; i < s.length(); i++) {\n    while(s[i] == ' ')i++, prev_split_point++;\n    while(s[i] != deliter && i < s.length())i++;\n    string add = s.substr(prev_split_point, i - prev_split_point);\n    if(!add.empty())res.push_back(add);\n    prev_split_point = i + 1;\n  }\n  return res;\n}\n\nstring slove(vector<string> &query,\n             map<string, string> &hash,\n             string s,\n             int i){\n  string res;\n  if(hash.find(s) == hash.end()){\n    return \"no such property\";\n  }\n  if(i == query.size() - 1){\n    return \"string \\\"\" + hash[s] + \"\\\"\";\n  }else if(hash.find(s) != hash.end()){\n    res = slove(query, hash, query[i + 1], i + 1);\n  }else{\n    return \"object\";\n  }\n  return res;\n}\n\n\nint main(int argc, char *argv[]){\n  map<string, string> hash;\n  string s;\n  cin >> s;\n  vector<string> query = split(s, '.');\n  cin.ignore();\n  while(getline(cin, s)){\n    vector<string> vs = split(s, ':');\n    // for (int i = 0; i < vs.size(); i++) {\n    //   std::cout << vs[i] << std::endl;\n    // }\n    if(vs.size() > 1)hash[vs[0]] = vs[1];\n    else hash[vs[0]] = \"\";\n  }\n  string ans = slove(query, hash, query[0], 0);\n  if(ans == \"string \\\"\\\"\"){\n    std::cout << \"object\" << std::endl;\n  }else{\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nstring req;\nvector<string> props;\nmain(){\n\tchar c;\n\tcin >> c >> req;\n\tREP(i, req.size()) if(req[i] == '.') req[i] = ' ';\n\tstringstream ss;\n\tss << req;\n\twhile(ss >> req){\n\t\tprops.push_back(req);\n\t}\n\t\n\tcin.ignore();\n\tint level = 0;\n\tint depth = 0;\n\tvi sp(1);\n\twhile(getline(cin, req)){\n\t\tint p = 0;\n\t\tstring prop;\n\t\tfor(;req[p] == ' ';p++);\n\t\twhile(sp.back() > p) sp.pop_back();\n\t\tif(sp.back() < p) sp.push_back(p);\n\t\tif(level > sp.size()-1) break;\n\t\tif(level < sp.size()-1) continue;\n\t\twhile(req[p] != ':') prop.push_back(req[p++\t]);\n\t\tif(props[level] == prop){\n\t\t\tlevel ++;\n\t\t}else continue;\n\t\tif(level == props.size()){\n\t\t\tif(p+1 == req.size()){\n\t\t\t\tputs(\"object\");\n\t\t\t}else{\n\t\t\t\tcout << \"string \\\"\" << req.substr(p+2) << \"\\\"\" << endl;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"no such property\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\n\nclass Input{\n\tpublic:\n\tbool isObject;\n\tint space;\n\tstring key;\n\tstring data;\n\t\n\tInput(string str){\n\t\tint nspace = 0;\n\t\tfor(;;nspace++)if(str[nspace]!=' ')break;\n\t\t\n\t\tint colon = nspace;\n\t\tfor(;;colon++)if(str[colon-1]==':')break;\n\t\t\n\t\tint lspace =  colon+1;\n\t\t\n\t\tspace = nspace;\n\t\tkey = str.substr(nspace, colon-nspace-1);\n\t\t\n\t\tif(lspace+1 <= str.size()){\n\t\t\tdata = str.substr(lspace, str.size()-lspace);\n\t\t\tisObject = false;\n\t\t}else{\n\t\t\tisObject = true;\n\t\t}\n\t}\n\t\n\tvoid print(){\n\t\tcout<<\"sp = \"<<space<<\" key=\"<<key<<\" data=\"<<data<<endl;\n\t}\n};\n\n\nstring query;\nvector<Input> in;\n\n\nbool input(){\n\tgetline(cin, query);\n\twhile(!cin.eof()){\n\t\tstring s;\n\t\tgetline(cin, s);\n\t\tif(s==\"\")break;\n\t\tin.pb(Input(s));\n\t}\n\treturn true;\n}\n\nclass Data{\n\tpublic:\n\tbool isprop;\n\tstring prop;\n\tstring key;\n\tvector<Data> data;\n\t\n\tData(string key){\n\t\tisprop = false;\n\t\tthis->key = key;\n\t}\n\tData(string key, string prop){\n\t\tisprop = true;\n\t\tthis->key = key;\n\t\tthis->prop = prop;\n\t}\n\t\n\tvoid print(int index){\n\t\tstring space = \"\";\n\t\trep(i,index)space += ' ';\n\t\t\n\t\tcout<<space; puts(\"----------------------\");\n\t\tcout<<space; cout<<\"key    : '\"<<key<<\"'\"<<endl;\n\t\tcout<<space; cout<<\"isprop : \"<<isprop<<endl;\n\t\tcout<<space; cout<<\"prop   : '\"<<prop<<\"'\"<<endl;\n\t\trep(i,data.size()){\n\t\t\tdata[i].print(index+2);\n\t\t}\n\t}\n};\n\n\nData kaiseki(int st, int en){\n\t\n\t//printf(\"st=%d  en=%d\\n\",st,en);\n\tif(st+1==en){\n\t\treturn Data(in[st].key,  in[st].data);\n\t}\n\t\n\t\n\tData ret(in[st].key);\n\tint head = st+1;\n\tint stspace = in[st+1].space;\n\treps(i,st+2, en+1){\n\t\tif(i==en || in[i].space==stspace){\n\t\t\tret.data.pb(kaiseki(head, i));\n\t\t\thead = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nstring calc(Data& data, string& q){\n\t\n\t\n\tif(q==\"\"){\n\t\tif(data.isprop){\n\t\t\tstringstream sst;\n\t\t\treturn \"string \\\"\"+data.prop+\"\\\"\";\n\t\t}\n\t\treturn \"object\";\n\t}\n\t\n\tint en = 1;\n\tfor(;en<q.size();en++){\n\t\tif(q[en]=='.')break;\n\t}\n\tstring key = q.substr(1, en-1);\n\tstring nq = q.substr(en, q.size()-(en));\n\t\n\t//cout<<\"q:\"<<q<<\"   nq:\"<<nq<<\"   key:\"<<key<<endl;\n\trep(i,data.data.size()){\n\t\tif(data.data[i].key==key){\n\t\t\treturn calc(data.data[i], nq);\n\t\t}\n\t}\n\t\n\treturn \"no such property\";\n}\n\n\nvoid solve(){\n\tData parent(\"parent\");\n\t\n\tint head = 0;\n\treps(i,1,in.size()+1){\n\t\tif(i==in.size() || in[i].space==0){\n\t\t\tparent.data.pb(kaiseki(head, i));\n\t\t\thead=i;\n\t\t}\n\t}\n\tstring ans = calc(parent, query);\n\tcout<<ans;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Table {\n  int indent;\n  string name;\n  string value;\n  map<string, Table*> child;\n  Table() {;}\n  Table(int indent) : indent(indent) {;}\n  Table(int indent, string name, string value) : indent(indent), name(name), value(value) {;}\n};\n\nint CountIndent(string &str) {\n  int ret = 0;\n  FORIT(it, str) {\n    if (*it != ' ') { break; }\n    ret++;\n  }\n  str = str.substr(ret);\n  return ret;\n}\n\nstring GetKey(string &str) {\n  string ret;\n  FORIT(it, str) {\n    if (*it == ':') { break; }\n    ret += *it;\n  }\n  str = str.substr(ret.size() + 1);\n  return ret;\n}\n\nstring GetValue(string &str) {\n  if (str.size() == 0) { return \"\"; }\n  str = str.substr(1);\n  return str;\n}\n\nstring line;\nint m;\nTable tables[50000];\n\nint main() {\n  string query;\n  while (getline(cin, query)) {\n    m = 0;\n    vector<string> queries;\n    {\n      FORIT(it, query) {\n        if (*it == '.') { *it = ' '; }\n      }\n      stringstream sin(query);\n      string str;\n      while (sin >> str) {\n        queries.push_back(str);\n      }\n    }\n    stack<Table*> st;\n    tables[m++] = Table(-1);\n    st.push(tables);\n    while (getline(cin, line)) {\n      int indent = CountIndent(line);\n      string key = GetKey(line);\n      string value = GetValue(line);\n      //cout << st.top()->indent << \" \" << indent << endl;\n      while (st.top()->indent >= indent) {\n        st.pop();\n      }\n      //cout << st.top()->name << endl;\n      tables[m++] = Table(indent, key, value);\n      st.top()->child[key] = tables + m - 1;\n      st.push(tables + m - 1);\n    }\n    while (st.top()->indent >= 0) { st.pop(); }\n    Table *t = st.top();\n    FORIT(it, queries) {\n      if (!t->child.count(*it)) { goto error; }\n      t = t->child[*it];\n    }\n    if (t->value == \"\") {\n      puts(\"object\");\n    } else {\n      printf(\"string \\\"%s\\\"\\n\", t->value.c_str());\n    }\n    continue;\nerror:\n    puts(\"no such property\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n16:30\n */\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<sstream>\n#include<set>\n#include<cstdlib>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Tree{\n  int depth;// root -> -1\n  string key,str;\n  Tree* parent;\n  vector<Tree*> children;\n  Tree(int depth=IINF):depth(depth){}\n};\n\n\nvector<string> input;\nvector<int> depth;\n\npair<string,string> divide(string line){\n  string a = \"\",b = \"\";\n  int sp = -1;\n  bool coron = false;\n  rep(i,line.size()){\n    if(sp == -1 && line[i] != ' '){\n      sp = i;\n    }\n    if(line[i] == ':'){\n      a = line.substr(sp,i-sp);\n      coron = true;\n      sp = i + 2;\n    }\n    if(coron && i >= sp){\n      b += line[i];\n    }\n  }\n  return pair<string,string>(a,b);\n}\n\nvoid makeTree(Tree *tree){\n  tree->depth = -1;\n  rep(i,input.size()){\n    while((tree->depth) >= depth[i]){\n      tree = tree->parent;\n    }\n    pair<string,string> tmp = divide(input[i]);\n    //cout << \"input[\" << i << \"] = \"  << input[i] << endl;\n    //cout << \"divide = (\" << tmp.first << \",\" << tmp.second << \")\" << endl;\n    Tree* child = new Tree;\n    child->depth = depth[i];\n    child->parent = tree;\n    child->key = tmp.first;\n    child->str = tmp.second;\n    (tree->children).push_back(child);\n    tree = child;\n  }\n  while((tree->depth) != -1){\n    tree = tree->parent;\n  }\n}\n\nvoid Answer(vector<string> query,Tree* tree){\n  bool not_found = false;\n  rep(i,query.size()){\n    bool found = false;\n    rep(j,tree->children.size()){\n      if(tree->children[j]->key == query[i]){\n\ttree = tree->children[j];\n\tfound = true;\n\tbreak;\n      }\n    }\n    if(!found){\n      cout << \"no such property\" << endl;\n      return;\n    }\n  }\n  if(tree->str.empty()){\n    cout << \"object\" << endl;\n  } else {\n    cout << \"string \\\"\" << (tree->str) << \"\\\"\" << endl;\n  }\n}\n/*\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << \"cur : \" <<  (t->key) << \" depth = \" << (t->depth) << endl; \n  rep(i,t->children.size()){\n    cout << \"( \" << (t->children[i]->key) << \",\" << (t->children[i]->str) << \" )\" << endl;\n  }\n  rep(i,t->children.size()){\n    tree_walk(t->children[i],depth+1);\n  }\n}\n*/\nint main(){\n  string query;\n  getline(cin,query);\n  rep(i,query.size()){\n    if(query[i] == '.')query[i] = ' ';\n  }\n  stringstream ss;\n  ss << query;\n  vector<string> squery;\n  while(!(ss >> query).fail()){\n    squery.push_back(query);\n  }\n\n  string line;\n  while(getline(cin,line)){\n    input.push_back(line);\n    int cnt = 0, index = input.size()-1;\n    rep(i,input[index].size()){\n      if(input[index][i] != ' '){ \n\tbreak;\n      }\n      cnt++;\n    }\n    depth.push_back(cnt);\n  }\n\n  Tree tree;\n  makeTree(&tree);\n  //tree_walk(&tree,0);\n  Answer(squery,&tree);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring key[25];\nstring yaml[50005];\nint indent[50005];\nint line;\nint n;\n\nbool starts_with(const string &s, const string &key) {\n    if (s.size() < key.size()) return false;\n    \n    for (int i = 0; i < key.size(); i++) {\n        if (s[i] != key[i]) return false;\n    }\n\n    return true;\n}\n\nstring get_property_value(const string &s) {\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ') return \"string \\\"\" + s.substr(i + 1) + \"\\\"\";\n    }\n    return \"object\";\n}\n\nstring dfs(int kptr, int lptr) {\n    if (lptr >= line) return \"\";\n    if (kptr >= n) return get_property_value(yaml[lptr]);\n\n    int m = indent[lptr + 1];\n    int i = lptr + 1;\n    while (indent[i] > indent[lptr] && i < line) {\n        if (indent[i] == m && starts_with(yaml[i], key[kptr] + \":\")) return dfs(kptr + 1, i);\n        i++;\n    }\n    \n\n    return \"\";\n}\n\nint main() {\n    //input\n    {\n        string tmp;\n        getline(cin, tmp);\n\n        int cnt = 0;\n        for (int i = 1; i < tmp.size(); i++) {\n            if (tmp[i] == '.') {\n                cnt++;\n                continue;\n            }\n            key[cnt] += tmp[i];\n        }\n        n = cnt + 1;\n    }\n\n    {\n        string tmp;\n        int cnt = 0;\n        while (getline(cin, tmp)) {\n            yaml[cnt++] = tmp;\n        }\n        line = cnt;\n    }\n\n    for (int i = 0; i < line; i++) {\n        int j = 0;\n        while (yaml[i][j] == ' ') j++;\n        indent[i] = j;\n\n        yaml[i] = yaml[i].substr(indent[i]);\n    }\n\n    int i = 0;\n    string ans;\n    while (!starts_with(ans, \"string\") && i < line) {\n        if (indent[i] == 0 && starts_with(yaml[i], key[0])) {\n            string tmp = dfs(1, i);\n            if (!tmp.empty()) ans = tmp;\n        }\n        i++;\n    }\n    \n    if (ans.empty()) cout << \"no such property\" << endl;\n    else cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst int M=50*1000+10;\nchar buf[M+1];\nchar in[M+1];\nvoid No(){\n\tcout << \"no such property\" << endl;\n\texit(0);\n}\nint main() {\n\tcin.getline(in,M);\n\tint e=0;\n\tint indent=0;\n\twhile(in[e]!=0){\n\t\te++;\n\t\tint s=e;\n\t\twhile(in[e]!='.'&&in[e]!=0){\n\t\t\te++;\n\t\t}\n\t\tbool newIndent=true;\n\t\twhile(cin.getline(buf,M)){\n\t\t\tint s0=0;\n\t\t\twhile(buf[s0]==' '){\n\t\t\t\ts0++;\n\t\t\t}\n\t\t\tif(newIndent){\n\t\t\t\tindent=s0;\n\t\t\t\tnewIndent=false;\n\t\t\t}\n\t\t\telse if(s0<indent){\n\t\t\t\tNo();\n\t\t\t}\n\t\t\telse if(s0>indent){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint e0=s0;\n\t\t\twhile(buf[e0]!=':'){\n\t\t\t\te0++;\n\t\t\t}\n\t\t\tif(e0-s0==e-s){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int i=0;i<e-s;i++){\n\t\t\t\t\tif(buf[i+s0]!=in[i+s]){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tif(in[e]==0){\n\t\t\t\t\t\tif(buf[e0+1]==0){\n\t\t\t\t\t\t\tcout << \"object\" << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcout << \"string \\\"\" << (buf+e0+2) << \"\\\"\" << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(buf[e0+1]==' '){\n\t\t\t\t\t\t\tNo();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewIndent=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tNo();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nstring key;\nint pos;\n\nbool check(string a,string b){\n  int ima=pos,i=0,j=0;\n  // while(a[i]==' ')i++;\n  //while(b[i]==' ')j++;\n  if(i<j) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  string par;\n  while(pos<(int)key.size()){\n    idx=0;\n    while(idx<(int)str.size()&&!check(str[idx],par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=str[idx];\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst bool debug = false;\n\nvector<string> query;\n\nvector<string> split(string s, char delim) {\n    string cur = \"\";\n    vector<string> ret;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == delim) {\n            ret.push_back(cur);\n            cur = \"\";\n        } else {\n            cur += s[i];\n        }\n    }\n    ret.push_back(cur);\n    return ret;\n}\n\nvoid get_query() {\n    string query_str;\n    getline(cin, query_str);\n    query = split(query_str, '.');\n}\n\nint level(string s) {\n    int cnt = 0;\n    for (int i = 0; i < s.size() && s[i] == ' '; i++) cnt++;\n    return cnt;\n}\n\nstring cache = \"\";\nbool get_input(string &s) {\n    if (cache != \"\") {\n        s = cache;\n        cache = \"\";\n        return true;\n    }\n    return getline(cin, s);\n}\n\nvoid unget_input(string s) {\n    cache = s;\n}\n\nstring get_key(const string &s) {\n    if (debug) cout << \"get_key: called with argument \" << s << endl;\n    string ret = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ') continue;\n        if (s[i] == ':') return ret;\n        ret.push_back(s[i]);\n    }\n    if (debug) cout << \"ERROR in get_key\" << endl;\n    if (debug) cout << ret << endl;\n    return \"FOO\";\n}\n\nstring get_string_value(const string &s) {\n    int colon_index = s.find(':');\n    return s.substr(colon_index+2);\n}\n\nbool is_object(const string &s) {\n    return s.size()-1 == s.find(':');\n}\n\nstring solve() {\n    string s;\n    int cur_indent = 0;\n    for (int i = 1; i < query.size(); i++) {\n        while(get_input(s)) {\n            if (debug) cout << \"solve: invoke while loop with s: \" << s << endl;\n            if (debug) cout << \"s's key: \" << get_key(s) << endl;\n            if (debug) cout << \"cur_indent: \" << cur_indent << endl;\n\n            if (level(s) == cur_indent && query[i] == get_key(s)) {\n                if (i == query.size()-1) {\n                    if (is_object(s)) {\n                        return \"object\";\n                    } else {\n                        return \"string \\\"\" + get_string_value(s) + \"\\\"\";\n                    }\n                }\n                string t; get_input(t);\n                cur_indent = level(t);\n                unget_input(t);\n                break;\n            }\n        }\n    }\n    // ここに来ればそんなプロパティは存在しなかった\n    return \"no such property\";\n}\n\n\nint main() {\n    get_query();\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector <string> str;\nvector <int> cnt;\nstring key;\nint pos;\n\nbool check(string a,int x,int y){\n  int ima=pos,i=0,j=0;\n  if(cnt[x]<=cnt[y]&&pos!=1) return 0;\n  while(key[ima]==a[i])ima++,i++;\n  if((key[ima]=='.'||!key[ima])&&a[i]==':') {\n    pos=ima+1;\n    return 1;\n  }\n  return 0;\n}\n\nstring bnf(){\n  int idx=0;\n  int par=0;\n  while(pos<(int)key.size()){\n    while(idx<(int)str.size()&&!check(str[idx],idx,par))idx++;\n    if(idx==(int)str.size()) return \"no such property\";  \n    par=idx;\n  }\n\n\n  if(str[idx][str[idx].size()-1]==':') return \"object\";\n  string ans=\"string \\\"\";\n  int f=0;\n  for(int i=0;i<str[idx].size();i++){\n    if(str[idx][i]==':') f=1;\n    else if(f==1&&str[idx][i]==' ')f=2;\n    else if(f==2) ans+=str[idx][i];\n  }\n  ans+=\"\\\"\";\n  return ans;\n}\n\nint main(){\n  cin>>key;\n  string a;\n  getline(cin,a);\n  while(getline(cin,a))str.push_back(a);\n  for(int i=0;i<str.size();i++){\n    int j=0;\n    while(str[i][j]==' ') j++;\n    cnt.push_back(j+1);\n    str[i]=str[i].substr(j,str[i].size()-j);\n  }\n  pos=1;\n  cout << bnf()<<endl;\n  return 0;\n}\n  \n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct Tree{\n  string data=\"\";\n  map<string,Tree*> child;\n};\n\nint main(){\n  string s;\n  cin >> s;\n  string t;\n  Tree* root=new Tree();\n  vector<Tree*> mem(21);\n  vector<int> indent(21);\n  mem[0]=root;\n  indent[0]=0;\n  int depth=0;\n  getline(cin,t);\n  while(getline(cin,t)){\n    int i=0;\n    for(;;i++){\n      if(t[i]!=' '){\n        if(indent[depth]<i) depth++,indent[depth]=i;\n        else{\n          while(indent[depth]>i) depth--;\n        }\n        break;\n      }\n    }\n    int j=i;\n    for(;;j++){\n      if(t[j]==':') break;\n    }\n    mem[depth+1]=new Tree();\n    mem[depth]->child[t.substr(i,j-i)]=mem[depth+1];\n    if(j+1<t.length()){\n      mem[depth+1]->data=t.substr(j+2);\n    }\n  }\n  Tree* now=root;\n  int pre=1;\n  s+='.';\n  for(int i=1;i<s.length();i++){\n    if(s[i]=='.'){\n      auto itr=now->child.find(s.substr(pre,i-pre));\n      if(itr==now->child.end()){\n        cout << \"no such property\" << endl;\n        return 0;\n      }else{\n        now=itr->second;\n      }\n      pre=i+1;\n    }\n  }\n  if(now->data==\"\") cout << \"object\" << endl;\n  else cout << \"string \\\"\" << now->data << \"\\\"\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\nusing namespace std;\n\nchar buf[50010];\n\nint main(){\n\tstring s;\n\tgetline(cin, s);\n\tconst char *ptr = s.c_str();\n\t\n\tvector<string> key;\n\tint d = 0;\n\twhile(sscanf(ptr, \".%[^.]%n\", buf, &d) > 0){\n\t\tptr += d;\n\t\tkey.push_back(buf);\n\t}\n\t\n\tint m = 0;\n\tint prev = -1;\n\tint k = 0;\n\twhile(getline(cin, s)){\n\t\tptr = s.c_str();\n\t\tint indent = -1;\n\t\tsscanf(ptr, \" %n%[^:]:%n\", &indent, buf, &d);\n\n\t\tif(indent <= prev){ break; }\n\n\t\tif(m == -1) m = indent;\n\n\t\tif(m == indent && key[k] == buf){\n\t\t\tm = -1;\n\t\t\tprev = indent;\n\n\t\t\tif(++k == key.size()){\n\t\t\t\tif(d < s.size()){\n\t\t\t\t\tcout << \"string \\\"\" << s.substr(d + 1) << \"\\\"\\n\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << \"object\\n\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << \"no such property\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint tabnum(string &s){\n\tint ret = 0;\n\tfor(; ret<(int)s.length() && s[ret]==' '; ret++);\n\treturn ret;\n}\n\nint main(){\n\tstring match;\n\tgetline(cin, match);\n\tvector<string> stc(1, \"\");\n\tvector<int> tnum(1, -1);\n\tmap<string, string> ext;\n\tstring input;\n\twhile(getline(cin, input)){\n\t\tint intab = tabnum(input);\n\t\twhile(tnum.back() >= intab){\n\t\t\tstc.pop_back();\n\t\t\ttnum.pop_back();\n\t\t}\n\t\tstring tmp = input.substr(intab, input.length() -intab);\n\t\tif(input.back() == ':'){\n\t\t\ttmp.pop_back();\n\t\t\text[stc.back() +\".\" +tmp] = \"object\";\n\t\t\tstc.push_back(stc.back() +\".\" +tmp);\n\t\t\ttnum.push_back(intab);\n\t\t}else{\n\t\t\tint pos = 0;\n\t\t\twhile(tmp[pos] != ':') pos++;\n\t\t\text[stc.back() +\".\" +tmp.substr(0, pos)] = tmp.substr(pos+2, tmp.length()-pos-2);\n\t\t}\n\t}\n\t\n\tif(ext.count(match) == 0){\n\t\tcout << \"no such property\" << endl;\n\t}else if(ext[match] == \"object\"){\n\t\tcout << \"object\" << endl;\n\t}else{\n\t\tcout << \"string \\\"\" << ext[match] << \"\\\"\" << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\ntemplate<typename A,typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost){\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n){\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0&&level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s,int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nvector<string> answers;\nvector<pair<int, string>> findings;\nvoid calc(State &now) {\n    int cnt = 0;\n    while (*now == ' ') {\n        cnt++;\n        now++;\n    }\n    while (findings.empty() == false && findings.back().first >= cnt) {\n        findings.pop_back();\n    }\n    string c;\n    while (*now != ':') {\n        c.push_back(*now);\n        now++;\n    }\n    findings.push_back(mp(cnt, c));\n    now++;\n    if (findings.size() == answers.size()) {\n        int ok = 1;\n        REP(q, findings.size()) {\n            if (findings[q].second != answers[q]) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok == 1) {\n            if (*now == '\\n') {\n                cout << \"object\" << endl;\n            }\n            else {\n                cout << \"string \" << '\"';\n                now++;\n                while (*now != '\\n') {\n                    cout << (char)(*now);\n                    now++;\n                }\n                cout << '\"' << endl;\n            }\n            exit(0);\n        }\n    }\n    while (*now != '\\n') {\n        now++;\n    }\n    now++;\n    if (*now != 1) {\n        calc(now);\n    }\n}\nvoid solve() {\n    string s;\n    cin >> s;\n    string b;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        if (s[i] == '.') {\n            reverse(ALL(b));\n            answers.push_back(b);\n            b.clear();\n            continue;\n        }\n        b.push_back(s[i]);\n    }\n    reverse(ALL(answers));\n    string now;\n    getline(cin, s);\n    while (getline(cin, s)) {\n        now += s;\n        now.push_back('\\n');\n    }\n    now.push_back(1);\n    State start = now.begin();\n    calc(start);\n    cout << \"no such property\" << endl;\n    return;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    vector<string> dir;\n    {\n        string str; cin >> str;\n        str.push_back('.');\n        int p = 1;\n        int np;\n        while((np = str.find('.', p)) != string::npos){\n            dir.push_back(str.substr(p, np - p));\n            p = np + 1;\n        }\n    }\n    int len = dir.size();\n\n    cin.ignore();\n\n    int depth = 0;\n    string in;\n    int correct = -1;\n    int pbcnt = 0;\n    vi brs = {0};\n    while(getline(cin, in)){\n        int bcnt = 0;\n        while(in[bcnt] == ' ') bcnt++;\n        if(bcnt > brs.back()) depth++, brs.push_back(bcnt);\n        while(bcnt < brs.back()){\n            brs.pop_back();\n            depth--;\n        }\n\n        if(correct >= depth) correct = depth - 1;\n\n        stringstream ss(in);\n        string obj; ss >> obj;\n\n        obj.pop_back();\n        if(correct == depth - 1 and dir[depth] == obj){\n            correct = depth;\n            if(correct == len - 1){\n                int si = in.find(':') + 2;\n                if(si >= in.size()){\n                    cout << \"object\" << endl;\n                }\n                else {\n                    string name = in.substr(in.find(':') + 2);\n                    cout << \"string \\\"\" << name << \"\\\"\" << endl;\n                }\n                return 0;\n            }\n        }\n    }\n\n    cout << \"no such property\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_indent,int arg_address){\n\t\tindent = arg_indent;\n\t\taddress = arg_address;\n\t}\n\n\tint indent,address;\n};\n\nstruct Obj{\n\tvoid allocate(int n){\n\t\tname = new char[n+1];\n\t}\n\n\tchar* name;\n\tvector<int> children; //??????????????£??¨?????????????????§?????????????????°???????????¢?????¬????????????\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint main(){\n\n\tchar* query = new char[50001];\n\tchar* buf = new char[50001];\n\tchar* work = new char[50001];\n\n\tscanf(\"%s\",query);\n\tgetchar();\n\n\tObj obj[15000];\n\n\tint ob_index = 0,work_index,calc_index,indent_num;\n\tstack<Info> S;\t//????????¢?????¬??????????????????????????????\n\n\tchar ch;\n\n\tint buf_index,debug = 0;\n\tbool breakFLG;\n\n\twhile(true){\n\t\t//fgetc?????¨??¢??????????????????getchar()????????¨\n\t\tbuf_index = 0;\n\t\tch = getchar();\n\t\twhile(ch != '\\n' && ch != '\\0' && ch != EOF){\n\t\t\tbuf[buf_index++] = ch;\n\t\t\tch = getchar();\n\t\t}\n\t\tbuf[buf_index] = '\\0';\n\n\t\t//printf(\"buf: %s buf_index:%d\\n\",buf,buf_index);\n\t\tbreakFLG = true;\n\n\t\tfor(int z = 0; z < buf_index; z++){\n\t\t\tif(buf[z] == ':'){\n\t\t\t\tbreakFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(breakFLG){\n\t\t\tbreak;\n\t\t}\n\n\t\t/*debug++;\n\t\tif(debug >= 5)break;*/\n\n\t\tfor(calc_index = 0;buf[calc_index] == ' ';calc_index++);\t//????????????????£???°???\n\t\tindent_num = calc_index;\n\n\t\twork_index = 0;\n\n\t\tfor(;buf[calc_index] != ':';calc_index++){ //???????????§???????????????????????????????????£???key???????????????\n\t\t\twork[work_index++] = buf[calc_index];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tobj[ob_index].allocate(work_index);\n\t\tstrcpy(obj[ob_index].name,work); //???????????§???????????????????????????????????£???key????????????\n\n\t\twhile(S.empty() == false && S.top().indent >= indent_num)S.pop();\t//????????¨???????????????????????????????????§?????????????????????????????????????????????????????????pop\n\t\tif(S.empty()){ //???????´????????????´???\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tobj[S.top().address].children.push_back(ob_index); //???????´??????????????´??????????????????£??§?????????????????????????????¢?????¬???????¨??????????\n\t\t}\n\n\t\tif(buf[calc_index+1] == '\\n' || buf[calc_index+1] == '\\0'){ //key????????????value???object??§????????´???\n\t\t\tS.push(Info(indent_num,ob_index));\n\t\t\tob_index++;\n\t\t}else{ //key????????????value???string?????´???\n\t\t\tob_index++;;\n\t\t\twork_index = 0;\n\t\t\tcalc_index += 2;\n\t\t\tfor(;buf[calc_index] != '\\n' && buf[calc_index] != '\\0';calc_index++){\n\t\t\t\twork[work_index++] = buf[calc_index];\n\t\t\t}\n\t\t\twork[work_index] = '\\0';\n\n\t\t\tobj[ob_index].allocate(work_index);\n\t\t\tstrcpy(obj[ob_index].name,work);\n\n\t\t\tob_index++;\n\t\t}\n\n\t}\n\n\t//?????¨???????§£?????????\n\tbool FLG = false;\n\n\tint parse_index = 0,parse_address = -1,next_address,ans_index = 0;\n\tchar* ans = new char[50001];\n\tchar const_object[7] = \"object\";\n\n\twhile(true){\n\n\t\tif(query[parse_index] == '.'){\n\t\t\tparse_index++;\n\t\t}\n\t\twork_index = 0;\n\t\tfor(;query[parse_index] != '.' && query[parse_index] != '\\n' && query[parse_index] != '\\0';parse_index++){\n\t\t\twork[work_index++] = query[parse_index];\n\t\t}\n\t\twork[work_index] = '\\n';\n\n\t\tif(work_index == 0){ //?????¨??????????????????????????´???\n\t\t\tif(ans_index == 0){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tif(strCmp(ans,const_object)){\n\t\t\t\t\tprintf(\"%s\\n\",const_object);\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",ans);\n\t\t\t\t}\n\t\t\t\tFLG = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}else{ //??????????????£????????¨?????????????????¨??????????????\\???????§??????§?????????????????????\n\t\t\tif(parse_address == -1){ //????????????????´??????´???\n\t\t\t\tfor(int i = 0; i < ob_index;i++){\n\t\t\t\t\tif(strCmp(work,obj[i].name)){\n\t\t\t\t\t\tparse_address = i;\n\t\t\t\t\t\tif(obj[i].children.size() == 0){ //obj[i]???value?????´???\n\t\t\t\t\t\t\tparse_address = -1; //??????????§?????????????key????????????????????????????????§???value?????????????????????no such????????????????????????????????????\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(obj[i].children.size() == 1 && obj[obj[i].children[0]].children.size() == 0){ //value???????????????1????????????==:obj[i]???key???\n\t\t\t\t\t\t\t\tstrcpy(ans,obj[obj[i].children[0]].name);\n\t\t\t\t\t\t\t\tans_index = 50;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tstrcpy(ans,const_object);\n\t\t\t\t\t\t\t\tans_index = 7;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(parse_address == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{ //???????????¨????????´???\n\t\t\t\tnext_address = -1;\n\t\t\t\tfor(int i = 0; i < obj[parse_address].children.size();i++){\n\t\t\t\t\tif(strCmp(obj[obj[parse_address].children[i]].name,work)){\n\t\t\t\t\t\tnext_address = obj[parse_address].children[i];\n\n\t\t\t\t\t\tif(obj[next_address].children.size() == 0){ //obj[i]???value?????´???\n\t\t\t\t\t\t\tnext_address = -1; //??????????§?????????????key????????????????????????????????§???????????????????????????\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(obj[next_address].children.size() == 1 && obj[obj[next_address].children[0]].children.size() == 0){ //value???????????????1????????????==:obj[i]???key???\n\t\t\t\t\t\t\t\tstrcpy(ans,obj[obj[next_address].children[0]].name);\n\t\t\t\t\t\t\t\tans_index = 50;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tstrcpy(ans,const_object);\n\t\t\t\t\t\t\t\tans_index = 7;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(next_address == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tparse_address = next_address;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"no such property\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[24999];\nchar *q[9];\nchar L[19999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[99999];\nchar *q[99];\nchar L[99999];\nint ind[99];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nn;dfs(old_indent,depth){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin))puts(\"no such property\"),exit(0);\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent)puts(\"no such property\"),exit(0);\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1)\n\t\t\tif(*value)printf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse puts(\"object\"),exit(0);\n\t\tdfs(indent,depth+1);\n\t}\n\tdfs(old_indent,depth);\n}\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;dfs(-1,0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BLN 65536\n\nstatic char *p;\nstatic char *query;\nstatic char buffer[ BLN ];\n\nstruct line\n{\n  int ind;\n  char *a;\n  char *b;\n};\ntypedef struct line line;\nstatic line lp[ BLN ];\nstatic int ln = 0;\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  char *q, *nq;\n  int b, lv;\n\n  for ( p = buffer; ; )\n  {\n    q = fgets ( p, BLN - ( p - buffer ), stdin );\n    if ( q == NULL ) break ;\n    p = q + strlen ( q );\n  }\n\n  query = buffer;\n  p = strchr ( buffer, '\\n' );\n  *( p++ ) = '\\0';\n\n  for ( ; *p != '\\0' ; ++ln )\n  {\n    for ( lp[ ln ].ind = 0; *p == ' '; ++lp[ ln ].ind, ++p ) ;\n    lp[ ln ].a = p;\n    p = strchr ( p, ':' );\n    *( p++ ) = '\\0';\n    if ( *p == '\\n' )\n    {\n      lp[ ln ].b = NULL;\n      ++p;\n    }\n    else\n    {\n      lp[ ln ].b = ++p;\n      p = strchr ( p, '\\n' );\n      *( p++ ) = '\\0';\n    }\n  }\n\n  lv = 0; ++query;\n  nq = strchr ( query, '.' );\n  if ( nq != NULL )\n    *( nq++ ) = '\\0';\n  for ( b = 0; b < ln; ++b )\n  {\n    if ( lp[ b ].ind < lv )\n    {\n      b = ln;\n      continue ;\n    }\n    else if ( lp[ b ].ind > lv )\n      continue ;\n\n    if ( !strcmp ( lp[ b ].a, query ) )\n    {\n      if ( nq == NULL )\n      {\n        if ( lp[ b ].b == NULL )\n          puts ( \"object\" );\n        else\n          printf ( \"string \\\"%s\\\"\\n\", lp[ b ].b );\n        break ;\n      }\n      else if ( lp[ b ].b != NULL )\n      {\n        b = ln;\n        continue ;\n      }\n\n      query = nq;\n\n      nq = strchr ( query, '.' );\n      if ( nq != NULL )\n        *( nq++ ) = '\\0';\n\n      lv = lp[ b + 1 ].ind;\n    }\n  }\n  if ( b >= ln )\n    puts ( \"no such property\" );\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(buf,n,f);if(!r)return NULL;buf[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nint n;\ndfs(old_indent,depth){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent){puts(\"no such property\");exit(0);}\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tdfs(indent,depth+1);\n\t}\n\tdfs(old_indent,depth);\n}\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;dfs(-1,0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[99999];\nchar *q[9];\nchar L[99999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nn;D(old_indent,depth){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin))puts(\"no such property\"),exit(0);\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent)puts(\"no such property\"),exit(0);\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1)\n\t\t\tif(*value)printf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse puts(\"object\"),exit(0);\n\t\tD(indent,depth+1);\n\t}\n\tD(old_indent,depth);\n}\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;D(-1,0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[9999];\nchar *q[99];\nchar L[9999];\nint ind[999];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nint n;\ndfs(old_indent,depth){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent){puts(\"no such property\");exit(0);}\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tdfs(indent,depth+1);\n\t}\n\tdfs(old_indent,depth);\n}\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;dfs(-1,0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[29999],*q[9],L[29999];\nint n;\ndfs(old_indent,depth){\n\tint indent=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent){puts(\"no such property\");exit(0);}\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tdfs(indent,depth+1);\n\t}\n\tdfs(old_indent,depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(-1,0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2438: YAML\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar *property[21];\nchar *line[1000];\nchar buf[100010];\n\nint main()\n{\n\tint n, m, i, t, ln, indent, cnt;\n\tchar *p, *q, c;\n\n\tfgets(buf, 50010, stdin);\n\tn = 0, p = buf+1; while (*p >= ' ') {\n\t\tproperty[n++] = p;\n\t\twhile (*p >= ' ' && *p != '.') p++;\n\t\tif (*p == '.') *p++ = 0;\n\t}\n\t*p = 0;\n\n\tp++, m = 0;\n\twhile (fgets(p, 50010, stdin) != NULL) {\n\t\tline[m++] = p; while (*p >= ' ') p++;\n\t\t*p++ = 0;\n\t}\n\n\tln = indent = 0;\n\tfor (i = 0; i < n; i++) {\n\t\twhile (ln < m) {\n\t\t\tcnt = 0, p = line[ln];\n\t\t\twhile (*p == ' ') p++, cnt++;\n\t\t\tif (cnt < indent) goto done;\n\t\t\tif (cnt > indent) { ln++; continue; }\n\n\t\t\tq = p; while (*p && *p != ':') p++;\n\t\t\tc = *p, *p = 0;\n\t\t\tt = strcmp(q, property[i]);\n\t\t\t*p = c;\n\n\t\t\tif (t) { ln++; continue; }\n\t\t\tif (i == n-1) {\n\t\t\t\tif (*(p+1) == 0) puts(\"object\");\n\t\t\t\telse printf(\"string \\\"%s\\\"\\n\", p+2);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (ln >= m-1) goto done;\n\t\t\tindent = 0, p = line[++ln];\n\t\t\twhile (*p == ' ') p++, indent++;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tputs(\"no such property\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nn,old_indent=-1,depth=0;\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;for(;;){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin))puts(\"no such property\"),exit(0);\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent)puts(\"no such property\"),exit(0);\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(old_indent=indent,depth++,depth==n)\n\t\t\tif(*value)printf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse puts(\"object\"),exit(0);\n\t}\n}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[24999];\nchar *q[9];\nchar L[99999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[24999];\nchar *q[9];\nchar L[29999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[19999];\nchar *q[9];\nchar L[99999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[29999];\nchar *q[9];\nchar L[99999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[99999];\nchar *q[999];\nchar L[99999];\nint ind[9999];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nn,old_indent=-1,depth=0;\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;for(;;){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin))puts(\"no such property\"),exit(0);\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent)puts(\"no such property\"),exit(0);\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth]))if(old_indent=indent,depth++,depth==n)\n\t\tif(*value)printf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\telse puts(\"object\"),exit(0);\n}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BLN 65536\n\nstatic char *p;\nstatic char *query;\nstatic char buffer[ BLN ];\n\nstruct line\n{\n  int ind;\n  char *a;\n  char *b;\n};\ntypedef struct line line;\nstatic line lp[ BLN ];\nstatic int ln = 0;\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  char *q, *nq;\n  int b, lv;\n\n  for ( p = buffer; ; )\n  {\n    q = fgets ( p, BLN - ( p - buffer ), stdin );\n    if ( q == NULL ) break ;\n    p = q + strlen ( q );\n  }\n\n  query = buffer;\n  p = strchr ( buffer, '\\n' );\n  *( p++ ) = '\\0';\n\n  for ( ; *p != '\\0' ; ++ln )\n  {\n    for ( lp[ ln ].ind = 0; *p == ' '; ++lp[ ln ].ind, ++p ) ;\n    lp[ ln ].a = p;\n    p = strchr ( p, ':' );\n    *( p++ ) = '\\0';\n    if ( *p == '\\n' )\n    {\n      lp[ ln ].b = NULL;\n      ++p;\n    }\n    else\n    {\n      lp[ ln ].b = ++p;\n      p = strchr ( p, '\\n' );\n      *( p++ ) = '\\0';\n    }\n  }\n\n  lv = 0; ++query;\n  nq = strchr ( query, '.' );\n  if ( nq != NULL )\n    *( nq++ ) = '\\0';\n  for ( b = 0; b < ln; ++b )\n  {\n    if ( lp[ b ].ind < lv )\n    {\n      b = ln;\n      continue ;\n    }\n    if ( !strcmp ( lp[ b ].a, query ) )\n    {\n      if ( nq == NULL )\n      {\n        if ( lp[ b ].b == NULL )\n          puts ( \"object\" );\n        else\n          printf ( \"string \\\"%s\\\"\\n\", lp[ b ].b );\n        break ;\n      }\n\n      query = nq;\n\n      nq = strchr ( query, '.' );\n      if ( nq != NULL )\n        *( nq++ ) = '\\0';\n\n      lv += lp[ b ].ind + 1;\n    }\n  }\n  if ( b >= ln )\n    puts ( \"no such property\" );\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[19999];\nchar *q[9];\nchar L[19999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BLN 65536\n\nstatic char *p;\nstatic char *query;\nstatic char buffer[ BLN ];\n\nstruct line\n{\n  int ind;\n  char *a;\n  char *b;\n};\ntypedef struct line line;\nstatic line lp[ BLN ];\nstatic int ln = 0;\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  char *q, *nq;\n  int b, lv;\n\n  for ( p = buffer; ; )\n  {\n    q = fgets ( p, BLN - ( p - buffer ), stdin );\n    if ( q == NULL ) break ;\n    p = q + strlen ( q );\n  }\n\n  query = buffer;\n  p = strchr ( buffer, '\\n' );\n  *( p++ ) = '\\0';\n\n  for ( ; *p != '\\0' ; ++ln )\n  {\n    for ( lp[ ln ].ind = 0; *p == ' '; ++lp[ ln ].ind, ++p ) ;\n    lp[ ln ].a = p;\n    p = strchr ( p, ':' );\n    *( p++ ) = '\\0';\n    if ( *p == '\\n' )\n    {\n      lp[ ln ].b = NULL;\n      ++p;\n    }\n    else\n    {\n      lp[ ln ].b = ++p;\n      p = strchr ( p, '\\n' );\n      *( p++ ) = '\\0';\n    }\n  }\n\n  lv = 0; ++query;\n  nq = strchr ( query, '.' );\n  if ( nq != NULL )\n    *( nq++ ) = '\\0';\n  for ( b = 0; b < ln; ++b )\n  {\n    if ( lp[ b ].ind != lv )\n    {\n      b = ln;\n      continue ;\n    }\n    if ( !strcmp ( lp[ b ].a, query ) )\n    {\n      if ( nq == NULL )\n      {\n        if ( lp[ b ].b == NULL )\n          puts ( \"object\" );\n        else\n          printf ( \"string \\\"%s\\\"\\n\", lp[ b ].b );\n        break ;\n      }\n      else if ( lp[ b ].b != NULL )\n      {\n        b = ln;\n        continue ;\n      }\n\n      query = nq;\n\n      nq = strchr ( query, '.' );\n      if ( nq != NULL )\n        *( nq++ ) = '\\0';\n\n      lv = lp[ b + 1 ].ind;\n    }\n  }\n  if ( b >= ln )\n    puts ( \"no such property\" );\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nn;D(old_indent,depth){}\nold_indent=-1,depth=0;\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;for(;;){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin))puts(\"no such property\"),exit(0);\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent)puts(\"no such property\"),exit(0);\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1)\n\t\t\tif(*value)printf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse puts(\"object\"),exit(0);\n\t\told_indent=indent,depth++;\n\t}\n}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[24999];\nchar *q[9];\nchar L[29999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[24999];\nchar *q[9];\nchar L[24999];\nint ind[9];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[99999];\nchar *q[999];\nchar L[99999];\nint ind[9999];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2438: YAML\n// 2017.12.30 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar *property[21];\nchar *line[1000];\nchar buf[50010];\n\nint main()\n{\n\tint n, m, i, t, ln, indent, cnt;\n\tchar *p, *q, c;\n\n\tfgets(buf, 1000, stdin);\n\tn = 0, p = buf+1; while (*p >= ' ') {\n\t\tproperty[n++] = p;\n\t\twhile (*p >= ' ' && *p != '.') p++;\n\t\tif (*p == '.') *p++ = 0;\n\t}\n\t*p = 0;\n\n\tp++, m = 0;\n\twhile (fgets(p, 1000, stdin) != NULL) {\n\t\tline[m++] = p; while (*p >= ' ') p++;\n\t\t*p++ = 0;\n\t}\n\n\tln = indent = 0;\n\tfor (i = 0; i < n; i++) {\n\t\twhile (ln < m) {\n\t\t\tcnt = 0, p = line[ln];\n\t\t\twhile (*p == ' ') p++, cnt++;\n\t\t\tif (cnt < indent) goto done;\n\t\t\tif (cnt > indent) { ln++; continue; }\n\n\t\t\tq = p; while (*p && *p != ':') p++;\n\t\t\tc = *p, *p = 0;\n\t\t\tt = strcmp(q, property[i]);\n\t\t\t*p = c;\n\n\t\t\tif (t) { ln++; continue; }\n\t\t\tif (i == n-1) {\n\t\t\t\tif (*(p+1) == 0) puts(\"object\");\n\t\t\t\telse printf(\"string \\\"%s\\\"\\n\", p+2);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (ln >= m-1) goto done;\n\t\t\tindent = 0, p = line[++ln];\n\t\t\twhile (*p == ' ') p++, indent++;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tputs(\"no such property\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\nchar* myfgets(char *buf,int n,FILE *fp){ //accepts LF/CRLF\n\tchar *ret=fgets(buf,n,fp);\n\tif(!ret)return NULL;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\n')buf[strlen(buf)-1]=0;\n\tif(strlen(buf)&&buf[strlen(buf)-1]=='\\r')buf[strlen(buf)-1]=0;\n\treturn ret;\n}\n\nchar Q[9999];\nchar *q[999];\nchar L[99999];\nint ind[9999];\nint n;\ndfs(depth){\n\tint cur_ind=0;\n\tif(!myfgets(L,sizeof(L),stdin)){puts(\"no such property\");exit(0);}\n\tif(depth){\n\t\tfor(;L[cur_ind]==' ';cur_ind++);\n\t\tif(ind[depth-1]>=cur_ind){puts(\"no such property\");exit(0);}\n\t}\n\tchar *name=strtok(L+cur_ind,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1){\n\t\t\tif(*value)\n\t\t\t\tprintf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse\n\t\t\t\tputs(\"object\"),exit(0);\n\t\t}\n\t\tind[depth]=cur_ind;\n\t\tdfs(depth+1);\n\t}\n\tdfs(depth);\n}\n\nmain(depth){\n\tmyfgets(Q,sizeof(Q),stdin);\n\tq[0]=strtok(Q+1,\".\");\n\tfor(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;\n\tdfs(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nchar* F(char *b,int n,FILE *f){char *r=fgets(b,n,f);if(!r)return NULL;b[strlen(b)-1]=0;return r;}\nchar Q[29999],*q[9],L[29999];\nn;D(old_indent,depth){for(;;){\n\tint indent=0;\n\tif(!F(L,sizeof(L),stdin))puts(\"no such property\"),exit(0);\n\tfor(;L[indent]==' ';indent++);\n\tif(old_indent>=indent)puts(\"no such property\"),exit(0);\n\tchar *name=strtok(L+indent,\":\"),*value=name+strlen(name)+1;\n\tif(!strcmp(name,q[depth])){\n\t\tif(depth==n-1)\n\t\t\tif(*value)printf(\"string \\\"%s\\\"\\n\",value+1),exit(0);\n\t\t\telse puts(\"object\"),exit(0);\n\t\told_indent=indent,depth++;\n\t}\n}}\nmain(){F(Q,sizeof(Q),stdin);q[0]=strtok(Q+1,\".\");for(n=1;;n++)if(!(q[n]=strtok(NULL,\".\")))break;D(-1,0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar query[50004];\nchar buffer[50004];\n\nint gets2(char* row,int len) {\n\tchar* lf;\n\tif(!fgets(row,len,stdin))return 0;\n\tlf=strchr(row,'\\n');\n\tif(lf)*lf=0;\n\treturn 1;\n}\n\nint main(void) {\n\tchar* nowquery=NULL;\n\tint currentindent;\n\tint isobject;\n\tint found;\n\tint previsstring;\n\tchar* thestring;\n\tgets2(query,sizeof(query));\n\tcurrentindent=0;\n\tprevisstring=0;\n\tfound=1;\n\twhile(found && (nowquery=strtok(nowquery?NULL:query,\".\"))) {\n\t\tfound=0;\n\t\tcurrentindent=-1;\n\t\tif(previsstring)break;\n\t\twhile(gets2(buffer,sizeof(buffer))) {\n\t\t\tchar* kugiri;\n\t\t\tchar* start;\n\t\t\tint nowindent;\n\t\t\tfor(start=buffer;*start==' ';start++);\n\t\t\tkugiri=strchr(start,':');\n\t\t\tif(kugiri==NULL)return 1;/* sintax error */\n\t\t\tnowindent=(int)(start-buffer);\n\t\t\tif(currentindent<0)currentindent=nowindent;\n\t\t\tif(nowindent!=currentindent)continue;\n\t\t\t*kugiri=0;\n\t\t\tif(strcmp(start,nowquery)==0) {\n\t\t\t\tfound=1;\n\t\t\t\tprevisstring=(*(kugiri+1)==' ');\n\t\t\t\tif(previsstring)thestring=kugiri+2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(found) {\n\t\tif(previsstring) {\n\t\t\tprintf(\"string \\\"%s\\\"\\n\",thestring);\n\t\t} else {\n\t\t\tputs(\"object\");\n\t\t}\n\t} else {\n\t\tputs(\"no such property\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tLinkedList<String> stack;\n\tHashMap<String,HashSet<String> > map;\n\tString [] keys;\n\tHashSet<String>map0;\n\t\n\tprivate void doit(){\n\t\t\n\t\tkeys = sc.nextLine().split(\"\\\\.\");\n\t\tmap0 = new HashSet<String>();\n\t\tstack = new LinkedList<String>();\n\t\tmap = new HashMap<String, HashSet<String>>();\n\t\tmapping(0);\n\t\tcheck();\n//\t\t\n//\t\t//debug\n//\t\tfor(int i = 0; i < keys.length; i++){\n//\t\t\tSystem.out.println(\"i=\" + i + \":\" + keys[i] + \".\");\n//\t\t}\n//\t\tSystem.out.println(keys.length);\n//\t\t\n//\t\t//debug\n//\t\tfor(String key: map.keySet()){\n//\t\t\tSystem.out.println(\"key=\" + key +\" \"+ \"valu=\"+map.get(key));\n//\t\t}\n//\t\tSystem.out.println();\n\t\t\n\t}\n\t\n\t\n\n\tprivate void check() {\n\t\tif(! map0.contains(keys[1])){\n\t\t\tSystem.out.println(\"no such property\");\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i < keys.length; i++){\n\t\t\tif(map.containsKey(keys[i])){\n\t\t\t\tif(i == 1) continue;\n\t\t\t\tHashSet<String> temp = map.get(keys[i-1]);\n\t\t\t\tif(temp.contains(keys[i])){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"no such property\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"no such property\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tString now = keys[keys.length-1];\n\t\tHashSet<String> hs = map.get(now);\n\t\tif(hs.size() > 1){\n\t\t\tSystem.out.println(\"object\");\n\t\t}\n\t\telse {\n\t\t\tString value = \"\";\n\t\t\tfor(String s: hs){\n\t\t\t\tvalue = s;\n\t\t\t}\n\t\t\tif(map.containsKey(value) && ! value.equals(now)){\n\t\t\t\tSystem.out.println(\"object\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"string \\\"\" + value +\"\\\"\");\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tprivate HashSet<String> mapping(int n) {\n\t\tHashSet<String> res = new HashSet<String>();\n\t\twhile(true){\n\t\t\tString line = gettoken();\n\t\t\tif(line == null) return res;\n\t\t\tint count = ci(line);\n\t\t\tif(count == n){\n\t\t\t\tString [] arr = line.split(\":\");\n\t\t\t\tString key = arr[0].trim();\n\t\t\t\tres.add(key);\n\t\t\t\tif(n == 0){\n\t\t\t\t\tmap0.add(key);\n\t\t\t\t}\n\t\t\t\tmappingItem(n, line);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstack.add(line);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tprivate void mappingItem(int n, String line) {\n\t\tString [] arr = line.split(\":\");\n\t\tString key = arr[0].trim();\n\t\tif(arr.length == 1){\n\t\t\tString nline = gettoken();\n\t\t\tif(nline == null) return;\n\t\t\tint m = ci(nline);\n\t\t\tstack.add(nline);\n\t\t\tHashSet<String> value = mapping(m);\n\t\t\tmap.put(key, value);\n\t\t}\n\t\telse{\n\t\t\tHashSet<String> value = new HashSet<String>();\n\t\t\tvalue.add(arr[1].substring(1));\n\t\t\tmap.put(key, value);\n\t\t}\n\t\t\n\t}\n\n\tprivate String gettoken() {\n\t\tif(! stack.isEmpty()){\n\t\t\treturn stack.removeLast();\n\t\t}\n\t\tif(sc.hasNext()){\n\t\t\treturn sc.nextLine();\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate int ci(String line) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < line.length(); i++){\n\t\t\tif(line.charAt(i) != ' '){\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> lines = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tlines.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tString line1 = lines.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = lines.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop<Obj>(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop<String>(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tObject value = null;\n\t\twhile (query.hasMoreTokens()) {\n\t\t\tvalue = obj.get(query.nextToken());\n\t\t\tif (value == null) break;\n\t\t\tif (value instanceof Obj) {\n\t\t\t\tobj = (Obj) value;\n\t\t\t} else {\n\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\tvalue = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (value == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (value instanceof String) {\n\t\t\tans = \"string \\\"\" + value + \"\\\"\";\n\t\t} else if (value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tObject get(String key) {\n\t\t\tif (props.containsKey(key)) {\n\t\t\t\treturn props.get(key).value;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// YAML\n// 2012/10/29\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tString query;\n\tArrayList<String> ss;\n\n\tvoid run(){\n\t\tquery=sc.nextLine();\n\t\tss=new ArrayList<String>();\n\t\tfor(; sc.hasNextLine();){\n\t\t\tss.add(sc.nextLine());\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tNode root=new Node(\"\", \"\", -1, null);\n\t\tNode node=root;\n\t\tfor(String line : ss){\n\t\t\tint depth=line.length();\n\t\t\tline=line.replaceAll(\"^ *\", \"\");\n\t\t\tdepth-=line.length();\n\t\t\tfor(; depth<=node.depth; node=node.parent);\n\t\t\tif(line.charAt(line.length()-1)==':'){\n\t\t\t\tNode child=new Node(line.substring(0, line.length()-1), null,\n\t\t\t\t\t\tdepth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}else{\n\t\t\t\tString key=line.split(\": \")[0];\n\t\t\t\tString value=line.split(\": \")[1];\n\t\t\t\tNode child=new Node(key, value, depth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t}\n\t\t}\n\n\t\tString ans;\n\t\tnode=root;\n\t\tfor(String s : query.substring(1).split(\"\\\\.\")){\n\t\t\tif(node.children.containsKey(s)){\n\t\t\t\tnode=node.children.get(s);\n\t\t\t}else{\n\t\t\t\tnode=null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(node==null){\n\t\t\tans=\"no such property\";\n\t\t}else if(node.children.size()>0){\n\t\t\tans=\"object\";\n\t\t}else{\n\t\t\tans=\"string \\\"\"+node.value+\"\\\"\";\n\t\t}\n\t\tprintln(ans);\n\t}\n\n\tclass Node{\n\t\tString key, value;\n\t\tint depth;\n\t\tNode parent;\n\t\tHashMap<String, Node> children;\n\n\t\tNode(String key, String value, int depth, Node parent){\n\t\t\tthis.key=key;\n\t\t\tthis.value=value;\n\t\t\tthis.depth=depth;\n\t\t\tthis.parent=parent;\n\t\t\tchildren=new HashMap<String, Node>();\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import com.sun.istack.internal.NotNull;\nimport com.sun.istack.internal.Nullable;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> lines = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tlines.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tString line1 = lines.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = lines.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop<Obj>(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop<String>(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tObject value = null;\n\t\twhile (query.hasMoreTokens()) {\n\t\t\tvalue = obj.get(query.nextToken());\n\t\t\tif (value == null) break;\n\t\t\tif (value instanceof Obj) {\n\t\t\t\tobj = (Obj) value;\n\t\t\t} else {\n\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\tvalue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (value == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (value instanceof String) {\n\t\t\tans = \"string \\\"\" + value + \"\\\"\";\n\t\t} else if (value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tObject get(String key) {\n\t\t\treturn props.get(key).value;\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString[] input = scan.nextLine().split(java.util.regex.Pattern.quote(\".\"));\n\t\t//System.out.println(Arrays.toString(input));\n\t\tStack<Integer> indentLengths = new Stack<>();\n\t\tint maxDepth = 0;\n\t\tindentLengths.push(0);\n\t\twhile(scan.hasNext()) {\n\t\t\tString[] line = scan.nextLine().split(\":\");\n\t\t\tint indents = 0;\n\t\t\tfor(char c : line[0].toCharArray()) if(c==' ')indents++;else break;\n\t\t\tline[0] = line[0].substring(indents);\n\t\t\t//System.out.println(Arrays.toString(line));\n\t\t\t//System.out.println(indentLengths.peek()+\",\"+indents+\",\"+indentLengths.size()+\",\"+maxDepth);\n\t\t\tif(indentLengths.peek()==indents) {\n\t\t\t\t//tannsaku keizoku\n\t\t\t}\n\t\t\telse if(indentLengths.peek()<indents) {\n\t\t\t\tindentLengths.push(indents);\n\t\t\t\t//more kaisou\n\t\t\t}else {\n\t\t\t\twhile(indentLengths.peek() == indents) {\n\t\t\t\t\tindentLengths.pop();\n\t\t\t\t}\n\t\t\t\tif(indentLengths.size()<=maxDepth) break;\n\t\t\t}\n\t\t\tif(input.length>indentLengths.size() && input[indentLengths.size()].equals(line[0])) {\n\t\t\t\tmaxDepth++;\n\t\t\t\tif(maxDepth+1==input.length) {\n\t\t\t\t\tif(line.length==1) System.out.println(\"object\");\n\t\t\t\t\telse System.out.println(\"string \\\"\"+line[1].substring(1)+\"\\\"\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(indentLengths.peek()+\",\"+indents+\",\"+indentLengths.size()+\",\"+maxDepth);\n\t\t}\n\t\tSystem.out.println(\"no such property\");\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    String value = \"\";\n    HashMap<String, Node> map = new HashMap<>();\n  }\n\n  class Ret {\n    int index;\n    Node node = new Node();\n  }\n\n  class RetKey {\n    int index;\n    String key;\n  }\n\n  RetKey parseKey(int index, String str) {\n//    debug(\"PARSE KEY\");\n//    for (int i = 0; i < str.length(); ++i) {\n//      if (str.charAt(i) == '\\n') {\n//        System.err.print('<');\n//      } else {\n//        System.err.print(str.charAt(i));\n//      }\n//    }\n//    System.err.println();\n//    for (int i = 0; i < index; ++i) {\n//      System.err.print(\" \");\n//    }\n//    System.err.println(\"^\");\n    StringBuilder sb = new StringBuilder();\n    for (; ; ) {\n      char c = str.charAt(index);\n      if (!Character.isDigit(c) && !Character.isAlphabetic(c)) {\n        break;\n      }\n      sb.append(c);\n      ++index;\n    }\n    RetKey r = new RetKey();\n    r.index = index;\n    r.key = sb.toString();\n    return r;\n  }\n\n  Ret parseObj(int index, String str, int indent) {\n//    debug(\"PARSE OBJ\");\n//    for (int i = 0; i < str.length(); ++i) {\n//      if (str.charAt(i) == '\\n') {\n//        System.err.print('<');\n//      } else {\n//        System.err.print(str.charAt(i));\n//      }\n//    }\n//    System.err.println();\n//    for (int i = 0; i < index; ++i) {\n//      System.err.print(\" \");\n//    }\n//    System.err.println(\"^\");\n    Ret ret = new Ret();\n    if (str.charAt(index) == '\\n') {\n      ++index;\n      int j = 0;\n      while (str.charAt(index + j) == ' ') {\n        ++j;\n      }\n      index += j;\n      return parseObj(index, str, j);\n    } else if (indent > 0) {\n      for (; ; ) {\n        RetKey key = parseKey(index, str);\n        assert str.charAt(key.index) == ':';\n        Ret obj = parseObj(key.index + 1, str, 0);\n        ret.node.map.put(key.key, obj.node);\n        index = obj.index;\n        int j = 0;\n//        debug(index, str.length());\n        while (str.charAt(index + j) == ' ') {\n          ++j;\n        }\n//        debug(indent, j);\n        if (indent != j) {\n          break;\n        }\n        index += j;\n      }\n      ret.index = index;\n//      debug(\"\\t\\t\", \"RETURN OBJ : \", ret.node.map.size());\n      return ret;\n    } else {\n      assert str.charAt(index) == ' ';\n      ++index;\n      StringBuilder sb = new StringBuilder();\n      while (str.charAt(index) != '\\n') {\n        sb.append(str.charAt(index++));\n      }\n      ++index;\n      ret.index = index;\n      ret.node.value = sb.toString();\n//      debug(\"\\t\\t\", \"RETURN VALUE :\", sb.toString());\n      return ret;\n    }\n  }\n\n  Ret parse(int index, String str) {\n    Ret ret = new Ret();\n    while (index < str.length() - 1) {\n//      debug(index);\n      RetKey retKey = parseKey(index, str);\n      String key = retKey.key;\n      index = retKey.index;\n//      debug(index, str.charAt(index));\n      assert str.charAt(index) == ':';\n      ++index;\n      Ret obj = parseObj(index, str, 0);\n      index = obj.index;\n      ret.node.map.put(key, obj.node);\n    }\n    return ret;\n  }\n\n  void run() {\n    String q = sc.nextLine();\n    StringBuilder sb = new StringBuilder();\n    while (sc.hasNext()) {\n      sb.append(sc.nextLine());\n      sb.append('\\n');\n    }\n    sb.append('\\n');\n    Ret ret = parse(0, sb.toString());\n    String[] a = q.split(\"\\\\.\");\n    Node node = ret.node;\n    for (int i = 1; i < a.length; ++i) {\n      String key = a[i];\n      if (!node.map.containsKey(key)) {\n        node = null;\n        break;\n      }\n      node = node.map.get(key);\n    }\n    if (node == null) {\n      System.out.println(\"no such property\");\n    } else {\n      if (node.value.length() == 0) {\n        System.out.println(\"object\");\n      } else {\n        System.out.println(\"string \\\"\" + node.value + \"\\\"\");\n      }\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "package aoj.volume24.jags2012;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> lines = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tlines.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tString line1 = lines.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = lines.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop<Obj>(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop<String>(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tObject value = null;\n\t\twhile ((value = obj.get(query.nextToken())) != null) {\n\t\t\tif (value instanceof Obj) {\n\t\t\t\tobj = (Obj) value;\n\t\t\t} else {\n\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\tvalue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (value == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (value instanceof String) {\n\t\t\tans = \"string \\\"\" + value + \"\\\"\";\n\t\t} else if (value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tObject get(String key) {\n\t\t\treturn props.get(key).value;\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tString q=s.nextLine();\n\t//\tSystem.out.println(q);\n\t\tString[]key=q.split(\"\\\\.\");\n\t//\tSystem.out.println(key.length);\n\t//\tfor(int i=0;i<key.length;i++)System.out.println(key[i]);\n\t\tint now=1;\n\t\tint n=key.length;\n\t\tint d[]=new int[120];\n\t\tfor(int i=0;i<120;i++)d[i]=-1;\n\t\td[1]=0;\n\t\tboolean ok=false;\n\t\twhile(s.hasNext()){\n\t\t\tString str=s.nextLine();\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<str.length();i++){\n\t\t\t\tif(str.charAt(i)!=' ')break;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(d[now]==-1)d[now]=cnt;\n\t\t\twhile(cnt<d[now]){\n\t\t\t\td[now]=-1;\n\t\t\t\tnow--;\n\t\t\t}\n\t\t\tString tmp=str.split(\":\")[0].substring(cnt);\n\t\t//\tSystem.out.println(tmp);\n\t\t\tif(tmp.equals(key[now])){\n\t\t\t\tnow++;\n\t\t\t\tif(n==now){\n\t\t\t\t\tif(str.split(\":\").length>1)System.out.println(\"string \\\"\"+str.split(\":\")[1].substring(1)+\"\\\"\");\n\t\t\t\t\telse System.out.println(\"object\");\n\t\t\t\t\tok=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok)System.out.println(\"no such property\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * YAML\n */\npublic class P2438 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tP2438 main = new P2438();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> yaml = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tyaml.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < yaml.size(); i++) {\n\t\t\tString line1 = yaml.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = yaml.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop<Obj>(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop<String>(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tProp prop = null;\n\t\twhile (query.hasMoreTokens()) {\n\t\t\tif ((prop = obj.get(query.nextToken())) != null) {\n\t\t\t\tif (prop.value instanceof Obj) {\n\t\t\t\t\tobj = (Obj) prop.value;\n\t\t\t\t} else {\n\t\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\t\tprop = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (prop == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (prop.value instanceof String) {\n\t\t\tans = \"string \\\"\" + prop.value + \"\\\"\";\n\t\t} else if (prop.value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tProp get(String key) {\n\t\t\treturn props.get(key);\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[] input;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\tString[] q = sc.nextLine().split(\"\\\\.\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (sc.hasNext()) {\n\t\t\tsb.append(sc.nextLine() + \"\\n\");\n\t\t}\n\t\tinput = sb.toString().toCharArray();\n\t\tElem elem = parseMapping(0);\n\t\tfor (int i = 1; i < q.length && elem != null; ++i) {\n\t\t\telem = elem.get(q[i]);\n\t\t}\n\t\tSystem.out.println(elem == null ? \"no such property\" : elem.toString());\n\t}\n\n\tstatic Mapping parseMapping(int indent) {\n\t\tMapping mapping = new Mapping();\n\t\twhile (true) {\n\t\t\tint n = nextIndent();\n\t\t\tif (n != indent) break;\n\t\t\tpos += indent;\n\t\t\tint sp = pos;\n\t\t\twhile (input[pos] != ':') {\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\tString key = String.valueOf(input, sp, pos - sp);\n\t\t\t++pos;\n\t\t\tif (input[pos] == '\\n') {\n\t\t\t\t++pos;\n\t\t\t\tint m = nextIndent();\n\t\t\t\tMapping child = parseMapping(m);\n\t\t\t\tmapping.map.put(key, child);\n\t\t\t} else {\n\t\t\t\t++pos;\n\t\t\t\tsp = pos;\n\t\t\t\twhile (input[pos] != '\\n') {\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\tmapping.map.put(key, new Str(String.valueOf(input, sp, pos - sp)));\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\t\treturn mapping;\n\t}\n\n\tstatic int nextIndent() {\n\t\tint cur = pos;\n\t\tif (cur >= input.length) return -1;\n\t\twhile (input[cur] == ' ') {\n\t\t\t++cur;\n\t\t}\n\t\treturn cur - pos;\n\t}\n\n\tstatic abstract class Elem {\n\t\tabstract Elem get(String key);\n\t}\n\n\tstatic class Mapping extends Elem {\n\t\tHashMap<String, Elem> map = new HashMap<String, Elem>();\n\n\t\tElem get(String key) {\n\t\t\treturn map.get(key);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"object\";\n\t\t}\n\t}\n\n\tstatic class Str extends Elem {\n\t\tString v;\n\n\t\tStr(String s) {\n\t\t\tthis.v = s;\n\t\t}\n\n\t\tElem get(String key) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[] input;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\tString[] q = sc.nextLine().split(\"\\\\.\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (sc.hasNext()) {\n\t\t\tsb.append(sc.nextLine() + \"\\n\");\n\t\t}\n\t\tinput = sb.toString().toCharArray();\n\t\tElem elem = parseMapping(0);\n\t\tfor (int i = 1; i < q.length && elem != null; ++i) {\n\t\t\telem = elem.get(q[i]);\n\t\t}\n\t\tSystem.out.println(elem == null ? \"no such property\" : elem.toString());\n\t}\n\n\tstatic Mapping parseMapping(int indent) {\n\t\tMapping mapping = new Mapping();\n\t\twhile (true) {\n\t\t\tint n = nextIndent();\n\t\t\tif (n != indent) break;\n\t\t\tpos += indent;\n\t\t\tint sp = pos;\n\t\t\twhile (input[pos] != ':') {\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\tString key = String.valueOf(input, sp, pos - sp);\n\t\t\t++pos;\n\t\t\tif (input[pos] == '\\n') {\n\t\t\t\t++pos;\n\t\t\t\tint m = nextIndent();\n\t\t\t\tMapping child = parseMapping(m);\n\t\t\t\tmapping.map.put(key, child);\n\t\t\t} else {\n\t\t\t\t++pos;\n\t\t\t\tsp = pos;\n\t\t\t\twhile (input[pos] != '\\n') {\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\tmapping.map.put(key, new Str(String.valueOf(input, sp, pos - sp)));\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\t\treturn mapping;\n\t}\n\n\tstatic int nextIndent() {\n\t\tint cur = pos;\n\t\tif (cur >= input.length) return -1;\n\t\twhile (input[cur] == ' ') {\n\t\t\t++cur;\n\t\t}\n\t\treturn cur - pos;\n\t}\n\n\tstatic abstract class Elem {\n\t\tabstract Elem get(String key);\n\t}\n\n\tstatic class Mapping extends Elem {\n\t\tHashMap<String, Elem> map = new HashMap<String, Elem>();\n\n\t\tElem get(String key) {\n\t\t\treturn map.get(key);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"object\";\n\t\t}\n\n\t\tvoid print(int indent) {\n\t\t\tfor (String key : map.keySet()) {\n\t\t\t\tfor (int i = 0; i < indent; ++i) {\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.print(key + \":\");\n\t\t\t\tElem obj = map.get(key);\n\t\t\t\tif (obj instanceof Mapping) {\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t((Mapping) obj).print(indent + 1);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(((Str) obj).v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Str extends Elem {\n\t\tString v;\n\n\t\tStr(String s) {\n\t\t\tthis.v = s;\n\t\t}\n\n\t\tElem get(String key) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"string \\\"\" + v + \"\\\"\";\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString[] input = scan.nextLine().split(java.util.regex.Pattern.quote(\".\"));\n\t\t//System.out.println(Arrays.toString(input));\n\t\tStack<Integer> indentLengths = new Stack<>();\n\t\tint maxDepth = 0;\n\t\tindentLengths.push(0);\n\t\twhile(scan.hasNext()) {\n\t\t\tString[] line = scan.nextLine().split(\":\");\n\t\t\tint indents = 0;\n\t\t\tfor(char c : line[0].toCharArray()) if(c==' ')indents++;else break;\n\t\t\tline[0] = line[0].substring(indents);\n\t\t\t//System.out.println(Arrays.toString(line));\n\t\t\t//System.out.println(indentLengths.peek()+\",\"+indents+\",\"+indentLengths.size()+\",\"+maxDepth);\n\t\t\tif(indentLengths.peek()==indents) {\n\t\t\t\t//tannsaku keizoku\n\t\t\t}\n\t\t\telse if(indentLengths.peek()<indents) {\n\t\t\t\tindentLengths.push(indents);\n\t\t\t\t//more kaisou\n\t\t\t}else {\n\t\t\t\twhile(indentLengths.peek() != indents) {\n\t\t\t\t\tindentLengths.pop();\n\t\t\t\t}\n\t\t\t\tif(indentLengths.size()<=maxDepth) break;\n\t\t\t}\n\t\t\tif(input.length>indentLengths.size() && input[indentLengths.size()].equals(line[0])) {\n\t\t\t\tmaxDepth++;\n\t\t\t\tif(maxDepth+1==input.length) {\n\t\t\t\t\tif(line.length==1) System.out.println(\"object\");\n\t\t\t\t\telse System.out.println(\"string \\\"\"+line[1].substring(1)+\"\\\"\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(indentLengths.peek()+\",\"+indents+\",\"+indentLengths.size()+\",\"+maxDepth);\n\t\t}\n\t\tSystem.out.println(\"no such property\");\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString query;\n\tArrayList<String> ss;\n\n\tvoid run(){\n\t\tquery=sc.nextLine();\n\t\tss=new ArrayList<String>();\n\t\tfor(; sc.hasNextLine();){\n\t\t\tss.add(sc.nextLine());\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tNode root=new Node(\"\", \"\", -1, null);\n\t\tNode node=root;\n\t\tfor(String line : ss){\n\t\t\tint depth=line.length()-line.trim().length();\n\t\t\tline=line.trim();\n\t\t\tfor(; depth<=node.depth; node=node.parent);\n\t\t\tif(line.charAt(line.length()-1)==':'){\n\t\t\t\t// 次にいく\n\t\t\t\tNode child=new Node(line.substring(0, line.length()-1), null,\n\t\t\t\t\t\tdepth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}else{\n\t\t\t\tString key=line.split(\": \")[0];\n\t\t\t\tString value=line.split(\": \")[1];\n\t\t\t\tNode child=new Node(key, value, depth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}\n\t\t}\n\t\tif(false){\n\t\t\tLinkedList<Node> stack=new LinkedList<Node>();\n\t\t\tstack.push(root);\n\t\t\tfor(; !stack.isEmpty();){\n\t\t\t\tnode=stack.pop();\n\t\t\t\tString s=\"\";\n\t\t\t\tfor(int i=0; i<node.depth; i++){\n\t\t\t\t\ts+=\" \";\n\t\t\t\t}\n\t\t\t\ts+=node.key+\":\"+node.value;\n\t\t\t\tdebug(s);\n\t\t\t\tfor(Node child : node.children.values()){\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString ans;\n\t\tnode=root;\n\t\tfor(String s : query.substring(1).split(\"\\\\.\")){\n\t\t\tif(node.children.containsKey(s)){\n\t\t\t\tnode=node.children.get(s);\n\t\t\t}else{\n\t\t\t\tnode=null;\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tdebug(node.depth, node.key, node.value);\n\t\t}\n\t\tif(node==null){\n\t\t\tans=\"no such property\";\n\t\t}else if(node.children.size()>0){\n\t\t\tans=\"object\";\n\t\t}else{\n\t\t\tans=\"string: \\\"\"+node.value+\"\\\"\";\n\t\t}\n\t\tprintln(ans);\n\t}\n\n\tclass Node{\n\t\tString key, value;\n\t\tint depth;\n\t\tNode parent;\n\t\tHashMap<String, Node> children;\n\n\t\tNode(String key, String value, int depth, Node parent){\n\t\t\tthis.key=key;\n\t\t\tthis.value=value;\n\t\t\tthis.depth=depth;\n\t\t\tthis.parent=parent;\n\t\t\tchildren=new HashMap<String, Node>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString query;\n\tArrayList<String> ss;\n\n\tvoid run(){\n\t\tquery=sc.nextLine();\n\t\tss=new ArrayList<String>();\n\t\tfor(; sc.hasNextLine();){\n\t\t\tss.add(sc.nextLine());\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tNode root=new Node(\"\", \"\", -1, null);\n\t\tNode node=root;\n\t\tfor(String line : ss){\n\t\t\tint depth=line.length()-line.trim().length();\n\t\t\tline=line.trim();\n\t\t\tfor(; depth<=node.depth; node=node.parent);\n\t\t\tif(line.charAt(line.length()-1)==':'){\n\t\t\t\t// 次にいく\n\t\t\t\tNode child=new Node(line.substring(0, line.length()-1), null,\n\t\t\t\t\t\tdepth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}else{\n\t\t\t\tString key=line.split(\": \")[0];\n\t\t\t\tString value=line.split(\": \")[1];\n\t\t\t\tNode child=new Node(key, value, depth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}\n\t\t}\n\t\tif(false){\n\t\t\tLinkedList<Node> stack=new LinkedList<Node>();\n\t\t\tstack.push(root);\n\t\t\tfor(; !stack.isEmpty();){\n\t\t\t\tnode=stack.pop();\n\t\t\t\tString s=\"\";\n\t\t\t\tfor(int i=0; i<node.depth; i++){\n\t\t\t\t\ts+=\" \";\n\t\t\t\t}\n\t\t\t\ts+=node.key+\":\"+node.value;\n\t\t\t\tdebug(s);\n\t\t\t\tfor(Node child : node.children.values()){\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString ans;\n\t\tnode=root;\n\t\tfor(String s : query.substring(1).split(\"\\\\.\")){\n\t\t\tif(node.children.containsKey(s)){\n\t\t\t\tnode=node.children.get(s);\n\t\t\t}else{\n\t\t\t\tnode=null;\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tdebug(node.depth, node.key, node.value);\n\t\t}\n\t\tif(node==null){\n\t\t\tans=\"no such property\";\n\t\t}else if(node.children.size()>0){\n\t\t\tans=\"object\";\n\t\t}else{\n\t\t\tans=\"string \\\"\"+node.value+\"\\\"\";\n\t\t}\n\t\tprintln(ans);\n\t}\n\n\tclass Node{\n\t\tString key, value;\n\t\tint depth;\n\t\tNode parent;\n\t\tHashMap<String, Node> children;\n\n\t\tNode(String key, String value, int depth, Node parent){\n\t\t\tthis.key=key;\n\t\t\tthis.value=value;\n\t\t\tthis.depth=depth;\n\t\t\tthis.parent=parent;\n\t\t\tchildren=new HashMap<String, Node>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> yaml = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tyaml.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < yaml.size(); i++) {\n\t\t\tString line1 = yaml.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = yaml.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop<Obj>(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop<String>(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tProp prop = null;\n\t\twhile (query.hasMoreTokens()) {\n\t\t\tif ((prop = obj.get(query.nextToken())) != null) {\n\t\t\t\tif (prop.value instanceof Obj) {\n\t\t\t\t\tobj = (Obj) prop.value;\n\t\t\t\t} else {\n\t\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\t\tprop = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (prop == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (prop.value instanceof String) {\n\t\t\tans = \"string \\\"\" + prop.value + \"\\\"\";\n\t\t} else if (prop.value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tProp get(String key) {\n\t\t\treturn props.get(key);\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//YAML\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] ps = sc.nextLine().split(\"\\\\.\");\n\t\tchar[][] s = new char[15000][];\n\t\tint n = 0;\n\t\twhile(sc.hasNext()){\n\t\t\ts[n++] = sc.nextLine().toCharArray();\n\t\t}\n\t\tint now = 0, indent = 0;\n\t\tfor(int i=1;i<ps.length;i++){\n\t\t\tboolean find = false;\n\t\t\twhile(now < n){\n\t\t\t\tint cnt = 0, idx = 0;\n\t\t\t\twhile(s[now][idx]==' '){\n\t\t\t\t\tcnt++; idx++;\n\t\t\t\t}\n\t\t\t\tif(cnt < indent){\n\t\t\t\t\tSystem.out.println(\"no such property\"); return;\n\t\t\t\t}\n\t\t\t\telse if(cnt==indent){\n\t\t\t\t\tString name = \"\";\n\t\t\t\t\twhile(s[now][idx]!=':'){\n\t\t\t\t\t\tname+=s[now][idx++];\n\t\t\t\t\t}\n\t\t\t\t\tif(ps[i].equals(name)){\n\t\t\t\t\t\tif(i==ps.length-1){\n\t\t\t\t\t\t\tif(idx==s[now].length-1){\n\t\t\t\t\t\t\t\tSystem.out.println(\"object\"); return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tidx+=2;\n\t\t\t\t\t\t\tString res = \"\";\n\t\t\t\t\t\t\twhile(idx < s[now].length)res+=s[now][idx++];\n\t\t\t\t\t\t\tSystem.out.println(\"string \\\"\" + res +\"\\\"\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(now==n-1){\n\t\t\t\t\t\t\tSystem.out.println(\"no such property\"); return;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindent = 0;\n\t\t\t\t\t\twhile(s[now+1][indent]==' ')indent++;\n\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\tnow++; break;\n\t\t\t\t\t}\n\t\t\t\t\telse now++;\n\t\t\t\t}\n\t\t\t\telse now++;\n\t\t\t}\n\t\t\tif(!find){\n\t\t\t\tSystem.out.println(\"no such property\"); return;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString query;\n\tArrayList<String> ss;\n\n\tvoid run(){\n\t\tquery=sc.nextLine();\n\t\tss=new ArrayList<String>();\n\t\tfor(; sc.hasNextLine();){\n\t\t\tss.add(sc.nextLine());\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tNode root=new Node(\"\", \"\", -1, null);\n\t\tNode node=root;\n\t\tfor(String line : ss){\n\t\t\tint depth=line.length();\n\t\t\tline=line.replaceAll(\"^ *\", \"\");\n\t\t\tdepth-=line.length();\n\t\t\tfor(; depth<=node.depth; node=node.parent);\n\t\t\t// debug(line, node.key);\n\t\t\tif(line.charAt(line.length()-1)==':'){\n\t\t\t\tNode child=new Node(line.substring(0, line.length()-1), null,\n\t\t\t\t\t\tdepth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}else{\n\t\t\t\tString key=line.split(\": \")[0];\n\t\t\t\tString value=line.split(\": \")[1];\n\t\t\t\tNode child=new Node(key, value, depth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\t// node=child;\n\t\t\t}\n\t\t}\n\t\tif(true){\n\t\t\tLinkedList<Node> stack=new LinkedList<Node>();\n\t\t\tstack.push(root);\n\t\t\tfor(; !stack.isEmpty();){\n\t\t\t\tnode=stack.pop();\n\t\t\t\tString s=\"\";\n\t\t\t\tfor(int i=0; i<node.depth; i++){\n\t\t\t\t\ts+=\" \";\n\t\t\t\t}\n\t\t\t\ts+=node.key+\":\"+node.value;\n\t\t\t\t// debug(s, node.parent==null?\"\":node.parent.key);\n\t\t\t\t// debug(s);\n\t\t\t\tfor(Node child : node.children.values()){\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString ans;\n\t\tnode=root;\n\t\tfor(String s : query.substring(1).split(\"\\\\.\")){\n\t\t\tif(node.children.containsKey(s)){\n\t\t\t\tnode=node.children.get(s);\n\t\t\t}else{\n\t\t\t\tnode=null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// debug(node.depth, node.key, node.value);\n\t\t}\n\t\tif(node==null){\n\t\t\tans=\"no such property\";\n\t\t}else if(node.children.size()>0){\n\t\t\tans=\"object\";\n\t\t}else{\n\t\t\tans=\"string \\\"\"+node.value+\"\\\"\";\n\t\t}\n\t\tprintln(ans);\n\t}\n\n\tclass Node{\n\t\tString key, value;\n\t\tint depth;\n\t\tNode parent;\n\t\tHashMap<String, Node> children;\n\n\t\tNode(String key, String value, int depth, Node parent){\n\t\t\tthis.key=key;\n\t\t\tthis.value=value;\n\t\t\tthis.depth=depth;\n\t\t\tthis.parent=parent;\n\t\t\tchildren=new HashMap<String, Node>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> lines = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tlines.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tString line1 = lines.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = lines.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tObject value = null;\n\t\twhile ((value = obj.get(query.nextToken())) != null) {\n\t\t\tif (value instanceof Obj) {\n\t\t\t\tobj = (Obj) value;\n\t\t\t} else {\n\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\tvalue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (value == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (value instanceof String) {\n\t\t\tans = \"string \\\"\" + value + \"\\\"\";\n\t\t} else if (value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tObject get(String key) {\n\t\t\treturn props.get(key).value;\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tString query;\n\tArrayList<String> ss;\n\n\tvoid run(){\n\t\tquery=sc.nextLine();\n\t\tss=new ArrayList<String>();\n\t\tfor(; sc.hasNextLine();){\n\t\t\tss.add(sc.nextLine());\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tNode root=new Node(\"\", \"\", -1, null);\n\t\tNode node=root;\n\t\tfor(String line : ss){\n\t\t\tint depth=line.length();\n\t\t\tline=line.replaceAll(\"^ *\", \"\");\n\t\t\tfor(; depth<=node.depth; node=node.parent);\n\t\t\tif(line.charAt(line.length()-1)==':'){\n\t\t\t\t// 次にいく\n\t\t\t\tNode child=new Node(line.substring(0, line.length()-1), null,\n\t\t\t\t\t\tdepth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}else{\n\t\t\t\tString key=line.split(\": \")[0];\n\t\t\t\tString value=line.split(\": \")[1];\n\t\t\t\tNode child=new Node(key, value, depth, node);\n\t\t\t\tnode.children.put(child.key, child);\n\t\t\t\tnode=child;\n\t\t\t}\n\t\t}\n\t\tif(false){\n\t\t\tLinkedList<Node> stack=new LinkedList<Node>();\n\t\t\tstack.push(root);\n\t\t\tfor(; !stack.isEmpty();){\n\t\t\t\tnode=stack.pop();\n\t\t\t\tString s=\"\";\n\t\t\t\tfor(int i=0; i<node.depth; i++){\n\t\t\t\t\ts+=\" \";\n\t\t\t\t}\n\t\t\t\ts+=node.key+\":\"+node.value;\n\t\t\t\tdebug(s, node.parent==null?\"\":node.parent.key);\n\t\t\t\tfor(Node child : node.children.values()){\n\t\t\t\t\tstack.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString ans;\n\t\tnode=root;\n\t\tfor(String s : query.substring(1).split(\"\\\\.\")){\n\t\t\tif(node.children.containsKey(s)){\n\t\t\t\tnode=node.children.get(s);\n\t\t\t}else{\n\t\t\t\tnode=null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// debug(node.depth, node.key, node.value);\n\t\t}\n\t\tif(node==null){\n\t\t\tans=\"no such property\";\n\t\t}else if(node.children.size()>0){\n\t\t\tans=\"object\";\n\t\t}else{\n\t\t\tans=\"string \\\"\"+node.value+\"\\\"\";\n\t\t}\n\t\tprintln(ans);\n\t}\n\n\tclass Node{\n\t\tString key, value;\n\t\tint depth;\n\t\tNode parent;\n\t\tHashMap<String, Node> children;\n\n\t\tNode(String key, String value, int depth, Node parent){\n\t\t\tthis.key=key;\n\t\t\tthis.value=value;\n\t\t\tthis.depth=depth;\n\t\t\tthis.parent=parent;\n\t\t\tchildren=new HashMap<String, Node>();\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> lines = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tlines.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tString line1 = lines.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = lines.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].put(key, objs[m]);\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].put(key, string);\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tObject value = null;\n\t\twhile (query.hasMoreTokens()) {\n\t\t\tvalue = obj.get(query.nextToken());\n\t\t\tif (value == null) break;\n\t\t\tif (value instanceof Obj) {\n\t\t\t\tobj = (Obj) value;\n\t\t\t} else {\n\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\tvalue = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (value == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t} else if (value instanceof String) {\n\t\t\tans = \"string \\\"\" + value + \"\\\"\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\tclass Obj {\n\t\tprivate Map<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tObject get(String key) {\n\t\t\tif (props.containsKey(key)) {\n\t\t\t\treturn props.get(key).value;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tProp put(String key, Obj value) {\n\t\t\treturn props.put(key, new Prop<Obj>(value));\n\t\t}\n\n\t\tProp put(String key, String value) {\n\t\t\treturn props.put(key, new Prop<String>(value));\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tprivate T value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[] input;\n\tstatic int pos;\n\n\tpublic static void main(String[] arg) {\n\t\tString[] q = sc.nextLine().split(\"\\\\.\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (sc.hasNext()) {\n\t\t\tsb.append(sc.nextLine() + \"\\n\");\n\t\t}\n\t\tinput = sb.toString().toCharArray();\n\t\tElem elem = parseMapping(0);\n\t\tfor (int i = 1; i < q.length && elem != null; ++i) {\n\t\t\telem = elem.get(q[i]);\n\t\t}\n\t\tSystem.out.println(elem == null ? \"no such property\" : elem.toString());\n\t}\n\n\tstatic Mapping parseMapping(int indent) {\n\t\tMapping mapping = new Mapping();\n\t\twhile (true) {\n\t\t\tint n = nextIndent();\n\t\t\tif (n != indent) break;\n\t\t\tpos += indent;\n\t\t\tint sp = pos;\n\t\t\twhile (input[pos] != ':') {\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\tString key = String.valueOf(input, sp, pos - sp);\n\t\t\t++pos;\n\t\t\tif (input[pos] == '\\n') {\n\t\t\t\t++pos;\n\t\t\t\tint m = nextIndent();\n\t\t\t\tMapping child = parseMapping(m);\n\t\t\t\tmapping.map.put(key, child);\n\t\t\t} else {\n\t\t\t\t++pos;\n\t\t\t\tsp = pos;\n\t\t\t\twhile (input[pos] != '\\n') {\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\tmapping.map.put(key, new Str(String.valueOf(input, sp, pos - sp)));\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\t\treturn mapping;\n\t}\n\n\tstatic int nextIndent() {\n\t\tint cur = pos;\n\t\tif (cur >= input.length) return -1;\n\t\twhile (input[cur] == ' ') {\n\t\t\t++cur;\n\t\t}\n\t\treturn cur - pos;\n\t}\n\n\tstatic abstract class Elem {\n\t\tabstract Elem get(String key);\n\t}\n\n\tstatic class Mapping extends Elem {\n\t\tHashMap<String, Elem> map = new HashMap<String, Elem>();\n\n\t\tElem get(String key) {\n\t\t\treturn map.get(key);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"object\";\n\t\t}\n\t}\n\n\tstatic class Str extends Elem {\n\t\tString v;\n\n\t\tStr(String s) {\n\t\t\tthis.v = s;\n\t\t}\n\n\t\tElem get(String key) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"string \\\"\" + v + \"\\\"\";\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * YAML\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tStringTokenizer query = new StringTokenizer(br.readLine(), \".\");\n\t\tList<String> lines = new ArrayList<>();\n\t\tObj[] objs = new Obj[50_000];\n\n\t\t//read\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tlines.add(line);\n\t\t}\n\n\t\t//parse\n\t\tfor (int i = 0; i < lines.size(); i++) {\n\t\t\tString line1 = lines.get(i);\n\n\t\t\t//parent\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j < line1.length(); j++) {\n\t\t\t\tif (line1.charAt(j) == ' ') n++;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (objs[n] == null) {\n\t\t\t\tobjs[n] = main.new Obj();\n\t\t\t}\n\n\t\t\t//prop\n\t\t\twords = line1.substring(n).split(\":\");\n\t\t\tif (words.length == 1) {\n\t\t\t\t//prop: object\n\t\t\t\tString line2 = lines.get(i + 1);\n\t\t\t\t//self\n\t\t\t\tint m = 0;\n\t\t\t\tfor (int j = 0; j < line2.length(); j++) {\n\t\t\t\t\tif (line2.charAt(j) == ' ') m++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif (objs[m] == null) {\n\t\t\t\t\tobjs[m] = main.new Obj();\n\t\t\t\t}\n\t\t\t\tString key = words[0];\n\t\t\t\tobjs[n].props.put(key, main.new Prop<Obj>(objs[m]));\n\t\t\t} else {\n\t\t\t\t//prop: string\n\t\t\t\tString key = words[0];\n\t\t\t\tString string = words[1].substring(1);\n\t\t\t\tobjs[n].props.put(key, main.new Prop<String>(string));\n\t\t\t}\n\t\t}\n\n\t\tObj obj = objs[0];\n\t\tObject value = null;\n\t\twhile (query.hasMoreTokens()) {\n\t\t\tvalue = obj.get(query.nextToken());\n\t\t\tif (value == null) break;\n\t\t\tif (value instanceof Obj) {\n\t\t\t\tobj = (Obj) value;\n\t\t\t} else {\n\t\t\t\tif (query.hasMoreTokens()) {\n\t\t\t\t\tvalue = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString ans = \"\";\n\t\tif (value == null) {\n\t\t\tans = \"no such property\";\n\t\t} else if (value instanceof String) {\n\t\t\tans = \"string \\\"\" + value + \"\\\"\";\n\t\t} else if (value instanceof Obj) {\n\t\t\tans = \"object\";\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t} //end main\n\n\tclass Obj {\n\t\tMap<String, Prop> props;\n\n\t\tObj() {\n\t\t\tprops = new HashMap<>();\n\t\t}\n\n\t\tObject get(String key) {\n\t\t\treturn props.get(key).value;\n\t\t}\n\t}\n\n\tclass Prop<T> {\n\t\tT value;\n\n\t\tProp(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var query = Console.ReadLine();\n            var yaml = Parse();\n            Console.WriteLine(yaml.ContainsKey(query) ? yaml[query] : \"no such property\");\n        }\n        static Dictionary<string, string> Parse() {\n            var result = new Dictionary<string, string>();\n            var indent = new Stack<int>(new[] { -1 });\n            var header = new LinkedList<string>();\n            foreach (var line in Input()) {\n                var lastIndent = indent.Peek();\n                var orig = line.Split(':');\n                var com = new[] { orig[0].Trim(), orig[1].Trim() };\n                var currentIndent = orig[0].Length - com[0].Length;\n                if (currentIndent != lastIndent) {\n                    if (currentIndent < lastIndent) {\n                        while (currentIndent != lastIndent) {\n                            header.RemoveLast();\n                            lastIndent = indent.Pop();\n                        }\n                    }\n                    header.AddLast(\".\" + com[0]);\n                    indent.Push(currentIndent);\n                }\n                else {\n                    header.Last.Value = \".\" + com[0];\n                }\n                result.Add(string.Concat(header.ToArray()), com[1].Length != 0 ? \"string \\\"\" + com[1] + \"\\\"\" : \"object\");\n            }\n            return result;\n        }\n        static IEnumerable<string> Input() {\n            for (string i; (i = Console.ReadLine()) != null;) {\n                yield return i;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var query = Console.ReadLine();\n            var yaml = Parse();\n            Console.WriteLine(yaml.ContainsKey(query) ? yaml[query] : \"no such property\");\n        }\n        static Dictionary<string, string> Parse() {\n            var result = new Dictionary<string, string>();\n            var indent = new Stack<int>(new[] { -1 });\n            var header = new LinkedList<string>();\n            foreach (var line in Input()) {\n                var lastIndent = indent.Peek();\n                var orig = line.Split(':');\n                var com = new[] { orig[0].Trim(), orig[1].Substring(1) };\n                var currentIndent = orig[0].Length - com[0].Length;\n                if (currentIndent != lastIndent) {\n                    if (currentIndent < lastIndent) {\n                        while (currentIndent != lastIndent) {\n                            header.RemoveLast();\n                            lastIndent = indent.Pop();\n                        }\n                    }\n                    header.AddLast(\".\" + com[0]);\n                    indent.Push(currentIndent);\n                }\n                else {\n                    header.Last.Value = \".\" + com[0];\n                }\n                result.Add(string.Concat(header.ToArray()), com[1].Length != 0 ? \"string \\\"\" + com[1] + \"\\\"\" : \"object\");\n            }\n            return result;\n        }\n        static IEnumerable<string> Input() {\n            for (string i; (i = Console.ReadLine()) != null;) {\n                yield return i;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n//    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        var keys = sc.Str.Substring(1).Split('.');\n        var lines = new List<string>();\n        var indents = new List<int>();\n        while (true)\n        {\n            var s = Console.ReadLine();\n            if (s == null) break;\n            lines.Add(s);\n            indents.Add(clws(s));\n        }\n        int nextindent = 0, ind = 0;\n        for (int i = 0; i < lines.Count; i++)\n        {\n            if (indents[i] != nextindent) continue;\n\n            int ci = lines[i].IndexOf(':');\n            var name = lines[i].Remove(ci).Trim();\n            if (name == keys[ind])\n            {\n                ++ind;\n                if (ind == keys.Length)\n                {\n                    if (ci == lines[i].Length - 1)\n                    {\n                        Prt(\"object\");\n                        sw.Flush();\n                        return;\n                    }\n                    else\n                    {\n                        Prt(\"string \\\"\" + lines[i].Substring(ci + 2) + \"\\\"\");\n                        sw.Flush();\n                        return;\n                    }\n                }\n                if (i + 1 == lines.Count)\n                    break;\n\n                nextindent = indents[i + 1];\n            }\n        }\n        Prt(\"no such property\");\n        sw.Flush();\n    }\n    static int clws(string s)\n    {\n        int c = 0;\n        foreach (var item in s)\n        {\n            if (item != ' ') break;\n\n            ++c;\n        }\n        return c;\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nclass mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n)\n    {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n)\n    {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n)\n    {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n)\n    {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n)\n    {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n)\n    {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y)\n    {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++)\n        {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y)\n    {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A)\n    {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x)\n    {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x)\n    {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B)\n    {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y)\n    {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B)\n    {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b)\n    {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y)\n    {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r)\n    {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++)\n        {\n            int piv = denom[p - 1];\n            if (piv > 1)\n            {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var query = Console.ReadLine();\n            var yaml = Parse();\n            Console.WriteLine(yaml.ContainsKey(query) ? yaml[query] : \"no such property\");\n        }\n        static Dictionary<string, string> Parse() {\n            var result = new Dictionary<string, string>();\n            var indent = new Stack<int>(new[] { -1 });\n            var header = new LinkedList<string>();\n            foreach (var line in Input()) {\n                var lastIndent = indent.Peek();\n                var orig = line.Split(':');\n                var com = new[] { orig[0].Trim(), orig[1] };\n                var currentIndent = orig[0].Length - com[0].Length;\n                if (currentIndent != lastIndent) {\n                    if (currentIndent < lastIndent) {\n                        while (currentIndent != lastIndent) {\n                            header.RemoveLast();\n                            lastIndent = indent.Pop();\n                        }\n                    }\n                    header.AddLast(\".\" + com[0]);\n                    indent.Push(currentIndent);\n                }\n                else {\n                    header.Last.Value = \".\" + com[0];\n                }\n                result.Add(string.Concat(header.ToArray()), com[1].Length != 0 ? \"string \\\"\" + com[1].Substring(1) + \"\\\"\" : \"object\");\n            }\n            return result;\n        }\n        static IEnumerable<string> Input() {\n            for (string i; (i = Console.ReadLine()) != null;) {\n                yield return i;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Aizu {\n    class OnlineJudge {\n        static void Main() {\n            var query = Console.ReadLine();\n            var yaml = Parse();\n            Console.WriteLine(yaml.ContainsKey(query) ? yaml[query] : \"no such property\");\n            Console.ReadKey();\n        }\n        static Dictionary<string, string> Parse() {\n            var result = new Dictionary<string, string>();\n            var indent = new Stack<int>(new[] { -1 });\n            var header = new Stack<string>();\n            var header2 = new LinkedList<string>();\n            foreach (var line in Input()) {\n                var lastIndent = indent.Peek();\n                var orig = line.Split(':');\n                var com = new[] { orig[0].Trim(), orig[1].Trim() };\n                var currentIndent = orig[0].Length - com[0].Length;\n                if (currentIndent != lastIndent) {\n                    if (currentIndent < lastIndent) {\n                        while (currentIndent != lastIndent) {\n                            header2.RemoveLast();\n                            lastIndent = indent.Pop();\n                        }\n                    }\n                    header2.AddLast(\".\" + com[0]);\n                    indent.Push(currentIndent);\n                }\n                else {\n                    header2.Last.Value = \".\" + com[0];\n                }\n                result.Add(string.Concat(header2.ToArray()), com[1].Length != 0 ? \"string \\\"\" + com[1] + \"\\\"\" : \"object\");\n            }\n            return result;\n        }\n        static IEnumerable<string> Input() {\n            for (string i; (i = Console.ReadLine()) != null;) {\n                yield return i;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n\ndef main\n  params = gets.chomp.split('.')\n  params.shift\n  current_lv = 0\n  result_value = nil\n  params.each do |param|\n    loop do\n      line = gets\n      if line.nil?\n        puts 'no such property'\n        return\n      end\n\n      lv = obj_level(line.chomp)\n      if lv < current_lv\n        puts 'no such property'\n        return\n      elsif lv > current_lv\n        next\n      end\n\n      key,value = parse_line(line.chomp)\n      unless key.eql?(param)\n        next\n      end\n\n      if value.nil?\n        result_value = 'object'\n      else\n        result_value = \"string \\\"#{value}\\\"\"\n      end\n      current_lv = lv + 1\n      break\n    end\n  end\n  puts result_value\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n\ndef main\n  params = gets.chomp.split('.')\n  params.shift\n  current_lv = 0\n  result_value = nil\n  params.each do |param|\n    loop do\n      line = gets.chomp\n      if line.size == 0\n        puts 'no such property'\n        return\n      end\n\n      lv = obj_level(line)\n      if lv < current_lv\n        puts 'no such property'\n        return\n      elsif lv > current_lv\n        next\n      end\n\n      key,value = parse_line(line)\n      unless key.eql?(param)\n        next\n      end\n\n      if value.nil?\n        result_value = 'object'\n      else\n        result_value = \"string \\\"#{value}\\\"\"\n      end\n      current_lv = lv + 1\n      break\n    end\n  end\n  puts result_value\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "def main\n  command = gets.chomp\n  obj = make_obj\n  puts command_eval(obj, command)\nend\n\ndef command_eval obj, command\n  params = command.split('.')\n  params.shift\n  next_obj = obj\n\n  params.each do |param|\n    unless next_obj.instance_of?(Hash)\n      return 'no such property'\n    end\n\n    next_obj = next_obj[param]\n    if next_obj.nil?\n      return 'no such property'\n    end\n  end\n\n  unless next_obj.instance_of?(String)\n    return 'object'\n  end\n\n  \"string \\\"#{next_obj}\\\"\"\nend\n\ndef make_obj\n  next_line,obj = make_child_obj\n  obj\nend\n\ndef make_child_obj\n  obj = Hash.new\n  line = gets.chomp\n  next_line = ''\n  level = obj_level(line)\n  loop do\n    key,value = parse_line(line)\n\n    if value.nil?\n      next_line,value = make_child_obj\n    else\n      next_line = gets.chomp\n    end\n    obj[key] = value\n\n    break if next_line.size == 0 or obj_level(next_line) < level\n    line = next_line\n  end\n  [next_line, obj]\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key,value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\n\nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "def main\n  params = gets.chomp.split('.')\n  params.shift\n  current_lv = 0\n  result_value = nil\n  params.each do |param|\n    loop do\n      line = gets.chomp\n      if line.size == 0\n        puts 'no such property'\n        return\n      end\n\n      lv = obj_level(line)\n      if lv < current_lv\n        while gets.chomp.size != 0\n          # 読み捨て\n        end\n        puts 'no such property'\n        return\n      elsif lv > current_lv\n        next\n      end\n\n      key,value = parse_line(line)\n      unless key.eql?(param)\n        next\n      end\n\n      if value.nil?\n        result_value = 'object'\n      else\n        result_value = \"string \\\"#{value}\\\"\"\n      end\n      current_lv = lv + 1\n      break\n    end\n  end\n  while gets.chomp.size != 0\n    # 読み捨て\n  end\n  puts result_value\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\n\nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "def parse(yaml, pos, props, cur_lv = -1)\n  cur = \"\"\n  while pos < yaml.size\n    line = yaml[pos]\n    lv = 0\n    while line[0] == ' '\n      line = line[1..-1]\n      lv += 1\n    end\n    if lv <= cur_lv\n      return pos\n    end\n    dat = line.split(':')\n    if dat.size == 1\n      child = {}\n      # it has children\n      pos = parse(yaml, pos + 1, child, lv)\n      props[dat[0]] = child\n    else\n      props[dat[0]] = dat[1][1..-1]\n      pos += 1\n    end\n  end\n  return pos\nend\n\n\nquery = gets.chomp.split(\".\")[1..-1]\nyaml = []\nwhile s = gets\n  yaml << s.chomp\nend\n\nprops = {}\nparse(yaml, 0, props)\nfor v in query\n  if props.member?(v)\n    props = props[v]\n  else\n    puts \"no such property\"\n    exit 0\n  end\nend\n\nif props.is_a?(String)\n  puts \"string \\\"#{props}\\\"\"\nelse\n  puts \"object\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def main\n  command = gets.chomp\n  yaml = parse_yaml\n  puts print(yaml, command)\nend\n \ndef print obj, command\n  params = command.split('.')\n  params.shift\n  next_obj = obj\n \n  params.each do |param|\n    unless next_obj.instance_of?(Hash)\n      return 'no such property'\n    end\n \n    next_obj = next_obj[param]\n    if next_obj.nil?\n      return 'no such property'\n    end\n  end\n \n  unless next_obj.instance_of?(String)\n    return 'object'\n  end\n \n  \"string \\\"#{next_obj}\\\"\"\nend\n \ndef parse_yaml\n  next_line,yaml = make_obj\n  yaml\nend\n \ndef make_obj\n  obj = Hash.new\n  line = gets.chomp\n  next_line = ''\n  level = obj_level(line)\n  loop do\n    key,value = parse_line(line)\n \n    if value.nil?\n      next_line,value = make_obj\n    else\n      next_line = gets.chomp\n    end\n    obj[key] = value\n \n    break if next_line.size == 0 or obj_level(next_line) < level\n    line = next_line\n  end\n  [next_line, obj]\nend\n \ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n \ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n \n \nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "def main\n  params = gets.chomp.split('.')\n  params.shift\n  current_lv = 0\n  result_value = nil\n  params.each do |param|\n    loop do\n      line = gets.chomp\n      if line.size == 0\n        puts 'no such property'\n        return 0\n      end\n\n      lv = obj_level(line)\n      if lv < current_lv\n        puts 'no such property'\n        return　0\n      elsif lv > current_lv\n        next\n      end\n\n      key,value = parse_line(line)\n      unless key.eql?(param)\n        next\n      end\n\n      if value.nil?\n        result_value = 'object'\n      else\n        result_value = \"string \\\"#{value}\\\"\"\n      end\n      current_lv = lv + 1\n      break\n    end\n  end\n  puts result_value\n  0\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "def main\n  params = gets.chomp.split('.')\n  params.shift\n  current_lv = 0\n  result_value = nil\n  params.each do |param|\n    loop do\n      line = gets.chomp\n      if line.size == 0\n        puts 'no such property'\n        return 0\n      end\n\n      lv = obj_level(line)\n      if lv < current_lv\n        puts 'no such property'\n        return　0\n      elsif lv > current_lv\n        next\n      end\n\n      key,value = parse_line(line)\n      unless key.eql?(param)\n        next\n      end\n\n      if value.nil?\n        result_value = 'object'\n      else\n        result_value = \"string \\\"#{value}\\\"\"\n      end\n      current_lv = lv + 1\n      break\n    end\n  end\n  puts result_value\n  0\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\n\nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "query = gets\n\na = [?{]\nindent = [0]\n\nwhile gets\n\ts = $_.chomp\n\tif s =~ /^(\\s*)(\\w+): (.+)$/\n\t\ti = $1.size\n\t\twhile i < indent[-1]\n\t\t\ta << \" \" * indent.pop + \"},\"\n\t\tend\n\t\tif i > indent[-1]\n\t\t\tindent << i\n\t\tend\n\t\ta << %(#{$1}\"#{$2}\" => \"#{$3}\",)\n\telse\n\t\ts =~ /^(\\s*)(\\w+):$/ \n\t\ta << %(#{$1}\"#{$2}\" => {)\n\tend\nend\n\nloop do\n\tindent.pop\n\tbreak if indent.empty?\n\ta << \" \" * indent[-1] + \"},\"\nend\n\na << ?}\n\nyaml = eval a.join\np yaml\n\nquery.scan(/(?<=\\.)\\w+/) do |key|\n\tif yaml.class == String\n\t\tputs \"no such property\"\n\t\texit\n\tend\n\tyaml = yaml[key]\n\tif !yaml\n\t\tputs \"no such property\"\n\t\texit\n\tend\nend\n\nif yaml.class == String\n\tputs %(string \"#{yaml}\")\nelse\n\tputs 'object'\nend"
  },
  {
    "language": "Ruby",
    "code": "def main\n  command = gets.chomp\n  yaml = parse_yaml\n  puts print(yaml, command)\nend\n\ndef print obj, command\n  params = command.split('.')\n  params.shift\n  next_obj = obj\n\n  params.each do |param|\n    unless next_obj.instance_of?(Hash)\n      return 'no such property'\n    end\n\n    next_obj = next_obj[param]\n    if next_obj.nil?\n      return 'no such property'\n    end\n  end\n\n  unless next_obj.instance_of?(String)\n    return 'object'\n  end\n\n  \"string \\\"#{next_obj}\\\"\"\nend\n\ndef parse_yaml\n  next_line,yaml = make_obj\n  yaml\nend\n\ndef make_obj\n  obj = Hash.new\n  line = gets.chomp\n  next_line = ''\n  level = obj_level(line)\n  loop do\n    key,value = parse_line(line)\n\n    if value.nil?\n      next_line,value = make_obj\n    else\n      next_line = gets\n    end\n    obj[key] = value\n\n    break if next_line.nil? or obj_level(next_line) < level\n    line = next_line.chomp\n  end\n  [next_line, obj]\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\n\nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "def main\n  command = gets.chomp\n  obj = make_obj\n  puts print(obj, command)\n  0\nend\n\ndef print obj, command\n  params = command.split('.')\n  params.shift\n  next_obj = obj\n\n  params.each do |param|\n    unless next_obj.instance_of?(Hash)\n      return 'no such property'\n    end\n\n    next_obj = next_obj[param]\n    if next_obj.nil?\n      return 'no such property'\n    end\n  end\n\n  unless next_obj.instance_of?(String)\n    return 'object'\n  end\n\n  \"string \\\"#{next_obj}\\\"\"\nend\n\ndef make_obj\n  next_line,obj = make_child_obj\n  obj\nend\n\ndef make_child_obj\n  obj = Hash.new\n  line = gets.chomp\n  next_line = ''\n  level = obj_level(line)\n  loop do\n    key,value = parse_line(line)\n\n    if value.nil?\n      next_line,value = make_child_obj\n    else\n      next_line = gets.chomp\n    end\n    obj[key] = value\n\n    break if next_line.size == 0 or obj_level(next_line) < level\n    line = next_line\n  end\n  [next_line, obj]\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key,value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\n\nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\nrequire 'yaml'\nquery = gets.strip()\ndata = YAML.parse(ARGF.read).to_ruby\nquery.split('.').each do |name|\n    if name.empty?\n        # nop\n    elsif data == nil\n        # nop\n    else\n        if name =~ /^\\d+$/\n            name = name.to_i\n        end\n        if data.is_a? Hash and data.include? name\n            data = data[name]\n        else\n            data = nil\n        end\n    end\nend\nif data.is_a? Hash\n    puts 'object'\nelsif data.is_a? String\n    puts \"string \\\"#{data}\\\"\"\nelse\n    puts 'no such property'\nend"
  },
  {
    "language": "Ruby",
    "code": "query = gets\n\na = [?{]\nindent = [0]\n\nwhile gets\n\ts = $_.chomp\n\tif s =~ /^(\\s*)(\\w+): (.+)$/\n\t\ti = $1.size\n\t\twhile i < indent[-1]\n\t\t\ta << \" \" * indent.pop + \"},\"\n\t\tend\n\t\tif i > indent[-1]\n\t\t\tindent << i\n\t\tend\n\t\ta << %(#{$1}\"#{$2}\" => \"#{$3}\",)\n\telse\n\t\ts =~ /^(\\s*)(\\w+):$/ \n\t\ti = $1.size\n\t\twhile i < indent[-1]\n\t\t\ta << \" \" * indent.pop + \"},\"\n\t\tend\n\t\tif i > indent[-1]\n\t\t\tindent << i\n\t\tend\n\t\ta << %(#{$1}\"#{$2}\" => {)\n\tend\nend\n\nloop do\n\tindent.pop\n\tbreak if indent.empty?\n\ta << \" \" * indent[-1] + \"},\"\nend\n\na << ?}\nputs a\nexit\n\nyaml = eval a.join\n\nquery.scan(/(?<=\\.)\\w+/) do |key|\n\tif yaml.class == String\n\t\tputs \"no such property\"\n\t\texit\n\tend\n\tyaml = yaml[key]\n\tif !yaml\n\t\tputs \"no such property\"\n\t\texit\n\tend\nend\n\nif yaml.class == String\n\tputs %(string \"#{yaml}\")\nelse\n\tputs 'object'\nend"
  },
  {
    "language": "Ruby",
    "code": "query = gets\n\na = [?{]\nindent = [0]\n\nwhile gets\n\ts = $_.chomp\n\tif s =~ /^(\\s*)(\\w+): (.+)$/\n\t\ti = $1.size\n\t\twhile i < indent[-1]\n\t\t\ta << \" \" * indent.pop + \"},\"\n\t\tend\n\t\tif i > indent[-1]\n\t\t\tindent << i\n\t\tend\n\t\ta << %(#{$1}\"#{$2}\" => \"#{$3}\",)\n\telse\n\t\ts =~ /^(\\s*)(\\w+):$/ \n\t\ti = $1.size\n\t\twhile i < indent[-1]\n\t\t\ta << \" \" * indent.pop + \"},\"\n\t\tend\n\t\tif i > indent[-1]\n\t\t\tindent << i\n\t\tend\n\t\ta << %(#{$1}\"#{$2}\" => {)\n\tend\nend\n\nloop do\n\tindent.pop\n\tbreak if indent.empty?\n\ta << \" \" * indent[-1] + \"},\"\nend\n\na << ?}\n\nyaml = eval a.join\n\nquery.scan(/(?<=\\.)\\w+/) do |key|\n\tif yaml.class == String\n\t\tputs \"no such property\"\n\t\texit\n\tend\n\tyaml = yaml[key]\n\tif !yaml\n\t\tputs \"no such property\"\n\t\texit\n\tend\nend\n\nif yaml.class == String\n\tputs %(string \"#{yaml}\")\nelse\n\tputs 'object'\nend"
  },
  {
    "language": "Ruby",
    "code": "class Object\n  def define_accessor *properties\n    properties.each do |property|\n      self.instance_eval %Q{\n        def self.#{property}\n          return @#{property}\n        end\n\n        def self.#{property}=(arg)\n          @#{property} = arg\n        end\n      }\n    end\n  end\nend\n\ndef main\n  command = gets.chomp\n  obj = make_obj\n  puts command_eval(obj, command)\nend\n\ndef command_eval obj, command\n  eval %Q{\n    begin\n      if obj#{command}.instance_of?(String)\n        return \\\"string \\\\\"\\\" + obj#{command} + \\\"\\\\\"\\\"\n      elsif obj#{command}.instance_of?(Object)\n        return 'object'\n      end\n    rescue\n      return 'no such property'\n    end\n  }\nend\n\ndef make_obj\n  next_line,obj = make_child_obj\n  obj\nend\n\ndef make_child_obj\n  obj = Object.new\n  line = gets.chomp\n  next_line = ''\n  level = obj_level(line)\n  loop do\n    key,value = parse_line(line)\n    obj.define_accessor(key)\n\n    if value.nil?\n      next_line,value = make_child_obj\n      eval(\"obj.#{key} = value\")\n    else\n      next_line = gets.chomp\n      eval(\"obj.#{key} = \\\"#{value}\\\"\")\n    end\n\n    break if next_line.size == 0 or obj_level(next_line) < level\n    line = next_line\n  end\n  [next_line, obj]\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key,value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\n\nif __FILE__ == $0\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "def parse(yaml, pos, props, cur_lv = -1)\n  cur = \"\"\n  while pos < yaml.size\n    line = yaml[pos]\n    lv = 0\n    while line[0] == ' '\n      line = line[1..-1]\n      lv += 1\n    end\n    if lv <= cur_lv\n      return pos\n    end\n    dat = line.split(':')\n    if dat.size == 1\n      child = {}\n      # it has children\n      pos = parse(yaml, pos + 1, child, lv)\n      props[dat[0]] = child\n    else\n      props[dat[0]] = dat[1][1..-1]\n      pos += 1\n    end\n  end\n  return pos\nend\n\n\nquery = gets.chomp.split(\".\")[1..-1]\nyaml = []\nwhile s = gets\n  yaml << s.chomp\nend\n\nprops = {}\nparse(yaml, 0, props)\nfor v in query\n  if props.is_a?(Hash) && props.member?(v)\n    props = props[v]\n  else\n    puts \"no such property\"\n    exit 0\n  end\nend\n\nif props.is_a?(String)\n  puts \"string \\\"#{props}\\\"\"\nelse\n  puts \"object\"\nend"
  },
  {
    "language": "Ruby",
    "code": "query = gets\n\na = [?{]\nindent = [0]\n\nwhile gets\n\ts = $_.chomp\n\tif s =~ /^(\\s*)(\\w+): (.+)$/\n\t\ti = $1.size\n\t\twhile i < indent[-1]\n\t\t\ta << \" \" * indent.pop + \"},\"\n\t\tend\n\t\tif i > indent[-1]\n\t\t\tindent << i\n\t\tend\n\t\ta << %(#{$1}\"#{$2}\" => \"#{$3}\",)\n\telse\n\t\ts =~ /^(\\s*)(\\w+):$/ \n\t\ta << %(#{$1}\"#{$2}\" => {)\n\tend\nend\n\nloop do\n\tindent.pop\n\tbreak if indent.empty?\n\ta << \" \" * indent[-1] + \"},\"\nend\n\na << ?}\n\nyaml = eval a.join\n\nquery.scan(/(?<=\\.)\\w+/) do |key|\n\tif yaml.class == String\n\t\tputs \"no such property\"\n\t\texit\n\tend\n\tyaml = yaml[key]\n\tif !yaml\n\t\tputs \"no such property\"\n\t\texit\n\tend\nend\n\nif yaml.class == String\n\tputs %(string \"#{yaml}\")\nelse\n\tputs 'object'\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'yaml'\n\nkeys = STDIN.gets.chomp.split('.')\nyaml = STDIN.readlines.map(&:chomp).join(\"\\n\")\n\nobject = YAML.load(yaml)\nkeys[1..-1].each do |key|\n  if object.is_a?(Hash) && (object[key] || object[key.to_i])\n    object = object[key] || object[key.to_i]\n  else\n    puts \"no such property\"\n    exit\n  end\nend\n\nif object.is_a? Hash\n  puts \"object\"\nelse\n  puts \"string \\\"#{object}\\\"\"\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "def main\n  params = gets.chomp.split('.')\n  params.shift\n\n  yaml = []\n  while line = gets\n    break if line.nil?\n    yaml << line.chomp\n  end\n\n  current_lv = 0\n  result_value = nil\n  params.each do |param|\n    loop do\n      line = gets\n      if line.nil?\n        puts 'no such property'\n        return\n      end\n\n      lv = obj_level(line.chomp)\n      if lv < current_lv\n        puts 'no such property'\n        return\n      elsif lv > current_lv\n        next\n      end\n\n      key,value = parse_line(line.chomp)\n      unless key.eql?(param)\n        next\n      end\n\n      if value.nil?\n        result_value = 'object'\n      else\n        result_value = \"string \\\"#{value}\\\"\"\n      end\n      current_lv = lv + 1\n      break\n    end\n  end\n  puts result_value\nend\n\ndef parse_line str\n  key,value = str.split(':')\n  key.strip!\n  value.sub!(/^ /, '') unless value.nil?\n  [key, value]\nend\n\ndef obj_level str\n  str.index(/[a-z0-9]/)\nend\n\nmain"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\nimport re\n\ndef main():\n    key = raw_input().split('.')[1:]\n    indent = 0\n    level = 0\n    while True:\n        try:\n            s = raw_input()\n        except EOFError:\n            break\n\n        if re.match(' *'+' '*indent+key[level]+':', s):\n            indent = len(re.match(' *', s).group())\n            level += 1\n            if len(key) == level:\n                t = s[len(key[level-1])+indent+2:]\n                if not t:\n                    print 'object'\n                else:\n                    print 'string \"'+t+'\"'\n                return\n\n            t = s[len(key[level-1])+indent+2:]\n            if t:\n                break\n\n        elif not s.startswith(' '*indent):\n            break\n\n        indent = len(re.match(' *', s).group())\n\n    print 'no such property'\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nd = defaultdict(lambda : \"no such property\")\n\ncheck, *yaml = list(open(0))\nbefore = []\nbeforei = []\nka = defaultdict(lambda :-1)\nbv = -1\nfor y in yaml:\n    y = y.split(\":\")\n    vacant = y[0].count(\" \")\n    if bv >= vacant:\n        for num,b in enumerate(beforei):\n            if b == vacant:\n                break\n        before = before[:num]\n        beforei = beforei[:num]\n    bv = vacant\n    before.append(y[0].strip(\" \"))\n    beforei.append(bv)\n    x = y[1][1:-1]\n    d[tuple(before)] = \"object\" if x == \"\" else \"string \\\"\"+x+\"\\\"\"\nans = tuple(check.strip(\"\\n\").split(\".\")[1:])\nprint(d[ans])\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+9\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(ks):\n        a = []\n        while 1:\n            try:\n                s = S()\n                if s == '':\n                    break\n                a.append(s)\n            except:\n                break\n        y = {}\n        keys = []\n        for l in a:\n            while 1:\n                yi = y\n                for k in keys:\n                    yi = yi[k]\n                ti = 0\n                for c in l:\n                    if c != ' ':\n                        break\n                    ti += 1\n                if '_ind' not in yi:\n                    yi['_ind'] = ti\n                if yi['_ind'] != ti:\n                    keys = keys[:-1]\n                    continue\n                k = l.split(':')[0].split(' ')[-1]\n                if l[-1] == ':':\n                    keys.append(k)\n                    yi[k] = {}\n                else:\n                    yi[k] = l.split(':')[1][1:]\n                break\n        ka = ks.split('.')[1:]\n        yi = y\n        for k in ka:\n            if isinstance(yi, str) or k not in yi:\n                return 'no such property'\n            yi = yi[k]\n        if isinstance(yi, str):\n            return 'string \"{}\"'.format(yi)\n        return 'object'\n\n    while 1:\n        n = S()\n        if n == 0:\n            break\n        rr.append(f(n))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nQuery = raw_input()\nQuery = Query.split('.')[1:]\n\nlst = []\nm = {}\n\nfor line in sys.stdin:\n    key, value = line[:-1].split(\":\")\n    rank = key.count(' ')\n    key = key[rank:]\n    index = len(lst)\n    for i in range(len(lst)):\n        if rank == lst[i][0]:\n            index = i\n            break\n    lst = lst[:index]\n    ms = m\n    for p in lst:\n        ms = ms[p[1]]\n    if value == '':\n        ms[key] = {}\n    else:\n        ms[key] = value\n    lst.append((rank, key))\n\ntry:\n    ms = m\n    for key in Query:\n        ms = ms[key]\n    if type(ms) == type(''):\n        print 'string \"' + ms[1:] + '\"'\n    else:\n        print 'object'\nexcept:\n    print 'no such property'\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\nimport re\n\ndef main():\n    key = raw_input().split('.')[1:]\n    indent = 0\n    level = 0\n    need_update = False\n    while True:\n        try:\n            s = raw_input()\n        except EOFError:\n            break\n\n        space = len(re.match(' *', s).group())\n        if need_update:\n            indent = space\n            need_update = False\n\n        if re.match(' *'+' '*indent+key[level]+':', s):\n            indent = len(re.match(' *', s).group())\n            level += 1\n            need_update = True\n            if len(key) == level:\n                t = s[len(key[level-1])+indent+2:]\n                if not t:\n                    print 'object'\n                else:\n                    print 'string \"'+t+'\"'\n                return\n\n            t = s[len(key[level-1])+indent+2:]\n            if t:\n                break\n\n        elif not s.startswith(' '*indent):\n            break\n\n        if space < indent:\n            break\n\n    print 'no such property'\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nipts = sys.stdin.readlines()\nkeys = ipts[0][1:-1].split('.')\n\nnode = root = {}\nprev = 0\nfor cur in xrange(1, len(ipts)):\n    line = ipts[cur]\n    indent = 0\n    while line[indent] == ' ':\n        indent += 1\n    m = line[indent:]\n    key, value = m.split(':')\n    if indent < prev:\n        node = node[\":\"]\n    if value == '\\n':\n        parent = node\n        node[key] = node = {}\n        node[\":\"] = parent\n    else:\n        node[key] = value[1:-1]\n    prev = indent\nnode = root\nfor key in keys:\n    if type(node) == dict and key in node:\n        node = node[key]\n    else:\n        print \"no such property\"\n        break\nelse:\n    if type(node) == dict:\n        print \"object\"\n    else:\n        print \"string \\\"%s\\\"\" % node"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\nimport re\n\ngkey = input()\n\nyaml = {}\nopening_key = ['']\nopening_ind = [-1]\nspace_prog = re.compile(r' *')\nkey_prog = re.compile(r'[a-z\\d]+')\nwhile True:\n    try:\n        line = input()\n    except EOFError:\n        break\n\n    indent = len(space_prog.match(line).group())\n    while opening_ind[-1] >= indent:\n        opening_ind.pop()\n        opening_key.pop()\n\n    key = key_prog.search(line).group()\n    if not line.endswith(':'):\n        yaml['.'.join(opening_key+[key])] = (\n            'string \"{}\"'.format(line[line.index(':')+2:])\n        )\n        continue\n\n    opening_key.append(key)\n    opening_ind.append(indent)\n\n    yaml['.'.join(opening_key)] = 'object'\n\nprint(yaml.get(gkey, 'no such property'))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nipts = sys.stdin.readlines()\nkeys = ipts[0][1:-1].split('.')\n\nnode = root = {}\nfor cur in xrange(1, len(ipts)):\n    line = ipts[cur]\n    indent = 0\n    while line[indent] == ' ':\n        indent += 1\n    m = line[indent:]\n    key, value = m.split(':')\n    if \":i\" not in node:\n        node[\":i\"] = indent\n    while indent < node[\":i\"]:\n        node = node[\":p\"]\n    if value == '\\n':\n        parent = node\n        node[key] = node = {}\n        node[\":p\"] = parent\n    else:\n        node[key] = value[1:-1]\n    prev = indent\nnode = root\nfor key in keys:\n    if type(node) == dict and key in node:\n        node = node[key]\n    else:\n        print \"no such property\"\n        break\nelse:\n    if type(node) == dict:\n        print \"object\"\n    else:\n        print \"string \\\"%s\\\"\" % node"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\ndef main():\n    key = raw_input().split('.')[1:]\n    indent = 0\n    while True:\n        try:\n            s = raw_input()\n        except EOFError:\n            print 'EOFError'\n            break\n\n        # print '>>', '\"'+' '*indent+key[indent/2]+':\"'\n        # print '<<', s\n        if s.startswith(' '*indent+key[indent/2]+':'):\n            indent += 2\n            if len(key) == indent/2:\n                t = s[len(key[indent/2-1])+indent:]\n                if not t:\n                    print 'object'\n                else:\n                    print 'string \"'+t+'\"'\n                return\n\n            t = s[len(key[indent/2-1])+indent:]\n            # print t\n            if t:\n                break\n\n        elif not s.startswith(' '*indent):\n            break\n\n    print 'no such property'\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python\n\nimport re\n\ndef main():\n    key = raw_input().split('.')[1:]\n    indent = 0\n    level = 0\n    while True:\n        try:\n            s = raw_input()\n        except EOFError:\n            break\n\n        if re.match(' *'+' '*indent+key[level]+':', s):\n            indent = len(re.match(' *', s).group())\n            level += 1\n            if len(key) == level:\n                t = s[len(key[level-1])+indent+2:]\n                if not t:\n                    print 'object'\n                else:\n                    print 'string \"'+t+'\"'\n                return\n\n            t = s[len(key[level-1])+indent+2:]\n            if t:\n                break\n\n        elif not s.startswith(' '*indent):\n            break\n\n        space = len(re.match(' *', s).group())\n        if space < indent:\n            break\n\n    print 'no such property'\n\nif __name__ == '__main__':\n    main()"
  }
]