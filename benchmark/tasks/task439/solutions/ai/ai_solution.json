[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LINE_LENGTH 1024\n#define MAX_INDENT 100\n#define MAX_KEYS 100\n\ntypedef struct {\n    char key[MAX_LINE_LENGTH];\n    char value[MAX_LINE_LENGTH];\n    bool is_object;\n    int indent;\n} YAML_Entry;\n\nYAML_Entry yaml_entries[MAX_LINE_LENGTH];\nint entry_count = 0;\n\nvoid parse_yaml(char *yaml) {\n    char *line = strtok(yaml, \"\\n\");\n    while (line != NULL) {\n        int indent = 0;\n        while (line[indent] == ' ') indent++;\n        \n        char *colon = strchr(line, ':');\n        if (colon == NULL) {\n            line = strtok(NULL, \"\\n\");\n            continue;\n        }\n        \n        strncpy(yaml_entries[entry_count].key, line + indent, colon - (line + indent));\n        yaml_entries[entry_count].key[colon - (line + indent)] = '\\0';\n        \n        char *value_start = colon + 1;\n        while (*value_start == ' ') value_start++;\n        \n        if (*value_start == '\\0') {\n            yaml_entries[entry_count].is_object = true;\n            yaml_entries[entry_count].value[0] = '\\0';\n        } else {\n            yaml_entries[entry_count].is_object = false;\n            strcpy(yaml_entries[entry_count].value, value_start);\n        }\n        \n        yaml_entries[entry_count].indent = indent;\n        entry_count++;\n        \n        line = strtok(NULL, \"\\n\");\n    }\n}\n\nchar* process_query(char *query) {\n    char *keys[MAX_KEYS];\n    int key_count = 0;\n    \n    char *token = strtok(query, \".\");\n    while (token != NULL) {\n        keys[key_count++] = token;\n        token = strtok(NULL, \".\");\n    }\n    \n    int current_indent = 0;\n    int current_entry = 0;\n    \n    for (int i = 0; i < key_count; i++) {\n        bool found = false;\n        for (int j = current_entry; j < entry_count; j++) {\n            if (yaml_entries[j].indent == current_indent && strcmp(yaml_entries[j].key, keys[i]) == 0) {\n                if (i == key_count - 1) {\n                    if (yaml_entries[j].is_object) {\n                        return \"object\";\n                    } else {\n                        static char result[MAX_LINE_LENGTH];\n                        snprintf(result, sizeof(result), \"string \\\"%s\\\"\", yaml_entries[j].value);\n                        return result;\n                    }\n                } else {\n                    if (!yaml_entries[j].is_object) {\n                        return \"no such property\";\n                    }\n                    current_indent = yaml_entries[j].indent + 2;\n                    current_entry = j + 1;\n                    found = true;\n                    break;\n                }\n            }\n        }\n        if (!found) {\n            return \"no such property\";\n        }\n    }\n    \n    return \"no such property\";\n}\n\nchar* query_yaml(char* yaml, char* query) {\n    entry_count = 0;\n    parse_yaml(yaml);\n    return process_query(query);\n}",
    "timestamp": "2025-08-05 21:33:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct YAMLValue {\n    string strValue;\n    map<string, YAMLValue> objValue;\n    bool isObject;\n\n    YAMLValue() : isObject(false) {}\n};\n\nvector<string> split(const string &s, char delimiter) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nYAMLValue parseYAML(const vector<string> &lines, int &index, int indentLevel) {\n    YAMLValue node;\n    node.isObject = true;\n\n    while (index < lines.size()) {\n        string line = lines[index];\n        int currentIndent = 0;\n        while (currentIndent < line.size() && line[currentIndent] == ' ') {\n            currentIndent++;\n        }\n\n        if (currentIndent < indentLevel) {\n            break;\n        }\n\n        line = line.substr(currentIndent);\n        size_t colonPos = line.find(':');\n        if (colonPos == string::npos) {\n            index++;\n            continue;\n        }\n\n        string key = line.substr(0, colonPos);\n        string value = line.substr(colonPos + 1);\n        value.erase(remove_if(value.begin(), value.end(), ::isspace), value.end());\n\n        if (value.empty()) {\n            YAMLValue child;\n            index++;\n            child = parseYAML(lines, index, currentIndent + 2);\n            node.objValue[key] = child;\n        } else {\n            YAMLValue child;\n            child.isObject = false;\n            child.strValue = value;\n            node.objValue[key] = child;\n            index++;\n        }\n    }\n\n    return node;\n}\n\nstring queryYAML(const YAMLValue &node, const vector<string> &keys, int depth) {\n    if (depth >= keys.size()) {\n        if (node.isObject) {\n            return \"object\";\n        } else {\n            return \"string \\\"\" + node.strValue + \"\\\"\";\n        }\n    }\n\n    const string &key = keys[depth];\n    auto it = node.objValue.find(key);\n    if (it == node.objValue.end()) {\n        return \"no such property\";\n    }\n\n    return queryYAML(it->second, keys, depth + 1);\n}\n\nint main() {\n    vector<string> lines;\n    string line;\n    while (getline(cin, line)) {\n        if (line.empty()) break;\n        lines.push_back(line);\n    }\n\n    string query;\n    getline(cin, query);\n\n    int index = 0;\n    YAMLValue root = parseYAML(lines, index, 0);\n\n    vector<string> keys;\n    if (!query.empty()) {\n        keys = split(query.substr(1), '.');\n    }\n\n    string result = queryYAML(root, keys, 0);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\npublic class YAMLQuery {\n    public static String queryYAML(String yaml, String query) {\n        Map<String, Object> data = parseYAML(yaml);\n        String[] keys = query.substring(1).split(\"\\\\.\");\n        Object current = data;\n        \n        for (String key : keys) {\n            if (current instanceof Map) {\n                Map<String, Object> map = (Map<String, Object>) current;\n                if (!map.containsKey(key)) {\n                    return \"no such property\";\n                }\n                current = map.get(key);\n            } else {\n                return \"no such property\";\n            }\n        }\n        \n        if (current instanceof Map) {\n            return \"object\";\n        } else if (current instanceof String) {\n            return \"string \\\"\" + current + \"\\\"\";\n        } else {\n            return \"no such property\";\n        }\n    }\n    \n    private static Map<String, Object> parseYAML(String yaml) {\n        Map<String, Object> result = new HashMap<>();\n        String[] lines = yaml.split(\"\\n\");\n        Stack<Map<String, Object>> stack = new Stack<>();\n        stack.push(result);\n        int prevIndent = 0;\n        \n        for (String line : lines) {\n            if (line.trim().isEmpty()) continue;\n            \n            int indent = line.indexOf(line.trim());\n            while (indent < prevIndent) {\n                stack.pop();\n                prevIndent -= 2;\n            }\n            \n            String[] parts = line.trim().split(\":\", 2);\n            String key = parts[0].trim();\n            if (parts.length == 1) {\n                stack.peek().put(key, new HashMap<String, Object>());\n            } else {\n                String value = parts[1].trim();\n                if (value.isEmpty()) {\n                    Map<String, Object> newMap = new HashMap<>();\n                    stack.peek().put(key, newMap);\n                    stack.push(newMap);\n                    prevIndent = indent + 2;\n                } else {\n                    stack.peek().put(key, value);\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
    "timestamp": "2025-08-05 21:34:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class YAMLParser {\n    public static String parseYAML(String yaml, String query) {\n        Map<String, Object> parsed = parseYAMLString(yaml);\n        return resolveQuery(parsed, query.split(\"\\\\.\"));\n    }\n\n    private static Map<String, Object> parseYAMLString(String yaml) {\n        Map<String, Object> result = new HashMap<>();\n        String[] lines = yaml.split(\"\\n\");\n        parseLevel(lines, 0, result, 0);\n        return result;\n    }\n\n    private static int parseLevel(String[] lines, int start, Map<String, Object> current, int currentIndent) {\n        for (int i = start; i < lines.length; i++) {\n            String line = lines[i];\n            int indent = countIndent(line);\n            line = line.trim();\n\n            if (indent < currentIndent) {\n                return i;\n            }\n\n            if (line.isEmpty() || line.startsWith(\"#\")) {\n                continue;\n            }\n\n            if (line.endsWith(\":\")) {\n                String key = line.substring(0, line.length() - 1).trim();\n                Map<String, Object> nested = new HashMap<>();\n                current.put(key, nested);\n                i = parseLevel(lines, i + 1, nested, indent + 2);\n                if (i < lines.length) {\n                    i--;\n                }\n            } else {\n                String[] parts = line.split(\":\", 2);\n                if (parts.length == 2) {\n                    String key = parts[0].trim();\n                    String value = parts[1].trim();\n                    current.put(key, value);\n                }\n            }\n        }\n        return lines.length;\n    }\n\n    private static int countIndent(String line) {\n        int count = 0;\n        for (char c : line.toCharArray()) {\n            if (c == ' ') {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n\n    private static String resolveQuery(Map<String, Object> current, String[] queryParts) {\n        for (String part : queryParts) {\n            if (current == null) {\n                return \"no such property\";\n            }\n            Object value = current.get(part);\n            if (value == null) {\n                return \"no such property\";\n            }\n            if (value instanceof Map) {\n                current = (Map<String, Object>) value;\n            } else {\n                if (queryParts[queryParts.length - 1].equals(part)) {\n                    return value instanceof String ? \"string \\\"\" + value + \"\\\"\" : \"object\";\n                }\n                return \"no such property\";\n            }\n        }\n        return \"object\";\n    }\n}",
    "timestamp": "2025-08-05 21:34:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LENGTH 1024\n\ntypedef struct Node {\n    char* key;\n    char* value;\n    struct Node** children;\n    int child_count;\n} Node;\n\nchar* trim(char* str) {\n    char* start = str;\n    char* end = str + strlen(str) - 1;\n    \n    while (isspace(*start)) start++;\n    while (end > start && isspace(*end)) end--;\n    \n    *(end + 1) = '\\0';\n    return start;\n}\n\nNode* create_node(char* key, char* value) {\n    Node* node = malloc(sizeof(Node));\n    node->key = strdup(key);\n    node->value = value ? strdup(value) : NULL;\n    node->children = NULL;\n    node->child_count = 0;\n    return node;\n}\n\nvoid add_child(Node* parent, Node* child) {\n    parent->children = realloc(parent->children, (parent->child_count + 1) * sizeof(Node*));\n    parent->children[parent->child_count++] = child;\n}\n\nNode* parse_yaml(char* yaml) {\n    Node* root = create_node(\"root\", NULL);\n    char* line;\n    int indent = 0;\n    Node* current_node = root;\n    \n    line = strtok(yaml, \"\\n\");\n    while (line) {\n        char* trimmed = trim(line);\n        if (strlen(trimmed) == 0) {\n            line = strtok(NULL, \"\\n\");\n            continue;\n        }\n        \n        int current_indent = line - trimmed;\n        char* key = strtok(trimmed, \":\");\n        char* value = strtok(NULL, \"\");\n        \n        if (key) {\n            key = trim(key);\n            Node* new_node = create_node(key, value ? trim(value) : NULL);\n            \n            if (current_indent > indent) {\n                add_child(current_node, new_node);\n                current_node = new_node;\n            } else if (current_indent < indent) {\n                current_node = root;\n                for (int i = 0; i < current_indent / 2; i++) {\n                    current_node = current_node->children[current_node->child_count - 1];\n                }\n                add_child(current_node, new_node);\n                current_node = new_node;\n            } else {\n                add_child(current_node->key ? current_node : root, new_node);\n            }\n            \n            indent = current_indent;\n        }\n        \n        line = strtok(NULL, \"\\n\");\n    }\n    \n    return root;\n}\n\nNode* find_property(Node* node, char* property) {\n    char* key = strtok(property, \".\");\n    while (key) {\n        int found = 0;\n        for (int i = 0; i < node->child_count; i++) {\n            if (strcmp(node->children[i]->key, key) == 0) {\n                node = node->children[i];\n                found = 1;\n                break;\n            }\n        }\n        \n        if (!found) return NULL;\n        key = strtok(NULL, \".\");\n    }\n    \n    return node;\n}\n\nchar* process_yaml(char* yaml, char* query) {\n    Node* root = parse_yaml(yaml);\n    Node* result = find_property(root, query);\n    \n    if (!result) return strdup(\"no such property\");\n    \n    if (result->child_count > 0) return strdup(\"object\");\n    \n    char* output = malloc(strlen(result->value) + 10);\n    sprintf(output, \"string \\\"%s\\\"\", result->value);\n    \n    return output;\n}",
    "timestamp": "2025-08-05 21:34:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <regex>\n\nclass YAMLObject {\nprivate:\n    std::unordered_map<std::string, std::string> properties;\n    std::unordered_map<std::string, YAMLObject*> nested_objects;\n\npublic:\n    void addProperty(const std::string& key, const std::string& value) {\n        properties[key] = value;\n    }\n\n    void addNestedObject(const std::string& key, YAMLObject* obj) {\n        nested_objects[key] = obj;\n    }\n\n    std::string query(const std::string& query_str) {\n        std::vector<std::string> keys;\n        std::regex key_regex(R\"(\\.([^.]+))\");\n        std::sregex_iterator it(query_str.begin(), query_str.end(), key_regex);\n        std::sregex_iterator end;\n\n        while (it != end) {\n            keys.push_back((*it)[1]);\n            ++it;\n        }\n\n        return traverseQuery(keys, 0);\n    }\n\nprivate:\n    std::string traverseQuery(const std::vector<std::string>& keys, size_t index) {\n        if (index >= keys.size()) {\n            return \"no such property\";\n        }\n\n        std::string current_key = keys[index];\n\n        if (index == keys.size() - 1) {\n            if (properties.count(current_key)) {\n                return \"string \\\"\" + properties[current_key] + \"\\\"\";\n            }\n            if (nested_objects.count(current_key)) {\n                return \"object\";\n            }\n            return \"no such property\";\n        }\n\n        if (nested_objects.count(current_key)) {\n            return nested_objects[current_key]->traverseQuery(keys, index + 1);\n        }\n\n        return \"no such property\";\n    }\n};\n\nint main() {\n    YAMLObject* root = new YAMLObject();\n    YAMLObject* person = new YAMLObject();\n    YAMLObject* address = new YAMLObject();\n\n    address->addProperty(\"street\", \"123 Main St\");\n    address->addProperty(\"city\", \"Anytown\");\n\n    person->addProperty(\"name\", \"John Doe\");\n    person->addProperty(\"age\", \"30\");\n    person->addNestedObject(\"address\", address);\n\n    root->addNestedObject(\"person\", person);\n\n    std::cout << root->query(\".person.name\") << std::endl;\n    std::cout << root->query(\".person.address.street\") << std::endl;\n    std::cout << root->query(\".person.address\") << std::endl;\n    std::cout << root->query(\".unknown\") << std::endl;\n\n    delete root;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import yaml\n\ndef query_yaml(yaml_string, query):\n    def parse_query(query):\n        return query.strip('.').split('.')\n    \n    def get_property(data, keys):\n        for key in keys:\n            if isinstance(data, dict) and key in data:\n                data = data[key]\n            else:\n                return 'no such property'\n        return data\n    \n    try:\n        data = yaml.safe_load(yaml_string)\n    except yaml.YAMLError:\n        return 'no such property'\n    \n    keys = parse_query(query)\n    result = get_property(data, keys)\n\n    if isinstance(result, dict):\n        return 'object'\n    elif isinstance(result, str):\n        return f'string \"{result}\"'\n    else:\n        return 'no such property'\n\n# Example usage:\nyaml_string = \"\"\"\nkey_1:\n  key_2:\n    key_3: \"value\"\n\"\"\"\nquery = \".key_1.key_2.key_3\"\noutput = query_yaml(yaml_string, query)",
    "timestamp": "2025-08-13 07:03:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\npublic class YamlParser {\n    public static Object parseYaml(String yaml) {\n        Map<String, Object> result = new LinkedHashMap<>();\n        String[] lines = yaml.split(\"\\n\");\n        Stack<Map<String, Object>> stack = new Stack<>();\n        stack.push(result);\n        int prevIndent = 0;\n        \n        for (String line : lines) {\n            int indent = 0;\n            while (indent < line.length() && line.charAt(indent) == ' ') {\n                indent++;\n            }\n            String trimmedLine = line.trim();\n            if (trimmedLine.isEmpty()) {\n                continue;\n            }\n            \n            String[] parts = trimmedLine.split(\": \");\n            String key = parts[0].trim();\n            String value = parts.length > 1 ? parts[1].trim() : null;\n\n            Map<String, Object> currentMap = indent > prevIndent ? (Map<String, Object>) stack.peek().get(stack.peek().keySet().toArray()[stack.peek().keySet().size() - 1]) : stack.peek();\n            if (indent > prevIndent) {\n                stack.push(currentMap);\n            } else if (indent < prevIndent) {\n                while (indent < prevIndent) {\n                    stack.pop();\n                    prevIndent -= 2;\n                }\n            }\n\n            if (value == null) {\n                currentMap.put(key, new LinkedHashMap<>());\n            } else if (value.matches(\"^\\\".*\\\"$\")) {\n                currentMap.put(key, value);\n            } else {\n                currentMap.put(key, new LinkedHashMap<>());\n            }\n            \n            prevIndent = indent;\n        }\n        return result;\n    }\n\n    public static String queryYaml(Object yamlObject, String query) {\n        if (!(yamlObject instanceof Map)) {\n            return \"no such property\";\n        }\n        \n        Map<String, Object> current = (Map<String, Object>) yamlObject;\n        String[] keys = query.split(\"\\\\.\");\n\n        for (String key : keys) {\n            if (!current.containsKey(key)) {\n                return \"no such property\";\n            }\n\n            Object value = current.get(key);\n\n            if (value instanceof Map) {\n                current = (Map<String, Object>) value;\n            } else if (value instanceof String) {\n                return \"string \" + value;\n            } else {\n                return \"object\";\n            }\n        }\n        return \"object\";\n    }\n\n    public static void main(String[] args) {\n        String yaml = \"a:\\n  b:\\n    c: \\\"d\\\"\\n    e: \\\"f\\\"\\n  g:\\n    h: i\\nj: k\";\n        String query = \".a.b.c\";\n        \n        Object yamlObject = parseYaml(yaml);\n        String result = queryYaml(yamlObject, query);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 07:03:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 1024\n#define MAX_QUERY_PARTS 256\n#define MAX_PART_LENGTH 256\n\ntypedef struct Node {\n    char key[MAX_PART_LENGTH];\n    char value[MAX_LINE_LENGTH];\n    struct Node *child;\n    struct Node *sibling;\n} Node;\n\nNode* parseYaml(FILE *file) {\n    Node *root = NULL, *current = NULL;\n    char line[MAX_LINE_LENGTH];\n    int currentIndent = -1;\n\n    while (fgets(line, sizeof(line), file)) {\n        int indent = 0;\n        while (line[indent] == ' ') indent++;\n\n        char *key = strtok(line + indent, \":\");\n        char *value = strtok(NULL, \"\\n\");\n        if (value && value[0] == ' ') value++;\n\n        Node *newNode = (Node*)malloc(sizeof(Node));\n        strcpy(newNode->key, key);\n        strcpy(newNode->value, value ? value : \"\");\n        newNode->child = NULL;\n        newNode->sibling = NULL;\n\n        if (currentIndent == -1) {\n            root = newNode;\n            current = root;\n            currentIndent = indent;\n        } else {\n            if (indent > currentIndent) {\n                current->child = newNode;\n            } else {\n                while (current && indent <= currentIndent) {\n                    current = current->sibling;\n                    currentIndent -= 2;\n                }\n                if (current) {\n                    newNode->sibling = current->sibling;\n                    current->sibling = newNode;\n                }\n            }\n            current = newNode;\n            currentIndent = indent;\n        }\n    }\n    return root;\n}\n\nchar* queryYaml(Node *root, char *query) {\n    char *result = (char*)malloc(MAX_LINE_LENGTH);\n    strcpy(result, \"no such property\");\n    Node *current = root;\n    char *part = strtok(query, \".\");\n\n    while (part) {\n        current = current->child;\n        while (current && strcmp(current->key, part) != 0) {\n            current = current->sibling;\n        }\n        if (!current) return result;\n        part = strtok(NULL, \".\");\n    }\n\n    if (strlen(current->value) == 0) {\n        strcpy(result, \"object\");\n    } else {\n        snprintf(result, MAX_LINE_LENGTH, \"string \\\"%s\\\"\", current->value);\n    }\n    \n    return result;\n}\n\nint main() {\n    FILE *file = fopen(\"input.yaml\", \"r\");\n    if (!file) {\n        printf(\"Failed to open input file\\n\");\n        return EXIT_FAILURE;\n    }\n\n    Node *root = parseYaml(file);\n    fclose(file);\n\n    char query[MAX_LINE_LENGTH];\n    printf(\"Enter query: \");\n    if (fgets(query, sizeof(query), stdin)) {\n        query[strcspn(query, \"\\n\")] = 0;\n\n        char *result = queryYaml(root, query);\n        printf(\"%s\\n\", result);\n        free(result);\n    }\n\n    // Free memory logic can be implemented here for cleanup if needed.\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:03:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_yaml(yaml_str):\n    def parse_mapping(lines, indent=0):\n        mapping = {}\n        while lines:\n            line = lines.pop(0)\n            current_indent = len(line) - len(line.lstrip())\n            if current_indent < indent:\n                lines.insert(0, line)\n                return mapping\n            \n            if current_indent > indent:\n                continue\n            \n            key, value = line.strip().split(':', 1)\n            key = key.strip()\n            value = value.strip()\n            \n            if value == '':\n                mapping[key] = parse_mapping(lines, current_indent + 2)\n            else:\n                mapping[key] = value.strip('\"')\n        \n        return mapping\n\n    lines = [line for line in yaml_str.split('\\n') if line.strip()]\n    return parse_mapping(lines)\n\ndef query_yaml(yaml_obj, query):\n    keys = query.split('.')[1:]\n    current = yaml_obj\n    \n    for key in keys:\n        if not isinstance(current, dict):\n            return 'no such property'\n        \n        if key not in current:\n            return 'no such property'\n        \n        current = current[key]\n    \n    if isinstance(current, dict):\n        return 'object'\n    \n    return f'string \"{current}\"'",
    "timestamp": "2025-08-13 07:03:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import re\n\ndef parse_yaml(yaml_str):\n    lines = yaml_str.split('\\n')\n    stack = []\n    current_indent = 0\n    root = {}\n    stack.append((current_indent, root))\n    \n    for line in lines:\n        stripped = line.strip()\n        if not stripped or stripped.startswith('#'):\n            continue\n        \n        indent = len(line) - len(line.lstrip())\n        key_value = stripped.split(':', 1)\n        key = key_value[0].strip()\n        \n        while stack and stack[-1][0] >= indent:\n            stack.pop()\n        \n        current_indent, current_dict = stack[-1]\n        \n        if len(key_value) == 1:\n            new_dict = {}\n            current_dict[key] = new_dict\n            stack.append((indent, new_dict))\n        else:\n            value = key_value[1].strip()\n            if not value:\n                new_dict = {}\n                current_dict[key] = new_dict\n                stack.append((indent, new_dict))\n            else:\n                if value.startswith('\"') and value.endswith('\"'):\n                    value = value[1:-1]\n                current_dict[key] = value\n    \n    return root\n\ndef query_yaml(yaml_obj, query):\n    keys = query.split('.')[1:]  # Split and ignore the leading dot\n    current = yaml_obj\n    \n    for key in keys:\n        if isinstance(current, dict) and key in current:\n            current = current[key]\n        else:\n            return 'no such property'\n    \n    if isinstance(current, dict):\n        return 'object'\n    elif isinstance(current, str):\n        return f'string \"{current}\"'\n    else:\n        return 'no such property'\n\ndef solve_yaml_query(yaml_str, query):\n    try:\n        yaml_obj = parse_yaml(yaml_str)\n        return query_yaml(yaml_obj, query)\n    except:\n        return 'no such property'",
    "timestamp": "2025-08-13 07:03:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nclass YAMLParser {\npublic:\n    YAMLParser() {}\n\n    map<string, YAMLParser> mapContent;\n    string strContent;\n    bool isObject = false;\n    bool isString = false;\n\n    void parseYAML(istream &stream);\n    string queryYAML(const vector<string> &query);\n\nprivate:\n    void parseContent(istream &stream);\n    string trim(const string &str);\n};\n\nvoid YAMLParser::parseYAML(istream &stream) {\n    string line;\n    while (getline(stream, line)) {\n        line = trim(line);\n        if (line.empty()) continue;\n\n        size_t colonPos = line.find(\":\");\n        if (colonPos == string::npos) continue;\n\n        string key = trim(line.substr(0, colonPos));\n        string value = trim(line.substr(colonPos + 1));\n\n        if (!value.empty() && value[0] != '-' && value.find(\":\") == string::npos) {\n            mapContent[key].strContent = value;\n            mapContent[key].isString = true;\n        } else {\n            stringstream ss(value);\n            mapContent[key].parseContent(ss);\n            mapContent[key].isObject = true;\n        }\n    }\n}\n\nvoid YAMLParser::parseContent(istream &stream) {\n    parseYAML(stream);\n}\n\nstring YAMLParser::queryYAML(const vector<string> &query) {\n    const YAMLParser* current = this;\n\n    for (const string &key : query) {\n        if (current->mapContent.count(key) == 0) {\n            return \"no such property\";\n        }\n        current = &current->mapContent.at(key);\n    }\n\n    if (current->isString) {\n        return \"string \\\"\" + current->strContent + \"\\\"\";\n    } else if (current->isObject) {\n        return \"object\";\n    } else {\n        return \"no such property\";\n    }\n}\n\nstring YAMLParser::trim(const string &str) {\n    const char* whitespace = \" \\t\\n\\r\";\n    size_t start = str.find_first_not_of(whitespace);\n    if (start == string::npos) return \"\";\n    size_t end = str.find_last_not_of(whitespace);\n    return str.substr(start, end - start + 1);\n}\n\nint main() {\n    string yamlInput;\n    cout << \"Enter YAML content:\" << endl;\n    yamlInput.assign(istreambuf_iterator<char>(cin), istreambuf_iterator<char>());\n\n    YAMLParser yamlParser;\n    stringstream ss(yamlInput);\n    yamlParser.parseYAML(ss);\n\n    string queryString;\n    cout << \"Enter query:\" << endl;\n    cin >> queryString;\n\n    vector<string> query;\n    stringstream queryStream(queryString);\n    string segment;\n    while (getline(queryStream, segment, '.')) {\n        if (!segment.empty()) query.push_back(segment);\n    }\n\n    string result = yamlParser.queryYAML(query);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:35:40"
  }
]