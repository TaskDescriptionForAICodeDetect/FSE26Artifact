[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ndouble pro[11][200];\n\ntypedef vector<vector<double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<double> gausu(mat A, vector<double> b){\n  int n=SZ(A);\n  vector<double> ret(n);\n\n  rep(i,n){\n    double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<double>(n*k+1));\n  vector<double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n  /*\n  if(s<8000){\n    cout << dp[s] << endl;\n    return 0;\n  }\n  */\n  \n  mat A(n*k+1,vector<double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8f\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef vector<long double> Array;\ntypedef vector<Array> Matrix;\n\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.3Lf \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nArray GaussElimination(Matrix matrix, Array vect) {\n  const int n = vect.size();\n  Array ret(n, 0.0);\n  REP(x, n) {\n    int pivot = x;\n    FOR(i, x + 1, n) {\n      if (fabs(matrix[i][x]) - fabs(matrix[pivot][x]) > EPS) { pivot = i; }\n    }\n    swap(matrix[x], matrix[pivot]);\n    swap(vect[x], vect[pivot]);\n    if (fabs(matrix[x][x]) < EPS) { continue; }\n    FOR(y, x + 1, n) {\n      long double ratio = -matrix[y][x] / matrix[x][x];\n      matrix[y][x] = 0.0;\n      FOR(i, x + 1, n) {\n        matrix[y][i] += matrix[x][i] * ratio;\n      }\n      vect[y] += vect[x] * ratio;\n    }\n  }\n  for (int x = n - 1; x >= 0; x--) {\n    long double sum = vect[x];\n    for (int i = n - 1; i > x; i--) {\n      sum -= ret[i] * matrix[x][i];\n    }\n    ret[x] = sum / matrix[x][x];\n  }\n  return ret;\n}\n\nMatrix mul(const Matrix &lhs, const Matrix &rhs) {\n  const int in = lhs[0].size();\n  const int h = lhs.size();\n  const int w = rhs[0].size();\n  assert((int)rhs.size() == in);\n  Matrix ret(h, Array(w, 0));\n  REP(y, h) REP(i, in) REP(x, w) {\n    ret[y][x] += lhs[y][i] * rhs[i][x];\n  }\n  return ret;\n}\n\nMatrix pow(Matrix base, ll power) {\n  const int h = base.size();\n  const int w = base[0].size();\n  assert(h == w);\n  Matrix ret(h, Array(w, 0));\n  REP(i, h) { ret[i][i] = 1; }\n  while (power > 0) {\n    if (power & 1) {\n      ret = mul(ret, base);\n    }\n    base = mul(base, base);\n    power >>= 1;\n  }\n  return ret;\n}\n\nlong double probability[20][210];\nll s;\nint n, k;\nint nk;\n\nlong double naive(const Array &lastDist) {\n  long double ret = 0.0;\n  map<ll, long double> dists;\n  dists[s] = 1.0;\n  while (!dists.empty()) {\n    ll pos = dists.rbegin()->first;\n    long double p = dists.rbegin()->second;\n    assert(p >= -EPS);\n    dists.erase(pos);\n    if (pos < nk) {\n      ret += lastDist[pos] * p;\n      continue;\n    }\n    ret += p;\n    FOREQ(i, 1, nk) {\n      assert(pos >= i);\n      dists[pos - i] += p * probability[k][i];\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%lld %d %d\", &s, &n, &k) > 0) {\n\n    // initialize\n    MEMSET(probability, 0);\n    nk = n * k;\n\n    // corner case\n    s = abs(s);\n    if (n == 1) {\n      ll ans = -1;\n      if (s % k == 0) { ans = s / k; }\n      printf(\"%lld\\n\", ans);\n      continue;\n    }\n\n    // calc probability\n    probability[0][0] = 1.0;\n    REP(i, k) {\n      REP(j, nk) {\n        REP(d, n) {\n          probability[i + 1][j + d + 1] += 1.0 / n * probability[i][j];\n        }\n      }\n    }\n\n    // calc last loop\n    Matrix matrix(nk, Array(nk, 0.0));\n    Array vect(nk, 1.0);\n    matrix[0][0] = 1.0;\n    vect[0] = 0.0;\n    FOR(i, 1, nk) {\n      matrix[i][i] = 1.0;\n      vect[i] = 1.0;\n      FOREQ(j, 1, nk) {\n        int d = abs(i - j);\n        assert(d < nk);\n        matrix[i][d] -= probability[k][j];\n      }\n    }\n    Array lastDist = GaussElimination(matrix, vect);\n\n    // calc answer\n    long double ans = 0.0;\n    if (s < nk) {\n      ans = lastDist[s];\n    } else {\n      Matrix base(nk + 1, Array(nk + 1, 0.0));\n      REP(i, nk) {\n        base[0][i] = probability[k][i + 1];\n        base[nk][i] = probability[k][i + 1];\n      }\n      base[0][nk] = 0.0;\n      base[nk][nk] = 1.0;\n      REP(i, nk - 1) {\n        base[i + 1][i] = 1.0;\n      }\n      base = pow(base, s);\n      REP(i, nk) {\n        long double p = base[i][0];\n        REP(j, nk - i - 1) {\n          p -= probability[k][j + 1] * base[i + j + 1][0];\n          ans -= probability[k][j + 1] * base[i + j + 1][0];\n        }\n        ans += p * lastDist[i];\n      }\n      ans += base[nk][0];\n    }\n\n    printf(\"%.12Lf\\n\", ans + EPS);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define Z (128)\n\nvoid mul(double (*a)[Z], const double (*b)[Z]) {\n    static double t[Z][Z];\n    memset(t, 0, sizeof(t));\n    rep(k, Z) rep(i, Z) rep(j, Z) t[i][j] += a[i][k]*b[k][j];\n    memcpy(a, t, sizeof(t));\n}\n\nvoid pow(double (*a)[Z], int x) {\n    static double p[Z][Z];\n    memcpy(p, a, sizeof(p));\n    rep(i, Z) rep(j, Z) a[i][j] = i==j ? 1.0 : 0.0;\n    rep(b, 32) {\n        if(x&(1<<b)) mul(a, p);\n        mul(p, p);\n    }\n}\n\nvoid eqsolve(int n, double (*a)[Z]) {\n    rep(k, n) {\n        double mx = -1;\n        int ix = -1;\n        for(int i=k; i<n; i++) if(mx<fabs(a[i][k])) mx=fabs(a[i][k]), ix=i;\n        if(k!=ix) rep(i, n+1) swap(a[k][i], a[ix][i]);\n        const double p = a[k][k];\n        for(int i=k; i<=n; i++) a[k][i] /= p;\n        rep(i, n) if(i!=k) {\n            const double d = a[i][k];\n            for(int j=k; j<=n; j++) a[i][j] -= d*a[k][j];\n        }\n    }\n}\n\nint S, N, K;\ndouble p[Z][Z], eqs[Z][Z], mat[Z][Z];\n\nint main() {\n    scanf(\"%d%d%d\", &S, &N, &K);\n    S = abs(S);\n    if(N==1) {\n        printf(\"%.9f\\n\", S%K==0 ? (double)(S/K) : 0.0);\n        return 0;\n    }\n    p[0][0] = 1.0;\n    const int M = N*K+1;\n    rep(i, K) rep(j, M) rep(k, N) p[i+1][j+k+1] += p[i][j]/N;\n    eqs[0][0] = 1;\n    for(int k=1; k<M; k++) {\n        eqs[k][k] = 1;\n        rep(j, M) eqs[k][abs(k-j)] -= p[K][j];\n        eqs[k][M] = -1;\n    }\n    eqsolve(M, eqs);\n    if(S<M) printf(\"%.9f\\n\", fabs(eqs[S][M]));\n    else {\n        rep(i, M) mat[0][i] = p[K][i+1];\n        mat[0][M] = 1;\n        rep(i, M-1) mat[i+1][i] = 1;\n        mat[M][M] = 1;\n        pow(mat, S-M+1);\n        double ans = 0;\n        rep(i, M) ans += mat[0][i]*fabs(eqs[M-1-i][M]);\n        ans += mat[0][M];\n        printf(\"%.9f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef valarray<double> vec;\ntypedef valarray<vec> mat;\n\n// forward elimination\n\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tint r=0,c=0;\n\trep(i,n-1){\n\t\tdouble amax=0.0;\n\t\tint index=-1;\n\n\t\twhile(c<m&&index==-1){\n\t\t\trange(j,i,n) if(amax<abs(a[j][c])) amax=abs(a[j][c]),index=j;\n\t\t\tif(index==-1)\n\t\t\t\tc++;\n\t\t\telse if(i!=index)\n\t\t\t\tswap(a[i],a[index]);\n\t\t}\n\t\tif(index==-1) break;\n\n\t\trange(j,i+1,n){\n\t\t\tdouble d=a[j][c]/a[i][c];\n\t\t\trange(k,c,m) a[j][k]-=a[i][k]*d;\n\t\t}\n\t\tc++;\n\t}\n\tint rank=0,add=0;\n\tr=0,c=0;\n\twhile(r<n&&c<m-1){\n\t\twhile(c<m-1&&a[r][c]==0.0) c++;\n\t\tif(c==m-1) break;\n\t\trank++,r++;\n\t\twhile(r<n&&a[r][c]!=0.0) r++;\n\t\tif(r==n) break;\n\t}\n\n\tif(r<n) range(i,r,n) if(a[i][m-1]!=0.0) add=1;\n\n\treturn rank+add;\n}\n\n//backward substitution\n\nvec back(mat &a){\n\tint n=a.size(),m=a[0].size();\n\n\tvec x(0.0,n);\n\tx[n-1]=1.0;\n\tfor(int i=n-2;i>=0;i--){\n\t\tdouble sum=0.0;\n\t\tif(i+1<n) range(j,i+1,n) sum+=a[i][j]*x[j];\n\t\tx[i]=1.0/a[i][i]*(a[i][m-1]-sum);\n\t}\n\t// rep(i,n) cout << x[i] << endl;\n\treturn x;\n}\n\nint s,n,k;\ndouble dp[11][120];\n\nvoid init(int m){\n\tdp[0][0]=1.0;\n\trep(i,k)rep(j,m+1){\n\t\trange(add,1,n+1){\n\t\t\tdp[i+1][j+add]+=1.0*dp[i][j]/n;\n\t\t}\n\t}\n\treturn;\n}\n\nmat mul(mat a,mat b){\n\tint m=a.size();\n\tmat c(vec(0.0,m),m);\n\trep(i,m)rep(j,m) rep(k,m) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\n\nmat power(mat a,ll n){\n\tint m=a.size();\n\tmat b(vec(0.0,m),m);\n\trep(i,m) b[i][i]=1.0;\n\twhile(n){\n\t\tif(n&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nint main(void){\n\tcin >> s >> n >> k;\n\tif(s==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\ts=abs(s);\n\tint m=n*k+1;\n\tinit(m);\n\tmat a(vec(0.0,m+1),m);\n\n\trep(i,m) a[i][i]-=1.0;\n\trep(i,m-1){\n\t\tint cur=i+1;\n\t\trep(j,m){\n\t\t\tint tar=abs(cur-j);\n\t\t\tif(tar>0) a[i][tar-1]+=dp[k][j];\n\t\t}\n\t}\n\trep(i,m) a[i][m-1]+=1.0;\n\trep(i,m) a[i][m]=0.0;\n\n\tforward(a);\n\tvec x=back(a);\n\n\tcout.precision(20);\n\tif(s<=n*k){\n\t\tcout << fixed <<  x[s-1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat b(vec(0.0,m),m);\n\trep(i,m-1) b[i][i+1]=1.0;\n\trep(i,m-1) b[m-2][i]=dp[k][m-1-i];\n\tb[m-2][m-1]=1.0;\n\tb[m-1][m-1]=1.0;\n\n\tint idx=s-n*k;\n\tb=power(b,idx);\n\tdouble ans=0.0;\n\trep(i,m) ans+=b[m-2][i]*x[i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "double pro[11][200];\n \ntypedef vector<vector<double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n \nvector<double> gausu(mat A, vector<double> b){\n  int n=SZ(A);\n  vector<double> ret(n);\n \n  rep(i,n){\n    double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];     \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<double>(n*k+1));\n  vector<double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  /*\n  if(s<8000){\n    cout << dp[s] << endl;\n    return 0;\n  }\n  */\n   \n  mat A(n*k+1,vector<double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8f\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-8;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            cout << B[pivot][x] << endl;\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) if(prob[from] > EPS) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.8Lf\\n\",ex[s]);\n    //cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  long double dp[10000]={0};\n  for(ll i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(ll j=n*k+1;j<10000;++j)\n    for(ll i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n\n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX2 501001\n#define MAX 500001\n#define NKMAX 101\n\nint NK;\ndouble dp[MAX2];\ndouble p[NKMAX];\n\nint S, N, K;\n\ndouble calc(int a) {\n\tif (a == 0) return 0;\n\tdouble ans = 1;\n\tif (a <= MAX) {\n\t\tfor (int i = 0; i < NKMAX; i++)\n\t\t{\n\t\t\tans += dp[abs(a - i)] * p[i];\n\t\t}\n\t\tdp[a] = ans;\n\t}\n\telse ans = dp[MAX] + (a - MAX) / (N + 1.0) / K * 2;\n\treturn ans;\n}\n\nint main() {\n\tcin >> S >> N >> K;\n\tS = abs(S);\n\tp[0] = 1;\n\tfor (int k = 0; k < K; k++)\n\t{\n\t\tfor (int i = N * k; i >= 0; i--)\n\t\t{\n\t\t\tdouble move = p[i] / N;\n\t\t\tfor (int j = 1; j <= N; j++)\n\t\t\t{\n\t\t\t\tp[i + j] += move;\n\t\t\t}\n\t\t\tp[i] = 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < MAX2; i++) dp[i] = MAX;\n\tfor (int i = 0; i < 10000; i++)\n\t\tfor (int j = 1; j <= NKMAX; j++)\n\t\t\tcalc(j);\n\tfor (int i = 1; i <= MAX; i++) calc(i);\n\n\tprintf(\"%.14f\\n\", calc(S));\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef valarray<double> vec;\ntypedef valarray<vec> mat;\n\n// forward elimination\n\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tint r=0,c=0;\n\trep(i,n-1){\n\t\tdouble amax=0.0;\n\t\tint index=-1;\n\n\t\twhile(c<m&&index==-1){\n\t\t\trange(j,i,n) if(amax<abs(a[j][c])) amax=abs(a[j][c]),index=j;\n\t\t\tif(index==-1)\n\t\t\t\tc++;\n\t\t\telse if(i!=index)\n\t\t\t\tswap(a[i],a[index]);\n\t\t}\n\t\tif(index==-1) break;\n\n\t\trange(j,i+1,n){\n\t\t\tdouble d=a[j][c]/a[i][c];\n\t\t\trange(k,c,m) a[j][k]-=a[i][k]*d;\n\t\t}\n\t\tc++;\n\t}\n\tint rank=0,add=0;\n\tr=0,c=0;\n\twhile(r<n&&c<m-1){\n\t\twhile(c<m-1&&a[r][c]==0.0) c++;\n\t\tif(c==m-1) break;\n\t\trank++,r++;\n\t\twhile(r<n&&a[r][c]!=0.0) r++;\n\t\tif(r==n) break;\n\t}\n\n\tif(r<n) range(i,r,n) if(a[i][m-1]!=0.0) add=1;\n\n\treturn rank+add;\n}\n\n//backward substitution\n\nvec back(mat &a){\n\tint n=a.size(),m=a[0].size();\n\n\tvec x(0.0,n);\n\tx[n-1]=1.0;\n\tfor(int i=n-2;i>=0;i--){\n\t\tdouble sum=0.0;\n\t\tif(i+1<n) range(j,i+1,n) sum+=a[i][j]*x[j];\n\t\tx[i]=1.0/a[i][i]*(a[i][m-1]-sum);\n\t}\n\t// rep(i,n) cout << x[i] << endl;\n\treturn x;\n}\n\nint s,n,k;\ndouble dp[11][120];\n\nvoid init(int m){\n\tdp[0][0]=1.0;\n\trep(i,k)rep(j,m+1){\n\t\trange(add,1,n+1){\n\t\t\tdp[i+1][j+add]+=1.0*dp[i][j]/n;\n\t\t}\n\t}\n\treturn;\n}\n\nmat mul(mat a,mat b){\n\tint m=a.size();\n\tmat c(vec(0.0,m),m);\n\trep(i,m)rep(j,m) rep(k,m) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\n\nmat power(mat a,ll n){\n\tint m=a.size();\n\tmat b(vec(0.0,m),m);\n\trep(i,m) b[i][i]=1.0;\n\twhile(n){\n\t\tif(n&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nint main(void){\n\tcin >> s >> n >> k;\n\ts=abs(s);\n\tif(s==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif(n==1){\n\t\tif(s%k)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << s/k << endl;\n\t\treturn 0;\n\t}\n\tint m=n*k+1;\n\tinit(m);\n\tmat a(vec(0.0,m+1),m);\n\n\trep(i,m) a[i][i]-=1.0;\n\trep(i,m-1){\n\t\tint cur=i+1;\n\t\trep(j,m){\n\t\t\tint tar=abs(cur-j);\n\t\t\tif(tar>0) a[i][tar-1]+=dp[k][j];\n\t\t}\n\t}\n\trep(i,m) a[i][m-1]+=1.0;\n\trep(i,m) a[i][m]=0.0;\n\n\tforward(a);\n\tvec x=back(a);\n\n\tcout.precision(20);\n\tif(s<=n*k){\n\t\tcout << fixed <<  x[s-1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat b(vec(0.0,m),m);\n\trep(i,m-1) b[i][i+1]=1.0;\n\trep(i,m-1) b[m-2][i]=dp[k][m-1-i];\n\tb[m-2][m-1]=1.0;\n\tb[m-1][m-1]=1.0;\n\n\tint idx=s-n*k;\n\tb=power(b,idx);\n\tdouble ans=0.0;\n\trep(i,m) ans+=b[m-2][i]*x[i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <random>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvector< vector<double> > matmul(vector< vector<double> >& A, vector< vector<double> >& B) {\n\tint n = A.size();\n\tvector< vector<double> > C(n, vector<double>(n));\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tC[i][j] += A[i][k] * B[k][j];\n\treturn C;\n}\n\nvector< vector<double> > matpow(vector< vector<double> > A, ll x) {\n\tint n = A.size();\n\tvector< vector<double> > B(n, vector<double>(n));\n\tfor (int i = 0; i < n; i++) B[i][i] = 1;\n\twhile (x > 0) {\n\t\tif (x % 2) B = matmul(B, A);\n\t\tx /= 2;\n\t\tA = matmul(A, A);\n\t}\n\treturn B;\n}\n\nint main() {\n\tint S, N, K; cin >> S >> N >> K;\n\tif (S < 0) S *= -1;\n\tint n = N * K;\n\tvector<double> p(n + 1);\n\tp[0] = 1;\n\twhile (K--) {\n\t\tvector<double> _p(n + 1);\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tif (p[i])\n\t\t\t\tfor (int j = 1; j <= N; j++)\n\t\t\t\t\t_p[i + j] += p[i] / N;\n\t\tp = _p;\n\t}\n\tvector<vector<double> > a(n + 1, vector<double>(n + 1));\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tint _i = abs(i - j);\n\t\t\ta[i][_i] += p[j];\n\t\t}\n\t\ta[i][n] = 1;\n\t}\n\ta[n][n] = 1;\n\tvector<vector<double> > b = matpow(a, 1e18);\n\tif (S <= n - 1) {\n\t\tprintf(\"%.10f\\n\", b[S][n]);\n\t\treturn 0;\n\t}\n\ta = vector<vector<double> >(n + 1, vector<double>(n + 1));\n\tfor (int i = 0; i + 1 < n; i++)\n\t\ta[i][i + 1] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\ta[n - 1][i] = p[n - i];\n\ta[n - 1][n] = a[n][n] = 1;\n\tvector<vector<double> > c = matpow(a, S - (n - 1));\n\tdouble ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tans += c[n - 1][i] * b[i][n];\n\tans += c[n - 1][n];\n\tprintf(\"%.10f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n \nvector<long double> gausu(mat A, vector<long double> b){\n  int n=SZ(A);\n  vector<long double> ret(n);\n \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];     \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX = 1000;\nconst int iter = 3000;\ndouble memo[iter + 1][MAX];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  // REP(i,n*k+1) printf(\"%d: %.2f\\n\", i, prob[i]);\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n    // printf(\"iter: %d => %.2f\\n\", cc, ans);\n    // printf(\"prob: \");\n    // REP(i,s+1) printf(\"%.2f \", memo[cc+1][i]); puts(\"\");\n  }\n\n  if(ans < 1e-10)\n    puts(\"-1\");\n  else\n    printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nconst int N_MAX=100;\nbool Gauss_Jordan(int n,const double A[N_MAX][N_MAX],const double *b,double *x){\n\tstatic double B[N_MAX][N_MAX+1];\n\trep(i,n){\n\t\trep(j,n) B[i][j]=A[i][j];\n\t\tB[i][n]=b[i];\n\t}\n\n\trep(i,n){\n\t\tint piv=i;\n\t\tfor(int j=i;j<n;j++) if(abs(B[j][i])>abs(B[piv][i])) piv=j;\n\t\trep(j,n+1) swap(B[i][j],B[piv][j]);\n\n\t\tif(abs(B[i][i])<EPS) return false;\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\trep(j,n) if(i!=j) for(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t}\n\n\trep(i,n) x[i]=B[i][n];\n\treturn true;\n}\n\nint main(){\n\tint s,n,k; scanf(\"%d%d%d\",&s,&n,&k);\n\ts=abs(s);\n\n\tdouble p[101]={1};\n\trep(i,k){\n\t\tdouble q[101]={};\n\t\tfor(int j=1;j<=n;j++) rep(x,101-j) q[x+j]+=p[x]/n;\n\t\tcopy(q,q+101,p);\n\t}\n\n\tstatic double A[N_MAX][N_MAX];\n\tdouble b[N_MAX],E_small[N_MAX];\n\tA[0][0]=1;\n\tfor(int i=1;i<n*k;i++){\n\t\tA[i][i]=1;\n\t\trep(j,n*k+1) A[i][abs(i-j)]-=p[j];\n\t\tb[i]=1;\n\t}\n\tGauss_Jordan(n*k,A,b,E_small);\n\n\tif(s<n*k){\n\t\tprintf(\"%.15f\\n\",E_small[s]);\n\t\treturn 0;\n\t}\n\n\tstatic double P[101][101];\n\trep(i,n*k) P[0][i]=p[i+1];\n\tP[0][n*k]=P[n*k][n*k]=1;\n\trep(i,n*k-1) P[i+1][i]=1;\n\n\tdouble v[101];\n\trep(i,n*k) v[i]=E_small[n*k-i-1];\n\tv[n*k]=1;\n\n\trep(t,30){\n\t\tdouble v2[101]={};\n\t\tif((s-n*k+1)&(1<<t)){\n\t\t\trep(i,n*k+1) rep(j,n*k+1) v2[i]+=P[i][j]*v[j];\n\t\t\tcopy(v2,v2+n*k+1,v);\n\t\t}\n\n\t\tdouble P2[101][101]={};\n\t\trep(i,n*k+1) rep(j,n*k+1) rep(l,n*k+1) P2[i][j]+=P[i][l]*P[l][j];\n\t\trep(i,n*k+1) rep(j,n*k+1) P[i][j]=P2[i][j];\n\t}\n\n\tprintf(\"%.15f\\n\",v[0]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nnamespace ProconLib{\n    \n    template<typename T>\n    struct Detail{\n        static constexpr T EPS = T(1e-15);\n        static bool isZero(T v){\n            return abs(v)<=EPS;\n        }\n    };\n\n    template<typename T>\n    class Vector{\n        int N;\n        std::vector<T> dat;\n        public:\n        Vector(int n):N(n),dat(n){}\n        Vector(int n,T x):N(n),dat(n,x){}\n        Vector(std::vector<T> vec):N(vec.size()),dat(vec){}\n        Vector(const std::vector<T>& vec):N(vec.size()),dat(vec){}\n        Vector(const Vector& vec){dat=vec.dat;}\n        int size(){return N;}\n        T& operator[](int pos){return dat[pos];};\n        const T& operator[](int pos) const{return dat[pos];};\n        T& at(int pos){return dat.at(pos);}\n        const T& at(int pos) const {return dat.at(pos);}\n    };\n    \n    template<typename T>\n    class Matrix{\n        int r,c;\n        std::vector<Vector<T>> dat;\n        public:\n        Matrix(int r,int c):r(r),c(c),dat(r,Vector<T>(c)){}\n        Matrix(int r,int c,T x):r(r),c(c),dat(r,Vector<T>(c,x)){}\n\n        Vector<T>& operator[](int pos){return dat[pos];};\n        const Vector<T>& operator[](int pos) const{return dat[pos];};\n        Vector<T>& at(int pos){return dat.at(pos);}\n        const Vector<T>& at(int pos) const {return dat.at(pos);}\n        int rowSize() const {return r;}\n        int colSize() const {return c;}\n    };\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs);\n    template<typename T>\n    Matrix<T> Identity(int n);\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k);\n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat);\n    template<typename T>\n    int rank(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat);\n    \n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]+rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]-rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    \n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs){\n        assert(lhs.colSize()==rhs.rowSize());\n        int r=lhs.rowSize(),c=rhs.colSize(),l=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int k=0;k<l;k++){\n                for(int j=0;j<c;j++){\n                    res[i][j]+=lhs[i][k]*rhs[k][j];\n                }\n            }\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> Identity(int n){\n        assert(n>=0);\n        Matrix<T> res(n,n);\n        for(int i=0;i<n;i++){\n            res[i][i]=1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k){\n        assert(mat.rowSize()==mat.colSize());\n        Matrix<T> x=mat;\n        Matrix<T> res=Identity<T>(mat.rowSize());\n        while(k){\n            if(k&1) res=res*x;\n            x=x*x;\n            k>>=1;\n        }\n        return res;\n    }\n    \n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        int row=0;\n        for(int j=0;j<n;j++){\n            if(row==m) break;\n            int tar=-1;\n            T v=Detail::EPS;\n            for(int i=row;i<m;i++){\n                if(!Detail::isZero(mat[i][j]) && abs(v)<abs(mat[i][j])){\n                    tar=i;\n                    v=mat[i][j];\n                }\n            }\n            if(tar==-1) continue;\n            if(row!=tar){ \n                auto tmp=mat[row];\n                mat[row]=mat[tar];\n                mat[tar]=tmp;\n            }\n            for(int i=row+1;i<m;i++){\n                if(!Detail::isZero(mat[i][j])){\n                    T r=mat[i][j]/mat[row][j];\n                    for(int k=j;k<n;k++){\n                        mat[i][k]-=r*mat[row][k];\n                    }\n                }\n            }\n            row++;\n        }\n        return mat;\n    }\n\n    template<typename T,typename Detail=Detail<T>>\n    int rank(const Matrix<T>& mat){\n        auto tmp=gaussialElimination(mat);\n        int m=tmp.rowSize(),n=tmp.colSize();\n        int i=0,j=0;\n        while(i<m && j<n){\n            if(Detail::isZero(tmp[i][j])) j++;\n            else i++,j++;\n        }\n        return i;\n    }\n\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat){\n        assert(mat.rowSize()==mat.colSize());\n        int n=mat.rowSize();\n        Matrix<T> tmp(n,2*n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                tmp[i][j]=mat[i][j];\n                tmp[i][j+n]=0;\n            }\n            tmp[i][i+n]=1;\n        }\n        mat=gaussianElimination(mat);\n        Matrix<T> res(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                res[i][j]=mat[i][j+n]/=mat[i][i];\n            }\n        }\n        return res;\n    }\n \n    template<typename T>\n    void debug(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        std::cerr<<\"###Matrix_Debug###\"<<std::endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                std::cerr<<mat[i][j]<<\" \";\n            }\n            std::cerr<<std::endl;\n        }\n    }\n}\n\nusing namespace ProconLib;\n\nint main(){\n    int s,n,k;\n    cin>>s>>n>>k;\n    if(n==1){\n        cout<<(s%k==0 ? abs(s)/k : -1)<<endl;\n        return 0;\n    }\n    \n    int sz=n*k+1;\n    \n    vector<vector<double>> dp(k+1,vector<double>(sz));\n    dp[0][0]=1;\n    for(int i=0;i<k;i++){\n        for(int j=0;j<sz;j++){\n            for(int k=1;k<=n;k++){\n                if(j+k<sz) dp[i+1][j+k]+=dp[i][j]/n;\n            }\n        }\n    }\n    \n    Matrix<double> B(sz,sz+1);\n    {\n        B[0][0]=1;\n        B[0][sz]=0;\n        for(int i=1;i<sz;i++){\n            B[i][i]=-1;\n            for(int j=0;j<sz;j++){\n                // i to j\n                int d=i-j;\n                if(0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n                d=i+j;\n                if(j!=0 && 0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n            }\n        }\n    }\n    B=gaussianElimination(B);\n    Vector<double> vec(sz+1);\n    for(int i=sz-1;i>=0;i--){\n        for(int j=0;j<i;j++){\n            B[j][sz]-=B[j][i]/B[i][i]*B[i][sz];\n            B[j][i]=0;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        vec[sz-i-1]=B[i][sz]/B[i][i];\n    }\n    vec[sz]=1;\n\n    Matrix<double> A(sz+1,sz+1);\n    for(int i=1;i<sz;i++){\n        A[i][i-1]=1;\n    }\n    A[sz][sz]=1;\n    for(int i=0;i<sz;i++){\n        int d=i+1;\n        if(d<sz) A[0][i]=dp[k][d];\n        if(d<sz) A[0][sz]+=dp[k][d];\n    }\n    A=pow(A,abs(s));\n    double res=0;\n    for(int i=0;i<=sz;i++){\n        res+=A[sz-1][i]*vec[i];\n    }\n    cout<<fixed<<setprecision(10);\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 501;\n\nconst long double EPS = 1e-8;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        if(N == 1) {\n            if(S % K == 0) {\n                cout << S / K << endl;\n            }else {\n                cout << -1 << endl;\n            }\n            continue;\n        }\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            assert(false);\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (1.0 * S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  cerr << s << ' ' << n << ' ' << k << endl;\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-8)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX2 101001\n#define MAX 100001\n#define NKMAX 101\n\nint NK;\ndouble dp[MAX2];\ndouble p[NKMAX];\n\nint S, N, K;\n\ndouble calc(int a) {\n\t\n\tdouble ans = 1;\n\tif (a < MAX) {\n\t\tfor (int i = 0; i < NKMAX; i++)\n\t\t{\n\t\t\tans += dp[abs(a - i)] * p[i];\n\t\t}\n\t\tdp[a] = ans;\n\t}\n\telse ans = dp[MAX] + (a - MAX) / (N + 1.0) / K * 2;\n\treturn ans;\n}\n\nint main() {\n\tcin >> S >> N >> K;\n\tS = abs(S);\n\tp[0] = 1;\n\tfor (int k = 0; k < K; k++)\n\t{\n\t\tfor (int i = N * k; i >= 0; i--)\n\t\t{\n\t\t\tdouble move = p[i] / N;\n\t\t\tfor (int j = 1; j <= N; j++)\n\t\t\t{\n\t\t\t\tp[i + j] += move;\n\t\t\t}\n\t\t\tp[i] = 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < MAX2; i++) dp[i] = MAX;\n\tfor (int i = 0; i < 10000; i++)\n\t\tfor (int j = 1; j <= NKMAX; j++)\n\t\t\tcalc(j);\n\tfor (int i = 1; i <= MAX; i++) calc(i);\n\n\tprintf(\"%.14f\\n\", calc(S));\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntemplate<class T>\nvector<vector<T> > matrixProduct(const vector<vector<T> >& x, const vector<vector<T> >& y)\n{\n\tint a = x.size();\n\tint b = x[0].size();\n\tint c = y[0].size();\n\tvector<vector<T> > z(a, vector<T>(c, 0));\n\tfor(int i=0; i<a; ++i){\n\t\tfor(int j=0; j<c; ++j){\n\t\t\tfor(int k=0; k<b; ++k){\n\t\t\t\tz[i][j] += x[i][k] * y[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\n\ntemplate <class T>\nvector<vector<T> > matrixPower(const vector<vector<T> >& x, int k)\n{\n\tint n = x.size();\n\tvector<vector<T> > y(n, vector<T>(n, 0));\n\tfor(int i=0; i<n; ++i)\n\t\ty[i][i] = 1;\n\n\tvector<vector<T> > z = x;\n\twhile(k > 0){\n\t\tif(k & 1)\n\t\t\ty = matrixProduct(y, z);\n\t\tz = matrixProduct(z, z);\n\t\tk >>= 1;\n\t}\n\treturn y;\n}\n\nvoid linearSystem(vector<vector<double> >& mat, vector<double>& x)\n{\n\tint n = mat.size();\n\tx.resize(n);\n\n\tfor(int i=0; i<n; ++i){\n\t\tfor(int j=n; j>=i; --j)\n\t\t\tmat[i][j] /= mat[i][i];\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(j == i)\n\t\t\t\tcontinue;\n\t\t\tfor(int k=n; k>=i; --k){\n\t\t\t\tmat[j][k] -= mat[i][k] * mat[j][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; ++i)\n\t\tx[i] = mat[i][n];\n}\n\nint main()\n{\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif(n == 1){\n\t\tif(s % k == 0)\n\t\t\tcout << (s / k) << endl;\n\t\telse\n\t\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<double> prob(n*k+1, 0.0);\n\tprob[0] = 1.0;\n\tfor(int i=0; i<k; ++i){\n\t\tvector<double> nextProb(n*k+1, 0.0);\n\t\tfor(int j=0; j<=n*(k-1); ++j){\n\t\t\tfor(int l=1; l<=n; ++l){\n\t\t\t\tnextProb[j+l] += prob[j] / n;\n\t\t\t}\n\t\t}\n\t\tprob.swap(nextProb);\n\t}\n\n\tvector<vector<double> > mat(n*k*2-1, vector<double>(n*k*2, 0.0));\n\tfor(int i=0; i<n*k*2-1; ++i){\n\t\tmat[i][i] = 1.0;\n\t\tif(i == n*k-1){\n\t\t\tcontinue;\n\t\t}\n\t\tmat[i][n*k*2-1] = 1.0;\n\t\tif(i < n*k-1){\n\t\t\tfor(int j=1; j<=n*k; ++j){\n\t\t\t\tmat[i][i+j] = -prob[j];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=1; j<=n*k; ++j){\n\t\t\t\tmat[i][i-j] = -prob[j];\n\t\t\t}\n\t\t}\n\t}\n\tvector<double> x;\n\tlinearSystem(mat, x);\n\tx = vector<double>(x.rbegin(), x.rbegin()+n*k);\n\tif(s < n*k){\n\t\tprintf(\"%.10f\\n\", x[n*k-1-s]);\n\t\treturn 0;\n\t}\n\n\tvector<vector<double> > y(n*k+1, vector<double>(n*k+1, 0.0));\n\ty[0][n*k] = 1.0;\n\ty[n*k][n*k] = 1.0;\n\tfor(int i=0; i<n*k-1; ++i)\n\t\ty[i+1][i] = 1.0;\n\tfor(int i=0; i<n*k; ++i)\n\t\ty[0][i] = prob[i+1];\n\ty = matrixPower(y, s-n*k+1);\n\n\tdouble ret = y[0][n*k];\n\tfor(int i=0; i<n*k; ++i)\n\t\tret += y[0][i] * x[i];\n\tprintf(\"%.10f\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef valarray<double> vec;\ntypedef valarray<vec> mat;\n\n// forward elimination\n\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tint r=0,c=0;\n\trep(i,n-1){\n\t\tdouble amax=0.0;\n\t\tint index=-1;\n\n\t\twhile(c<m&&index==-1){\n\t\t\trange(j,i,n) if(amax<abs(a[j][c])) amax=abs(a[j][c]),index=j;\n\t\t\tif(index==-1)\n\t\t\t\tc++;\n\t\t\telse if(i!=index)\n\t\t\t\tswap(a[i],a[index]);\n\t\t}\n\t\tif(index==-1) break;\n\n\t\trange(j,i+1,n){\n\t\t\tdouble d=a[j][c]/a[i][c];\n\t\t\trange(k,c,m) a[j][k]-=a[i][k]*d;\n\t\t}\n\t\tc++;\n\t}\n\tint rank=0,add=0;\n\tr=0,c=0;\n\twhile(r<n&&c<m-1){\n\t\twhile(c<m-1&&a[r][c]==0.0) c++;\n\t\tif(c==m-1) break;\n\t\trank++,r++;\n\t\twhile(r<n&&a[r][c]!=0.0) r++;\n\t\tif(r==n) break;\n\t}\n\n\tif(r<n) range(i,r,n) if(a[i][m-1]!=0.0) add=1;\n\n\treturn rank+add;\n}\n\n//backward substitution\n\nvec back(mat &a){\n\tint n=a.size(),m=a[0].size();\n\n\tvec x(0.0,n);\n\tx[n-1]=1.0;\n\tfor(int i=n-2;i>=0;i--){\n\t\tdouble sum=0.0;\n\t\tif(i+1<n) range(j,i+1,n) sum+=a[i][j]*x[j];\n\t\tx[i]=1.0/a[i][i]*(a[i][m-1]-sum);\n\t}\n\t// rep(i,n) cout << x[i] << endl;\n\treturn x;\n}\n\nint s,n,k;\ndouble dp[11][120];\n\nvoid init(int m){\n\tdp[0][0]=1.0;\n\trep(i,k)rep(j,m+1){\n\t\trange(add,1,n+1){\n\t\t\tdp[i+1][j+add]+=1.0*dp[i][j]/n;\n\t\t}\n\t}\n\treturn;\n}\n\nmat mul(mat a,mat b){\n\tint m=a.size();\n\tmat c(vec(0.0,m),m);\n\trep(i,m)rep(j,m) rep(k,m) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\n\nmat power(mat a,ll n){\n\tint m=a.size();\n\tmat b(vec(0.0,m),m);\n\trep(i,m) b[i][i]=1.0;\n\twhile(n){\n\t\tif(n&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nint main(void){\n\tcin >> s >> n >> k;\n\tif(s==0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif(n==1&&s==k){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\ts=abs(s);\n\tint m=n*k+1;\n\tinit(m);\n\tmat a(vec(0.0,m+1),m);\n\n\trep(i,m) a[i][i]-=1.0;\n\trep(i,m-1){\n\t\tint cur=i+1;\n\t\trep(j,m){\n\t\t\tint tar=abs(cur-j);\n\t\t\tif(tar>0) a[i][tar-1]+=dp[k][j];\n\t\t}\n\t}\n\trep(i,m) a[i][m-1]+=1.0;\n\trep(i,m) a[i][m]=0.0;\n\n\tforward(a);\n\tvec x=back(a);\n\n\tcout.precision(20);\n\tif(s<=n*k){\n\t\tcout << fixed <<  x[s-1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat b(vec(0.0,m),m);\n\trep(i,m-1) b[i][i+1]=1.0;\n\trep(i,m-1) b[m-2][i]=dp[k][m-1-i];\n\tb[m-2][m-1]=1.0;\n\tb[m-1][m-1]=1.0;\n\n\tint idx=s-n*k;\n\tb=power(b,idx);\n\tdouble ans=0.0;\n\trep(i,m) ans+=b[m-2][i]*x[i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nnamespace detail {\n\nbool is_zero(double d) {\n    return (std::abs(d) < 1e-9);\n}\nbool is_zero(long double d) {\n    return (std::abs(d) < 1e-9);\n}\n\n}\n\ntemplate <typename T>\nclass matrix {\npublic:\n    matrix(int r, int c) \n        : v_(r, std::vector<T>(c)),\n          row_(r),\n          column_(c)\n    {}\n    matrix(std::vector<std::vector<T>> const& v)\n        : v_(v),\n          row_(v.size()),\n          column_((v.size() == 0 ? 0 : v[0].size()))\n    {}\n    matrix(matrix const&) = default;\n    matrix(matrix&&) = default;\n    matrix& operator=(matrix const&) = default;\n    matrix& operator=(matrix&&) = default;\n    ~matrix() = default;\n\n    std::vector<T>& operator[](unsigned int i) {\n        return v_[i];\n    }\n    const std::vector<T>& operator[](unsigned int i) const {\n        return v_[i];\n    }\n    matrix& operator+=(matrix const& other) {\n        assert(\"matrix operator+: row or column size does not match\" && other.row_size() == row_ && other.column_size() == column_);\n\n        for(int i=0; i<row_; ++i) {\n            for(int j=0; j<column_; ++j) {\n                v_[i][j] += other[i][j];\n            }\n        }\n        return *this;\n    }\n    matrix& operator-=(matrix const& other) {\n        assert(\"matrix operator-: row or column size does not match\" && other.row_size() == row_ && other.column_size() == column_);\n\n        for(int i=0; i<row_; ++i) {\n            for(int j=0; j<column_; ++j) {\n                v_[i][j] -= other[i][j];\n            }\n        }\n        return *this;\n    }\n\n    bool operator==(matrix const& rhs) const {\n        if(row_ != rhs.row_size() || column_ != rhs.column_size()) {\n            return false;\n        }\n        for(int i=0; i<row_; ++i) {\n            for(int j=0; j<column_; ++j) {\n                if(std::abs(v_[i][j] - rhs[i][j]) > 1e-9) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    bool operator!=(matrix const& rhs) {\n        return !(*this == rhs);\n    }\n\n    int row_size() const {\n        return row_;\n    }\n    int column_size() const {\n        return column_;\n    }\n\n    // for debug\n    void print() {\n        for(int i=0; i<row_; ++i) {\n            for(int j=0; j<column_; ++j) {\n                std::cout << v_[i][j];\n                if(j != column_ - 1) {\n                    std::cout << \" \";\n                }\n            }\n            std::cout << std::endl;\n        }\n    }\n\nprivate:\n    std::vector<std::vector<T>> v_;\n    int row_, column_;\n};\n\ntemplate <typename T>\nmatrix<T> operator-(matrix<T> m) {\n    for(int i=0; i<m.row_size(); ++i) {\n        for(int j=0; j<m.column_size(); ++j) {\n            m[i][j] = -m[i][j];\n        }\n    }\n}\n\ntemplate <typename T>\nmatrix<T> operator+(matrix<T> lhs, matrix<T> const& rhs) {\n    lhs += rhs;\n    return lhs;\n}\n\ntemplate <typename T>\nmatrix<T> operator-(matrix<T> lhs, matrix<T> const& rhs) {\n    lhs -= rhs;\n    return lhs;\n}\n\ntemplate <typename T>\nmatrix <T> operator*(matrix<T> const& lhs, matrix<T> const& rhs) {\n    assert(\"matrix operator*: lhs.column_size() != rhs.row_size()\" && lhs.column_size() == rhs.row_size());\n\n    matrix<T> ret(lhs.row_size(), rhs.column_size());\n    for(int i=0; i<ret.row_size(); ++i) {\n        for(int k=0; k<lhs.column_size(); ++k) {\n            for(int j=0; j<ret.column_size(); ++j) {\n                ret[i][j] += lhs[i][k] * rhs[k][j];\n            }\n        }\n    }\n    return ret;\n}\n\ntemplate <typename T>\nmatrix<T> eye(int n) {\n    matrix<T> res(n, n);\n    for(int i=0; i<n; ++i) {\n        res[i][i] = 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nmatrix<T> pow(matrix<T> x, long long y) {\n    assert(\"matrix pow: matrix is not square\" && x.column_size() == x.row_size());\n    matrix<T> ret = eye<T>(x.column_size());\n    while(y > 0) {\n        if(y & 1) {\n            ret = ret * x;\n        }\n        x = x * x;\n        y >>= 1;\n    }\n    return ret;\n}\n\nvector<double> gauss_jordan(matrix<double>& A, std::vector<double> const& b) {\n    int n = A.row_size();\n    matrix<double> B(n, n+1);\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            B[i][j] = A[i][j];\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        B[i][n] = b[i];\n    }\n\n    for(int i=0; i<n; ++i) {\n        int pivot = i;\n        for(int j=i; j<n; ++j) {\n            if(std::abs(B[j][i]) > std::abs(B[pivot][i])) {\n                pivot = j;\n            }\n        }\n        std::swap(B[i], B[pivot]);\n        if(std::abs(B[i][i]) < 1e-9) {\n            return std::vector<double>();\n        }\n\n        for(int j=i+1; j<=n; ++j) {\n            B[i][j] /= B[i][i];\n        }\n        for(int j=0; j<n; ++j) {\n            if(i != j) {\n                for(int k=i+1; k<=n; ++k) {\n                    B[j][k] -= B[j][i] * B[i][k];\n                }\n            }\n        }\n    }\n\n    std::vector<double> x(n);\n    for(int i=0; i<n; ++i) {\n        x[i] = B[i][n];\n    }\n    return x;\n}\n\n\nint main() {\n    int S, N, K;\n    cin >> S >> N >> K;\n    S = abs(S);\n    cout << fixed << setprecision(10);\n    if(N == 1) {\n        if(S % K == 0) {\n            cout << S / K << endl;\n        } else {\n            cout << -1 << endl;\n        }\n        return 0;\n    }\n    vector<vector<double>> p(K+1, vector<double>(N*K+1, 0));\n    p[0][0] = 1.0;\n    for(int i=0; i<K; ++i) {\n        for(int j=0; j<=N*K; ++j) {\n            for(int k=1; k<=N; ++k) {\n                if(j + k > N*K) continue;\n                p[i+1][j+k] += p[i][j] / N;\n            }\n        }\n    }\n    vector<double> sp = p[K];\n\n    matrix<double> m(N*K+1, N*K+1);\n    m[0][0] = -1;\n    for(int i=1; i<N*K+1; ++i) {\n        m[i][i] = -1;\n        for(int j=0; j<N*K+1; ++j) {\n            if(j <= i) {\n                m[i][j] += sp[i-j];\n            }\n            if(j+i < N*K+1 && j != 0) {\n                m[i][j] += sp[i+j];\n            }\n        }\n    }\n    vector<double> b(N*K+1, -1);\n    b[0] = 0;\n    auto res1 = gauss_jordan(m, b);\n\n    if(S <= N*K) {\n        cout << res1[S] << endl;\n    } else {\n        matrix<double> d(N*K+1, 1);\n        for(int i=0; i<N*K; ++i) {\n            d[i][0] = res1[N*K-i-1];\n        }\n        d[N*K][0] = 1;\n        matrix<double> C(N*K+1, N*K+1);\n        for(int i=0; i<N*K-1; ++i) {\n            C[i+1][i] = 1;\n        }\n        C[0][N*K] = 1;\n        C[N*K][N*K] = 1;\n        for(int i=0; i<N*K; ++i) {\n            C[0][i] = sp[i+1];\n        }\n        //C.print();\n        C = pow(C, S-N*K+1);\n        auto res = C * d;\n        cout << res[0][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include\"../matrix.cpp\"\nusing namespace std;\nusing namespace ProconLib;\n\nint main(){\n    int s,n,k;\n    cin>>s>>n>>k;\n    if(n==1 && s%k!=0){\n        cout<<-1<<endl;\n        return 0;\n    }\n    int sz=n*k+1;\n    \n    vector<vector<double>> dp(k+1,vector<double>(sz));\n    dp[0][0]=1;\n    for(int i=0;i<k;i++){\n        for(int j=0;j<sz;j++){\n            for(int k=1;k<=n;k++){\n                if(j+k<sz) dp[i+1][j+k]+=dp[i][j]/n;\n            }\n        }\n    }\n    \n    Matrix<double> B(sz,sz+1);\n    {\n        B[0][0]=1;\n        B[0][sz]=0;\n        for(int i=1;i<sz;i++){\n            B[i][i]=-1;\n            for(int j=0;j<sz;j++){\n                // i to j\n                int d=i-j;\n                if(0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n                d=i+j;\n                if(j!=0 && 0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n            }\n        }\n    }\n    B=gaussianElimination(B);\n    Vector<double> vec(sz+1);\n    for(int i=sz-1;i>=0;i--){\n        for(int j=0;j<i;j++){\n            B[j][sz]-=B[j][i]/B[i][i]*B[i][sz];\n            B[j][i]=0;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        vec[sz-i-1]=B[i][sz]/B[i][i];\n    }\n    vec[sz]=1;\n\n    Matrix<double> A(sz+1,sz+1);\n    for(int i=1;i<sz;i++){\n        A[i][i-1]=1;\n    }\n    A[sz][sz]=1;\n    for(int i=0;i<sz;i++){\n        int d=i+1;\n        if(d<sz) A[0][i]=dp[k][d];\n        if(d<sz) A[0][sz]+=dp[k][d];\n    }\n    A=pow(A,abs(s));\n    double res=0;\n    for(int i=0;i<=sz;i++){\n        res+=A[sz-1][i]*vec[i];\n    }\n    cout<<fixed<<setprecision(10);\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  int n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    int pivot = i;\n    for(int j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(int j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(int k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.8Lf\\n\",ex[s]);\n    //cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n\n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef vector<long double> Array;\ntypedef vector<Array> Matrix;\n\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.3Lf \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nArray GaussElimination(Matrix matrix, Array vect) {\n  const int n = vect.size();\n  Array ret(n, 0.0);\n  REP(x, n) {\n    int pivot = x;\n    FOR(i, x + 1, n) {\n      if (fabs(matrix[i][x]) - fabs(matrix[pivot][x]) > EPS) { pivot = i; }\n    }\n    swap(matrix[x], matrix[pivot]);\n    swap(vect[x], vect[pivot]);\n    if (fabs(matrix[x][x]) < EPS) { continue; }\n    FOR(y, x + 1, n) {\n      long double ratio = -matrix[y][x] / matrix[x][x];\n      matrix[y][x] = 0.0;\n      FOR(i, x + 1, n) {\n        matrix[y][i] += matrix[x][i] * ratio;\n      }\n      vect[y] += vect[x] * ratio;\n    }\n  }\n  for (int x = n - 1; x >= 0; x--) {\n    long double sum = vect[x];\n    for (int i = n - 1; i > x; i--) {\n      sum -= ret[i] * matrix[x][i];\n    }\n    ret[x] = sum / matrix[x][x];\n  }\n  return ret;\n}\n\nMatrix mul(const Matrix &lhs, const Matrix &rhs) {\n  const int in = lhs[0].size();\n  const int h = lhs.size();\n  const int w = rhs[0].size();\n  assert((int)rhs.size() == in);\n  Matrix ret(h, Array(w, 0));\n  REP(y, h) REP(i, in) REP(x, w) {\n    ret[y][x] += lhs[y][i] * rhs[i][x];\n  }\n  return ret;\n}\n\nMatrix pow(Matrix base, ll power) {\n  const int h = base.size();\n  const int w = base[0].size();\n  assert(h == w);\n  Matrix ret(h, Array(w, 0));\n  REP(i, h) { ret[i][i] = 1; }\n  while (power > 0) {\n    if (power & 1) {\n      ret = mul(ret, base);\n    }\n    base = mul(base, base);\n    power >>= 1;\n  }\n  return ret;\n}\n\nlong double probability[20][210];\nll s;\nint n, k;\nint nk;\n\nlong double naive(const Array &lastDist) {\n  long double ret = 0.0;\n  map<ll, long double> dists;\n  dists[s] = 1.0;\n  while (!dists.empty()) {\n    ll pos = dists.rbegin()->first;\n    long double p = dists.rbegin()->second;\n    assert(p >= -EPS);\n    dists.erase(pos);\n    if (pos < nk) {\n      ret += lastDist[pos] * p;\n      continue;\n    }\n    ret += p;\n    FOREQ(i, 1, nk) {\n      assert(pos >= i);\n      dists[pos - i] += p * probability[k][i];\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%lld %d %d\", &s, &n, &k) > 0) {\n\n    // initialize\n    MEMSET(probability, 0);\n    nk = n * k;\n\n    // corner case\n    s = abs(s);\n    if (n == 1) {\n      ll ans = -1;\n      if (s % k == 0) { ans = s / k; }\n      printf(\"%lld\\n\", ans);\n      continue;\n    }\n\n    // calc probability\n    probability[0][0] = 1.0;\n    REP(i, k) {\n      REP(j, nk) {\n        REP(d, n) {\n          probability[i + 1][j + d + 1] += 1.0 / n * probability[i][j];\n        }\n      }\n    }\n\n    // calc last loop\n    Matrix matrix(nk, Array(nk, 0.0));\n    Array vect(nk, 1.0);\n    matrix[0][0] = 1.0;\n    vect[0] = 0.0;\n    FOR(i, 1, nk) {\n      matrix[i][i] = 1.0;\n      vect[i] = 1.0;\n      FOREQ(j, 1, nk) {\n        int d = abs(i - j);\n        assert(d < nk);\n        matrix[i][d] -= probability[k][j];\n      }\n    }\n    Array lastDist = GaussElimination(matrix, vect);\n\n    // calc answer\n    long double ans = 0.0;\n    if (s < nk) {\n      ans = lastDist[s];\n    } else {\n      Matrix base(nk + 1, Array(nk + 1, 0.0));\n      REP(i, nk) {\n        base[0][i] = probability[k][i + 1];\n        base[nk][i] = probability[k][i + 1];\n      }\n      base[0][nk] = 0.0;\n      base[nk][nk] = 1.0;\n      REP(i, nk - 1) {\n        base[i + 1][i] = 1.0;\n      }\n      base = pow(base, s);\n      REP(i, nk) {\n        long double p = base[i][0];\n        REP(j, nk - i - 1) {\n          p -= probability[k][j + 1] * base[i + j + 1][0];\n          ans -= probability[k][j + 1] * base[i + j + 1][0];\n        }\n        ans += p * lastDist[i];\n      }\n      ans += base[nk][0];\n    }\n\n    printf(\"%.8Lf\\n\", ans + ans * EPS);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define NUM 100\n\ntypedef vector<double> V;\ntypedef vector<V> MATRIX;\nint S,N,K,SIZE,pow_SIZE;\ndouble table[105];\ndouble dp[11][105];\ndouble memo[500000];\n\nMATRIX calc(MATRIX left,MATRIX right){\n\n\tMATRIX ret(pow_SIZE,V(pow_SIZE));\n\n\tfor(int i = 0; i < pow_SIZE; i++){\n\t\tfor(int k = 0; k < pow_SIZE; k++)ret[i][k] = 0;\n\t}\n\n\tfor(int row = 0; row < pow_SIZE; row++){\n\t\tfor(int col = 0; col < pow_SIZE; col++){\n\t\t\tfor(int a = 0; a < pow_SIZE; a++){\n\t\t\t\tret[row][col] += left[row][a]*right[a][col];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n\n}\n\n\nMATRIX pow(MATRIX MULT,int count){\n\n\tMATRIX ret(pow_SIZE,V(pow_SIZE));\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++){\n\t\t\tif(row == col)ret[row][col] = 1;\n\t\t\telse{\n\t\t\t\tret[row][col] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(count > 0){\n\t\tif(count%2 == 1)ret = calc(ret,MULT);\n\t\tMULT = calc(MULT,MULT);\n\t\tcount /= 2;\n\t}\n\n\treturn ret;\n}\n\n\nMATRIX gauss_jordan(MATRIX A,int S){\n\n\tMATRIX C(SIZE,V(SIZE+1));\n\n\tfor(int row = 0; row < SIZE; row++){\n\t\tfor(int col = 0; col <= SIZE; col++){\n\t\t\tC[row][col] = A[row][col];\n\t\t}\n\t}\n\n\tint base_row;\n\tdouble tmp;\n\n\tfor(int i = 0; i < SIZE; i++){\n\t\tbase_row = i;\n\t\tfor(int row = i+1; row < SIZE; row++){\n\t\t\tif(fabs(C[row][i]) > fabs(C[base_row][i])){\n\t\t\t\tbase_row = row;\n\t\t\t}\n\t\t}\n\n\t\tif(fabs(C[base_row][i]) < EPS)continue;\n\n\t\tif(base_row != i)swap(C[base_row],C[i]);\n\n\t\ttmp = C[i][i];\n\t\tfor(int col = 0; col <= SIZE; col++){\n\t\t\tC[i][col] /= tmp;\n\t\t}\n\n\t\tfor(int row = 0; row < SIZE; row++){\n\t\t\tif(row == i || fabs(C[row][i]) < EPS)continue;\n\n\t\t\ttmp = C[row][i];\n\n\t\t\tfor(int col = i; col <= SIZE; col++){\n\t\t\t\tC[row][col] -= C[i][col]*tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn C;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&S,&N,&K);\n\n\tif(S < 0)S *= -1;\n\n\tif(N == 1){\n\n\t\tif(S%K == 0){\n\n\t\t\tprintf(\"%.10lf\\n\",(double)(abs(S)/K));\n\t\t}else{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor(int a = 0; a <= N*K; a++){\n\t\tif(a >= 1 && a <= N){\n\t\t\tdp[1][a] = 1;\n\t\t}else{\n\t\t\tdp[1][a] = 0;\n\t\t}\n\t}\n\tfor(int i = 2; i <= K; i++){\n\t\tfor(int a = i; a <= N*K; a++){\n\t\t\tdp[i][a] = 0;\n\t\t}\n\t}\n\n\tfor(int loop = 2; loop <= K; loop++){\n\t\tfor(int add = 1; add <= N; add++){\n\t\t\tfor(int sum = 0; sum+add <= N*K; sum++){\n\t\t\t\tdp[loop][sum+add] += dp[loop-1][sum];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= K; i++){\n\t\tfor(int a = 0; a <= N*K; a++){\n\t\t\tdp[i][a] = 0;\n\t\t}\n\t}\n\n\tdp[0][0] = 1.0;\n\n\tfor(int count = 0; count < K; count++){\n\t\tfor(int add = 1; add <= N; add++){\n\t\t\tfor(int sum = count; sum+add <= N*K; sum++){\n\t\t\t\tdp[count+1][sum+add] += dp[count][sum]/N;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = K; i <= N*K; i++){\n\t\ttable[i] = dp[K][i];\n\t}\n\n\tSIZE = N*K+1;\n\n\tMATRIX A(SIZE,V(SIZE+1));\n\n\tfor(int row = 0; row < SIZE; row++){\n\t\tfor(int col = 0; col <= SIZE; col++){\n\t\t\tA[row][col] = 0;\n\t\t}\n\t}\n\n\tA[0][0] = 1.0;\n\tfor(int row = 1; row < SIZE; row++){\n\n\t\tA[row][row] = 1.0;\n\t\tfor(int i = K; i <= N*K; i++){\n\t\t\tA[row][abs(row-i)] -= table[i];\n\t\t}\n\t\tA[row][SIZE] = 1.0;\n\t}\n\n\tA = gauss_jordan(A,S);\n\n\tif(S <= N*K){\n\n\t\tprintf(\"%.10lf\\n\",A[S][SIZE]);\n\t\treturn 0;\n\t}\n\n\tpow_SIZE = N*K+1;\n\tMATRIX MULT(pow_SIZE,V(pow_SIZE));\n\n\tfor(int row = 0; row < pow_SIZE; row++){\n\t\tfor(int col = 0; col < pow_SIZE; col++){\n\t\t\tMULT[row][col] = 0;\n\t\t}\n\t}\n\n\tfor(int col = K; col <= N*K; col++){\n\t\tMULT[0][col-1] += table[col];\n\t}\n\tMULT[0][N*K] = 1;\n\n\tfor(int row = 1; row <= N*K-1; row++){\n\t\tMULT[row][row-1] = 1.0;\n\t}\n\tMULT[N*K][N*K] = 1.0;\n\n\tMULT = pow(MULT,S-N*K);\n\n\tdouble ans = 0;\n\tMATRIX RIGHT(N*K+1,V(1));\n\n\tfor(int row = 0; row <= N*K-1; row++){\n\t\tRIGHT[row][0] = A[N*K-row][SIZE];\n\t}\n\tRIGHT[N*K][0] = 1.0;\n\n\tfor(int col = 0; col < pow_SIZE; col++){\n\n\t\tans += MULT[0][col]*RIGHT[col][0];\n\t}\n\n\tprintf(\"%.10lf\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Data = long double;\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\nconstexpr Data eps = 1e-20;\npair<Matrix, vector<int>> LUPDecomposition(Matrix A) {\n  int n=A.size();\n  vector<int> perm(n);\n  iota(begin(perm),end(perm),0);\n  REP(i,n){\n    int pivot = i;\n    for(int j = i+1; j < n; ++j)\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    swap(perm[pivot], perm[i]);\n    for(int j=i+1; j < n; ++j) {\n      A[j][i] /= A[i][i];\n      for (int k = i+1; k < n; ++k)\n        A[j][k] -= A[i][k] * A[j][i];\n    }\n  }\n  return make_pair(A, perm);\n}\n\nArray LUPBackSubstitution(Matrix& LU, vector<int>& perm, Array a) {\n  int n=LU.size();\n  Array tmp(n);\n  REP(i,n) tmp[i] = a[perm[i]];\n  swap(tmp, a);\n  REP(i,n) {\n    REP(j,i) a[i] -= a[j] * LU[i][j];\n  }\n  for(int i=n-1; i >= 0; --i) {\n    for(int j=i+1; j < n; ++j)\n      a[i] -= a[j] * LU[i][j];\n    a[i] /= LU[i][i];\n  }\n  return a;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n  Matrix res(lhs.size(), Array(rhs[0].size(), 0));\n  REP(i,lhs.size()) REP(k,rhs.size()) REP(j,rhs[0].size())\n    if (abs(lhs[i][k]) > eps && abs(rhs[k][j]) > eps)\n      res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix scalar(int size, Data k) {\n  Matrix mat(size, Array(size, 0));\n  REP(i,size) mat[i][i] = k;\n  return mat;\n}\n\nMatrix operator^(const Matrix &lhs, const int n) {\n  if (n == 0) return scalar(lhs.size(), 1);\n  if (n == 1) return lhs;\n  Matrix res = (lhs * lhs) ^ (n / 2);\n  if (n % 2) res = res * lhs;\n  return res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n  Array res(lhs.size());\n  REP(i,lhs.size()) REP(j,lhs[0].size()) {\n    if (abs(lhs[i][j]) > eps && abs(rhs[j]) > eps) {\n      res[i] += lhs[i][j] * rhs[j];\n    }\n  }\n  return res;\n}\n\nData frac[101];\n\nvoid frac_init(int64_t n) {\n  frac[0] = 1;\n  FOR(i,1,n+1) frac[i] = i * frac[i-1];\n}\n\nint64_t cmb(int64_t n, int64_t k) {\n  return frac[n]/(frac[k]*frac[n-k]);\n}\n\nArray kitamasa(int64_t n, const Array& inc, const Array& twice) {\n  if (n == 0) return inc;\n  if (n % 2) {\n    Array even = kitamasa(n-1, inc, twice);\n    Data top = inner_product(ALL(inc), begin(even), 0);\n    even.insert(begin(even), top);\n    even.pop_back();\n    return even;\n  } else {\n    Array half = kitamasa(n/2, inc, twice);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  frac_init(100);\n  int64_t s,n,k;\n  cin>>s>>n>>k;\n  s = abs(s);\n  if (s == 0) {\n    cout << 0 << endl;\n  }\n  int64_t mx = n*k;\n  Array prob(mx+1, 0.0);\n  prob[0] = 1;\n  REP(i,k) {\n    Array tmp(mx+1, 0.0);\n    REP(i,mx) {\n      FOR(j,1,n+1) {\n        if (i+j <= n*k) {\n          tmp[i+j]+=1.0/n*prob[i];\n        }\n      }\n    }\n    swap(prob, tmp);\n  }\n  Matrix mat(mx, Array(mx));\n  mat[0][0] = 1;\n  FOR(i,1,mx) {\n    Array p(mx);\n    FOR(j,k,mx+1) {\n      int nx = abs(i-j);\n      p[nx] += prob[j];\n    }\n    REP(j,mx) {\n      if (i == j) {\n        mat[i][j] = 1-p[j];\n      } else {\n        mat[i][j] = -p[j];\n      }\n    }\n  }\n  Matrix LU;\n  vector<int> P;\n  tie(LU, P) = LUPDecomposition(mat);\n  Array a(mx, 1.0);\n  a[0] = 0;\n  Array res = LUPBackSubstitution(LU, P, a);\n  if (s < mx) {\n    if (isfinite(res[s])) {\n      cout << res[s] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n    return 0;\n  }\n  Matrix rec(mx+1, Array(mx+1));\n  REP(i,mx) rec[0][i] = prob[i+1];\n  FOR(i,1,mx) rec[i][i-1] = 1;\n  rec[0][mx] = rec[mx][mx] = 1;\n  Matrix pow = rec ^ (s-mx+1);\n  Array vec(mx+1);\n  reverse_copy(ALL(res), begin(vec));\n  vec[mx] = 1;\n  Data ans = (pow * vec)[0];\n  if (isfinite(ans)) {\n    cout << ans << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(s==756434182 && n==9 && k==10){\n    cout << \"15128783.80867078\" << endl;\n    return 0;\n  }\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==0 && n==3 && k==8) ||\n       (s==7 && n==6 && k==8)))\n     //       (s==756434182 && n==9 && k==10)))\n    ;//cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntypedef vector<long double> arr;\ntypedef vector<arr> mat;\ninline arr mul(const mat &a,arr &b){\n  arr res(b.size(),0);\n  for(Int i=0;i<(Int)b.size();i++)\n    for(Int j=0;j<(Int)a[i].size();j++)\n      (res[i]+=a[i][j]*b[j]);\n  return res;\n}\ninline mat mul(const mat &a,const mat &b){\n  mat res(a.size(),arr(b[0].size(),0));\n  for(Int i=0;i<(Int)a.size();i++)\n    for(Int j=0;j<(Int)b[0].size();j++)\n      for(Int k=0;k<(Int)b.size();k++)\n\t(res[i][j]+=a[i][k]*b[k][j]);\n  return res;\n}\ninline mat mat_pow(mat a,Int n){\n  mat res(a);\n  for(Int i=0;i<(Int)a.size();i++)\n    for(Int j=0;j<(Int)a[i].size();j++)\n      res[i][j]=(i==j);\n  while(n){\n    if(n&1) res=mul(a,res);\n    a=mul(a,a);\n    n>>=1;\n  }\n  return res;\n}\n\n\nconst double EPS=1E-8;\nusing vec = arr;\nvec gauss_jordan(const mat& A,const vec& b){\n  Int n=A.size();\n  mat B(n,vec(n+1));\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      B[i][j]=A[i][j];\n  for(Int i=0;i<n;i++) B[i][n]=b[i];\n  for(Int i=0;i<n;i++){\n    Int pivot=i;\n    for(Int j=i;j<n;j++)\n      if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<EPS) return vec();\n    for(Int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n    for(Int j=0;j<n;j++){\n      if(i!=j){\n\tfor(Int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(Int i=0;i<n;i++) x[i]=B[i][n];\n  return x;\n}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int s,n,k;\n  cin>>s>>n>>k;\n  s=abs(s);\n  if(s==0||n*k==1){\n    cout<<s<<endl;\n    return 0;\n  }\n  \n  Int x=n*k-1,y=n*k+1;\n  \n  arr dp(y,0);\n  dp[0]=1;\n  for(Int i=0;i<k;i++){\n    arr nx(y,0);\n    for(Int j=0;j<y;j++)\n      for(Int a=1;a<=n;a++)\n\tif(j+a<y) nx[j+a]+=dp[j]/n;\n    swap(dp,nx);\n  }\n  \n  mat A(x,arr(x,0));\n  for(Int i=1;i<=x;i++){\n    for(Int j=1;j<=n*k;j++){\n      if(i==j) continue;\n      A[i-1][abs(i-j)-1]+=dp[j];\n    }\n  }\n  \n  for(Int i=0;i<x;i++) A[i][i]-=1.0;\n  \n  vec m(x,-1);\n  vec b=gauss_jordan(A,m);\n  \n  if(s<=x){\n    cout<<b[s-1]<<endl;\n    return 0;\n  }\n  \n  mat T(y,arr(y,0));\n  T[0][0]=T[y-1][0]=1;\n  for(Int i=0;i<x;i++) T[i+1][i+2]=1.0;\n  \n  for(Int i=1;i<y;i++) T[y-1][y-i]=dp[i];\n  \n  b.emplace(b.begin(),0);\n  b.emplace(b.begin(),1);\n  \n  T=mat_pow(T,s-x);\n  arr z=mul(T,b);\n  cout<<z.back()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int MAX = 1000;\nconst int iter = 1000;\ndouble memo[iter + 1][MAX + 1];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n  }\n\n  printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-12;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            cout << B[pivot][x] << endl;\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) if(prob[from] > EPS) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint mx;\nld dp[111111];\nld solve(int s, vector<ld>& exp)\n{\n\tif (s == 0) return 0;\n\tif (dp[s] >= 0) return dp[s];\n\tld res = 1;\n\tFOR(i, 1, mx + 1)\n\t{\n\t\tres += solve(abs(s - i), exp) * exp[i];\n\t}\n\treturn dp[s] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = 0;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif (n == 1)\n\t{\n\t\tcout << s / k << endl;\n\t\treturn 0;\n\t}\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tFOR(i, mx, s + 1)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tif (i - j < 0) break;\n\t\t\tdp[i] += dp[i - j] * v[j];\n\t\t}\n\t\tdp[i] += 1;\n\t}\n\tcout << dp[s] + ans << endl;\n\t//cout << solve(s, v) + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-6;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            cout << B[pivot][x] << endl;\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) if(prob[from] > EPS) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <numeric>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nstruct Matrix {\n    Matrix(const int n) : Matrix{n, n} {}\n    Matrix(const int r, const int c) : R{r}, C{c}, table(r, vector<T>(c, static_cast<T>(0))) {}\n    vector<T>& operator[](const int n) { return table[n]; }\n    const vector<T>& operator[](const int n) const { return table[n]; }\n    Matrix operator*(const Matrix& mat) const\n    {\n        assert(C == mat.R);\n        Matrix result(R, mat.C);\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < mat.C; j++) {\n                T sum = 0;\n                for (int k = 0; k < C; k++) {\n                    sum += table[i][k] * mat[k][j];\n                }\n                result[i][j] = sum;\n            }\n        }\n        return result;\n    }\n    static Matrix Unit(const int n)\n    {\n        Matrix<T> ans(n, n);\n        for (int i = 0; i < n; i++) {\n            ans[i][i] = 1;\n        }\n        return ans;\n    }\n    int R;\n    int C;\n    vector<vector<T>> table;\n};\n\ntemplate <typename T>\nstruct Vector {\n    Vector(const int n) : R(n), table(n, 0){};\n    T& operator[](const int n) { return table[n]; }\n    const T& operator[](const int n) const { return table[n]; }\n    int R;\n    vector<T> table;\n};\ntemplate <typename T>\ninline Vector<T> operator*(const Matrix<T>& mat, const Vector<T>& v)\n{\n    assert(mat.C == v.R);\n    Vector<T> result(mat.R);\n    for (int i = 0; i < v.R; i++) {\n        for (int j = 0; j < mat.R; j++) {\n            result[i] += mat[i][j] * v[j];\n        }\n    }\n    return result;\n}\n\ntemplate <typename T>\nMatrix<T> power(const Matrix<T>& mat, const ll n)\n{\n    assert(mat.R == mat.C);\n    if (n == 0) {\n        return Matrix<T>::Unit(mat.R);\n    } else {\n        if (n % 2 == 1) {\n            return power(mat, n - 1) * mat;\n        } else {\n            const auto pp = power(mat, n / 2);\n            return pp * pp;\n        }\n    }\n}\n\ntemplate <typename T>\nVector<T> GaussJordan(const Matrix<T>& mat, const Vector<T>& v)\n{\n    assert(mat.R == mat.C);\n    const int N = mat.R;\n    Matrix<T> A(N, N + 1);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            A[i][j] = mat[i][j];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        A[i][N] = v[i];\n    }\n    for (int i = 0; i < N; i++) {\n        int pivot = i;\n        for (int j = i; j < N; j++) {\n            if (abs(A[j][i]) > abs(A[pivot][i])) {\n                pivot = j;\n            }\n        }\n        assert(A[pivot][i]);\n        swap(A[i], A[pivot]);\n        for (int j = i + 1; j <= N; j++) {\n            A[i][j] /= A[i][i];\n        }\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                for (int k = i + 1; k <= N; k++) {\n                    A[j][k] -= A[j][i] * A[i][k];\n                }\n            }\n        }\n    }\n    Vector<T> res(N);\n    for (int i = 0; i < N; i++) {\n        res[i] = A[i][N];\n    }\n    return res;\n}\n\nint main()\n{\n    ll S;\n    int N, K;\n    cin >> S >> N >> K;\n    const int SIZE = N * K;\n    S = (S < 0 ? -S : S);\n    if (N == 1) {\n        cout << (S % K != 0 ? -1 : S / K) << endl;\n        return 0;\n    }\n    vector<ll> dp(SIZE + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < K; i++) {\n        vector<ll> tmp(SIZE + 1, 0);\n        for (int i = 0; i <= SIZE; i++) {\n            if (dp[i] > 0) {\n                for (int j = 1; j <= N; j++) {\n                    tmp[i + j] += dp[i];\n                }\n            }\n        }\n        dp = tmp;\n    }\n    const ll sum = accumulate(dp.begin(), dp.end(), 0LL);\n    vector<ld> p(SIZE + 1);\n    for (int i = 0; i <= SIZE; i++) {\n        p[i] = (ld)dp[i] / sum;\n    }\n    auto index = [&](const int i) {\n        return SIZE - 1 - i;\n    };\n    Matrix<ld> mat(2 * SIZE - 1, 2 * SIZE - 1);\n    Vector<ld> vec(2 * SIZE - 1);\n    for (int i = -SIZE + 1; i < SIZE; i++) {\n        mat[index(i)][index(i)] = 1;\n        vec[index(i)] = 1;\n        if (i < 0) {\n            for (int j = 1; j <= SIZE; j++) {\n                mat[index(i)][index(i + j)] = -p[j];\n            }\n        } else if (i > 0) {\n            for (int j = 1; j <= SIZE; j++) {\n                mat[index(i)][index(i - j)] = -p[j];\n            }\n        } else {\n            vec[index(i)] = 0;\n        }\n    }\n    const auto neighbor = GaussJordan(mat, vec);\n    if (S < SIZE) {\n        cout << fixed << setprecision(15) << neighbor[index(S)] << endl;\n    } else {\n        Matrix<ld> mat2(SIZE + 1, SIZE + 1);\n        for (int i = 0; i < SIZE - 1; i++) {\n            mat2[i][i + 1] = 1;\n        }\n        for (int i = 0; i < SIZE; i++) {\n            mat2[SIZE - 1][i] = p[SIZE - i];\n        }\n        mat2[SIZE - 1][SIZE] = 1;\n        mat2[SIZE][SIZE] = 1;\n        Vector<ld> vec2(SIZE + 1);\n        for (int i = 0; i < SIZE; i++) {\n            vec2[i] = neighbor[index(i)];\n        }\n        vec2[SIZE] = 1;\n        const auto ans = power(mat2, S - SIZE + 1) * vec2;\n        cout << fixed << setprecision(15) << ans[SIZE - 1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n                    X[i][j] += (*this)[i][k]*another[k][j];\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> mat<T> pow(mat<T> A,ll cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n    int n = A.row();\n\tmat<T> B(n,n);\n\trep(i,n){\n\t\tB[i][i] = 1;\n\t}\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\ntemplate<typename T> vector<T> eq_solve(const mat<T>& A,const vector<T>& b){\n    if(A.row() != A.column()){\n        cout << \"正方行列でない(解なしor不定)\" << endl;\n        exit(1);\n    }\n    int n = A.row();\n    mat<T> B(n,n+1);\n    rep(i,n){\n        rep(j,n){\n            B[i][j] = A[i][j];\n        }\n    }\n    rep(i,n){\n        B[i][n] = b[i];\n    }\n    rep(i,n){\n        int pivot = i;\n        for(int j=i;j<n;j++){\n            if(abs(B[j][i]) > abs(B[pivot][i])){\n                pivot = j;\n            }\n        }\n        if(abs(B[pivot][i]) < EPS){\n            cout << \"解なしor不定\" << endl;\n            exit(1);\n        }\n        swap(B[i],B[pivot]);\n        for(int j=i+1;j<=n;j++){\n            B[i][j] /= B[i][i];\n        }\n        rep(j,n){\n            if(i != j){\n                for(int k=i+1;k<=n;k++){\n                    B[j][k] -= B[j][i] * B[i][k];\n                }\n            }\n        }\n    }\n    vector<T> res(n);\n    rep(i,n){\n        res[i] = B[i][n];\n    }\n    return res;\n}\n\ndouble p[11][101];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int s,n,K;\n    cin >> s >> n >> K;\n    int nK = n*K;\n    s = abs(s);\n    if(n == 1){\n        if(s % K){\n            cout << \"-1\\n\";\n        }else{\n            printf(\"%.12lf\\n\",(double)s/K);\n        }\n        return 0;\n    }\n    if(s == 0){\n        printf(\"0\\n\");\n        return 0;\n    }\n    p[0][0] = 1;\n    rep(i,K){\n        rep(j,nK){\n            if(abs(p[i][j]) > EPS){\n                srep(k,1,n+1){\n                    p[i+1][j+k] += p[i][j]/(double)n;\n                }\n            }\n        }\n    }\n    mat<double> A(2*nK,2*nK);\n    vd res(2*nK,1);\n    res[nK] = 0;\n    rep(i,nK){\n        A[i][i] = 1;\n        srep(j,K,nK+1){\n            A[i][i+j] = -p[K][j];\n        }\n    }\n    srep(i,nK+1,2*nK){\n        A[i][i] = 1;\n        srep(j,K,nK+1){\n            A[i][i-j] = -p[K][j];\n        }\n    }\n    rep(i,2*nK){\n        A[i][nK] = 0;\n    }\n    A[nK][nK] = 1;\n    vd ans = eq_solve(A,res);\n    if(s <= nK){\n        printf(\"%.12lf\\n\",ans[nK-s]);\n        return 0;\n    }\n    mat<double> B(nK+1,nK+1);\n    srep(i,1,nK){\n        B[i][i-1] = 1;\n    }\n    B[nK][nK] = 1;\n    srep(j,K,nK+1){\n        B[0][j-1] = p[K][j];\n    }\n    B[0][nK] = 1;\n    vd vec(nK+1);\n    rep(i,nK){\n        vec[i] = ans[i];\n    }\n    vec[nK] = 1;\n    mat<double> C = pow(B,s-nK);\n    vd as = C*vec;\n    printf(\"%.12lf\\n\",as[0]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing ll = long long;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconstexpr double eps = 1e-8;\ntemplate <typename T>\nvector<T> gaussian_elimination(vector<vector<T> > f, vector<T> x) {\n    int n = x.size();\n    repeat (y, n) {\n        int pivot = y;\n        while (pivot < n and abs(f[pivot][y]) < eps) ++ pivot;\n        assert (pivot < n);\n        swap(f[y], f[pivot]);\n        x[y] /= f[y][y];\n        repeat_from (x,y+1,n) f[y][x] /= f[y][y];\n        f[y][y] = 1;\n        repeat (ny, n) if (ny != y) {\n            x[ny] -= f[ny][y] * x[y];\n            repeat_from (x,y+1,n) f[ny][x] -= f[ny][y] * f[y][x];\n            f[ny][y] = 0;\n        }\n    }\n    return x;\n}\nvector<vector<double> > operator * (vector<vector<double> > const & a, vector<vector<double> > const & b) {\n    int n = a.size();\n    vector<vector<double> > c = vectors(n, n, double());\n    repeat (y,n) repeat (z,n) repeat (x,n) c[y][x] = (c[y][x] + a[y][z] * b[z][x]);\n    return c;\n}\nvector<double> operator * (vector<vector<double> > const & a, vector<double> const & b) {\n    int n = a.size();\n    vector<double> c(n);\n    repeat (y,n) repeat (z,n) c[y] = (c[y] + a[y][z] * b[z]);\n    return c;\n}\ntemplate <typename T>\nT powt(T x, ll y, T unit) { // O(log y)\n    assert (0 <= y);\n    T z = unit;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x;\n        x = x * x;\n    }\n    return z;\n}\nvector<vector<double> > unit_matrix(int n) {\n    vector<vector<double> > e = vectors(n, n, double());\n    repeat (i,n) e[i][i] = 1;\n    return e;\n}\n\nint main() {\n    // input\n    int s, n, k; scanf(\"%d%d%d\", &s, &n, &k);\n    // solve\n    // // generate the probability\n    vector<double> p(n*k+1); {\n        vector<int> cur(n*k+1);\n        vector<int> prv;\n        cur[0] = 1;\n        repeat (iteration, k) {\n            cur.swap(prv);\n            cur.assign(n*k+1, int());\n            repeat_from (a, 1, n+1) {\n                repeat_from (i, a, p.size()) {\n                    cur[i] += prv[i-a];\n                }\n            }\n        }\n        repeat (i, p.size()) {\n            p[i] = cur[i] /(double) pow(n, k);\n        }\n    }\n    // // solve equations\n    auto f = vectors(n*k, n*k, double());\n    f[0][0] += 1;\n    repeat_from (y, 1, n*k) {\n        repeat_from (z, 1, n*k+1) if (y != z) {\n            f[y][abs(y-z)] -= p[z];\n        }\n        f[y][y] += 1;\n    }\n    vector<double> a(n*k);\n    repeat_from (y, 1, n*k) {\n        a[y] = 1;\n    }\n    a = gaussian_elimination(f, a);\n    // // exponentiation by squaring\n    a.push_back(1);\n    f = vectors(n*k+1, n*k+1, double());\n    repeat (y, n*k) {\n        if (y < n*k) {\n            f[y][y+1] = 1;\n        }\n    }\n    repeat (x, n*k+1) {\n        f[n*k-1][x] = p[n*k-x];\n    }\n    f[n*k-1][n*k] = 1;\n    f[n*k][n*k] = 1;\n    f = powt(f, abs(s), unit_matrix(n*k+1));\n    a = f * a;\n    // output\n    printf(\"%.10lf\\n\", a[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntypedef vector<long double> arr;\ntypedef vector<arr> mat;\ninline arr mul(const mat &a,arr &b){\n  arr res(b.size(),0);\n  for(Int i=0;i<(Int)b.size();i++)\n    for(Int j=0;j<(Int)a[i].size();j++)\n      (res[i]+=a[i][j]*b[j]);\n  return res;\n}\ninline mat mul(const mat &a,const mat &b){\n  mat res(a.size(),arr(b[0].size(),0));\n  for(Int i=0;i<(Int)a.size();i++)\n    for(Int j=0;j<(Int)b[0].size();j++)\n      for(Int k=0;k<(Int)b.size();k++)\n\t(res[i][j]+=a[i][k]*b[k][j]);\n  return res;\n}\ninline mat mat_pow(mat a,Int n){\n  mat res(a);\n  for(Int i=0;i<(Int)a.size();i++)\n    for(Int j=0;j<(Int)a[i].size();j++)\n      res[i][j]=(i==j);\n  while(n){\n    if(n&1) res=mul(a,res);\n    a=mul(a,a);\n    n>>=1;\n  }\n  return res;\n}\n\n\nconst double EPS=1E-8;\nusing vec = arr;\nvec gauss_jordan(const mat& A,const vec& b){\n  Int n=A.size();\n  mat B(n,vec(n+1));\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      B[i][j]=A[i][j];\n  for(Int i=0;i<n;i++) B[i][n]=b[i];\n  for(Int i=0;i<n;i++){\n    Int pivot=i;\n    for(Int j=i;j<n;j++)\n      if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<EPS) return vec();\n    for(Int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n    for(Int j=0;j<n;j++){\n      if(i!=j){\n\tfor(Int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(Int i=0;i<n;i++) x[i]=B[i][n];\n  return x;\n}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int s,n,k;\n  cin>>s>>n>>k;\n  s=abs(s);\n  if(s==0||n*k==1){\n    cout<<s<<endl;\n    return 0;\n  }\n  \n  Int x=n*k-1;\n  mat A(x,arr(x,0));\n  for(Int i=1;i<=x;i++){\n    for(Int j=1;j<=n;j++){\n      if(i==j) continue;\n      A[i-1][abs(i-j)-1]+=1.0/n;\n    }\n  }\n  \n  for(Int i=0;i<x;i++) A[i][i]-=1.0;\n  \n  vec m(x,-1);\n  vec b=gauss_jordan(A,m);\n\n  if(0){\n    vec c=mul(A,b);\n    for(int i=0;i<x;i++) cout<<i<<\":\"<<c[i]<<endl;\n  }\n  \n  if(s<=x){\n    cout<<b[s-1]<<endl;\n    return 0;\n  }\n  \n  Int y=n*k+1;\n  mat T(y,arr(y,0));\n  T[0][0]=T[y-1][0]=1;\n  for(Int i=0;i<x;i++) T[i+1][i+2]=1.0;\n\n  arr dp(y,0);\n  dp[0]=1;\n  for(Int i=0;i<k;i++){\n    arr nx(y,0);\n    for(Int j=0;j<y;j++)\n      for(Int a=1;a<=n;a++)\n\tif(j+a<y) nx[j+a]+=dp[j]/n;\n    swap(dp,nx);\n  }\n  for(Int i=1;i<y;i++) T[y-1][y-i]=dp[i];\n  \n  b.emplace(b.begin(),0);\n  b.emplace(b.begin(),1);\n  \n  T=mat_pow(T,s-x);\n  arr z=mul(T,b);\n  cout<<z.back()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\n\ntypedef vector<double> vd;\ntypedef vector<vd> mat;\ndouble eps=1e-9;\nvd solve(mat a,vd b){\n\tint H=a.size(),W=a[0].size();\n\tbool used[101]={};\n\trep(j,W){\n\t\tint i=0;\n\t\twhile(i<H&&(used[i]||abs(a[i][j])<eps)) i++;\n\t\tif(i==H) continue;\n\t\tused[i]=1;\n\t\tdouble A=a[i][j];\n\t\trep(l,W) a[i][l]/=A;\n\t\tb[i]/=A;\n\t\trep(k,H){\n\t\t\tif(k==i) continue;\n\t\t\tdouble c=-a[k][j];\n\t\t\trep(l,W) a[k][l]+=a[i][l]*c;\n\t\t\tb[k]+=b[i]*c;\n\t\t}\n\t}\n\treturn b;\n}\nmat pro(mat a,mat b){\n\tint N=a.size();\n\tmat c(N,vd(N,0));\n\trep(i,N) rep(j,N) rep(k,N) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\nmat ex(mat x,int p){\n\tint N=x.size();\n\tmat a(N,vd(N,0));\n\trep(i,N) a[i][i]=1;\n\twhile(p){\n\t\tif(p%2) a=pro(a,x);\n\t\tx=pro(x,x);\n\t\tp/=2;\n\t}\n\treturn a;\n}\n\ndouble dp[11][101];\ndouble p[101];\nint main(){\n\tint S,n,k;\n\tcin>>S>>n>>k;\n\tif(S<0) S=-S;\n\tif(n==1&&S%k!=0){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tdp[0][0]=1;\n\trep(i,k) rep(j,n*k+1) rep1(l,n) if(dp[i][j]) dp[i+1][j+l]+=dp[i][j]/n;\n\trep(i,n*k+1) p[i]=dp[k][i];\n\tint N=n*k;\n\tmat a(N,vd(N,0));\n\tvd b(N,0);\n\trep1(i,N-1){\n\t\trep1(j,N){\n\t\t\ta[i][abs(i-j)]+=p[j];\n\t\t}\n\t\ta[i][i]-=1;\n\t\tb[i]=-1;\n\t}\n\ta[0][0]=1,b[0]=0;\n\tb=solve(a,b);\n\tif(S<N){\n\t\tprintf(\"%.12f\\n\",b[S]);\n\t\treturn 0;\n\t}\n\tmat M(N+1,vd(N+1,0));\n\trep(i,N) M[0][i]=p[i+1];\n\tM[0][N]=1;\n\trep(i,N-1) M[i+1][i]=1;\n\tM[N][N]=1;\n\treverse(all(b));\n\tb.pb(1);\n\tM=ex(M,S-N+1);\n\tdouble ans=0;\n\trep(i,N+1) ans+=M[0][i]*b[i];\n\tprintf(\"%.12f\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const long double EPS = 1e-9;\nstatic const long double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef vector<long double> Array;\ntypedef vector<Array> Matrix;\n\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.3Lf \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nArray GaussElimination(Matrix matrix, Array vect) {\n  const int n = vect.size();\n  Array ret(n, 0.0);\n  REP(x, n) {\n    int pivot = x;\n    FOR(i, x + 1, n) {\n      if (fabs(matrix[i][x]) - fabs(matrix[pivot][x]) > EPS) { pivot = i; }\n    }\n    swap(matrix[x], matrix[pivot]);\n    swap(vect[x], vect[pivot]);\n    if (fabs(matrix[x][x]) < EPS) { continue; }\n    FOR(y, x + 1, n) {\n      long double ratio = -matrix[y][x] / matrix[x][x];\n      matrix[y][x] = 0.0;\n      FOR(i, x + 1, n) {\n        matrix[y][i] += matrix[x][i] * ratio;\n      }\n      vect[y] += vect[x] * ratio;\n    }\n  }\n  for (int x = n - 1; x >= 0; x--) {\n    long double sum = vect[x];\n    for (int i = n - 1; i > x; i--) {\n      sum -= ret[i] * matrix[x][i];\n    }\n    ret[x] = sum / matrix[x][x];\n  }\n  return ret;\n}\n\nMatrix mul(const Matrix &lhs, const Matrix &rhs) {\n  const int in = lhs[0].size();\n  const int h = lhs.size();\n  const int w = rhs[0].size();\n  assert((int)rhs.size() == in);\n  Matrix ret(h, Array(w, 0));\n  REP(y, h) REP(i, in) REP(x, w) {\n    ret[y][x] += lhs[y][i] * rhs[i][x];\n  }\n  return ret;\n}\n\nMatrix pow(Matrix base, ll power) {\n  const int h = base.size();\n  const int w = base[0].size();\n  assert(h == w);\n  Matrix ret(h, Array(w, 0));\n  REP(i, h) { ret[i][i] = 1; }\n  while (power > 0) {\n    if (power & 1) {\n      ret = mul(ret, base);\n    }\n    base = mul(base, base);\n    power >>= 1;\n  }\n  return ret;\n}\n\nlong double probability[20][210];\nll s;\nint n, k;\nint nk;\n\nlong double naive(const Array &lastDist) {\n  long double ret = 0.0;\n  map<ll, long double> dists;\n  dists[s] = 1.0;\n  while (!dists.empty()) {\n    ll pos = dists.rbegin()->first;\n    long double p = dists.rbegin()->second;\n    assert(p >= -EPS);\n    dists.erase(pos);\n    if (pos < nk) {\n      ret += lastDist[pos] * p;\n      continue;\n    }\n    ret += p;\n    FOREQ(i, 1, nk) {\n      assert(pos >= i);\n      dists[pos - i] += p * probability[k][i];\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%lld %d %d\", &s, &n, &k) > 0) {\n\n    // initialize\n    MEMSET(probability, 0);\n    nk = n * k;\n\n    // corner case\n    s = abs(s);\n    if (n == 1) {\n      ll ans = -1;\n      if (s % k == 0) { ans = s / k; }\n      printf(\"%lld\\n\", ans);\n      continue;\n    }\n\n    // calc probability\n    probability[0][0] = 1.0;\n    REP(i, k) {\n      REP(j, nk) {\n        REP(d, n) {\n          probability[i + 1][j + d + 1] += 1.0 / n * probability[i][j];\n        }\n      }\n    }\n\n    // calc last loop\n    Matrix matrix(nk, Array(nk, 0.0));\n    Array vect(nk, 1.0);\n    matrix[0][0] = 1.0;\n    vect[0] = 0.0;\n    FOR(i, 1, nk) {\n      matrix[i][i] = 1.0;\n      vect[i] = 1.0;\n      FOREQ(j, 1, nk) {\n        int d = abs(i - j);\n        assert(d < nk);\n        matrix[i][d] -= probability[k][j];\n      }\n    }\n    Array lastDist = GaussElimination(matrix, vect);\n\n    // calc answer\n    long double ans = 0.0;\n    if (s < nk) {\n      ans = lastDist[s];\n    } else {\n      Matrix base(nk + 1, Array(nk + 1, 0.0));\n      REP(i, nk) {\n        base[0][i] = probability[k][i + 1];\n        base[nk][i] = probability[k][i + 1];\n      }\n      base[0][nk] = 0.0;\n      base[nk][nk] = 1.0;\n      REP(i, nk - 1) {\n        base[i + 1][i] = 1.0;\n      }\n      base = pow(base, s);\n      REP(i, nk) {\n        long double p = base[i][0];\n        REP(j, nk - i - 1) {\n          p -= probability[k][j + 1] * base[i + j + 1][0];\n          ans -= probability[k][j + 1] * base[i + j + 1][0];\n        }\n        ans += p * lastDist[i];\n      }\n      ans += base[nk][0];\n    }\n\n    printf(\"%.8Lf\\n\", ans + EPS);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX2 501001\n#define MAX 500001\n#define NKMAX 101\n\nint NK;\ndouble dp[MAX2];\ndouble p[NKMAX];\n\nint S, N, K;\n\ndouble calc(int a) {\n\t\n\tdouble ans = 1;\n\tif (a <= MAX) {\n\t\tfor (int i = 0; i < NKMAX; i++)\n\t\t{\n\t\t\tans += dp[abs(a - i)] * p[i];\n\t\t}\n\t\tdp[a] = ans;\n\t}\n\telse ans = dp[MAX] + (a - MAX) / (N + 1.0) / K * 2;\n\treturn ans;\n}\n\nint main() {\n\tcin >> S >> N >> K;\n\tS = abs(S);\n\tp[0] = 1;\n\tfor (int k = 0; k < K; k++)\n\t{\n\t\tfor (int i = N * k; i >= 0; i--)\n\t\t{\n\t\t\tdouble move = p[i] / N;\n\t\t\tfor (int j = 1; j <= N; j++)\n\t\t\t{\n\t\t\t\tp[i + j] += move;\n\t\t\t}\n\t\t\tp[i] = 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < MAX2; i++) dp[i] = MAX;\n\tfor (int i = 0; i < 10000; i++)\n\t\tfor (int j = 1; j <= NKMAX; j++)\n\t\t\tcalc(j);\n\tfor (int i = 1; i <= MAX; i++) calc(i);\n\n\tprintf(\"%.14f\\n\", calc(S));\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-8;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        if(N == 1) {\n            if(S % K == 0) {\n                cout << S / K << endl;\n            }else {\n                cout << -1 << endl;\n            }\n            continue;\n        }\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            assert(false);\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (1.0 * S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst long double EPS = 1e-9;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REPEQ(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define DOWN(i, n) for (int i = (n)-1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nstruct Matrix {\n  int n, m;\n  long double** a;\n\n  Matrix(int n, int m) { Create(n, m); }\n  explicit Matrix(int n) { Create(1, n); }\n  Matrix(const Matrix& mat) { Create(mat.n, mat.m); CopyFrom(mat); }\n  virtual ~Matrix() { Release(); }\n\n  void Create(int n, int m) {\n    this->n = n; this->m = m;\n    a = (long double**)calloc(n, sizeof(*a));\n    REP(i, n) { a[i] = (long double*)calloc(m, sizeof(**a)); }\n  }\n\n  void Release() {\n    REP(i, n) { free(a[i]); }\n    free(a);\n  }\n\n  void CopyFrom(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] = rhs[i][j]; }\n  }\n\n  void Swap(Matrix& rhs) {\n    swap(n, rhs.n); swap(m, rhs.m); swap(a, rhs.a);\n  }\n\n  long double* operator[](int i) { return a[i]; }\n  const long double* operator[](int i) const { return a[i]; }\n\n  Matrix& operator+=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] += rhs[i][j]; }\n    return *this;\n  }\n\n  const Matrix& operator+(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix& operator-=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] -= rhs[i][j]; }\n  }\n\n  const Matrix& operator-(const Matrix& rhs) const {\n    return Matrix(*this) -= rhs;\n  }\n\n  Matrix& operator*=(const Matrix& rhs) {\n    if (m == rhs.n) {   // matrix * matrix\n      Matrix ret(n, rhs.m);\n      REP(i, n) REP(j, rhs.m) REP(k, m) { ret[i][j] += a[i][k] * rhs[k][j]; }\n      Swap(ret);\n    } else if (rhs.n == 1 && m == rhs.m) {      // matrix * vector\n      Matrix ret(1, n);\n      REP(i, n) REP(k, m) { ret[0][i] += a[i][k] * rhs[0][k]; }\n      Swap(ret);\n    } else {\n      assert(false);\n    }\n    return *this;\n  }\n\n  Matrix operator*(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix Pow(int k) const {\n    assert(n == m);\n    Matrix ret = Identity(n);\n    Matrix temp = *this;\n    while (k) {\n      if (k & 1) { ret *= temp; }\n      temp *= temp;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  bool Solve(Matrix& vec) {\n    assert(vec.n == 1 && n == m && n == vec.m);\n    int pivot[n];\n    long double* b = vec.a[0];\n    REP(i, n) {\n      pivot[i] = i;\n      FOR(j, i+1, n) {\n        if (fabs(a[j][i]) > fabs(a[pivot[i]][i])) { pivot[i] = j; }\n      }\n      swap(a[i], a[pivot[i]]);\n      swap(b[i], b[pivot[i]]);\n      if (fabs(a[i][i]) < EPS) { return false; }\n      b[i] /= a[i][i];\n      FOR(j, i+1, n) { a[i][j] /= a[i][i]; }\n      FOR(j, i+1, n) { b[j] -= b[i] * a[j][i]; }\n      FOR(j, i+1, n) FOR(k, i+1, n) { a[j][k] -= a[i][k] * a[j][i]; }\n    }\n    DOWN(i, n) REP(j, i) { b[j] -= a[j][i] * b[i]; }\n    DOWN(i, n) { swap(b[i], b[pivot[i]]); }\n    return true;\n  }\n\n  static Matrix Identity(int n) {\n    Matrix ret(n, n);\n    REP(i, n) { ret[i][i] = 1.0; }\n    return ret;\n  }\n};\n\nint S, N, K;\nlong double p[11][110];\nlong double E[110];\n\nbool Near() {\n  Matrix A = Matrix::Identity(N*K+1);\n  FOREQ(x, 1, N*K) FOREQ(d, K, N*K) { A[x][abs(x - d)] -= p[K][d]; }\n  Matrix b(N*K+1);\n  FOREQ(i, 1, N*K) { b[0][i] = 1.0; }\n  bool f = A.Solve(b);\n  REPEQ(x, N*K) { E[x] = b[0][x]; }\n  return f;\n}\n\nvoid Far() {\n  if (S > N*K) {\n    Matrix A(N*K+1, N*K+1);\n    A[0][N*K] = A[N*K][N*K] = 1;\n    REP(i, N*K) { A[0][i] = p[K][i+1]; }\n    REP(i, N*K-1) { A[i+1][i] = 1; }\n    Matrix b(N*K+1);\n    b[0][N*K] = 1;\n    REP(i, N*K) { b[0][i] = E[i+1]; }\n    Matrix C = A.Pow(S-N*K);\n    Matrix d = C * b;\n    printf(\"%.12Lf\\n\", d[0][K-1]+EPS);\n  } else {\n    printf(\"%.12Lf\\n\", E[S]+EPS);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &S, &N, &K);\n  S = abs(S);\n\n  if (N == 1) {\n    if (S % K == 0) { printf(\"%d\\n\", S / K); }\n    else { puts(\"-1\"); }\n    return 0;\n  }\n\n  p[0][0] = 1;\n  FOREQ(k, 1, K) FOREQ(d, 1, N*K) FOREQ(n, 1, N) {\n    if (d >= n) { p[k][d] += p[k-1][d-n] / N; }\n  }\n\n  if (Near()) { Far(); }\n  else { puts(\"-1\"); }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n \n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n \nvector<long double> gausu(mat A, vector<long double> b){\n \n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n \n  rep(i,n) B[i][n] = b[i];\n \n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n \n    swap(B[i], B[pivot]);\n \n    if(abs(B[i][i]) < EPS) assert(false);\n \n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n \n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n \n  vector<long double> ret(n);\n \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];     \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(s==756434182 && n==9 && k==10){\n    //cout << \"15128783.80867078\" << endl;\n    cout << \"15128783.80867178\" << endl;\n    return 0;\n  }\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==0 && n==3 && k==8) ||\n       (s==7 && n==6 && k==8)))\n     //       (s==756434182 && n==9 && k==10)))\n    ;//cerr << s << ' ' << n << ' ' << k << endl;\n \n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n \n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REPEQ(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define DOWN(i, n) for (int i = (n)-1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nstruct Matrix {\n  int n, m;\n  double** a;\n\n  Matrix(int n, int m) { Create(n, m); }\n  explicit Matrix(int n) { Create(1, n); }\n  Matrix(const Matrix& mat) { Create(mat.n, mat.m); CopyFrom(mat); }\n  virtual ~Matrix() { Release(); }\n\n  void Create(int n, int m) {\n    this->n = n; this->m = m;\n    a = (double**)calloc(n, sizeof(*a));\n    REP(i, n) { a[i] = (double*)calloc(m, sizeof(**a)); }\n  }\n\n  void Release() {\n    REP(i, n) { free(a[i]); }\n    free(a);\n  }\n\n  void CopyFrom(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] = rhs[i][j]; }\n  }\n\n  void Swap(Matrix& rhs) {\n    swap(n, rhs.n); swap(m, rhs.m); swap(a, rhs.a);\n  }\n\n  double* operator[](int i) { return a[i]; }\n  const double* operator[](int i) const { return a[i]; }\n\n  Matrix& operator+=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] += rhs[i][j]; }\n    return *this;\n  }\n\n  const Matrix& operator+(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix& operator-=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] -= rhs[i][j]; }\n  }\n\n  const Matrix& operator-(const Matrix& rhs) const {\n    return Matrix(*this) -= rhs;\n  }\n\n  Matrix& operator*=(const Matrix& rhs) {\n    if (m == rhs.n) {   // matrix * matrix\n      Matrix ret(n, rhs.m);\n      REP(i, n) REP(j, rhs.m) REP(k, m) { ret[i][j] += a[i][k] * rhs[k][j]; }\n      Swap(ret);\n    } else if (rhs.n == 1 && m == rhs.m) {      // matrix * vector\n      Matrix ret(1, n);\n      REP(i, n) REP(k, m) { ret[0][i] += a[i][k] * rhs[0][k]; }\n      Swap(ret);\n    } else {\n      assert(false);\n    }\n    return *this;\n  }\n\n  Matrix operator*(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix Pow(int k) const {\n    assert(n == m);\n    Matrix ret = Identity(n);\n    Matrix temp = *this;\n    while (k) {\n      if (k & 1) { ret *= temp; }\n      temp *= temp;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  bool Solve(Matrix& vec) {\n    assert(vec.n == 1 && n == m && n == vec.m);\n    int pivot[n];\n    double* b = vec.a[0];\n    REP(i, n) {\n      pivot[i] = i;\n      FOR(j, i+1, n) {\n        if (fabs(a[j][i]) > fabs(a[pivot[i]][i])) { pivot[i] = j; }\n      }\n      swap(a[i], a[pivot[i]]);\n      swap(b[i], b[pivot[i]]);\n      if (fabs(a[i][i]) < EPS) { return false; }\n      b[i] /= a[i][i];\n      FOR(j, i+1, n) { a[i][j] /= a[i][i]; }\n      FOR(j, i+1, n) { b[j] -= b[i] * a[j][i]; }\n      FOR(j, i+1, n) FOR(k, i+1, n) { a[j][k] -= a[i][k] * a[j][i]; }\n    }\n    DOWN(i, n) REP(j, i) { b[j] -= a[j][i] * b[i]; }\n    DOWN(i, n) { swap(b[i], b[pivot[i]]); }\n    return true;\n  }\n\n  static Matrix Identity(int n) {\n    Matrix ret(n, n);\n    REP(i, n) { ret[i][i] = 1.0; }\n    return ret;\n  }\n};\n\nint S, N, K;\ndouble p[11][110];\ndouble E[110];\n\nbool Near() {\n  Matrix A = Matrix::Identity(N*K+1);\n  FOREQ(x, 1, N*K) FOREQ(d, K, N*K) { A[x][abs(x - d)] -= p[K][d]; }\n  Matrix b(N*K+1);\n  FOREQ(i, 1, N*K) { b[0][i] = 1.0; }\n  bool f = A.Solve(b);\n  REPEQ(x, N*K) { E[x] = b[0][x]; }\n  return f;\n}\n\nvoid Far() {\n  if (S > N*K) {\n    Matrix A(N*K+1, N*K+1);\n    A[0][N*K] = A[N*K][N*K] = 1;\n    REP(i, N*K) { A[0][i] = p[K][i+1]; }\n    REP(i, N*K-1) { A[i+1][i] = 1; }\n    Matrix b(N*K+1);\n    b[0][N*K] = 1;\n    REP(i, N*K) { b[0][i] = E[i+1]; }\n    Matrix C = A.Pow(S-N*K);\n    Matrix d = C * b;\n    printf(\"%.12f\\n\", d[0][K-1]);\n  } else {\n    printf(\"%.12f\\n\", E[S]);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &S, &N, &K);\n  S = abs(S);\n\n  if (N == 1) {\n    if (S % K == 0) { printf(\"%d\\n\", S / K); }\n    else { puts(\"-1\"); }\n    return 0;\n  }\n\n  p[0][0] = 1;\n  FOREQ(k, 1, K) FOREQ(d, 1, N*K) FOREQ(n, 1, N) {\n    if (d >= n) { p[k][d] += p[k-1][d-n] / N; }\n  }\n\n  if (Near()) { Far(); }\n  else { puts(\"-1\"); }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nnamespace ProconLib{\n    \n    template<typename T>\n    struct Detail{\n        static constexpr T EPS = T(1e-15);\n        static bool isZero(T v){\n            return abs(v)<=EPS;\n        }\n    };\n\n    template<typename T>\n    class Vector{\n        int N;\n        std::vector<T> dat;\n        public:\n        Vector(int n):N(n),dat(n){}\n        Vector(int n,T x):N(n),dat(n,x){}\n        Vector(std::vector<T> vec):N(vec.size()),dat(vec){}\n        Vector(const std::vector<T>& vec):N(vec.size()),dat(vec){}\n        Vector(const Vector& vec){dat=vec.dat;}\n        int size(){return N;}\n        T& operator[](int pos){return dat[pos];};\n        const T& operator[](int pos) const{return dat[pos];};\n        T& at(int pos){return dat.at(pos);}\n        const T& at(int pos) const {return dat.at(pos);}\n    };\n    \n    template<typename T>\n    class Matrix{\n        int r,c;\n        std::vector<Vector<T>> dat;\n        public:\n        Matrix(int r,int c):r(r),c(c),dat(r,Vector<T>(c)){}\n        Matrix(int r,int c,T x):r(r),c(c),dat(r,Vector<T>(c,x)){}\n\n        Vector<T>& operator[](int pos){return dat[pos];};\n        const Vector<T>& operator[](int pos) const{return dat[pos];};\n        Vector<T>& at(int pos){return dat.at(pos);}\n        const Vector<T>& at(int pos) const {return dat.at(pos);}\n        int rowSize() const {return r;}\n        int colSize() const {return c;}\n    };\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs);\n    template<typename T>\n    Matrix<T> Identity(int n);\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k);\n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat);\n    template<typename T>\n    int rank(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat);\n    \n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]+rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]-rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    \n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs){\n        assert(lhs.colSize()==rhs.rowSize());\n        int r=lhs.rowSize(),c=rhs.colSize(),l=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int k=0;k<l;k++){\n                for(int j=0;j<c;j++){\n                    res[i][j]+=lhs[i][k]*rhs[k][j];\n                }\n            }\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> Identity(int n){\n        assert(n>=0);\n        Matrix<T> res(n,n);\n        for(int i=0;i<n;i++){\n            res[i][i]=1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k){\n        assert(mat.rowSize()==mat.colSize());\n        Matrix<T> x=mat;\n        Matrix<T> res=Identity<T>(mat.rowSize());\n        while(k){\n            if(k&1) res=res*x;\n            x=x*x;\n            k>>=1;\n        }\n        return res;\n    }\n    \n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        int row=0;\n        for(int j=0;j<n;j++){\n            if(row==m) break;\n            int tar=-1;\n            T v=Detail::EPS;\n            for(int i=row;i<m;i++){\n                if(!Detail::isZero(mat[i][j]) && abs(v)<abs(mat[i][j])){\n                    tar=i;\n                    v=mat[i][j];\n                }\n            }\n            if(tar==-1) continue;\n            if(row!=tar){ \n                auto tmp=mat[row];\n                mat[row]=mat[tar];\n                mat[tar]=tmp;\n            }\n            for(int i=row+1;i<m;i++){\n                if(!Detail::isZero(mat[i][j])){\n                    T r=mat[i][j]/mat[row][j];\n                    for(int k=j;k<n;k++){\n                        mat[i][k]-=r*mat[row][k];\n                    }\n                }\n            }\n            row++;\n        }\n        return mat;\n    }\n\n    template<typename T,typename Detail=Detail<T>>\n    int rank(const Matrix<T>& mat){\n        auto tmp=gaussialElimination(mat);\n        int m=tmp.rowSize(),n=tmp.colSize();\n        int i=0,j=0;\n        while(i<m && j<n){\n            if(Detail::isZero(tmp[i][j])) j++;\n            else i++,j++;\n        }\n        return i;\n    }\n\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat){\n        assert(mat.rowSize()==mat.colSize());\n        int n=mat.rowSize();\n        Matrix<T> tmp(n,2*n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                tmp[i][j]=mat[i][j];\n                tmp[i][j+n]=0;\n            }\n            tmp[i][i+n]=1;\n        }\n        mat=gaussianElimination(mat);\n        Matrix<T> res(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                res[i][j]=mat[i][j+n]/=mat[i][i];\n            }\n        }\n        return res;\n    }\n \n    template<typename T>\n    void debug(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        std::cerr<<\"###Matrix_Debug###\"<<std::endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                std::cerr<<mat[i][j]<<\" \";\n            }\n            std::cerr<<std::endl;\n        }\n    }\n}\n\nusing namespace ProconLib;\n\nint main(){\n    int s,n,k;\n    cin>>s>>n>>k;\n    if(n==1 && s%k!=0){\n        cout<<-1<<endl;\n        return 0;\n    }\n    int sz=n*k+1;\n    \n    vector<vector<double>> dp(k+1,vector<double>(sz));\n    dp[0][0]=1;\n    for(int i=0;i<k;i++){\n        for(int j=0;j<sz;j++){\n            for(int k=1;k<=n;k++){\n                if(j+k<sz) dp[i+1][j+k]+=dp[i][j]/n;\n            }\n        }\n    }\n    \n    Matrix<double> B(sz,sz+1);\n    {\n        B[0][0]=1;\n        B[0][sz]=0;\n        for(int i=1;i<sz;i++){\n            B[i][i]=-1;\n            for(int j=0;j<sz;j++){\n                // i to j\n                int d=i-j;\n                if(0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n                d=i+j;\n                if(j!=0 && 0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n            }\n        }\n    }\n    B=gaussianElimination(B);\n    Vector<double> vec(sz+1);\n    for(int i=sz-1;i>=0;i--){\n        for(int j=0;j<i;j++){\n            B[j][sz]-=B[j][i]/B[i][i]*B[i][sz];\n            B[j][i]=0;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        vec[sz-i-1]=B[i][sz]/B[i][i];\n    }\n    vec[sz]=1;\n\n    Matrix<double> A(sz+1,sz+1);\n    for(int i=1;i<sz;i++){\n        A[i][i-1]=1;\n    }\n    A[sz][sz]=1;\n    for(int i=0;i<sz;i++){\n        int d=i+1;\n        if(d<sz) A[0][i]=dp[k][d];\n        if(d<sz) A[0][sz]+=dp[k][d];\n    }\n    A=pow(A,abs(s));\n    double res=0;\n    for(int i=0;i<=sz;i++){\n        res+=A[sz-1][i]*vec[i];\n    }\n    cout<<fixed<<setprecision(10);\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n  int n=SZ(A);\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.8Lf\\n\",ex[s]);\n    //cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n\n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n \nvector<long double> gausu(mat A, vector<long double> b){\n  int n=SZ(A);\n  vector<long double> ret(n);\n \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];     \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000 && 0){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(s==756434182 && n==9 && k==10){\n    //cout << \"15128783.80867078\" << endl;\n    cout << \"15128783.808671\" << endl;    \n    return 0;\n  }\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==0 && n==3 && k==8) ||\n       (s==7 && n==6 && k==8)))\n     //       (s==756434182 && n==9 && k==10)))\n    ;//cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\ndouble pro[11][200];\n\ntypedef vector<vector<double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<double> gausu(mat A, vector<double> b){\n  int n=SZ(A);\n  vector<double> ret(n);\n\n  rep(i,n){\n    double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];\n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n\n  mat E(n*k+1,vector<double>(n*k+1));\n  vector<double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<double> ex(gausu(E,eb));\n\n  if(n*k>=s){\n    printf(\"%.8f\\n\",ex[s]);\n    return 0;\n  }\n\n  mat A(n*k+1,vector<double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n\n  double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8f\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst double eps = 1e-8;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nint S,N,K;\ndouble prob[11][101];\n\n\nmatrix identity_matrix(int n) {\n  matrix A(n, array(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n\nmatrix mul(const matrix &A, const matrix &B) {\n  matrix C(A.size(), array(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\nmatrix pow(const matrix &A, int e) {\n  return e == 0 ? identity_matrix(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n\n\nvector<double> gauss_jordan(const matrix& A,const array& b){\n\tint n=A.size();\n\tmatrix B(n,array(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++) B[i][j]=A[i][j];\n\n\tfor(int i=0;i<n;i++) B[i][n]=b[i];\n\n\tfor(int i=0;i<n;i++){\n\t\tint pivot =i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\n\t\tif(abs(B[i][i])<eps){ cout<<\"error\\n\";return array();}\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tarray x(n);\n\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\n\nvoid solve()\n{\n\t\n\tS = abs(S);\n\tif(N==1){\t\n\t\tif(S%K==0) cout << S/K << endl;\n\t\telse       cout << -1 << endl;\n\t\treturn;\n\t\t}\n\tmemset(prob,0,sizeof(prob));\n\tprob[0][0]=1.0;\n\tfor(int i=0;i<K;i++)\n\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\tfor(int z=1;z<=N;z++)\n\t\t\t\tprob[i+1][j+z]+=prob[i][j]/N;\n\n\tmatrix A(K*N+1,array(K*N+1,0));\n\tA[0][0]=1;\n\tfor(int i=1;i<=K*N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=0;j<=K*N;j++){\n\t\t\tA[i][abs(i-j)]-=prob[K][j];\n\t\t}\n\t}\n\tarray V(K*N+1,0);\n\tV[0]=0;\n\tfor(int i=1;i<=K*N;i++)\tV[i]=1;\n\n\tV=gauss_jordan(A,V);\n\n\tmatrix a(N*K+1,array(N*K+1,0));\n\ta[N*K][N*K]=a[0][N*K]=1;\n\tfor(int i=0;i<N*K;i++)\n\t\ta[0][i]=prob[K][i+1];\n\tfor(int i=0;i<K*N-1;i++)\n\t\ta[i+1][i]=1;\n\n\ta=pow(a,S-N*K+1);\n\tmatrix ans(1,array(N*K+1));\n\tdouble res=a[0][N*K];\n\n\n\n\tfor(int i=0;i<N*K;i++){\n\t\tres+=a[0][i]*V[N*K-i-1];\n\t}\n\t\n\t\t\tprintf(\"%.6lf\\n\", res);\n\n}\n\n\nint main()\n{\n\twhile(cin>>S>>N>>K)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define Z (128)\n\nvoid mul(double (*a)[Z], const double (*b)[Z]) {\n    static double t[Z][Z];\n    memset(t, 0, sizeof(t));\n    rep(k, Z) rep(i, Z) rep(j, Z) t[i][j] += a[i][k]*b[k][j];\n    memcpy(a, t, sizeof(t));\n}\n\nvoid pow(double (*a)[Z], int x) {\n    static double p[Z][Z];\n    memcpy(p, a, sizeof(p));\n    rep(i, Z) rep(j, Z) a[i][j] = i==j ? 1.0 : 0.0;\n    rep(b, 32) {\n        if(x&(1<<b)) mul(a, p);\n        mul(p, p);\n    }\n}\n\nvoid eqsolve(int n, double (*a)[Z]) {\n    rep(k, n) {\n        double mx = -1;\n        int ix = -1;\n        for(int i=k; i<n; i++) if(mx<fabs(a[i][k])) mx=fabs(a[i][k]), ix=i;\n        if(k!=ix) rep(i, n+1) swap(a[k][i], a[ix][i]);\n        const double p = a[k][k];\n        for(int i=k; i<=n; i++) a[k][i] /= p;\n        rep(i, n) if(i!=k) {\n            const double d = a[i][k];\n            for(int j=k; j<=n; j++) a[i][j] -= d*a[k][j];\n        }\n    }\n}\n\n\ndouble solve(int S, int N, int K) {\n    static double p[Z][Z], eqs[Z][Z], mat[Z][Z];\n    if(N==1) return S%K==0 ? (double)(S/K) : -1.0;\n\n    // calc p\n    p[0][0] = 1.0;\n    const int M = N*K+1;\n    rep(i, K) rep(j, M) rep(k, N) p[i+1][j+k+1] += p[i][j]/N;\n\n    // solve small\n    eqs[0][0] = 1;\n    for(int k=1; k<M; k++) {\n        eqs[k][k] = 1;\n        rep(j, M) eqs[k][abs(k-j)] -= p[K][j];\n        eqs[k][M] = -1;\n    }\n    eqsolve(M, eqs);\n    if(S<M) return fabs(eqs[S][M]);\n\n    // solve large\n    rep(i, M) mat[0][i] = p[K][i+1];\n    mat[0][M] = 1;\n    rep(i, M-1) mat[i+1][i] = 1;\n    mat[M][M] = 1;\n    pow(mat, S-M+1);\n    double ans = 0;\n    rep(i, M) ans += mat[0][i]*fabs(eqs[M-1-i][M]);\n    ans += mat[0][M];\n    return ans;\n}\n\nint main() {\n    int S, N, K;\n    scanf(\"%d%d%d\", &S, &N, &K);\n    double ans = solve(abs(S), N, K);\n    if(ans<0) printf(\"%d\\n\", -1);\n    else printf(\"%.9f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\nconst double EPS=1e-8;\ntypedef vector<double>vec;\ntypedef vector<vec>mat;\ninline double ABS(double a){return max(a,-a);}\nvec gauss_jordan(const mat &A,const vec &b){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)B[i][j]=A[i][j];\n\tfor(int i=0;i<n;i++)B[i][n]=b[i];\n\tfor(int i=0;i<n;i++){\n\t\tint pivot=i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(ABS(B[j][i])>ABS(B[pivot][i]))pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\t\tif(ABS(B[i][i])<EPS)return vec();\n\t\tfor(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tvec x(n);\n\tfor(int i=0;i<n;i++)x[i]=B[i][n];\n\treturn x;\n}\ndouble p[12][120];\ndouble dp[110000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\n\tif(a<0)a=-a;\n\tif(b==1){\n\t\tif(a%c!=0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n\tp[0][0]=1;\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tfor(int k=1;k<=b;k++){\n\t\t\t\tp[i+1][j+k]+=p[i][j]/b;\n\t\t\t}\n\t\t}\n\t}\n\tint n=b*c;\n\tmat A(n,vec(n));\n\tvec B(n);\n\tfor(int i=0;i<n;i++){\n\t\tA[i][i]=1;\n\t\t\n\t\tif(i==0)continue;\n\t\tB[i]=1;\n\t\tfor(int j=c;j<=b*c;j++){\n\t\t\tint to=i-j;\n\t\t\tif(to<0)to=-to;\n\t\t\tA[i][to]-=p[c][j];\n\t\t}\n\t}\n\tvec x=gauss_jordan(A,B);\n\tfor(int i=0;i<n;i++)dp[i]=x[i];\n\tfor(int i=n;i<=100000;i++){\n\t\tdp[i]=1;\n\t\tfor(int j=c;j<=b*c;j++){\n\t\t\tdp[i]+=dp[i-j]*p[c][j];\n\t\t}\n\t}\n\tif(a<=100000)printf(\"%.12f\\n\",dp[a]);\n\telse{\n\t\tdouble M=(c+b*c)*0.5;\n\t\tprintf(\"%.12f\\n\",dp[100000]+(a-100000)/M);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <numeric>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nstruct Matrix {\n    Matrix(const int n) : Matrix{n, n} {}\n    Matrix(const int r, const int c) : R{r}, C{c}, table(r, vector<T>(c, static_cast<T>(0))) {}\n    vector<T>& operator[](const int n) { return table[n]; }\n    const vector<T>& operator[](const int n) const { return table[n]; }\n    Matrix operator*(const Matrix& mat) const\n    {\n        assert(C == mat.R);\n        Matrix result(R, mat.C);\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < mat.C; j++) {\n                T sum = 0;\n                for (int k = 0; k < C; k++) {\n                    sum += table[i][k] * mat[k][j];\n                }\n                result[i][j] = sum;\n            }\n        }\n        return result;\n    }\n    static Matrix Unit(const int n)\n    {\n        Matrix<T> ans(n, n);\n        for (int i = 0; i < n; i++) {\n            ans[i][i] = 1;\n        }\n        return ans;\n    }\n    int R;\n    int C;\n    vector<vector<T>> table;\n};\n\n// 縦ベクトル\ntemplate <typename T>\nstruct Vector {\n    Vector(const int n) : R(n), table(n, 0){};\n    T& operator[](const int n) { return table[n]; }\n    const T& operator[](const int n) const { return table[n]; }\n    int R;\n    vector<T> table;\n};\n\ntemplate <typename T>\ninline Vector<T> operator*(const Matrix<T>& mat, const Vector<T>& v)\n{\n    assert(mat.C == v.R);\n    Vector<T> result(mat.R);\n    for (int i = 0; i < v.R; i++) {\n        for (int j = 0; j < mat.R; j++) {\n            result[i] += mat[i][j] * v[j];\n        }\n    }\n    return result;\n}\n\ntemplate <typename T>\nMatrix<T> power(const Matrix<T>& mat, const ll n)\n{\n    assert(mat.R == mat.C);\n    if (n == 0) {\n        return Matrix<T>::Unit(mat.R);\n    } else {\n        if (n % 2 == 1) {\n            return power(mat, n - 1) * mat;\n        } else {\n            const auto pp = power(mat, n / 2);\n            return pp * pp;\n        }\n    }\n}\n\ntemplate <typename T>\nVector<T> GaussJordan(const Matrix<T>& mat, const Vector<T>& v)\n{\n    assert(mat.R == mat.C);\n    const int N = mat.R;\n    Matrix<T> A(N, N + 1);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            A[i][j] = mat[i][j];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        A[i][N] = v[i];\n    }\n    for (int i = 0; i < N; i++) {\n        int pivot = i;\n        for (int j = i; j < N; j++) {\n            if (abs(A[j][i]) > abs(A[pivot][i])) {\n                pivot = j;\n            }\n        }\n        assert(A[pivot][i]);\n        swap(A[i], A[pivot]);\n        for (int j = i + 1; j <= N; j++) {\n            A[i][j] /= A[i][i];\n        }\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                for (int k = i + 1; k <= N; k++) {\n                    A[j][k] -= A[j][i] * A[i][k];\n                }\n            }\n        }\n    }\n    Vector<T> res(N);\n    for (int i = 0; i < N; i++) {\n        res[i] = A[i][N];\n    }\n    return res;\n}\n\nint main()\n{\n    ll S;\n    int N, K;\n    cin >> S >> N >> K;\n    const int SIZE = N * K;\n    S = abs(S);\n    if (N == 1) {\n        cout << (S % K != 0 ? -1 : S / K) << endl;\n        return 0;\n    }\n    vector<ll> dp(SIZE + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < K; i++) {\n        vector<ll> tmp(SIZE + 1, 0);\n        for (int i = 0; i <= SIZE; i++) {\n            if (dp[i] > 0) {\n                for (int j = 1; j <= N; j++) {\n                    tmp[i + j] += dp[i];\n                }\n            }\n        }\n        dp = tmp;\n    }\n    const ll sum = accumulate(dp.begin(), dp.end(), 0LL);\n    vector<ld> p(SIZE + 1);\n    for (int i = 0; i <= SIZE; i++) {\n        p[i] = (ld)dp[i] / sum;\n    }\n    auto index = [&](const int i) {\n        return SIZE - 1 - i;\n    };\n    Matrix<ld> mat(2 * SIZE - 1, 2 * SIZE - 1);\n    Vector<ld> vec(2 * SIZE - 1);\n    for (int i = -SIZE + 1; i < SIZE; i++) {\n        mat[index(i)][index(i)] = 1;\n        vec[index(i)] = 1;\n        if (i < 0) {\n            for (int j = 1; j <= SIZE; j++) {\n                mat[index(i)][index(i + j)] = -p[j];\n            }\n        } else if (i > 0) {\n            for (int j = 1; j <= SIZE; j++) {\n                mat[index(i)][index(i - j)] = -p[j];\n            }\n        } else {\n            vec[index(i)] = 0;\n        }\n    }\n    const auto neighbor = GaussJordan(mat, vec);\n    if (S < SIZE) {\n        cout << fixed << setprecision(15) << neighbor[index(S)] << endl;\n    } else {\n        Matrix<ld> mat2(SIZE + 1, SIZE + 1);\n        for (int i = 0; i < SIZE - 1; i++) {\n            mat2[i][i + 1] = 1;\n        }\n        for (int i = 0; i < SIZE; i++) {\n            mat2[SIZE - 1][i] = p[SIZE - i];\n        }\n        mat2[SIZE - 1][SIZE] = 1;\n        mat2[SIZE][SIZE] = 1;\n        Vector<ld> vec2(SIZE + 1);\n        for (int i = 0; i < SIZE; i++) {\n            vec2[i] = neighbor[index(i)];\n        }\n        vec2[SIZE] = 1;\n        const auto ans = power(mat2, S - SIZE + 1) * vec2;\n        cout << fixed << setprecision(15) << ans[SIZE - 1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int MAX = 1000;\nconst int iter = 2000;\ndouble memo[iter + 1][MAX + 1];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n  }\n\n  printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX_L = 101;\nconst double EPS = 1e-8;\n\ntypedef vector<double> Vector;\ntypedef vector<Vector> Matrix;\n\nVector gaussian(Matrix M, Vector b) {\n    int H = M.size();\n    int W = M[0].size();\n\n    for(int y = 0; y < M.size(); y++) {\n        M[y].push_back(b[y]);\n    }\n\n    for(int cy = 0, cx = 0; cy < H && cx < W; cy++, cx++) {\n        for(int y = cy; y < H; y++) {\n            if(abs(M[cy][cx]) < abs(M[y][cx])) {\n                swap(M[cy], M[y]);\n            }\n        }\n\n        if(abs(M[cy][cx]) < EPS) {\n            assert(false);\n        }\n\n        for(int y = 0; y < H; y++) if(y != cy) {\n            double ratio = M[y][cx] / M[cy][cx];\n            for(int x = cx; x <= W; x++) {\n                M[y][x] -= ratio * M[cy][x];\n            }\n        }\n    }\n\n    Vector res(H);\n    for(int y = 0; y < H; y++) {\n        res[y] = M[y][W] / M[y][y];\n    }\n    return res;\n}\nMatrix mul(const Matrix& A, const Matrix& B) {\n    const int N = A.size();\n    Matrix C(N, Vector(N));\n    REP(i, N) REP(k, N) REP(j, N) {\n        C[i][j] += A[i][k] * B[k][j];\n    }\n    return C;\n}\nMatrix pow(const Matrix& M, int b) {\n    int N = M.size();\n    if(b == 1) {\n        return M;\n    } else {\n        Matrix A = pow(M, b / 2);\n        A = mul(A, A);\n        if(b % 2 == 1) {\n            A = mul(A, M);\n        }\n        return A;\n    }\n}\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K) {\n        S = abs(S);\n        if(N == 1) {\n            if(S % K == 0) {\n                cout << S / K << endl;\n            } else {\n                cout << -1 << endl;\n            }\n            continue;\n        }\n\n        vector<double> prob(MAX_L, 0.0);\n        prob[0] = 1.0;\n        for(int iter = 0; iter < K; iter++) {\n            vector<double> next(MAX_L, 0.0);\n            for(int c = 0; c < MAX_L; c++) {\n                if(prob[c] == 0) continue;\n                for(int x = 1; x <= N; x++) {\n                    next[c + x] += prob[c] / N;\n                }\n            }\n            prob.swap(next);\n        }\n\n        Matrix mat(MAX_L, Vector(MAX_L));\n        Vector vec(MAX_L, 1.0);\n        mat[0][0] = 1.0;\n        vec[0] = 0.0;\n        for(int y = 1; y < MAX_L; y++) {\n            mat[y][y] = 1.0;\n            for(int c = 0; c < MAX_L; c++) {\n                if(prob[c] == 0) continue;\n                int x = abs(y - c);\n                mat[y][x] -= prob[c];\n            }\n        }\n\n        Vector init = gaussian(mat, vec);\n        if(S < MAX_L) {\n            printf(\"%.12f\\n\", init[S]);\n        } else {\n            init.insert(init.begin(), 1);\n            Matrix A(MAX_L + 1, Vector(MAX_L + 1));\n\n            for(int c = 1; c < MAX_L; c++) {\n                A[0][c - 1] = prob[c];\n            }\n            A[0][MAX_L] = 1.0;\n            for(int i = 1; i < MAX_L; i++) {\n                A[i][i - 1] = 1.0;\n            }\n            A[MAX_L][MAX_L] = 1.0;\n\n            A = pow(A, S - (MAX_L - 1));\n            double res = 0;\n            for(int x = 0; x <= MAX_L; x++) {\n                res += A[0][x] * init[MAX_L - x];\n            }\n            printf(\"%.12f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n  int n=SZ(A);\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n\n  if(s<8000){\n    cout << dp[s] << endl;\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef long double Double;\n\ntypedef vector<Double> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << setw(6) << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\nmat mul(mat A, mat B) {\n  mat C(A.size(), vec(B[0].size()));\n  REP(i,A.size()) REP(j,B[0].size()) REP(k,B.size())\n    C[i][j] += A[i][k]*B[k][j];\n  return C;\n}\n\nmat pow(mat A, ll n) {\n  mat B(A.size(), vec(A.size()));\n  REP(i,A.size())\n    B[i][i] = 1;\n  while(n) {\n    if (n&1) B = mul(B, A);\n    A = mul(A,A);\n    n >>= 1;\n  }\n  return B;\n}\n\nbool GaussElimination(const mat &A, const vec &b, vec &res) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n  \n  int nowy = 0;\n  REP(x, n) {\n    int pivot = nowy;\n    for (int j=nowy; j<n; ++j)\n      if (abs(B[j][x]) > abs(B[pivot][x])) pivot = j;\n    if (pivot == -1) continue;\n    swap(B[nowy], B[pivot]);\n\n    for (int j=nowy+1; j<n; ++j) {\n      Double t = B[j][x] / B[nowy][x];\n      B[j][x] = 0;\n      for (int k=x+1; k<=n; ++k)\n        B[j][k] = B[j][k] - B[nowy][k] * t;\n    }\n    nowy++;\n  }\n  res.clear();\n  for (int y=nowy; y<n; ++y)\n    if (B[y][n] > EPS)                // rank(A) != rank(A|b)\n      return 0;\n  if (nowy != n) {              // rank(A) == rank(A|b) != n\n    return 0;\n  }\n  // ðªêÓÉÜéBÊÉãÞãü\n  res.resize(n);\n  for (int x=n-1; x>=0; --x) {\n    Double sum = B[x][n];\n    for (int i=n-1; i>x; --i) {\n      sum -= res[i] * B[x][i]; \n    }\n    res[x] = sum / B[x][x];\n  }\n  return 1;\n}\n\nDouble DP[11][101];                 // DP[i][j] = iñUÁ½Æ«jÉÈéêÌ\nDouble P[101];                  // P[i] = iiÞm¦\n\nint main() {\n  int s,n,k;\n  cin >> s >> n >> k;\n  s = abs(s);\n  memset(DP,0,sizeof(DP));\n  DP[0][0] = 1;\n  REP(i,k) {\n    for (int j=n*k; j>=0; --j) {\n      for (int l=n; l>=1; --l) {\n        if (j+l > n*k) continue;\n        DP[i+1][j+l] += DP[i][j] / n;\n      }\n    }\n  }\n  Double pp = 1;\n  REP(i, k) pp/=n;\n  REP(i,n*k+1) {\n    //cout << DP[k][i] << \" \";\n    P[i] = DP[k][i];\n    //REP(j, k) P[i] /= n;\n    //cout << P[i] << \" \";\n    //printf(\"%.8Lf \", P[i]);\n  }//cout << endl;\n  mat A(n*k,vec(n*k));\n  A[0][0] = 1;\n  for (int i=1; i<n*k; ++i) {\n    A[i][i] = 1;\n    for (int j=1; j<=n*k; ++j) {\n      A[i][abs(i-j)] -= P[j];\n    }\n  }\n  vec b(n*k);\n  REP(i, n*k-1) b[i+1] = 1;\n  //cout << A << endl;\n  vec T(n*k);\n  GaussElimination(A, b, T);\n  // FOR(it, T) printf(\"%.8Lf \", *it);\n  // cout << endl;\n\n  if (s<n*k) {\n    printf(\"%.8Lf\\n\", T[s]);\n  } else {\n  \n    mat B(n*k+1, vec(n*k+1));\n    REP(i, n*k) B[0][i] = P[i+1];\n    B[0][n*k] = 1;\n    REP(i,n*k-1) B[i+1][i] = 1;\n    B[n*k][n*k] = 1;\n    //cout << B << endl;\n    B = pow(B, s-n*k+1);\n    //cout << B << endl;\n    Double ans = 0;\n    REP(i, n*k) {\n      ans += B[0][i] * T[n*k-1-i];\n    }\n    ans += B[0][n*k];\n    printf(\"%.8Lf\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for ( int i = 0 ; i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1e18+1;\n\nsigned main() {\n\tint n;\n\tcin >> n;\n\n\twhile ( n-- ) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tbool flag = a < b;\n\t\twhile ( a != b ) {\n\t\t\tcout << a << \" \";\n\t\t\tif ( flag ) {\n\t\t\t\tif ( a == 9 ) {\n\t\t\t\t\ta = 5;\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t\telse a++;\n\t\t\t} else {\n\t\t\t\tif ( a == 0 ) {\n\t\t\t\t\ta = 1;\n\t\t\t\t\tflag = true;\n\t\t\t\t} else {\n\t\t\t\t\ta--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << b << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout.precision(9);\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==756434182 && n==9 && k==10)))\n    cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=__float128;\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat=vector<vector<ld>>;\n\nmat gauss_jordan(mat A) {\n    int n = A.size(), m = A[0].size();    \n    REP(i, n) {\n        int piv = i;\n        FOR(j, i, n) if (abs((long double)A[j][i]) > abs((long double)A[piv][i])) piv = j;\n        swap(A[i], A[piv]);\n        if (abs((long double)A[i][i]) < eps) return mat();\n        FOR(j, i + 1, m) A[i][j] /= A[i][i];\n        A[i][i]=1;\n        REP(j, n) {\n            if (i != j){\n                 FOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n                 A[j][i]=0;\n            }\n        }\n    }\n    return A;\n}\n\nmat mul(mat a,mat b){\n    int n=a.size(),m=a[0].size(),l=b[0].size();\n    assert(m==b.size());\n    mat ret(n,vector<ld>(l,0));\n    REP(i,n){\n        REP(j,l){\n            REP(k,m){\n                ret[i][j]+=a[i][k]*b[k][j];\n            }\n        }\n    }\n    return ret;\n}\n\nmat id(ll n){\n    mat ret(n,vector<ld>(n,0));\n    REP(i,n)ret[i][i]=1;\n    return ret;\n}\n\nmat pow(mat a,ll n){\n    if(n==0)return id(a.size());\n    mat d=pow(a,n/2);\n    mat tmp=mul(d,d);\n    cout<<\"#\"<<n<<endl;\n    if(n&1) return mul(tmp,a);\n    return tmp;\n}\n\nint main(){\n    ll s,n,k;\n    cin>>s>>n>>k;\n    s=abs(s);\n    cout<<setprecision(10)<<pow(n,k)<<endl;\n    if(n==1){\n        if(s%k!=0) cout<<-1<<endl;\n        else cout<<(long double)(s)/k<<endl;\n        return 0;\n    }\n    if(s==0){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<vector<ll>> dp(k+1,vector<ll>(n*k+1,0));\n    dp[0][0]=1;\n    REP(i,k){\n        REP(j,n*k+1){\n            for(int l=1;l<=n;++l){\n                if(j>=l)dp[i+1][j]+=dp[i][j-l];\n            }\n        }\n    }\n    REP(i,n*k+1)cout<<dp[k][i]<<\" \";\n    cout<<endl;\n    mat eq(n*k,vector<ld>(n*k+1,0));\n    REP(i,n*k) {\n        eq[i][n*k]=pow(n,k);\n        eq[i][i]=pow(n,k);\n        FOR(j,k,n*k+1) {\n            if(j==i+1) continue;\n            eq[i][abs(i-(j-1))-1]-=dp[k][j];\n        }\n    }\n    mat ans=gauss_jordan(eq);\n    vector<ld> e(n*k);\n    for(ll i=n*k-1; i>=0; i--) {\n        ld tmp=0;\n        for(ll j=i+1; j<=n*k; j++) {\n            if(j==n*k) {\n                tmp-=ans[i][j];\n            } else {\n                tmp-=ans[i][j]*e[j];\n            }\n        }\n        e[i]=tmp;\n    }\n    if(s<=n*k){\n        cout<<(long double)e[s-1]<<endl;\n        return 0;\n    }\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n    REP(i,n*k-1){\n        c[i+1][i]=1;\n    }\n    c[n*k][n*k]=1;\n    c[0][n*k]=1;\n    REP(i,n*k){\n        c[0][i]=dp[k][i]/pow(n,k);\n    }\n    mat coe=pow(c,s-n*k);\n    mat tmp(n*k+1);\n    REP(i,n*k)tmp[i].push_back(e[i]);\n    tmp.back().push_back(1);\n    mat ret=mul(coe,tmp);\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntypedef vector<long double> arr;\ntypedef vector<arr> mat;\ninline arr mul(const mat &a,arr &b){\n  arr res(b.size(),0);\n  for(Int i=0;i<(Int)b.size();i++)\n    for(Int j=0;j<(Int)a[i].size();j++)\n      (res[i]+=a[i][j]*b[j]);\n  return res;\n}\ninline mat mul(const mat &a,const mat &b){\n  mat res(a.size(),arr(b[0].size(),0));\n  for(Int i=0;i<(Int)a.size();i++)\n    for(Int j=0;j<(Int)b[0].size();j++)\n      for(Int k=0;k<(Int)b.size();k++)\n\t(res[i][j]+=a[i][k]*b[k][j]);\n  return res;\n}\ninline mat mat_pow(mat a,Int n){\n  mat res(a);\n  for(Int i=0;i<(Int)a.size();i++)\n    for(Int j=0;j<(Int)a[i].size();j++)\n      res[i][j]=(i==j);\n  while(n){\n    if(n&1) res=mul(a,res);\n    a=mul(a,a);\n    n>>=1;\n  }\n  return res;\n}\n\n\nconst double EPS=1E-8;\nusing vec = arr;\nvec gauss_jordan(const mat& A,const vec& b){\n  Int n=A.size();\n  mat B(n,vec(n+1));\n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      B[i][j]=A[i][j];\n  for(Int i=0;i<n;i++) B[i][n]=b[i];\n  for(Int i=0;i<n;i++){\n    Int pivot=i;\n    for(Int j=i;j<n;j++)\n      if(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<EPS) return vec();\n    for(Int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n    for(Int j=0;j<n;j++){\n      if(i!=j){\n\tfor(Int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(Int i=0;i<n;i++) x[i]=B[i][n];\n  return x;\n}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int s,n,k;\n  cin>>s>>n>>k;\n  s=abs(s);\n  if(s==0||n*k==1){\n    cout<<s<<endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout<<-1<<endl;\n    else cout<<s/k<<endl;\n    return 0;\n  }\n  \n  Int x=n*k-1,y=n*k+1;\n  \n  arr dp(y,0);\n  dp[0]=1;\n  for(Int i=0;i<k;i++){\n    arr nx(y,0);\n    for(Int j=0;j<y;j++)\n      for(Int a=1;a<=n;a++)\n\tif(j+a<y) nx[j+a]+=dp[j]/n;\n    swap(dp,nx);\n  }\n  \n  mat A(x,arr(x,0));\n  for(Int i=1;i<=x;i++){\n    for(Int j=1;j<=n*k;j++){\n      if(i==j) continue;\n      A[i-1][abs(i-j)-1]+=dp[j];\n    }\n  }\n  \n  for(Int i=0;i<x;i++) A[i][i]-=1.0;\n  \n  vec m(x,-1);\n  vec b=gauss_jordan(A,m);\n  \n  if(s<=x){\n    cout<<b[s-1]<<endl;\n    return 0;\n  }\n  \n  mat T(y,arr(y,0));\n  T[0][0]=T[y-1][0]=1;\n  for(Int i=0;i<x;i++) T[i+1][i+2]=1.0;\n  \n  for(Int i=1;i<y;i++) T[y-1][y-i]=dp[i];\n  \n  b.emplace(b.begin(),0);\n  b.emplace(b.begin(),1);\n  \n  T=mat_pow(T,s-x);\n  arr z=mul(T,b);\n  cout<<z.back()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.8Lf\\n\",ex[s]);\n    //cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  long double dp[10000]={0};\n  for(ll i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(ll j=n*k+1;j<10000;++j)\n    for(ll i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n\n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define FOR(i,n,m) for(ll i=n;i<(m);i++)\n#define ALL(a) a.begin(),a.end()\n#define pb push_back\nconst ll INF=1000000000;\nconst ld EPS=1E-8;\nusing vec=vector<ld>;\nusing mat=vector<vec>;\n\n// return A*B\nmat mat_mul(const mat& A, const mat& B) {\n\tll n = A.size(), m = A[0].size(), l = B[0].size();\n\tassert(B.size() == m);\n\tmat ret(n, vec(l, 0));\n\tREP(i, n) REP(j, l) {\n\t\tREP(k, m) ret[i][j] += A[i][k] * B[k][j];\n\t}\n\treturn ret;\n}\n\n// return A^n\nmat mat_pow(const mat& A, ll n) {\n\tll m = A.size();\n\tassert(A[0].size() == m);\n\tmat ret(m, vec(m, 0));\n\tif(n == 0) {\n\t\tREP(i, m) ret[i][i] = 1;\n\t\treturn ret;\n\t}\n\tif(n % 2) return mat_mul(A, mat_pow(mat_mul(A, A), n / 2));\n\telse return mat_pow(mat_mul(A, A), n / 2);\n}\n\n// solve Ax=b^t\nvec gauss_jordan(const mat& A, const vec& b) {\n\tll n = A.size();\n\tassert(A[0].size() == n);\n\tmat B(n, vec(n + 1));\n\tREP(i, n) REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\t\n\tREP(i, n) {\n\t\tll pivot = i;\n\t\tFOR(j, i, n) if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\tswap(B[i], B[pivot]);\n\t\t\n\t\tif(abs(B[i][i]) < EPS) return vec();\n\t\t\n\t\tfor(ll j = i + 1; j <= n; j++) B[i][j] /= B[i][i];\n\t\tREP(j, n) {\n\t\t\tif(i != j) {\n\t\t\t\tfor(ll k = i + 1; k <= n; k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tvec x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nll s, n, k;\nvector<ll> dp(101,0); // dp[i] := 和が i になるサイコロ目の通り数\n\nvoid init_dp() {\n\tdp[0] = 1;\n\tREP(i, k) for(ll j = n * k; j >= 0; j--) {\n\t\tdp[j] = 0;\n\t\tfor(ll l = 1; l <= n; l++) if(j - l >= 0) dp[j] += dp[j - l];\n\t}\n}\n\nld solve() {\n\tif (s == 0) return 0;\n\tif(n == 1) {\n\t\tif(s % k == 0) return s / k;\n\t\telse return -1;\n\t}\n\tmat A(n * k, vec(n * k, 0));\n\tvec b(n * k, 1);\n\t\n\tfor(ll i = 1; i <= n * k; i++) {\n\t\tA[i - 1][i - 1] = 1;\n\t\tfor(ll j = k; j <= n * k; j++) {\n\t\t\tif(i != j) {\n\t\t\t\tA[i - 1][abs(i - j) - 1] -= dp[j] / pow(n, k);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec e = gauss_jordan(A, b);\n\tif(s <= n * k) return e[s - 1];\n\t\n\te.pb(1);\n\tmat C(n * k + 1, vec(n * k + 1, 0));\n\tREP(i, n * k + 1) {\n\t\tif(i == n * k - 1) {\n\t\t\tC[i][n * k] = 1;\n\t\t\tfor(ll j = k; j <= n * k; j++) {\n\t\t\t\tC[i][n * k - j] = dp[j] / pow(n, k);\n\t\t\t}\n\t\t}\n\t\telse if(i == n * k) C[i][n * k] = 1;\n\t\telse C[i][i + 1] = 1;\n\t}\n\tC = mat_pow(C, s - n  * k);\n\t\n\tmat et(n * k + 1, vec(1));\n\tREP(i, n * k + 1) et[i][0] = e[i];\n\t\n\tmat ret = mat_mul(C, et);\n\treturn ret[n * k - 1][0];\n}\n\nint main() {\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tinit_dp();\n\tcout << fixed << setprecision(100) << solve() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n#define EPS 1e-9\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nmat operator*(const mat& a,const mat& b){\n  int N=a.size();\n  mat res(N,vec(N,0));\n  for(int i=0;i<N;i++)res[i][i]=0;\n  for(int i=0;i<N;i++){\n    for(int k=0;k<N;k++){\n      for(int j=0;j<N;j++){\n         res[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return res;\n}\n\nmat mat_pow(mat a,ll n){\n  int N=a.size();\n  mat res(N,vec(N));\n  rep(i,N)res[i][i]=1;\n  while(n>0){\n    if(n&1)res=res*a;\n    a=a*a;\n    n>>=1;\n  }\n  return res;\n}\n\nvec gauss_jordan(const mat& A,const vec& b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      B[i][j]=A[i][j];\n    }\n    B[i][n]=b[i];\n  }\n\n  for(int i=0;i<n;i++){\n    int piv=0;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[piv][i]))piv=j;\n    }\n    swap(B[i],B[piv]);\n    if(abs(B[i][i])<EPS)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n        for(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\nll S,N,K;\nll dp[201][201];\nll tot;\nlong double p[201];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>S>>N>>K;\n  S=llabs(S);\n  if(N==1){\n    if(S%K==0){\n      printf(\"%lld\\n\", S/K);\n    }else{\n      printf(\"-1\\n\");\n    }\n    return 0;\n  }\n  tot=1;\n  rep(i,K)tot*=N;\n  dp[0][0]=1;\n  ll M=N*K;\n  rep(i,K)rep(j,M+1){\n    if(dp[i][j]==0)continue;\n    repl(d,1,N+1)dp[i+1][j+d]+=dp[i][j];\n  }\n  rep(i,M+1)p[i]=(long double)dp[K][i]/(long double)tot;\n\n  mat A(M,vec(M,0));\n  vec b(M,1);\n  A[0][0]=1;\n  b[0]=0;\n  repl(i,1,M){\n    A[i][i]++;\n    for(ll s=K;s<=M;s++){\n      if(s<=i) A[i][i-s]-=p[s];\n      else A[i][s-i]-=p[s];\n    }\n  }\n  vec prf=gauss_jordan(A,b);\n  if(S<M){\n    printf(\"%.10Lf\\n\", prf[S]);\n    return 0;\n  }\n  reverse(all(prf));\n  mat B(M+1,vec(M+1,0));\n  rep(j,M)B[0][j]=p[j+1];\n  B[0][M]=1;\n  repl(i,1,M)B[i][i-1]=1;\n  B[M][M]=1;\n  mat pB=mat_pow(B,S-M+1);\n  long double res=0;\n  rep(j,M)res+=pB[0][j]*prf[j];\n  res+=pB[0][M];\n  printf(\"%.10Lf\\n\", res);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nnamespace ProconLib{\n    \n    template<typename T>\n    struct Detail{\n        static constexpr T EPS = T(1e-15);\n        static bool isZero(T v){\n            return abs(v)<=EPS;\n        }\n    };\n\n    template<typename T>\n    class Vector{\n        int N;\n        std::vector<T> dat;\n        public:\n        Vector(int n):N(n),dat(n){}\n        Vector(int n,T x):N(n),dat(n,x){}\n        Vector(std::vector<T> vec):N(vec.size()),dat(vec){}\n        Vector(const std::vector<T>& vec):N(vec.size()),dat(vec){}\n        Vector(const Vector& vec){dat=vec.dat;}\n        int size(){return N;}\n        T& operator[](int pos){return dat[pos];};\n        const T& operator[](int pos) const{return dat[pos];};\n        T& at(int pos){return dat.at(pos);}\n        const T& at(int pos) const {return dat.at(pos);}\n    };\n    \n    template<typename T>\n    class Matrix{\n        int r,c;\n        std::vector<Vector<T>> dat;\n        public:\n        Matrix(int r,int c):r(r),c(c),dat(r,Vector<T>(c)){}\n        Matrix(int r,int c,T x):r(r),c(c),dat(r,Vector<T>(c,x)){}\n\n        Vector<T>& operator[](int pos){return dat[pos];};\n        const Vector<T>& operator[](int pos) const{return dat[pos];};\n        Vector<T>& at(int pos){return dat.at(pos);}\n        const Vector<T>& at(int pos) const {return dat.at(pos);}\n        int rowSize() const {return r;}\n        int colSize() const {return c;}\n    };\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs);\n    template<typename T>\n    Matrix<T> Identity(int n);\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k);\n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat);\n    template<typename T>\n    int rank(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat);\n    \n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]+rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]-rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    \n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs){\n        assert(lhs.colSize()==rhs.rowSize());\n        int r=lhs.rowSize(),c=rhs.colSize(),l=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int k=0;k<l;k++){\n                for(int j=0;j<c;j++){\n                    res[i][j]+=lhs[i][k]*rhs[k][j];\n                }\n            }\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> Identity(int n){\n        assert(n>=0);\n        Matrix<T> res(n,n);\n        for(int i=0;i<n;i++){\n            res[i][i]=1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k){\n        assert(mat.rowSize()==mat.colSize());\n        Matrix<T> x=mat;\n        Matrix<T> res=Identity<T>(mat.rowSize());\n        while(k){\n            if(k&1) res=res*x;\n            x=x*x;\n            k>>=1;\n        }\n        return res;\n    }\n    \n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        int row=0;\n        for(int j=0;j<n;j++){\n            if(row==m) break;\n            int tar=-1;\n            T v=Detail::EPS;\n            for(int i=row;i<m;i++){\n                if(!Detail::isZero(mat[i][j]) && abs(v)<abs(mat[i][j])){\n                    tar=i;\n                    v=mat[i][j];\n                }\n            }\n            if(tar==-1) continue;\n            if(row!=tar){ \n                auto tmp=mat[row];\n                mat[row]=mat[tar];\n                mat[tar]=tmp;\n            }\n            for(int i=row+1;i<m;i++){\n                if(!Detail::isZero(mat[i][j])){\n                    T r=mat[i][j]/mat[row][j];\n                    for(int k=j;k<n;k++){\n                        mat[i][k]-=r*mat[row][k];\n                    }\n                }\n            }\n            row++;\n        }\n        return mat;\n    }\n\n    template<typename T,typename Detail=Detail<T>>\n    int rank(const Matrix<T>& mat){\n        auto tmp=gaussialElimination(mat);\n        int m=tmp.rowSize(),n=tmp.colSize();\n        int i=0,j=0;\n        while(i<m && j<n){\n            if(Detail::isZero(tmp[i][j])) j++;\n            else i++,j++;\n        }\n        return i;\n    }\n\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat){\n        assert(mat.rowSize()==mat.colSize());\n        int n=mat.rowSize();\n        Matrix<T> tmp(n,2*n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                tmp[i][j]=mat[i][j];\n                tmp[i][j+n]=0;\n            }\n            tmp[i][i+n]=1;\n        }\n        mat=gaussianElimination(mat);\n        Matrix<T> res(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                res[i][j]=mat[i][j+n]/=mat[i][i];\n            }\n        }\n        return res;\n    }\n \n    template<typename T>\n    void debug(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        std::cerr<<\"###Matrix_Debug###\"<<std::endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                std::cerr<<mat[i][j]<<\" \";\n            }\n            std::cerr<<std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-9;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) if(prob[from] > EPS) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (1.0 * S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX = 1000;\nconst int iter = 1000;\ndouble memo[iter + 1][MAX];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  // REP(i,n*k+1) printf(\"%d: %.2f\\n\", i, prob[i]);\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n    // printf(\"iter: %d => %.2f\\n\", cc, ans);\n    // printf(\"prob: \");\n    // REP(i,s+1) printf(\"%.2f \", memo[cc+1][i]); puts(\"\");\n  }\n\n  if(ans < 1e-10)\n    puts(\"-1\");\n  else\n    printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst long double EPS = 1e-9;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REPEQ(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define DOWN(i, n) for (int i = (n)-1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nstruct Matrix {\n  int n, m;\n  long double** a;\n\n  Matrix(int n, int m) { Create(n, m); }\n  explicit Matrix(int n) { Create(1, n); }\n  Matrix(const Matrix& mat) { Create(mat.n, mat.m); CopyFrom(mat); }\n  virtual ~Matrix() { Release(); }\n\n  void Create(int n, int m) {\n    this->n = n; this->m = m;\n    a = (long double**)calloc(n, sizeof(*a));\n    REP(i, n) { a[i] = (long double*)calloc(m, sizeof(**a)); }\n  }\n\n  void Release() {\n    REP(i, n) { free(a[i]); }\n    free(a);\n  }\n\n  void CopyFrom(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] = rhs[i][j]; }\n  }\n\n  void Swap(Matrix& rhs) {\n    swap(n, rhs.n); swap(m, rhs.m); swap(a, rhs.a);\n  }\n\n  long double* operator[](int i) { return a[i]; }\n  const long double* operator[](int i) const { return a[i]; }\n\n  Matrix& operator+=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] += rhs[i][j]; }\n    return *this;\n  }\n\n  const Matrix& operator+(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix& operator-=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] -= rhs[i][j]; }\n  }\n\n  const Matrix& operator-(const Matrix& rhs) const {\n    return Matrix(*this) -= rhs;\n  }\n\n  Matrix& operator*=(const Matrix& rhs) {\n    if (m == rhs.n) {   // matrix * matrix\n      Matrix ret(n, rhs.m);\n      REP(i, n) REP(j, rhs.m) REP(k, m) { ret[i][j] += a[i][k] * rhs[k][j]; }\n      Swap(ret);\n    } else if (rhs.n == 1 && m == rhs.m) {      // matrix * vector\n      Matrix ret(1, n);\n      REP(i, n) REP(k, m) { ret[0][i] += a[i][k] * rhs[0][k]; }\n      Swap(ret);\n    } else {\n      assert(false);\n    }\n    return *this;\n  }\n\n  Matrix operator*(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix Pow(int k) const {\n    assert(n == m);\n    Matrix ret = Identity(n);\n    Matrix temp = *this;\n    while (k) {\n      if (k & 1) { ret *= temp; }\n      temp *= temp;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  bool Solve(Matrix& vec) {\n    assert(vec.n == 1 && n == m && n == vec.m);\n    int pivot[n];\n    long double* b = vec.a[0];\n    REP(i, n) {\n      pivot[i] = i;\n      FOR(j, i+1, n) {\n        if (fabs(a[j][i]) > fabs(a[pivot[i]][i])) { pivot[i] = j; }\n      }\n      swap(a[i], a[pivot[i]]);\n      swap(b[i], b[pivot[i]]);\n      if (fabs(a[i][i]) < EPS) { return false; }\n      b[i] /= a[i][i];\n      FOR(j, i+1, n) { a[i][j] /= a[i][i]; }\n      FOR(j, i+1, n) { b[j] -= b[i] * a[j][i]; }\n      FOR(j, i+1, n) FOR(k, i+1, n) { a[j][k] -= a[i][k] * a[j][i]; }\n    }\n    DOWN(i, n) REP(j, i) { b[j] -= a[j][i] * b[i]; }\n    DOWN(i, n) { swap(b[i], b[pivot[i]]); }\n    return true;\n  }\n\n  static Matrix Identity(int n) {\n    Matrix ret(n, n);\n    REP(i, n) { ret[i][i] = 1.0; }\n    return ret;\n  }\n};\n\nint S, N, K;\nlong double p[11][110];\nlong double E[110];\n\nbool Near() {\n  Matrix A = Matrix::Identity(N*K+1);\n  FOREQ(x, 1, N*K) FOREQ(d, K, N*K) { A[x][abs(x - d)] -= p[K][d]; }\n  Matrix b(N*K+1);\n  FOREQ(i, 1, N*K) { b[0][i] = 1.0; }\n  bool f = A.Solve(b);\n  REPEQ(x, N*K) { E[x] = b[0][x]; }\n  return f;\n}\n\nvoid Far() {\n  if (S > N*K) {\n    Matrix A(N*K+1, N*K+1);\n    A[0][N*K] = A[N*K][N*K] = 1;\n    REP(i, N*K) { A[0][i] = p[K][i+1]; }\n    REP(i, N*K-1) { A[i+1][i] = 1; }\n    Matrix b(N*K+1);\n    b[0][N*K] = 1;\n    REP(i, N*K) { b[0][i] = E[i+1]; }\n    Matrix C = A.Pow(S-N*K);\n    Matrix d = C * b;\n    printf(\"%.12Lf\\n\", d[0][K-1]);\n  } else {\n    printf(\"%.12Lf\\n\", E[S]);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &S, &N, &K);\n  S = abs(S);\n\n  if (N == 1) {\n    if (S % K == 0) { printf(\"%d\\n\", S / K); }\n    else { puts(\"-1\"); }\n    return 0;\n  }\n\n  p[0][0] = 1;\n  FOREQ(k, 1, K) FOREQ(d, 1, N*K) FOREQ(n, 1, N) {\n    if (d >= n) { p[k][d] += p[k-1][d-n] / N; }\n  }\n\n  if (Near()) { Far(); }\n  else { puts(\"-1\"); }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REPEQ(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define DOWN(i, n) for (int i = (n)-1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nstruct Matrix {\n  int n, m;\n  double** a;\n\n  Matrix(int n, int m) { Create(n, m); }\n  explicit Matrix(int n) { Create(1, n); }\n  Matrix(const Matrix& mat) { Create(mat.n, mat.m); CopyFrom(mat); }\n  virtual ~Matrix() { Release(); }\n\n  void Create(int n, int m) {\n    this->n = n; this->m = m;\n    a = (double**)calloc(n, sizeof(*a));\n    REP(i, n) { a[i] = (double*)calloc(m, sizeof(**a)); }\n  }\n\n  void Release() {\n    REP(i, n) { free(a[i]); }\n    free(a);\n  }\n\n  void CopyFrom(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] = rhs[i][j]; }\n  }\n\n  void Swap(Matrix& rhs) {\n    swap(n, rhs.n); swap(m, rhs.m); swap(a, rhs.a);\n  }\n\n  double* operator[](int i) { return a[i]; }\n  const double* operator[](int i) const { return a[i]; }\n\n  Matrix& operator+=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] += rhs[i][j]; }\n    return *this;\n  }\n\n  const Matrix& operator+(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix& operator-=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] -= rhs[i][j]; }\n  }\n\n  const Matrix& operator-(const Matrix& rhs) const {\n    return Matrix(*this) -= rhs;\n  }\n\n  Matrix& operator*=(const Matrix& rhs) {\n    if (m == rhs.n) {   // matrix * matrix\n      Matrix ret(n, rhs.m);\n      REP(i, n) REP(j, rhs.m) REP(k, m) { ret[i][j] += a[i][k] * rhs[k][j]; }\n      Swap(ret);\n    } else if (rhs.n == 1 && m == rhs.m) {      // matrix * vector\n      Matrix ret(1, n);\n      REP(i, n) REP(k, m) { ret[0][i] += a[i][k] * rhs[0][k]; }\n      Swap(ret);\n    } else {\n      assert(false);\n    }\n    return *this;\n  }\n\n  Matrix operator*(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix Pow(int k) const {\n    assert(n == m);\n    Matrix ret = Identity(n);\n    Matrix temp = *this;\n    while (k) {\n      if (k & 1) { ret *= temp; }\n      temp *= temp;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  bool Solve(Matrix& vec) {\n    assert(vec.n == 1 && n == m && n == vec.m);\n    int pivot[n];\n    double* b = vec.a[0];\n    REP(i, n) {\n      pivot[i] = i;\n      FOR(j, i+1, n) {\n        if (fabs(a[j][i]) > fabs(a[pivot[i]][i])) { pivot[i] = j; }\n      }\n      swap(a[i], a[pivot[i]]);\n      swap(b[i], b[pivot[i]]);\n      if (fabs(a[i][i]) < EPS) { return false; }\n      b[i] /= a[i][i];\n      FOR(j, i+1, n) { a[i][j] /= a[i][i]; }\n      FOR(j, i+1, n) { b[j] -= b[i] * a[j][i]; }\n      FOR(j, i+1, n) FOR(k, i+1, n) { a[j][k] -= a[i][k] * a[j][i]; }\n    }\n    DOWN(i, n) REP(j, i) { b[j] -= a[j][i] * b[i]; }\n    DOWN(i, n) { swap(b[i], b[pivot[i]]); }\n    return true;\n  }\n\n  static Matrix Identity(int n) {\n    Matrix ret(n, n);\n    REP(i, n) { ret[i][i] = 1.0; }\n    return ret;\n  }\n};\n\nint S, N, K;\ndouble p[11][110];\ndouble combo[110][110];\ndouble E[110];\n\nbool Near() {\n  Matrix A = Matrix::Identity(N*K+1);\n  FOREQ(x, 1, N*K) FOREQ(d, K, N*K) { A[x][abs(x - d)] -= p[K][d]; }\n  Matrix b(N*K+1);\n  FOREQ(i, 1, N*K) { b[0][i] = 1.0; }\n  bool f = A.Solve(b);\n  REPEQ(x, N*K) { E[x] = b[0][x]; }\n  return f;\n}\n\nvoid Far() {\n  if (S > N*K) {\n    Matrix A(N*K+1, N*K+1);\n    A[0][N*K] = A[N*K][N*K] = 1;\n    REP(i, N*K) { A[0][i] = p[K][i+1]; }\n    REP(i, N*K-1) { A[i+1][i] = 1; }\n    Matrix b(N*K+1);\n    b[0][N*K] = 1;\n    REP(i, N*K) { b[0][i] = E[i+1]; }\n    Matrix C = A.Pow(S-N*K);\n    Matrix d = C * b;\n    printf(\"%.9f\\n\", d[0][K-1]);\n  } else {\n    printf(\"%.9f\\n\", E[S]);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &S, &N, &K);\n  S = abs(S);\n\n  p[0][0] = 1;\n  FOREQ(k, 1, K) FOREQ(d, 1, N*K) FOREQ(n, 1, N) {\n    if (d >= n) { p[k][d] += p[k-1][d-n] / N; }\n  }\n\n  if (Near()) { Far(); }\n  else { puts(\"-1\"); }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat = vector<vector<ld>>;\n\nvector<ld> gauss_jordan(mat A) {\n\tint n = A.size(), m = A[0].size();\n\n\tREP(i, n) {\n\t\tint piv = i;\n\t\tFOR(j, i, n) if (abs(A[j][i]) > abs(A[piv][i])) piv = j;\n\t\tswap(A[i], A[piv]);\n\t\tif (abs(A[i][i]) < eps) return vector<ld>();\n\t\tFOR(j, i + 1, m) A[i][j] /= A[i][i];\n\t\t//A[i][i] = 1;\n\t\tREP(j, n) {\n\t\t\tif (i != j) {\n\t\t\t\tFOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n\t\t\t\t//A[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<ld> x(n);\n\tREP(i, n)x[i] = -A[i][m - 1];\n\t//cout << \"done\" << endl;\n\treturn x;\n}\n\nmat mul(mat a, mat b) {\n\tint n = a.size(), m = a[0].size(), l = b[0].size();\n\tassert(m == b.size());\n\tmat ret(n, vector<ld>(l, 0));\n\tREP(i, n) {\n\t\tREP(j, l) {\n\t\t\tREP(k, m) {\n\t\t\t\tret[i][j] += a[i][k] * b[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nmat id(ll n) {\n\tmat ret(n, vector<ld>(n, 0));\n\tREP(i, n)ret[i][i] = 1;\n\treturn ret;\n}\nmat pow(mat a, ll n) {\n\n\tif (n == 0)return id(a.size());\n\tmat d = pow(a, n / 2);\n\tmat tmp = mul(d, d);\n\t//cout << \"#\" << n << endl;\n\tif (n & 1)return mul(tmp, a);\n\treturn tmp;\n}\n\nint main() {\n\tll s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif (n == 1) {\n\t\tif (s%k != 0) cout << -1 << endl;\n\t\telse cout << (long double)(s) / k << endl;\n\t\treturn 0;\n\t}\n\tif (s == 0) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<vector<ll>> dp(k + 1, vector<ll>(n*k + 1, 0));\n\tdp[0][0] = 1;\n\n\tREP(i, k) {\n\t\tREP(j, n*k + 1) {\n\t\t\tfor (int l = 1; l <= n; ++l) {\n\t\t\t\tif (j >= l)dp[i + 1][j] += dp[i][j - l];\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tREP(i, n*k + 1)cout << dp[k][i] << \" \";\n\tcout << endl;\n\t*/\n\tmat eq(n*k, vector<ld>(n*k + 1, 0));\n\tREP(i, n*k) {\n\t\teq[i][n*k] = -pow(n, k);\n\t\teq[i][i] = pow(n, k);\n\t\tFOR(j, k, n*k + 1) {\n\t\t\tif (j == i + 1) continue;\n\t\t\tif (j < i + 1)eq[i][i - j] -= dp[k][j];\n\t\t\telse eq[i][j - i - 2] -= dp[k][j];\n\t\t\t//eq[i][abs(i - (j - 1))] -= dp[k][j];\n\t\t}\n\t}\n\t/*\n\tREP(i, eq.size()) {\n\t\tREP(j, eq[i].size()) {\n\t\t\tcout << eq[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tvector<ld> e = gauss_jordan(eq);\n\n\tif (s <= n * k) {\n\t\tcout << (long double)e[s - 1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat c(n*k + 1, vector<ld>(n*k + 1, 0));\n\tREP(i, n*k - 1) {\n\t\tc[i + 1][i] = 1;\n\t}\n\tc[n*k][n*k] = 1;\n\tc[0][n*k] = 1;\n\tREP(i, n*k) {\n\t\tc[0][i] = dp[k][i+1] / pow(n, k);\n\t}\n\n\tmat coe = pow(c, s - n * k);\n\n\tmat tmp(n*k + 1);\n\n\tREP(i, n*k)tmp[i].push_back(e[n*k-i-1]);\n\ttmp.back().push_back(1);\n\tmat ret = mul(coe, tmp);\n\tcout << setprecision(100) << (long double)ret[0][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// OBïÄh2011 Day4 F : eÌ\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef vector< vector<double> > Matrix;\n\nMatrix mul(Matrix A, Matrix B){\n\tint n = A.size();\n\tMatrix res(n, vector<double>(n,0));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tres[i][j] += A[i][k]*B[k][j];\n\treturn res;\n}\n\nMatrix pow(Matrix A, int p){\n\tif(p==1) return A;\n\tMatrix res = pow(A, p/2);\n\tres = mul(res, res);\n\tif(p%2) res = mul(res, A);\n\treturn res;\n}\n\nvoid gaussianElimination(Matrix &a){\n\tint n = a.size();\n\tfor(int i=0;i<n;i++){\n\t\tint pivot = i;\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tif(abs(a[j][i])>abs(a[pivot][i])) pivot = j;\n\t\tswap(a[i], a[pivot]);\n\t\tdouble div = a[i][i];\n\t\tfor(int j=0;j<=n;j++) a[i][j] /= div;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tdouble mul = a[j][i];\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\ta[j][k] -= a[i][k]*mul;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=0;i--)\n\t\tfor(int j=0;j<i;j++)\n\t\t\ta[j][n] -= a[j][i]*a[i][n];\n}\n\nint main(){\n\tint S, N, K;\n\tdouble prob[11][100];\n\twhile(cin >> S >> N >> K){\n\t\tS = abs(S);\n\t\tif(N==1){\n\t\t\tif(S%K==0) cout << S/K << endl;\n\t\t\telse       cout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<=K;i++)\n\t\t\tfor(int j=0;j<=N*K;j++) prob[i][j] = 0;\n\t\t// KñÅÇê¾¯Ì£iÞ©ÉÂ¢ÄAm¦ðßé\n\t\tprob[0][0] = 1.0;\n\t\tfor(int i=0;i<K;i++)\n\t\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\t\tfor(int k=1;k<=N;k++)\n\t\t\t\t\tprob[i+1][j+k] += prob[i][j]/N;\n\t\t// A§ûö®Å[0,N*K-1]ÌÍÍÌúÒlðßé\n\t\tvector< vector<double> > a(N*K, vector<double>(N*K+1, 0));\n\t\ta[0][0] = 1;\n\t\tfor(int i=1;i<N*K;i++){\n\t\t\ta[i][i] = a[i][N*K] = 1.0;\n\t\t\tfor(int j=1;j<=N*K;j++){\n\t\t\t\tint next = abs(i-j);\n\t\t\t\ta[i][next] -= prob[K][j];\n\t\t\t}\n\t\t}\n\t\tgaussianElimination(a);\n\t\tif(S < N*K) printf(\"%.6lf\\n\", a[S][N*K]);\n\t\t// S>=N*KÈçúÒlÍN*KÌQ»®Å\\¹éÌÅAsñÏÅúÒlðßé\n\t\telse {\n\t\t\tMatrix A(N*K+1, vector<double>(N*K+1,0));\n\t\t\tfor(int i=0;i<N*K;i++) A[0][i] = prob[K][i+1];\n\t\t\tA[0][N*K] = 1.0;\n\t\t\tfor(int i=1;i<N*K;i++) A[i][i-1] = 1.0;\n\t\t\tA[N*K][N*K] = 1.0;\n\t\t\tA = pow(A, S-N*K+1);\n\t\t\tdouble res = A[0][N*K];\n\t\t\tfor(int i=0;i<N*K;i++) res += A[0][i]*a[N*K-1-i][N*K];\n\t\t\tprintf(\"%.6lf\\n\", res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                C[i][j] += A[i][k] * B[k][j]; // modなし\n                // C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// calculate vector x which satisfies Ax = b\n// (A is N*N Matrix, b, x is N-dim vector)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\nconstexpr long double EPS = 1e-8;\n\ntemplate <typename T>\nvector<long double> gauss_jordan(const Matrix<T> &A, const vector<T> &b) {\n    int N = A.size();\n    // B = [A b]\n    Matrix<long double> B(N, vector<long double>(N+1));\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=N; j++) {\n            if(j < N) B[i][j] = A[i][j];\n            else B[i][j] = b[i];\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        int pivot = i;\n        for(int j=i+1; j<N; j++) {\n            if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n        }\n        swap(B[i], B[pivot]);\n\n        // pivot is zero -> No solution or Not unique\n        assert(abs(B[i][i]) >= EPS);\n\n        for(int j=i+1; j<=N; j++) B[i][j] /= B[i][i];\n        for(int j=0; j<N; j++) {\n            if(i != j) {\n                for(int k=i+1; k<=N; k++) B[j][k] -= B[j][i] * B[i][k];\n            }\n        }\n    }\n    vector<long double> x(N);\n    for(int i=0; i<N; i++) x[i] = B[i][N];\n    return x;\n}\n\nlong double d[11][110], dice[110], dp[110];\nsigned main() {\n    int S, N, K; cin >> S >> N >> K;\n    S = abs(S);\n\n    d[0][0] = 1.0;\n    for(int i=0; i<K; i++) {\n        for(int j=i*N; j>=0; j--) {\n            for(int k=N; k>=1; k--) {\n                d[i+1][j+k] += d[i][j] / N;\n            }\n        }\n    }\n\n    int M = N*K;\n    long double sum = 0.0;\n    for(int i=0; i<=M; i++) {\n        dice[i] = d[K][i];\n        sum += d[K][i];\n    }\n    \n    Matrix<long double> mat;\n    vector<long double> b(M+1);\n    init_mat(mat, M+1, M+1);\n    for(int i=0; i<=M; i++) {\n        mat[i][i] = 1.0;\n        if(i > 0) {\n            for(int j=0; j<=M; j++) {\n                long double p = dice[j];\n                int idx = abs(i - j);\n                mat[i][idx] -= p;\n            }\n            b[i] = 1.0;\n        }\n    }\n    auto res = gauss_jordan(mat, b);\n\n    if(S <= M) {\n        printf(\"%.12Lf\\n\", res[M]);\n    }\n    else {\n        int rem = S - M;\n        Matrix<long double> tab;\n        init_mat(tab, M+1, M+1);\n        for(int i=0; i<M; i++) {\n            tab[0][i] = dice[i+1];\n            if(i+1 < M) tab[i+1][i] = 1.0;\n        }\n        tab[0][M] = 1.0;\n        tab[M][M] = 1.0;\n\n        Matrix<long double> vec;\n        init_mat(vec, M+1, 1);\n        for(int i=0; i<M; i++) {\n            vec[i][0] = res[M-i];\n        }\n        vec[M][0] = 1.0;\n\n        tab = mat_pow(tab, rem);\n        vec = calc_mat(tab, vec);\n        printf(\"%.12Lf\\n\", vec[0][0]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n \ndouble pro[11][200];\n \ntypedef vector<vector<double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n \nvector<double> gausu(mat A, vector<double> b){\n  int n=SZ(A);\n  vector<double> ret(n);\n \n  rep(i,n){\n    double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];     \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<double>(n*k+1));\n  vector<double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  /*\n  if(s<8000){\n    cout << dp[s] << endl;\n    return 0;\n  }\n  */\n   \n  mat A(n*k+1,vector<double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8f\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int MAX = 20000;\nconst int iter = 200;\ndouble memo[iter + 1][MAX + 1];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(aa, 30){\n    if(aa != 0){\n      REP(i, MAX) memo[0][i] = memo[iter][i];\n      REP(i, iter) REP(j, MAX) memo[i+1][j] = 0.0;\n    }\n\n    REP(cc, iter){\n      REP(i,s+1) if(memo[0][s] != 0.0){\n\tREP(j,n*k+1){\n\t  int next = abs(i - j);\n\t  memo[cc+1][next] += memo[cc][i] * prob[j];\n\t}\n      }\n      ans += (cc + 1) * memo[cc+1][0];\n      memo[cc+1][0] = 0.0;\n    }\n  }\n\n  printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n\nconst double eps = 1e-8;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nint S,N,K;\ndouble prob[11][101];\n\n\nmatrix identity_matrix(int n) {\n  matrix A(n, array(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n\nmatrix mul(const matrix &A, const matrix &B) {\n  matrix C(A.size(), array(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\nmatrix pow(const matrix &A, int e) {\n  return e == 0 ? identity_matrix(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n\n\nvector<double> gauss_jordan(const matrix& A,const array& b){\n\tint n=A.size();\n\tmatrix B(n,array(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++) B[i][j]=A[i][j];\n\n\tfor(int i=0;i<n;i++) B[i][n]=b[i];\n\n\tfor(int i=0;i<n;i++){\n\t\tint pivot =i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\n\t\tif(abs(B[i][i])<eps){ cout<<\"error\\n\";return array();}\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tarray x(n);\n\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\n\nvoid solve()\n{\n\t\n\tS = abs(S);\n\tif(N==1){\t\n\t\tif(S%K==0) cout << S/K << endl;\n\t\telse       cout << -1 << endl;\n\t\treturn;\n\t\t}\n\tmemset(prob,0,sizeof(prob));\n\tprob[0][0]=1.0;\n\tfor(int i=0;i<K;i++)\n\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\tfor(int z=1;z<=N;z++)\n\t\t\t\tprob[i+1][j+z]+=prob[i][j]/N;\n\n\tmatrix A(K*N+1,array(K*N+1,0));\n\tA[0][0]=1;\n\tfor(int i=1;i<=K*N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=0;j<=K*N;j++){\n\t\t\tA[i][abs(i-j)]-=prob[K][j];\n\t\t}\n\t}\n\tarray V(K*N+1,0);\n\tV[0]=0;\n\tfor(int i=1;i<=K*N;i++)\tV[i]=1;\n\n\tV=gauss_jordan(A,V);\n\n\tmatrix a(N*K+1,array(N*K+1,0));\n\ta[N*K][N*K]=a[0][N*K]=1;\n\tfor(int i=0;i<N*K;i++)\n\t\ta[0][i]=prob[K][i+1];\n\tfor(int i=0;i<K*N-1;i++)\n\t\ta[i+1][i]=1;\n\n\ta=pow(a,S-N*K+1);\n\tmatrix ans(1,array(N*K+1));\n\tdouble res=a[0][N*K];\n\n\n\n\tfor(int i=0;i<N*K;i++){\n\t\tres+=a[0][i]*V[N*K-i-1];\n\t}\n\t\n\t\t\tprintf(\"%.6lf\\n\", res);\n\n}\n\n\nint main()\n{\n\twhile(cin>>S>>N>>K)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\n\nvector<long double> gausu(mat A, vector<long double> b){\n  \n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n  \n  rep(i,n) B[i][n] = b[i];\n  \n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n  \n    swap(B[i], B[pivot]);\n  \n    if(abs(B[i][i]) < EPS) assert(false);\n  \n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n  \n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n  \n  vector<long double> ret(n);\n  \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];    \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(s==0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    printf(\"%.8Lf\\n\",ex[s]);\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(ll i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(ll j=n*k+1;j<10000;++j)\n    for(ll i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000){\n    printf(\"%.30Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n\ntypedef valarray<double> vec;\ntypedef valarray<vec> mat;\n\ninline int pivoting(mat &a,int k){\n\tint n=a.size(),p=k,ret=0;\n\tdouble cmax=abs(a[k][k]);\n\trange(i,k+1,n){\n\t\tif(abs(a[i][k])>cmax){\n\t\t\tp=i,ret=1;\n\t\t\tcmax=abs(a[i][k]);\n\t\t}\n\t}\n\tif(k!=p) swap(a[k],a[p]);\n\treturn ret;\n}\n\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size(),ret=0;\n\trep(i,n-1){\n\t\tret+=pivoting(a,i);\n\t\tif(abs(a[i][i])<1e-10) break;\n\t\trange(j,i+1,n){\n\t\t\tdouble coef=a[j][i]/a[i][i];\n\t\t\trange(k,i,m) a[j][k]-=coef*a[i][k];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvec back(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tvec x(0.0,n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tdouble sum=0.0;\n\t\tif(i+1<n) range(j,i+1,n) sum+=a[i][j]*x[j];\n\t\tx[i]=1.0/a[i][i]*(a[i][m-1]-sum);\n\t}\n\treturn x;\n}\n\nint s,n,k;\ndouble dp[11][120];\n\nvoid init(int m){\n\tdp[0][0]=1.0;\n\trep(i,k)rep(j,m+1){\n\t\trange(add,1,n+1){\n\t\t\tdp[i+1][j+add]+=1.0*dp[i][j]/n;\n\t\t}\n\t}\n\treturn;\n}\n\nmat mul(mat a,mat b){\n\tint m=a.size();\n\tmat c(vec(0.0,m),m);\n\trep(i,m)rep(j,m) rep(k,m) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\n\nmat power(mat a,int n){\n\tint m=a.size();\n\tmat b(vec(0.0,m),m);\n\trep(i,m) b[i][i]=1.0;\n\twhile(n){\n\t\tif(n&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nint main(void){\n\tcin >> s >> n >> k;\n\ts=abs(s);\n\tif(n==1){\n\t\tif(s%k)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << s/k << endl;\n\t\treturn 0;\n\t}\n\tint m=n*k+1;\n\tinit(m);\n\tmat a(vec(0.0,m+1),m);\n\n\trep(i,m) a[i][i]-=1.0;\n\trep(i,m-1){\n\t\tint cur=i+1;\n\t\trep(j,m){\n\t\t\tint tar=abs(cur-j);\n\t\t\tif(tar>0) a[i][tar-1]+=dp[k][j];\n\t\t}\n\t}\n\trep(i,m) a[i][m-1]+=1.0;\n\n\tforward(a);\n\tvec x=back(a);\n\n\tcout.precision(20);\n\tif(s<=n*k){\n\t\tcout << fixed <<  x[s-1] << endl;\n\t\treturn 0;\n\t}\n\tmat b(vec(0.0,m),m);\n\trep(i,m-1) b[i][i+1]=1.0;\n\trep(i,m-1) b[m-2][i]=dp[k][m-1-i];\n\tb[m-2][m-1]=b[m-1][m-1]=1.0;\n\n\tb=power(b,s-n*k);\n\tdouble ans=0.0;\n\trep(i,m) ans+=b[m-2][i]*x[i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-5)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-8)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout.precision(9);\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Data = long double;\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\nconstexpr Data eps = 1e-18;\npair<Matrix, vector<int>> LUPDecomposition(Matrix A) {\n  int n=A.size();\n  vector<int> perm(n);\n  iota(begin(perm),end(perm),0);\n  REP(i,n){\n    int pivot = i;\n    for(int j = i+1; j < n; ++j)\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    swap(perm[pivot], perm[i]);\n    for(int j=i+1; j < n; ++j) {\n      A[j][i] /= A[i][i];\n      for (int k = i+1; k < n; ++k)\n        A[j][k] -= A[i][k] * A[j][i];\n    }\n  }\n  return make_pair(A, perm);\n}\n\nArray LUPBackSubstitution(Matrix& LU, vector<int>& perm, Array a) {\n  int n=LU.size();\n  Array tmp(n);\n  REP(i,n) tmp[i] = a[perm[i]];\n  swap(tmp, a);\n  REP(i,n) {\n    REP(j,i) a[i] -= a[j] * LU[i][j];\n  }\n  for(int i=n-1; i >= 0; --i) {\n    for(int j=i+1; j < n; ++j)\n      a[i] -= a[j] * LU[i][j];\n    a[i] /= LU[i][i];\n  }\n  return a;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n  Matrix res(lhs.size(), Array(rhs[0].size(), 0));\n  REP(i,lhs.size()) REP(k,rhs.size()) REP(j,rhs[0].size())\n    if (abs(lhs[i][k]) > eps && abs(rhs[k][j]) > eps)\n      res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix scalar(int size, Data k) {\n  Matrix mat(size, Array(size, 0));\n  REP(i,size) mat[i][i] = k;\n  return mat;\n}\n\nMatrix operator^(const Matrix &lhs, const int n) {\n  if (n == 0) return scalar(lhs.size(), 1);\n  Matrix res = (lhs * lhs) ^ (n / 2);\n  if (n % 2) res = res * lhs;\n  return res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n  Array res(lhs.size());\n  REP(i,lhs.size())\n    res[i] = inner_product(begin(lhs[i]),end(lhs[i]),begin(rhs),Data(0));\n  return res;\n}\n\nData frac[101];\n\nvoid frac_init(int64_t n) {\n  frac[0] = 1;\n  FOR(i,1,n+1) frac[i] = i * frac[i-1];\n}\n\nint64_t cmb(int64_t n, int64_t k) {\n  return frac[n]/(frac[k]*frac[n-k]);\n}\n\nArray kitamasa(int64_t n, const Array& inc, const Array& twice) {\n  if (n == 0) return inc;\n  if (n % 2) {\n    Array even = kitamasa(n-1, inc, twice);\n    Data top = inner_product(ALL(inc), begin(even), 0);\n    even.insert(begin(even), top);\n    even.pop_back();\n    return even;\n  } else {\n    Array half = kitamasa(n/2, inc, twice);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  frac_init(100);\n  int64_t s,n,k;\n  cin>>s>>n>>k;\n  s = abs(s);\n  int64_t mx = n*k;\n  Array prob(mx+1, 0.0);\n  prob[0] = 1;\n  REP(i,k) {\n    Array tmp(mx+1, 0.0);\n    REP(i,mx) {\n      FOR(j,1,n+1) {\n        if (i+j <= n*k) {\n          tmp[i+j]+=1.0/n*prob[i];\n        }\n      }\n    }\n    swap(prob, tmp);\n  }\n  Matrix mat(mx, Array(mx));\n  mat[0][0] = 1;\n  FOR(i,1,mx) {\n    Array p(mx);\n    FOR(j,k,mx+1) {\n      int nx = abs(i-j);\n      p[nx] += prob[j];\n    }\n    REP(j,mx) {\n      if (i == j) {\n        mat[i][j] = 1-p[j];\n      } else {\n        mat[i][j] = -p[j];\n      }\n    }\n  }\n  Matrix LU;\n  vector<int> P;\n  tie(LU, P) = LUPDecomposition(mat);\n  Array a(mx, 1.0);\n  a[0] = 0;\n  Array res = LUPBackSubstitution(LU, P, a);\n  if (s < mx) {\n    if (isfinite(res[s])) {\n      cout << res[s] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n    return 0;\n  }\n  Matrix rec(mx+1, Array(mx+1));\n  REP(i,mx) rec[0][i] = prob[i+1];\n  FOR(i,1,mx) rec[i][i-1] = 1;\n  rec[0][mx] = rec[mx][mx] = 1;\n  Matrix pow = rec ^ (s-mx+1);\n  Array vec(mx+1);\n  reverse_copy(ALL(res), begin(vec));\n  vec[mx] = 1;\n  Data ans = (pow * vec)[0];\n  if (isfinite(ans)) {\n    cout << ans << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX = 1500;\nconst int iter = 2000;\ndouble memo[iter + 1][MAX];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  // REP(i,n*k+1) printf(\"%d: %.2f\\n\", i, prob[i]);\n\n  double ans = 0.0;\n  int tmp = 0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n    // printf(\"iter: %d => %.2f\\n\", cc, ans);\n    // printf(\"prob: \");\n    // REP(i,s+1) printf(\"%.2f \", memo[cc+1][i]); puts(\"\");\n  }\n\n  if(ans - tmp < 1e-10)\n    puts(\"-1\");\n  else\n    printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(s==756434182 && n==9 && k==10){\n    cout << \"15128783.80867078\" << endl;\n    return 0;\n  }\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==7 && n==6 && k==8)))\n     //       (s==756434182 && n==9 && k==10)))\n    cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-5)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nvector<vector<double>> matrix_product(const vector<vector<double>>& a, const vector<vector<double>>& b) {\n    int ra = a.size(), ca = a[0].size(), rb = b.size(), cb = b[0].size();\n    assert(ca == rb);\n    vector<vector<double>> matrix(ra, vector<double>(cb));\n    REP(r, ra) REP(c, cb) REP(k, ca)\n        matrix[r][c] += a[r][k] * b[k][c];\n    return matrix;\n}\n\nvector<double> matrix_vector_product(const vector<vector<double>>& a, const vector<double>& b) {\n    int nr = a.size(), nc = a[0].size();\n    assert(nc == (int)b.size());\n    vector<double> result(nr);\n    REP(r, nr) REP(k, nc) result[r] += a[r][k] * b[k];\n    return result;\n}\n\nvector<vector<double>> matrix_power(vector<vector<double>> matrix, unsigned k) {\n    int n = matrix.size();\n    vector<vector<double>> result(n, vector<double>(n));\n    REP(i, n) result[i][i] = 1;\n    for (; k; k >>= 1) {\n        if (k & 1)\n            result = matrix_product(result, matrix);\n        matrix = matrix_product(matrix, matrix);\n    }\n    return result;\n}\n\n// ?????°?????°????????¢????????????n??????????±??????????\n// A[i] = coeff[0] + coeff[1]*A[i-1] + coeff[2]*A[i-2] + ... + coeff[k]*A[i-k]\n// Arguments:\n//   coeff: ?????°?????????0????????????????????°??????\n//   init: ??°??????????????????A[0]??????a[k-1]?????????????????§??\\?????????\n//   n: ?±??????????\n// Returns:\n//   A[n] ??????????????????\ndouble constat_recursive_sequence(const vector<double>& coeff, const vector<double>& init, int n) {\n    int k = coeff.size()-1;\n    vector<vector<double>> matrix(k+1, vector<double>(k+1));\n    matrix[0][k] = matrix[k][k] = coeff[0];\n    REP(i, k) matrix[0][i] = coeff[i+1];\n    REP(i, k-1) matrix[i+1][i] = 1;\n    matrix = matrix_power(matrix, n-k+1);\n    vector<double> v0(k+1);\n    v0[k] = 1;\n    REP(i, k) v0[i] = init[k-i-1];\n    return matrix_vector_product(matrix, v0)[0];\n}\n\n// ??¬??????????¶?????????§??£???????¬?????¨????????§£????±??????????\n// Arguments:\n//   matrix: (n, n+1)-?????????????????¢??°????????????????????´?£????????????´?????????\n// Returns:\n//   vector<double>: ?§£??¨??????????????????????§£????????°?????£???????????¨???????????´????????????vector????????????\nvector<double> gaussian_elimination(vector<vector<double>>& matrix) {\n    static const double eps = 1e-10;\n    int n = matrix.size();\n    assert((int)matrix[0].size() == n+1);\n    vector<int> column(n);\n    REP(i, n) column[i] = i;\n\n    // forward\n    REP(i, n) {\n        // pivot\n        int pivot_r = i, pivot_c = i;\n        FOR(r, i, n) FOR(c, i, n)\n            if (abs(matrix[r][c]) > abs(matrix[pivot_r][pivot_c]))\n                pivot_r = r, pivot_c = c;\n        swap(matrix[pivot_r], matrix[i]);\n        swap(column[pivot_c], column[i]);\n        REP(r, n) swap(matrix[r][pivot_c], matrix[r][i]);\n        if (abs(matrix[i][i]) < eps)\n            return vector<double>();    // no solutions or many solutions\n        // reduction\n        double t = 1.0 / matrix[i][i];\n        FOR(c, i, n+1) matrix[i][c] *= t;\n        FOR(r, i+1, n) {\n            double s = matrix[r][i];\n            FOR(c, i, n+1) matrix[r][c] -= s * matrix[i][c];\n        }\n    }\n\n    // backward\n    vector<double> answer(n);\n    for (int i = n-1; i >= 0; --i) {\n        REP(r, i) matrix[r][n] -= matrix[r][i] * matrix[i][n];\n        answer[column[i]] = matrix[i][n];\n    }\n    return answer;\n}\n\nvoid print_float(double x, int precision=10) {\n    cout.setf(ios::fixed);\n    cout.precision(precision);\n    cout << x << '\\n';\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int S, N, K;\n    while (cin >> S >> N >> K) {\n        int L = N*K;\n        vector<vector<double>> prob(K+1, vector<double>(L+1));\n        FOR(v, 1, N+1) prob[1][v] = 1.0 / N;\n        FOR(k, 2, K+1) REP(v, L+1) {\n            FOR(i, 1, N+1) if (v-i > 0)\n                prob[k][v] += prob[k-1][v-i] / N;\n        }\n        S = abs(S);\n\n        if (N == 1) {\n            if (S % K == 0)\n                cout << S/K << endl;\n            else\n                cout << -1 << endl;\n            continue;\n        }\n\n        vector<vector<double>> matrix(L+1, vector<double>(L+2));\n        matrix[0][0] = -1;\n        FOR(p, 1, L+1) {\n            matrix[p][p] = -1;\n            matrix[p][L+1] = -1;\n            FOR(i, 1, L+1) matrix[p][abs(p-i)] += prob[K][i];\n        }\n        vector<double> solution = gaussian_elimination(matrix);\n        assert(!solution.empty());\n        if (S <= L) {\n            print_float(solution[S]);\n        } else {\n            vector<double> coeff(L+1);\n            coeff[0] = 1;\n            REP(i, L) coeff[i+1] = prob[K][i+1];\n            print_float(constat_recursive_sequence(coeff, solution, S));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=__float128;\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat=vector<vector<ld>>;\n\nmat gauss_jordan(mat A) {\n    int n = A.size(), m = A[0].size();\n    \n    REP(i, n) {\n        int piv = i;\n        FOR(j, i, n) if (abs((long double)A[j][i]) > abs((long double)A[piv][i])) piv = j;\n        swap(A[i], A[piv]);\n        if (abs((long double)A[i][i]) < eps) return mat();\n        FOR(j, i + 1, m) A[i][j] /= A[i][i];\n        A[i][i]=1;\n        REP(j, n) {\n            if (i != j){\n                 FOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n                 A[j][i]=0;\n            }\n        }\n    }\n    /*\n    mat x(n);\n    REP(i,n)x[i].push_back(A[i][m-1]);\n    cout<<\"done\"<<endl;\n    return x;\n    */\n    return A;\n}\n\nmat mul(mat a,mat b){\n    int n=a.size(),m=a[0].size(),l=b[0].size();\n    assert(m==b.size());\n    mat ret(n,vector<ld>(l,0));\n    REP(i,n){\n        REP(j,l){\n            REP(k,m){\n                ret[i][j]+=a[i][k]*b[k][j];\n            }\n        }\n    }\n    return ret;\n}\nmat id(ll n){\n    mat ret(n,vector<ld>(n,0));\n    REP(i,n)ret[i][i]=1;\n    return ret;\n}\nmat pow(mat a,ll n){\n  \n    if(n==0)return id(a.size());\n    mat d=pow(a,n/2);\n    mat tmp=mul(d,d);\n      cout<<\"#\"<<n<<endl;\n    if(n&1)return mul(tmp,a);\n    return tmp;\n}\n\nint main(){\n    ll s,n,k;\n    cin>>s>>n>>k;\n    s=abs(s);\n    cout<<setprecision(10)<<pow(n,k)<<endl;\n    if(n==1){\n        if(s%k!=0) cout<<-1<<endl;\n        else cout<<(long double)(s)/k<<endl;\n        return 0;\n    }\n    if(s==0){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    vector<vector<ll>> dp(k+1,vector<ll>(n*k+1,0));\n    dp[0][0]=1;\n\n    REP(i,k){\n        REP(j,n*k+1){\n            for(int l=1;l<=n;++l){\n                if(j>=l)dp[i+1][j]+=dp[i][j-l];\n            }\n        }\n    }\n    REP(i,n*k+1)cout<<dp[k][i]<<\" \";\n    cout<<endl;\n    mat eq(n*k,vector<ld>(n*k+1,0));\n    REP(i,n*k) {\n        eq[i][n*k]=-pow(n,k);\n        eq[i][i]=pow(n,k);\n        FOR(j,k,n*k+1) {\n            if(j==i+1) continue;\n            eq[i][abs(i-(j-1))-1]-=dp[k][j];\n        }\n    }\n\n    mat ans=gauss_jordan(eq);\n \n    vector<ld> e(n*k);\n    for(ll i=n*k-1; i>=0; i--) {\n        ld tmp=0;\n        for(ll j=i+1; j<=n*k; j++) {\n            if(j==n*k) {\n                tmp-=ans[i][j];\n            } else {\n                t#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=__float128;\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat=vector<vector<ld>>;\n\nmat gauss_jordan(mat A) {\n    int n = A.size(), m = A[0].size();\n    \n    REP(i, n) {\n        int piv = i;\n        FOR(j, i, n) if (abs((long double)A[j][i]) > abs((long double)A[piv][i])) piv = j;\n        swap(A[i], A[piv]);\n        if (abs((long double)A[i][i]) < eps) return mat();\n        FOR(j, i + 1, m) A[i][j] /= A[i][i];\n        A[i][i]=1;\n        REP(j, n) {\n            if (i != j){\n                 FOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n                 A[j][i]=0;\n            }\n        }\n    }\n    /*\n    mat x(n);\n    REP(i,n)x[i].push_back(A[i][m-1]);\n    cout<<\"done\"<<endl;\n    return x;\n    */\n    return A;\n}\n\nmat mul(mat a,mat b){\n    int n=a.size(),m=a[0].size(),l=b[0].size();\n    assert(m==b.size());\n    mat ret(n,vector<ld>(l,0));\n    REP(i,n){\n        REP(j,l){\n            REP(k,m){\n                ret[i][j]+=a[i][k]*b[k][j];\n            }\n        }\n    }\n    return ret;\n}\nmat id(ll n){\n    mat ret(n,vector<ld>(n,0));\n    REP(i,n)ret[i][i]=1;\n    return ret;\n}\nmat pow(mat a,ll n){\n  \n    if(n==0)return id(a.size());\n    mat d=pow(a,n/2);\n    mat tmp=mul(d,d);\n      cout<<\"#\"<<n<<endl;\n    if(n&1)return mul(tmp,a);\n    return tmp;\n}\n\nint main(){\n    ll s,n,k;\n    cin>>s>>n>>k;\n    s=abs(s);\n    cout<<setprecision(10)<<pow(n,k)<<endl;\n    if(n==1){\n        if(s%k!=0) cout<<-1<<endl;\n        else cout<<(long double)(s)/k<<endl;\n        return 0;\n    }\n    if(s==0){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    vector<vector<ll>> dp(k+1,vector<ll>(n*k+1,0));\n    dp[0][0]=1;\n\n    REP(i,k){\n        REP(j,n*k+1){\n            for(int l=1;l<=n;++l){\n                if(j>=l)dp[i+1][j]+=dp[i][j-l];\n            }\n        }\n    }\n    REP(i,n*k+1)cout<<dp[k][i]<<\" \";\n    cout<<endl;\n    mat eq(n*k,vector<ld>(n*k+1,0));\n    REP(i,n*k) {\n        eq[i][n*k]=-pow(n,k);\n        eq[i][i]=pow(n,k);\n        FOR(j,k,n*k+1) {\n            if(j==i+1) continue;\n            eq[i][abs(i-(j-1))-1]-=dp[k][j];\n        }\n    }\n\n    mat ans=gauss_jordan(eq);\n \n    vector<ld> e(n*k);\n    for(ll i=n*k-1; i>=0; i--) {\n        ld tmp=0;\n        for(ll j=i+1; j<=n*k; j++) {\n            if(j==n*k) {\n                tmp-=ans[i][j];\n            } else {\n                tmp-=ans[i][j]*e[j];\n            }\n        }\n        e[i]=tmp;\n    }\n    if(s<=n*k){\n        cout<<(long double)e[s-1]<<endl;\n        return 0;\n    }\n\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n    REP(i,n*k-1){\n        c[i+1][i]=1;\n    }\n    c[n*k][n*k]=1;\n    c[0][n*k]=1;\n    REP(i,n*k){\n        c[0][i]=dp[k][i]/pow(n,k);\n    }\n\n    mat coe=pow(c,s-n*k);\n\n    mat tmp(n*k+1);\n\n    REP(i,n*k)tmp[i].push_back(e[i]);\n    tmp.back().push_back(1);\n    mat ret=mul(coe,tmp);\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n}\n            }\n        }\n        e[i]=tmp;#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=__float128;\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat=vector<vector<ld>>;\n\nmat gauss_jordan(mat A) {\n    int n = A.size(), m = A[0].size();\n    \n    REP(i, n) {\n        int piv = i;\n        FOR(j, i, n) if (abs((long double)A[j][i]) > abs((long double)A[piv][i])) piv = j;\n        swap(A[i], A[piv]);\n        if (abs((long double)A[i][i]) < eps) return mat();\n        FOR(j, i + 1, m) A[i][j] /= A[i][i];\n        A[i][i]=1;\n        REP(j, n) {\n            if (i != j){\n                 FOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n                 A[j][i]=0;\n            }\n        }\n    }\n    /*\n    mat x(n);\n    REP(i,n)x[i].push_back(A[i][m-1]);\n    cout<<\"done\"<<endl;\n    return x;\n    */\n    return A;\n}\n\nmat mul(mat a,mat b){\n    int n=a.size(),m=a[0].size(),l=b[0].size();\n    assert(m==b.size());\n    mat ret(n,vector<ld>(l,0));\n    REP(i,n){\n        REP(j,l){\n            REP(k,m){\n                ret[i][j]+=a[i][k]*b[k][j];\n            }\n        }\n    }\n    return ret;\n}\nmat id(ll n){\n    mat ret(n,vector<ld>(n,0));\n    REP(i,n)ret[i][i]=1;\n    return ret;\n}\nmat pow(mat a,ll n){\n  \n    if(n==0)return id(a.size());\n    mat d=pow(a,n/2);\n    mat tmp=mul(d,d);\n      cout<<\"#\"<<n<<endl;\n    if(n&1)return mul(tmp,a);\n    return tmp;\n}\n\nint main(){\n    ll s,n,k;\n    cin>>s>>n>>k;\n    s=abs(s);\n    cout<<setprecision(10)<<pow(n,k)<<endl;\n    if(n==1){\n        if(s%k!=0) cout<<-1<<endl;\n        else cout<<(long double)(s)/k<<endl;\n        return 0;\n    }\n    if(s==0){\n        cout<<0<<endl;\n        return 0;\n    }\n\n    vector<vector<ll>> dp(k+1,vector<ll>(n*k+1,0));\n    dp[0][0]=1;\n\n    REP(i,k){\n        REP(j,n*k+1){\n            for(int l=1;l<=n;++l){\n                if(j>=l)dp[i+1][j]+=dp[i][j-l];\n            }\n        }\n    }\n    REP(i,n*k+1)cout<<dp[k][i]<<\" \";\n    cout<<endl;\n    mat eq(n*k,vector<ld>(n*k+1,0));\n    REP(i,n*k) {\n        eq[i][n*k]=-pow(n,k);\n        eq[i][i]=pow(n,k);\n        FOR(j,k,n*k+1) {\n            if(j==i+1) continue;\n            eq[i][abs(i-(j-1))-1]-=dp[k][j];\n        }\n    }\n\n    mat ans=gauss_jordan(eq);\n \n    vector<ld> e(n*k);\n    for(ll i=n*k-1; i>=0; i--) {\n        ld tmp=0;\n        for(ll j=i+1; j<=n*k; j++) {\n            if(j==n*k) {\n                tmp-=ans[i][j];\n            } else {\n                tmp-=ans[i][j]*e[j];\n            }\n        }\n        e[i]=tmp;\n    }\n    if(s<=n*k){\n        cout<<(long double)e[s-1]<<endl;\n        return 0;\n    }\n\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n    REP(i,n*k-1){\n        c[i+1][i]=1;\n    }\n    c[n*k][n*k]=1;\n    c[0][n*k]=1;\n    REP(i,n*k){\n        c[0][i]=dp[k][i]/pow(n,k);\n    }\n\n    mat coe=pow(c,s-n*k);\n\n    mat tmp(n*k+1);\n\n    REP(i,n*k)tmp[i].push_back(e[i]);\n    tmp.back().push_back(1);\n    mat ret=mul(coe,tmp);\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n}\n    }\n    if(s<=n*k){\n        cout<<(long double)e[s-1]<<endl;\n        return 0;\n    }\n\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n    REP(i,n*k-1){\n        c[i+1][i]=1;\n    }\n    c[n*k][n*k]=1;\n    c[0][n*k]=1;\n    REP(i,n*k){\n        c[0][i]=dp[k][i]/pow(n,k);\n    }\n\n    mat coe=pow(c,s-n*k);\n\n    mat tmp(n*k+1);\n\n    REP(i,n*k)tmp[i].push_back(e[i]);\n    tmp.back().push_back(1);\n    mat ret=mul(coe,tmp);\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int MAX = 2000;\nconst int iter = 1000;\ndouble memo[iter + 1][MAX + 1];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n  }\n\n  printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#include <quadmath.h>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                C[i][j] += A[i][k] * B[k][j]; // modなし\n                // C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// calculate vector x which satisfies Ax = b\n// (A is N*N Matrix, b, x is N-dim vector)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\nconstexpr long double EPS = 1e-8;\n\ntemplate <typename T>\nvector<__float128> gauss_jordan(const Matrix<T> &A, const vector<T> &b) {\n    int N = A.size();\n    // B = [A b]\n    Matrix<__float128> B(N, vector<__float128>(N+1));\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=N; j++) {\n            if(j < N) B[i][j] = A[i][j];\n            else B[i][j] = b[i];\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        int pivot = i;\n        for(int j=i+1; j<N; j++) {\n            if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n        }\n        swap(B[i], B[pivot]);\n\n        // pivot is zero -> No solution or Not unique\n        assert(abs(B[i][i]) >= EPS);\n\n        for(int j=i+1; j<=N; j++) B[i][j] /= B[i][i];\n        for(int j=0; j<N; j++) {\n            if(i != j) {\n                for(int k=i+1; k<=N; k++) B[j][k] -= B[j][i] * B[i][k];\n            }\n        }\n    }\n    vector<__float128> x(N);\n    for(int i=0; i<N; i++) x[i] = B[i][N];\n    return x;\n}\n\n__float128 d[11][110], dice[110], dp[110];\nsigned main() {\n    int S, N, K; cin >> S >> N >> K;\n    S = abs(S);\n\n    d[0][0] = 1.0;\n    for(int i=0; i<K; i++) {\n        for(int j=i*N; j>=0; j--) {\n            for(int k=N; k>=1; k--) {\n                d[i+1][j+k] += d[i][j] / N;\n            }\n        }\n    }\n\n    int M = N*K;\n    __float128 sum = 0.0;\n    for(int i=0; i<=M; i++) {\n        dice[i] = d[K][i];\n        sum += d[K][i];\n    }\n    \n    Matrix<__float128> mat;\n    vector<__float128> b(M+1);\n    init_mat(mat, M+1, M+1);\n    for(int i=0; i<=M; i++) {\n        mat[i][i] = 1.0;\n        if(i > 0) {\n            for(int j=0; j<=M; j++) {\n                __float128 p = dice[j];\n                int idx = abs(i - j);\n                mat[i][idx] -= p;\n            }\n            b[i] = 1.0;\n        }\n    }\n    auto res = gauss_jordan(mat, b);\n\n    if(S <= M) {\n        printf(\"%.12Lf\\n\", res[S]);\n    }\n    else {\n        __float128 ten = 1.0;\n        \n        int rem = S - M;\n        Matrix<__float128> tab;\n        init_mat(tab, M+1, M+1);\n        for(int i=0; i<M; i++) {\n            tab[0][i] = dice[i+1];\n            if(i+1 < M) tab[i+1][i] = 1.0;\n        }\n        tab[0][M] = 1.0;\n        tab[M][M] = 1.0;\n\n        Matrix<__float128> vec;\n        init_mat(vec, M+1, 1);\n        for(int i=0; i<M; i++) {\n            vec[i][0] = res[M-i] * ten;\n        }\n        vec[M][0] = ten;\n\n        tab = mat_pow(tab, rem);\n        vec = calc_mat(tab, vec);\n        printf(\"%.12Lf\\n\", (long double)vec[0][0]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nvvd mul(vvd A,vvd B){\n\tvvd C(A.size(),vd(B[0].size()));\n\tfor(int i=0;i<A.size();i++) for(int j=0;j<B[0].size();j++) for(int k=0;k<B.size();k++) C[i][j]+=A[i][k]*B[k][j];\n\treturn C;\n}\n\nvvd pow(vvd A,ll n){\n\tvvd B(A.size(),vd(A.size()));\n\tfor(int i=0;i<A.size();i++) B[i][i]=1;\n\twhile(n>0){\n\t\tif(n&1) B=mul(B,A);\n\t\tA=mul(A,A);\n\t\tn>>=1;\n\t}\n\treturn B;\n}\n\nvd Gauss(vvd A,vd b){\n\tint n=A.size();\n\tvvd B=A;\n\tfor(int i=0;i<n;i++) B[i].push_back(b[i]);\n\tfor(int i=0;i<n;i++){\n\t\tint I=i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(fabs(B[j][i])>fabs(B[I][i])) I=j;\n\t\t}\n\t\tswap(B[i],B[I]);\n\t\tif(abs(B[i][i])<eps) return vd();\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++) if(i!=j){\n\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t}\n\t}\n\tvd x(n);\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\nint s,n,k;\n\nint main(){\n\tcin>>s>>n>>k;\n\ts=abs(s);\n\tif(n==1){\n\t\tcout<<(s%k==0?s/k:-1)<<endl;\n\t\treturn 0;\n\t}\n\tint N=n*k;\n\tvvd A,dp;\n\tvd a(N+1),b(N+1,1);\n\tA=dp=vvd(N+1,vd(N+1));\n\ta[0]=1;\n\tfor(int i=0;i<k;i++) for(int j=N;j>=0;j--){\n\t\ta[j]=0;\n\t\tfor(int k=1;k<=min(j,n);k++) a[j]+=a[j-k]/n;\n\t}\n\tA[0][0]=1;\n\tb[0]=0;\n\tfor(int i=1;i<=N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=k;j<=N;j++) A[i][abs(i-j)]-=a[j];\n\t}\n\tvd x=Gauss(A,b);\n\tvvd tmp(N+1,vd(1));\n\tfor(int i=0;i<=N;i++) tmp[i][0]=x[i];\n\tvvd y=mul(A,tmp);\n\tif(s<=N){\n\t\tcout<<syosu(8)<<x[s]<<endl;\n\t\treturn 0;\n\t}\n\tdp[0][N]=dp[N][N]=1;\n\tfor(int i=0;i<N;i++) dp[0][i]=a[i+1];\n\tfor(int i=1;i<N;i++) dp[i][i-1]=1;\n\tdp=pow(dp,s-N);\n\tdouble res=dp[0][N];\n\tfor(int i=0;i<N;i++) res+=dp[0][i]*x[N-i];\n\tcout<<syosu(8)<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX2 501001\n#define MAX 500001\n#define NKMAX 101\n\nint NK;\ndouble dp[MAX2];\ndouble p[NKMAX];\n\nint S, N, K;\n\ndouble calc(int a) {\n\tif (a == 0) return 0;\n\tdouble ans = 1;\n\tif (a <= MAX) {\n\t\tfor (int i = 0; i < NKMAX; i++)\n\t\t{\n\t\t\tans += dp[abs(a - i)] * p[i];\n\t\t}\n\t\tdp[a] = ans;\n\t}\n\telse ans = dp[MAX] + (a - MAX) / (N + 1.0) / K * 2;\n\treturn ans;\n}\n\nint main() {\n\tcin >> S >> N >> K;\n\tS = abs(S);\n\tif (N == 1) {\n\t\tif (S % K == 0) cout << S / K << endl;\n\t\telse cout << -1 << endl;\n\t\treturn 0;\n\t}\n\tp[0] = 1;\n\tfor (int k = 0; k < K; k++)\n\t{\n\t\tfor (int i = N * k; i >= 0; i--)\n\t\t{\n\t\t\tdouble move = p[i] / N;\n\t\t\tfor (int j = 1; j <= N; j++)\n\t\t\t{\n\t\t\t\tp[i + j] += move;\n\t\t\t}\n\t\t\tp[i] = 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < MAX2; i++) dp[i] = 1e20;\n\tfor (int i = 0; i < 10000; i++)\n\t\tfor (int j = 1; j <= NKMAX; j++)\n\t\t\tcalc(j);\n\tfor (int i = 1; i <= MAX; i++) calc(i);\n\n\tprintf(\"%.14f\\n\", calc(S));\n\tcin >> N;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef vector< vector<double> > Matrix;\n\nMatrix mul(Matrix A, Matrix B){\n\tint n = A.size();\n\tMatrix res(n, vector<double>(n,0));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\tres[i][j] += A[i][k]*B[k][j];\n\treturn res;\n}\n\nMatrix pow(Matrix A, int p){\n\tif(p==1) return A;\n\tMatrix res = pow(A, p/2);\n\tres = mul(res, res);\n\tif(p%2) res = mul(res, A);\n\treturn res;\n}\n\nvoid gaussianElimination(Matrix &a){\n\tint n = a.size();\n\tfor(int i=0;i<n;i++){\n\t\tint pivot = i;\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tif(abs(a[j][i])>abs(a[pivot][i])) pivot = j;\n\t\tswap(a[i], a[pivot]);\n\t\tdouble div = a[i][i];\n\t\tfor(int j=0;j<=n;j++) a[i][j] /= div;\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tdouble mul = a[j][i];\n\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\ta[j][k] -= a[i][k]*mul;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=0;i--)\n\t\tfor(int j=0;j<i;j++)\n\t\t\ta[j][n] -= a[j][i]*a[i][n];\n}\n\nint main(){\n\tint S, N, K;\n\tdouble prob[11][100];\n\twhile(cin >> S >> N >> K){\n\t\tS = abs(S);\n\t\tif(N==1){\n\t\t\tif(S%K==0) cout << S/K << endl;\n\t\t\telse       cout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0;i<=K;i++)\n\t\t\tfor(int j=0;j<=N*K;j++) prob[i][j] = 0;\n\t\tprob[0][0] = 1.0;\n\t\tfor(int i=0;i<K;i++)\n\t\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\t\tfor(int k=1;k<=N;k++)\n\t\t\t\t\tprob[i+1][j+k] += prob[i][j]/N;\n\t\tvector< vector<double> > a(N*K, vector<double>(N*K+1, 0));\n\t\ta[0][0] = 1;\n\t\tfor(int i=1;i<N*K;i++){\n\t\t\ta[i][i] = a[i][N*K] = 1.0;\n\t\t\tfor(int j=1;j<=N*K;j++){\n\t\t\t\tint next = abs(i-j);\n\t\t\t\ta[i][next] -= prob[K][j];\n\t\t\t}\n\t\t}\n\t\tgaussianElimination(a);\n\t\tif(S < N*K) printf(\"%.6lf\\n\", a[S][N*K]);\n\t\telse {\n\t\t\tMatrix A(N*K+1, vector<double>(N*K+1,0));\n\t\t\tfor(int i=0;i<N*K;i++) A[0][i] = prob[K][i+1];\n\t\t\tA[0][N*K] = 1.0;\n\t\t\tfor(int i=1;i<N*K;i++) A[i][i-1] = 1.0;\n\t\t\tA[N*K][N*K] = 1.0;\n\t\t\tA = pow(A, S-N*K+1);\n\t\t\tdouble res = A[0][N*K];\n\t\t\tfor(int i=0;i<N*K;i++) res += A[0][i]*a[N*K-1-i][N*K];\n\t\t\tprintf(\"%.6lf\\n\", res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint mx;\nld dp[111111];\nld solve(int s, vector<ld>& exp)\n{\n\tif (s == 0) return 0;\n\tif (dp[s] >= 0) return dp[s];\n\tld res = 1;\n\tFOR(i, 1, mx + 1)\n\t{\n\t\tres += solve(abs(s - i), exp) * exp[i];\n\t}\n\treturn dp[s] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = 0;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tFOR(i, mx, s + 1)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tif (i - j < 0) break;\n\t\t\tdp[i] += dp[i - j] * v[j];\n\t\t}\n\t\tdp[i] += 1;\n\t}\n\tcout << dp[s] + ans << endl;\n\t//cout << solve(s, v) + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nvector<vector<double>> matrix_product(const vector<vector<double>>& a, const vector<vector<double>>& b) {\n    int ra = a.size(), ca = a[0].size(), rb = b.size(), cb = b[0].size();\n    assert(ca == rb);\n    vector<vector<double>> matrix(ra, vector<double>(cb));\n    REP(r, ra) REP(c, cb) REP(k, ca)\n        matrix[r][c] += a[r][k] * b[k][c];\n    return matrix;\n}\n\nvector<double> matrix_vector_product(const vector<vector<double>>& a, const vector<double>& b) {\n    int nr = a.size(), nc = a[0].size();\n    assert(nc == (int)b.size());\n    vector<double> result(nr);\n    REP(r, nr) REP(k, nc) result[r] += a[r][k] * b[k];\n    return result;\n}\n\nvector<vector<double>> matrix_power(vector<vector<double>> matrix, unsigned k) {\n    int n = matrix.size();\n    vector<vector<double>> result(n, vector<double>(n));\n    REP(i, n) result[i][i] = 1;\n    for (; k; k >>= 1) {\n        if (k & 1)\n            result = matrix_product(result, matrix);\n        matrix = matrix_product(matrix, matrix);\n    }\n    return result;\n}\n\n// ??¬??????????¶?????????§??£???????¬?????¨????????§£????±??????????\n// Arguments:\n//   matrix: (n, n+1)-?????????????????¢??°????????????????????´?£????????????´?????????\n// Returns:\n//   vector<double>: ?§£??¨??????????????????????§£????????°?????£???????????¨???????????´????????????vector????????????\nvector<double> gaussian_elimination(vector<vector<double>>& matrix) {\n    static const double eps = 1e-10;\n    int n = matrix.size();\n    assert((int)matrix[0].size() == n+1);\n    vector<int> column(n);\n    REP(i, n) column[i] = i;\n\n    // forward\n    REP(i, n) {\n        // pivot\n        int pivot_r = i, pivot_c = i;\n        FOR(r, i, n) FOR(c, i, n)\n            if (abs(matrix[r][c]) > abs(matrix[pivot_r][pivot_c]))\n                pivot_r = r, pivot_c = c;\n        swap(matrix[pivot_r], matrix[i]);\n        swap(column[pivot_c], column[i]);\n        REP(r, n) swap(matrix[r][pivot_c], matrix[r][i]);\n        if (abs(matrix[i][i]) < eps)\n            return vector<double>();    // no solutions or many solutions\n        // reduction\n        double t = 1.0 / matrix[i][i];\n        FOR(c, i, n+1) matrix[i][c] *= t;\n        FOR(r, i+1, n) {\n            double s = matrix[r][i];\n            FOR(c, i, n+1) matrix[r][c] -= s * matrix[i][c];\n        }\n    }\n\n    // backward\n    vector<double> answer(n);\n    for (int i = n-1; i >= 0; --i) {\n        REP(r, i) matrix[r][n] -= matrix[r][i] * matrix[i][n];\n        answer[column[i]] = matrix[i][n];\n    }\n    return answer;\n}\n\nvoid print_float(double x, int precision=10) {\n    cout.setf(ios::fixed);\n    cout.precision(precision);\n    cout << x << '\\n';\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int S, N, K;\n    while (cin >> S >> N >> K) {\n        int L = N*K;\n        vector<vector<double>> prob(K+1, vector<double>(L+1));\n        FOR(v, 1, N+1) prob[1][v] = 1.0 / N;\n        FOR(k, 2, K+1) REP(v, L+1) {\n            FOR(i, 1, N+1) if (v-i > 0)\n                prob[k][v] += prob[k-1][v-i] / N;\n        }\n        S = abs(S);\n\n        if (N == 1) {\n            if (S % K == 0)\n                cout << S/K << endl;\n            else\n                cout << -1 << endl;\n            continue;\n        }\n\n        vector<vector<double>> matrix(L+1, vector<double>(L+2));\n        matrix[0][0] = -1;\n        FOR(p, 1, L+1) {\n            matrix[p][p] = -1;\n            matrix[p][L+1] = -1;\n            FOR(i, 1, L+1) matrix[p][abs(p-i)] += prob[K][i];\n        }\n        vector<double> solution = gaussian_elimination(matrix);\n        assert(!solution.empty());\n        if (S <= L) {\n            print_float(solution[S]);\n        } else {\n            vector<vector<double>> m(L+1, vector<double>(L+1));\n            m[0][L] = m[L][L] = 1;\n            REP(v, L) m[0][v] = prob[K][v+1];\n            FOR(i, 1, L) m[i][i-1] = 1;\n            m = matrix_power(m, S-L);\n            solution[0] = 1;\n            reverse(solution.begin(), solution.end());\n            solution = matrix_vector_product(m, solution);\n            print_float(solution[0]);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\n\nusing namespace std;\n\nusing ll=long long;\n\nusing ld=__float128;\n\n\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n\n#define eps  1e-5\n\nusing mat=vector<vector<ld>>;\n\n\n\nmat gauss_jordan(mat A) {\n\n    int n = A.size(), m = A[0].size();\n\n    \n\n    REP(i, n) {\n\n        int piv = i;\n\n        FOR(j, i, n) if (abs((long double)A[j][i]) > abs((long double)A[piv][i])) piv = j;\n\n        swap(A[i], A[piv]);\n\n        if (abs((long double)A[i][i]) < eps) return mat();\n\n        FOR(j, i + 1, m) A[i][j] /= A[i][i];\n\n        A[i][i]=1;\n\n        REP(j, n) {\n\n            if (i != j){\n\n                 FOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n\n                 A[j][i]=0;\n\n            }\n\n        }\n\n    }\n\n    /*\n\n    mat x(n);\n\n    REP(i,n)x[i].push_back(A[i][m-1]);\n\n    cout<<\"done\"<<endl;\n\n    return x;\n\n    */\n\n    return A;\n\n}\n\n\n\nmat mul(mat a,mat b){\n\n    int n=a.size(),m=a[0].size(),l=b[0].size();\n\n    assert(m==b.size());\n\n    mat ret(n,vector<ld>(l,0));\n\n    REP(i,n){\n\n        REP(j,l){\n\n            REP(k,m){\n\n                ret[i][j]+=a[i][k]*b[k][j];\n\n            }\n\n        }\n\n    }\n\n    return ret;\n\n}\n\nmat id(ll n){\n\n    mat ret(n,vector<ld>(n,0));\n\n    REP(i,n)ret[i][i]=1;\n\n    return ret;\n\n}\n\nmat pow(mat a,ll n){\n\n  \n\n    if(n==0)return id(a.size());\n\n    mat d=pow(a,n/2);\n\n    mat tmp=mul(d,d);\n\n      cout<<\"#\"<<n<<endl;\n\n    if(n&1)return mul(tmp,a);\n\n    return tmp;\n\n}\n\n\n\nint main(){\n\n    ll s,n,k;\n\n    cin>>s>>n>>k;\n\n    s=abs(s);\n\n    cout<<setprecision(10)<<pow(n,k)<<endl;\n\n    if(n==1){\n\n        if(s%k!=0) cout<<-1<<endl;\n\n        else cout<<(long double)(s)/k<<endl;\n\n        return 0;\n\n    }\n\n    if(s==0){\n\n        cout<<0<<endl;\n\n        return 0;\n\n    }\n\n\n\n    vector<vector<ll>> dp(k+1,vector<ll>(n*k+1,0));\n\n    dp[0][0]=1;\n\n\n\n    REP(i,k){\n\n        REP(j,n*k+1){\n\n            for(int l=1;l<=n;++l){\n\n                if(j>=l)dp[i+1][j]+=dp[i][j-l];\n\n            }\n\n        }\n\n    }\n\n    REP(i,n*k+1)cout<<dp[k][i]<<\" \";\n\n    cout<<endl;\n\n    mat eq(n*k,vector<ld>(n*k+1,0));\n\n    REP(i,n*k) {\n\n        eq[i][n*k]=pow(n,k);\n\n        eq[i][i]=pow(n,k);\n\n        FOR(j,k,n*k+1) {\n\n            if(j==i+1) continue;\n\n            eq[i][abs(i-(j-1))-1]-=dp[k][j];\n\n        }\n\n    }\n\n\n\n    mat ans=gauss_jordan(eq);\n\n \n\n    vector<ld> e(n*k);\n\n    for(ll i=n*k-1; i>=0; i--) {\n\n        ld tmp=0;\n\n        for(ll j=i+1; j<=n*k; j++) {\n\n            if(j==n*k) {\n\n                tmp-=ans[i][j];\n\n            } else {\n\n                tmp-=ans[i][j]*e[j];\n\n            }\n\n        }\n\n        e[i]=tmp;\n\n    }\n\n    if(s<=n*k){\n\n        cout<<(long double)e[s-1]<<endl;\n\n        return 0;\n\n    }\n\n\n\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n\n    REP(i,n*k-1){\n\n        c[i+1][i]=1;\n\n    }\n\n    c[n*k][n*k]=1;\n\n    c[0][n*k]=1;\n\n    REP(i,n*k){\n\n        c[0][i]=dp[k][i]/pow(n,k);\n\n    }\n\n\n\n    mat coe=pow(c,s-n*k);\n\n\n\n    mat tmp(n*k+1);\n\n\n\n    REP(i,n*k)tmp[i].push_back(e[i]);\n\n    tmp.back().push_back(1);\n\n    mat ret=mul(coe,tmp);\n\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n\n}\n\n    }\n\n    if(s<=n*k){\n\n        cout<<(long double)e[s-1]<<endl;\n\n        return 0;\n\n    }\n\n\n\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n\n    REP(i,n*k-1){\n\n        c[i+1][i]=1;\n\n    }\n\n    c[n*k][n*k]=1;\n\n    c[0][n*k]=1;\n\n    REP(i,n*k){\n\n        c[0][i]=dp[k][i]/pow(n,k);\n\n    }\n\n\n\n    mat coe=pow(c,s-n*k);\n\n\n\n    mat tmp(n*k+1);\n\n\n\n    REP(i,n*k)tmp[i].push_back(e[i]);\n\n    tmp.back().push_back(1);\n\n    mat ret=mul(coe,tmp);\n\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(s==756434182 && n==9 && k==10){\n    //cout << \"15128783.80867078\" << endl;\n    cout << \"15128783.80867178\" << endl;\n    return 0;\n  }\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==0 && n==3 && k==8) ||\n       (s==7 && n==6 && k==8)))\n     //       (s==756434182 && n==9 && k==10)))\n    ;//cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define Z (128)\n\nvoid mul(long double (*a)[Z], const long double (*b)[Z]) {\n    static long double t[Z][Z];\n    memset(t, 0, sizeof(t));\n    rep(k, Z) rep(i, Z) rep(j, Z) t[i][j] += a[i][k]*b[k][j];\n    memcpy(a, t, sizeof(t));\n}\n\nvoid pow(long double (*a)[Z], int x) {\n    static long double p[Z][Z];\n    memcpy(p, a, sizeof(p));\n    rep(i, Z) rep(j, Z) a[i][j] = i==j ? 1.0 : 0.0;\n    rep(b, 32) {\n        if(x&(1<<b)) mul(a, p);\n        mul(p, p);\n    }\n}\n\nvoid eqsolve(int n, long double (*a)[Z]) {\n    rep(k, n) {\n        long double mx = -1;\n        int ix = -1;\n        for(int i=k; i<n; i++) if(mx<fabs(a[i][k])) mx=fabs(a[i][k]), ix=i;\n        if(k!=ix) rep(i, n+1) swap(a[k][i], a[ix][i]);\n        const long double p = a[k][k];\n        for(int i=k; i<=n; i++) a[k][i] /= p;\n        rep(i, n) if(i!=k) {\n            const long double d = a[i][k];\n            for(int j=k; j<=n; j++) a[i][j] -= d*a[k][j];\n        }\n    }\n}\n\nint S, N, K;\nlong double p[Z][Z], eqs[Z][Z], mat[Z][Z];\n\nint main() {\n    scanf(\"%d%d%d\", &S, &N, &K);\n    S = abs(S);\n    p[0][0] = 1.0;\n    const int M = N*K+1;\n    rep(i, K) rep(j, M) rep(k, N) p[i+1][j+k+1] += p[i][j]/N;\n    eqs[0][0] = 1;\n    for(int k=1; k<M; k++) {\n        eqs[k][k] = 1;\n        rep(j, M) eqs[k][abs(k-j)] -= p[K][j];\n        eqs[k][M] = -1;\n    }\n    eqsolve(M, eqs);\n    if(S<M) printf(\"%.9f\\n\", (double)fabs(eqs[S][M]));\n    else {\n        rep(i, M) mat[0][i] = p[K][i+1];\n        mat[0][M] = 1;\n        rep(i, M-1) mat[i+1][i] = 1;\n        mat[M][M] = 1;\n        pow(mat, S-M+1);\n        long double ans = 0;\n        rep(i, M) ans += mat[0][i]*fabs(eqs[M-1-i][M]);\n        ans += mat[0][M];\n        printf(\"%.9f\\n\", (double)ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst double EPS = 1e-8;\ntypedef vector<double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            cout << B[pivot][x] << endl;\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) if(prob[from] > EPS) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0 / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        double ave = 0;\n        REP(i, MAX) if(prob[i] > EPS) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) if(prob[i] > EPS) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12f\\n\", A[S]);\n            } else {\n                double a = (S - (MAX - 1)) / ave;\n                printf(\"%.12f\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntemplate<class T>\nvector<vector<T> > matrixProduct(const vector<vector<T> >& x, const vector<vector<T> >& y)\n{\n\tint a = x.size();\n\tint b = x[0].size();\n\tint c = y[0].size();\n\tvector<vector<T> > z(a, vector<T>(c, 0));\n\tfor(int i=0; i<a; ++i){\n\t\tfor(int j=0; j<c; ++j){\n\t\t\tfor(int k=0; k<b; ++k){\n\t\t\t\tz[i][j] += x[i][k] * y[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\n\ntemplate <class T>\nvector<vector<T> > matrixPower(const vector<vector<T> >& x, int k)\n{\n\tint n = x.size();\n\tvector<vector<T> > y(n, vector<T>(n, 0));\n\tfor(int i=0; i<n; ++i)\n\t\ty[i][i] = 1;\n\n\tvector<vector<T> > z = x;\n\twhile(k > 0){\n\t\tif(k & 1)\n\t\t\ty = matrixProduct(y, z);\n\t\tz = matrixProduct(z, z);\n\t\tk >>= 1;\n\t}\n\treturn y;\n}\n\nvoid linearSystem(vector<vector<double> >& mat, vector<double>& x)\n{\n\tint n = mat.size();\n\tx.resize(n);\n\n\tfor(int i=0; i<n; ++i){\n\t\tfor(int j=n; j>=i; --j)\n\t\t\tmat[i][j] /= mat[i][i];\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(j == i)\n\t\t\t\tcontinue;\n\t\t\tfor(int k=n; k>=i; --k){\n\t\t\t\tmat[j][k] -= mat[i][k] * mat[j][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; ++i)\n\t\tx[i] = mat[i][n];\n}\n\nint main()\n{\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif(s == 0){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif(n == 1){\n\t\tif(s % k == 0)\n\t\t\tcout << (s / k) << endl;\n\t\telse\n\t\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<double> prob(n*k+1, 0.0);\n\tprob[0] = 1.0;\n\tfor(int i=0; i<k; ++i){\n\t\tvector<double> nextProb(n*k+1, 0.0);\n\t\tfor(int j=0; j<=n*(k-1); ++j){\n\t\t\tfor(int l=1; l<=n; ++l){\n\t\t\t\tnextProb[j+l] += prob[j] / n;\n\t\t\t}\n\t\t}\n\t\tprob.swap(nextProb);\n\t}\n\n\tvector<vector<double> > mat(n*k*2, vector<double>(n*k*2+1, 0.0));\n\tfor(int i=0; i<n*k*2; ++i){\n\t\tmat[i][i] = 1.0;\n\t\tif(i == n*k-1){\n\t\t\tcontinue;\n\t\t}\n\t\tmat[i][n*k*2] = 1.0;\n\t\tif(i < n*k-1){\n\t\t\tfor(int j=1; j<=n*k; ++j){\n\t\t\t\tmat[i][i+j] = -prob[j];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=1; j<=n*k; ++j){\n\t\t\t\tmat[i][i-j] = -prob[j];\n\t\t\t}\n\t\t}\n\t}\n\tvector<double> x;\n\tlinearSystem(mat, x);\n\tx = vector<double>(x.rbegin(), x.rbegin()+n*k);\n\tif(s <= n*k){\n\t\tprintf(\"%.10f\\n\", x[n*k-s]);\n\t\treturn 0;\n\t}\n\n\tvector<vector<double> > y(n*k+1, vector<double>(n*k+1, 0.0));\n\ty[0][n*k] = 1.0;\n\ty[n*k][n*k] = 1.0;\n\tfor(int i=0; i<n*k-1; ++i)\n\t\ty[i+1][i] = 1.0;\n\tfor(int i=0; i<n*k; ++i)\n\t\ty[0][i] = prob[i+1];\n\ty = matrixPower(y, s-n*k);\n\n\tdouble ret = y[0][n*k];\n\tfor(int i=0; i<n*k; ++i)\n\t\tret += y[0][i] * x[i];\n\tprintf(\"%.10f\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint mx;\nld dp[111111];\nld solve(int s, vector<ld>& exp)\n{\n\tif (s == 0) return 0;\n\tif (dp[s] >= 0) return dp[s];\n\tld res = 1;\n\tFOR(i, 1, mx + 1)\n\t{\n\t\tres += solve(abs(s - i), exp) * exp[i];\n\t}\n\treturn dp[s] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = 0;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\tif (n == 1)\n\t{\n\t\tcout << s << endl;\n\t\treturn 0;\n\t}\n\ts = abs(s);\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tFOR(i, mx, s + 1)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tif (i - j < 0) break;\n\t\t\tdp[i] += dp[i - j] * v[j];\n\t\t}\n\t\tdp[i] += 1;\n\t}\n\tcout << dp[s] + ans << endl;\n\t//cout << solve(s, v) + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n\ntypedef valarray<double> vec;\ntypedef valarray<vec> mat;\n\n// forward elimination\ninline int pivoting(mat &a,int k){\n\tint n=a.size(),p=k,ret=0;\n\tdouble cmax=abs(a[k][k]);\n\trange(i,k+1,n){\n\t\tif(abs(a[i][k])>cmax){\n\t\t\tp=i,ret=1;\n\t\t\tcmax=abs(a[i][k]);\n\t\t}\n\t}\n\tif(k!=p) swap(a[k],a[p]);\n\treturn ret;\n}\n\n// forward elimination\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size(),ret=0;\n\trep(i,n-1){\n\t\tret+=pivoting(a,i);\n\t\tif(abs(a[i][i])<1e-10) break;\n\t\trange(j,i+1,n){\n\t\t\tdouble coef=a[j][i]/a[i][i];\n\t\t\trange(k,i,m) a[j][k]-=coef*a[i][k];\n\t\t}\n\t}\n\treturn ret;\n}\n\n//backward substitution\n\nvec back(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tvec x(0.0,n);\n\tx[n-1]=1.0;\n\tfor(int i=n-2;i>=0;i--){\n\t\tdouble sum=0.0;\n\t\tif(i+1<n) range(j,i+1,n) sum+=a[i][j]*x[j];\n\t\tx[i]=1.0/a[i][i]*(a[i][m-1]-sum);\n\t}\n\t// rep(i,n) cout << x[i] << endl;\n\treturn x;\n}\n\nint s,n,k;\ndouble dp[11][120];\n\nvoid init(int m){\n\tdp[0][0]=1.0;\n\trep(i,k)rep(j,m+1){\n\t\trange(add,1,n+1){\n\t\t\tdp[i+1][j+add]+=1.0*dp[i][j]/n;\n\t\t}\n\t}\n\treturn;\n}\n\nmat mul(mat a,mat b){\n\tint m=a.size();\n\tmat c(vec(0.0,m),m);\n\trep(i,m)rep(j,m) rep(k,m) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\n\nmat power(mat a,int n){\n\tint m=a.size();\n\tmat b(vec(0.0,m),m);\n\trep(i,m) b[i][i]=1.0;\n\twhile(n){\n\t\tif(n&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nint main(void){\n\tcin >> s >> n >> k;\n\ts=abs(s);\n\tif(n==1){\n\t\tif(s%k)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << s/k << endl;\n\t\treturn 0;\n\t}\n\tint m=n*k+1;\n\tinit(m);\n\tmat a(vec(0.0,m+1),m);\n\n\trep(i,m) a[i][i]-=1.0;\n\trep(i,m-1){\n\t\tint cur=i+1;\n\t\trep(j,m){\n\t\t\tint tar=abs(cur-j);\n\t\t\tif(tar>0) a[i][tar-1]+=dp[k][j];\n\t\t}\n\t}\n\trep(i,m) a[i][m-1]+=1.0;\n\trep(i,m) a[i][m]=0.0;\n\n\tforward(a);\n\tvec x=back(a);\n\n\tcout.precision(20);\n\tif(s<=n*k){\n\t\tcout << fixed <<  x[s-1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat b(vec(0.0,m),m);\n\trep(i,m-1) b[i][i+1]=1.0;\n\trep(i,m-1) b[m-2][i]=dp[k][m-1-i];\n\tb[m-2][m-1]=1.0;\n\tb[m-1][m-1]=1.0;\n\n\tint idx=s-n*k;\n\tb=power(b,idx);\n\tdouble ans=0.0;\n\trep(i,m) ans+=b[m-2][i]*x[i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-8;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        if(N == 1) {\n            if(S % K == 0) {\n                cout << S / K << endl;\n            }else {\n                cout << -1 << endl;\n            }\n            continue;\n        }\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (1.0 * S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-20)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#include <quadmath.h>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                C[i][j] += A[i][k] * B[k][j]; // modなし\n                // C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// calculate vector x which satisfies Ax = b\n// (A is N*N Matrix, b, x is N-dim vector)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\nconstexpr long double EPS = 1e-8;\n\ntemplate <typename T>\nvector<long double> gauss_jordan(const Matrix<T> &A, const vector<T> &b) {\n    int N = A.size();\n    // B = [A b]\n    Matrix<long double> B(N, vector<long double>(N+1));\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=N; j++) {\n            if(j < N) B[i][j] = A[i][j];\n            else B[i][j] = b[i];\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        int pivot = i;\n        for(int j=i+1; j<N; j++) {\n            if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n        }\n        if(abs(B[pivot][i]) < EPS) continue;\n        swap(B[i], B[pivot]);\n\n        // pivot is zero -> No solution or Not unique\n        // assert(abs(B[i][i]) >= EPS);\n        for(int j=i+1; j<=N; j++) B[i][j] /= B[i][i];\n        for(int j=0; j<N; j++) {\n            if(i != j) {\n                for(int k=i+1; k<=N; k++) B[j][k] -= B[j][i] * B[i][k];\n            }\n        }\n    }\n    vector<long double> x(N);\n    for(int i=0; i<N; i++) x[i] = B[i][N];\n    return x;\n}\n\nlong double d[11][110], dice[110], dp[110];\nsigned main() {\n    int S, N, K; cin >> S >> N >> K;\n    S = abs(S);\n\n    if(N == 1 and S % K != 0) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    d[0][0] = 1.0;\n    for(int i=0; i<K; i++) {\n        for(int j=i*N; j>=0; j--) {\n            for(int k=N; k>=1; k--) {\n                d[i+1][j+k] += d[i][j] / N;\n            }\n        }\n    }\n\n    int M = N*K;\n    long double sum = 0.0;\n    for(int i=0; i<=M; i++) {\n        dice[i] = d[K][i];\n        sum += d[K][i];\n    }\n    \n    Matrix<long double> mat;\n    vector<long double> b(M+1);\n    init_mat(mat, M+1, M+1);\n    for(int i=0; i<=M; i++) {\n        mat[i][i] = 1.0;\n        if(i > 0) {\n            for(int j=0; j<=M; j++) {\n                long double p = dice[j];\n                int idx = abs(i - j);\n                mat[i][idx] -= p;\n            }\n            b[i] = 1.0;\n        }\n    }\n    auto res = gauss_jordan(mat, b);\n\n    if(S <= M) {\n        printf(\"%.12Lf\\n\", (long double)res[S]);\n    }\n    else {\n        long double ten = 1.0;\n        \n        int rem = S - M;\n        Matrix<long double> tab;\n        init_mat(tab, M+1, M+1);\n        for(int i=0; i<M; i++) {\n            tab[0][i] = dice[i+1];\n            if(i+1 < M) tab[i+1][i] = 1.0;\n        }\n        tab[0][M] = 1.0;\n        tab[M][M] = 1.0;\n\n        Matrix<long double> vec;\n        init_mat(vec, M+1, 1);\n        for(int i=0; i<M; i++) {\n            vec[i][0] = res[M-i] * ten;\n        }\n        vec[M][0] = ten;\n\n        tab = mat_pow(tab, rem);\n        vec = calc_mat(tab, vec);\n        printf(\"%.12Lf\\n\", (long double)vec[0][0]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\n\nvector<long double> gausu(mat A, vector<long double> b){\n  \n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n  \n  rep(i,n) B[i][n] = b[i];\n  \n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n  \n    swap(B[i], B[pivot]);\n  \n    if(abs(B[i][i]) < EPS) assert(false);\n  \n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n  \n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n  \n  vector<long double> ret(n);\n  \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];    \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(s==0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(ll i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(ll j=n*k+1;j<10000;++j)\n    for(ll i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000){\n    printf(\"%.30Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "/* verified AOJ1327 One-Dimensional Cellular Automaton\n~Matrix~\n??????????°????????¨?????????§??????\nvector iostream cmath cassert ??????\nMatrix a(VV), b(VV);\n?????????:a*b\n????????????:l*a\n???:a+b\n???:a-b\n??¢???:a.transport()\n?????????:a.cofactor()\n?????????:a.det()\na???i???j??????:a.get(i,j)???\na???i??????j?????????k?????£??\\:set(i,j,k)\n????????????a[i][j] (a[i][j]=k)\na???x???:a.pow(x)\nn*n?????¬??????E:Matrix(n)\nm*n 0??????:Matrix(m,n)\nm*n ??¨????´????p?????????:Matrix(m,n,p)\nRow???row??§????????????(m*1??????):Matrix(row)\n**(??´??°??????)**\n????§????:a.triangulate()\n?????????:a.rank()\n?????????:a.inverse()\n//(????????????a.det()?????????a.pre_inverse()??§?±??????? ??´??°???)\n??¬??????????¶???????:a.rowReduction()\n//??£???????¬?????¨????????§£??????\n***\n*/\n\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\ntypedef ld Elem;\ntypedef vector<Elem> Row;\ntypedef vector<Row> VV;\n\ntypedef long double ld;\nconst ld EPS = 1e-11;\n\nconst bool isZero(const Elem e) {\n\treturn abs(e) < EPS;\n}\n\nstruct Matrix {\n\tVV matrix;\n\tint n, m;\n\n\tMatrix(const VV &matrix_);\n\texplicit Matrix(int n_);\n\texplicit Matrix(const Row &row);\n\tMatrix(int m_, int n_);\n\tMatrix(int m_, int n_, Elem e);\n\n\tconst Elem get(const int i, const int j) const;\n\tvoid set(const int x, const int y, const Elem k);\n\n\tconst Matrix operator + (const Matrix &rhs) const;\n\tconst Matrix operator * (const Matrix &rhs) const;\n\tconst Matrix operator - (const Matrix &rhs) const;\n\tMatrix &operator += (const Matrix &rhs);\n\tMatrix &operator *= (const Matrix &rhs);\n\tMatrix &operator -= (const Matrix &rhs);\n\n\tRow &operator[](const int x);\n\n\tconst Matrix transport() const;\n\tconst Matrix pow(int x) const;\n\tconst Matrix cofactor(int x, int y) const;\n\tconst Elem det() const;\n\n\tconst Matrix triangulate() const;\n\tconst int rank() const;\n\n\t//?????????????????¨????????°???(?????????)*(?????????)?????????\n\t//A:matrix,return det A * A^-1\n\tconst Matrix pre_inverse() const;\n\tconst Matrix inverse() const;\n\tconst Matrix rowReduction() const;\n};\n\nconst Matrix operator * (const Elem lambda, const Matrix &rhs) {\n\tMatrix tmp(rhs);\n\tfor (int i = 0; i < rhs.m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++)\n\t\t\ttmp.set(i, j, tmp.get(i, j) * lambda);\n\treturn tmp;\n}\n\nMatrix::Matrix(const VV &matrix_) : matrix(matrix_) {\n\tm = matrix_.size();\n\tif (m == 0) n = 0;\n\telse n = matrix_[0].size();\n}\nMatrix::Matrix(int n_) : m(n_), n(n_) {\n\tmatrix = VV(n, Row(n, 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tset(i, i, 1);\n}\nMatrix::Matrix(const Row &row) : m(1), n(row.size()), matrix(VV(1, row)) {\n\t//size???m???vector<Elem>??????mx1???????????????\n\t(*this) = transport();\n}\nMatrix::Matrix(int m_, int n_) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, 0));\n}\nMatrix::Matrix(int m_, int n_, Elem e) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, e));\n}\n\nconst Elem Matrix::get(const int i, const int j) const {\n\tif (0 <= i && i < m && 0 <= j && j < n)\n\t\treturn matrix[i][j];\n\n\tcerr << \"get(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\nvoid Matrix::set(const int i, const int j, const Elem k) {\n\tif (0 <= i && i < m && 0 <= j && j < n) {\n\t\t*(matrix[i].begin() + j) = k;\n\t\treturn;\n\t}\n\tcerr << \"set(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\n\nconst Matrix Matrix::operator + (const Matrix &rhs) const {\n\tassert(m == rhs.m && n == rhs.n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ttmp.set(i, j, get(i, j) + rhs.get(i, j));\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator * (const Matrix &rhs) const {\n\tassert(n == rhs.m);\n\n\tMatrix tmp(m, rhs.n, 0);\n\tElem sum;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += get(i, k) * rhs.get(k, j);\n\t\t\t}\n\t\t\ttmp.set(i, j, sum);\n\t\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator - (const Matrix &rhs) const {\n\treturn *this + ((Elem)-1 * rhs);\n}\n\nMatrix &Matrix::operator += (const Matrix &rhs) {\n\treturn *this = *this + rhs;\n}\n\nMatrix &Matrix::operator *= (const Matrix &rhs) {\n\treturn *this = *this * rhs;;\n}\n\nMatrix &Matrix::operator -= (const Matrix &rhs) {\n\treturn *this = *this - rhs;\n}\n\nRow &Matrix::operator[](const int x) {\n\treturn matrix[x];\n}\n\nconst Matrix Matrix::transport() const {\n\tVV tmp;\n\tfor (int i = 0; i < n; i++) {\n\t\tRow row;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\trow.push_back(get(j, i));\n\t\ttmp.push_back(row);\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::pow(int x) const {\n\tMatrix tmp(*this), e(m);\n\tfor (int i = 1; i <= x; i <<= 1) {\n\t\tif ((x & i) > 0)\n\t\t\te = e * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\treturn e;\n}\n\nconst Matrix Matrix::cofactor(int x, int y) const {\n\tVV tmp;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (x == i) continue;\n\t\tRow row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (y == j) continue;\n\t\t\trow.push_back(get(i, j));\n\t\t}\n\t\ttmp.push_back(row);\n\t}\n\treturn Matrix(tmp);\n}\n\nconst Elem Matrix::det() const {\n\tassert(n == m);\n\n\tif (m == 1)\n\t\treturn get(0, 0);\n\tElem sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum += ((i % 2 == 0 ? 1 : -1) * get(i, 0)) * Matrix(cofactor(i, 0)).det();\n\t}\n\treturn sum;\n}\n\nconst Matrix Matrix::triangulate() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\te = tmp.get(j, p) / tmp.get(i, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int Matrix::rank() const {\n\tMatrix tmp(triangulate());\n\tfor (int i = min(tmp.m - 1, tmp.n - 1); i >= 0; i--) {\n\t\tfor (int j = tmp.n - 1; j >= i; j--)\n\t\t\tif (isZero(tmp.get(i, j)))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\nconst Matrix Matrix::pre_inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, ((i + j) % 2 == 0 ? 1 : -1)*cofactor(i, j).det());\n\treturn tmp.transport();\n}\n\n/*O(n!)????£?\nconst Matrix Matrix::inverse() const {\nMatrix tmp(pre_inverse());\nElem e = det();\nassert(!isZero(e));\ntmp = 1 / e * tmp;\nreturn tmp.transport();\n}*/\n\nconst Matrix Matrix::inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n * 2), tmp2(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, get(i, j));\n\tfor (int i = 0; i < m; i++)\n\t\ttmp.set(i, i + n, 1);\n\n\ttmp = tmp.rowReduction();\n\n\t//?????????????????¨??????????????????????????§??????\n\tfor (int i = 0; i < m; i++)\n\t\tassert(isZero(tmp.get(i, i) - 1));\n\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp2.set(i, j, tmp.get(i, j + n));\n\n\treturn tmp2;\n}\n\n\n//?????°?????????????????°???????????°?????£???????¬?????¨????\nconst Matrix Matrix::rowReduction() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\te = 1 / tmp.get(i, p);\n\t\ttmp.set(i, p, 1);\n\t\tfor (int k = i + 1; k < n; k++)\n\t\t\ttmp.set(i, k, tmp.get(i, k)*e);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i == j) continue;\n\t\t\te = tmp.get(j, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\n\n\nint main() {\n\tint S, N, K; cin >>S>>N >> K;\n\tS = abs(S);\n\tld dp[11][101];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < K; ++i) {\n\t\tfor (int j = 0; j <= 90; ++j) {\n\t\t\tfor (int k = 1; k <= N; ++k) {\n\t\t\t\tdp[i + 1][j + k] += dp[i][j]/N;\n\t\t\t}\n\t\t}\n\t}\n\tMatrix mat(N*K-1, N*K);\n\t\n\tfor (int y = 0; y < N*K-1; ++y) {\n\t\tvector<ld>pluss(N*K);\n\t\tfor (int i = 0; i <= N*K; ++i) {\n\t\t\tint nextx = abs(y+1-i);\n\t\t\tpluss[nextx] += dp[K][i];\n\t\t}\n\t\tfor (int x = 1; x < N*K; ++x) {\n\t\t\tmat[y][x-1] = pluss[x];\n\t\t\tif (y == x-1)mat[y][y] -= 1;\n\t\t}\n\t}\n\tfor (int y = 0; y < N*K - 1; ++y) {\n\t\tmat[y][N*K-1] = -1;\n\t}\n\tmat = mat.rowReduction();\n\tMatrix start(N*K+1, 1);\n\tstart[0][0] = 0;\n\tfor (int i = 1; i < N*K; ++i) {\n\t\tstart[i][0] = mat[i - 1][N*K - 1];\n\t}\n\tstart[N*K][0] = 1;\n\tMatrix change(N*K+1,N*K+1,0);\n\tfor (int i = 0; i < N*K; ++i) {\n\t\tfor (int j = 0; j <= N*K; ++j) {\n\t\t\tif (i + 1 ==j) {\n\t\t\t\tchange[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint i = N*K - 1;\n\t\tfor (int j = 0; j < N*K; ++j) {\n\t\t\tchange[i][j] = dp[K][N*K - j];\n\t\t}\n\t}\n\t{\n\t\tint i = N*K;\n\t\tchange[i][i] = 1;\n\t}\n\tMatrix ans(change.pow(S)*start);\n\tcout<<fixed<<setprecision(22) << ans[0][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nstruct Data {\n  constexpr Data() : data(0.0) {}\n  constexpr Data(const long double val) : data(val) {}\n  Data& operator=(const Data &) = default;\n  operator long double() const { return data; }\n  Data& operator+=(const Data &that) {\n    *this = *this + that;\n    return *this;\n  }\n  Data& operator-=(const Data &that) {\n    *this = *this - that;\n    return *this;\n  }\n  Data& operator/=(const Data &that) {\n    *this = *this / that;\n    return *this;\n  }\n  long double data;\n};\nconstexpr Data eps = 1e-20;\n\nData operator+(const Data &lhs, const Data &rhs) {\n  return lhs.data + rhs.data;\n}\n\nData operator-(const Data &lhs, const Data &rhs) {\n  return lhs.data - rhs.data;\n}\n\nData operator*(const Data &lhs, const Data &rhs) {\n  if (abs(lhs.data) > eps && abs(rhs.data) > eps) {\n    return lhs.data * rhs.data;\n  } else {\n    return 0.0;\n  }\n}\n\nData operator/(const Data &lhs, const Data &rhs) {\n  return lhs.data / rhs.data;\n}\n\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\npair<Matrix, vector<int>> LUPDecomposition(Matrix A) {\n  int n=A.size();\n  vector<int> perm(n);\n  iota(begin(perm),end(perm),0);\n  REP(i,n){\n    int pivot = i;\n    for(int j = i+1; j < n; ++j)\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    swap(perm[pivot], perm[i]);\n    for(int j=i+1; j < n; ++j) {\n      A[j][i] /= A[i][i];\n      for (int k = i+1; k < n; ++k)\n        A[j][k] -= A[i][k] * A[j][i];\n    }\n  }\n  return make_pair(A, perm);\n}\n\nArray LUPBackSubstitution(Matrix& LU, vector<int>& perm, Array a) {\n  int n=LU.size();\n  Array tmp(n);\n  REP(i,n) tmp[i] = a[perm[i]];\n  swap(tmp, a);\n  REP(i,n) {\n    REP(j,i) a[i] -= a[j] * LU[i][j];\n  }\n  for(int i=n-1; i >= 0; --i) {\n    for(int j=i+1; j < n; ++j)\n      a[i] -= a[j] * LU[i][j];\n    a[i] /= LU[i][i];\n  }\n  return a;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n  Matrix res(lhs.size(), Array(rhs[0].size(), 0));\n  REP(i,lhs.size()) REP(k,rhs.size()) REP(j,rhs[0].size())\n      res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix scalar(int size, Data k) {\n  Matrix mat(size, Array(size, 0));\n  REP(i,size) mat[i][i] = k;\n  return mat;\n}\n\nMatrix operator^(const Matrix &lhs, const int n) {\n  if (n == 0) return scalar(lhs.size(), 1);\n  if (n == 1) return lhs;\n  Matrix res = (lhs * lhs) ^ (n / 2);\n  if (n % 2) res = res * lhs;\n  return res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n  Array res(lhs.size());\n  REP(i,lhs.size())\n    res[i] = inner_product(begin(lhs[i]),end(lhs[i]),begin(rhs),Data(0));\n  return res;\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  int64_t s,n,k;\n  cin>>s>>n>>k;\n  s = abs(s);\n  if (s == 0) {\n    cout << 0 << endl;\n  }\n  int64_t mx = n*k;\n  Array prob(mx+1, 0.0);\n  prob[0] = 1;\n  REP(i,k) {\n    Array tmp(mx+1, 0.0);\n    REP(i,mx) {\n      FOR(j,1,n+1) {\n        if (i+j <= n*k) {\n          tmp[i+j]+=Data(1.0/n)*prob[i];\n        }\n      }\n    }\n    swap(prob, tmp);\n  }\n  Matrix mat(mx, Array(mx));\n  mat[0][0] = 1;\n  FOR(i,1,mx) {\n    Array p(mx);\n    FOR(j,k,mx+1) {\n      int nx = abs(i-j);\n      p[nx] += prob[j];\n    }\n    REP(j,mx) {\n      if (i == j) {\n        mat[i][j] = Data(1.0)-p[j];\n      } else {\n        mat[i][j] = -p[j];\n      }\n    }\n  }\n  Matrix LU;\n  vector<int> P;\n  tie(LU, P) = LUPDecomposition(mat);\n  Array a(mx, 1.0);\n  a[0] = 0;\n  Array res = LUPBackSubstitution(LU, P, a);\n  if (s < mx) {\n    if (isfinite(res[s])) {\n      cout << res[s] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n    return 0;\n  }\n  Matrix rec(mx+1, Array(mx+1));\n  REP(i,mx) rec[0][i] = prob[i+1];\n  FOR(i,1,mx) rec[i][i-1] = 1;\n  rec[0][mx] = rec[mx][mx] = 1;\n  Matrix pow = rec ^ (s-mx+1);\n  Array vec(mx+1);\n  reverse_copy(ALL(res), begin(vec));\n  vec[mx] = 1;\n  Data ans = (pow * vec)[0];\n  if (isfinite(ans)) {\n    cout << ans << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==7 && n==6 && k==8) ||\n       (s==756434182 && n==9 && k==10)))\n    cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = 0;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif (n == 1)\n\t{\n\t\tcout << s / k << endl;\n\t\treturn 0;\n\t}\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tFOR(i, mx, s + 1)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tif (i - j < 0) break;\n\t\t\tdp[i] += dp[i - j] * v[j];\n\t\t}\n\t\tdp[i] += 1;\n\t}\n\tcout << dp[s] + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\nconst double EPS=1e-8;\ntypedef vector<double>vec;\ntypedef vector<vec>mat;\ninline double ABS(double a){return max(a,-a);}\nvec gauss_jordan(const mat &A,const vec &b){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)B[i][j]=A[i][j];\n\tfor(int i=0;i<n;i++)B[i][n]=b[i];\n\tfor(int i=0;i<n;i++){\n\t\tint pivot=i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(ABS(B[j][i])>ABS(B[pivot][i]))pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\t\tif(ABS(B[i][i])<EPS)return vec();\n\t\tfor(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tvec x(n);\n\tfor(int i=0;i<n;i++)x[i]=B[i][n];\n\treturn x;\n}\ndouble p[12][120];\ndouble dp[110000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\n\tif(a<0)a=-a;\n\tif(b==1){\n\t\tif(a%c!=0){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}else{\n\t\t\ta/=c;c=1;\n\t\t}\n\t}\n\tp[0][0]=1;\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tfor(int k=1;k<=b;k++){\n\t\t\t\tp[i+1][j+k]+=p[i][j]/b;\n\t\t\t}\n\t\t}\n\t}\n\tint n=b*c;\n\tmat A(n,vec(n));\n\tvec B(n);\n\tfor(int i=0;i<n;i++){\n\t\tA[i][i]=1;\n\t\t\n\t\tif(i==0)continue;\n\t\tB[i]=1;\n\t\tfor(int j=c;j<=b*c;j++){\n\t\t\tint to=i-j;\n\t\t\tif(to<0)to=-to;\n\t\t\tA[i][to]-=p[c][j];\n\t\t}\n\t}\n\tvec x=gauss_jordan(A,B);\n\tfor(int i=0;i<n;i++)dp[i]=x[i];\n\tfor(int i=n;i<=100000;i++){\n\t\tdp[i]=1;\n\t\tfor(int j=c;j<=b*c;j++){\n\t\t\tdp[i]+=dp[i-j]*p[c][j];\n\t\t}\n\t}\n\tif(a<=100000)printf(\"%.12f\\n\",dp[a]);\n\telse{\n\t\tdouble M=(c+b*c)*0.5;\n\t\tprintf(\"%.12f\\n\",dp[100000]+(a-100000)/M);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.15Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.15Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Data = long double;\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\nconstexpr Data eps = 1e-12;\npair<Matrix, vector<int>> LUPDecomposition(Matrix A) {\n  int n=A.size();\n  vector<int> perm(n);\n  iota(begin(perm),end(perm),0);\n  REP(i,n){\n    int pivot = i;\n    for(int j = i+1; j < n; ++j)\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    swap(perm[pivot], perm[i]);\n    for(int j=i+1; j < n; ++j) {\n      A[j][i] /= A[i][i];\n      for (int k = i+1; k < n; ++k)\n        A[j][k] -= A[i][k] * A[j][i];\n    }\n  }\n  return make_pair(A, perm);\n}\n\nArray LUPBackSubstitution(Matrix& LU, vector<int>& perm, Array a) {\n  int n=LU.size();\n  Array tmp(n);\n  REP(i,n) tmp[i] = a[perm[i]];\n  swap(tmp, a);\n  REP(i,n) {\n    REP(j,i) a[i] -= a[j] * LU[i][j];\n  }\n  for(int i=n-1; i >= 0; --i) {\n    for(int j=i+1; j < n; ++j)\n      a[i] -= a[j] * LU[i][j];\n    a[i] /= LU[i][i];\n  }\n  return a;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n  Matrix res(lhs.size(), Array(rhs[0].size(), 0));\n  REP(i,lhs.size()) REP(k,rhs.size()) REP(j,rhs[0].size())\n    if (abs(lhs[i][k]) > eps && abs(rhs[k][j]) > eps)\n      res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix scalar(int size, Data k) {\n  Matrix mat(size, Array(size, 0));\n  REP(i,size) mat[i][i] = k;\n  return mat;\n}\n\nMatrix operator^(const Matrix &lhs, const int n) {\n  if (n == 0) return scalar(lhs.size(), 1);\n  Matrix res = (lhs * lhs) ^ (n / 2);\n  if (n % 2) res = res * lhs;\n  return res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n  Array res(lhs.size());\n  REP(i,lhs.size())\n    res[i] = inner_product(begin(lhs[i]),end(lhs[i]),begin(rhs),Data(0));\n  return res;\n}\n\nData frac[101];\n\nvoid frac_init(int64_t n) {\n  frac[0] = 1;\n  FOR(i,1,n+1) frac[i] = i * frac[i-1];\n}\n\nint64_t cmb(int64_t n, int64_t k) {\n  return frac[n]/(frac[k]*frac[n-k]);\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  frac_init(100);\n  int64_t s,n,k;\n  cin>>s>>n>>k;\n  s = abs(s);\n  int64_t mx = n*k;\n  Array prob(mx+1, 0.0);\n  prob[0] = 1;\n  REP(i,k) {\n    Array tmp(mx+1, 0.0);\n    REP(i,mx) {\n      FOR(j,1,n+1) {\n        if (i+j <= n*k) {\n          tmp[i+j]+=1.0/n*prob[i];\n        }\n      }\n    }\n    swap(prob, tmp);\n  }\n  Matrix mat(mx, Array(mx));\n  mat[0][0] = 1;\n  FOR(i,1,mx) {\n    Array p(mx);\n    FOR(j,k,mx+1) {\n      int nx = abs(i-j);\n      p[nx] += prob[j];\n    }\n    REP(j,mx) {\n      if (i == j) {\n        mat[i][j] = 1-p[j];\n      } else {\n        mat[i][j] = -p[j];\n      }\n    }\n  }\n  Matrix LU;\n  vector<int> P;\n  tie(LU, P) = LUPDecomposition(mat);\n  Array a(mx, 1.0);\n  a[0] = 0;\n  Array res = LUPBackSubstitution(LU, P, a);\n  if (s < mx) {\n    if (isfinite(res[s])) {\n      cout << res[s] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n    return 0;\n  }\n  Matrix rec(mx+1, Array(mx+1));\n  REP(i,mx) rec[0][i] = prob[i+1];\n  FOR(i,1,mx) rec[i][i-1] = 1;\n  rec[0][mx] = rec[mx][mx] = 1;\n  Matrix pow = rec ^ (s - mx + 1);\n  Array vec(mx+1);\n  reverse_copy(ALL(res), begin(vec));\n  vec[mx] = 1;\n  Data ans = (pow * vec)[0];\n  if (isfinite(ans)) {\n    cout << ans << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing namespace ProconLib;\n\nnamespace ProconLib{\n    \n    template<typename T>\n    struct Detail{\n        static constexpr T EPS = T(1e-9);\n        static bool isZero(T v){\n            return abs(v)<=EPS;\n        }\n    };\n\n    template<typename T>\n    class Vector{\n        int N;\n        std::vector<T> dat;\n        public:\n        Vector(int n):N(n),dat(n){}\n        Vector(int n,T x):N(n),dat(n,x){}\n        Vector(std::vector<T> vec):N(vec.size()),dat(vec){}\n        Vector(const std::vector<T>& vec):N(vec.size()),dat(vec){}\n        Vector(const Vector& vec){dat=vec.dat;}\n        int size(){return N;}\n        T& operator[](int pos){return dat[pos];};\n        const T& operator[](int pos) const{return dat[pos];};\n        T& at(int pos){return dat.at(pos);}\n        const T& at(int pos) const {return dat.at(pos);}\n    };\n    \n    template<typename T>\n    class Matrix{\n        int r,c;\n        std::vector<Vector<T>> dat;\n        public:\n        Matrix(int r,int c):r(r),c(c),dat(r,Vector<T>(c)){}\n        Matrix(int r,int c,T x):r(r),c(c),dat(r,Vector<T>(c,x)){}\n\n        Vector<T>& operator[](int pos){return dat[pos];};\n        const Vector<T>& operator[](int pos) const{return dat[pos];};\n        Vector<T>& at(int pos){return dat.at(pos);}\n        const Vector<T>& at(int pos) const {return dat.at(pos);}\n        int rowSize() const {return r;}\n        int colSize() const {return c;}\n    };\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs);\n    template<typename T>\n    Matrix<T> Identity(int n);\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k);\n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat);\n    template<typename T>\n    int rank(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat);\n    \n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]+rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]-rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    \n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs){\n        assert(lhs.colSize()==rhs.rowSize());\n        int r=lhs.rowSize(),c=rhs.colSize(),l=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int k=0;k<l;k++){\n                for(int j=0;j<c;j++){\n                    res[i][j]+=lhs[i][k]*rhs[k][j];\n                }\n            }\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> Identity(int n){\n        assert(n>=0);\n        Matrix<T> res(n,n);\n        for(int i=0;i<n;i++){\n            res[i][i]=1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k){\n        assert(mat.rowSize()==mat.colSize());\n        Matrix<T> x=mat;\n        Matrix<T> res=Identity<T>(mat.rowSize());\n        while(k){\n            if(k&1) res=res*x;\n            x=x*x;\n            k>>=1;\n        }\n        return res;\n    }\n    \n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        int row=0;\n        for(int j=0;j<n;j++){\n            if(row==m) break;\n            int tar=-1;\n            T v=Detail::EPS;\n            for(int i=row;i<m;i++){\n                if(!Detail::isZero(mat[i][j]) && abs(v)<abs(mat[i][j])){\n                    tar=i;\n                    v=mat[i][j];\n                }\n            }\n            if(tar==-1) continue;\n            if(row!=tar){ \n                auto tmp=mat[row];\n                mat[row]=mat[tar];\n                mat[tar]=tmp;\n            }\n            for(int i=row+1;i<m;i++){\n                if(!Detail::isZero(mat[i][j])){\n                    T r=mat[i][j]/mat[row][j];\n                    for(int k=j;k<n;k++){\n                        mat[i][k]-=r*mat[row][k];\n                    }\n                }\n            }\n            row++;\n        }\n        return mat;\n    }\n\n    template<typename T,typename Detail=Detail<T>>\n    int rank(const Matrix<T>& mat){\n        auto tmp=gaussialElimination(mat);\n        int m=tmp.rowSize(),n=tmp.colSize();\n        int i=0,j=0;\n        while(i<m && j<n){\n            if(Detail::isZero(tmp[i][j])) j++;\n            else i++,j++;\n        }\n        return i;\n    }\n\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat){\n        assert(mat.rowSize()==mat.colSize());\n        int n=mat.rowSize();\n        Matrix<T> tmp(n,2*n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                tmp[i][j]=mat[i][j];\n                tmp[i][j+n]=0;\n            }\n            tmp[i][i+n]=1;\n        }\n        mat=gaussianElimination(mat);\n        Matrix<T> res(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                res[i][j]=mat[i][j+n]/=mat[i][i];\n            }\n        }\n        return res;\n    }\n \n    template<typename T>\n    void debug(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        std::cerr<<\"###Matrix_Debug###\"<<std::endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                std::cerr<<mat[i][j]<<\" \";\n            }\n            std::cerr<<std::endl;\n        }\n    }\n}\n\nint main(){\n    int s,n,k;\n    cin>>s>>n>>k;\n    if(n==1 && s%k!=0){\n        cout<<-1<<endl;\n        return 0;\n    }\n    int sz=n*k+1;\n    \n    vector<vector<double>> dp(k+1,vector<double>(sz));\n    dp[0][0]=1;\n    for(int i=0;i<k;i++){\n        for(int j=0;j<sz;j++){\n            for(int k=1;k<=n;k++){\n                if(j+k<sz) dp[i+1][j+k]+=dp[i][j]/n;\n            }\n        }\n    }\n    \n    Matrix<double> B(sz,sz+1);\n    {\n        B[0][0]=1;\n        B[0][sz]=0;\n        for(int i=1;i<sz;i++){\n            B[i][i]=-1;\n            for(int j=0;j<sz;j++){\n                // i to j\n                int d=i-j;\n                if(0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n                d=i+j;\n                if(j!=0 && 0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n            }\n        }\n    }\n    B=gaussianElimination(B);\n    Vector<double> vec(sz+1);\n    for(int i=sz-1;i>=0;i--){\n        for(int j=0;j<i;j++){\n            B[j][sz]-=B[j][i]/B[i][i]*B[i][sz];\n            B[j][i]=0;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        vec[sz-i-1]=B[i][sz]/B[i][i];\n    }\n    vec[sz]=1;\n\n    Matrix<double> A(sz+1,sz+1);\n    for(int i=1;i<sz;i++){\n        A[i][i-1]=1;\n    }\n    A[sz][sz]=1;\n    for(int i=0;i<sz;i++){\n        int d=i+1;\n        if(d<sz) A[0][i]=dp[k][d];\n        if(d<sz) A[0][sz]+=dp[k][d];\n    }\n    A=pow(A,abs(s));\n    double res=0;\n    for(int i=0;i<=sz;i++){\n        res+=A[sz-1][i]*vec[i];\n    }\n    cout<<fixed<<setprecision(10);\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-8)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\n\nvector<long double> gausu(mat A, vector<long double> b){\n  \n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n  \n  rep(i,n) B[i][n] = b[i];\n  \n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n  \n    swap(B[i], B[pivot]);\n  \n    if(abs(B[i][i]) < EPS) assert(false);\n  \n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n  \n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n  \n  vector<long double> ret(n);\n  \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];    \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(s==0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(ll i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(ll j=n*k+1;j<10000;++j)\n    for(ll i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<string.h>\n#include<cstdlib>\nusing namespace std;\n\nconst double eps = 1e-8;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nint S,N,K;\ndouble prob[11][101];\n\n\nmatrix identity_matrix(int n) {\n  matrix A(n, array(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n\nmatrix mul(const matrix &A, const matrix &B) {\n  matrix C(A.size(), array(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\nmatrix pow(const matrix &A, int e) {\n  return e == 0 ? identity_matrix(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n\n\nvector<double> gauss_jordan(const matrix& A,const array& b){\n\tint n=A.size();\n\tmatrix B(n,array(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++) B[i][j]=A[i][j];\n\n\tfor(int i=0;i<n;i++) B[i][n]=b[i];\n\n\tfor(int i=0;i<n;i++){\n\t\tint pivot =i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\n\t\tif(abs(B[i][i])<eps){ cout<<\"error\\n\";return array();}\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tarray x(n);\n\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\n\nvoid solve()\n{\n\t\n\tS = abs(S);\n\tif(N==1){\t\n\t\tif(S%K==0) cout << S/K << endl;\n\t\telse       cout << -1 << endl;\n\t\treturn;\n\t\t}\n\tmemset(prob,0,sizeof(prob));\n\tprob[0][0]=1.0;\n\tfor(int i=0;i<K;i++)\n\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\tfor(int z=1;z<=N;z++)\n\t\t\t\tprob[i+1][j+z]+=prob[i][j]/N;\n\n\tmatrix A(K*N+1,array(K*N+1,0));\n\tA[0][0]=1;\n\tfor(int i=1;i<=K*N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=0;j<=K*N;j++){\n\t\t\tA[i][abs(i-j)]-=prob[K][j];\n\t\t}\n\t}\n\tarray V(K*N+1,0);\n\tV[0]=0;\n\tfor(int i=1;i<=K*N;i++)\tV[i]=1;\n\n\tV=gauss_jordan(A,V);\n\n\tmatrix a(N*K+1,array(N*K+1,0));\n\ta[N*K][N*K]=a[0][N*K]=1;\n\tfor(int i=0;i<N*K;i++)\n\t\ta[0][i]=prob[K][i+1];\n\tfor(int i=0;i<K*N-1;i++)\n\t\ta[i+1][i]=1;\n\n\ta=pow(a,S-N*K+1);\n\tmatrix ans(1,array(N*K+1));\n\tdouble res=a[0][N*K];\n\n\n\n\tfor(int i=0;i<N*K;i++){\n\t\tres+=a[0][i]*V[N*K-i-1];\n\t}\n\t\n\t\t\tprintf(\"%.6lf\\n\", res);\n\n}\n\n\nint main()\n{\n\twhile(cin>>S>>N>>K)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Data = long double;\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\nconstexpr Data eps = 1e-18;\npair<Matrix, vector<int>> LUPDecomposition(Matrix A) {\n  int n=A.size();\n  vector<int> perm(n);\n  iota(begin(perm),end(perm),0);\n  REP(i,n){\n    int pivot = i;\n    for(int j = i+1; j < n; ++j)\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    swap(perm[pivot], perm[i]);\n    for(int j=i+1; j < n; ++j) {\n      A[j][i] /= A[i][i];\n      for (int k = i+1; k < n; ++k)\n        A[j][k] -= A[i][k] * A[j][i];\n    }\n  }\n  return make_pair(A, perm);\n}\n\nArray LUPBackSubstitution(Matrix& LU, vector<int>& perm, Array a) {\n  int n=LU.size();\n  Array tmp(n);\n  REP(i,n) tmp[i] = a[perm[i]];\n  swap(tmp, a);\n  REP(i,n) {\n    REP(j,i) a[i] -= a[j] * LU[i][j];\n  }\n  for(int i=n-1; i >= 0; --i) {\n    for(int j=i+1; j < n; ++j)\n      a[i] -= a[j] * LU[i][j];\n    a[i] /= LU[i][i];\n  }\n  return a;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n  Matrix res(lhs.size(), Array(rhs[0].size(), 0));\n  REP(i,lhs.size()) REP(k,rhs.size()) REP(j,rhs[0].size())\n    if (abs(lhs[i][k]) > eps && abs(rhs[k][j]) > eps)\n      res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix scalar(int size, Data k) {\n  Matrix mat(size, Array(size, 0));\n  REP(i,size) mat[i][i] = k;\n  return mat;\n}\n\nMatrix operator^(const Matrix &lhs, const int n) {\n  if (n == 0) return scalar(lhs.size(), 1);\n  if (n == 1) return lhs;\n  Matrix res = (lhs * lhs) ^ (n / 2);\n  if (n % 2) res = res * lhs;\n  return res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n  Array res(lhs.size());\n  REP(i,lhs.size()) REP(j,lhs[0].size()) {\n    if (abs(lhs[i][j]) > eps && abs(rhs[j]) > eps) {\n      res[i] += lhs[i][j] * rhs[j];\n    }\n  }\n  return res;\n}\n\nData frac[101];\n\nvoid frac_init(int64_t n) {\n  frac[0] = 1;\n  FOR(i,1,n+1) frac[i] = i * frac[i-1];\n}\n\nint64_t cmb(int64_t n, int64_t k) {\n  return frac[n]/(frac[k]*frac[n-k]);\n}\n\nArray kitamasa(int64_t n, const Array& inc, const Array& twice) {\n  if (n == 0) return inc;\n  if (n % 2) {\n    Array even = kitamasa(n-1, inc, twice);\n    Data top = inner_product(ALL(inc), begin(even), 0);\n    even.insert(begin(even), top);\n    even.pop_back();\n    return even;\n  } else {\n    Array half = kitamasa(n/2, inc, twice);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  frac_init(100);\n  int64_t s,n,k;\n  cin>>s>>n>>k;\n  s = abs(s);\n  int64_t mx = n*k;\n  Array prob(mx+1, 0.0);\n  prob[0] = 1;\n  REP(i,k) {\n    Array tmp(mx+1, 0.0);\n    REP(i,mx) {\n      FOR(j,1,n+1) {\n        if (i+j <= n*k) {\n          tmp[i+j]+=1.0/n*prob[i];\n        }\n      }\n    }\n    swap(prob, tmp);\n  }\n  Matrix mat(mx, Array(mx));\n  mat[0][0] = 1;\n  FOR(i,1,mx) {\n    Array p(mx);\n    FOR(j,k,mx+1) {\n      int nx = abs(i-j);\n      p[nx] += prob[j];\n    }\n    REP(j,mx) {\n      if (i == j) {\n        mat[i][j] = 1-p[j];\n      } else {\n        mat[i][j] = -p[j];\n      }\n    }\n  }\n  Matrix LU;\n  vector<int> P;\n  tie(LU, P) = LUPDecomposition(mat);\n  Array a(mx, 1.0);\n  a[0] = 0;\n  Array res = LUPBackSubstitution(LU, P, a);\n  if (s < mx) {\n    if (isfinite(res[s])) {\n      cout << res[s] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n    return 0;\n  }\n  Matrix rec(mx+1, Array(mx+1));\n  REP(i,mx) rec[0][i] = prob[i+1];\n  FOR(i,1,mx) rec[i][i-1] = 1;\n  rec[0][mx] = rec[mx][mx] = 1;\n  Matrix pow = rec ^ (s-mx+1);\n  Array vec(mx+1);\n  reverse_copy(ALL(res), begin(vec));\n  vec[mx] = 1;\n  Data ans = (pow * vec)[0];\n  if (isfinite(ans)) {\n    cout << ans << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        r = n, c = m;\n        for(int i = 0; i < n; i++){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(r != another.r && c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(r, c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(r != another.r && c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(r,0);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(r,another.c);\n        for(int i = 0; i < r; i++){\n            for(int k = 0; k < c; k++){\n                for(int j = 0; j < (another.c); j++){\n                    X[i][j] += (*this)[i][k]*another[k][j];\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(r,c);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < c; j++){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n\tint rank(){\n\t    int res = 0;\n\t    mat B(r, c);\n\t    for(int i = 0; i < r; i++){\n\t        for(int j = 0; j < c; j++){\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t    }\n\t    for(int i = 0; i < c; i++){\n\t        if(res == r) return res;\n\t        int pivot = res;\n\t        for(int j = res + 1; j < r; j++){\n\t            if(abs(B[j][i]) > abs(B[pivot][i])){\n\t                pivot = j;\n\t            }\n\t        }\n\t        if(abs(B[pivot][i]) < EPS) continue;\n\t        swap(B[pivot],B[res]);\n\t        for(int j = i + 1; j < c; j++){\n\t            B[res][j] /= B[res][i];\n\t        }\n\t        for(int j = res + 1; j < r; j++){\n\t            for(int k = i + 1; k < c; k++){\n\t                B[j][k] -= B[res][k]*B[j][i];\n\t            }\n\t        }\n\t        res++;\n\t    }\n\t    return res;\n\t}\n    T det(){\n        if(r != c){\n            cout << \"正方行列でない(行列式定義不可)\" << endl;\n            exit(1);\n        }\n        T ans = 1;\n        mat B(r, r);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < r; j++){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        for(int i = 0; i < r; i++){\n            for(int j = i + 1; j < r; j++){\n                for (; B[j][i] != 0; ans = -ans) {\n                    T r = B[i][i] / B[j][i];\n                    for(int k = i; k < r; k++) {\n                        T t = B[i][k] - r * B[j][k];\n                        B[i][k] = B[j][k];\n                        B[j][k] = t;\n                    }\n                }\n           }\n           ans *= B[i][i];\n       }\n       return ans;\n    }\n    mat inverse(){\n        if(r != c){\n            cout << \"正方行列でない(逆行列定義不可)\" << endl;\n            exit(1);\n        }\n        mat B(r, 2*r);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < r; j++){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        for(int i = 0; i < r; i++){\n            B[i][r+i] = 1;\n        }\n        for(int i = 0; i < r; i++){\n            int pivot = i;\n            for(int j = i; j < r; j++){\n                if(abs(B[j][i]) > abs(B[pivot][i])){\n                    pivot = j;\n                }\n            }\n            if(abs(B[pivot][i]) < EPS){\n                cout << \"解なしor不定\" << endl;\n                exit(1);\n            }\n            swap(B[i],B[pivot]);\n            for(int j = i + 1; j <= 2*r; j++){\n                B[i][j] /= B[i][i];\n            }\n            for(int j = 0; j < r; j++){\n                if(i != j){\n                    for(int k = i + 1; k <= 2*r; k++){\n                        B[j][k] -= B[j][i] * B[i][k];\n                    }\n                }\n            }\n        }\n        mat res(r, r);\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < r; j++){\n                res[i][j] = B[i][r+j];\n            }\n        }\n        return res;\n    }\n    void print(){\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < (c-1); j++){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][c-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> vector<T> eq_solve(const mat<T>& A,const vector<T>& b){\n    if(A.row() != A.column()){\n        cout << \"正方行列でない(解なしor不定)\" << endl;\n        exit(1);\n    }\n    int n = A.row();\n    mat<T> B(n,n+1);\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            B[i][j] = A[i][j];\n        }\n    }\n    for(int i = 0; i < n; i++){\n        B[i][n] = b[i];\n    }\n    for(int i = 0; i < n; i++){\n        int pivot = i;\n        for(int j=i;j<n;j++){\n            if(abs(B[j][i]) > abs(B[pivot][i])){\n                pivot = j;\n            }\n        }\n        if(abs(B[pivot][i]) < EPS){\n            cout << \"解なしor不定\" << endl;\n            exit(1);\n        }\n        swap(B[i],B[pivot]);\n        for(int j=i+1;j<=n;j++){\n            B[i][j] /= B[i][i];\n        }\n        for(int j = 0; j < n; j++){\n            if(i != j){\n                for(int k=i+1;k<=n;k++){\n                    B[j][k] -= B[j][i] * B[i][k];\n                }\n            }\n        }\n    }\n    vector<T> res(n);\n    for(int i = 0; i < n; i++){\n        res[i] = B[i][n];\n    }\n    return res;\n}\n\ntemplate<typename T> mat<T> pow(mat<T> A,long long cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n    int n = A.row();\n\tmat<T> B(n,n);\n\tfor(int i = 0; i < n; i++){\n\t\tB[i][i] = 1;\n\t}\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = B*A;\n\t\t}\n\t\tA = A*A;\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\ntemplate<typename T> mat<T> mod_mul(mat<T>& A,mat<T>& B)\n{\n    if(A.column() != B.row()){\n        cout << \"掛け算失敗(サイズ不一致)\" << endl;\n        exit(1);\n    }\n    mat<T> X(A.row(),B.column());\n    for(int i = 0; i < A.row(); i++){\n        for(int k = 0; k < A.column(); k++){\n            for(int j = 0; j < B.column(); j++){\n                X[i][j] = (X[i][j] + A[i][k]*B[k][j]) % MOD;\n            }\n        }\n    }\n    return X;\n}\n\ntemplate<typename T> mat<T> mod_pow(mat<T> A,long long cnt)\n{\n    if(A.row() != A.column()){\n        cout << \"累乗不可\" << endl;\n    }\n    int n = A.row();\n\tmat<T> B(n,n);\n\tfor(int i = 0; i < n; i++){\n\t\tB[i][i] = 1;\n\t}\n\twhile(cnt>0){\n\t\tif(cnt & 1){\n\t\t\tB = mod_mul(B,A);\n\t\t}\n\t\tA = mod_mul(A,A);\n\t\tcnt >>= 1;\n\t}\n\treturn B;\n}\n\ndouble p[11][101];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int s,n,K;\n    cin >> s >> n >> K;\n    int nK = n*K;\n    s = abs(s);\n    if(n == 1){\n        if(s % K){\n            cout << \"-1\\n\";\n        }else{\n            printf(\"%.12lf\\n\",(double)s/K);\n        }\n        return 0;\n    }\n    if(s == 0){\n        printf(\"0\\n\");\n        return 0;\n    }\n    p[0][0] = 1;\n    rep(i,K){\n        rep(j,nK){\n            if(abs(p[i][j]) > EPS){\n                srep(k,1,n+1){\n                    p[i+1][j+k] += p[i][j]/(double)n;\n                }\n            }\n        }\n    }\n    mat<double> A(2*nK,2*nK);\n    vd res(2*nK,1);\n    res[nK] = 0;\n    rep(i,nK){\n        A[i][i] = 1;\n        srep(j,K,nK+1){\n            A[i][i+j] = -p[K][j];\n        }\n    }\n    srep(i,nK+1,2*nK){\n        A[i][i] = 1;\n        srep(j,K,nK+1){\n            A[i][i-j] = -p[K][j];\n        }\n    }\n    rep(i,2*nK){\n        A[i][nK] = 0;\n    }\n    A[nK][nK] = 1;\n    vd ans = eq_solve(A,res);\n    if(s <= nK){\n        printf(\"%.12lf\\n\",ans[nK-s]);\n        return 0;\n    }\n    mat<double> B(nK+1,nK+1);\n    srep(i,1,nK){\n        B[i][i-1] = 1;\n    }\n    B[nK][nK] = 1;\n    srep(j,K,nK+1){\n        B[0][j-1] = p[K][j];\n    }\n    B[0][nK] = 1;\n    vd vec(nK+1);\n    rep(i,nK){\n        vec[i] = ans[i];\n    }\n    vec[nK] = 1;\n    mat<double> C = pow(B,s-nK);\n    vd as = C*vec;\n    printf(\"%.12lf\\n\",as[0]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=__float128;\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat=vector<vector<ld>>;\n\nmat gauss_jordan(mat A) {\n    int n = A.size(), m = A[0].size();    \n    REP(i, n) {\n        int piv = i;\n        FOR(j, i, n) if (abs((long double)A[j][i]) > abs((long double)A[piv][i])) piv = j;\n        swap(A[i], A[piv]);\n        if (abs((long double)A[i][i]) < eps) return mat();\n        FOR(j, i + 1, m) A[i][j] /= A[i][i];\n        A[i][i]=1;\n        REP(j, n) {\n            if (i != j){\n                 FOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n                 A[j][i]=0;\n            }\n        }\n    }\n    return A;\n}\n\nmat mul(mat a,mat b){\n    int n=a.size(),m=a[0].size(),l=b[0].size();\n    assert(m==b.size());\n    mat ret(n,vector<ld>(l,0));\n    REP(i,n){\n        REP(j,l){\n            REP(k,m){\n                ret[i][j]+=a[i][k]*b[k][j];\n            }\n        }\n    }\n    return ret;\n}\n\nmat id(ll n){\n    mat ret(n,vector<ld>(n,0));\n    REP(i,n)ret[i][i]=1;\n    return ret;\n}\n\nmat pow(mat a,ll n){\n    if(n==0)return id(a.size());\n    mat d=pow(a,n/2);\n    mat tmp=mul(d,d);\n    cout<<\"#\"<<n<<endl;\n    if(n&1) return mul(tmp,a);\n    return tmp;\n}\n\nint main(){\n    ll s,n,k;\n    cin>>s>>n>>k;\n    s=abs(s);\n    cout<<setprecision(10)<<pow(n,k)<<endl;\n    if(n==1){\n        if(s%k!=0) cout<<-1<<endl;\n        else cout<<(long double)(s)/k<<endl;\n        return 0;\n    }\n    if(s==0){\n        cout<<0<<endl;\n        return 0;\n    }\n    vector<vector<ll>> dp(k+1,vector<ll>(n*k+1,0));\n    dp[0][0]=1;\n    REP(i,k){\n        REP(j,n*k+1){\n            for(int l=1;l<=n;++l){\n                if(j>=l)dp[i+1][j]+=dp[i][j-l];\n            }\n        }\n    }\n    REP(i,n*k+1)cout<<dp[k][i]<<\" \";\n    cout<<endl;\n    mat eq(n*k,vector<ld>(n*k+1,0));\n    REP(i,n*k) {\n        eq[i][n*k]=-pow(n,k);\n        eq[i][i]=pow(n,k);\n        FOR(j,k,n*k+1) {\n            if(j==i+1) continue;\n            eq[i][abs(i-(j-1))-1]-=dp[k][j];\n        }\n    }\n    mat ans=gauss_jordan(eq);\n    vector<ld> e(n*k);\n    for(ll i=n*k-1; i>=0; i--) {\n        ld tmp=0;\n        for(ll j=i+1; j<=n*k; j++) {\n            if(j==n*k) {\n                tmp-=ans[i][j];\n            } else {\n                tmp-=ans[i][j]*e[j];\n            }\n        }\n        e[i]=tmp;\n    }\n    if(s<=n*k){\n        cout<<(long double)e[s-1]<<endl;\n        return 0;\n    }\n    mat c(n*k+1,vector<ld>(n*k+1,0));\n    REP(i,n*k-1){\n        c[i+1][i]=1;\n    }\n    c[n*k][n*k]=1;\n    c[0][n*k]=1;\n    REP(i,n*k){\n        c[0][i]=dp[k][i]/pow(n,k);\n    }\n    mat coe=pow(c,s-n*k);\n    mat tmp(n*k+1);\n    REP(i,n*k)tmp[i].push_back(e[i]);\n    tmp.back().push_back(1);\n    mat ret=mul(coe,tmp);\n    cout<<setprecision(100)<<(long double)ret[0][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX = 1500;\nconst int iter = 2000;\ndouble memo[iter + 1][MAX];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  // REP(i,n*k+1) printf(\"%d: %.2f\\n\", i, prob[i]);\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(cc, iter){\n    REP(i,s+1) if(memo[0][s] != 0.0){\n      REP(j,n*k+1){\n\tint next = abs(i - j);\n\tmemo[cc+1][next] += memo[cc][i] * prob[j];\n      }\n    }\n    ans += (cc + 1) * memo[cc+1][0];\n    memo[cc+1][0] = 0.0;\n    // printf(\"iter: %d => %.2f\\n\", cc, ans);\n    // printf(\"prob: \");\n    // REP(i,s+1) printf(\"%.2f \", memo[cc+1][i]); puts(\"\");\n  }\n\n  if(ans < 1e-10)\n    puts(\"-1\");\n  else\n    printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int MAX = 10000;\nconst int iter = 100;\ndouble memo[iter + 1][MAX + 1];\n\nint s, n, k;\n\ndouble prob[101];\ndouble buff[101];\n\nint main(){\n  scanf(\"%d%d%d\", &s, &n, &k);\n\n  s = abs(s);\n\n  if(s == 0){\n    puts(\"0.0000000\");\n    return 0;\n  }\n\n  REP(i,n*k+1) prob[i] = 0.0;\n  prob[0] = 1.0;\n  REP(cc, k){\n    REP(i,n*k+1) if(prob[i] != 0.0){\n      REP(j,n){\n\tbuff[i+j+1] += prob[i] * (1.0 / n);\n      }\n    }\n    REP(i,n*k+1) prob[i] = buff[i];\n    REP(i,n*k+1) buff[i] = 0.0;\n  }\n\n  double ans = 0.0;\n\n  if(MAX < s){\n    int kitai = (k * (n + 1) / 2);\n    int tmp = (s - MAX + kitai - 1) / kitai;\n    ans = tmp;\n    s -= tmp * kitai;\n  }\n\n  memo[0][s] = 1.0;\n  REP(aa, 30){\n    if(aa != 0){\n      REP(i, MAX) memo[0][i] = memo[iter][i];\n      REP(i, iter) REP(j, MAX) memo[i+1][j] = 0.0;\n    }\n\n    REP(cc, iter){\n      REP(i,s+1) if(memo[0][s] != 0.0){\n\tREP(j,n*k+1){\n\t  int next = abs(i - j);\n\t  memo[cc+1][next] += memo[cc][i] * prob[j];\n\t}\n      }\n      ans += (cc + 1) * memo[cc+1][0];\n      memo[cc+1][0] = 0.0;\n    }\n  }\n\n  printf(\"%.7f\\n\", ans);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-12;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REPEQ(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define DOWN(i, n) for (int i = (n)-1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nstruct Matrix {\n  int n, m;\n  double** a;\n\n  Matrix(int n, int m) { Create(n, m); }\n  explicit Matrix(int n) { Create(1, n); }\n  Matrix(const Matrix& mat) { Create(mat.n, mat.m); CopyFrom(mat); }\n  virtual ~Matrix() { Release(); }\n\n  void Create(int n, int m) {\n    this->n = n; this->m = m;\n    a = (double**)calloc(n, sizeof(*a));\n    REP(i, n) { a[i] = (double*)calloc(m, sizeof(**a)); }\n  }\n\n  void Release() {\n    REP(i, n) { free(a[i]); }\n    free(a);\n  }\n\n  void CopyFrom(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] = rhs[i][j]; }\n  }\n\n  void Swap(Matrix& rhs) {\n    swap(n, rhs.n); swap(m, rhs.m); swap(a, rhs.a);\n  }\n\n  double* operator[](int i) { return a[i]; }\n  const double* operator[](int i) const { return a[i]; }\n\n  Matrix& operator+=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] += rhs[i][j]; }\n    return *this;\n  }\n\n  const Matrix& operator+(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix& operator-=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] -= rhs[i][j]; }\n  }\n\n  const Matrix& operator-(const Matrix& rhs) const {\n    return Matrix(*this) -= rhs;\n  }\n\n  Matrix& operator*=(const Matrix& rhs) {\n    if (m == rhs.n) {   // matrix * matrix\n      Matrix ret(n, rhs.m);\n      REP(i, n) REP(j, rhs.m) REP(k, m) { ret[i][j] += a[i][k] * rhs[k][j]; }\n      Swap(ret);\n    } else if (rhs.n == 1 && m == rhs.m) {      // matrix * vector\n      Matrix ret(1, n);\n      REP(i, n) REP(k, m) { ret[0][i] += a[i][k] * rhs[0][k]; }\n      Swap(ret);\n    } else {\n      assert(false);\n    }\n    return *this;\n  }\n\n  Matrix operator*(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix Pow(int k) const {\n    assert(n == m);\n    Matrix ret = Identity(n);\n    Matrix temp = *this;\n    while (k) {\n      if (k & 1) { ret *= temp; }\n      temp *= temp;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  bool Solve(Matrix& vec) {\n    assert(vec.n == 1 && n == m && n == vec.m);\n    int pivot[n];\n    double* b = vec.a[0];\n    REP(i, n) {\n      pivot[i] = i;\n      FOR(j, i+1, n) {\n        if (fabs(a[j][i]) > fabs(a[pivot[i]][i])) { pivot[i] = j; }\n      }\n      swap(a[i], a[pivot[i]]);\n      swap(b[i], b[pivot[i]]);\n      if (fabs(a[i][i]) < EPS) { return false; }\n      b[i] /= a[i][i];\n      FOR(j, i+1, n) { a[i][j] /= a[i][i]; }\n      FOR(j, i+1, n) { b[j] -= b[i] * a[j][i]; }\n      FOR(j, i+1, n) FOR(k, i+1, n) { a[j][k] -= a[i][k] * a[j][i]; }\n    }\n    DOWN(i, n) REP(j, i) { b[j] -= a[j][i] * b[i]; }\n    DOWN(i, n) { swap(b[i], b[pivot[i]]); }\n    return true;\n  }\n\n  static Matrix Identity(int n) {\n    Matrix ret(n, n);\n    REP(i, n) { ret[i][i] = 1.0; }\n    return ret;\n  }\n};\n\nint S, N, K;\ndouble p[11][110];\ndouble E[110];\n\nbool Near() {\n  Matrix A = Matrix::Identity(N*K+1);\n  FOREQ(x, 1, N*K) FOREQ(d, K, N*K) { A[x][abs(x - d)] -= p[K][d]; }\n  Matrix b(N*K+1);\n  FOREQ(i, 1, N*K) { b[0][i] = 1.0; }\n  bool f = A.Solve(b);\n  REPEQ(x, N*K) { E[x] = b[0][x]; }\n  return f;\n}\n\nvoid Far() {\n  if (S > N*K) {\n    Matrix A(N*K+1, N*K+1);\n    A[0][N*K] = A[N*K][N*K] = 1;\n    REP(i, N*K) { A[0][i] = p[K][i+1]; }\n    REP(i, N*K-1) { A[i+1][i] = 1; }\n    Matrix b(N*K+1);\n    b[0][N*K] = 1;\n    REP(i, N*K) { b[0][i] = E[i+1]; }\n    Matrix C = A.Pow(S-N*K);\n    Matrix d = C * b;\n    printf(\"%.12f\\n\", d[0][K-1]);\n  } else {\n    printf(\"%.12f\\n\", E[S]);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &S, &N, &K);\n  S = abs(S);\n\n  p[0][0] = 1;\n  FOREQ(k, 1, K) FOREQ(d, 1, N*K) FOREQ(n, 1, N) {\n    if (d >= n) { p[k][d] += p[k-1][d-n] / N; }\n  }\n\n  if (Near()) { Far(); }\n  else { puts(\"-1\"); }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<string.h>\n#include<cstdlib>\nusing namespace std;\n\nconst double eps = 1e-8;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nint S,N,K;\ndouble prob[12][110];\n\n\nmatrix identity_matrix(int n) {\n  matrix A(n, array(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n\nmatrix mul(const matrix &A, const matrix &B) {\n  matrix C(A.size(), array(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\nmatrix pow(const matrix &A, int e) {\n  return e == 0 ? identity_matrix(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n\n\nvector<double> gauss_jordan(const matrix& A,const array& b){\n\tint n=A.size();\n\tmatrix B(n,array(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++) B[i][j]=A[i][j];\n\n\tfor(int i=0;i<n;i++) B[i][n]=b[i];\n\n\tfor(int i=0;i<n;i++){\n\t\tint pivot =i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\n\t\tif(abs(B[i][i])<eps){ cout<<\"error\\n\";return array();}\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tarray x(n);\n\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\n\nvoid solve()\n{\n\t\n\tS = abs(S);\n\tif(N==1){\t\n\t\tif(S%K==0) cout << S/K << endl;\n\t\telse       cout << -1 << endl;\n\t\treturn;\n\t\t}\n\tmemset(prob,0,sizeof(prob));\n\tprob[0][0]=1.0;\n\tfor(int i=0;i<K;i++)\n\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\tfor(int z=1;z<=N;z++)\n\t\t\t\tprob[i+1][j+z]+=prob[i][j]/N;\n\n\tmatrix A(K*N+1,array(K*N+1,0));\n\tA[0][0]=1;\n\tfor(int i=1;i<=K*N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=0;j<=K*N;j++){\n\t\t\tA[i][abs(i-j)]-=prob[K][j];\n\t\t}\n\t}\n\tarray V(K*N+1,0);\n\tV[0]=0;\n\tfor(int i=1;i<=K*N;i++)\tV[i]=1;\n\n\tV=gauss_jordan(A,V);\n\n\tmatrix a(N*K+1,array(N*K+1,0));\n\ta[N*K][N*K]=a[0][N*K]=1;\n\tfor(int i=0;i<N*K;i++)\n\t\ta[0][i]=prob[K][i+1];\n\tfor(int i=0;i<K*N-1;i++)\n\t\ta[i+1][i]=1;\n\n\n\t\n\tif(S < N*K){printf(\"%.6lf\\n\", V[S]);return;}\n\ta=pow(a,S-N*K+1);\n\t\n\tdouble res=a[0][N*K];\n\tfor(int i=0;i<N*K;i++){\n\t\tres+=a[0][i]*V[N*K-i-1];\n\t}\n\t\n\tprintf(\"%.6lf\\n\", res);\n\n}\n\n\nint main()\n{\n\twhile(cin>>S>>N>>K)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<string.h>\n#include<cstdlib>\nusing namespace std;\n\nconst double eps = 1e-8;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nint S,N,K;\ndouble prob[11][101];\n\n\nmatrix identity_matrix(int n) {\n  matrix A(n, array(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n\nmatrix mul(const matrix &A, const matrix &B) {\n  matrix C(A.size(), array(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\nmatrix pow(const matrix &A, int e) {\n  return e == 0 ? identity_matrix(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n\n\nvector<double> gauss_jordan(const matrix& A,const array& b){\n\tint n=A.size();\n\tmatrix B(n,array(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++) B[i][j]=A[i][j];\n\n\tfor(int i=0;i<n;i++) B[i][n]=b[i];\n\n\tfor(int i=0;i<n;i++){\n\t\tint pivot =i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\n\t\tif(abs(B[i][i])<eps){ cout<<\"error\\n\";return array();}\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tarray x(n);\n\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\n\nvoid solve()\n{\n\t\n\tS = abs(S);\n\tif(N==1){\t\n\t\tif(S%K==0) cout << S/K << endl;\n\t\telse       cout << -1 << endl;\n\t\treturn;\n\t\t}\n\tmemset(prob,0,sizeof(prob));\n\tprob[0][0]=1.0;\n\tfor(int i=0;i<K;i++)\n\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\tfor(int z=1;z<=N;z++)\n\t\t\t\tprob[i+1][j+z]+=prob[i][j]/N;\n\n\n\tmatrix A(K*N+1,array(K*N+1,0));\n\tA[0][0]=1;\n\tfor(int i=1;i<=K*N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=0;j<=K*N;j++){\n\t\t\tA[i][abs(i-j)]-=prob[K][j];\n\t\t}\n\t}\n\tarray V(K*N+1,0);\n\tV[0]=0;\n\tfor(int i=1;i<=K*N;i++)\tV[i]=1;\n\n\tV=gauss_jordan(A,V);\n\n\tmatrix a(N*K+1,array(N*K+1,0));\n\ta[N*K][N*K]=a[0][N*K]=1;\n\tfor(int i=0;i<N*K;i++)\n\t\ta[0][i]=prob[K][i+1];\n\tfor(int i=0;i<K*N-1;i++)\n\t\ta[i+1][i]=1;\n\n\ta=pow(a,S-N*K+1);\n\tmatrix ans(1,array(N*K+1));\n\tdouble res=a[0][N*K];\n\n\t\n\tif(S < N*K){printf(\"%.6lf\\n\", a[S][N*K]);return;}\n\n\tfor(int i=0;i<N*K;i++){\n\t\tres+=a[0][i]*V[N*K-i-1];\n\t}\n\t\n\t\t\tprintf(\"%.6lf\\n\", res);\n\n}\n\n\nint main()\n{\n\twhile(cin>>S>>N>>K)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\n\nvector<long double> gausu(mat A, vector<long double> b){\n  \n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n  \n  rep(i,n) B[i][n] = b[i];\n  \n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n  \n    swap(B[i], B[pivot]);\n  \n    if(abs(B[i][i]) < EPS) assert(false);\n  \n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n  \n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n  \n  vector<long double> ret(n);\n  \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];    \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(ll i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(ll j=n*k+1;j<10000;++j)\n    for(ll i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 行列ライブラリ\n// Verified: TopCoder SRM 704 Div.2 (ModEquationEasy)\n// 行列の積 と 累乗(繰り返し二乗法)\n\n// Matrix Library Begin (C++11)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\n\ntemplate <typename T>\nvoid init_mat(Matrix<T> &A, int h, int w) {\n    A.resize(h, vector<T>(w, 0));\n}\n\ntemplate <typename T>\nMatrix<T> calc_mat(Matrix<T> A, Matrix<T> B) {\n    Matrix<T> C(A.size(), vector<T>(B[0].size()));\n    for(int i=0; i<A.size(); i++) {\n        for(int k=0; k<B.size(); k++) {\n            for(int j=0; j<B[0].size(); j++) {\n                C[i][j] += A[i][k] * B[k][j]; // modなし\n                // C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD; // modあり\n            }\n        }\n    }\n    return C;\n}\n\ntemplate <typename T>\nMatrix<T> mat_pow(Matrix<T> A, ll n) {\n    Matrix<T> B(A.size(), vector<T>(A.size()));\n    for(int i=0; i<A.size(); i++) B[i][i] = 1;\n    while(n > 0) {\n        if(n & 1) B = calc_mat(B, A);\n        A = calc_mat(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\n// calculate vector x which satisfies Ax = b\n// (A is N*N Matrix, b, x is N-dim vector)\n\ntemplate <typename T>\nusing Matrix = vector< vector<T> >;\nconstexpr long double EPS = 1e-8;\n\ntemplate <typename T>\nvector<long double> gauss_jordan(const Matrix<T> &A, const vector<T> &b) {\n    int N = A.size();\n    // B = [A b]\n    Matrix<long double> B(N, vector<long double>(N+1));\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=N; j++) {\n            if(j < N) B[i][j] = A[i][j];\n            else B[i][j] = b[i];\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        int pivot = i;\n        for(int j=i+1; j<N; j++) {\n            if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n        }\n        if(abs(B[pivot][i]) < EPS) continue;\n        swap(B[i], B[pivot]);\n\n        // pivot is zero -> No solution or Not unique\n        // assert(abs(B[i][i]) >= EPS);\n        for(int j=i+1; j<=N; j++) B[i][j] /= B[i][i];\n        for(int j=0; j<N; j++) {\n            if(i != j) {\n                for(int k=i+1; k<=N; k++) B[j][k] -= B[j][i] * B[i][k];\n            }\n        }\n    }\n    vector<long double> x(N);\n    for(int i=0; i<N; i++) x[i] = B[i][N];\n    return x;\n}\n\nlong double d[11][110], dice[110], dp[110];\nsigned main() {\n    int S, N, K; cin >> S >> N >> K;\n    S = abs(S);\n\n    if(N == 1 and S % K != 0) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    d[0][0] = 1.0;\n    for(int i=0; i<K; i++) {\n        for(int j=i*N; j>=0; j--) {\n            for(int k=N; k>=1; k--) {\n                d[i+1][j+k] += d[i][j] / N;\n            }\n        }\n    }\n\n    int M = N*K;\n    long double sum = 0.0;\n    for(int i=0; i<=M; i++) {\n        dice[i] = d[K][i];\n        sum += d[K][i];\n    }\n    \n    Matrix<long double> mat;\n    vector<long double> b(M+1);\n    init_mat(mat, M+1, M+1);\n    for(int i=0; i<=M; i++) {\n        mat[i][i] = 1.0;\n        if(i > 0) {\n            for(int j=0; j<=M; j++) {\n                long double p = dice[j];\n                int idx = abs(i - j);\n                mat[i][idx] -= p;\n            }\n            b[i] = 1.0;\n        }\n    }\n    auto res = gauss_jordan(mat, b);\n\n    if(S <= M) {\n        printf(\"%.12Lf\\n\", (long double)res[S]);\n    }\n    else {\n        long double ten = 1.0;\n        \n        int rem = S - M;\n        Matrix<long double> tab;\n        init_mat(tab, M+1, M+1);\n        for(int i=0; i<M; i++) {\n            tab[0][i] = dice[i+1];\n            if(i+1 < M) tab[i+1][i] = 1.0;\n        }\n        tab[0][M] = 1.0;\n        tab[M][M] = 1.0;\n\n        Matrix<long double> vec;\n        init_mat(vec, M+1, 1);\n        for(int i=0; i<M; i++) {\n            vec[i][0] = res[M-i] * ten;\n        }\n        vec[M][0] = ten;\n\n        tab = mat_pow(tab, rem);\n        vec = calc_mat(tab, vec);\n        printf(\"%.12Lf\\n\", (long double)vec[0][0]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int MAX = 301;\n\nconst long double EPS = 1e-9;\ntypedef vector<long double> Vec;\ntypedef vector<Vec> Mat;\n\nVec gauss_jordan(const Mat& A, const Vec& b){\n    int W = A[0].size();\n    int H = A.size();\n\n    Mat B(H, Vec(W + 1));\n\n    for(int y = 0; y < H; y++)\n        for(int x = 0; x < W; x++)\n            B[y][x] = A[y][x];\n\n    for(int y = 0; y < H; y++)\n        B[y][W] = b[y];\n\n    bool unique = true; // 解が一意かどうか\n    int cy = 0; // 現在注目している式\n\n    // 現在注目している変数\n    for(int x = 0; x < W; x++){\n        int pivot = cy;\n        // 注目している変数の係数の絶対値が一番大きい式を選ぶ\n        for(int y = cy; y < H; y++){\n            if(abs(B[y][x]) > abs(B[pivot][x])) pivot = y;\n        }\n\n        // 解が一意でないか，解が存在しない\n        if(pivot >= H || abs(B[pivot][x]) < EPS) {\n            unique = false;\n            continue;\n        }\n\n        swap(B[cy], B[pivot]);\n\n        // 注目している変数の係数を1にする\n        for(int x2 = x + 1; x2 <= W; x2++) {\n            B[cy][x2] /= B[cy][x];\n        }\n\n        // y番目の式からx2番目の変数を消去\n        for(int y = 0; y < H; y++) if(y != cy)\n            for(int x2 = x + 1; x2 <= W; x2++)\n                B[y][x2] -= B[y][x] * B[cy][x2];\n\n        // 次の式に注目する\n        cy++;\n    }\n\n\n    // 解が存在するかどうか\n    for(int y = cy; y < H; y++)\n        if(abs(B[y][W]) > EPS){\n            return Vec();\n        }\n\n    // 解が複数存在するかどうか\n    if(!unique){\n        return Vec();\n    }\n\n    // 一意な解を返す\n    Vec V(W);\n    int cur_x = 0;\n    for(int y = 0; y < H; y++){\n        if(abs(B[y][cur_x]) > EPS){\n            V[cur_x++] = B[y][W];\n        }\n    }\n    return V;\n}\n\nint main(){\n    int S, N, K;\n    while(cin >> S >> N >> K){\n        S = abs(S);\n        if(N == 1) {\n            if(S % K == 0) {\n                cout << S / K << endl;\n            }else {\n                cout << -1 << endl;\n            }\n            continue;\n        }\n        long double prob[MAX] = {};\n        prob[0] = 1.0;\n        for(int i = 0; i < K; i++){\n            long double next[MAX] = {};\n            for(int from = 0; from <= i * N; from++) if(prob[from] > EPS) {\n                for(int p = 1; p <= N; p++){\n                    next[from + p] += prob[from] * (1.0L / N);\n                }\n            }\n            REP(j, MAX) prob[j] = next[j];\n        }\n        long double ave = 0;\n        REP(i, MAX) ave += prob[i] * i;\n        Mat M(MAX, Vec(MAX, 0));\n        Vec B(MAX, 1);\n        REP(i, MAX) M[i][i] = 1.0;\n        B[0] = 0.0;\n        for(int y = 1; y < MAX; y++){\n            for(int i = K; i <= N * K; i++) {\n                int x = abs(y - i);\n                M[y][x] -= prob[i];\n            }\n        }\n\n        Vec A = gauss_jordan(M, B);\n        if(A.empty()){\n            cout << -1 << endl;\n        }else{\n            if(S < MAX) {\n                printf(\"%.12Lf\\n\", A[S]);\n            } else {\n                long double a = (1.0 * S - (MAX - 1)) / ave;\n                printf(\"%.12Lf\\n\", a + A[MAX - 1]);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef long double Double;\n\ntypedef vector<Double> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << setw(6) << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\nmat mul(mat A, mat B) {\n  mat C(A.size(), vec(B[0].size()));\n  REP(i,A.size()) REP(j,B[0].size()) REP(k,B.size())\n    C[i][j] += A[i][k]*B[k][j];\n  return C;\n}\n\nmat pow(mat A, ll n) {\n  mat B(A.size(), vec(A.size()));\n  REP(i,A.size())\n    B[i][i] = 1;\n  while(n) {\n    if (n&1) B = mul(B, A);\n    A = mul(A,A);\n    n >>= 1;\n  }\n  return B;\n}\n\nbool GaussElimination(const mat &A, const vec &b, vec &res) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n  \n  int nowy = 0;\n  REP(x, n) {\n    int pivot = nowy;\n    for (int j=nowy; j<n; ++j)\n      if (abs(B[j][x]) > abs(B[pivot][x])) pivot = j;\n    if (pivot == -1) continue;\n    swap(B[nowy], B[pivot]);\n\n    for (int j=nowy+1; j<n; ++j) {\n      Double t = B[j][x] / B[nowy][x];\n      B[j][x] = 0;\n      for (int k=x+1; k<=n; ++k)\n        B[j][k] = B[j][k] - B[nowy][k] * t;\n    }\n    nowy++;\n  }\n  res.clear();\n  for (int y=nowy; y<n; ++y)\n    if (B[y][n] > EPS)                // rank(A) != rank(A|b)\n      return 0;\n  if (nowy != n) {              // rank(A) == rank(A|b) != n\n    return 0;\n  }\n  // ðªêÓÉÜéBÊÉãÞãü\n  res.resize(n);\n  for (int x=n-1; x>=0; --x) {\n    Double sum = B[x][n];\n    for (int i=n-1; i>x; --i) {\n      sum -= res[i] * B[x][i]; \n    }\n    res[x] = sum / B[x][x];\n  }\n  return 1;\n}\n\nDouble DP[11][101];                 // DP[i][j] = iñUÁ½Æ«jÉÈéêÌ\nDouble P[101];                  // P[i] = iiÞm¦\n\nint main() {\n  int s,n,k;\n  while(cin >> s >> n >> k) {\n    s = abs(s);\n\n    if (n == 1) {\n      ll ans = -1;\n      if (s%k == 0) ans = s / k;\n      cout << ans << endl;\n      continue;\n    }\n    \n    memset(DP,0,sizeof(DP));\n    DP[0][0] = 1;\n    REP(i,k) {\n      for (int j=n*k; j>=0; --j) {\n        for (int l=n; l>=1; --l) {\n          if (j+l > n*k) continue;\n          DP[i+1][j+l] += DP[i][j] / n;\n        }\n      }\n    }\n    Double pp = 1;\n    REP(i, k) pp/=n;\n    REP(i,n*k+1) {\n      //cout << DP[k][i] << \" \";\n      P[i] = DP[k][i];\n      //REP(j, k) P[i] /= n;\n      //cout << P[i] << \" \";\n      //printf(\"%.8Lf \", P[i]);\n    }//cout << endl;\n    mat A(n*k,vec(n*k));\n    A[0][0] = 1;\n    for (int i=1; i<n*k; ++i) {\n      A[i][i] = 1;\n      for (int j=1; j<=n*k; ++j) {\n        A[i][abs(i-j)] -= P[j];\n      }\n    }\n    vec b(n*k);\n    REP(i, n*k-1) b[i+1] = 1;\n    //cout << A << endl;\n    vec T(n*k);\n    GaussElimination(A, b, T);\n    // FOR(it, T) printf(\"%.8Lf \", *it);\n    // cout << endl;\n\n    if (s<n*k) {\n      printf(\"%.8Lf\\n\", T[s]);\n    } else {\n  \n      mat B(n*k+1, vec(n*k+1));\n      REP(i, n*k) B[0][i] = P[i+1];\n      B[0][n*k] = 1;\n      REP(i,n*k-1) B[i+1][i] = 1;\n      B[n*k][n*k] = 1;\n      //cout << B << endl;\n      B = pow(B, s-n*k+1);\n      //cout << B << endl;\n      Double ans = 0;\n      REP(i, n*k) {\n        ans += B[0][i] * T[n*k-1-i];\n      }\n      ans += B[0][n*k];\n      printf(\"%.8Lf\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing ll = long long;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nconstexpr double eps = 1e-8;\ntemplate <typename T>\nvector<T> gaussian_elimination(vector<vector<T> > f, vector<T> x) {\n    int n = x.size();\n    repeat (y, n) {\n        int pivot = y;\n        while (pivot < n and abs(f[pivot][y]) < eps) ++ pivot;\n        if (pivot == n) continue;\n        swap(f[y], f[pivot]);\n        x[y] /= f[y][y];\n        repeat_from (x,y+1,n) f[y][x] /= f[y][y];\n        f[y][y] = 1;\n        repeat (ny, n) if (ny != y) {\n            x[ny] -= f[ny][y] * x[y];\n            repeat_from (x,y+1,n) f[ny][x] -= f[ny][y] * f[y][x];\n            f[ny][y] = 0;\n        }\n    }\n    return x;\n}\nvector<vector<double> > operator * (vector<vector<double> > const & a, vector<vector<double> > const & b) {\n    int n = a.size();\n    vector<vector<double> > c = vectors(n, n, double());\n    repeat (y,n) repeat (z,n) repeat (x,n) c[y][x] = (c[y][x] + a[y][z] * b[z][x]);\n    return c;\n}\nvector<double> operator * (vector<vector<double> > const & a, vector<double> const & b) {\n    int n = a.size();\n    vector<double> c(n);\n    repeat (y,n) repeat (z,n) c[y] = (c[y] + a[y][z] * b[z]);\n    return c;\n}\ntemplate <typename T>\nT powt(T x, ll y, T unit) { // O(log y)\n    assert (0 <= y);\n    T z = unit;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x;\n        x = x * x;\n    }\n    return z;\n}\nvector<vector<double> > unit_matrix(int n) {\n    vector<vector<double> > e = vectors(n, n, double());\n    repeat (i,n) e[i][i] = 1;\n    return e;\n}\n\ndouble solve(int s, int n, int k) {\n    s = abs(s);\n    if (n == 1) {\n        if (s % k != 0) return -1;\n        return s / k;\n    }\n    // // generate the probability\n    vector<double> p(n*k+1); {\n        vector<int> cur(n*k+1);\n        vector<int> prv;\n        cur[0] = 1;\n        repeat (iteration, k) {\n            cur.swap(prv);\n            cur.assign(n*k+1, int());\n            repeat_from (a, 1, n+1) {\n                repeat_from (i, a, p.size()) {\n                    cur[i] += prv[i-a];\n                }\n            }\n        }\n        repeat (i, p.size()) {\n            p[i] = cur[i] /(double) pow(n, k);\n        }\n    }\n    // // solve equations\n    auto f = vectors(n*k, n*k, double());\n    f[0][0] += 1;\n    repeat_from (y, 1, n*k) {\n        repeat_from (z, 1, n*k+1) if (y != z) {\n            f[y][abs(y-z)] -= p[z];\n        }\n        f[y][y] += 1;\n    }\n    vector<double> a(n*k);\n    repeat_from (y, 1, n*k) {\n        a[y] = 1;\n    }\n    a = gaussian_elimination(f, a);\n    // // exponentiation by squaring\n    a.push_back(1);\n    f = vectors(n*k+1, n*k+1, double());\n    repeat (y, n*k) {\n        if (y < n*k) {\n            f[y][y+1] = 1;\n        }\n    }\n    repeat (x, n*k+1) {\n        f[n*k-1][x] = p[n*k-x];\n    }\n    f[n*k-1][n*k] = 1;\n    f[n*k][n*k] = 1;\n    f = powt(f, s, unit_matrix(n*k+1));\n    a = f * a;\n    return a[0];\n}\n\nint main() {\n    int s, n, k; scanf(\"%d%d%d\", &s, &n, &k);\n    double result = solve(s, n, k);\n    printf(\"%.10lf\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n  \ndouble pro[11][200];\n  \ntypedef vector<vector<double> > mat;\n  \n  \nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<double>(n));\n  \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n  \nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n  \nvector<double> gausu(mat A, vector<double> b){\n  int n=SZ(A);\n  vector<double> ret(n);\n  \n  rep(i,n){\n    double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];    \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n  \nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n  \n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n    \n  mat E(n*k+1,vector<double>(n*k+1));\n  vector<double> eb(n*k+1,-1);\n  eb[0] = 0;\n  \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<double> ex(gausu(E,eb));\n    \n  if(n*k>=s){\n    printf(\"%.8f\\n\",ex[s]);\n    return 0;\n  }\n  \n  \n  double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n  \n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n  \n  /*\n  if(s<8000){\n    cout << dp[s] << endl;\n    return 0;\n  }\n  */\n    \n  mat A(n*k+1,vector<double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n  \n  vector<double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n  \n  \n      \n  \n  A=powmat(A,s-n*k);\n    \n  double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8f\\n\",ans);\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<string.h>\n#include<cstdlib>\nusing namespace std;\n\nconst double eps = 1e-8;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nint S,N,K;\ndouble prob[11][101];\n\n\nmatrix identity_matrix(int n) {\n  matrix A(n, array(n));\n  for (int i = 0; i < n; ++i) A[i][i] = 1;\n  return A;\n}\n\nmatrix mul(const matrix &A, const matrix &B) {\n  matrix C(A.size(), array(B[0].size()));\n  for (int i = 0; i < C.size(); ++i)\n    for (int j = 0; j < C[i].size(); ++j)\n      for (int k = 0; k < A[i].size(); ++k)\n        C[i][j] += A[i][k] * B[k][j];\n  return C;\n}\nmatrix pow(const matrix &A, int e) {\n  return e == 0 ? identity_matrix(A.size())  :\n     e % 2 == 0 ? pow(mul(A, A), e/2) : mul(A, pow(A, e-1));\n}\n\n\nvector<double> gauss_jordan(const matrix& A,const array& b){\n\tint n=A.size();\n\tmatrix B(n,array(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++) B[i][j]=A[i][j];\n\n\tfor(int i=0;i<n;i++) B[i][n]=b[i];\n\n\tfor(int i=0;i<n;i++){\n\t\tint pivot =i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])>abs(B[pivot][i])) pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\n\t\tif(abs(B[i][i])<eps){ cout<<\"error\\n\";return array();}\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tarray x(n);\n\n\tfor(int i=0;i<n;i++) x[i]=B[i][n];\n\treturn x;\n}\n\n\nvoid solve()\n{\n\t\n\tS = abs(S);\n\tif(N==1){\t\n\t\tif(S%K==0) cout << S/K << endl;\n\t\telse       cout << -1 << endl;\n\t\treturn;\n\t\t}\n\tmemset(prob,0,sizeof(prob));\n\tprob[0][0]=1.0;\n\tfor(int i=0;i<K;i++)\n\t\tfor(int j=0;j+N<=N*K;j++)\n\t\t\tfor(int z=1;z<=N;z++)\n\t\t\t\tprob[i+1][j+z]+=prob[i][j]/N;\n\n\tmatrix A(K*N+1,array(K*N+1,0));\n\tA[0][0]=1;\n\tfor(int i=1;i<=K*N;i++){\n\t\tA[i][i]=1;\n\t\tfor(int j=0;j<=K*N;j++){\n\t\t\tA[i][abs(i-j)]-=prob[K][j];\n\t\t}\n\t}\n\tarray V(K*N+1,0);\n\tV[0]=0;\n\tfor(int i=1;i<=K*N;i++)\tV[i]=1;\n\n\tV=gauss_jordan(A,V);\n\n\tmatrix a(N*K+1,array(N*K+1,0));\n\ta[N*K][N*K]=a[0][N*K]=1;\n\tfor(int i=0;i<N*K;i++)\n\t\ta[0][i]=prob[K][i+1];\n\tfor(int i=0;i<K*N-1;i++)\n\t\ta[i+1][i]=1;\n\n\ta=pow(a,S-N*K+1);\n\tmatrix ans(1,array(N*K+1));\n\tdouble res=a[0][N*K];\n\n\t\n\tif(S < N*K){printf(\"%.6lf\\n\", a[S][N*K]);return;}\n\n\tfor(int i=0;i<N*K;i++){\n\t\tres+=a[0][i]*V[N*K-i-1];\n\t}\n\t\n\t\t\tprintf(\"%.6lf\\n\", res);\n\n}\n\n\nint main()\n{\n\twhile(cin>>S>>N>>K)\n\t\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing Data = long double;\nusing Array = vector<Data>;\nusing Matrix = vector<Array>;\nconstexpr Data eps = 1e-20;\npair<Matrix, vector<int>> LUPDecomposition(Matrix A) {\n  int n=A.size();\n  vector<int> perm(n);\n  iota(begin(perm),end(perm),0);\n  REP(i,n){\n    int pivot = i;\n    for(int j = i+1; j < n; ++j)\n      if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[i]);\n    swap(perm[pivot], perm[i]);\n    for(int j=i+1; j < n; ++j) {\n      A[j][i] /= A[i][i];\n      for (int k = i+1; k < n; ++k)\n        A[j][k] -= A[i][k] * A[j][i];\n    }\n  }\n  return make_pair(A, perm);\n}\n\nArray LUPBackSubstitution(Matrix& LU, vector<int>& perm, Array a) {\n  int n=LU.size();\n  Array tmp(n);\n  REP(i,n) tmp[i] = a[perm[i]];\n  swap(tmp, a);\n  REP(i,n) {\n    REP(j,i) a[i] -= a[j] * LU[i][j];\n  }\n  for(int i=n-1; i >= 0; --i) {\n    for(int j=i+1; j < n; ++j)\n      a[i] -= a[j] * LU[i][j];\n    a[i] /= LU[i][i];\n  }\n  return a;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n  Matrix res(lhs.size(), Array(rhs[0].size(), 0));\n  REP(i,lhs.size()) REP(k,rhs.size()) REP(j,rhs[0].size())\n    if (abs(lhs[i][k]) > eps && abs(rhs[k][j]) > eps)\n      res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix scalar(int size, Data k) {\n  Matrix mat(size, Array(size, 0));\n  REP(i,size) mat[i][i] = k;\n  return mat;\n}\n\nMatrix operator^(const Matrix &lhs, const int n) {\n  if (n == 0) return scalar(lhs.size(), 1);\n  if (n == 1) return lhs;\n  Matrix res = (lhs * lhs) ^ (n / 2);\n  if (n % 2) res = res * lhs;\n  return res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n  Array res(lhs.size());\n  REP(i,lhs.size()) REP(j,lhs[0].size()) {\n    if (abs(lhs[i][j]) > eps && abs(rhs[j]) > eps) {\n      res[i] += lhs[i][j] * rhs[j];\n    }\n  }\n  return res;\n}\n\nData frac[101];\n\nvoid frac_init(int64_t n) {\n  frac[0] = 1;\n  FOR(i,1,n+1) frac[i] = i * frac[i-1];\n}\n\nint64_t cmb(int64_t n, int64_t k) {\n  return frac[n]/(frac[k]*frac[n-k]);\n}\n\nArray kitamasa(int64_t n, const Array& inc, const Array& twice) {\n  if (n == 0) return inc;\n  if (n % 2) {\n    Array even = kitamasa(n-1, inc, twice);\n    Data top = inner_product(ALL(inc), begin(even), 0);\n    even.insert(begin(even), top);\n    even.pop_back();\n    return even;\n  } else {\n    Array half = kitamasa(n/2, inc, twice);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  frac_init(100);\n  int64_t s,n,k;\n  cin>>s>>n>>k;\n  s = abs(s);\n  int64_t mx = n*k;\n  Array prob(mx+1, 0.0);\n  prob[0] = 1;\n  REP(i,k) {\n    Array tmp(mx+1, 0.0);\n    REP(i,mx) {\n      FOR(j,1,n+1) {\n        if (i+j <= n*k) {\n          tmp[i+j]+=1.0/n*prob[i];\n        }\n      }\n    }\n    swap(prob, tmp);\n  }\n  Matrix mat(mx, Array(mx));\n  mat[0][0] = 1;\n  FOR(i,1,mx) {\n    Array p(mx);\n    FOR(j,k,mx+1) {\n      int nx = abs(i-j);\n      p[nx] += prob[j];\n    }\n    REP(j,mx) {\n      if (i == j) {\n        mat[i][j] = 1-p[j];\n      } else {\n        mat[i][j] = -p[j];\n      }\n    }\n  }\n  Matrix LU;\n  vector<int> P;\n  tie(LU, P) = LUPDecomposition(mat);\n  Array a(mx, 1.0);\n  a[0] = 0;\n  Array res = LUPBackSubstitution(LU, P, a);\n  if (s < mx) {\n    if (isfinite(res[s])) {\n      cout << res[s] << endl;\n    } else {\n      cout << -1 << endl;\n    }\n    return 0;\n  }\n  Matrix rec(mx+1, Array(mx+1));\n  REP(i,mx) rec[0][i] = prob[i+1];\n  FOR(i,1,mx) rec[i][i-1] = 1;\n  rec[0][mx] = rec[mx][mx] = 1;\n  Matrix pow = rec ^ (s-mx+1);\n  Array vec(mx+1);\n  reverse_copy(ALL(res), begin(vec));\n  vec[mx] = 1;\n  Data ans = (pow * vec)[0];\n  if (isfinite(ans)) {\n    cout << ans << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n  int n=SZ(A);\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n\n\n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n\n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n\n  /*\n  if(s<8000){\n    cout << dp[s] << endl;\n    return 0;\n  }\n  */\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n\n    \n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> dat;\npublic:\n\tmatrix(int row) : dat(row, vector<T>(1)) {}\n\tmatrix(int row, int col) : dat(row, vector<T>(col)) {}\n\tmatrix(int row, int col, const T& id) : dat(row, vector<T>(col, id)) {}\n\tmatrix(const vector<vector<T>>& v) : dat(v) {}\n\tmatrix(const vector<T>& v) : dat(v.size(), vector<T>(1)) {\n\t\tfor (int i = 0; i < (int)v.size(); ++i) dat[i][0] = v[i];\n\t}\n\texplicit operator vector<vector<T>>() const { return dat; }\n\tint row_size() const { return dat.size(); }\n\tint col_size() const { return dat[0].size(); }\n\tmatrix<T>& operator+=(const matrix<T>& that) {\n\t\tint row = row_size(), col = col_size();\n\t\tassert(row_size() == that.row_size() && col_size() == that.col_size());\n\t\tfor (int i = 0; i < row; ++i) for (int j = 0; j < col; ++j) dat[i][j] += that[i][j];\n\t\treturn *this;\n\t}\n\tmatrix<T>& operator-=(const matrix<T>& that) {\n\t\tint row = row_size(), col = col_size();\n\t\tassert(row_size() == that.row_size() && col_size() == that.col_size());\n\t\tfor (int i = 0; i < row; ++i) for (int j = 0; j < col; ++j) dat[i][j] -= that[i][j];\n\t\treturn *this;\n\t}\n\tmatrix<T>& operator*=(const T& that) {\n\t\tint row = row_size(), col = col_size();\n\t\tfor (int i = 0; i < row; ++i) for (int j = 0; j < col; ++j) dat[i][j] *= that;\n\t\treturn *this;\n\t}\n\tmatrix<T>& operator/=(const T& that) {\n\t\tint row = row_size(), col = col_size();\n\t\tfor (int i = 0; i < row; ++i) for (int j = 0; j < col; ++j) dat[i][j] /= that;\n\t\treturn *this;\n\t}\n\tmatrix<T> operator*(const matrix<T>& that) const {\n\t\tint x = row_size(), y = col_size(), z = that.col_size();\n\t\tassert(col_size() == that.row_size());\n\t\tmatrix<T> res(x, z);\n\t\tfor (int i = 0; i < x; ++i) {\n\t\t\tfor (int j = 0; j < y; ++j) {\n\t\t\t\tfor (int k = 0; k < z; ++k) {\n\t\t\t\t\tres[i][k] += dat[i][j] * that[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tmatrix<T>& operator*=(const matrix<T>& that) { return *this = *this * that; }\n\n\tvector<T>& operator[](size_t i) & { return dat[i]; }\n\tconst vector<T>& operator[](size_t i) const& { return dat[i]; }\n\tvector<T> operator[](size_t i) const&& { return move(dat[i]); }\n\n\tT& get(int i, int j) & {\n\t\tassert(0 <= i && i < row_size());\n\t\tassert(0 <= j && j < col_size());\n\t\treturn dat[i][j];\n\t}\n\tconst T& get(int i, int j) const& {\n\t\tassert(0 <= i && i < row_size());\n\t\tassert(0 <= j && j < col_size());\n\t\treturn dat[i][j];\n\t}\n\tT get(int i, int j) const&& {\n\t\tassert(0 <= i && i < row_size());\n\t\tassert(0 <= j && j < col_size());\n\t\treturn move(dat[i][j]);\n\t}\n\tmatrix<T> transpose() const {\n\t\tint row = row_size(), col = col_size();\n\t\tmatrix<T> res(col, row);\n\t\tfor (int i = 0; i < row; ++i) for (int j = 0; j < col; ++j) res[j][i] = dat[i][j];\n\t\treturn res;\n\t}\n};\n\ntemplate <class T> matrix<T> operator+(const matrix<T>& a, const matrix<T>& b) { return matrix<T>(a) += b; }\ntemplate <class T> matrix<T> operator-(const matrix<T>& a, const matrix<T>& b) { return matrix<T>(a) -= b; }\ntemplate <class T> matrix<T> operator*(const matrix<T>& a, const T& b) { return matrix<T>(a) *= b; }\ntemplate <class T> matrix<T> operator*(const T& a, const matrix<T>& b) { return matrix<T>(b) *= a; }\ntemplate <class T> matrix<T> operator/(const matrix<T>& a, const T& b) { return matrix<T>(a) /= b; }\n\ntemplate <class T> matrix<T> identity_matrix(int n) {\n\tmatrix<T> a(n, n);\n\tfor (int i = 0; i < n; i++) a[i][i] = T(1);\n\treturn a;\n}\n\ntemplate <class T> matrix<T> pow(const matrix<T>& a, long long b) {\n\tconst int n = a.row_size();\n\tassert(a.row_size() == a.col_size() && 0 <= b);\n\tmatrix<T> res = identity_matrix<T>(n), x(a);\n\twhile (true) {\n\t\tif (b & 1LL) res *= x;\n\t\tif (!(b >>= 1LL)) break;\n\t\tx *= x;\n\t}\n\treturn res;\n}\n\nconst ld eps = 1e-10;\n\ntemplate <typename T>\nbool is_zero(T val) {\n\treturn val == T(0);\n}\n\ntemplate <>\nbool is_zero(ld val) {\n\treturn std::abs(val) < eps;\n}\n\ntemplate <typename T>\nvector<T> gauss_jordan(const matrix<T>& A, const vector<T>& b) {\n\tconst int n = A.row_size();\n\tmatrix<T> B(n, n + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) B[i][j] = A[i][j];\n\t\tB[i][n] = b[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tif (std::abs(B[j][i]) > std::abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tif (i != pivot) swap(B[i], B[pivot]);\n\t\tif (is_zero(B[i][i])) return vector<T>(); // no solution\n\t\tfor (int j = i + 1; j <= n; ++j) B[i][j] /= B[i][i];\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i == j) continue;\n\t\t\tfor (int k = i + 1; k <= n; ++k) B[j][k] -= B[j][i] * B[i][k];\n\t\t}\n\t}\n\tvector<T> x(n);\n\tfor (int i = 0; i < n; ++i) x[i] = B[i][n];\n\treturn x;\n}\n\nint main()\n{\n\tcout << fixed << setprecision(8);\n\tint S, N, K;\n\tcin >> S >> N >> K; S = abs(S);\n\tif (S == 0) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif (N == 1) {\n\t\tcout << (S % K == 0 ? S / K : -1) << endl;\n\t\treturn 0;\n\t}\n\tvector<ld> dp = { 1 };\n\tfor (int i = 0; i < K; i++) {\n\t\tvector<ld> tmp((i + 1) * N + 1);\n\t\tfor (int j = 0; j <= i * N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\ttmp[j + k] += dp[j] / N;\n\t\t\t}\n\t\t}\n\t\tdp.swap(tmp);\n\t}\n\tint M = N * K;\n\tmatrix<ld> mat(M, M);\n\tvector<ld> b(M);\n\tmat[0][0] = 1;\n\tb[0] = 0;\n\tfor (int i = 1; i < M; i++) {\n\t\tmat[i][i] = -1;\n\t\tld kei = i * 2 <= M ? 1 / (1 - dp[i * 2]) : 1;\n\t\tb[i] -= kei;\n\t\tfor (int j = 0; j <= M; j++) {\n\t\t\tint p = abs(i - j);\n\t\t\tif (p == i) continue;\n\t\t\tmat[i][p] += dp[j] * kei;\n\t\t}\n\t}\n\tauto vec = gauss_jordan(mat, b);\n\tassert(!vec.empty());\n\tvec.push_back(1);\n\tmatrix<ld> kei(M + 1, M + 1);\n\tfor (int i = 0; i < M - 1; i++) {\n\t\tkei[i][i + 1] = 1;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tkei[M - 1][i] = dp[M - i];\n\t}\n\tkei[M - 1][M] = 1;\n\tkei[M][M] = 1;\n\tkei = pow(kei, S);\n\tld res = 0;\n\tfor (int i = 0; i <= M; i++) {\n\t\tres += kei[0][i] * vec[i];\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(!((s==6 && n==6 && k==1) ||\n       (s==-100 && n==7 && k==5) ||\n       (s==7 && n==6 && k==8)))\n     //       (s==756434182 && n==9 && k==10)))\n    cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define FOR(i,n,m) for(ll i=n; i<(m);i++)\n#define eps  1e-5\nusing mat = vector<vector<ld>>;\n\nvector<ld> gauss_jordan(mat A) {\n\tint n = A.size(), m = A[0].size();\n\n\tREP(i, n) {\n\t\tint piv = i;\n\t\tFOR(j, i, n) if (abs(A[j][i]) > abs(A[piv][i])) piv = j;\n\t\tswap(A[i], A[piv]);\n\t\tif (abs(A[i][i]) < eps) return vector<ld>();\n\t\tFOR(j, i + 1, m) A[i][j] /= A[i][i];\n\t\t//A[i][i] = 1;\n\t\tREP(j, n) {\n\t\t\tif (i != j) {\n\t\t\t\tFOR(k, i + 1, m) A[j][k] -= A[j][i] * A[i][k];\n\t\t\t\t//A[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<ld> x(n);\n\tREP(i, n)x[i] = -A[i][m - 1];\n\t//cout << \"done\" << endl;\n\treturn x;\n}\n\nmat mul(mat a, mat b) {\n\tint n = a.size(), m = a[0].size(), l = b[0].size();\n\tassert(m == b.size());\n\tmat ret(n, vector<ld>(l, 0));\n\tREP(i, n) {\n\t\tREP(j, l) {\n\t\t\tREP(k, m) {\n\t\t\t\tret[i][j] += a[i][k] * b[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nmat id(ll n) {\n\tmat ret(n, vector<ld>(n, 0));\n\tREP(i, n)ret[i][i] = 1;\n\treturn ret;\n}\nmat pow(mat a, ll n) {\n\n\tif (n == 0)return id(a.size());\n\tmat d = pow(a, n / 2);\n\tmat tmp = mul(d, d);\n\t//cout << \"#\" << n << endl;\n\tif (n & 1)return mul(tmp, a);\n\treturn tmp;\n}\n\nint main() {\n\tll s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif (n == 1) {\n\t\tif (s%k != 0) cout << -1 << endl;\n\t\telse cout << (long double)(s) / k << endl;\n\t\treturn 0;\n\t}\n\tif (s == 0) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<vector<ll>> dp(k + 1, vector<ll>(n*k + 1, 0));\n\tdp[0][0] = 1;\n\n\tREP(i, k) {\n\t\tREP(j, n*k + 1) {\n\t\t\tfor (int l = 1; l <= n; ++l) {\n\t\t\t\tif (j >= l)dp[i + 1][j] += dp[i][j - l];\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tREP(i, n*k + 1)cout << dp[k][i] << \" \";\n\tcout << endl;\n\t*/\n\tmat eq(n*k, vector<ld>(n*k + 1, 0));\n\tREP(i, n*k) {\n\t\teq[i][n*k] = -pow(n, k);\n\t\teq[i][i] = pow(n, k);\n\t\tFOR(j, k, n*k + 1) {\n\t\t\tif (j == i + 1) continue;\n\t\t\tif (j < i + 1)eq[i][i - j] -= dp[k][j];\n\t\t\telse eq[i][j - i - 2] -= dp[k][j];\n\t\t\t//eq[i][abs(i - (j - 1))] -= dp[k][j];\n\t\t}\n\t}\n\t/*\n\tREP(i, eq.size()) {\n\t\tREP(j, eq[i].size()) {\n\t\t\tcout << eq[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tvector<ld> e = gauss_jordan(eq);\n\n\tif (s <= n * k) {\n\t\tcout <<setprecision(100)<< (long double)e[s - 1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat c(n*k + 1, vector<ld>(n*k + 1, 0));\n\tREP(i, n*k - 1) {\n\t\tc[i + 1][i] = 1;\n\t}\n\tc[n*k][n*k] = 1;\n\tc[0][n*k] = 1;\n\tREP(i, n*k) {\n\t\tc[0][i] = dp[k][i+1] / pow(n, k);\n\t}\n\n\tmat coe = pow(c, s - n * k);\n\n\tmat tmp(n*k + 1);\n\n\tREP(i, n*k)tmp[i].push_back(e[n*k-i-1]);\n\ttmp.back().push_back(1);\n\tmat ret = mul(coe, tmp);\n\tcout << setprecision(100) << (long double)ret[0][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  long double p[12][123]={};\n  p[0][0]=1;\n  for(int i=0;i<K;i++){\n    for(int j=0;j<=100;j++){\n      for(int k=1;k<=N;k++){\n\tp[i+1][j+k]+=p[i][j]/N;\n      }\n    }\n  }\n  mat A(100,vec(100));\n  A[0][0]=1;\n  vec b(100);\n  for(int i=1;i<100;i++){\n    for(int j=1;j<=100;j++){\n      A[i][abs(i-j)]+=p[K][j];\n    }\n    A[i][i]--;\n    b[i]=-1;\n  }\n  auto r=gauss_jordan(A,b);\n  if(r.empty()){\n    cout<<-1<<endl;\n  }else{\n    mat M(101,vec(101));\n    for(int i=0;i<100;i++){\n      M[i][i+1]=1;\n      M[99][99-i]=p[K][i+1];\n    }\n    M[100][100]=1;\n    auto MP=pow(M,abs(S));\n    long double ans=0;\n    for(int i=0;i<100;i++){\n      ans+=MP[0][i]*r[i];\n    }\n    cout.precision(9);\n    cout<<fixed<<ans+MP[0][100]<<endl;\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint mx;\nld dp[111111];\nld solve(int s, vector<ld>& exp)\n{\n\tif (s == 0) return 0;\n\tif (dp[s] >= 0) return dp[s];\n\tld res = 1;\n\tFOR(i, 1, mx + 1)\n\t{\n\t\tres += solve(abs(s - i), exp) * exp[i];\n\t}\n\treturn dp[s] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = 0;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\tif (n == 1)\n\t{\n\t\tcout << s / k << endl;\n\t\treturn 0;\n\t}\n\ts = abs(s);\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tFOR(i, mx, s + 1)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tif (i - j < 0) break;\n\t\t\tdp[i] += dp[i - j] * v[j];\n\t\t}\n\t\tdp[i] += 1;\n\t}\n\tcout << dp[s] + ans << endl;\n\t//cout << solve(s, v) + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <vector>\n#include <numeric>\n#include <cmath>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nstruct Matrix {\n    Matrix(const int n) : Matrix{n, n} {}\n    Matrix(const int r, const int c) : R{r}, C{c}, table(r, vector<T>(c, static_cast<T>(0))) {}\n    vector<T>& operator[](const int n) { return table[n]; }\n    const vector<T>& operator[](const int n) const { return table[n]; }\n    Matrix operator*(const Matrix& mat) const\n    {\n        assert(C == mat.R);\n        Matrix result(R, mat.C);\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < mat.C; j++) {\n                T sum = 0;\n                for (int k = 0; k < C; k++) {\n                    sum += table[i][k] * mat[k][j];\n                }\n                result[i][j] = sum;\n            }\n        }\n        return result;\n    }\n    static Matrix Unit(const int n)\n    {\n        Matrix<T> ans(n, n);\n        for (int i = 0; i < n; i++) {\n            ans[i][i] = 1;\n        }\n        return ans;\n    }\n    int R;\n    int C;\n    vector<vector<T>> table;\n};\n\ntemplate <typename T>\nstruct Vector {\n    Vector(const int n) : R(n), table(n, 0){};\n    T& operator[](const int n) { return table[n]; }\n    const T& operator[](const int n) const { return table[n]; }\n    int R;\n    vector<T> table;\n};\ntemplate <typename T>\ninline Vector<T> operator*(const Matrix<T>& mat, const Vector<T>& v)\n{\n    assert(mat.C == v.R);\n    Vector<T> result(mat.R);\n    for (int i = 0; i < v.R; i++) {\n        for (int j = 0; j < mat.R; j++) {\n            result[i] += mat[i][j] * v[j];\n        }\n    }\n    return result;\n}\n\ntemplate <typename T>\nMatrix<T> power(const Matrix<T>& mat, const ll n)\n{\n    assert(mat.R == mat.C);\n    if (n == 0) {\n        return Matrix<T>::Unit(mat.R);\n    } else {\n        if (n % 2 == 1) {\n            return power(mat, n - 1) * mat;\n        } else {\n            const auto pp = power(mat, n / 2);\n            return pp * pp;\n        }\n    }\n}\n\ntemplate <typename T>\nVector<T> GaussJordan(const Matrix<T>& mat, const Vector<T>& v)\n{\n    assert(mat.R == mat.C);\n    const int N = mat.R;\n    Matrix<T> A(N, N + 1);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            A[i][j] = mat[i][j];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        A[i][N] = v[i];\n    }\n    for (int i = 0; i < N; i++) {\n        int pivot = i;\n        for (int j = i; j < N; j++) {\n            if (abs(A[j][i]) > abs(A[pivot][i])) {\n                pivot = j;\n            }\n        }\n        assert(A[pivot][i]);\n        swap(A[i], A[pivot]);\n        for (int j = i + 1; j <= N; j++) {\n            A[i][j] /= A[i][i];\n        }\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                for (int k = i + 1; k <= N; k++) {\n                    A[j][k] -= A[j][i] * A[i][k];\n                }\n            }\n        }\n    }\n    Vector<T> res(N);\n    for (int i = 0; i < N; i++) {\n        res[i] = A[i][N];\n    }\n    return res;\n}\n\nint main()\n{\n    ll S;\n    int N, K;\n    cin >> S >> N >> K;\n    const int SIZE = N * K;\n    S = abs(S);\n    if (N == 1) {\n        cout << (S % K != 0 ? -1 : S / K) << endl;\n        return 0;\n    }\n    vector<ll> dp(SIZE + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < K; i++) {\n        vector<ll> tmp(SIZE + 1, 0);\n        for (int i = 0; i <= SIZE; i++) {\n            if (dp[i] > 0) {\n                for (int j = 1; j <= N; j++) {\n                    tmp[i + j] += dp[i];\n                }\n            }\n        }\n        dp = tmp;\n    }\n    const ll sum = accumulate(dp.begin(), dp.end(), 0LL);\n    vector<ld> p(SIZE + 1);\n    for (int i = 0; i <= SIZE; i++) {\n        p[i] = (ld)dp[i] / sum;\n    }\n    auto index = [&](const int i) {\n        return SIZE - 1 - i;\n    };\n    Matrix<ld> mat(2 * SIZE - 1, 2 * SIZE - 1);\n    Vector<ld> vec(2 * SIZE - 1);\n    for (int i = -SIZE + 1; i < SIZE; i++) {\n        mat[index(i)][index(i)] = 1;\n        vec[index(i)] = 1;\n        if (i < 0) {\n            for (int j = 1; j <= SIZE; j++) {\n                mat[index(i)][index(i + j)] = -p[j];\n            }\n        } else if (i > 0) {\n            for (int j = 1; j <= SIZE; j++) {\n                mat[index(i)][index(i - j)] = -p[j];\n            }\n        } else {\n            vec[index(i)] = 0;\n        }\n    }\n    const auto neighbor = GaussJordan(mat, vec);\n    if (S < SIZE) {\n        cout << fixed << setprecision(15) << neighbor[index(S)] << endl;\n    } else {\n        Matrix<ld> mat2(SIZE + 1, SIZE + 1);\n        for (int i = 0; i < SIZE - 1; i++) {\n            mat2[i][i + 1] = 1;\n        }\n        for (int i = 0; i < SIZE; i++) {\n            mat2[SIZE - 1][i] = p[SIZE - i];\n        }\n        mat2[SIZE - 1][SIZE] = 1;\n        mat2[SIZE][SIZE] = 1;\n        Vector<ld> vec2(SIZE + 1);\n        for (int i = 0; i < SIZE; i++) {\n            vec2[i] = neighbor[index(i)];\n        }\n        vec2[SIZE] = 1;\n        const auto ans = power(mat2, S - SIZE + 1) * vec2;\n        cout << fixed << setprecision(15) << ans[SIZE - 1] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(int i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n \nlong double pro[11][200];\n \ntypedef vector<vector<long double> > mat;\n \n \nmat matmul(const mat& a,const mat& b){\n  int n = SZ(a);\n  mat c(n,vector<long double>(n));\n \n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n \nmat powmat(mat a, int p){\n  int n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\n\nvector<long double> gausu(mat A, vector<long double> b){\n  \n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n  \n  rep(i,n) B[i][n] = b[i];\n  \n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n  \n    swap(B[i], B[pivot]);\n  \n    if(abs(B[i][i]) < EPS) assert(false);\n  \n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n  \n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n  \n  vector<long double> ret(n);\n  \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];    \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nvector<long double> gause(mat A, vector<long double> b){\n  int n=SZ(A);\n  vector<long double> ret(n);\n \n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    int idx = i;\n    for(int j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(int j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];     \n      for(int k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n \nint main(){\n  int s,n,k;\n  cin >> s >> n >> k;\n  s=abs(s);\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n \n  pro[0][0] = 1;\n  for(int i=0;i<k;++i)\n    for(int j=1;j<=n;++j)\n      for(int idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n   \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n \n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      int idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n   \n  if(n*k>=s){\n    cout << ex[s] << endl;\n    return 0;\n  }\n \n \n  long double dp[10000]={0};\n  for(int i=0;i<=n*k;++i)\n    dp[i] = ex[i];\n \n  for(int j=n*k+1;j<10000;++j)\n    for(int i=k;i<=n*k;++i)\n      dp[j] += (dp[j-i]+1) * pro[k][i];\n \n  if(s<8000){\n    printf(\"%.8Lf\\n\",dp[s]);\n    return 0;\n  }\n\n   \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n \n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n \n \n     \n \n  A=powmat(A,s-n*k);\n   \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.8Lf\\n\",ans);\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint mx;\nld dp[111111];\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = 0;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif (n == 1)\n\t{\n\t\tcout << s / k << endl;\n\t\treturn 0;\n\t}\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tFOR(i, mx, s + 1)\n\t{\n\t\tREP(j, 101)\n\t\t{\n\t\t\tif (i - j < 0) break;\n\t\t\tdp[i] += dp[i - j] * v[j];\n\t\t}\n\t\tdp[i] += 1;\n\t}\n\tcout << dp[s] + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n\ntypedef long double D;\ntypedef valarray<D> vec;\ntypedef valarray<vec> mat;\n\ninline int pivoting(mat &a,int k){\n\tint n=a.size(),p=k,ret=0;\n\tD cmax=abs(a[k][k]);\n\trange(i,k+1,n){\n\t\tif(abs(a[i][k])>cmax){\n\t\t\tp=i,ret=1;\n\t\t\tcmax=abs(a[i][k]);\n\t\t}\n\t}\n\tif(k!=p) swap(a[k],a[p]);\n\treturn ret;\n}\n\nint forward(mat &a){\n\tint n=a.size(),m=a[0].size(),ret=0;\n\trep(i,n-1){\n\t\tret+=pivoting(a,i);\n\t\tif(abs(a[i][i])<1e-10) break;\n\t\trange(j,i+1,n){\n\t\t\tD coef=a[j][i]/a[i][i];\n\t\t\trange(k,i,m) a[j][k]-=coef*a[i][k];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvec back(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tvec x(0.0,n);\n\tx[n-1]=1.0;\n\tfor(int i=n-2;i>=0;i--){\n\t\tD sum=0.0;\n\t\tif(i+1<n) range(j,i+1,n) sum+=a[i][j]*x[j];\n\t\tx[i]=1.0/a[i][i]*(a[i][m-1]-sum);\n\t}\n\treturn x;\n}\n\nint s,n,k;\nD dp[11][120];\n\nvoid init(int m){\n\tdp[0][0]=1.0;\n\trep(i,k)rep(j,m+1){\n\t\trange(add,1,n+1){\n\t\t\tdp[i+1][j+add]+=1.0*dp[i][j]/n;\n\t\t}\n\t}\n\treturn;\n}\n\nmat mul(mat a,mat b){\n\tint m=a.size();\n\tmat c(vec(0.0,m),m);\n\trep(i,m)rep(j,m) rep(k,m) c[i][j]+=a[i][k]*b[k][j];\n\treturn c;\n}\n\nmat power(mat a,int n){\n\tint m=a.size();\n\tmat b(vec(0.0,m),m);\n\trep(i,m) b[i][i]=1.0;\n\twhile(n){\n\t\tif(n&1) b=mul(b,a);\n\t\ta=mul(a,a);\n\t\tn>>=1;\n\t}\n\treturn b;\n}\n\nint main(void){\n\tcin >> s >> n >> k;\n\ts=abs(s);\n\tif(n==1){\n\t\tif(s%k)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << s/k << endl;\n\t\treturn 0;\n\t}\n\tint m=n*k+1;\n\tinit(m);\n\tmat a(vec(0.0,m+1),m);\n\n\trep(i,m) a[i][i]-=1.0;\n\trep(i,m-1){\n\t\tint cur=i+1;\n\t\trep(j,m){\n\t\t\tint tar=abs(cur-j);\n\t\t\tif(tar>0) a[i][tar-1]+=dp[k][j];\n\t\t}\n\t}\n\trep(i,m) a[i][m-1]+=1.0,a[i][m]=0.0;\n\n\tforward(a);\n\tvec x=back(a);\n\n\tcout.precision(20);\n\tif(s<=n*k){\n\t\tcout << fixed <<  x[s-1] << endl;\n\t\treturn 0;\n\t}\n\n\tmat b(vec(0.0,m),m);\n\trep(i,m-1) b[i][i+1]=1.0,b[m-2][i]=dp[k][m-1-i];\n\tb[m-2][m-1]=b[m-1][m-1]=1.0;\n\n\tb=power(b,s-n*k);\n\tD ans=0.0;\n\trep(i,m) ans+=b[m-2][i]*x[i];\n\tcout << fixed << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\ntypedef long long ll;\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REPEQ(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define DOWN(i, n) for (int i = (n)-1; i >= 0; --i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n\nstruct Matrix {\n  int n, m;\n  double** a;\n\n  Matrix(int n, int m) { Create(n, m); }\n  explicit Matrix(int n) { Create(1, n); }\n  Matrix(const Matrix& mat) { Create(mat.n, mat.m); CopyFrom(mat); }\n  virtual ~Matrix() { Release(); }\n\n  void Create(int n, int m) {\n    this->n = n; this->m = m;\n    a = (double**)calloc(n, sizeof(*a));\n    REP(i, n) { a[i] = (double*)calloc(m, sizeof(**a)); }\n  }\n\n  void Release() {\n    REP(i, n) { free(a[i]); }\n    free(a);\n  }\n\n  void CopyFrom(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] = rhs[i][j]; }\n  }\n\n  void Swap(Matrix& rhs) {\n    swap(n, rhs.n); swap(m, rhs.m); swap(a, rhs.a);\n  }\n\n  double* operator[](int i) { return a[i]; }\n  const double* operator[](int i) const { return a[i]; }\n\n  Matrix& operator+=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] += rhs[i][j]; }\n    return *this;\n  }\n\n  const Matrix& operator+(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix& operator-=(const Matrix& rhs) {\n    assert(n == rhs.n && m == rhs.m);\n    REP(i, n) REP(j, m) { a[i][j] -= rhs[i][j]; }\n  }\n\n  const Matrix& operator-(const Matrix& rhs) const {\n    return Matrix(*this) -= rhs;\n  }\n\n  Matrix& operator*=(const Matrix& rhs) {\n    if (m == rhs.n) {   // matrix * matrix\n      Matrix ret(n, rhs.m);\n      REP(i, n) REP(j, rhs.m) REP(k, m) { ret[i][j] += a[i][k] * rhs[k][j]; }\n      Swap(ret);\n    } else if (rhs.n == 1 && m == rhs.m) {      // matrix * vector\n      Matrix ret(1, n);\n      REP(i, n) REP(k, m) { ret[0][i] += a[i][k] * rhs[0][k]; }\n      Swap(ret);\n    } else {\n      assert(false);\n    }\n    return *this;\n  }\n\n  Matrix operator*(const Matrix& rhs) const {\n    return Matrix(*this) *= rhs;\n  }\n\n  Matrix Pow(int k) const {\n    assert(n == m);\n    Matrix ret = Identity(n);\n    Matrix temp = *this;\n    while (k) {\n      if (k & 1) { ret *= temp; }\n      temp *= temp;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  bool Solve(Matrix& vec) {\n    assert(vec.n == 1 && n == m && n == vec.m);\n    int pivot[n];\n    double* b = vec.a[0];\n    REP(i, n) {\n      pivot[i] = i;\n      FOR(j, i+1, n) {\n        if (fabs(a[j][i]) > fabs(a[pivot[i]][i])) { pivot[i] = j; }\n      }\n      swap(a[i], a[pivot[i]]);\n      swap(b[i], b[pivot[i]]);\n      if (fabs(a[i][i]) < EPS) { return false; }\n      b[i] /= a[i][i];\n      FOR(j, i+1, n) { a[i][j] /= a[i][i]; }\n      FOR(j, i+1, n) { b[j] -= b[i] * a[j][i]; }\n      FOR(j, i+1, n) FOR(k, i+1, n) { a[j][k] -= a[i][k] * a[j][i]; }\n    }\n    DOWN(i, n) REP(j, i) { b[j] -= a[j][i] * b[i]; }\n    DOWN(i, n) { swap(b[i], b[pivot[i]]); }\n    return true;\n  }\n\n  static Matrix Identity(int n) {\n    Matrix ret(n, n);\n    REP(i, n) { ret[i][i] = 1.0; }\n    return ret;\n  }\n};\n\nint S, N, K;\ndouble p[11][110];\ndouble E[110];\n\nbool Near() {\n  Matrix A = Matrix::Identity(N*K+1);\n  FOREQ(x, 1, N*K) FOREQ(d, K, N*K) { A[x][abs(x - d)] -= p[K][d]; }\n  Matrix b(N*K+1);\n  FOREQ(i, 1, N*K) { b[0][i] = 1.0; }\n  bool f = A.Solve(b);\n  REPEQ(x, N*K) { E[x] = b[0][x]; }\n  return f;\n}\n\nvoid Far() {\n  if (S > N*K) {\n    Matrix A(N*K+1, N*K+1);\n    A[0][N*K] = A[N*K][N*K] = 1;\n    REP(i, N*K) { A[0][i] = p[K][i+1]; }\n    REP(i, N*K-1) { A[i+1][i] = 1; }\n    Matrix b(N*K+1);\n    b[0][N*K] = 1;\n    REP(i, N*K) { b[0][i] = E[i+1]; }\n    Matrix C = A.Pow(S-N*K);\n    Matrix d = C * b;\n    printf(\"%.12f\\n\", d[0][K-1]+EPS);\n  } else {\n    printf(\"%.12f\\n\", E[S]+EPS);\n  }\n}\n\nint main() {\n  scanf(\"%d%d%d\", &S, &N, &K);\n  S = abs(S);\n\n  if (N == 1) {\n    if (S % K == 0) { printf(\"%d\\n\", S / K); }\n    else { puts(\"-1\"); }\n    return 0;\n  }\n\n  p[0][0] = 1;\n  FOREQ(k, 1, K) FOREQ(d, 1, N*K) FOREQ(n, 1, N) {\n    if (d >= n) { p[k][d] += p[k-1][d-n] / N; }\n  }\n\n  if (Near()) { Far(); }\n  else { puts(\"-1\"); }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\n\nlong double pro[11][200];\n\ntypedef vector<vector<long double> > mat;\n\n\nmat matmul(const mat& a,const mat& b){\n  ll n = SZ(a);\n  mat c(n,vector<long double>(n));\n\n  rep(i,n)rep(j,n)rep(k,n)\n    c[i][j] += a[i][k] * b[k][j];\n  return c;\n}\n\nmat powmat(mat a, ll p){\n  ll n=SZ(a);\n  mat ret(n,vector<long double>(n));\n  rep(i,n) ret[i][i] = 1;\n  while(p){\n    if(p&1) ret=matmul(ret,a);\n    a=matmul(a,a);\n    p >>= 1;\n  }\n  return ret;\n}\n\nvector<long double> gausu(mat A, vector<long double> b){\n\n  ll n=SZ(A);\n  mat B(n, vector<long double>(n+1));\n  rep(i,n)rep(j,n) B[i][j] = A[i][j];\n\n  rep(i,n) B[i][n] = b[i];\n\n  rep(i,n){\n    ll pivot = i;\n    for(ll j=i;j<n;++j)\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\n    swap(B[i], B[pivot]);\n\n    if(abs(B[i][i]) < EPS) assert(false);\n\n    for(ll j=i+1;j<=n;++j) B[i][j] /= B[i][i];\n    rep(j,n)\n      if(i!=j)\n        for(ll k=i+1;k<=n;++k)\n          B[j][k] -= B[j][i] * B[i][k];\n  }\n\n  vector<long double> x(n);\n  rep(i,n) x[i] = B[i][n];\n  return x;\n\n  vector<long double> ret(n);\n\n  rep(i,n){\n    long double maxv=abs(A[i][i]);\n    ll idx = i;\n    for(ll j=i+1;j<n;++j){\n      if(maxv<abs(A[j][i])){\n        maxv = abs(A[j][i]);\n        idx = j;\n      }\n    }\n    swap(A[i],A[idx]);\n    swap(b[i],b[idx]);\n    maxv = A[i][i];\n    for(ll j=0;j<n;++j){\n      if(j==i) continue;\n      long double mul = A[j][i]/maxv;\n      b[j] -= mul * b[i];      \n      for(ll k=i;k<n;++k)\n        A[j][k] -= mul * A[i][k];\n    }\n  }\n  rep(i,n) ret[i] = b[i]/A[i][i];\n  return ret;\n}\n\nint main(){\n  ll s,n,k;\n  cin >> s >> n >> k;\n  if(s!=6 && n!=6 && k!=1 ||\n     s!=-100 && n!=7 && k!=5 ||\n     s!=756434182 && n!=9 && k!=10)\n    cerr << s << ' ' << n << ' ' << k << endl;\n\n  s=abs(s);\n  if(s==0){\n    cout << 0 << endl;\n    return 0;\n  }\n  if(n==1){\n    if(s%k) cout << -1 << endl;\n    else cout << s/k << endl;\n    return 0;\n  }\n\n  pro[0][0] = 1;\n  for(ll i=0;i<k;++i)\n    for(ll j=1;j<=n;++j)\n      for(ll idx=0;idx<=n*k;++idx)\n        pro[i+1][idx+j] += pro[i][idx]/n;\n  \n  mat E(n*k+1,vector<long double>(n*k+1));\n  vector<long double> eb(n*k+1,-1);\n  eb[0] = 0;\n\n  rep(x,n*k+1){\n    if(x==0){\n      E[0][0]=1;\n      continue;\n    }\n    E[x][x] -= 1;\n    rep(i,n*k){\n      ll idx=abs((x)-(i+1));\n      E[x][idx] += pro[k][i+1];\n    }\n  }\n  vector<long double> ex(gausu(E,eb));\n  \n  if(n*k>=s){\n    printf(\"%.30Lf\\n\",ex[s]);\n    return 0;\n  }\n\n  \n  mat A(n*k+1,vector<long double>(n*k+1));\n  rep(i,n*k) A[0][i] = pro[k][i+1];\n  rep(i,n*k-1) A[i+1][i] = 1;\n  A[0][n*k]=1;\n  A[n*k][n*k]=1;\n\n  vector<long double> b(n*k+1);\n  b[0] = b[n*k] = 1;\n\n  A=powmat(A,s-n*k);\n  \n  long double ans = 0;\n  ex[0] = 1;\n  rep(i,n*k+1)\n    ans += ex[n*k-i] * A[0][i];\n  printf(\"%.30Lf\\n\",ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\ntypedef vector<long double> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat &A,const vec &b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i])<1e-8)return vec();\n    for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n      }\n    }\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  return x;\n}\n\t\nmat operator*(const mat &a,const mat &b){\n  mat r(a.size(),vec(b[0].size()));\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b[0].size();j++){\n      for(int k=0;k<a[0].size();k++){\n\tr[i][j]+=a[i][k]*b[k][j];\n      }\n    }\n  }\n  return r;\t  \n}\n\nmat pow(const mat &m,int n){\n  if(n==0){\n    mat e(m.size(),vec(m.size()));\n    for(int i=0;i<m.size();i++){\n      e[i][i]=1;\n    }\n    return e;\n  }else{\n    auto h=pow(m,n/2);\n    return (n%2)?h*h*m:h*h;\n  }\n}\n\nint main(){\n  int S,N,K;\n  cin>>S>>N>>K;\n  if(N==1){\n    S=abs(S);\n    if(S%K){\n      cout<<-1<<endl;\n    }else{\n      cout<<S/K<<endl;\n    }\n  }else{\n    long double p[12][123]={};\n    p[0][0]=1;\n    for(int i=0;i<K;i++){\n      for(int j=0;j<=100;j++){\n\tfor(int k=1;k<=N;k++){\n\t  p[i+1][j+k]+=p[i][j]/N;\n\t}\n      }\n    }\n    mat A(100,vec(100));\n    A[0][0]=1;\n    vec b(100);\n    for(int i=1;i<100;i++){\n      for(int j=1;j<=100;j++){\n\tA[i][abs(i-j)]+=p[K][j];\n      }\n      A[i][i]--;\n      b[i]=-1;\n    }\n    auto r=gauss_jordan(A,b);\n    if(r.empty()){\n      cout<<-1<<endl;\n    }else{\n      mat M(101,vec(101));\n      for(int i=0;i<100;i++){\n\tM[i][i+1]=1;\n\tM[99][99-i]=p[K][i+1];\n      }\n      M[100][100]=1;\n      auto MP=pow(M,abs(S));\n      long double ans=0;\n      for(int i=0;i<100;i++){\n\tans+=MP[0][i]*r[i];\n      }\n      cout.precision(9);\n      cout<<fixed<<ans+MP[0][100]<<endl;\n    }\n  }\n}\n\n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nnamespace ProconLib{\n    \n    template<typename T>\n    struct Detail{\n        static constexpr T EPS = T(1e-9);\n        static bool isZero(T v){\n            return abs(v)<=EPS;\n        }\n    };\n\n    template<typename T>\n    class Vector{\n        int N;\n        std::vector<T> dat;\n        public:\n        Vector(int n):N(n),dat(n){}\n        Vector(int n,T x):N(n),dat(n,x){}\n        Vector(std::vector<T> vec):N(vec.size()),dat(vec){}\n        Vector(const std::vector<T>& vec):N(vec.size()),dat(vec){}\n        Vector(const Vector& vec){dat=vec.dat;}\n        int size(){return N;}\n        T& operator[](int pos){return dat[pos];};\n        const T& operator[](int pos) const{return dat[pos];};\n        T& at(int pos){return dat.at(pos);}\n        const T& at(int pos) const {return dat.at(pos);}\n    };\n    \n    template<typename T>\n    class Matrix{\n        int r,c;\n        std::vector<Vector<T>> dat;\n        public:\n        Matrix(int r,int c):r(r),c(c),dat(r,Vector<T>(c)){}\n        Matrix(int r,int c,T x):r(r),c(c),dat(r,Vector<T>(c,x)){}\n\n        Vector<T>& operator[](int pos){return dat[pos];};\n        const Vector<T>& operator[](int pos) const{return dat[pos];};\n        Vector<T>& at(int pos){return dat.at(pos);}\n        const Vector<T>& at(int pos) const {return dat.at(pos);}\n        int rowSize() const {return r;}\n        int colSize() const {return c;}\n    };\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs);\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs);\n    template<typename T>\n    Matrix<T> Identity(int n);\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k);\n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat);\n    template<typename T>\n    int rank(const Matrix<T>& mat);\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat);\n    \n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]+rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& lhs,const Matrix<T>& rhs){\n        assert(lhs.rowSize()==rhs.rowSize() && lhs.colSize()==rhs.colSize());\n        int r=lhs.rowSize(),c=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                res[i][j]=lhs[i]-rhs[i];\n            }\n        }\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator+(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    template<typename T>\n    Matrix<T> operator-(const Matrix<T>& mat){\n        int r=mat.rowSize(),c=mat.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++)for(int j=0;j<c;j++) res[i][j]=-mat[i][j];\n        return res;\n    }\n    \n    template<typename T>\n    Matrix<T> operator*(const Matrix<T>& lhs,const Matrix<T> &rhs){\n        assert(lhs.colSize()==rhs.rowSize());\n        int r=lhs.rowSize(),c=rhs.colSize(),l=lhs.colSize();\n        Matrix<T> res(r,c);\n        for(int i=0;i<r;i++){\n            for(int k=0;k<l;k++){\n                for(int j=0;j<c;j++){\n                    res[i][j]+=lhs[i][k]*rhs[k][j];\n                }\n            }\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> Identity(int n){\n        assert(n>=0);\n        Matrix<T> res(n,n);\n        for(int i=0;i<n;i++){\n            res[i][i]=1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    Matrix<T> pow(const Matrix<T>& mat,int k){\n        assert(mat.rowSize()==mat.colSize());\n        Matrix<T> x=mat;\n        Matrix<T> res=Identity<T>(mat.rowSize());\n        while(k){\n            if(k&1) res=res*x;\n            x=x*x;\n            k>>=1;\n        }\n        return res;\n    }\n    \n    template<typename T,typename Detail=Detail<T>>\n    Matrix<T> gaussianElimination(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        int row=0;\n        for(int j=0;j<n;j++){\n            if(row==m) break;\n            int tar=-1;\n            T v=Detail::EPS;\n            for(int i=row;i<m;i++){\n                if(!Detail::isZero(mat[i][j]) && abs(v)<abs(mat[i][j])){\n                    tar=i;\n                    v=mat[i][j];\n                }\n            }\n            if(tar==-1) continue;\n            if(row!=tar){ \n                auto tmp=mat[row];\n                mat[row]=mat[tar];\n                mat[tar]=tmp;\n            }\n            for(int i=row+1;i<m;i++){\n                if(!Detail::isZero(mat[i][j])){\n                    T r=mat[i][j]/mat[row][j];\n                    for(int k=j;k<n;k++){\n                        mat[i][k]-=r*mat[row][k];\n                    }\n                }\n            }\n            row++;\n        }\n        return mat;\n    }\n\n    template<typename T,typename Detail=Detail<T>>\n    int rank(const Matrix<T>& mat){\n        auto tmp=gaussialElimination(mat);\n        int m=tmp.rowSize(),n=tmp.colSize();\n        int i=0,j=0;\n        while(i<m && j<n){\n            if(Detail::isZero(tmp[i][j])) j++;\n            else i++,j++;\n        }\n        return i;\n    }\n\n    template<typename T>\n    Matrix<T> inv(const Matrix<T>& mat){\n        assert(mat.rowSize()==mat.colSize());\n        int n=mat.rowSize();\n        Matrix<T> tmp(n,2*n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                tmp[i][j]=mat[i][j];\n                tmp[i][j+n]=0;\n            }\n            tmp[i][i+n]=1;\n        }\n        mat=gaussianElimination(mat);\n        Matrix<T> res(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                res[i][j]=mat[i][j+n]/=mat[i][i];\n            }\n        }\n        return res;\n    }\n \n    template<typename T>\n    void debug(Matrix<T> mat){\n        int m=mat.rowSize(),n=mat.colSize();\n        std::cerr<<\"###Matrix_Debug###\"<<std::endl;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                std::cerr<<mat[i][j]<<\" \";\n            }\n            std::cerr<<std::endl;\n        }\n    }\n}\n\nusing namespace ProconLib;\n\nint main(){\n    int s,n,k;\n    cin>>s>>n>>k;\n    if(n==1 && s%k!=0){\n        cout<<-1<<endl;\n        return 0;\n    }\n    int sz=n*k+1;\n    \n    vector<vector<double>> dp(k+1,vector<double>(sz));\n    dp[0][0]=1;\n    for(int i=0;i<k;i++){\n        for(int j=0;j<sz;j++){\n            for(int k=1;k<=n;k++){\n                if(j+k<sz) dp[i+1][j+k]+=dp[i][j]/n;\n            }\n        }\n    }\n    \n    Matrix<double> B(sz,sz+1);\n    {\n        B[0][0]=1;\n        B[0][sz]=0;\n        for(int i=1;i<sz;i++){\n            B[i][i]=-1;\n            for(int j=0;j<sz;j++){\n                // i to j\n                int d=i-j;\n                if(0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n                d=i+j;\n                if(j!=0 && 0<=d && d<sz){\n                    B[i][j]+=dp[k][d];\n                    B[i][sz]-=dp[k][d];\n                }\n            }\n        }\n    }\n    B=gaussianElimination(B);\n    Vector<double> vec(sz+1);\n    for(int i=sz-1;i>=0;i--){\n        for(int j=0;j<i;j++){\n            B[j][sz]-=B[j][i]/B[i][i]*B[i][sz];\n            B[j][i]=0;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        vec[sz-i-1]=B[i][sz]/B[i][i];\n    }\n    vec[sz]=1;\n\n    Matrix<double> A(sz+1,sz+1);\n    for(int i=1;i<sz;i++){\n        A[i][i-1]=1;\n    }\n    A[sz][sz]=1;\n    for(int i=0;i<sz;i++){\n        int d=i+1;\n        if(d<sz) A[0][i]=dp[k][d];\n        if(d<sz) A[0][sz]+=dp[k][d];\n    }\n    A=pow(A,abs(s));\n    double res=0;\n    for(int i=0;i<=sz;i++){\n        res+=A[sz-1][i]*vec[i];\n    }\n    cout<<fixed<<setprecision(10);\n    cout<<res<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define Z (128)\n\nvoid mul(double (*a)[Z], const double (*b)[Z]) {\n    static double t[Z][Z];\n    memset(t, 0, sizeof(t));\n    rep(k, Z) rep(i, Z) rep(j, Z) t[i][j] += a[i][k]*b[k][j];\n    memcpy(a, t, sizeof(t));\n}\n\nvoid pow(double (*a)[Z], int x) {\n    static double p[Z][Z];\n    memcpy(p, a, sizeof(p));\n    rep(i, Z) rep(j, Z) a[i][j] = i==j ? 1.0 : 0.0;\n    rep(b, 32) {\n        if(x&(1<<b)) mul(a, p);\n        mul(p, p);\n    }\n}\n\nvoid eqsolve(int n, double (*a)[Z]) {\n    rep(k, n) {\n        double mx = -1;\n        int ix = -1;\n        for(int i=k; i<n; i++) if(mx<fabs(a[i][k])) mx=fabs(a[i][k]), ix=i;\n        if(k!=ix) rep(i, n+1) swap(a[k][i], a[ix][i]);\n        const double p = a[k][k];\n        for(int i=k; i<=n; i++) a[k][i] /= p;\n        rep(i, n) if(i!=k) {\n            const double d = a[i][k];\n            for(int j=k; j<=n; j++) a[i][j] -= d*a[k][j];\n        }\n    }\n}\n\nint S, N, K;\ndouble p[Z][Z], eqs[Z][Z], mat[Z][Z];\n\nint main() {\n    scanf(\"%d%d%d\", &S, &N, &K);\n    S = abs(S);\n    p[0][0] = 1.0;\n    const int M = N*K+1;\n    rep(i, K) rep(j, M) rep(k, N) p[i+1][j+k+1] += p[i][j]/N;\n    eqs[0][0] = 1;\n    for(int k=1; k<M; k++) {\n        eqs[k][k] = 1;\n        rep(j, M) eqs[k][abs(k-j)] -= p[K][j];\n        eqs[k][M] = -1;\n    }\n    eqsolve(M, eqs);\n    if(S<M) printf(\"%.9f\\n\", fabs(eqs[S][M]));\n    else {\n        rep(i, M) mat[0][i] = p[K][i+1];\n        mat[0][M] = 1;\n        rep(i, M-1) mat[i+1][i] = 1;\n        mat[M][M] = 1;\n        pow(mat, S-M+1);\n        double ans = 0;\n        rep(i, M) ans += mat[0][i]*fabs(eqs[M-1-i][M]);\n        ans += mat[0][M];\n        printf(\"%.9f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\nconst double EPS=1e-8;\ntypedef vector<double>vec;\ntypedef vector<vec>mat;\ninline double ABS(double a){return max(a,-a);}\nvec gauss_jordan(const mat &A,const vec &b){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)B[i][j]=A[i][j];\n\tfor(int i=0;i<n;i++)B[i][n]=b[i];\n\tfor(int i=0;i<n;i++){\n\t\tint pivot=i;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(ABS(B[j][i])>ABS(B[pivot][i]))pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\t\tif(ABS(B[i][i])<EPS)return vec();\n\t\tfor(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=n;k++)B[j][k]-=B[j][i]*B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tvec x(n);\n\tfor(int i=0;i<n;i++)x[i]=B[i][n];\n\treturn x;\n}\ndouble p[12][120];\ndouble dp[110000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\n\tif(a<0)a=-a;\n\tif(b==1){\n\t\tif(a%c!=0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\ta/=c;c=1;\n\t\t}\n\t}\n\tp[0][0]=1;\n\tfor(int i=0;i<c;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tfor(int k=1;k<=b;k++){\n\t\t\t\tp[i+1][j+k]+=p[i][j]/b;\n\t\t\t}\n\t\t}\n\t}\n\tint n=b*c;\n\tmat A(n,vec(n));\n\tvec B(n);\n\tfor(int i=0;i<n;i++){\n\t\tA[i][i]=1;\n\t\t\n\t\tif(i==0)continue;\n\t\tB[i]=1;\n\t\tfor(int j=c;j<=b*c;j++){\n\t\t\tint to=i-j;\n\t\t\tif(to<0)to=-to;\n\t\t\tA[i][to]-=p[c][j];\n\t\t}\n\t}\n\tvec x=gauss_jordan(A,B);\n\tfor(int i=0;i<n;i++)dp[i]=x[i];\n\tfor(int i=n;i<=100000;i++){\n\t\tdp[i]=1;\n\t\tfor(int j=c;j<=b*c;j++){\n\t\t\tdp[i]+=dp[i-j]*p[c][j];\n\t\t}\n\t}\n\tif(a<=100000)printf(\"%.12f\\n\",dp[a]);\n\telse{\n\t\tdouble M=(c+b*c)*0.5;\n\t\tprintf(\"%.12f\\n\",dp[100000]+(a-100000)/M);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\nconst int N_MAX=100;\nbool Gauss_Jordan(int n,const double A[N_MAX][N_MAX],const double *b,double *x){\n\tstatic double B[N_MAX][N_MAX+1];\n\trep(i,n){\n\t\trep(j,n) B[i][j]=A[i][j];\n\t\tB[i][n]=b[i];\n\t}\n\n\trep(i,n){\n\t\tint piv=i;\n\t\tfor(int j=i;j<n;j++) if(abs(B[j][i])>abs(B[piv][i])) piv=j;\n\t\trep(j,n+1) swap(B[i][j],B[piv][j]);\n\n\t\tif(abs(B[i][i])<EPS) return false;\n\n\t\tfor(int j=i+1;j<=n;j++) B[i][j]/=B[i][i];\n\t\trep(j,n) if(i!=j) for(int k=i+1;k<=n;k++) B[j][k]-=B[j][i]*B[i][k];\n\t}\n\n\trep(i,n) x[i]=B[i][n];\n\treturn true;\n}\n\nint main(){\n\tint s,n,k; scanf(\"%d%d%d\",&s,&n,&k);\n\ts=abs(s);\n\n\tdouble p[101]={1}; // p[x] := ³¢±ëÌÚÌaª x ÉÈém¦\n\trep(i,k){\n\t\tdouble q[101]={};\n\t\tfor(int j=1;j<=n;j++) rep(x,101-j) q[x+j]+=p[x]/n;\n\t\tcopy(q,q+101,p);\n\t}\n\n\t// ¬³¢Æ±ëÍA§ûö®ÉµÄð­\n\tstatic double A[N_MAX][N_MAX];\n\tdouble b[N_MAX],E_small[N_MAX];\n\tA[0][0]=1;\n\tfor(int i=1;i<n*k;i++){\n\t\tA[i][i]=1;\n\t\trep(j,n*k+1) A[i][abs(i-j)]-=p[j];\n\t\tb[i]=1;\n\t}\n\tGauss_Jordan(n*k,A,b,E_small);\n\n\tif(s<n*k){\n\t\tprintf(\"%.15f\\n\",E_small[s]);\n\t\treturn 0;\n\t}\n\n\t// å«¢Æ±ëÍµËÔèªÈ¢ÌÅAsñ×«æÅêCÉißé\n\tstatic double P[101][101]; // JÚsñ\n\trep(i,n*k) P[0][i]=p[i+1];\n\tP[0][n*k]=P[n*k][n*k]=1;\n\trep(i,n*k-1) P[i+1][i]=1;\n\n\tdouble v[101]; // úxNg v0[i]:=(Êu nk-i-1 É¨¯éúÒl)\n\trep(i,n*k) v[i]=E_small[n*k-i-1];\n\tv[n*k]=1;\n\n\t// P^(s-nk+1)*v0 ÌvZ\n\trep(t,30){\n\t\tdouble v2[101]={};\n\t\tif((s-n*k+1)&(1<<t)){\n\t\t\trep(i,n*k+1) rep(j,n*k+1) v2[i]+=P[i][j]*v[j];\n\t\t\tcopy(v2,v2+n*k+1,v);\n\t\t}\n\n\t\t// P <- P^2\n\t\tdouble P2[101][101]={};\n\t\trep(i,n*k+1) rep(j,n*k+1) rep(l,n*k+1) P2[i][j]+=P[i][l]*P[l][j];\n\t\trep(i,n*k+1) rep(j,n*k+1) P[i][j]=P2[i][j];\n\t}\n\n\tprintf(\"%.15f\\n\",v[0]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\ntypedef ld Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nMatrix transpose(const Matrix &A) {\n\tconst int n = A[0].size(), m = A.size();\n\tMatrix res(n, Array(m, 0));\n\tREP(i, n)REP(j, m) res[i][j] = A[j][i];\n\treturn res;\n}\n\nData inner_product_ex(const Array& a, const Array& b, const Matrix& m) {\n\tArray b_prime = m*b;\n\treturn inner_product(begin(a), end(a), begin(b_prime), Data(0));\n}\n\nData norm(const Array &a) {\n\treturn inner_product(begin(a), end(a), begin(a), Data(0));\n}\n\nData norm(const Array &a, const Matrix &M) {\n\treturn inner_product_ex(a, a, M);\n}\n\nint rankMat(Matrix A) {\n\tconst int n = A.size(), m = A[0].size();\n\tint r = 0;\n\tfor (int i = 0; r < n && i < m; ++i) {\n\t\tint pivot = r;\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[r]);\n\t\tif (is_zero(A[r][i])) continue;\n\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\tA[r][k] = A[r][k] / A[r][i];\n\t\tfor (int j = r + 1; j < n; ++j)\n\t\t\tfor (int k = m - 1; k >= i; --k)\n\t\t\t\tA[j][k] = fma(-A[r][k], A[j][i], A[j][k]);\n\t\t++r;\n\t}\n\treturn r;\n}\n\nData det(Matrix A) {\n\tconst int n = A.size();\n\tData D = Data(1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pivot = i;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tif (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n\t\tswap(A[pivot], A[i]);\n\t\tD = D * A[i][i] * Data(i != pivot ? -1 : 1);\n\t\tif (is_zero(A[i][i])) break;\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tfor (int k = n - 1; k >= i; --k)\n\t\t\t\tA[j][k] = A[j][k] - A[i][k] * A[j][i] / A[i][i];\n\t}\n\treturn D;\n}\n\nArray gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tif (abs(B[i][i]) < EPS) return Array();\n\t\tFOR(j, i + 1, n + 1) B[i][j] /= B[i][i];\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\treturn x;\n}\n\nint mx;\nld dp[111111];\nld solve(int s, vector<ld>& exp)\n{\n\tif (s == 0) return 0;\n\tif (dp[s] >= 0) return dp[s];\n\tld res = 1;\n\tFOR(i, 1, mx + 1)\n\t{\n\t\tres += solve(abs(s - i), exp) * exp[i];\n\t}\n\treturn dp[s] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tREP(i, 111111) dp[i] = -1;\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tld adv[11][111];\n\tMS(adv, 0);\n\tadv[0][0] = 1.0;\n\tREP(i, k)\n\t{\n\t\tREP(j, 100)\n\t\t{\n\t\t\tFOR(dice, 1, n + 1)\n\t\t\t{\n\t\t\t\tadv[i + 1][j + dice] += adv[i][j] / n;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ld> v;\n\tREP(i, 101) v.push_back(adv[k][i]);\n\tld exp = 0;\n\tREP(i, 111) exp += i*adv[k][i];\n\tld ans = 0;\n\tif (s > 100000)\n\t{\n\t\tans += (s - 100000) / exp;\n\t\ts = 100000;\n\t}\n\tmx = n*k;\n\tMatrix A(mx, Array(mx));\n\tArray b(mx);\n\tA[0][0] = 1;\n\tFOR(i, 1, mx)\n\t{\n\t\tFOR(j, 1, mx+1)\n\t\t{\n\t\t\tA[i][abs(i-j)] += v[j];\n\t\t}\n\t}\n\tFOR(i, 1, mx)\n\t{\n\t\tA[i][i] -= 1;\n\t\tb[i] = -1;\n\t}\n\tArray x = gauss_jordan(A, b);\n\tREP(i, mx) dp[i] = x[i];\n\tcout << solve(s, v) + ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <climits>\n#include <cfloat>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\ntemplate<class T>\nvector<vector<T> > matrixProduct(const vector<vector<T> >& x, const vector<vector<T> >& y)\n{\n\tint a = x.size();\n\tint b = x[0].size();\n\tint c = y[0].size();\n\tvector<vector<T> > z(a, vector<T>(c, 0));\n\tfor(int i=0; i<a; ++i){\n\t\tfor(int j=0; j<c; ++j){\n\t\t\tfor(int k=0; k<b; ++k){\n\t\t\t\tz[i][j] += x[i][k] * y[k][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\n\ntemplate <class T>\nvector<vector<T> > matrixPower(const vector<vector<T> >& x, int k)\n{\n\tint n = x.size();\n\tvector<vector<T> > y(n, vector<T>(n, 0));\n\tfor(int i=0; i<n; ++i)\n\t\ty[i][i] = 1;\n\n\tvector<vector<T> > z = x;\n\twhile(k > 0){\n\t\tif(k & 1)\n\t\t\ty = matrixProduct(y, z);\n\t\tz = matrixProduct(z, z);\n\t\tk >>= 1;\n\t}\n\treturn y;\n}\n\nvoid linearSystem(vector<vector<double> >& mat, vector<double>& x)\n{\n\tint n = mat.size();\n\tx.resize(n);\n\n\tfor(int i=0; i<n; ++i){\n\t\tfor(int j=n; j>=i; --j)\n\t\t\tmat[i][j] /= mat[i][i];\n\t\tfor(int j=0; j<n; ++j){\n\t\t\tif(j == i)\n\t\t\t\tcontinue;\n\t\t\tfor(int k=n; k>=i; --k){\n\t\t\t\tmat[j][k] -= mat[i][k] * mat[j][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0; i<n; ++i)\n\t\tx[i] = mat[i][n];\n}\n\nint main()\n{\n\tint s, n, k;\n\tcin >> s >> n >> k;\n\ts = abs(s);\n\tif(n == 1){\n\t\tif(s % k == 0)\n\t\t\tcout << (double)(s / k) << endl;\n\t\telse\n\t\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tvector<double> prob(n*k+1, 0.0);\n\tprob[0] = 1.0;\n\tfor(int i=0; i<k; ++i){\n\t\tvector<double> nextProb(n*k+1, 0.0);\n\t\tfor(int j=0; j<=n*(k-1); ++j){\n\t\t\tfor(int l=1; l<=n; ++l){\n\t\t\t\tnextProb[j+l] += prob[j] / n;\n\t\t\t}\n\t\t}\n\t\tprob.swap(nextProb);\n\t}\n\n\tvector<vector<double> > mat(n*k*2-1, vector<double>(n*k*2, 0.0));\n\tfor(int i=0; i<n*k*2-1; ++i){\n\t\tmat[i][i] = 1.0;\n\t\tif(i == n*k-1){\n\t\t\tcontinue;\n\t\t}\n\t\tmat[i][n*k*2-1] = 1.0;\n\t\tif(i < n*k-1){\n\t\t\tfor(int j=1; j<=n*k; ++j){\n\t\t\t\tmat[i][i+j] = -prob[j];\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=1; j<=n*k; ++j){\n\t\t\t\tmat[i][i-j] = -prob[j];\n\t\t\t}\n\t\t}\n\t}\n\tvector<double> x;\n\tlinearSystem(mat, x);\n\tx = vector<double>(x.rbegin(), x.rbegin()+n*k);\n\tif(s < n*k){\n\t\tprintf(\"%.10f\\n\", x[n*k-1-s]);\n\t\treturn 0;\n\t}\n\n\tvector<vector<double> > y(n*k+1, vector<double>(n*k+1, 0.0));\n\ty[0][n*k] = 1.0;\n\ty[n*k][n*k] = 1.0;\n\tfor(int i=0; i<n*k-1; ++i)\n\t\ty[i+1][i] = 1.0;\n\tfor(int i=0; i<n*k; ++i)\n\t\ty[0][i] = prob[i+1];\n\ty = matrixPower(y, s-n*k+1);\n\n\tdouble ret = y[0][n*k];\n\tfor(int i=0; i<n*k; ++i)\n\t\tret += y[0][i] * x[i];\n\tprintf(\"%.10f\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "fact = [1] + (1..10).map {|x| (1..x).inject(:*)}\nrequire 'matrix'\n\ns, n, k = gets.split.map(&:to_i)\ns = -s if s < 0\n\nif s == 0\n\tputs 0\n\texit\nend\n\nif n == 1\n    puts s % k == 0 ? s / k : -1\n    exit\nend\n\ni = 0\ntotal = 0\na = (0..n*k).map { (0..n*k).map { 0 } }\n(1..n).to_a.repeated_combination(k).each do |comb|\n\tstep = comb.inject(:+)\n\tnum = fact[k] / comb.group_by{|x| x}.values.map{|a| fact[a.size]}.inject(:*)\n\t(1..n*k).each do |i|\n\t\ta[i][(i-step).abs] += num\n\tend\n\ttotal += num\nend\n\na.map!{|row| row.map {|x| x.to_f / total}}\na[0][0] = 1.0\nm = Matrix[*a]\nabsorb = (Matrix.I(n*k) - m.minor(1..n*k, 1..n*k)).inv * Matrix[*[[1] * (n*k)].transpose].column(0)\n\nif s <= n * k\n\tputs absorb[s-1].to_f\n\texit\nend\n\nabsorb = Vector[*(absorb.to_a + [1])]\n\nb = (0..n*k).map { (0..n*k).map { 0 } } \n(0..n*k-1).each do |i|\n\tb[i][i+1] = 1\nend\nb[-2] = a[-1]\nb[-2][-1] = 1\nb[-1][-1] = 1\n\np ((Matrix[*b] ** (s-n*k)) * absorb).to_a[-2].to_f"
  },
  {
    "language": "Ruby",
    "code": "fact = [1] + (1..10).map {|x| (1..x).inject(:*)}\nrequire 'matrix'\n\ns, n, k = gets.split.map(&:to_i)\ns = -s if s < 0\n\nif s == 0\n\tputs 0\n\texit\nend\n\nif n == 1\n\tputs k == s ? 1 : 0\nend\n\ni = 0\ntotal = 0\na = (0..n*k).map { (0..n*k).map { 0 } }\n(1..n).to_a.repeated_combination(k).each do |comb|\n\tstep = comb.inject(:+)\n\tnum = fact[k] / comb.group_by{|x| x}.values.map{|a| fact[a.size]}.inject(:*)\n\t(1..n*k).each do |i|\n\t\ta[i][(i-step).abs] += num\n\tend\n\ttotal += num\nend\n\na.map!{|row| row.map {|x| x.to_f / total}}\na[0][0] = 1.0\nm = Matrix[*a]\nabsorb = (Matrix.I(n*k) - m.minor(1..n*k, 1..n*k)).inv * Matrix[*[[1] * (n*k)].transpose].column(0)\n\nif s <= n * k\n\tputs absorb[s-1].to_f\n\texit\nend\n\nabsorb = Vector[*(absorb.to_a + [1])]\n\nb = (0..n*k).map { (0..n*k).map { 0 } } \n(0..n*k-1).each do |i|\n\tb[i][i+1] = 1\nend\nb[-2] = a[-1]\nb[-2][-1] = 1\nb[-1][-1] = 1\n\np ((Matrix[*b] ** (s-n*k)) * absorb).to_a[-2].to_f"
  },
  {
    "language": "Ruby",
    "code": "fact = [1] + (1..10).map {|x| (1..x).inject(:*)}\nrequire 'matrix'\n\ns, n, k = gets.split.map(&:to_i)\ns = -s if s < 0\n\nif s == 0\n\tputs 0\n\texit\nend\n\nif n == 1\n\tputs s % k == 0 ? s / k : -1\n\texit\nend\n\ni = 0\ntotal = 0\na = (0..n*k).map { (0..n*k).map { 0 } }\n(1..n).to_a.repeated_combination(k).each do |comb|\n\tstep = comb.inject(:+)\n\tnum = fact[k] / comb.group_by{|x| x}.values.map{|a| fact[a.size]}.inject(:*)\n\t(1..n*k).each do |i|\n\t\ta[i][(i-step).abs] += num\n\tend\n\ttotal += num\nend\n\na.map!{|row| row.map {|x| x.to_f / total}}\na[0][0] = 1.0\nm = Matrix[*a]\nabsorb = (Matrix.I(n*k) - m.minor(1..n*k, 1..n*k)).inv * Matrix[*[[1] * (n*k)].transpose].column(0)\n\nif s <= n * k\n\tputs absorb[s-1].to_f\n\texit\nend\n\nabsorb = Vector[*(absorb.to_a + [1])]\n\nb = (0..n*k).map { (0..n*k).map { 0 } } \n(0..n*k-1).each do |i|\n\tb[i][i+1] = 1\nend\nb[-2] = a[-1]\nb[-2][-1] = 1\nb[-1][-1] = 1\n\ndef exp(n, k, v)\n\tresult = v\t\n\tr = n\n\twhile k > 0\n\t\tresult = r * result if k & 1 == 1\n\t\tr *= r\t\t\n\t\tk >>= 1\n\tend\n\tresult\nend\n\np exp(Matrix[*b], (s-n*k), absorb).to_a[-2].to_f"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef mul(n, A, B, C):\n    for i in range(n):\n        for j in range(n):\n            C[i][j] = sum(A[i][k] * A[k][j] for k in range(n))\ndef fast_pow(n, MA, A, k):\n    R = [[0]*n for i in range(n)]\n    while k:\n        if k & 1:\n            A = [sum(e*a for e, a in zip(MA[i], A)) for i in range(n)]\n        mul(n, MA, MA, R)\n        MA, R = R, MA\n        k >>= 1\n    return A\n\ndef solve():\n    S, N, K = map(int, readline().split())\n    S = abs(S)\n    if S == 0:\n        write(\"0\\n\")\n        return\n    if N == 1:\n        if S % K:\n            write(\"-1\\n\")\n        else:\n            write(\"%.16f\\n\" % (S // K))\n        return\n    M = N*K\n    dp = [0]*(M+1)\n    dp[0] = 1\n    for t in range(K):\n        for i in range(N*K, -1, -1):\n            dp[i] = sum(dp[i-k] for k in range(1, N+1) if i >= k)\n    s = sum(dp)\n    mat = [[0]*(M+2) for i in range(M+1)]\n    mat[0][0] = 1\n    for i in range(1, M+1):\n        mi = mat[i]\n        for j in range(M+1):\n            mi[abs(i-j)] -= dp[j]\n        mi[i] += s\n        for j in range(M+1):\n            mi[j] /= s\n        mi[M+1] = 1\n    for i in range(M+1):\n        v = mat[i][i]\n        for j in range(M+2):\n            mat[i][j] /= v\n        for k in range(M+1):\n            if k == i:\n                continue\n            e = mat[k][i]\n            for j in range(M+2):\n                mat[k][j] -= e * mat[i][j]\n    C = [mat[i][M+1] for i in range(M, -1, -1)]\n    C[-1] = 1\n    if S <= M:\n        write(\"%.16f\\n\" % C[M-S])\n        return\n\n    mat2 = [[0]*(M+1) for i in range(M+1)]\n    for i in range(M):\n        mat2[0][i] = dp[i+1] / s\n    for i in range(M-1):\n        mat2[i+1][i] = 1\n    mat2[0][M] = mat2[M][M] = 1\n    C1 = fast_pow(M+1, mat2, C, S-M)\n    write(\"%.16f\\n\" % C1[0])\nsolve()\n"
  }
]